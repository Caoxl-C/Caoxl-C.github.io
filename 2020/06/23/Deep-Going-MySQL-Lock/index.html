<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>深入mysql锁 | Keep It Simple And Stupid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="MySQL锁共享锁排他锁行锁表锁">
  
  
  
  
  <meta name="description" content="高并发场景下锁机制是怎么保证数据的一致性的和事务隔离性的?">
<meta name="keywords" content="MySQL锁,共享锁,排他锁,行锁,表锁">
<meta property="og:type" content="article">
<meta property="og:title" content="深入MySQL锁">
<meta property="og:url" content="http://blog.caoxl.com/2020/06/23/Deep-Going-MySQL-Lock/index.html">
<meta property="og:site_name" content="Keep It Simple And Stupid">
<meta property="og:description" content="高并发场景下锁机制是怎么保证数据的一致性的和事务隔离性的?">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-06-23T07:26:48.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入MySQL锁">
<meta name="twitter:description" content="高并发场景下锁机制是怎么保证数据的一致性的和事务隔离性的?">
  
    <link rel="alternate" href="/atom.xml" title="Keep It Simple And Stupid" type="application/atom+xml">
  

  

  <link rel="icon" href="http://caoxl.com/imgs/we-min.jpg">
  <link rel="apple-touch-icon" href="/http://caoxl.com/imgs/we-min.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css">
  

  
  
  

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="http://caoxl.com/imgs/we-min.jpg">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Deep-Going-MySQL-Lock" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      深入MySQL锁
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/06/23/Deep-Going-MySQL-Lock/" class="article-date">
	  <time datetime="2020-06-23T03:16:11.000Z" itemprop="datePublished">2020-06-23</time>
	</a>

      
    <a class="article-category-link" href="/categories/必备技能/">必备技能</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>

    <div class="article-entry" itemprop="articleBody">
      
        
        
          <blockquote>
<p>高并发场景下锁机制是怎么保证数据的一致性的和事务隔离性的?</p>
</blockquote>
<a id="more"></a>
<h1 id="锁种类"><a href="#锁种类" class="headerlink" title="锁种类"></a>锁种类</h1><blockquote>
<ul>
<li>按照<strong>锁的粒度</strong>划分：<code>表锁</code>、<code>页锁</code>、<code>行锁</code>；</li>
<li>按照<strong>使用的方式</strong>划分：<code>共享锁</code>和<code>排它锁</code>；</li>
<li>按照<strong>思想</strong>划分：<code>乐观锁</code>和<code>悲观锁</code>。</li>
</ul>
</blockquote>
<h2 id="按锁的粒度划分"><a href="#按锁的粒度划分" class="headerlink" title="按锁的粒度划分"></a>按锁的粒度划分</h2><ul>
<li><code>「表锁」</code>是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。</li>
</ul>
<p>Mysql中<code>「MyISAM储存引擎就支持表锁」</code>，MyISAM的表锁模式有两种：<code>「表共享读锁」</code>和<code>「表独占写锁」</code>。</p>
<p>当一个线程获取到MyISAM表的读锁的时候，会阻塞其他用户对该表的写操作，但是不会阻塞其它用户对该用户的读操作。</p>
<p>相反的，当一个线程获取到MyISAM表的写锁的时候，就会阻塞其它用户的读写操作对其它的线程具有排它性。</p>
<ul>
<li><p><code>「页锁」</code>的粒度是介于行锁和表锁之间的一种锁，因为页锁是在BDB中支持的一种锁机制，也很少被人提及和使用，所以这里制作概述，不做详解。</p>
</li>
<li><p><code>「行锁」</code>是粒度最小的锁机制，行锁的加锁开销性能大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。</p>
</li>
</ul>
<p>行锁是InnoDB默认的支持的锁机制，MyISAM不支持行锁，这个也是InnoDB和MyISAM的区别之一。</p>
<h2 id="按锁的使用方式划分"><a href="#按锁的使用方式划分" class="headerlink" title="按锁的使用方式划分"></a>按锁的使用方式划分</h2><blockquote>
<p>行锁在使用的方式上可以划分为：「<code>共享读锁（S锁）</code>「和」<code>排它写锁（X锁）</code>」。</p>
</blockquote>
<p>当一个事务对Mysql中的一条数据行加上了<code>S锁</code>，当前事务不能修改该行数据只能执行度操作，其他事务只能对该行数据加S锁不能加X锁。</p>
<p>若是一个事务对一行数据加了<code>X锁</code>，该事物能够对该行数据执行读和写操作，其它事务不能对该行数据加任何的锁，既不能读也不能写。</p>
<h2 id="按锁的思想划分"><a href="#按锁的思想划分" class="headerlink" title="按锁的思想划分"></a>按锁的思想划分</h2><p>「悲观锁和乐观锁是在很多框架都存在的一种思想，不要狭义地认为它们是某一种框架的锁机制」。</p>
<p>数据库管理系统中为了控制并发，保证在多个事务执行时的数据一致性以及事务的隔离性，使用悲观锁和乐观锁来解决并发场景下的问题。</p>
<p>Mysql中「<strong>悲观锁的实现是基于Mysql自身的锁机制实现，而乐观锁需要程序员自己去实现的锁机制</strong>」，最常见的乐观锁实现就锁机制是「<strong>使用版本号实现</strong>」。</p>
<h1 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h1><p>MyISAM中默认支持的表级锁有两种：<strong>「共享读锁」</strong> 和 <strong>「独占写锁」</strong>。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。</p>
<p>Mysql中平时读写操作都是隐式的进行加锁和解锁操作，Mysql已经自动帮我们实现加锁和解锁操作了，若是想要测试锁机制，我们就要显示的自己控制锁机制。</p>
<p>Mysql中可以通过以下sql来显示的在事务中显式的进行加锁和解锁操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 显式的添加表级读锁</span><br><span class="line">LOCK TABLE 表名 READ</span><br><span class="line"></span><br><span class="line">// 显示的添加表级写锁</span><br><span class="line">LOCK TABLE 表名 WRITE</span><br><span class="line"></span><br><span class="line">// 显式的解锁（当一个事务commit的时候也会自动解锁）</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<p>下面我们就来测试一下MyISAM中的表级锁机制，首先创建一个测试表<code>employee</code> ，这里要指定存储引擎为MyISAM，并插入两条测试数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个测试表</span><br><span class="line">CREATE TABLE IF NOT EXISTS employee (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    name VARCHAR(40),</span><br><span class="line">    money INT</span><br><span class="line">)ENGINE MyISAM;</span><br><span class="line"></span><br><span class="line">-- 插入两条测试数据</span><br><span class="line">INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 8888);</span><br><span class="line">INSERT INTO employee(name, money) VALUES(&apos;lc&apos;, 9999);</span><br></pre></td></tr></table></figure>
<p>查看一下，表结果如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee;</span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  1 | caoxl |  8888 |</span><br><span class="line">|  2 | lc    |  9999 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<h2 id="MyISAM表级写锁"><a href="#MyISAM表级写锁" class="headerlink" title="MyISAM表级写锁"></a>MyISAM表级写锁</h2><ul>
<li><ol>
<li>与此同时再开启一个session窗口，然后在第一个窗口执行下面的sql，在session1中给表添加写锁：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; LOCK TABLE employee WRITE;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>可以在session2中进行查询或者插入、更新该表数据，可以发现都会处于等待状态，也就是session1锁住了整个表，导致session2只能等待：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee;</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="3">
<li>在session1中进行查询、插入、更新数据，都可以执行成功：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 插入</span><br><span class="line">MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;caolx&apos;, 1111);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">-- 更新</span><br><span class="line">MariaDB [test]&gt; UPDATE employee set name=&apos;caoxllc&apos; where id=1; </span><br><span class="line">Query OK, 1 row affected (0.14 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">-- 查询</span><br><span class="line">MariaDB [test]&gt; SELECT * FROM employee;</span><br><span class="line">+----+---------+-------+</span><br><span class="line">| id | name    | money |</span><br><span class="line">+----+---------+-------+</span><br><span class="line">|  1 | caoxllc |  8888 |</span><br><span class="line">|  2 | lc      |  9999 |</span><br><span class="line">|  3 | caolx   |  1111 |</span><br><span class="line">+----+---------+-------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p><strong>「总结：」</strong> 从上面的测试结果显示 <strong>「当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作」</strong>。</p>
<h2 id="MyISAM表级共享读锁"><a href="#MyISAM表级共享读锁" class="headerlink" title="MyISAM表级共享读锁"></a>MyISAM表级共享读锁</h2><ul>
<li><ol>
<li>接下来测试一下表级共享读锁，同样还是利用上面的测试数据，第一步还是在session1给表加读锁。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; LOCK TABLE employee read;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>然后在session1中尝试进行插入、更新数据，发现都会报错，只能查询数据。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 查询</span><br><span class="line">MariaDB [test]&gt; select * from employee;</span><br><span class="line">+----+---------+-------+</span><br><span class="line">| id | name    | money |</span><br><span class="line">+----+---------+-------+</span><br><span class="line">|  1 | caoxllc |  8888 |</span><br><span class="line">|  2 | lc      |  9999 |</span><br><span class="line">|  3 | caolx   |  1111 |</span><br><span class="line">+----+---------+-------+</span><br><span class="line">3 rows in set (7 min 12.28 sec)</span><br><span class="line">-- 插入</span><br><span class="line">MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;lxlc&apos;, 2222);</span><br><span class="line">ERROR 1099 (HY000): Table &apos;employee&apos; was locked with a READ lock and can&apos;t be updated</span><br><span class="line">-- 更新</span><br><span class="line">MariaDB [test]&gt; UPDATE employee set name=&apos;lxlc&apos; where id=1;</span><br><span class="line">ERROR 1099 (HY000): Table &apos;employee&apos; was locked with a READ lock and can&apos;t be updated</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="3">
<li>最后在session2中尝试进行插入、更新数据，程序都会进入等待状态，只能查询数据，直到session1解锁表session2才能插入、更新数据。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;lxlc&apos;, 2222);</span><br></pre></td></tr></table></figure>
<p><strong>「总结：」</strong> 从上面的测试结果显示 <strong>「当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁」</strong>。</p>
<h2 id="MyISAM表级锁竞争情况"><a href="#MyISAM表级锁竞争情况" class="headerlink" title="MyISAM表级锁竞争情况"></a>MyISAM表级锁竞争情况</h2><p>MyISAM存储引擎中，可以通过查询变量来查看并发场景锁的争夺情况，具体执行下面的sql语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; show status like &apos;table%&apos;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Table_locks_immediate | 37    |</span><br><span class="line">| Table_locks_waited    | 2     |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">2 rows in set (0.27 sec)</span><br></pre></td></tr></table></figure>
<p>主要是查看<code>table_locks_waited</code>和<code>table_locks_immediate</code>的值的大小分析锁的竞争情况。</p>
<ul>
<li><code>Table_locks_immediate</code>: 表示能够立即获得表级锁的锁请求次数；</li>
<li><code>Table_locks_waited</code>: 表示不能立即获取表级锁而需要等待的锁请求次数分析，<strong>「值越大竞争就越严重」</strong>。</li>
</ul>
<h2 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h2><p>通过上面的操作演示，详细的说明了表级共享锁和表级写锁的特点。但是在平时的执行sql的时候，这些 <strong>「解锁和释放锁都是Mysql底层隐式的执行的」</strong>。</p>
<p>上面的演示只是为了证明显式的执行事务的过程共享锁和表级写锁的加锁和解锁的特点，实际并不会这么做的。</p>
<p>在我们平时执行select语句的时候就会隐式的加读锁，执行增、删、改的操作时就会隐式的执行加写锁。<br>MyISAM存储引擎中，虽然读写操作是串行化的，但是它也支持并发插入，这个需要设置内部变量<code>concurrent_insert</code>的值。</p>
<p>它的值有三个值<code>0</code>、<code>1</code>、<code>2</code>。可以通过以下的sql查看<code>concurrent_insert</code>的默认值为 <strong>「AUTO(或者1)」</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; show variables like &quot;%concurrent_insert&quot;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| concurrent_insert | AUTO  |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">1 row in set (0.25 sec)</span><br></pre></td></tr></table></figure>
<p><code>concurrent_insert</code>的值为:</p>
<ul>
<li><code>NEVER (or 0)</code>表示不支持比并发插入；</li>
<li><code>AUTO(或者1）</code>表示在MyISAM表中没有被删除的行，运行另一个线程从表尾插入数据；</li>
<li><code>ALWAYS (or 2)</code>表示不管是否有删除的行，都允许在表尾插入数据。</li>
</ul>
<h2 id="锁调度"><a href="#锁调度" class="headerlink" title="锁调度"></a>锁调度</h2><p>MyISAM存储引擎中，<strong>「假如同时一个读请求，一个写请求过来的话，它会优先处理写请求」</strong>，因为MyISAM存储引擎中认为<strong>写请求比读请求重要</strong>。</p>
<p>这样就会导致，<strong>「假如大量的读写请求过来，就会导致读请求长时间的等待，或者”线程饿死”，因此MyISAM不适合运用于大量读写操作的场景」</strong>，这样会导致长时间读取不到用户数据，用户体验感极差。</p>
<p>当然可以通过设置<code>low-priority-updates</code>参数，设置请求链接的优先级，使得Mysql优先处理读请求。</p>
<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><blockquote>
<p>InnoDB和MyISAM不同的是，<strong>InnoDB支持「行锁」和「事务」</strong></p>
</blockquote>
<p>InnoDB中除了有<code>「表锁」</code>和<code>「行级锁」</code>的概念，还有<code>Gap Lock（间隙锁）</code>、<code>Next-key Lock锁</code>，<strong>「间隙锁主要用于范围查询的时候，锁住查询的范围，并且间隙锁也是解决幻读的方案」</strong>。</p>
<p>InnoDB中的行级锁是 <strong>「对索引加的锁，在不通过索引查询数据的时候，InnoDB就会使用表锁」</strong>。</p>
<p><strong>「但是通过索引查询的时候是否使用索引，还要看Mysql的执行计划」</strong>，Mysql的优化器会判断是一条sql执行的最佳策略。</p>
<p>若是Mysql觉得执行索引查询还不如全表扫描速度快，那么Mysql就会使用全表扫描来查询，这是即使sql语句中使用了索引，最后还是执行为全表扫描，加的是表锁。</p>
<h2 id="InnoDB行锁和表锁"><a href="#InnoDB行锁和表锁" class="headerlink" title="InnoDB行锁和表锁"></a>InnoDB行锁和表锁</h2><p>InnoDB的行锁也是分为行级 <strong>「共享读锁（S锁）「和」排它写锁（X锁）」</strong>，原理特点和MyISAM的表级锁两种模式是一样的。</p>
<p>若想显式的给表加行级读锁和写锁，可以执行下面的sql语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 给查询sql显示添加读锁</span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line">// 给查询sql显示添加写锁</span><br><span class="line">select ... for update；</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>下面我们直接进入锁机制的测试阶段，还是创建一个测试表，并插入两条数据：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 先把原来的MyISAM表给删除了</span><br><span class="line">DROP TABLE IF EXISTS employee;</span><br><span class="line">CREATE TABLE IF NOT EXISTS employee (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    name VARCHAR(40),</span><br><span class="line">    money INT</span><br><span class="line">)ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">// 插入测试数据</span><br><span class="line">INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 1000);</span><br><span class="line">INSERT INTO employee(name, money) VALUES(&apos;lc&apos;, 2000);</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>创建的表中可以看出对表中的字段只有id添加了主键索引，接着就是在session1窗口执行<code>begin</code>开启事务，并执行下面的sql语句：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select * from employee where name=&apos;caoxl&apos; for update;</span><br><span class="line">MariaDB [test]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">-- 使用非索引字段查询，并显式的添加写锁</span><br><span class="line">MariaDB [test]&gt; select * from employee where name=&apos;caolx&apos; for update;</span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  1 | caolx |  1000 |</span><br><span class="line">|  2 | caolx |  2000 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="3">
<li>然后在session2中执行update语句，上面查询的式id=1的数据行，下面update的是id=1的数据行，会发现程序也会进入等待状态：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; update employee set name=&apos;caoxl&apos; where id = 1;</span><br></pre></td></tr></table></figure>
<p>可见若是 <strong>「使用非索引查询，直接就是使用的表级锁」</strong>，锁住了整个表。</p>
<ul>
<li><ol start="4">
<li>若是session1使用的是id来查询，如下所示：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee where id=&apos;1&apos; for update;  </span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  1 | caolx |  1000 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">1 row in set (0.14 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="5">
<li>那么session2是可以成功update其它数据行的，但是这里我建议使用数据量大的表进行测试，因为前面我说过了 <strong>「是否执行索引还得看Mysql的执行计划，对于一些小表的操作，可能就直接使用全表扫描」</strong>。</li>
</ol>
</li>
</ul>
<ul>
<li><ol start="6">
<li>还有一种情况就是：假如我们给name字段也加上了普通索引，那么通过普通索引来查询数据，并且查询到多行数据，拿它是锁这多行数据还是锁整个表呢？</li>
</ol>
</li>
</ul>
<p>下面我们来测试一下，首先给「name字段添加普通索引」，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; alter table employee add index index_name(name);</span><br><span class="line">Query OK, 0 rows affected (0.22 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="7">
<li>并插入一条新的数据name值与id=2的值相同，并显式的加锁，如下所示：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 3000);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [test]&gt; select * from employee;                        </span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  1 | caolx |  1000 |</span><br><span class="line">|  2 | caoxl |  2000 |</span><br><span class="line">|  3 | caoxl |  3000 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [test]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [test]&gt; select * from employee where name=&apos;caoxl&apos; for update;</span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  2 | caoxl |  2000 |</span><br><span class="line">|  3 | caoxl |  3000 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="8">
<li>当update其它数据行name值不是<code>caoxl</code>的也会进入等待状态，并且通过explain来查看是否name=’caoxl’有执行索引，可以看到sql语句是有执行索引条件的。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; MariaDB [test]&gt; explain update employee set name=&apos;lc&apos; where id = 1;</span><br><span class="line">+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id   | select_type | table    | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|    1 | SIMPLE      | employee | range | PRIMARY       | PRIMARY | 4       | NULL |    1 | Using where |</span><br><span class="line">+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>执行非索引条件查询执行的是表锁。</li>
<li>执行索引查询是否是加行锁，还得看Mysql的执行计划，可以通过explain关键字来查看。</li>
<li>用普通键索引的查询，遇到索引值相同的，也会对其他的操作数据行的产生影响。</li>
</ul>
<h2 id="InnoDB间隙锁"><a href="#InnoDB间隙锁" class="headerlink" title="InnoDB间隙锁"></a>InnoDB间隙锁</h2><p>当我们使用范围条件查询而不是等值条件查询的时候，InnoDB就会给符合条件的范围索引加锁，在条件范围内并不存的记录就叫做”间隙（GAP）”</p>
<p>大家大概都知道在事务的四大隔离级别中，不可重复读会产生幻读的现象，只能通过提高隔离级别到串行化来解决幻读现象。</p>
<p>但是Mysql中的不可重复是已经解决了幻读问题，它通过引入间隙锁的实现来解决幻读，通过给符合条件的间隙加锁，防止再次查询的时候出现新数据产生幻读的问题。</p>
<p>例如我们执行下面的sql语句，就会对id大于100的记录加锁，在id&gt;100的记录中肯定是有不存在的间隙：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from  employee where id &gt; 100 for update;</span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>接着来测试间隙锁，新增一个字段num，并将num添加为普通索引、修改之前的数据使得num之间的值存在间隙，操作如下sql所示：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table employee add num int not null default 0;</span><br><span class="line">update employee set num = 1 where id = 1;</span><br><span class="line">update employee set num = 1 where id = 2;</span><br><span class="line">update employee set num = 3 where id = 3;</span><br><span class="line">insert into employee values(4,&apos;kris&apos;,4000,5);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee;                        </span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">| id | name  | money | num |</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">|  1 | caolx |  1000 |   1 |</span><br><span class="line">|  2 | caoxl |  2000 |   1 |</span><br><span class="line">|  3 | caoxl |  3000 |   3 |</span><br><span class="line">|  4 | kris  |  4000 |   5 |</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="2">
<li>接着在session1的窗口开启事务，并执行下面操作：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee where num=3 for update;</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">| id | name  | money | num |</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">|  3 | caoxl |  3000 |   3 |</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">1 row in set (0.05 sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="3">
<li>同时打开窗口session2，并执行新增语句：</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into employee values(5,&apos;ceshi&apos;,5000,2);  // 程序出现等待</span><br><span class="line">insert into employee values(5,&apos;ceshi&apos;,5000,4);  // 程序出现等待</span><br><span class="line">insert into employee values(5,&apos;ceshi&apos;,5000,6);  // 新增成功</span><br><span class="line">insert into employee values(6,&apos;ceshi&apos;,5000,0);  // 新增成功</span><br></pre></td></tr></table></figure>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁在InnoDB中才会出现死锁，MyISAM是不会出现死锁，因为MyISAM支持的是表锁，一次性获取了所有得锁，其它的线程只能排队等候。</p>
<p>而InnoDB默认支持行锁，获取锁是分步的，并不是一次性获取所有得锁，因此在锁竞争的时候就会出现死锁的情况。</p>
<p>虽然InnoDB会出现死锁，但是并不影响InnoDB最受欢成为迎的存储引擎，MyISAM可以理解为串行化操作，读写有序，因此支持的并发性能低下。</p>
<h2 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h2><p>首先要解决死锁问题，在程序的设计上，当发现程序有高并发的访问某一个表时，尽量对该表的执行操作串行化，或者锁升级，一次性获取所有的锁资源。</p>
<p>然后也可以设置参数<code>innodb_lock_wait_timeout</code>，超时时间，并且将参数<code>innodb_deadlock_detect</code>打开，当发现死锁的时候，自动回滚其中的某一个事务。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面详细的介绍了<code>MyISAM</code>和<code>InnoDB</code>两种存储引擎的锁机制的实现，并进行了测试。</p>
<p><code>MyISAM</code>的表锁分为两种模式：<strong>「共享读锁」</strong> 和 <strong>「排它写锁」</strong>。获取的读锁的线程对该数据行只能读，不能修改，其它线程也只能对该数据行加读锁。</p>
<p>获取到写锁的线程对该数据行既能读也能写，对其他线程对该数据行的读写具有排它性。</p>
<p><strong>MyISAM中默认写优先于读操作</strong>，因此<code>MyISAM</code>一般不适合运用于大量读写操作的程序中。</p>
<p><code>InnoDB</code>的行锁虽然会出现死锁的可能，但是<code>InnoDB</code>的支持的并发性能比<code>MyISAM</code>好，行锁的粒度最小，一定的方法和措施可以解决死锁的发生，极大的发挥<code>InnoDB</code>的性能。</p>
<p><code>InnoDB</code>中引入了<strong>间隙锁</strong>的概念来决解出现幻读的问题，也引入事务的特性，通过事务的四种隔离级别，来降低锁冲突，提高并发性能。</p>

        
      
    </div>

    <footer class="article-footer">
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>CAO XIAN LIANG</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2020/06/23/Deep-Going-MySQL-Lock/" target="_blank" title="深入MySQL锁">http://blog.caoxl.com/2020/06/23/Deep-Going-MySQL-Lock/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL锁/">MySQL锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/共享锁/">共享锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排他锁/">排他锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/行锁/">行锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/表锁/">表锁</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/06/28/Install-PHP8-In-CentOS7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          CentOS7下编译安装PHP8
        
      </div>
    </a>
  
  
    <a href="/2020/06/18/MySQL-Interview-Questions-II/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">MySQL 面试题 II</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#锁种类"><span class="nav-number">1.</span> <span class="nav-text">锁种类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#按锁的粒度划分"><span class="nav-number">1.1.</span> <span class="nav-text">按锁的粒度划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按锁的使用方式划分"><span class="nav-number">1.2.</span> <span class="nav-text">按锁的使用方式划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按锁的思想划分"><span class="nav-number">1.3.</span> <span class="nav-text">按锁的思想划分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MyISAM"><span class="nav-number">2.</span> <span class="nav-text">MyISAM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM表级写锁"><span class="nav-number">2.1.</span> <span class="nav-text">MyISAM表级写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM表级共享读锁"><span class="nav-number">2.2.</span> <span class="nav-text">MyISAM表级共享读锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM表级锁竞争情况"><span class="nav-number">2.3.</span> <span class="nav-text">MyISAM表级锁竞争情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发插入"><span class="nav-number">2.4.</span> <span class="nav-text">并发插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁调度"><span class="nav-number">2.5.</span> <span class="nav-text">锁调度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#InnoDB"><span class="nav-number">3.</span> <span class="nav-text">InnoDB</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB行锁和表锁"><span class="nav-number">3.1.</span> <span class="nav-text">InnoDB行锁和表锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结论"><span class="nav-number">3.1.1.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB间隙锁"><span class="nav-number">3.2.</span> <span class="nav-text">InnoDB间隙锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#死锁"><span class="nav-number">4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的解决方案"><span class="nav-number">4.1.</span> <span class="nav-text">死锁的解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2017 - 2021 Keep It Simple And Stupid All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            Keep It Simple And Stupid
          </div>
          <div class="panel-body">
            Copyright © 2021 CAO XIAN LIANG All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>