<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>redis 集群 | Keep It Simple And Stupid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Redis集群">
  
  
  
  
  <meta name="description" content="前面是理论知识, 实操直接拉到 9. Linux下创建Redis集群  什么是Redis集群 ? Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施(installation)。  Redis 集群是一个分布式(distributed)、容错(fault-tolerant)的Redis实现, 集群可以使用的功能是普通单机Redis所能使用的功能的一个子集(subset).">
<meta name="keywords" content="Redis,集群">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 集群">
<meta property="og:url" content="http://blog.caoxl.com/2019/09/30/Redis-Cluster-Notes/index.html">
<meta property="og:site_name" content="Keep It Simple And Stupid">
<meta property="og:description" content="前面是理论知识, 实操直接拉到 9. Linux下创建Redis集群  什么是Redis集群 ? Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施(installation)。  Redis 集群是一个分布式(distributed)、容错(fault-tolerant)的Redis实现, 集群可以使用的功能是普通单机Redis所能使用的功能的一个子集(subset).">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-09-30T06:27:47.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis 集群">
<meta name="twitter:description" content="前面是理论知识, 实操直接拉到 9. Linux下创建Redis集群  什么是Redis集群 ? Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施(installation)。  Redis 集群是一个分布式(distributed)、容错(fault-tolerant)的Redis实现, 集群可以使用的功能是普通单机Redis所能使用的功能的一个子集(subset).">
  
    <link rel="alternate" href="/atom.xml" title="Keep It Simple And Stupid" type="application/atom+xml">
  

  

  <link rel="icon" href="https://source.unsplash.com/random">
  <link rel="apple-touch-icon" href="/https://source.unsplash.com/random">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css">
  

  
  
  

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="https://source.unsplash.com/random">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-Redis-Cluster-Notes" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Redis 集群
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/09/30/Redis-Cluster-Notes/" class="article-date">
	  <time datetime="2019-09-30T01:34:18.000Z" itemprop="datePublished">2019-09-30</time>
	</a>

      
    <a class="article-category-link" href="/categories/加分技能/">加分技能</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>

    <div class="article-entry" itemprop="articleBody">
      
        
        
          <blockquote>
<p>前面是理论知识, 实操直接拉到 <a href="http://blog.caoxl.com/2019/09/30/Redis-Cluster-Notes/#Linux%E4%B8%8B%E5%88%9B%E5%BB%BARedis%E9%9B%86%E7%BE%A4">9. Linux下创建Redis集群</a></p>
</blockquote>
<h2 id="什么是Redis集群"><a href="#什么是Redis集群" class="headerlink" title="什么是Redis集群 ?"></a>什么是Redis集群 ?</h2><blockquote>
<p>Redis 集群是一个可以在多个 <code>Redis</code> 节点之间进行数据共享的设施(<code>installation</code>)。</p>
</blockquote>
<p>Redis 集群是一个<strong>分布式</strong>(<code>distributed</code>)、<strong>容错</strong>(<code>fault-tolerant</code>)的Redis实现, 集群可以使用的功能是普通单机Redis所能使用的功能的一个子集(<code>subset</code>).</p>
<p>Redis 集群中不存在 <strong>中心(<code>central</code>)节点</strong> 或者 <strong>代理(<code>proxy</code>)节点</strong>, 集群的其中一个主要设计目标是达到线性可扩展性(<code>linear scalability</code>)</p>
<p>Redis 集群为了保证一致性(<code>consistency</code>)而牺牲了一部分容错性: 系统会在保证对网络断线(<code>net split</code>)和节点失效(<code>node failure</code>)具有有限(<code>limited</code>)抵抗力的前提下， 尽可能地保持数据的一致性。</p>
<a id="more"></a>
<h2 id="Redis集群实现的功能子集"><a href="#Redis集群实现的功能子集" class="headerlink" title="Redis集群实现的功能子集"></a>Redis集群实现的功能子集</h2><p>Redis 集群实现了单机 Redis 中， 所有处理单个数据库键的命令。</p>
<p>针对多个数据库键的复杂计算操作， 比如集合的并集操作、合集操作没有被实现， 那些理论上需要使用多个节点的多个数据库键才能完成的命令也没有被实现。</p>
<p>在将来， 用户也许可以通过 <code>MIGRATE COPY</code> 命令， 在集群的计算节点（<code>computation node</code>）中执行针对多个数据库键的只读操作， 但集群本身不会去实现那些需要将多个数据库键在多个节点中移来移去的复杂多键命令。</p>
<p>Redis 集群不像单机 Redis 那样支持多数据库功能， 集群只使用默认的 0 号数据库， 并且不能使用 SELECT index 命令。</p>
<h2 id="Redis集群协议中的客户端和服务器"><a href="#Redis集群协议中的客户端和服务器" class="headerlink" title="Redis集群协议中的客户端和服务器"></a>Redis集群协议中的客户端和服务器</h2><p>Redis 集群中的节点有以下责任：</p>
<ul>
<li>持有键值对数据。</li>
<li>记录集群的状态，包括键到正确节点的映射（<code>mapping keys to right nodes</code>）。</li>
<li>自动发现其他节点，识别工作不正常的节点，并在有需要时，在从节点中选举出新的主节点。</li>
</ul>
<p>为了执行以上列出的任务， 集群中的每个节点都与其他节点建立起了“集群连接(cluster bus)”， 该连接是一个 TCP 连接， 使用二进制协议进行通讯。</p>
<p>节点之间使用 <a href="https://en.wikipedia.org/wiki/Gossip_protocol" target="_blank" rel="noopener">Gossip协议</a> 来进行以下工作:</p>
<ul>
<li>传播 (propagate) 关于集群的信息，以此来发现新的节点。</li>
<li>向其他节点发送 <code>PING</code> 数据包，以此来检查目标节点是否正常运作。</li>
<li>在特定事件发生时，发送集群信息。</li>
</ul>
<p>除此之外， 集群连接还用于在集群中发布或订阅信息。</p>
<p>因为集群节点不能代理（<code>proxy</code>）命令请求， 所以客户端应该在节点返回 <code>-MOVED</code> 或者 <code>-ASK</code> 转向（<code>redirection</code>）错误时， 自行将命令请求转发至其他节点。</p>
<p>因为客户端可以自由地向集群中的任何一个节点发送命令请求， 并可以在有需要时， 根据转向错误所提供的信息， 将命令转发至正确的节点， 所以在理论上来说， 客户端是无须保存集群状态信息的。</p>
<p>不过， 如果客户端可以将键和节点之间的映射信息保存起来， 可以有效地减少可能出现的转向次数， 籍此提升命令执行的效率。</p>
<h2 id="Redis集群键分布模型"><a href="#Redis集群键分布模型" class="headerlink" title="Redis集群键分布模型"></a>Redis集群键分布模型</h2><p>Redis 集群的键空间被分割为 <code>16384</code> 个槽（slot）， 集群的最大节点数量也是 <code>16384</code> 个。</p>
<blockquote>
<p>推荐的最大节点数量为 1000 个左右。</p>
</blockquote>
<p>每个主节点都负责处理 <code>16384</code> 个哈希槽的其中一部分。</p>
<p>当我们说一个集群处于“稳定”（<code>stable</code>）状态时， 指的是集群没有在执行重配置（<code>reconfiguration</code>）操作， 每个哈希槽都只由一个节点进行处理。</p>
<p>以下是负责将键映射到槽的算法：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HASH_SLOT = CRC16(key) mod 16384</span><br></pre></td></tr></table></figure>
<p>以下是该算法所使用的参数：</p>
<ul>
<li>算法的名称: XMODEM (又称ZMODEM 或者 CRC-16/ACORN)</li>
<li>结果的长度: 16位</li>
<li>多项数 (poly): 1021 (也即是 <code>x16 + x12 + x5 + 1</code>)</li>
<li>初始化值: <code>0000</code></li>
<li>反射输入字节 (Reflect Input byte): <code>False</code></li>
<li>发射输出CRC (Reflect Output CRC): <code>False</code></li>
<li>用于 CRC 输出值的异或常量 (Xor constant to output CRC) : <code>0000</code></li>
<li>该算法对于输入 <code>&quot;123456789&quot;</code> 的输出: <code>31C3</code></li>
</ul>
<h2 id="Redis-集群数据共享"><a href="#Redis-集群数据共享" class="headerlink" title="Redis 集群数据共享"></a>Redis 集群数据共享</h2><p>Redis 集群使用<strong>数据分片</strong> (sharding) 而非<strong>一致性哈希</strong> (consistency hashing) 来实现： 一个 Redis 集群包含 <code>16384</code> 个哈希槽（hash slot）， 数据库中的每个键都属于这 <code>16384</code> 个哈希槽的其中一个， 集群使用公式 <code>CRC16(key) % 16384</code> 来计算键 <code>key</code> 属于哪个槽， 其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 <code>CRC16</code> 校验和 。</p>
<p>集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中：</p>
<ul>
<li>节点 <strong>A</strong> 负责处理 <code>0</code> 号至 <code>5500</code> 号哈希槽。</li>
<li>节点 <strong>B</strong> 负责处理 <code>5501</code> 号至 <code>11000</code> 号哈希槽。</li>
<li>节点 <strong>C</strong> 负责处理 <code>11001</code> 号至 <code>16384</code> 号哈希槽。</li>
</ul>
<p>种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p>
<ul>
<li>如果用户将新节点 <strong>D</strong> 添加到集群中， 那么集群只需要将节点 <strong>A</strong> 、<strong>B</strong> 、 <strong>C</strong> 中的某些槽移动到节点 <strong>D</strong> 就可以了。</li>
<li>与此类似， 如果用户要从集群中移除节点 <strong>A</strong> ， 那么集群只需要将节点 <strong>A</strong> 中的所有哈希槽移动到节点 <strong>B</strong> 和节点 <strong>C</strong> ， 然后再移除空白（不包含任何哈希槽）的节点 <strong>A</strong> 就可以了。</li>
</ul>
<p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。</p>
<h2 id="Redis集群中的主从复制"><a href="#Redis集群中的主从复制" class="headerlink" title="Redis集群中的主从复制"></a>Redis集群中的主从复制</h2><p>为了使得集群在一部分节点下线或者无法与集群的大多数（<code>majority</code>）节点进行通讯的情况下， 仍然可以正常运作， <code>Redis</code> 集群对节点使用了主从复制功能： 集群中的每个节点都有 <code>1</code> 个至 <code>N</code> 个复制品（<code>replica</code>）， 其中一个复制品为主节点（<code>master</code>）， 而其余的 <code>N-1</code> 个复制品为从节点（<code>slave</code>）。</p>
<p>在之前列举的节点 <strong>A</strong> 、<strong>B</strong> 、<strong>C</strong> 的例子中， 如果节点 <strong>B</strong> 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 <code>5501</code> 号至 <code>11000</code> 号的哈希槽。</p>
<p>另一方面， 假如在创建集群的时候（或者至少在节点 <strong>B</strong> 下线之前）， 我们为主节点 <strong>B</strong> 添加了从节点 <strong>B1</strong> ， 那么当主节点 <strong>B</strong> 下线的时候， 集群就会将 <strong>B1</strong> 设置为新的主节点， 并让它代替下线的主节点 <strong>B</strong> ， 继续处理 <code>5501</code> 号至 <code>11000</code> 号的哈希槽， 这样集群就不会因为主节点 <strong>B</strong> 的下线而无法正常运作了。另一方面， 假如在创建集群的时候（或者至少在节点 <strong>B</strong> 下线之前）， 我们为主节点 <strong>B</strong> 添加了从节点 <strong>B1</strong> ， 那么当主节点 <strong>B</strong> 下线的时候， 集群就会将 <strong>B1</strong> 设置为新的主节点， 并让它代替下线的主节点 <strong>B</strong> ， 继续处理 <code>5501</code> 号至 <code>11000</code> 号的哈希槽， 这样集群就不会因为主节点 <strong>B</strong> 的下线而无法正常运作了。</p>
<p>不过如果节点 <strong>B</strong> 和 <strong>B1</strong> 都下线的话， <code>Redis</code> 集群还是会停止运作。</p>
<h2 id="Redis-集群的一致性保证（guarantee）"><a href="#Redis-集群的一致性保证（guarantee）" class="headerlink" title="Redis 集群的一致性保证（guarantee）"></a>Redis 集群的一致性保证（<code>guarantee</code>）</h2><p>Redis 集群<strong>不保证数据的强一致性</strong>（<code>strong consistency</code>）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。</p>
<p>使用异步复制（<code>asynchronous replication</code>）是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子：</p>
<ul>
<li>客户端向主节点 B 发送一条写命令。</li>
<li>主节点 B 执行写命令，并向客户端返回命令回复。</li>
<li>主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。</li>
</ul>
<p>如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。</p>
<p>Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂 (<code>network partition</code>)， 并且一个客户端与至少包括一个主节点在内的少数 (<code>minority</code>) 实例被孤立。</p>
<h2 id="创建并使用Redis集群"><a href="#创建并使用Redis集群" class="headerlink" title="创建并使用Redis集群"></a>创建并使用Redis集群</h2><p>Redis 集群由多个运行在集群模式 (<code>cluster mode</code>) 下的 Redis 实例组成， 实例的集群模式需要通过配置来开启， 开启集群模式的实例将可以使用集群特有的功能和命令。</p>
<p>以下是一个包含了最少选项的集群配置文件示例：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>文件中的 <code>cluster-enabled</code> 选项用于开实例的集群模式， 而 <code>cluster-conf-file</code> 选项则设定了保存节点配置文件的路径， 默认值为 <code>nodes.conf</code> 。</p>
<p>节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。</p>
<p><strong>要让集群正常运作至少需要三个主节点</strong>， 不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。</p>
<p>首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cluster-test</span><br><span class="line">cd cluster-test</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure>
<p>在文件夹 <code>7000</code> 至 <code>7005</code> 中， 各创建一个 <code>redis.conf</code> 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码。</p>
<p>现在， 从 <a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis Github</a> 页面 的 <code>unstable</code> 分支中取出最新的 Redis 源码， 编译出可执行文件 <code>redis-server</code> ， 并将文件复制到 <code>cluster-test</code> 文件夹， 然后使用类似以下命令， 在每个标签页中打开一个实例：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd 7000</span><br><span class="line">../redis-server ./redis.conf</span><br></pre></td></tr></table></figure>
<p>实例打印的日志显示， 因为 <code>nodes.conf</code> 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I'm 97a3a64667477371c4479320d683e4c8db5858b1</span><br></pre></td></tr></table></figure>
<p>实例会一直使用同一个 <strong>ID</strong> ， 从而在集群中保持一个独一无二 (<code>unique</code>) 的名字。</p>
<p>每个节点都使用 <strong>ID</strong> 而不是 IP 或者端口号来记录其他节点， 因为 IP 地址和端口号都可能会改变， 而这个独一无二的标识符 (<code>identifier</code>) 则会在节点的整个生命周期中一直保持不变。</p>
<p>我们将这个标识符称为节点 <strong>ID</strong>。</p>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。</p>
<p>通过使用 Redis 集群命令行工具 <code>redis-trib</code> ， 编写节点配置文件的工作可以非常容易地完成： <code>redis-trib</code> 位于 Redis 源码的 <code>src</code> 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片 (<code>reshared</code>) 等工作。</p>
<p>我们需要执行以下命令来创建集群：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure>
<p>命令的意义如下：</p>
<ul>
<li>给定 <code>redis-trib.rb</code> 程序的命令是 <code>create</code> ， 这表示我们希望创建一个新的集群。</li>
<li>选项 <code>--replicas 1</code> 表示我们希望为集群中的每个主节点创建一个从节点。</li>
<li>后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。</li>
</ul>
<p>简单来说， 以上命令的意思就是让 <code>redis-trib</code> 程序创建一个包含三个主节点和三个从节点的集群。</p>
<p>接着， <code>redis-trib</code> 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 <code>yes</code> ， <code>redis-trib</code> 就会将这份配置应用到集群当中：</p>
<p>输入 <code>yes</code> 并按下回车确认之后， 集群就会将配置应用到各个节点， 并连接起 (<code>join</code>) 各个节点 —— 也即是， 让各个节点开始互相通讯：</p>
<p>如果一切正常的话， <code>redis-trib</code> 将输出以下信息：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>
<p>这表示集群中的 <code>16384</code> 个槽都有至少一个主节点在处理， 集群运作正常。</p>
<h2 id="Linux下创建Redis集群"><a href="#Linux下创建Redis集群" class="headerlink" title="Linux下创建Redis集群"></a>Linux下创建Redis集群</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl redis]# cd /usr/local/redis/</span><br><span class="line">[root@caoxl redis]# mkdir cluster</span><br><span class="line">[root@caoxl redis]# cd cluster/</span><br><span class="line">[root@caoxl cluster]# mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure>
<h3 id="复制和修改配置文件"><a href="#复制和修改配置文件" class="headerlink" title="复制和修改配置文件"></a>复制和修改配置文件</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl cluster]# cp ../bin/redis.conf ./7000</span><br></pre></td></tr></table></figure>
<p>修改配置文件 <code>redis.conf</code>，将下面的选项修改</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 端口号</span></span><br><span class="line">port 7000</span><br><span class="line"><span class="section"># 后台启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="section"># 开启集群</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="section">#集群节点配置文件</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"><span class="section"># 集群连接超时时间</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="section"># 进程pid的文件位置</span></span><br><span class="line">pidfile /var/run/redis-7000.pid</span><br><span class="line"><span class="section"># 开启aof</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="section"># aof文件路径</span></span><br><span class="line">appendfilename "appendonly-7000.aof"</span><br><span class="line"><span class="section"># rdb文件路径</span></span><br><span class="line">dbfilename dump-7000.rdb</span><br></pre></td></tr></table></figure>
<p>6个配置文件按照<strong>对应的端口</strong>分别修改配置文件</p>
<h3 id="创建启动脚本"><a href="#创建启动脚本" class="headerlink" title="创建启动脚本"></a>创建启动脚本</h3><p>在 <code>/usr/local/redis</code> 目录下创建一个 <code>start.sh</code></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#!/bin/bash</span></span><br><span class="line">bin/redis-server cluster/7000/redis.conf</span><br><span class="line">bin/redis-server cluster/7001/redis.conf</span><br><span class="line">bin/redis-server cluster/7002/redis.conf</span><br><span class="line">bin/redis-server cluster/7003/redis.conf</span><br><span class="line">bin/redis-server cluster/7004/redis.conf</span><br><span class="line">bin/redis-server cluster/7005/redis.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>这个时候我们查看一下进程看启动情况</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl redis]# ps -ef | grep redis</span><br><span class="line">root     20142 19734  0 11:29 pts/2    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>
<ul>
<li>执行 <code>start.sh</code></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl redis]# sh start.sh </span><br><span class="line">20169:C 30 Sep 2019 11:31:39.052 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">20169:C 30 Sep 2019 11:31:39.052 # Redis version=5.0.1, bits=64, commit=00000000, modified=0, pid=20169, just started</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>这个时候我们查看一下进程看启动情况</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl redis]# ps -ef | grep redis</span><br><span class="line">root     20155     1  0 11:31 ?        00:00:00 bin/redis-server 127.0.0.1:7000 [cluster]</span><br><span class="line">root     20162     1  0 11:31 ?        00:00:00 bin/redis-server 127.0.0.1:7001 [cluster]</span><br><span class="line">root     20174     1  0 11:31 ?        00:00:00 bin/redis-server 127.0.0.1:7002 [cluster]</span><br><span class="line">root     20176     1  0 11:31 ?        00:00:00 bin/redis-server 127.0.0.1:7003 [cluster]</span><br><span class="line">root     20181     1  0 11:31 ?        00:00:00 bin/redis-server 127.0.0.1:7004 [cluster]</span><br><span class="line">root     20189     1  0 11:31 ?        00:00:00 bin/redis-server 127.0.0.1:7005 [cluster]</span><br><span class="line">root     20194 19734  0 11:31 pts/2    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>
<p>有6个<code>Redis</code>进程在开启，说明我们的<code>Redis</code>就启动成功了</p>
<h3 id="创建-开启集群"><a href="#创建-开启集群" class="headerlink" title="创建/开启集群"></a>创建/开启集群</h3><p>这里我们只是<strong>开启了6个redis进程</strong>而已，它们都还只是独立的状态，还么有组成集群这里我们使用官方提供的工具<code>redis-trib</code>，不过这个工具是用<code>ruby</code>写的，要先安装<code>ruby</code>的环境</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ruby rubygems -y</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl redis]# redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 2730</span><br><span class="line">Master[1] -&gt; Slots 2731 - 5460</span><br><span class="line">Master[2] -&gt; Slots 5461 - 8191</span><br><span class="line">Master[3] -&gt; Slots 8192 - 10922</span><br><span class="line">Master[4] -&gt; Slots 10923 - 13652</span><br><span class="line">Master[5] -&gt; Slots 13653 - 16383</span><br><span class="line">M: ec6743b088fafa480bb6f06f2f5189df1ede2b1d 127.0.0.1:7000</span><br><span class="line">   slots:[0-2730] (2731 slots) master</span><br><span class="line">M: 61d89b9786b7785633224c5950eef2aa5cee7dfa 127.0.0.1:7001</span><br><span class="line">   slots:[2731-5460] (2730 slots) master</span><br><span class="line">M: 4449a1b0bd65e9688995907215c4ef1311dbdfc8 127.0.0.1:7002</span><br><span class="line">   slots:[5461-8191] (2731 slots) master</span><br><span class="line">M: 6ad224baedff1134cd443a249d5eb13a80c51017 127.0.0.1:7003</span><br><span class="line">   slots:[8192-10922] (2731 slots) master</span><br><span class="line">M: 797ad1ef54e859f724bc153223284a85c1afef44 127.0.0.1:7004</span><br><span class="line">   slots:[10923-13652] (2730 slots) master</span><br><span class="line">M: 32158e5b4e5815ffd253d8eb94ace27c8c96e84e 127.0.0.1:7005</span><br><span class="line">   slots:[13653-16383] (2731 slots) master</span><br><span class="line">Can I set the above configuration? (type 'yes' to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)</span><br><span class="line">M: ec6743b088fafa480bb6f06f2f5189df1ede2b1d 127.0.0.1:7000</span><br><span class="line">   slots:[0-2730] (2731 slots) master</span><br><span class="line">M: 32158e5b4e5815ffd253d8eb94ace27c8c96e84e 127.0.0.1:7005</span><br><span class="line">   slots:[13653-16383] (2731 slots) master</span><br><span class="line">M: 797ad1ef54e859f724bc153223284a85c1afef44 127.0.0.1:7004</span><br><span class="line">   slots:[10923-13652] (2730 slots) master</span><br><span class="line">M: 61d89b9786b7785633224c5950eef2aa5cee7dfa 127.0.0.1:7001</span><br><span class="line">   slots:[2731-5460] (2730 slots) master</span><br><span class="line">M: 4449a1b0bd65e9688995907215c4ef1311dbdfc8 127.0.0.1:7002</span><br><span class="line">   slots:[5461-8191] (2731 slots) master</span><br><span class="line">M: 6ad224baedff1134cd443a249d5eb13a80c51017 127.0.0.1:7003</span><br><span class="line">   slots:[8192-10922] (2731 slots) master</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>redis-cli –cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</p>
</blockquote>
<h3 id="连接集群"><a href="#连接集群" class="headerlink" title="连接集群"></a>连接集群</h3><p>这里我们使用 <code>reids-cli</code> 连接集群，使用时加上<code>-c</code>参数，就可以连接到集群<br>连接 <code>7000</code> 端口的节点</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl redis]# redis-cli -c -p 7000</span><br><span class="line">127.0.0.1:7000&gt; set key<span class="emphasis">_7000 value_</span>7000</span><br><span class="line">-&gt; Redirected to slot [10168] located at 127.0.0.1:7003</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7003&gt; get key_7000</span><br><span class="line">"value_7000"</span><br><span class="line">127.0.0.1:7003&gt; set key<span class="emphasis">_7003 value_</span>7003</span><br><span class="line">-&gt; Redirected to slot [6107] located at 127.0.0.1:7002</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7002&gt; get key_7003</span><br><span class="line">"value_7003"</span><br></pre></td></tr></table></figure>
<p>我们发现数据会在 <code>7000-7002</code>这<code>3</code>个节点之间来回跳转</p>
<h3 id="测试集群中的节点挂掉"><a href="#测试集群中的节点挂掉" class="headerlink" title="测试集群中的节点挂掉"></a>测试集群中的节点挂掉</h3><p>上面我们建立了一个集群，<code>3</code>个主节点和<code>3</code>个从节点，<code>7000-7002</code>负责存取数据，<code>7003-7005</code>负责把<code>7000-7005</code>的数据同步到自己的节点上来。我们现在来模拟一下一台matser服务器宕机的情况</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl redis]# ps -ef | grep redis</span><br><span class="line">root     20155     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7000 [cluster]</span><br><span class="line">root     20162     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7001 [cluster]</span><br><span class="line">root     20174     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7002 [cluster]</span><br><span class="line">root     20176     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7003 [cluster]</span><br><span class="line">root     20181     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7004 [cluster]</span><br><span class="line">root     20189     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7005 [cluster]</span><br><span class="line">root     20571 19734  0 11:49 pts/2    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>
<ul>
<li>杀死一个<code>redis master</code>进程</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl redis]# kill 20155</span><br><span class="line">[root@caoxl redis]# ps -ef | grep redis</span><br><span class="line">root     20162     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7001 [cluster]</span><br><span class="line">root     20174     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7002 [cluster]</span><br><span class="line">root     20176     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7003 [cluster]</span><br><span class="line">root     20181     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7004 [cluster]</span><br><span class="line">root     20189     1  0 11:31 ?        00:00:01 bin/redis-server 127.0.0.1:7005 [cluster]</span><br><span class="line">root     20578 19734  0 11:50 pts/2    00:00:00 grep --color=auto redis</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl bin]# redis-cli --cluster check 127.0.0.1:7001</span><br><span class="line">Could not connect to Redis at 127.0.0.1:7000: Connection refused</span><br><span class="line">127.0.0.1:7001 (61d89b97...) -&gt; 0 keys | 2730 slots | 0 slaves.</span><br><span class="line">127.0.0.1:7004 (797ad1ef...) -&gt; 0 keys | 2730 slots | 0 slaves.</span><br><span class="line">127.0.0.1:7002 (4449a1b0...) -&gt; 1 keys | 2731 slots | 0 slaves.</span><br><span class="line">127.0.0.1:7005 (32158e5b...) -&gt; 0 keys | 2731 slots | 0 slaves.</span><br><span class="line">127.0.0.1:7003 (6ad224ba...) -&gt; 1 keys | 2731 slots | 0 slaves.</span><br><span class="line">[OK] 2 keys in 5 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span><br><span class="line">M: 61d89b9786b7785633224c5950eef2aa5cee7dfa 127.0.0.1:7001</span><br><span class="line">   slots:[2731-5460] (2730 slots) master</span><br><span class="line">M: 797ad1ef54e859f724bc153223284a85c1afef44 127.0.0.1:7004</span><br><span class="line">   slots:[10923-13652] (2730 slots) master</span><br><span class="line">M: 4449a1b0bd65e9688995907215c4ef1311dbdfc8 127.0.0.1:7002</span><br><span class="line">   slots:[5461-8191] (2731 slots) master</span><br><span class="line">M: 32158e5b4e5815ffd253d8eb94ace27c8c96e84e 127.0.0.1:7005</span><br><span class="line">   slots:[13653-16383] (2731 slots) master</span><br><span class="line">M: 6ad224baedff1134cd443a249d5eb13a80c51017 127.0.0.1:7003</span><br><span class="line">   slots:[8192-10922] (2731 slots) master</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[ERR] Not all 16384 slots are covered by nodes.</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意:</strong> <code>redis-trib.rb</code>是redis 5.0以下的版本创建集群所使用的脚本，注意，redis5.0版本已不需要再使用此脚本，而是使用自带的<code>redis-cli</code>创建<br>[root@caoxl redis]# redis-cli -v<br>  redis-cli 5.0.1</p>
</blockquote>
<h3 id="Redis集群命令"><a href="#Redis集群命令" class="headerlink" title="Redis集群命令"></a>Redis集群命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl bin]# redis-cli --cluster help</span><br><span class="line">Cluster Manager Commands:</span><br><span class="line">  create         host1:port1 ... hostN:portN</span><br><span class="line"><span class="code">                 --cluster-replicas &lt;arg&gt;</span></span><br><span class="line">  check          host:port</span><br><span class="line">  info           host:port</span><br><span class="line">  fix            host:port</span><br><span class="line">  reshard        host:port</span><br><span class="line"><span class="code">                 --cluster-from &lt;arg&gt;</span></span><br><span class="line"><span class="code">                 --cluster-to &lt;arg&gt;</span></span><br><span class="line"><span class="code">                 --cluster-slots &lt;arg&gt;</span></span><br><span class="line"><span class="code">                 --cluster-yes</span></span><br><span class="line"><span class="code">                 --cluster-timeout &lt;arg&gt;</span></span><br><span class="line"><span class="code">                 --cluster-pipeline &lt;arg&gt;</span></span><br><span class="line">  rebalance      host:port</span><br><span class="line"><span class="code">                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;</span></span><br><span class="line"><span class="code">                 --cluster-use-empty-masters</span></span><br><span class="line"><span class="code">                 --cluster-timeout &lt;arg&gt;</span></span><br><span class="line"><span class="code">                 --cluster-simulate</span></span><br><span class="line"><span class="code">                 --cluster-pipeline &lt;arg&gt;</span></span><br><span class="line"><span class="code">                 --cluster-threshold &lt;arg&gt;</span></span><br><span class="line">  add-node       new<span class="emphasis">_host:new_</span>port existing<span class="emphasis">_host:existing_</span>port</span><br><span class="line"><span class="code">                 --cluster-slave</span></span><br><span class="line"><span class="code">                 --cluster-master-id &lt;arg&gt;</span></span><br><span class="line">  del-node       host:port node_id</span><br><span class="line">  call           host:port command arg arg .. arg</span><br><span class="line">  set-timeout    host:port milliseconds</span><br><span class="line">  import         host:port</span><br><span class="line"><span class="code">                 --cluster-from &lt;arg&gt;</span></span><br><span class="line"><span class="code">                 --cluster-copy</span></span><br><span class="line"><span class="code">                 --cluster-replace</span></span><br><span class="line">  help           </span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster.</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis cluster tutorial</a></li>
<li><a href="http://redisdoc.com/topic/cluster-tutorial.html#redis-guarantee" target="_blank" rel="noopener">Redis - 集群教程</a></li>
<li><a href="https://juejin.im/entry/596343056fb9a06bc340ac15" target="_blank" rel="noopener">Redis集群的原理和搭建</a></li>
<li><a href="https://github.com/eyjian/redis-tools/tree/master/deploy" target="_blank" rel="noopener">集群部署交互式命令行工具</a></li>
<li><a href="https://github.com/eyjian/redis-tools/tree/master" target="_blank" rel="noopener"> 集群运维命令行工具</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1367998" target="_blank" rel="noopener">Redis-5.0.0集群配置</a></li>
<li><a href="https://blog.csdn.net/Aquester/article/details/50150163" target="_blank" rel="noopener">Redis-5.0.0 以下版本的安装和部署</a></li>
</ul>

        
      
    </div>

    <footer class="article-footer">
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>CAO XIAN LIANG</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2019/09/30/Redis-Cluster-Notes/" target="_blank" title="Redis 集群">http://blog.caoxl.com/2019/09/30/Redis-Cluster-Notes/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/集群/">集群</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/30/Uni-App-Learning-Log/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Uni-App 学习日志
        
      </div>
    </a>
  
  
    <a href="/2019/09/29/Taro-Learning-Log/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Taro 学习日志</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Redis集群"><span class="nav-number">1.</span> <span class="nav-text">什么是Redis集群 ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis集群实现的功能子集"><span class="nav-number">2.</span> <span class="nav-text">Redis集群实现的功能子集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis集群协议中的客户端和服务器"><span class="nav-number">3.</span> <span class="nav-text">Redis集群协议中的客户端和服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis集群键分布模型"><span class="nav-number">4.</span> <span class="nav-text">Redis集群键分布模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-集群数据共享"><span class="nav-number">5.</span> <span class="nav-text">Redis 集群数据共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis集群中的主从复制"><span class="nav-number">6.</span> <span class="nav-text">Redis集群中的主从复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-集群的一致性保证（guarantee）"><span class="nav-number">7.</span> <span class="nav-text">Redis 集群的一致性保证（guarantee）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建并使用Redis集群"><span class="nav-number">8.</span> <span class="nav-text">创建并使用Redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建集群"><span class="nav-number">8.1.</span> <span class="nav-text">创建集群</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux下创建Redis集群"><span class="nav-number">9.</span> <span class="nav-text">Linux下创建Redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建目录"><span class="nav-number">9.1.</span> <span class="nav-text">创建目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制和修改配置文件"><span class="nav-number">9.2.</span> <span class="nav-text">复制和修改配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建启动脚本"><span class="nav-number">9.3.</span> <span class="nav-text">创建启动脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-开启集群"><span class="nav-number">9.4.</span> <span class="nav-text">创建/开启集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接集群"><span class="nav-number">9.5.</span> <span class="nav-text">连接集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试集群中的节点挂掉"><span class="nav-number">9.6.</span> <span class="nav-text">测试集群中的节点挂掉</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis集群命令"><span class="nav-number">9.7.</span> <span class="nav-text">Redis集群命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">10.</span> <span class="nav-text">参考</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2017 - 2021 Keep It Simple And Stupid All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            Keep It Simple And Stupid
          </div>
          <div class="panel-body">
            Copyright © 2021 CAO XIAN LIANG All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>