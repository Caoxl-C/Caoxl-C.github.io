<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep It Simple And Stupid</title>
  
  <subtitle>Caoxl-Hexo-caoxl.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.caoxl.com/"/>
  <updated>2022-10-25T02:53:06.665Z</updated>
  <id>http://blog.caoxl.com/</id>
  
  <author>
    <name>CAO XIAN LIANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang 面试题 V</title>
    <link href="http://blog.caoxl.com/2022/10/24/Golang-Interview-V/"/>
    <id>http://blog.caoxl.com/2022/10/24/Golang-Interview-V/</id>
    <published>2022-10-24T09:37:27.000Z</published>
    <updated>2022-10-25T02:53:06.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>一些杂的内容</p></blockquote><a id="more"></a><h1 id="go的调度"><a href="#go的调度" class="headerlink" title="go的调度"></a>go的调度</h1><ul><li>单线程调度器</li><li>多线程调度器</li><li>任务窃取调度器</li><li>抢占式调度器</li><li><p>非均匀存储访问调度器</p></li><li><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/" target="_blank" rel="noopener">调度器</a></p></li></ul><h1 id="go-struct能不能比较"><a href="#go-struct能不能比较" class="headerlink" title="go struct能不能比较"></a>go struct能不能比较</h1><p>struct能不能比较？ 很显然这句话包含了两种情况</p><ul><li><ol><li>同一个<code>struct</code>的两个实例能不能比较？</li></ol></li><li><ol start="2"><li>两个不同的<code>struct</code>的实例能不能比较？</li></ol></li></ul><blockquote><p>同一个struct的两个实例可比较也不可比较，当结构不包含不可直接比较成员变量时可直接比较，否则不可直接比较<br>两个不同的struct的实例可比较也不可比较, 如果成员变量中含有不可比较成员变量，即使可以强制转换，也不可以比较</p></blockquote><h2 id="可比较与不可比较类型"><a href="#可比较与不可比较类型" class="headerlink" title="可比较与不可比较类型"></a>可比较与不可比较类型</h2><ul><li>可比较: <code>Integer</code>, <code>Floating-point</code>, <code>String</code>, <code>Boolean</code>, <code>Complex(复数型)</code>, <code>Pointer</code>, <code>Channel</code>, <code>Interface</code>, <code>Array</code></li><li>不可比较: <code>Slice</code>, <code>Map</code>, <code>Function</code></li></ul><h1 id="go-defer（for-defer）"><a href="#go-defer（for-defer）" class="headerlink" title="go defer（for defer）"></a>go defer（for defer）</h1><blockquote><p>defer和go一样都是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。<br>如果有多个defer表达式，调用顺序类似于栈，越后面的defer表达式越先被调用</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        r++</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    t := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t = t + <span class="number">5</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">()</span> <span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        r = r + <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请读者先不要运行代码，在心里跑一遍结果，然后去验证。</p><p>例1的正确答案不是0，例2的正确答案不是10，如果例3的正确答案不是6……</p><p>函数返回的过程是这样的：先给返回值赋值，然后调用defer表达式，最后才是返回到调用函数中。</p><p>其实使用defer时，用一个简单的转换规则改写一下，就不会迷糊了。改写规则是将return语句拆成两句写，return xxx会被改写成:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值 = xxx</span><br><span class="line">调用<span class="keyword">defer</span>函数</span><br><span class="line">空的<span class="keyword">return</span></span><br></pre></td></tr></table></figure><blockquote><p>答案: 例1: 1 例2: 5 例3: 1</p></blockquote><h1 id="select可以用于什么"><a href="#select可以用于什么" class="headerlink" title="select可以用于什么"></a>select可以用于什么</h1><blockquote><p>select 只能应用于channel 的操作，<strong>既可以用于channel 的数据接收，也可以用于channel 的数据发送</strong>。 如果select 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支执行。</p></blockquote><h1 id="context包的用途"><a href="#context包的用途" class="headerlink" title="context包的用途"></a>context包的用途</h1><blockquote><p>context 包是Go 1.7 引入的标准库，<strong>主要用于在goroutine 之间传递取消信号、超时时间、截止时间以及一些共享的值等</strong>。 它并不是太完美，但几乎成了并发控制和超时控制的标准做法。 使用上，先创建一个根节点的context，之后根据库提供的四个函数创建相应功能的子节点context。</p></blockquote><h1 id="client如何实现长连接"><a href="#client如何实现长连接" class="headerlink" title="client如何实现长连接"></a>client如何实现长连接</h1><blockquote><p>net.Dialer.KeepAlive：开启长连接（说明默认http client是默认开启长连接的)</p></blockquote><h1 id="主协程如何等其余协程完再操作"><a href="#主协程如何等其余协程完再操作" class="headerlink" title="主协程如何等其余协程完再操作"></a>主协程如何等其余协程完再操作</h1><ul><li><code>channel</code>实现同步</li><li><code>sync.WaitGroup</code></li></ul><h1 id="slice，len，cap，共享，扩容"><a href="#slice，len，cap，共享，扩容" class="headerlink" title="slice，len，cap，共享，扩容"></a>slice，len，cap，共享，扩容</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>slice</code>的<code>len==cap</code>后，再向<code>slice</code>中追加元素时，会发生扩容</p><p>扩容遵循如下规则：（但结果不完全遵循此规则）</p><ul><li>如果原<code>slice</code>容量小于1024，则新<code>slice</code>容量将扩大为原来的<code>2</code>倍；</li><li>如果原<code>slice</code>容量大于等于1024，则新<code>slice</code>容量将扩大为原来的<code>1.25</code>倍；</li><li>如果扩容后的大小仍不能满足，那么直接扩容到所需的容量</li><li>在以上计算完新<code>slice</code>容量后，交由管理内存的组件申请内存，按照给出的表向上取整进行内存申请，申请出来的内存长度，作为<code>slice</code>扩容后的容量</li></ul><h1 id="map如何顺序读取"><a href="#map如何顺序读取" class="headerlink" title="map如何顺序读取"></a>map如何顺序读取</h1><blockquote><p>由于map底层实现与 slice不同, map底层使用<code>hash</code>表实现,<strong>插入数据位置是随机的</strong>, 所以遍历过程中新插入的数据不能保证遍历。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    m[<span class="string">"b"</span>] = <span class="string">"2"</span></span><br><span class="line">    m[<span class="string">"a"</span>] = <span class="string">"1"</span></span><br><span class="line">    m[<span class="string">"c"</span>] = <span class="string">"3"</span></span><br><span class="line"></span><br><span class="line">    keys := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(m))</span><br><span class="line">    <span class="keyword">for</span> k, _ := <span class="keyword">range</span> m &#123;</span><br><span class="line">        keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort.Strings(keys)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Key:%+v, Value:%+v\n"</span>, k, m[k])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对 key 排序</strong>，那么我们便可将 map 的 key 全部拿出来，放到一个数组中，然后对这个数组排序后对有序数组遍历，再间接取 map 里的值就行了。</p><h1 id="大文件排序"><a href="#大文件排序" class="headerlink" title="大文件排序"></a>大文件排序</h1><ul><li>随机数</li><li>类型转换</li><li>文件操作</li><li><code>priorityqueue</code>优先级队列</li></ul><h1 id="基本排序，哪些是稳定的"><a href="#基本排序，哪些是稳定的" class="headerlink" title="基本排序，哪些是稳定的"></a>基本排序，哪些是稳定的</h1><ul><li><p>常见的7种排序算法</p><ul><li>选择排序</li><li>冒泡排序</li><li>插入排序</li><li>希尔排序</li><li>归并排序  </li><li>快速排序 </li><li>堆排序</li></ul></li><li><p>稳定的排序算法</p><ul><li>冒泡排序</li><li>插入排序</li><li>归并排序  </li></ul></li></ul><h1 id="http-get跟head"><a href="#http-get跟head" class="headerlink" title="http get跟head"></a>http get跟head</h1><p>HTTP协议中GET、POST和HEAD的区别？ <strong>HEAD： 只请求页面的首部。 GET： 请求指定的页面信息，并返回实体主体</strong>。 POST： 请求服务器接受所指定的文档作为对所标识的URL.</p><h1 id="http-keep-alive"><a href="#http-keep-alive" class="headerlink" title="http keep-alive"></a>http keep-alive</h1><p>当使用<code>Keep-Alive</code>模式（又称持久连接、连接重用）时，<code>Keep-Alive</code>功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，<code>Keep-Alive</code>功能避免了建立或者重新建立连接</p><h1 id="http能不能一次连接多次请求，不等后端返回"><a href="#http能不能一次连接多次请求，不等后端返回" class="headerlink" title="http能不能一次连接多次请求，不等后端返回"></a>http能不能一次连接多次请求，不等后端返回</h1><p>如果是<code>http1.0</code>，一个tcp连接只能发一个<code>http</code>请求，如果是<code>http1.1</code>及以上，引入了持续连接的概念，所以一个<code>tcp</code>连接能发多个<code>http</code>请求。</p><h1 id="linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程"><a href="#linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程" class="headerlink" title="linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程"></a>linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程</h1><ul><li>查看端口占用</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lsof</span></span><br><span class="line">lsof -i:端口号</span><br><span class="line"></span><br><span class="line"><span class="comment">// netstat</span></span><br><span class="line">netstat -tunlp | grep 端口号</span><br></pre></td></tr></table></figure><ul><li>查看cpu负载</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"></span><br><span class="line">vmstat <span class="number">1</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">sar -u <span class="number">1</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">iostat -c <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">dstat -c</span><br></pre></td></tr></table></figure><ul><li>查看内存占用</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df -m</span><br><span class="line"></span><br><span class="line">free</span><br><span class="line"></span><br><span class="line">cat /proc/meminfo</span><br><span class="line"></span><br><span class="line">ps aux -sort -rss</span><br><span class="line"></span><br><span class="line">vmstat -s</span><br></pre></td></tr></table></figure><h1 id="git文件版本，使用顺序，merge跟rebase"><a href="#git文件版本，使用顺序，merge跟rebase" class="headerlink" title="git文件版本，使用顺序，merge跟rebase"></a>git文件版本，使用顺序，merge跟rebase</h1><ul><li>使用 rebase 和 merge 的基本原则：<ul><li>下游分支更新上游分支内容的时候使用 <code>rebase</code></li><li>上游分支合并下游分支内容的时候使用 <code>merge</code></li><li>更新当前分支的内容时一定要使用 <code>--rebase</code> 参数</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一些杂的内容&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://blog.caoxl.com/categories/Golang/"/>
    
    
      <category term="golang" scheme="http://blog.caoxl.com/tags/golang/"/>
    
      <category term="go" scheme="http://blog.caoxl.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 面试题 IV</title>
    <link href="http://blog.caoxl.com/2022/10/19/Golang-Interview-IV/"/>
    <id>http://blog.caoxl.com/2022/10/19/Golang-Interview-IV/</id>
    <published>2022-10-19T07:44:19.000Z</published>
    <updated>2022-10-24T08:45:18.895Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>坚持, 量变才会引起质变</p></blockquote><a id="more"></a><h1 id="new和make的区别？"><a href="#new和make的区别？" class="headerlink" title="new和make的区别？"></a><code>new</code>和<code>make</code>的区别？</h1><ul><li><code>new</code>只用于分配内存，返回一个指向地址的指针。它为每个新类型分配一片内存，初始化为0且返回类型<code>*T</code>的<strong>内存地址</strong>，它相当于<code>&amp;T{}</code></li><li><code>make</code>只可用于<code>slice</code>,<code>map</code>,<code>channel</code>的初始化,返回的是<strong>引用</strong>。</li></ul><h1 id="Go面向对象是如何实现的？"><a href="#Go面向对象是如何实现的？" class="headerlink" title="Go面向对象是如何实现的？"></a>Go面向对象是如何实现的？</h1><p>Go实现面向对象的两个关键是<code>struct</code>和<code>interface</code>。</p><ul><li>封装：对于同一个包，对象对包内的文件可见；对不同的包，需要将对象以大写开头才是可见的。</li><li>继承: 继承是编译时特征，在struct内加入所需要继承的类即可; (组合)</li><li>多态: 多态是运行时特征，Go多态通过<code>interface</code>来实现。类型和接口是松耦合的，某个类型的实例可以赋给它所实现的任意接口类型的变量。</li></ul><p>Go支持多重继承，就是在类型中嵌入所有必要的父类型。</p><h1 id="uint型变量值分别为-1，2，它们相减的结果是多少？"><a href="#uint型变量值分别为-1，2，它们相减的结果是多少？" class="headerlink" title="uint型变量值分别为 1，2，它们相减的结果是多少？"></a>uint型变量值分别为 1，2，它们相减的结果是多少？</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> a <span class="keyword">uint</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">uint</span> = <span class="number">2</span></span><br><span class="line">fmt.Println(a - b)</span><br></pre></td></tr></table></figure><blockquote><p>结果会溢出，如果是32位系统，结果是<code>2^32-1</code>，如果是64位系统，结果<code>2^64-1</code></p></blockquote><h1 id="有没有函数在main之前执行？怎么用？"><a href="#有没有函数在main之前执行？怎么用？" class="headerlink" title="有没有函数在main之前执行？怎么用？"></a>有没有函数在main之前执行？怎么用？</h1><blockquote><p>init函数</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>init函数非常特殊：<ul><li>初始化不能采用初始化表达式初始化的变量</li><li>程序运行前执行注册 </li><li>实现<code>sync.Once</code>功能</li><li>不能被其它函数调用</li><li><code>init</code>函数没有入口参数和返回值</li><li>每个包可以有多个<code>init</code>函数，每个源文件也可以有多个<code>init</code>函数</li><li>同一个包的<code>init</code>执行顺序，<code>golang</code>没有明确定义，编程时要注意程序不要依赖这个执行顺序</li><li>不同包的<code>init</code>函数按照包导入的依赖关系决定执行顺序</li></ul></li></ul><h1 id="下面这句代码是什么作用，为什么要定义一个空值？"><a href="#下面这句代码是什么作用，为什么要定义一个空值？" class="headerlink" title="下面这句代码是什么作用，为什么要定义一个空值？"></a>下面这句代码是什么作用，为什么要定义一个空值？</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GobCodec <span class="keyword">struct</span> &#123;</span><br><span class="line">    conn io.ReadWriteCloser</span><br><span class="line">    buf  *bufio.Writer</span><br><span class="line">    dec  *gob.Decoder</span><br><span class="line">    enc  *gob.Encoder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Codec <span class="keyword">interface</span> &#123;</span><br><span class="line">    io.Closer</span><br><span class="line">    ReadHeader(*Header) error</span><br><span class="line">    ReadBody(<span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">    Write(*Header, <span class="keyword">interface</span>&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ Codec = (*GobCodec)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><blockquote><p>将<code>nil</code>转换为<code>*GobCodec</code>类型，然后再转换为<code>Codec</code>接口，如果转换失败，说明<code>*GobCodec</code>没有实现<code>Codec</code>接口的所有方法。</p></blockquote><h1 id="mutex有几种模式？"><a href="#mutex有几种模式？" class="headerlink" title="mutex有几种模式？"></a>mutex有几种模式？</h1><blockquote><p><code>mutex</code>有两种模式：<code>normal</code> 和 <code>starvation</code></p></blockquote><h2 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h2><p>所有<code>goroutine</code>按照<code>FIFO</code>的顺序进行锁获取，被唤醒的<code>goroutine</code>和新请求锁的<code>goroutine</code>同时进行锁获取，通常<strong>新请求锁的<code>goroutine</code>更容易获取锁</strong>(持续占有cpu)，被唤醒的<code>goroutine</code>则不容易获取到锁。公平性：否。</p><h2 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h2><p>所有尝试获取锁的<code>goroutine</code>进行等待排队，新请求锁的<code>goroutine</code>不会进行锁获取(禁用自旋)，而是加入队列尾部等待获取锁。公平性：是。</p><h1 id="go如何进行调度的。GMP中状态流转"><a href="#go如何进行调度的。GMP中状态流转" class="headerlink" title="go如何进行调度的。GMP中状态流转"></a>go如何进行调度的。GMP中状态流转</h1><p>Go里面GMP分别代表：G：<code>goroutine</code>，M：<code>线程</code>（真正在CPU上跑的），P：<code>调度器</code>。</p><blockquote><p>调度器是M和G之间桥梁。</p></blockquote><p>go进行调度过程</p><ul><li>某个线程尝试创建一个新的<code>G</code>，那么这个G就会被安排到这个线程的<code>G</code>本地队列<code>LRQ</code>中，如果<code>LRQ</code>满了，就会分配到全局队列<code>GRQ</code>中；</li><li>尝试获取当前线程的<code>M</code>，如果无法获取，就会从空闲的<code>M</code>列表中找一个，如果空闲列表也没有，那么就创建一个<code>M</code>，然后绑定<code>G</code>与<code>P</code>运行。</li><li>进入调度循环：<ul><li>找到一个合适的<code>G</code></li><li>执行<code>G</code>，完成以后退出</li></ul></li></ul><h1 id="Go什么时候发生阻塞？阻塞时，调度器会怎么做。"><a href="#Go什么时候发生阻塞？阻塞时，调度器会怎么做。" class="headerlink" title="Go什么时候发生阻塞？阻塞时，调度器会怎么做。"></a>Go什么时候发生阻塞？阻塞时，调度器会怎么做。</h1><ul><li>用于<strong>原子、互斥量或通道</strong>操作导致<code>goroutine</code>阻塞，调度器将把当前阻塞的<code>goroutine</code>从本地运行队列<code>LRQ</code>换出，并重新调度其它<code>goroutine</code>；</li><li>由于<strong>网络请求</strong>和<strong>IO</strong>导致的阻塞，Go提供了网络轮询器（<code>Netpoller</code>）来处理，后台用<code>epoll</code>等技术实现IO多路复用</li></ul><p>其他回答</p><ul><li><strong>channel阻塞</strong>: 当goroutine读写channel发生阻塞时，会调用<code>gopark</code>函数，该G脱离当前的M和P，调度器将新的G放入当前M。</li><li><strong>系统调用</strong>: 当某个G由于系统调用陷入内核态，该P就会脱离当前M，此时P会更新自己的状态为<code>Psyscall</code>，M与G相互绑定，进行系统调用。结束以后，若该P状态还是<code>Psyscall</code>，则直接关联该M和G，否则使用闲置的处理器处理该G。</li><li><strong>系统监控</strong>: 当某个G在P上运行的时间超过10ms时候，或者P处于<code>Psyscall</code>状态过长等情况就会调用<code>retake</code>函数，触发新的调度。</li><li><strong>主动让出</strong>: 由于是协作式调度，该G会主动让出当前的P（通过<code>GoSched</code>），更新状态为<code>Grunnable</code>，该P会调度队列中的G运行。</li></ul><h1 id="如果有一个G一直占用资源怎么办？"><a href="#如果有一个G一直占用资源怎么办？" class="headerlink" title="如果有一个G一直占用资源怎么办？"></a>如果有一个G一直占用资源怎么办？</h1><p>如果有个<code>goroutine</code>一直占用资源，那么GMP模型会<strong>从正常模式转变为饥饿模式</strong>（类似于mutex），允许其它<code>goroutine</code>使用<code>work stealing</code>抢占（禁用自旋锁）。</p><h2 id="什么是work-stealing算法？"><a href="#什么是work-stealing算法？" class="headerlink" title="什么是work stealing算法？"></a>什么是<code>work stealing</code>算法？</h2><p>指，一个线程如果处于空闲状态，则帮其它正在忙的线程分担压力，从全局队列取一个G任务来执行，可以极大提高执行效率。</p><h1 id="Go竞态条件了解吗？"><a href="#Go竞态条件了解吗？" class="headerlink" title="Go竞态条件了解吗？"></a>Go竞态条件了解吗？</h1><blockquote><p>所谓竞态竞争，就是<strong>当两个或以上的goroutine访问相同资源时候，对资源进行读/写</strong>。</p></blockquote><p>比如<code>var a int = 0</code>，有两个协程分别对<code>a+=1</code>，我们发现<strong>最后a不一定为2</strong>.这就是<strong>竞态竞争</strong>。</p><p>通常我们可以用<code>go run -race xx.go</code>来进行检测。</p><blockquote><p>解决方法是，对临界区资源上锁，或者使用原子操作(atomics)，原子操作的开销小于上锁。</p></blockquote><h1 id="如果若干个goroutine，有一个panic会怎么做？"><a href="#如果若干个goroutine，有一个panic会怎么做？" class="headerlink" title="如果若干个goroutine，有一个panic会怎么做？"></a>如果若干个goroutine，有一个panic会怎么做？</h1><p>有一个<code>panic</code>，那么剩余<code>goroutine</code>也会退出，程序退出。如果不想程序退出，那么必须通过调用 <code>recover()</code> 方法来捕获 <code>panic</code> 并恢复将要崩掉的程序。</p><h1 id="defer可以捕获goroutine的子goroutine吗？"><a href="#defer可以捕获goroutine的子goroutine吗？" class="headerlink" title="defer可以捕获goroutine的子goroutine吗？"></a><code>defer</code>可以捕获<code>goroutine</code>的子<code>goroutine</code>吗？</h1><blockquote><p>不可以<br>它们处于不同的调度器P中。对于<code>子goroutine</code>，必须通过 <code>recover()</code> 机制来进行恢复，然后结合日志进行打印（或者通过channel传递error），下面是一个例子：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ping 心跳函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Ping</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... code ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Println(ctx, <span class="string">"ping panic: %v, stack: %v"</span>, r, <span class="keyword">string</span>(debug.Stack()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... code ...</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... code ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Go解析Tag是怎么实现的？"><a href="#Go解析Tag是怎么实现的？" class="headerlink" title="Go解析Tag是怎么实现的？"></a>Go解析Tag是怎么实现的？</h1><blockquote><p>Go解析tag采用的是<strong>反射</strong>。<br>具体来说使用<code>reflect.ValueOf</code>方法获取其反射值，然后获取其<code>Type</code>属性，之后再通过<code>Field(i)</code>获取第<code>i+1</code>个field，再<code>.Tag</code>获得Tag。<br>反射实现的原理在: <code>src/reflect/type.go</code>中</p></blockquote><h1 id="channel死锁的场景"><a href="#channel死锁的场景" class="headerlink" title="channel死锁的场景"></a><code>channel</code>死锁的场景</h1><p>当一个<code>channel</code>中没有数据，而直接读取时，会发生死锁：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">2</span>)</span><br><span class="line">&lt;-q</span><br></pre></td></tr></table></figure><p>解决方案是采用<code>select</code>语句，再<code>default</code>放默认处理方式：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line">   <span class="keyword">case</span> val:=&lt;-q:</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="说说-atomic底层怎么实现的"><a href="#说说-atomic底层怎么实现的" class="headerlink" title="说说 atomic底层怎么实现的"></a>说说 atomic底层怎么实现的</h1><blockquote><p><code>atomic</code>源码位于<code>sync\atomic</code>。通过阅读源码可知，atomic采用<code>CAS（CompareAndSwap）</code>的方式实现的。<br>所谓<code>CAS</code>就是使用了<code>CPU</code>中的原子性操作。在操作共享变量的时候，<code>CAS</code>不需要对其进行加锁，而是通过类似于乐观锁的方式进行检测，总是假设被操作的值未曾改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换。本质上是不断占用<code>CPU</code>资源来避免加锁的开销。</p></blockquote><h1 id="go的调试-分析工具用过哪些"><a href="#go的调试-分析工具用过哪些" class="headerlink" title="go的调试/分析工具用过哪些"></a>go的调试/分析工具用过哪些</h1><ul><li>go的自带工具链相当丰富<ul><li><code>go cover</code>: 测试代码覆盖率</li><li><code>pprof</code>: 用于性能调优，针对cpu，内存和并发；</li><li><code>godoc</code>: 用于生成go文档</li><li><code>race</code>：用于竞争检测</li></ul></li></ul><h1 id="实现使用字符串函数名，调用函数。"><a href="#实现使用字符串函数名，调用函数。" class="headerlink" title="实现使用字符串函数名，调用函数。"></a>实现使用字符串函数名，调用函数。</h1><blockquote><p>采用反射的Call方法实现。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Eat"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := Animal&#123;&#125;</span><br><span class="line">    reflect.ValueOf(&amp;a).MethodByName(<span class="string">"Eat"</span>).Call([]reflect.Value&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;坚持, 量变才会引起质变&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://blog.caoxl.com/categories/Golang/"/>
    
    
      <category term="golang" scheme="http://blog.caoxl.com/tags/golang/"/>
    
      <category term="go" scheme="http://blog.caoxl.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 面试题 III</title>
    <link href="http://blog.caoxl.com/2022/10/17/Golang-Interview-III/"/>
    <id>http://blog.caoxl.com/2022/10/17/Golang-Interview-III/</id>
    <published>2022-10-17T09:17:50.000Z</published>
    <updated>2022-10-18T02:02:31.261Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>在面试题中成长,在笔试题中查漏补缺</p></blockquote><a id="more"></a><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="Q1-和-的区别？"><a href="#Q1-和-的区别？" class="headerlink" title="Q1 = 和 := 的区别？"></a>Q1 <code>=</code> 和 <code>:=</code> 的区别？</h2><blockquote><p><code>:=</code> 声明+赋值<br><code>=</code> 仅赋值</p></blockquote><h2 id="Q2-指针的作用"><a href="#Q2-指针的作用" class="headerlink" title="Q2 指针的作用"></a>Q2 指针的作用</h2><blockquote><p>指针用来保存变量的地址。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = &amp;x</span><br><span class="line">fmt.Printf(<span class="string">"x = %d"</span>,  *p) <span class="comment">// x 可以用 *p 访问</span></span><br></pre></td></tr></table></figure><ul><li><code>*</code>运算符: 也称为解引用运算符，用于访问地址中的值。</li><li><code>&amp;</code>运算符: 也称为地址运算符，用于返回变量的地址</li></ul><h2 id="Q3-Go允许多个返回值吗？"><a href="#Q3-Go允许多个返回值吗？" class="headerlink" title="Q3 Go允许多个返回值吗？"></a>Q3 Go允许多个返回值吗？</h2><blockquote><p>允许</p></blockquote><h2 id="Q4-Go有异常类型吗？"><a href="#Q4-Go有异常类型吗？" class="headerlink" title="Q4 Go有异常类型吗？"></a>Q4 Go有异常类型吗？</h2><blockquote><p>Go 没有异常类型，只有错误类型（Error），通常使用返回值来表示异常状态。<br><code>panic</code>支持抛出任意类型的异常（而不仅仅是 <code>error</code> 类型的错误），<code>recover</code> 函数调用的返回值和 <code>panic</code> 函数的输入参数类型一致，它们的函数签名如下：</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panic</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recover</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>捕获异常转成错误</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> x := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">                err = errors.New(x)</span><br><span class="line">            <span class="keyword">case</span> error:</span><br><span class="line">                err = x</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                err = fmt.Errorf(<span class="string">"Unknown panic: %v"</span>, r)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"TODO"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q5-什么是协程（Goroutine）"><a href="#Q5-什么是协程（Goroutine）" class="headerlink" title="Q5 什么是协程（Goroutine）"></a>Q5 什么是协程（Goroutine）</h2><blockquote><p><code>Goroutine</code> 是与其他函数或方法同时运行的函数或方法。<br><code>Goroutines</code> 可以被认为是轻量级的线程。<br>与线程相比，创建 <code>Goroutine</code> 的开销很小。Go应用程序同时运行数千个 <code>Goroutine</code> 是非常常见的做法。</p></blockquote><h2 id="Q6-如何高效地拼接字符串"><a href="#Q6-如何高效地拼接字符串" class="headerlink" title="Q6 如何高效地拼接字符串"></a>Q6 如何高效地拼接字符串</h2><p>Go 语言中，字符串是只读的，也就意味着每次修改操作都会创建一个新的字符串。如果需要拼接多次，应使用 <code>strings.Builder</code>，最小化内存拷贝次数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">    str.WriteString(<span class="string">"a"</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(str.String())</span><br></pre></td></tr></table></figure><h2 id="Q7-什么是-rune-类型"><a href="#Q7-什么是-rune-类型" class="headerlink" title="Q7 什么是 rune 类型"></a>Q7 什么是 <code>rune</code> 类型</h2><blockquote><p><code>rune</code>是Go语言中一种特殊的数据类型,它是<code>int32</code>的别名,几乎在所有方面等同于<code>int32</code>,用于区分字符值和整数值。<br>补充：golang中的字符有两种，uint8（byte）代表ASCII的一个字符，<code>rune</code>代表一个utf-8字符。</p></blockquote><h2 id="Q8-如何判断map中是否包含某个key？"><a href="#Q8-如何判断map中是否包含某个key？" class="headerlink" title="Q8 如何判断map中是否包含某个key？"></a>Q8 如何判断<code>map</code>中是否包含某个<code>key</code>？</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> val, ok := dict[<span class="string">"foo"</span>]; ok &#123;</span><br><span class="line">    <span class="comment">//do something here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>dict[&quot;foo&quot;]</code> 有 2 个返回值，val 和 ok，如果 ok 等于 true，则说明 <code>dict</code> 包含 key “foo”，val 将被赋予 “foo” 对应的值。</p></blockquote><h2 id="Q9-Go支持默认参数或可选参数吗？"><a href="#Q9-Go支持默认参数或可选参数吗？" class="headerlink" title="Q9 Go支持默认参数或可选参数吗？"></a>Q9 Go支持默认参数或可选参数吗？</h2><blockquote><p><code>Go</code>语言不支持可选参数（Python, PHP 支持），也不支持方法重载（Java支持）。<br>Go支持可变参数</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(args ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, arg := <span class="keyword">range</span> args &#123;</span><br><span class="line">        fmt.Println(arg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形如<code>...type</code>格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数，它是一个语法糖（<code>syntactic sugar</code>），即这种语法对语言的功能并没有影响，但是更方便程序员使用，通常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的可能。</p><p>从内部实现机理上来说，类型<code>...type</code>本质上是一个数组切片，也就是<code>[]type</code>，这也是为什么上面的参数 <code>args</code> 可以用 <code>for</code> 循环来获得每个传入的参数。</p><h2 id="Q10-defer-的执行顺序"><a href="#Q10-defer-的执行顺序" class="headerlink" title="Q10 defer 的执行顺序"></a>Q10 <code>defer</code> 的执行顺序</h2><blockquote><p>多个 <code>defer</code> 语句，遵从<strong>后进先出</strong>(<code>Last In First Out，LIFO</code>)的原则，最后声明的 <code>defer</code> 语句，最先得到执行。<br><code>defer</code> 在 <code>return</code> 语句之后执行，但在函数退出之前，<code>defer</code> 可以修改返回值。</p></blockquote><h2 id="Q11-如何交换2个变量的值？"><a href="#Q11-如何交换2个变量的值？" class="headerlink" title="Q11 如何交换2个变量的值？"></a>Q11 如何交换2个变量的值？</h2><blockquote><p>x, y := y, x</p></blockquote><h2 id="Q12-Go语言tag的用处？"><a href="#Q12-Go语言tag的用处？" class="headerlink" title="Q12 Go语言tag的用处？"></a>Q12 Go语言<code>tag</code>的用处？</h2><blockquote><p><code>tag</code> 可以理解为 <code>struct</code> 字段的注解，可以用来定义字段的一个或多个属性。框架/工具可以通过<strong>反射</strong>获取到某个字段定义的属性，采取相应的处理方式。</p></blockquote><h2 id="Q13-如何判断2个字符串切片（slice-是相等的？"><a href="#Q13-如何判断2个字符串切片（slice-是相等的？" class="headerlink" title="Q13 如何判断2个字符串切片（slice) 是相等的？"></a>Q13 如何判断<code>2</code>个字符串切片（<code>slice</code>) 是相等的？</h2><blockquote><p>go 语言中可以使用反射 <code>reflect.DeepEqual(a, b)</code> 判断 a、b 两个切片是否相等，但是通常不推荐这么做，使用反射非常影响性能。</p></blockquote><p>通常采用的方式如下，遍历比较切片中的每一个元素（注意处理越界的情况）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringSliceEqualBCE</span><span class="params">(a, b []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(a) != <span class="built_in">len</span>(b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nil</span>) != (b == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b = b[:<span class="built_in">len</span>(a)]</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">if</span> v != b[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q14-字符串打印时，-v-和-v和-v-的区别"><a href="#Q14-字符串打印时，-v-和-v和-v-的区别" class="headerlink" title="Q14 字符串打印时，%v 和 %+v和 %#v 的区别"></a>Q14 字符串打印时，<code>%v</code> 和 <code>%+v</code>和 <code>%#v</code> 的区别</h2><blockquote><p><code>%v</code> 和 <code>%+v</code> 和 <code>%#v</code> 都可以用来打印 struct 的值</p></blockquote><ul><li>区别在于: <ul><li><code>%v</code> 仅打印各个字段的值</li><li><code>%+v</code> 还会打印各个字段的名称。</li><li><code>%#v</code> 还会打印结构体的名称</li></ul></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, Stu&#123;<span class="string">"Tom"</span>&#125;)  <span class="comment">// &#123;Tom&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, Stu&#123;<span class="string">"Tom"</span>&#125;) <span class="comment">// &#123;Name:Tom&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, Stu&#123;<span class="string">"Tom"</span>&#125;) <span class="comment">// main.Stu&#123;Name:"Tom"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q15-Go-语言中如何表示枚举值-enums-？"><a href="#Q15-Go-语言中如何表示枚举值-enums-？" class="headerlink" title="Q15 Go 语言中如何表示枚举值(enums)？"></a>Q15 Go 语言中如何表示枚举值(enums)？</h2><blockquote><p>通常使用常量(const) 来表示枚举值。</p></blockquote><h2 id="Q16-空struct-的用途"><a href="#Q16-空struct-的用途" class="headerlink" title="Q16 空struct{}的用途"></a>Q16 空<code>struct{}</code>的用途</h2><blockquote><p>使用空结构体 <code>struct{}</code> 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(unsafe.Sizeof(<span class="keyword">struct</span>&#123;&#125;&#123;&#125;)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>比如使用 <code>map</code> 表示集合时，只关注 <code>key</code>，<code>value</code> <strong>可以使用 <code>struct{}</code> 作为占位符</strong>。如果使用其他类型作为占位符，例如 <code>int</code>，<code>bool</code>，不仅浪费了内存，而且容易引起歧义。</p><p>再比如，使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 <code>struct{}</code> 代替。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;()</span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="Q17-init-函数是什么时候执行的？"><a href="#Q17-init-函数是什么时候执行的？" class="headerlink" title="Q17 init()函数是什么时候执行的？"></a>Q17 <code>init()</code>函数是什么时候执行的？</h2><blockquote><p><code>init()</code>函数是 Go 程序初始化的一部分。<br><strong>Go程序初始化先于 <code>main</code> 函数</strong>，由 <code>runtime</code> 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p></blockquote><p>一句话总结：<code>import</code> –&gt; <code>const</code> –&gt; <code>var</code> –&gt;<code>init()</code> -&gt; <code>main()</code></p><p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的<code>init()</code>函数。同一个包，甚至是同一个源文件可以有多个<code>init()</code>函数。<code>init()</code>函数没有入参和返回值，不能被其他函数调用，同一个包内多个<code>init()</code>函数的执行顺序不作保证。</p><h2 id="Q18-Go语言的局部变量分配在栈上还是堆上？"><a href="#Q18-Go语言的局部变量分配在栈上还是堆上？" class="headerlink" title="Q18 Go语言的局部变量分配在栈上还是堆上？"></a>Q18 Go语言的局部变量分配在栈上还是堆上？</h2><blockquote><p>由编译器决定。<br>Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做<strong>逃逸分析</strong>(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    v := <span class="number">11</span></span><br><span class="line">    <span class="keyword">return</span> &amp;v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := foo()</span><br><span class="line">    <span class="built_in">println</span>(*m) <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>foo()</code>函数中，如果 v 分配在栈上，<code>foo</code> 函数返回时，<code>&amp;v</code>就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 <code>foo</code> 的作用域，会将其分配在堆上。因此，<code>main</code> 函数中仍能够正常访问该值。</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ul><li><code>-gcflags=-m</code></li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> run -gcflags=-m echo.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./echo.<span class="keyword">go</span>:<span class="number">3</span>:<span class="number">6</span>: can inline foo</span><br><span class="line">./echo.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">6</span>: can inline main</span><br><span class="line">./echo.<span class="keyword">go</span>:<span class="number">9</span>:<span class="number">10</span>: inlining call to foo</span><br><span class="line">./echo.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">2</span>: moved to heap: v</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://geektutu.com/post/hpg-escape-analysis.html" target="_blank" rel="noopener">参考 - Go 逃逸分析</a></li></ul><h2 id="Q19-2个interface可以比较吗"><a href="#Q19-2个interface可以比较吗" class="headerlink" title="Q19 2个interface可以比较吗"></a>Q19 2个<code>interface</code>可以比较吗</h2><blockquote><p>可以<br>Go 语言中，<code>interface</code> 的内部实现包含了 2 个字段，类型<code>T</code>和 值<code>V</code>，<code>interface</code> 可以使用<code>==</code>或<code>!=</code>比较。2 个 <code>interface</code> 相等有以下 2 种情况</p></blockquote><ol><li>两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</li><li>类型 T 相同，且对应的值 V 相等。</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StuInt <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> stu1, stu2 StuInt = &amp;Stu&#123;<span class="string">"Tom"</span>&#125;, &amp;Stu&#123;<span class="string">"Tom"</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> stu3, stu4 StuInt = Stu&#123;<span class="string">"Tom"</span>&#125;, Stu&#123;<span class="string">"Tom"</span>&#125;</span><br><span class="line">    fmt.Println(stu1 == stu2) <span class="comment">// false</span></span><br><span class="line">    fmt.Println(stu3 == stu4) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stu1</code>和<code>stu2</code>对应的类型是<code>*Stu</code>，值是 <code>Stu</code> 结构体的地址，两个地址不同，因此结果为 <strong>false</strong>。<br><code>stu3</code>和<code>stu4</code>对应的类型是<code>Stu</code>，值是 <code>Stu</code> 结构体，且各字段相等，因此结果为 <strong>true</strong>。</p><h2 id="Q20-2个nil可能不相等吗？"><a href="#Q20-2个nil可能不相等吗？" class="headerlink" title="Q20 2个nil可能不相等吗？"></a>Q20 2个<code>nil</code>可能不相等吗？</h2><blockquote><p>可能</p></blockquote><blockquote><p>接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型<code>T</code>和 值<code>V</code>。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。</p></blockquote><ul><li>两个接口值比较时，会先比较 T，再比较 V。</li><li>接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = p</span><br><span class="line">    fmt.Println(i == p)   <span class="comment">// true</span></span><br><span class="line">    fmt.Println(p == <span class="literal">nil</span>) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(i == <span class="literal">nil</span>) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为<code>(T=*int, V=nil)</code>，i 与 p 作比较时，将 p 转换为接口后再比较，因此<code>i == p</code>，p 与 nil 比较，直接比较值，所以<code>p == nil</code>。</p><p>但是当 i 与 nil 比较时，会将 nil 转换为接口<code>(T=nil, V=nil)</code>，与i<code>(T=*int, V=nil)</code>不相等，因此<code>i != nil</code>。</p><p><strong>因此 <code>V</code> 为 <code>nil</code> ，但 <code>T</code> 不为 <code>nil</code> 的接口不等于 nil。</strong></p><h2 id="Q21-简述-Go-语言GC-垃圾回收-的工作原理"><a href="#Q21-简述-Go-语言GC-垃圾回收-的工作原理" class="headerlink" title="Q21 简述 Go 语言GC(垃圾回收)的工作原理"></a>Q21 简述 Go 语言GC(垃圾回收)的工作原理</h2><blockquote><p>最常见的垃圾回收算法有<strong>标记清除</strong>(Mark-Sweep) 和<strong>引用计数</strong>(Reference Count)，<strong>Go 语言采用的是标记清除算法</strong>。并在此基础上使用了<strong>三色标记法</strong>和<strong>写屏障技术</strong>，提高了效率。</p></blockquote><p>一次完整的 GC 分为四个阶段：</p><ul><li>1) 标记准备(<code>Mark Setup</code>, 需STW), 打开写屏障(<code>Write Barrier</code>)</li><li>2) 使用三色标记法去标记(<code>Marking</code>, 并发)    </li><li>3) 标记结束(<code>Mark Termination</code>, 需STW), 关闭写屏障</li><li>4) 清理(<code>Sweeping</code>, 并发)</li></ul><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：</p><ul><li>标记阶段: 从根对象出发查找并标记堆中所有存活的对象；</li><li>清除阶段: 遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。</li></ul><h3 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h3><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类。</p><ul><li>白色: 不确定对象</li><li>灰色: 存活对象, 子对象待处理</li><li>黑色: 存活对象</li></ul><h2 id="Q22-函数返回局部变量的指针是否安全？"><a href="#Q22-函数返回局部变量的指针是否安全？" class="headerlink" title="Q22 函数返回局部变量的指针是否安全？"></a>Q22 函数返回局部变量的指针是否安全？</h2><blockquote><p>这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。<strong>如果发现局部变量的作用域超出该函数，则不会将内存分配在栈(stack)上，而是分配在堆(heap)上。</strong></p></blockquote><h2 id="Q23-非接口的任意类型T-都能够调用-T的方法吗？反过来呢？"><a href="#Q23-非接口的任意类型T-都能够调用-T的方法吗？反过来呢？" class="headerlink" title="Q23 非接口的任意类型T()都能够调用*T的方法吗？反过来呢？"></a>Q23 非接口的任意类型<code>T()</code>都能够调用<code>*T</code>的方法吗？反过来呢？</h2><blockquote><p>一个T类型的值可以调用为<code>*T</code>类型声明的方法，但是仅当此T的值是<strong>可寻址</strong>(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为<strong>不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型<code>*T</code>声明的方法</strong><br>反过来，一个<code>*T</code>类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 <code>T</code> 声明的方法，编译器都会为类型<code>*T</code>自动隐式声明一个同名和同签名的方法。</p></blockquote><h3 id="不可寻址"><a href="#不可寻址" class="headerlink" title="不可寻址"></a>不可寻址</h3><ul><li>字符串中的字节；</li><li>map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）</li><li>常量</li><li>包级别的函数等</li></ul><p>举一个例子，定义类型 <code>T</code>，并为类型<code>*T</code>声明一个方法<code>hello()</code>，变量 <code>t1</code> 可以调用该方法，但是常量 <code>t2</code> 调用该方法时，会产生编译错误。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t1 T = <span class="string">"ABC"</span></span><br><span class="line">    t1.hello() <span class="comment">// hello</span></span><br><span class="line">    <span class="keyword">const</span> t2 T = <span class="string">"ABC"</span></span><br><span class="line">    t2.hello() <span class="comment">// error: cannot call pointer method on t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="Q24-无缓冲的channel和有缓冲的channel的区别？"><a href="#Q24-无缓冲的channel和有缓冲的channel的区别？" class="headerlink" title="Q24 无缓冲的channel和有缓冲的channel的区别？"></a>Q24 无缓冲的<code>channel</code>和有缓冲的<code>channel</code>的区别？</h2><blockquote><p>对于无缓冲的 <code>channel</code>，发送方将<strong>阻塞</strong>该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。<br>对于有缓存的 <code>channel</code>，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    st := time.Now()</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;()</span><br><span class="line">    ch &lt;- <span class="literal">true</span>  <span class="comment">// 无缓冲，发送方阻塞直到接收方接收到数据。</span></span><br><span class="line">    fmt.Printf(<span class="string">"cost %.1f s\n"</span>, time.Now().Sub(st).Seconds())</span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    st := time.Now()</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;()</span><br><span class="line">    ch &lt;- <span class="literal">true</span></span><br><span class="line">    ch &lt;- <span class="literal">true</span>                                                <span class="comment">// 缓冲区为 2，发送方不阻塞，继续往下执行</span></span><br><span class="line">    fmt.Printf(<span class="string">"cost %.1f s\n"</span>, time.Now().Sub(st).Seconds()) <span class="comment">// cost 0.0 s</span></span><br><span class="line">    ch &lt;- <span class="literal">true</span>                                                <span class="comment">// 缓冲区使用完，发送方阻塞，2s 后接收方接收到数据，释放一个插槽，继续往下执行</span></span><br><span class="line">    fmt.Printf(<span class="string">"cost %.1f s\n"</span>, time.Now().Sub(st).Seconds()) <span class="comment">// cost 2.0 s</span></span><br><span class="line">    time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q25-什么是协程泄露-Goroutine-Leak-？"><a href="#Q25-什么是协程泄露-Goroutine-Leak-？" class="headerlink" title="Q25 什么是协程泄露(Goroutine Leak)？"></a>Q25 什么是协程泄露(<code>Goroutine Leak</code>)？</h2><p>协程泄露是指协程创建后，长时间得不到释放，并且还在不断地创建新的协程，最终导致内存耗尽，程序崩溃。常见的导致协程泄露的场景有以下几种：</p><ul><li>缺少接收器，导致发送阻塞</li></ul><p>这个例子中，每执行一次 query，则启动1000个协程向信道 ch 发送数字 0，但只接收了一次，导致 999 个协程被阻塞，不能退出。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">query</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="number">0</span> &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        query()</span><br><span class="line">        fmt.Printf(<span class="string">"goroutines: %d\n"</span>, runtime.NumGoroutine())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>缺少发送器，导致接收阻塞</li></ul><blockquote><p>那同样的，如果启动 1000 个协程接收信道的信息，但信道并不会发送那么多次的信息，也会导致接收协程被阻塞，不能退出。</p></blockquote><ul><li>死锁(<code>dead lock</code>)</li></ul><blockquote><p>两个或两个以上的协程在执行过程中，由于竞争资源或者由于彼此通信而造成阻塞，这种情况下，也会导致协程被阻塞，不能退出。</p></blockquote><ul><li>无限循环(<code>infinite loops</code>)</li></ul><p>这个例子中，为了避免网络等问题，采用了无限重试的方式，发送 HTTP 请求，直到获取到数据。那如果 HTTP 服务宕机，永远不可达，导致协程不能退出，发生泄漏。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(url <span class="keyword">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := http.Get(url); err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// write to db</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> request(fmt.Sprintf(<span class="string">"https://127.0.0.1:8080/%d"</span>, i), &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q26-Go可以限制运行时操作系统线程的数量吗？"><a href="#Q26-Go可以限制运行时操作系统线程的数量吗？" class="headerlink" title="Q26 Go可以限制运行时操作系统线程的数量吗？"></a>Q26 Go可以限制运行时操作系统线程的数量吗？</h2><blockquote><p>可以; 可以使用环境变量 <code>GOMAXPROCS</code> 或 <code>runtime.GOMAXPROCS(num int)</code> 设置</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>) <span class="comment">// 限制同时执行Go代码的操作系统线程数为 1</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://blog.51cto.com/u_15300891/3054041" target="_blank" rel="noopener">转载 - Go 语言笔试面试题汇总</a></li><li><a href="https://blog.51cto.com/u_15300891/3053999" target="_blank" rel="noopener">转载 - Go 语言笔试面试题(基础语法)</a></li><li><a href="https://blog.51cto.com/lxw1844912514/5260754" target="_blank" rel="noopener">转载 - Go 语言笔试面试题(实现原理)</a></li><li><a href="https://blog.51cto.com/lxw1844912514/5291739" target="_blank" rel="noopener">转载 - Go 语言笔试面试题(并发编程)</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd67827" target="_blank" rel="noopener">Go 面试题 004：Go 有异常类型吗？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在面试题中成长,在笔试题中查漏补缺&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://blog.caoxl.com/categories/Golang/"/>
    
    
      <category term="golang" scheme="http://blog.caoxl.com/tags/golang/"/>
    
      <category term="go" scheme="http://blog.caoxl.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 面试题 II</title>
    <link href="http://blog.caoxl.com/2022/10/14/Golang-Interview-II/"/>
    <id>http://blog.caoxl.com/2022/10/14/Golang-Interview-II/</id>
    <published>2022-10-14T09:02:21.000Z</published>
    <updated>2022-10-14T09:49:28.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本篇来点代码问答</p></blockquote><a id="more"></a><h1 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h1><ul><li>下列代码的输出是：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        a, b = <span class="string">"golang"</span>, <span class="number">100</span></span><br><span class="line">        d, e</span><br><span class="line">        f <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">        g</span><br><span class="line">    )</span><br><span class="line">    fmt.Println(d, e, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>答案:</strong></li></ul><blockquote><p>golang 100 true<br>在同一个 const group 中，如果常量定义与前一行的定义一致，则可以省略类型和值。编译时，会按照前一行的定义自动补全。即等价于</p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        a, b = <span class="string">"golang"</span>, <span class="number">100</span></span><br><span class="line">        d, e = <span class="string">"golang"</span>, <span class="number">100</span></span><br><span class="line">        f <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">        g <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(d, e, g)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下列代码的输出是：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> N = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = N</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> M <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">int</span> = M</span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>答案:</strong></li></ul><blockquote><p>编译失败: cannot use M (constant 100 of type int32) as type int in variable declaration</p></blockquote><blockquote><p>Go 语言中，常量分为无类型常量和有类型常量两种，<code>const N = 100</code>，属于无类型常量，赋值给其他变量时，如果字面量能够转换为对应类型的变量，则赋值成功，例如，<code>var x int = N</code>。但是对于有类型的常量 <code>const M int32 = 100</code>，赋值给其他变量时，需要类型匹配才能成功，所以显示地类型转换：<br>var y int = int(M)</p></blockquote><ul><li>下列代码的输出是：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int8</span> = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int8</span> = <span class="number">-128</span> / a</span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>答案:</strong></li></ul><blockquote><p>-128</p></blockquote><blockquote><p>int8 能表示的数字的范围是 <code>[-2^7, 2^7-1]</code>，即 <code>[-128, 127]</code>。<code>-128</code> 是无类型常量，转换为 <code>int8</code>，再除以变量 <code>-1</code>，结果为 <code>128</code>，常量除以变量，结果是一个变量。变量转换时允许溢出，符号位变为1，转为补码后恰好等于 <code>-128</code>。</p></blockquote><blockquote><p>对于有符号整型，最高位是是符号位，计算机用补码表示负数。补码 = 原码取反加一</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-1 :  11111111</span><br><span class="line">00000001(原码)    11111110(取反)    11111111(加一)</span><br><span class="line">-128：    </span><br><span class="line">10000000(原码)    01111111(取反)    10000000(加一)</span><br><span class="line"></span><br><span class="line">-1 + 1 = 0</span><br><span class="line">11111111 + 00000001 = 00000000(最高位溢出省略)</span><br><span class="line">-128 + 127 = -1</span><br><span class="line">10000000 + 01111111 = 11111111</span><br></pre></td></tr></table></figure><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul><li>下列代码的输出是：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        err := fmt.Errorf(<span class="string">"err"</span>)</span><br><span class="line">        fmt.Println(<span class="number">1</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="number">2</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>答案:</strong></li></ul><blockquote><p>1 err</p></blockquote><blockquote><p><code>:=</code> 表示声明并赋值，<code>=</code> 表示仅赋值。<br>变量的作用域是大括号，因此在第一个 if 语句 <code>if err == nil</code> 内部重新声明且赋值了与外部变量同名的局部变量 err。对该局部变量的赋值不会影响到外部的 err。因此第二个 if 语句 <code>if err != nil</code> 不成立。所以只打印了 1 err。</p></blockquote><h1 id="defer-延迟调用"><a href="#defer-延迟调用" class="headerlink" title="defer 延迟调用"></a>defer 延迟调用</h1><ul><li>下列代码的输出是：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    fmt.Print(n)</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> t T</span><br><span class="line">    <span class="keyword">defer</span> t.f(<span class="number">1</span>).f(<span class="number">2</span>)</span><br><span class="line">    fmt.Print(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>答案:</strong></li></ul><blockquote><p>132<br><code>defer</code> 延迟调用时，需要保存函数指针和参数，因此链式调用的情况下，除了最后一个函数/方法外的函数/方法都会在调用时直接执行。也就是说 <code>t.f(1)</code> 直接执行，然后执行 <code>fmt.Print(3)</code>，最后函数返回时再执行 <code>.f(2)</code>，因此输出是 <code>132</code>。</p></blockquote><ul><li>下列代码的输出是：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(n)</span><br><span class="line">    n += <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1<br>打印 1 而不是 101。<code>defer</code> 语句执行时，会将需要延迟调用的函数和参数保存起来，也就是说，执行到 <code>defer</code> 时，参数 n(此时等于1) 已经被保存了。因此后面对 n 的改动并不会影响延迟函数调用的结果。</p></blockquote><ul><li>下列代码的输出是：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(n)</span><br><span class="line">    &#125;()</span><br><span class="line">    n += <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>101<br>匿名函数没有通过传参的方式将 n 传入，因此匿名函数内的 n 和函数外部的 n 是同一个，延迟执行时，已经被改变为 101。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇来点代码问答&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://blog.caoxl.com/categories/Golang/"/>
    
    
      <category term="golang" scheme="http://blog.caoxl.com/tags/golang/"/>
    
      <category term="go" scheme="http://blog.caoxl.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 再深入 II</title>
    <link href="http://blog.caoxl.com/2022/09/29/Golang-Learn-More-II/"/>
    <id>http://blog.caoxl.com/2022/09/29/Golang-Learn-More-II/</id>
    <published>2022-09-29T04:13:03.000Z</published>
    <updated>2022-09-29T08:27:06.244Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Golang 新手可能会踩的 50 个坑 下</p></blockquote><a id="more"></a><h1 id="在多行-array、slice、map-语句中缺少-号"><a href="#在多行-array、slice、map-语句中缺少-号" class="headerlink" title="在多行 array、slice、map 语句中缺少 , 号"></a>在多行 array、slice、map 语句中缺少 <code>,</code> 号</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>    <span class="comment">// syntax error: unexpected newline, expecting comma or &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    y := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,&#125;</span><br><span class="line">    z := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明语句中 <code>}</code> 折叠到单行后，尾部的 <code>,</code> 不是必需的。</p><h1 id="log-Fatal-和-log-Panic-不只是-log"><a href="#log-Fatal-和-log-Panic-不只是-log" class="headerlink" title="log.Fatal 和 log.Panic 不只是 log"></a><code>log.Fatal</code> 和 <code>log.Panic</code> 不只是 log</h1><p>log 标准库提供了不同的日志记录等级，与其他语言的日志库不同，Go 的 log 包在调用 Fatal<em>()、Panic</em>() 时能做更多日志外的事，如中断程序的执行等：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"Fatal level log: log entry"</span>)        <span class="comment">// 输出信息后，程序终止执行</span></span><br><span class="line">    log.Println(<span class="string">"Nomal level log: log entry"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对内建数据结构的操作并不是同步的"><a href="#对内建数据结构的操作并不是同步的" class="headerlink" title="对内建数据结构的操作并不是同步的"></a>对内建数据结构的操作并不是同步的</h1><p>尽管 Go 本身有大量的特性来支持并发，但并不保证并发的数据安全，用户需自己保证变量等数据以原子操作更新。</p><p><code>goroutine</code> 和 <code>channel</code> 是进行原子操作的好方法，或使用 <code>&quot;sync&quot;</code> 包中的锁。</p><h1 id="range-迭代-string-得到的值"><a href="#range-迭代-string-得到的值" class="headerlink" title="range 迭代 string 得到的值"></a>range 迭代 string 得到的值</h1><p><code>range</code> 得到的索引是字符值（<code>Unicode point</code> / <code>rune</code>）第一个字节的位置，与其他编程语言不同，这个索引并不直接是字符在字符串中的位置。</p><p>注意一个字符可能占多个 rune，比如法文单词 <code>café</code> 中的 é。操作特殊字符可使用norm 包。</p><p><code>for range</code> 迭代会尝试将 string 翻译为 UTF8 文本，对任何无效的码点都直接使用 <code>0XFFFD rune（�）UNicode</code> 替代字符来表示。如果 string 中有任何非 UTF8 的数据，应将 string 保存为 byte slice 再进行操作。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="string">"A\xfe\x02\xff\x04"</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>, v)    <span class="comment">// 0x41 0xfffd 0x2 0xfffd 0x4    // 错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="keyword">byte</span>(data) &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%#x "</span>, v)    <span class="comment">// 0x41 0xfe 0x2 0xff 0x4    // 正确</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="range-迭代-map"><a href="#range-迭代-map" class="headerlink" title="range 迭代 map"></a>range 迭代 map</h1><p>如果你希望以特定的顺序（如按 key 排序）来迭代 map，要注意每次迭代都可能产生不一样的结果。</p><p>Go 的运行时是有意打乱迭代顺序的，所以你得到的迭代结果可能不一致。但也并不总会打乱，得到连续相同的 5 个迭代结果也是可能的，如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"one"</span>: <span class="number">1</span>, <span class="string">"two"</span>: <span class="number">2</span>, <span class="string">"three"</span>: <span class="number">3</span>, <span class="string">"four"</span>: <span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你去 <a href="https://go.dev/play/" target="_blank" rel="noopener">Go Playground</a> 重复运行上边的代码，输出是不会变的，只有你更新代码它才会重新编译。重新编译后迭代顺序是被打乱的：</p><h1 id="switch-中的-fallthrough-语句"><a href="#switch-中的-fallthrough-语句" class="headerlink" title="switch 中的 fallthrough 语句"></a>switch 中的 fallthrough 语句</h1><p><code>switch</code> 语句中的 <code>case</code> 代码块会默认带上 <code>break</code>，但可以使用 <code>fallthrough</code> 来强制执行下一个 <code>case</code> 代码块。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>:    <span class="comment">// 空格符会直接 break，返回 false // 和其他语言不一样</span></span><br><span class="line">        <span class="comment">// fallthrough    // 返回 true</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">'\t'</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">' '</span>))     <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过你可以在 <code>case</code> 代码块末尾使用 <code>fallthrough</code>，强制执行下一个 <code>case</code> 代码块。</p><p>也可以改写 <code>case</code> 为多条件判断：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    isSpace := <span class="function"><span class="keyword">func</span><span class="params">(char <span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> char &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">' '</span>, <span class="string">'\t'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(isSpace(<span class="string">'\t'</span>))    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(isSpace(<span class="string">' '</span>))     <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自增和自减运算"><a href="#自增和自减运算" class="headerlink" title="自增和自减运算"></a>自增和自减运算</h1><p>很多编程语言都自带前置后置的 <code>++</code>、<code>--</code> 运算。但 Go 特立独行，去掉了前置操作，同时 <code>++</code>、<code>—</code> 只作为运算符而非表达式。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ++i            <span class="comment">// syntax error: unexpected ++, expecting &#125;</span></span><br><span class="line">    fmt.Println(data[i++])    <span class="comment">// syntax error: unexpected ++, expecting :</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    i++</span><br><span class="line">    fmt.Println(data[i])    <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h1><p>很多编程语言使用 <code>~</code> 作为一元按位取反（NOT）操作符，Go 重用 <code>^</code> XOR 操作符来<strong>按位取反</strong>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的取反操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(~<span class="number">2</span>)        <span class="comment">// bitwise complement operator is ^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="keyword">uint8</span> = <span class="number">2</span></span><br><span class="line">    fmt.Printf(<span class="string">"%08b\n"</span>, d)     <span class="comment">// 00000010</span></span><br><span class="line">    fmt.Printf(<span class="string">"%08b\n"</span>, ^d)    <span class="comment">// 11111101</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时 <code>^</code> 也是<strong>按位异或</strong>（XOR）操作符。</p><p>一个操作符能重用两次，是因为一元的 NOT 操作 <code>NOT 0x02</code>，与二元的 XOR 操作 <code>0x22 XOR 0xff</code> 是一致的。</p><h1 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>除了位清除（bit clear）操作符，Go 也有很多和其他语言一样的位操作符，但优先级另当别论。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"0x2 &amp; 0x2 + 0x4 -&gt; %#x\n"</span>, <span class="number">0x2</span>&amp;<span class="number">0x2</span>+<span class="number">0x4</span>)    <span class="comment">// &amp; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:    (0x2 &amp; 0x2) + 0x4</span></span><br><span class="line">    <span class="comment">//C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n"</span>, <span class="number">0x2</span>+<span class="number">0x2</span>&lt;&lt;<span class="number">0x1</span>)    <span class="comment">// &lt;&lt; 优先 +</span></span><br><span class="line">    <span class="comment">//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6</span></span><br><span class="line">    <span class="comment">//Go:     0x2 + (0x2 &lt;&lt; 0x1)</span></span><br><span class="line">    <span class="comment">//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8</span></span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"0xf | 0x2 ^ 0x2 -&gt; %#x\n"</span>, <span class="number">0xf</span>|<span class="number">0x2</span>^<span class="number">0x2</span>)    <span class="comment">// | 优先 ^</span></span><br><span class="line">    <span class="comment">//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd</span></span><br><span class="line">    <span class="comment">//Go:    (0xf | 0x2) ^ 0x2</span></span><br><span class="line">    <span class="comment">//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优先级列表</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Precedence    Operator</span><br><span class="line">    <span class="number">5</span>             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span><br><span class="line">    <span class="number">4</span>             +  -  |  ^</span><br><span class="line">    <span class="number">3</span>             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span><br><span class="line">    <span class="number">2</span>             &amp;&amp;</span><br><span class="line">    <span class="number">1</span>             ||</span><br></pre></td></tr></table></figure><h1 id="不导出的-struct-字段无法被-encode"><a href="#不导出的-struct-字段无法被-encode" class="headerlink" title="不导出的 struct 字段无法被 encode"></a>不导出的 struct 字段无法被 encode</h1><p>以小写字母开头的字段成员是无法被外部直接访问的，所以 struct 在进行 json、xml、gob 等格式的 encode 操作时，这些私有字段会被忽略，导出时得到零值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := MyData&#123;<span class="number">1</span>, <span class="string">"two"</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, in)    <span class="comment">// main.MyData&#123;One:1, two:"two"&#125;</span></span><br><span class="line"></span><br><span class="line">    encoded, _ := json.Marshal(in)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(encoded))    <span class="comment">// &#123;"One":1&#125;    // 私有字段 two 被忽略了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out MyData</span><br><span class="line">    json.Unmarshal(encoded, &amp;out)</span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, out)     <span class="comment">// main.MyData&#123;One:1, two:""&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序退出时还有-goroutine-在执行"><a href="#程序退出时还有-goroutine-在执行" class="headerlink" title="程序退出时还有 goroutine 在执行"></a>程序退出时还有 goroutine 在执行</h1><p>程序默认不等所有 <code>goroutine</code> 都执行完才退出，这点需要特别注意：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主程序会直接退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> doIt(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>, workerID)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)        <span class="comment">// 模拟 goroutine 正在执行</span></span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is done\n"</span>, workerID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用解决办法：使用 <code>&quot;WaitGroup&quot;</code> 变量，它会让主程序等待所有 <code>goroutine</code> 执行完毕再退出。</p><p>如果你的 <code>goroutine</code> 要做消息的循环处理等耗时操作，可以向它们发送一条 <code>kill</code> 消息来关闭它们。或直接关闭一个它们都等待接收数据的 <code>channel</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待所有 goroutine 执行完毕</span></span><br><span class="line"><span class="comment">// 使用传址方式为 WaitGroup 变量传参</span></span><br><span class="line"><span class="comment">// 使用 channel 关闭 goroutine</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    workerCount := <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> doIt(i, ch, done, &amp;wg)    <span class="comment">// wg 传指针，doIt() 内部会改变 wg 的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;    <span class="comment">// 向 ch 中发送数据，关闭 goroutine</span></span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">    fmt.Println(<span class="string">"all done!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIt</span><span class="params">(workerID <span class="keyword">int</span>, ch &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"[%v] is running\n"</span>, workerID)</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] m =&gt; %v\n"</span>, workerID, m)</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            fmt.Printf(<span class="string">"[%v] is done\n"</span>, workerID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回"><a href="#向无缓冲的-channel-发送数据，只要-receiver-准备好了就会立刻返回" class="headerlink" title="向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回"></a>向无缓冲的 channel 发送数据，只要 receiver 准备好了就会立刻返回</h1><p>只有在数据被 <code>receiver</code> 处理时，<code>sender</code> 才会阻塞。因运行环境而异，在 <code>sender</code> 发送完数据后，<code>receiver</code> 的 <code>goroutine</code> 可能没有足够的时间处理下一个数据。如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> m := <span class="keyword">range</span> ch &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Processed:"</span>, m)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)    <span class="comment">// 模拟需要长时间运行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="string">"cmd.1"</span></span><br><span class="line">    ch &lt;- <span class="string">"cmd.2"</span> <span class="comment">// 不会被接收处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="向已关闭的-channel-发送数据会造成-panic"><a href="#向已关闭的-channel-发送数据会造成-panic" class="headerlink" title="向已关闭的 channel 发送数据会造成 panic"></a>向已关闭的 channel 发送数据会造成 panic</h1><p>从已关闭的 channel 接收数据是安全的：</p><p>接收状态值 <code>ok</code> 是 <code>false</code> 时表明 <code>channel</code> 中已没有数据可以接收了。类似的，从有缓冲的 <code>channel</code> 中接收数据，缓存的数据获取完再没有数据可取时，状态值也是 <code>false</code></p><p>向已关闭的 <code>channel</code> 中发送数据会造成 <code>panic</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- idx</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-ch)           <span class="comment">// 输出第一个发送的值</span></span><br><span class="line">    <span class="built_in">close</span>(ch)                   <span class="comment">// 不能关闭，还有其他的 sender</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟做其他的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上边有 bug 的这个例子，可使用一个废弃 channel done 来告诉剩余的 goroutine 无需再向 ch 发送数据。此时 <code>&lt;- done</code> 的结果是 <code>{}</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ch &lt;- (idx + <span class="number">1</span>) * <span class="number">2</span>:</span><br><span class="line">                fmt.Println(idx, <span class="string">"Send result"</span>)</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                fmt.Println(idx, <span class="string">"Exiting"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Result: "</span>, &lt;-ch)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用了值为-nil-的-channel"><a href="#使用了值为-nil-的-channel" class="headerlink" title="使用了值为 nil 的 channel"></a>使用了值为 nil 的 channel</h1><p>在一个值为 <code>nil</code> 的 <code>channel</code> 上发送和接收数据将永久阻塞：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 未初始化，值为 nil</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            ch &lt;- i</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Result: "</span>, &lt;-ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runtime 死锁错误：</p><blockquote><p>fatal error: all goroutines are asleep - deadlock!<br>goroutine 1 [chan receive (nil chan)]</p></blockquote><p>利用这个死锁的特性，可以用在 select 中动态的打开和关闭 case 语句块：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> = inCh</span><br><span class="line">        <span class="keyword">var</span> out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> val <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- val:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">"--------"</span>)</span><br><span class="line">                out = <span class="literal">nil</span></span><br><span class="line">                in = inCh</span><br><span class="line">            <span class="keyword">case</span> val = &lt;-in:</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">"++++++++++"</span>)</span><br><span class="line">                out = outCh</span><br><span class="line">                in = <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Result: "</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">0</span>)</span><br><span class="line">    inCh &lt;- <span class="number">1</span></span><br><span class="line">    inCh &lt;- <span class="number">2</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="若函数-receiver-传参是传值方式，则无法修改参数的原有值"><a href="#若函数-receiver-传参是传值方式，则无法修改参数的原有值" class="headerlink" title="若函数 receiver 传参是传值方式，则无法修改参数的原有值"></a>若函数 receiver 传参是传值方式，则无法修改参数的原有值</h1><p>方法 <code>receiver</code> 的参数与一般函数的参数类似：如果声明为值，那方法体得到的是一份参数的值拷贝，此时对参数的任何修改都不会对原有值产生影响。</p><p>除非 <code>receiver</code> 参数是 <code>map</code> 或 <code>slice</code> 类型的变量，并且是以指针方式更新 <code>map</code> 中的字段、<code>slice</code> 中的元素的，才会更新原有值:</p><h1 id="struct、array、slice-和-map-的值比较"><a href="#struct、array、slice-和-map-的值比较" class="headerlink" title="struct、array、slice 和 map 的值比较"></a>struct、array、slice 和 map 的值比较</h1><p>可以使用相等运算符 <code>==</code> 来比较结构体变量，前提是<strong>两个结构体的成员都是可比较的类型</strong>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num     <span class="keyword">int</span></span><br><span class="line">    fp      <span class="keyword">float32</span></span><br><span class="line">    <span class="built_in">complex</span> <span class="keyword">complex64</span></span><br><span class="line">    str     <span class="keyword">string</span></span><br><span class="line">    char    <span class="keyword">rune</span></span><br><span class="line">    yes     <span class="keyword">bool</span></span><br><span class="line">    events  &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span><br><span class="line">    handler <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    ref     *<span class="keyword">byte</span></span><br><span class="line">    raw     [<span class="number">10</span>]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, v1 == v2)    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个结构体中有任意成员是不可比较的，将会造成编译错误。注意数组成员只有在数组元素可比较时候才可比较。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">    num    <span class="keyword">int</span></span><br><span class="line">    checks [<span class="number">10</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span>    // 无法比较</span></span><br><span class="line">    doIt   <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span>        // 无法比较</span></span><br><span class="line">    m      <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>  <span class="comment">// 无法比较</span></span><br><span class="line">    bytes  []<span class="keyword">byte</span>             <span class="comment">// 无法比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, v1 == v2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>invalid operation: v1 == v2 (struct containing [10]func() bool cannot be compared)</p></blockquote><p>Go 提供了一些库函数来比较那些无法使用 <code>==</code> 比较的变量，比如使用 <code>&quot;reflect&quot;</code> 包的 <code>DeepEqual()</code> ：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较相等运算符无法比较的元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    v1 := data&#123;&#125;</span><br><span class="line">    v2 := data&#123;&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(v1, v2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"a"</span>, <span class="string">"two"</span>: <span class="string">"b"</span>&#125;</span><br><span class="line">    m2 := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"two"</span>: <span class="string">"b"</span>, <span class="string">"one"</span>: <span class="string">"a"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(m1, m2))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    s2 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">       <span class="comment">// 注意两个 slice 相等，值和顺序必须一致</span></span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(s1, s2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意: <code>DeepEqual()</code> 并不总适合于比较 slice</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">"one"</span></span><br><span class="line">    <span class="keyword">var</span> in <span class="keyword">interface</span>&#123;&#125; = <span class="string">"one"</span></span><br><span class="line">    fmt.Println(<span class="string">"str == in: "</span>, reflect.DeepEqual(str, in))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    v1 := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>&#125;</span><br><span class="line">    v2 := []<span class="keyword">string</span>&#123;<span class="string">"two"</span>, <span class="string">"one"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"v1 == v2: "</span>, reflect.DeepEqual(v1, v2))     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    data := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">        <span class="string">"code"</span>:  <span class="number">200</span>,</span><br><span class="line">        <span class="string">"value"</span>: []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    encoded, _ := json.Marshal(data)</span><br><span class="line">    <span class="keyword">var</span> decoded <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    json.Unmarshal(encoded, &amp;decoded)</span><br><span class="line">    fmt.Println(<span class="string">"data == decoded: "</span>, reflect.DeepEqual(data, decoded))    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reflect.DeepEqual()</code> 认为空 <code>slice</code> 与 <code>nil slice</code> 并不相等，但注意 <code>byte.Equal()</code> 会认为二者相等：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b1 []<span class="keyword">byte</span> = <span class="literal">nil</span></span><br><span class="line">    b2 := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b1 与 b2 长度相等、有相同的字节序</span></span><br><span class="line">    <span class="comment">// nil 与 slice 在字节上是相同的</span></span><br><span class="line">    fmt.Println(<span class="string">"b1 == b2: "</span>, bytes.Equal(b1, b2))    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从-panic-中恢复"><a href="#从-panic-中恢复" class="headerlink" title="从 panic 中恢复"></a>从 panic 中恢复</h1><p>在一个 defer 延迟执行的函数中调用 <code>recover()</code> ，它便能捕捉 / 中断 <code>panic</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">recover</span>()         <span class="comment">// 什么都不会捕捉</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>) <span class="comment">// 发生 panic，主程序退出</span></span><br><span class="line">    <span class="built_in">recover</span>()         <span class="comment">// 不会被执行</span></span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"ok"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的 recover 调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"recovered: "</span>, <span class="built_in">recover</span>())</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上边可以看出，<code>recover()</code> 仅在 defer 执行的函数中调用才会生效。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        doRecover()</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"not good"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"recobered: "</span>, <span class="built_in">recover</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>recobered: panic: not good</p></blockquote><h1 id="在-range-迭代-slice、array、map-时通过更新引用来更新元素"><a href="#在-range-迭代-slice、array、map-时通过更新引用来更新元素" class="headerlink" title="在 range 迭代 slice、array、map 时通过更新引用来更新元素"></a>在 range 迭代 slice、array、map 时通过更新引用来更新元素</h1><p>在 <code>range</code> 迭代中，得到的值其实是元素的一份值拷贝，更新拷贝并不会更改原来的元素，即是拷贝的地址并不是原有元素的地址：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v *= <span class="number">10</span>        <span class="comment">// data 中原有元素是不会被修改的</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"data: "</span>, data)    <span class="comment">// data:  [1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要修改原有元素的值，应该使用索引直接访问：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        data[i] = v * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"data: "</span>, data)    <span class="comment">// data:  [10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你的集合保存的是指向值的指针，需稍作修改。依旧需要使用索引访问元素，不过可以使用 range 出来的元素直接更新原有值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []*<span class="keyword">struct</span>&#123; num <span class="keyword">int</span> &#125;&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;,&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        v.num *= <span class="number">10</span>    <span class="comment">// 直接使用指针更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>])    <span class="comment">// &amp;&#123;10&#125; &amp;&#123;20&#125; &amp;&#123;30&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="slice-中隐藏的数据"><a href="#slice-中隐藏的数据" class="headerlink" title="slice 中隐藏的数据"></a>slice 中隐藏的数据</h1><p>从 <code>slice</code> 中重新切出新 <code>slice</code> 时，新 <code>slice</code> 会引用原 <code>slice</code> 的底层数组。如果跳了这个坑，程序可能会分配大量的临时 <code>slice</code> 来指向原底层数组的部分数据，将导致难以预料的内存使用。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    <span class="keyword">return</span> raw[:<span class="number">3</span>]    <span class="comment">// 重新分配容量为 10000 的 slice</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 10000 0xc420080000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过拷贝临时 slice 的数据，而不是重新切片来解决：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">()</span> <span class="params">(res []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    raw := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10000</span>)</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(raw), <span class="built_in">cap</span>(raw), &amp;raw[<span class="number">0</span>])    <span class="comment">// 10000 10000 0xc420080000</span></span><br><span class="line">    res = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="built_in">copy</span>(res, raw[:<span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := get()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(data), <span class="built_in">cap</span>(data), &amp;data[<span class="number">0</span>])    <span class="comment">// 3 3 0xc4200160b8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旧-slice"><a href="#旧-slice" class="headerlink" title="旧 slice"></a>旧 slice</h1><p>当你从一个已存在的 slice 创建新 slice 时，二者的数据指向相同的底层数组。如果你的程序使用这个特性，那需要注意 “旧”（stale） slice 问题。</p><p>某些情况下，向一个 slice 中追加元素而它指向的底层数组容量不足时，将会重新分配一个新数组来存储数据。而其他 slice 还指向原来的旧底层数组。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过容量将重新分配数组来拷贝值、重新存储</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1), s1)    <span class="comment">// 3 3 [1 2 3 ]</span></span><br><span class="line"></span><br><span class="line">    s2 := s1[<span class="number">1</span>:]</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2), s2)    <span class="comment">// 2 2 [2 3]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 s1 与 s2 是指向同一个底层数组的</span></span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [22 23]</span></span><br><span class="line"></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">4</span>)    <span class="comment">// 向容量为 2 的 s2 中再追加元素，此时将分配新数组来存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> s2 &#123;</span><br><span class="line">        s2[i] += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(s1)        <span class="comment">// [1 22 23]    // 此时的 s1 不再更新，为旧数据</span></span><br><span class="line">    fmt.Println(s2)        <span class="comment">// [32 33 14]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="for-语句中的迭代变量与闭包函数"><a href="#for-语句中的迭代变量与闭包函数" class="headerlink" title="for 语句中的迭代变量与闭包函数"></a>for 语句中的迭代变量与闭包函数</h1><p>for 语句中的迭代变量在每次迭代中都会重用，即 <code>for</code> 中创建的闭包函数接收到的参数始终是<strong>同一个变量</strong>，在 <code>goroutine</code> 开始执行时都会得到同一个迭代值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(v)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 three three three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的解决方法：无需修改 <code>goroutine</code> 函数，在 <code>for</code> 内部使用局部变量保存迭代值，再传参：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        vCopy := v</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            fmt.Println(vCopy)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个解决方法：直接将当前的迭代值以参数形式传递给匿名函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="keyword">string</span>&#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(in <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">            fmt.Println(in)</span><br><span class="line">        &#125;(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    <span class="comment">// 输出 one two three</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer-函数的参数值"><a href="#defer-函数的参数值" class="headerlink" title="defer 函数的参数值"></a>defer 函数的参数值</h1><p>对 defer 延迟执行的函数，它的参数会在声明时候就会求出具体值，而不是在执行时才求值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 defer 函数中参数会提前求值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"result: "</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> i * <span class="number">2</span> &#125;())</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>result: 2</p></blockquote><h1 id="defer-函数的执行时机"><a href="#defer-函数的执行时机" class="headerlink" title="defer 函数的执行时机"></a>defer 函数的执行时机</h1><p>对 defer 延迟执行的函数，会在调用它的函数结束时执行，而不是在调用它的语句块结束时执行，注意区分开。</p><p>比如在一个长时间执行的函数里，内部 for 循环中使用 defer 来清理每次迭代产生的资源调用，就会出现问题：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令行参数指定目录名</span></span><br><span class="line"><span class="comment">// 遍历读取目录下的文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">        os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dir := os.Args[<span class="number">1</span>]</span><br><span class="line">    start, err := os.Stat(dir)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !start.IsDir() &#123;</span><br><span class="line">        os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> targets []<span class="keyword">string</span></span><br><span class="line">    filepath.Walk(dir, <span class="function"><span class="keyword">func</span><span class="params">(fPath <span class="keyword">string</span>, fInfo os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !fInfo.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        targets = <span class="built_in">append</span>(targets, fPath)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        f, err := os.Open(target)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"bad target:"</span>, target, <span class="string">"error:"</span>, err)    <span class="comment">//error:too many open files</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close()    <span class="comment">// 在每次 for 语句块结束时，不会关闭文件资源</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 f 资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法：defer 延迟执行的函数写入匿名函数中：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录遍历正常</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, target := <span class="keyword">range</span> targets &#123;</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Open(target)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"bad target:"</span>, target, <span class="string">"error:"</span>, err)</span><br><span class="line">                <span class="keyword">return</span>    <span class="comment">// 在匿名函数内使用 return 代替 break 即可</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close()    <span class="comment">// 匿名函数执行结束，调用关闭文件资源</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用 f 资源</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以去掉 <code>defer</code>，在文件资源使用完毕后，直接调用 <code>f.Close()</code> 来关闭。</p><h1 id="失败的类型断言"><a href="#失败的类型断言" class="headerlink" title="失败的类型断言"></a>失败的类型断言</h1><p>在类型断言语句中，断言失败则会返回目标类型的“零值”，断言变量与原来变量混用可能出现异常情况：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// data 混用</span></span><br><span class="line">    <span class="keyword">if</span> data, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int], data: "</span>, data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int], data: "</span>, data)    <span class="comment">// [not an int], data:  0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">interface</span>&#123;&#125; = <span class="string">"great"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> res, ok := data.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[is an int], data: "</span>, res)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"[not an int], data: "</span>, data)    <span class="comment">// [not an int], data:  great</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆栈变量"><a href="#堆栈变量" class="headerlink" title="堆栈变量"></a>堆栈变量</h1><p>你并不总是清楚你的变量是分配到了堆还是栈。</p><p>在 <code>C++</code> 中使用 <code>new</code> 创建的变量总是分配到堆内存上的，但在 Go 中即使使用 <code>new()</code>、<code>make()</code> 来创建变量，变量为内存分配位置依旧归 <code>Go</code> 编译器管。</p><p>Go 编译器会根据变量的大小及其 <code>&quot;escape analysis&quot;</code> 的结果来决定变量的存储位置，故能准确返回本地变量的地址，这在 C/C++ 中是不行的。</p><p>在 <code>go build</code> 或 <code>go run</code> 时，加入 <code>-m</code> 参数，能准确分析程序的变量分配位置：</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Golang 新手可能会踩的 50 个坑 下&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://blog.caoxl.com/categories/Golang/"/>
    
    
      <category term="golang" scheme="http://blog.caoxl.com/tags/golang/"/>
    
      <category term="go" scheme="http://blog.caoxl.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 再深入 I</title>
    <link href="http://blog.caoxl.com/2022/09/28/Golang-Learn-More-I/"/>
    <id>http://blog.caoxl.com/2022/09/28/Golang-Learn-More-I/</id>
    <published>2022-09-28T10:10:16.000Z</published>
    <updated>2022-09-29T04:13:59.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Golang 新手可能会踩的 50 个坑 上</p></blockquote><a id="more"></a><h1 id="左大括号-不能单独放一行"><a href="#左大括号-不能单独放一行" class="headerlink" title="左大括号 { 不能单独放一行"></a>左大括号 <code>{</code> 不能单独放一行</h1><p>在其他大多数语言中，<code>{</code>的位置你自行决定。Go 比较特别，遵守分号注入规则（automatic semicolon injection）：编译器会在每行代码尾部特定分隔符后加 <code>;</code> 来分隔多条语句，比如会在 <code>)</code> 后加分号：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span>;    // 无函数体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="未使用的变量"><a href="#未使用的变量" class="headerlink" title="未使用的变量"></a>未使用的变量</h1><p>如果在函数体代码中有未使用的变量，则无法通过编译，不过全局变量声明但不使用是可以的。</p><p>即使变量声明后为变量赋值，依旧无法通过编译，需在某处使用它：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">var</span> gvar <span class="keyword">int</span>        <span class="comment">// 全局变量，声明不使用也可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="keyword">int</span>     <span class="comment">// error: one declared and not used</span></span><br><span class="line">    two := <span class="number">2</span>        <span class="comment">// error: two declared and not used</span></span><br><span class="line">    <span class="keyword">var</span> three <span class="keyword">int</span>   <span class="comment">// error: three declared and not used</span></span><br><span class="line">    three = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="comment">// 可以直接注释或移除未使用的变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> one <span class="keyword">int</span></span><br><span class="line">    _ = one</span><br><span class="line"></span><br><span class="line">    two := <span class="number">2</span></span><br><span class="line">    <span class="built_in">println</span>(two)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> three <span class="keyword">int</span></span><br><span class="line">    one = three</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> four <span class="keyword">int</span></span><br><span class="line">    four = four</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="未使用的-import"><a href="#未使用的-import" class="headerlink" title="未使用的 import"></a>未使用的 import</h1><p>如果你 <code>import</code> 一个包，但包中的变量、函数、接口和结构体一个都没有用到的话，将编译失败。</p><p>可以使用 <code>_</code> 下划线符号作为别名来忽略导入的包，从而避免编译错误，这只会执行 <code>package</code> 的 <code>init()</code></p><h1 id="简短声明的变量只能在函数内部使用"><a href="#简短声明的变量只能在函数内部使用" class="headerlink" title="简短声明的变量只能在函数内部使用"></a>简短声明的变量只能在函数内部使用</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line">myvar := <span class="number">1</span>    <span class="comment">// syntax error: non-declaration statement outside function body</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">var</span>  myvar = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用简短声明来重复声明变量"><a href="#使用简短声明来重复声明变量" class="headerlink" title="使用简短声明来重复声明变量"></a>使用简短声明来重复声明变量</h1><p>不能用简短声明方式来单独为一个变量重复声明， := 左侧至少有一个新变量，才允许多变量的重复声明：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one := <span class="number">1</span> <span class="comment">// error: no new variables on left side of :=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    one := <span class="number">0</span></span><br><span class="line">    one, two := <span class="number">1</span>, <span class="number">2</span>    <span class="comment">// two 是新变量，允许 one 的重复声明。比如 error 处理经常用同名变量 err</span></span><br><span class="line">    one, two = two, one <span class="comment">// 交换两个变量值的简写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不能使用简短声明来设置字段的值"><a href="#不能使用简短声明来设置字段的值" class="headerlink" title="不能使用简短声明来设置字段的值"></a>不能使用简短声明来设置字段的值</h1><p><code>struct</code> 的变量字段不能使用 <code>:=</code> 来赋值以使用预定义的变量来避免解决：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    result <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    data.result, err := work()    <span class="comment">// error: non-name data.result on left side of :=</span></span><br><span class="line">    fmt.Printf(<span class="string">"info: %+v\n"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data info</span><br><span class="line">    <span class="keyword">var</span> err error    <span class="comment">// err 需要预声明</span></span><br><span class="line"></span><br><span class="line">    data.result, err = work()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"info: %+v\n"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不小心覆盖了变量"><a href="#不小心覆盖了变量" class="headerlink" title="不小心覆盖了变量"></a>不小心覆盖了变量</h1><p>对从动态语言转过来的开发者来说，简短声明很好用，这可能会让人误会 <code>:=</code> 是一个赋值操作符。</p><p>如果你在新的代码块中像下边这样误用了 <code>:=</code>，编译不会报错，但是变量不会按你的预期工作：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 1</span></span><br><span class="line">        x := <span class="number">2</span></span><br><span class="line">        <span class="built_in">println</span>(x)    <span class="comment">// 2    // 新的 x 变量的作用域只在代码块内部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>(x)        <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Go 开发者常犯的错，而且不易被发现。</p><p>可使用 <code>vet</code> 工具来诊断这种变量覆盖，Go 默认不做覆盖检查，添加 <code>-shadow</code> 选项来启用：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">go</span> tool vet -shadow main.<span class="keyword">go</span></span><br><span class="line">main.<span class="keyword">go</span>:<span class="number">9</span>: declaration of <span class="string">"x"</span> shadows declaration at main.<span class="keyword">go</span>:<span class="number">5</span></span><br></pre></td></tr></table></figure><p>注意 <code>vet</code> 不会报告全部被覆盖的变量，可以使用 <code>go-nyet</code> 来做进一步的检测：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; $GOPATH/bin/<span class="keyword">go</span>-nyet main.<span class="keyword">go</span></span><br><span class="line">main.<span class="keyword">go</span>:<span class="number">10</span>:<span class="number">3</span>:Shadowing variable <span class="string">`x`</span></span><br></pre></td></tr></table></figure><h1 id="显式类型的变量无法使用-nil-来初始化"><a href="#显式类型的变量无法使用-nil-来初始化" class="headerlink" title="显式类型的变量无法使用 nil 来初始化"></a>显式类型的变量无法使用 nil 来初始化</h1><p><code>nil</code> 是 <code>interface</code>、<code>function</code>、<code>pointer</code>、<code>map</code>、<code>slice</code> 和 channel 类型变量的默认初始值。但声明时不指定类型，编译器也无法推断出变量的具体类型。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="literal">nil</span>    <span class="comment">// error: use of untyped nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125; = <span class="literal">nil</span></span><br><span class="line">    _ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="直接使用值为-nil-的-slice、map"><a href="#直接使用值为-nil-的-slice、map" class="headerlink" title="直接使用值为 nil 的 slice、map"></a>直接使用值为 nil 的 slice、map</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">    m[<span class="string">"one"</span>] = <span class="number">1</span>        <span class="comment">// error: panic: assignment to entry in nil map</span></span><br><span class="line">    <span class="comment">// m := make(map[string]int) // map 的正确声明，分配了实际的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="map-容量"><a href="#map-容量" class="headerlink" title="map 容量"></a>map 容量</h1><p>在创建 map 类型的变量时可以指定容量，但不能像 <code>slice</code> 一样使用 <code>cap()</code> 来检测分配空间的大小：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">99</span>)</span><br><span class="line">    <span class="built_in">println</span>(<span class="built_in">cap</span>(m))     <span class="comment">// error: invalid argument m1 (type map[string]int) for cap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-类型的变量值不能为-nil"><a href="#string-类型的变量值不能为-nil" class="headerlink" title="string 类型的变量值不能为 nil"></a>string 类型的变量值不能为 nil</h1><p>对那些喜欢用 <code>nil</code> 初始化字符串的人来说，这就是坑：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="literal">nil</span>    <span class="comment">// cannot use nil as type string in assignment</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;         <span class="comment">// invalid operation: s == nil (mismatched types string and nil)</span></span><br><span class="line">        s = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span>    <span class="comment">// 字符串类型的零值是空串 ""</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">""</span> &#123;</span><br><span class="line">        s = <span class="string">"default"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Array-类型的值作为函数参数"><a href="#Array-类型的值作为函数参数" class="headerlink" title="Array 类型的值作为函数参数"></a>Array 类型的值作为函数参数</h1><p>在 C/C++ 中，数组（名）是指针。将数组作为参数传进函数时，相当于传递了数组内存地址的引用，在函数内部会改变该数组的值。</p><p>在 Go 中，数组是值。作为参数传进函数时，传递的是数组的原始值拷贝，此时在函数内部是无法更新该数组的：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组使用值拷贝传参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr [3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)            <span class="comment">// [1 2 3]    // 并不是你以为的 [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想修改参数数组：</p><ul><li>接传递指向这个数组的指针类型：</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传址会修改原数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr *[3]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        (*arr)[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(arr)    <span class="comment">// &amp;[7 2 3]</span></span><br><span class="line">    &#125;(&amp;x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接使用 slice：即使函数内部得到的是 slice 的值拷贝，但依旧会更新 slice 的原始数据（底层 array）</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会修改 slice 的底层 array，从而修改 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">7</span></span><br><span class="line">        fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">    &#125;(x)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// [7 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="range-遍历-slice-和-array-时混淆了返回值"><a href="#range-遍历-slice-和-array-时混淆了返回值" class="headerlink" title="range 遍历 slice 和 array 时混淆了返回值"></a>range 遍历 slice 和 array 时混淆了返回值</h1><p>与其他编程语言中的 <code>for-in</code> 、<code>foreach</code> 遍历语句不同，Go 中的 <code>range</code> 在遍历时会生成 2 个值，第一个是元素索引，第二个是元素的值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> x &#123;</span><br><span class="line">        fmt.Println(v)    <span class="comment">// 0 1 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> x &#123;    <span class="comment">// 使用 _ 丢弃索引</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="slice-和-array-其实是一维数据"><a href="#slice-和-array-其实是一维数据" class="headerlink" title="slice 和 array 其实是一维数据"></a>slice 和 array 其实是一维数据</h1><p>看起来 Go 支持多维的 array 和 slice，可以创建数组的数组、切片的切片，但其实并不是。</p><p>对依赖动态计算多维数组值的应用来说，就性能和复杂度而言，用 Go 实现的效果并不理想。</p><p>可以使用原始的一维数组、“独立“ 的切片、“共享底层数组”的切片来创建动态的多维数组。</p><h1 id="访问-map-中不存在的-key"><a href="#访问-map-中不存在的-key" class="headerlink" title="访问 map 中不存在的 key"></a>访问 map 中不存在的 key</h1><p>和其他编程语言类似，如果访问了 map 中不存在的 key 则希望能返回 nil，比如在 PHP 中：</p><p>Go 则会返回元素对应数据类型的零值，比如 <code>nil</code>、<code>&#39;&#39;</code> 、<code>false</code> 和 <code>0</code>，取值操作总有值返回，故不能通过取出来的值来判断 key 是不是在 map 中。</p><p>检查 key 是否存在可以用 map 直接访问，检查返回的第二个参数即可：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的 key 检测方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"2"</span>, <span class="string">"two"</span>: <span class="string">""</span>, <span class="string">"three"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> v := x[<span class="string">"two"</span>]; v == <span class="string">""</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key two is no entry"</span>)    <span class="comment">// 键 two 存不存在都会返回的空字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"one"</span>: <span class="string">"2"</span>, <span class="string">"two"</span>: <span class="string">""</span>, <span class="string">"three"</span>: <span class="string">"3"</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> _, ok := x[<span class="string">"two"</span>]; !ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key two is no entry"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-类型的值是常量，不可更改"><a href="#string-类型的值是常量，不可更改" class="headerlink" title="string 类型的值是常量，不可更改"></a>string 类型的值是常量，不可更改</h1><p>尝试使用索引遍历字符串，来更新字符串中的个别字符，是不允许的。</p><p><code>string</code> 类型的值是只读的二进制 <code>byte slice</code>，如果真要修改字符串中的字符，将 <code>string</code> 转为 <code>[]byte</code> 修改后，再转为 <code>string</code> 即可：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改字符串的错误示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    x[<span class="number">0</span>] = <span class="string">"T"</span>        <span class="comment">// error: cannot assign to x[0]</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    xBytes := []<span class="keyword">byte</span>(x)</span><br><span class="line">    xBytes[<span class="number">0</span>] = <span class="string">'T'</span>    <span class="comment">// 注意此时的 T 是 rune 类型</span></span><br><span class="line">    x = <span class="keyword">string</span>(xBytes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// Text</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 上边的示例并不是更新字符串的正确姿势，<strong>因为一个 UTF8 编码的字符可能会占多个字节，比如汉字就需要 3~4 个字节来存储，此时更新其中的一个字节是错误的</strong>。</p><p>更新字串的正确姿势：将 <code>string</code> 转为 <code>rune slice</code>（此时 1 个 rune 可能占多个 byte），直接更新 <code>rune</code> 中的字符</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"text"</span></span><br><span class="line">    xRunes := []<span class="keyword">rune</span>(x)</span><br><span class="line">    xRunes[<span class="number">0</span>] = <span class="string">'我'</span></span><br><span class="line">    x = <span class="keyword">string</span>(xRunes)</span><br><span class="line">    fmt.Println(x)    <span class="comment">// 我ext</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-与-byte-slice-之间的转换"><a href="#string-与-byte-slice-之间的转换" class="headerlink" title="string 与 byte slice 之间的转换"></a>string 与 byte slice 之间的转换</h1><p>当进行 string 和 byte slice 相互转换时，参与转换的是拷贝的原始值。这种转换的过程，与其他编程语的强制类型转换操作不同，也和新 slice 与旧 slice 共享底层数组不同。</p><p>Go 在 string 与 byte slice 相互转换上优化了两点，避免了额外的内存分配：</p><ul><li>在 <code>map[string]</code> 中查找 <code>key</code> 时，使用了对应的 <code>[]byte</code>，避免做 <code>m[string(key)]</code> 的内存分配</li><li>使用 <code>for range</code> 迭代 <code>string</code> 转换为 <code>[]byte</code> 的迭代：<code>for i,v := range []byte(str) {...}</code></li></ul><h1 id="string-与索引操作符"><a href="#string-与索引操作符" class="headerlink" title="string 与索引操作符"></a>string 与索引操作符</h1><p>对字符串用索引访问返回的不是字符，而是一个 <code>byte</code> 值。</p><p>这种处理方式和其他语言一样，比如 PHP 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; php -r &apos;$name=&quot;中文&quot;; var_dump($name);&apos;    # &quot;中文&quot; 占用 6 个字节</span><br><span class="line">string(6) &quot;中文&quot;</span><br><span class="line"></span><br><span class="line">&gt; php -r &apos;$name=&quot;中文&quot;; var_dump($name[0]);&apos; # 把第一个字节当做 Unicode 字符读取，显示 U+FFFD</span><br><span class="line">string(1) &quot;�&quot;</span><br><span class="line"></span><br><span class="line">&gt; php -r &apos;$name=&quot;中文&quot;; var_dump($name[0].$name[1].$name[2]);&apos;</span><br><span class="line">string(3) &quot;中&quot;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="string">"ascii"</span></span><br><span class="line">    fmt.Println(x[<span class="number">0</span>])        <span class="comment">// 97</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, x[<span class="number">0</span>]) <span class="comment">// uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用 <code>for range</code> 迭代访问字符串中的字符（<code>unicode code point</code> / <code>rune</code>），标准库中有 <code>&quot;unicode/utf8&quot;</code> 包来做 UTF8 的相关解码编码。另外 <code>utf8string</code> 也有像 <code>func (s *String) At(i int) rune</code> 等很方便的库函数。</p><h1 id="字符串并不都是-UTF8-文本"><a href="#字符串并不都是-UTF8-文本" class="headerlink" title="字符串并不都是 UTF8 文本"></a>字符串并不都是 UTF8 文本</h1><p>string 的值不必是 UTF8 文本，可以包含任意的值。只有字符串是文字字面值时才是 UTF8 文本，字串可以通过转义来包含其他数据。</p><p>判断字符串是否是 UTF8 文本，可使用 <code>&quot;unicode/utf8&quot;</code> 包中的 <code>ValidString()</code> 函数：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    str1 := <span class="string">"ABC"</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str1))    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    str2 := <span class="string">"A\xfeC"</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str2))    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    str3 := <span class="string">"A\\xfeC"</span></span><br><span class="line">    fmt.Println(utf8.ValidString(str3))    <span class="comment">// true    // 把转义字符转义成字面值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h1><p>在 Go 中：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))    <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 的内建函数 <code>len()</code> 返回的是字符串的 <code>byte</code> 数量，而不是像 Python 中那样是计算 <code>Unicode</code> 字符数。</p><p>如果要得到字符串的字符数，可使用 <code>&quot;unicode/utf8&quot;</code> 包中的 <code>RuneCountInString(str string) (n int)</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"♥"</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>RuneCountInString</code> 并不总是返回我们看到的字符数，因为有的字符会占用 2 个 <code>rune</code>：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    char := <span class="string">"é"</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(char))                       <span class="comment">// 3</span></span><br><span class="line">    fmt.Println(utf8.RuneCountInString(char))    <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(<span class="string">"cafe\u0301"</span>)                    <span class="comment">// 法文的 cafe，实际上是两个 rune 的组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Golang 新手可能会踩的 50 个坑 上&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://blog.caoxl.com/categories/Golang/"/>
    
    
      <category term="golang" scheme="http://blog.caoxl.com/tags/golang/"/>
    
      <category term="go" scheme="http://blog.caoxl.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Golang 面试题 I</title>
    <link href="http://blog.caoxl.com/2022/09/28/Golang-Interview-I/"/>
    <id>http://blog.caoxl.com/2022/09/28/Golang-Interview-I/</id>
    <published>2022-09-28T02:42:21.000Z</published>
    <updated>2022-09-28T10:02:09.571Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>成为Go开发工作者已经2个多月了, 是时候通过一些面试题笔试题提升自己了</p></blockquote><a id="more"></a><h1 id="结构体是否可以直接寻地址"><a href="#结构体是否可以直接寻地址" class="headerlink" title="结构体是否可以直接寻地址"></a>结构体是否可以直接寻地址</h1><h2 id="什么叫可寻址"><a href="#什么叫可寻址" class="headerlink" title="什么叫可寻址"></a>什么叫可寻址</h2><blockquote><p>可直接使用<code>&amp;</code>操作符取地址的对象,就是可寻址</p></blockquote><h2 id="哪些是可以寻址的"><a href="#哪些是可以寻址的" class="headerlink" title="哪些是可以寻址的"></a>哪些是可以寻址的</h2><h3 id="变量-amp-x"><a href="#变量-amp-x" class="headerlink" title="变量 &amp;x"></a>变量 <code>&amp;x</code></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">"caoxl"</span></span><br><span class="line">fmt.Println(&amp;name)</span><br></pre></td></tr></table></figure><h3 id="指针-amp-x"><a href="#指针-amp-x" class="headerlink" title="指针 &amp;*x"></a>指针 <code>&amp;*x</code></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(unsafe.Pointer(&amp;person&#123;<span class="string">"caoxl"</span>&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组元素索引-amp-a-0"><a href="#数组元素索引-amp-a-0" class="headerlink" title="数组元素索引 &amp;a[0]"></a>数组元素索引 <code>&amp;a[0]</code></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println([]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><h3 id="切片元素索引-amp-s-0"><a href="#切片元素索引-amp-s-0" class="headerlink" title="切片元素索引 &amp;s[0]"></a>切片元素索引 <code>&amp;s[0]</code></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(&amp;s[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h2 id="哪些是不可以寻址的"><a href="#哪些是不可以寻址的" class="headerlink" title="哪些是不可以寻址的"></a>哪些是不可以寻址的</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h3 id="函数或方法"><a href="#函数或方法" class="headerlink" title="函数或方法"></a>函数或方法</h3><ul><li><a href="https://juejin.cn/post/7077800061417029640" target="_blank" rel="noopener">Golang的寻址与不可寻址</a></li></ul><h1 id="有方向的channel是否可以关闭"><a href="#有方向的channel是否可以关闭" class="headerlink" title="有方向的channel是否可以关闭"></a>有方向的channel是否可以关闭</h1><blockquote><p>因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。</p></blockquote><h1 id="for-range和for对channel遍历的区别"><a href="#for-range和for对channel遍历的区别" class="headerlink" title="for range和for对channel遍历的区别"></a>for range和for对channel遍历的区别</h1><blockquote><p>for range 中，参与循环表达式的只是对象的副本</p></blockquote><h1 id="context超时控制"><a href="#context超时控制" class="headerlink" title="context超时控制"></a>context超时控制</h1><p>利用 <code>context.WithTimeout()</code> 方法会返回一个具有超时功能的上下文。</p><h1 id="cron定时"><a href="#cron定时" class="headerlink" title="cron定时"></a>cron定时</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"github.com/robfig/cron/v3"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := cron.New(cron.WithSeconds())</span><br><span class="line">    <span class="comment">// 含义查看下文表达式示例</span></span><br><span class="line">    c.AddFunc(<span class="string">"0/7 * * * * *"</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(time.Now().Format(<span class="string">"2006-01-02 15:04:05"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    c.Start()</span><br><span class="line">    time.Sleep(<span class="number">300</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://segmentfault.com/a/1190000039647260#item-3" target="_blank" rel="noopener">Cron表达式</a></li><li><a href="https://segmentfault.com/a/1190000039647260#item-3" target="_blank" rel="noopener">Golang cron 定时使用指南</a></li></ul><h1 id="embed包的作用"><a href="#embed包的作用" class="headerlink" title="embed包的作用"></a>embed包的作用</h1><p>embed是在Go 1.16中新加入的包。它通过<code>//go:embed</code>指令，可以在编译阶段将静态资源文件打包进编译好的程序中，并提供访问这些文件的能力。</p><h2 id="为什么需要-embed-包"><a href="#为什么需要-embed-包" class="headerlink" title="为什么需要 embed 包"></a>为什么需要 embed 包</h2><p>在以前，很多从其他语言转过来Go语言的同学会问到，或者踩到一个坑。就是以为Go语言所打包的二进制文件中会包含配置文件的联同编译和打包。</p><p>结果往往一把二进制文件挪来挪去，就无法把应用程序运行起来了。因为无法读取到静态文件的资源。</p><ul><li><a href="https://blog.51cto.com/niuben/3028670" target="_blank" rel="noopener">Golang 1.16新特性-embed包及其使用</a></li></ul><h1 id="哪些类型可以和nil比较"><a href="#哪些类型可以和nil比较" class="headerlink" title="哪些类型可以和nil比较"></a>哪些类型可以和nil比较</h1><p>nil是一个预先声明的标识符，代表指针(pointer)、通道(channel)、函数(func)、接口(interface)、map、切片(slice)。也可以这么理解：指针、通道、函数、接口、map、切片的零值就是nil，就像布尔类型的零值是false、整型的零值是0。</p><h2 id="nil标识符的比较"><a href="#nil标识符的比较" class="headerlink" title="nil标识符的比较"></a>nil标识符的比较</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="literal">nil</span>== <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>==符号对于nil来说是一种未定义的操作，所以是不可以比较两个nil的</p><h2 id="nil的值比较"><a href="#nil的值比较" class="headerlink" title="nil的值比较"></a>nil的值比较</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">// 指针类型的nil比较</span></span><br><span class="line">    fmt.Println((*<span class="keyword">int64</span>)(<span class="literal">nil</span>) == (*<span class="keyword">int64</span>)(<span class="literal">nil</span>))</span><br><span class="line">    <span class="comment">// channel 类型的nil比较</span></span><br><span class="line">    fmt.Println((<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">chan</span> <span class="keyword">int</span>)(<span class="literal">nil</span>))</span><br><span class="line">    <span class="comment">// func类型的nil比较</span></span><br><span class="line">    fmt.Println((<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(<span class="literal">nil</span>)</span> == <span class="params">(<span class="keyword">func</span>()</span>)<span class="params">(<span class="literal">nil</span>)</span>) // <span class="title">func</span><span class="params">()</span> 只能与<span class="title">nil</span>进行比较</span></span><br><span class="line">    <span class="comment">// interface类型的nil比较</span></span><br><span class="line">    fmt.Println((<span class="keyword">interface</span>&#123;&#125;)(<span class="literal">nil</span>) == (<span class="keyword">interface</span>&#123;&#125;)(<span class="literal">nil</span>))</span><br><span class="line">    <span class="comment">// map类型的nil比较</span></span><br><span class="line">    fmt.Println((<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>)) <span class="comment">// map 只能与nil进行比较</span></span><br><span class="line">    <span class="comment">// slice类型的nil比较</span></span><br><span class="line">    fmt.Println(([]<span class="keyword">int</span>)(<span class="literal">nil</span>) == ([]<span class="keyword">int</span>)(<span class="literal">nil</span>)) <span class="comment">// slice 只能与nil进行比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./<span class="literal">nil</span>.<span class="keyword">go</span>:<span class="number">13</span>:<span class="number">28</span>: invalid operation: (<span class="function"><span class="keyword">func</span><span class="params">()</span>)<span class="params">(<span class="literal">nil</span>)</span> == <span class="params">(<span class="keyword">func</span>()</span>)<span class="params">(<span class="literal">nil</span>)</span> <span class="params">(<span class="keyword">func</span> can only be compared to <span class="literal">nil</span>)</span></span></span><br><span class="line">./<span class="literal">nil</span>.<span class="keyword">go</span>:<span class="number">17</span>:<span class="number">36</span>: invalid operation: (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>) == (<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)(<span class="literal">nil</span>) (<span class="keyword">map</span> can only be compared to <span class="literal">nil</span>)</span><br><span class="line">./<span class="literal">nil</span>.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">27</span>: invalid operation: ([]<span class="keyword">int</span>)(<span class="literal">nil</span>) == ([]<span class="keyword">int</span>)(<span class="literal">nil</span>) (slice can only be compared to <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>从运行结果我们可以看出，指<code>针类型nil</code>、<code>channel类型的nil</code>、<code>interface类型</code>可以相互比较，而<code>func类型</code>、<code>map类型</code>、<code>slice类型</code>只能与<code>nil标识符</code>比较，两个类型相互比较是不合法的。</p><ul><li><a href="https://segmentfault.com/a/1190000039894167" target="_blank" rel="noopener">有趣的面试题：Go语言中nil的比较结果</a></li></ul><h1 id="fallthrouth是否可以用在断言"><a href="#fallthrouth是否可以用在断言" class="headerlink" title="fallthrouth是否可以用在断言"></a>fallthrouth是否可以用在断言</h1><h2 id="fallthrouth"><a href="#fallthrouth" class="headerlink" title="fallthrouth"></a>fallthrouth</h2><blockquote><p>fallthrough：Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。</p></blockquote><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>类型断言（Type Assertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。</p><p>断言还有一种形式，就是使用「switch语句」判断接口的类型</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;成为Go开发工作者已经2个多月了, 是时候通过一些面试题笔试题提升自己了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://blog.caoxl.com/categories/Golang/"/>
    
    
      <category term="golang" scheme="http://blog.caoxl.com/tags/golang/"/>
    
      <category term="go" scheme="http://blog.caoxl.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>MySQL8窗口函数详解-结合案例</title>
    <link href="http://blog.caoxl.com/2022/06/15/MySQL8-Window-Function-II/"/>
    <id>http://blog.caoxl.com/2022/06/15/MySQL8-Window-Function-II/</id>
    <published>2022-06-15T09:18:25.000Z</published>
    <updated>2022-06-16T07:54:22.069Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>窗口函数再深入,结合案例详解</p></blockquote><a id="more"></a><h2 id="MySQL窗口函数列表"><a href="#MySQL窗口函数列表" class="headerlink" title="MySQL窗口函数列表"></a>MySQL窗口函数列表</h2><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><strong>序号函数</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>ROW_NUMBER</code></td><td style="text-align:left">为其分区中的每一行分配一个连续整数</td></tr><tr><td style="text-align:left"><code>DENSE_RANK</code></td><td style="text-align:left">根据<code>ORDER BY</code>子句为其分区中的每一行分配一个排名。 它为具有相同值的行分配相同的排名。 如果两行或更多行具有相同的等级，则排序值序列中将没有间隙。</td></tr><tr><td style="text-align:left"><code>RANK</code></td><td style="text-align:left">与<code>DENSE_RANK()</code>函数类似，只是当两行或更多行具有相同的排名时，排序值序列中存在间隙。</td></tr><tr><td style="text-align:left"><strong>分布函数</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>PERCENT_RANK</code></td><td style="text-align:left">计算分区或结果集中行的百分位数</td></tr><tr><td style="text-align:left"><code>CUME_DIST</code></td><td style="text-align:left">计算一组值中值的累计分布</td></tr><tr><td style="text-align:left"><strong>前后函数</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>LAG</code></td><td style="text-align:left">返回分区中当前行之前的第N行的值。 如果不存在前一行，则返回NULL。</td></tr><tr><td style="text-align:left"><code>LEAD</code></td><td style="text-align:left">返回分区中当前行之后的第N行的值。 如果不存在后续行，则返回NULL。</td></tr><tr><td style="text-align:left"><strong>头尾函数</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>FIRST_VALUE</code></td><td style="text-align:left">返回指定表达式相对于窗口框架中第一行的值。</td></tr><tr><td style="text-align:left"><code>LAST_VALUE</code></td><td style="text-align:left">返回指定表达式相对于窗口框架中最后一行的值。</td></tr><tr><td style="text-align:left"><strong>聚合函数</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>SUM,AVG,COUNT,MAX</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>MEDIAN</code></td><td style="text-align:left">中位数</td></tr><tr><td style="text-align:left"><code>STDDEV</code></td><td style="text-align:left">总体标准差</td></tr><tr><td style="text-align:left"><code>STDDEV_SAMP</code></td><td style="text-align:left">样本标准差</td></tr><tr><td style="text-align:left"><strong>其他函数</strong></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>NTH_VALUE</code></td><td style="text-align:left">返回窗口框架第N行的参数值</td></tr><tr><td style="text-align:left"><code>NTILE</code></td><td style="text-align:left">将每个窗口分区的行分配到指定数量的已排名组中。</td></tr></tbody></table><h2 id="窗口函数详解-结合案例"><a href="#窗口函数详解-结合案例" class="headerlink" title="窗口函数详解-结合案例"></a>窗口函数详解-结合案例</h2><p>以订单表<code>orders</code>为例，来介绍每个函数的使用方法。表中各字段含义按顺序分别为<code>order_id订单号</code>、<code>user_no用户id</code>、<code>amount订单金额</code>、<code>create_date订单创建日期</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`orders`</span> (</span><br><span class="line">  <span class="string">`order_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`user_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`amount`</span> <span class="built_in">decimal</span>(<span class="number">14</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`create_date`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`order_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders ( order_id, user_no, amount, create_date )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="string">'2020-01-01 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">1</span>, <span class="number">300</span>, <span class="string">'2020-01-02 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="number">1</span>, <span class="number">500</span>, <span class="string">'2020-01-02 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="number">1</span>, <span class="number">800</span>, <span class="string">'2020-01-03 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">5</span>, <span class="number">1</span>, <span class="number">900</span>, <span class="string">'2020-01-04 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">6</span>, <span class="number">2</span>, <span class="number">500</span>, <span class="string">'2020-01-03 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">7</span>, <span class="number">2</span>, <span class="number">600</span>, <span class="string">'2020-01-04 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">8</span>, <span class="number">2</span>, <span class="number">300</span>, <span class="string">'2020-01-10 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">9</span>, <span class="number">2</span>, <span class="number">800</span>, <span class="string">'2020-01-16 00:00:00'</span> ),</span><br><span class="line">    ( <span class="number">10</span>, <span class="number">2</span>, <span class="number">800</span>, <span class="string">'2020-01-22 00:00:00'</span> );</span><br></pre></td></tr></table></figure><h3 id="序号函数"><a href="#序号函数" class="headerlink" title="序号函数"></a>序号函数</h3><ul><li>序号函数: <code>row_number()</code>, <code>rank()</code>, <code>dense_rank()</code><ul><li>用途: <code>显示分区中的当前行号</code></li><li>使用场景: 查询每个用户订单金额最高的前三个订单</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ( </span><br><span class="line">        <span class="keyword">SELECT</span> </span><br><span class="line">            ROW_NUMBER() <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">DESC</span> ) <span class="keyword">AS</span> row_num,</span><br><span class="line">            order_id, user_no, amount, create_date </span><br><span class="line">            <span class="keyword">FROM</span> orders </span><br><span class="line">) t <span class="keyword">WHERE</span> row_num &lt;= <span class="number">3</span></span><br></pre></td></tr></table></figure><p>此时可以使用<code>ROW_NUMBER()</code>函数<strong>按照用户进行分组并按照订单金额进行由大到小排序</strong>，最后查找每组中序号&lt;=3的记录。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">row<span class="emphasis">_num  order_</span>id  user<span class="emphasis">_no amount  create_</span>date</span><br><span class="line"> 1         5         1     900     2020-01-04 00:00:00</span><br><span class="line"> 2         4         1     800     2020-01-03 00:00:00</span><br><span class="line"> 3         3         1     500     2020-01-02 00:00:00</span><br><span class="line"> 1         9         2     800     2020-01-16 00:00:00</span><br><span class="line"> 2         10        2     800     2020-01-22 00:00:00</span><br><span class="line"> 3         7         2     600     2020-01-04 00:00:00</span><br></pre></td></tr></table></figure><p>对于用户<code>2</code>的订单，大家发现订单金额为800的有两条，<strong>序号随机排了1和2</strong>，但很多情况下二者应该是并列第一，而订单为600的序号则可能是第二名，也可能为第三名，这时候，<code>row_number</code>就不能满足需求，需要<code>rank</code>和<code>dense_rank</code>出场。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>* <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        ROW_NUMBER() <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">DESC</span> ) <span class="keyword">AS</span> row_num1,</span><br><span class="line">        <span class="keyword">RANK</span>() <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">DESC</span> ) <span class="keyword">AS</span> row_num2,</span><br><span class="line">        <span class="keyword">DENSE_RANK</span>() <span class="keyword">over</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">DESC</span> ) <span class="keyword">AS</span> row_num3, </span><br><span class="line">        order_id,</span><br><span class="line">        user_no,</span><br><span class="line">        amount,</span><br><span class="line">        create_date </span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        orders </span><br><span class="line">    ) t </span><br><span class="line"><span class="keyword">WHERE</span>row_num1 &lt;= <span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">row<span class="emphasis">_num1    row_</span>num2    row<span class="emphasis">_num3    order_</span>id    user<span class="emphasis">_no  amount  create_</span>date</span><br><span class="line">  1           1           1           5           1        900     2020-01-04 00:00:00</span><br><span class="line">  2           2           2           4           1        800     2020-01-03 00:00:00</span><br><span class="line">  3           3           3           3           1        500     2020-01-02 00:00:00</span><br><span class="line">  1           1           1           9           2        800     2020-01-16 00:00:00</span><br><span class="line">  2           1           1           10          2        800     2020-01-22 00:00:00</span><br><span class="line">  3           3           2           7           2        600     2020-01-04 00:00:00</span><br></pre></td></tr></table></figure><ul><li><code>row_number()</code>在amount都是800的两条记录上随机排序，但序号按照1、2递增，后面amount为600的的序号继续递增为3，中间不会产生序号间隙；</li><li><code>rank()</code>/<code>dense_rank()</code>则把amount为800的两条记录序号都设置为1，但后续amount为600的需要则分别设置为3（rank）和2（dense_rank）。<blockquote><p>即rank()会产生序号相同的记录，同时可能产生序号间隙；而dense_rank()也会产生序号相同的记录，但不会产生序号间隙。</p></blockquote></li></ul><h3 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h3><ul><li>分布函数: <code>percent_rank()</code>, <code>cume_dist()</code><ul><li>用途: 和之前的RANK()函数相关，每行按照如下公式进行计算：<code>(rank - 1) / (rows - 1)</code></li><li>应用场景: 大于等于当前订单金额的订单比例有多少。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        <span class="keyword">RANK</span>() <span class="keyword">over</span> w <span class="keyword">AS</span> row_num,</span><br><span class="line">        <span class="keyword">CUME_DIST</span>() <span class="keyword">over</span> w <span class="keyword">AS</span> <span class="keyword">percent</span>,</span><br><span class="line">        order_id,</span><br><span class="line">        user_no,</span><br><span class="line">        amount </span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    orders <span class="keyword">window</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> amount <span class="keyword">DESC</span> ) </span><br><span class="line">) t;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">row<span class="emphasis">_num  percent  order_</span>id  user_no   amount</span><br><span class="line"> 1         0.2       5          1      900</span><br><span class="line"> 2         0.4       4          1      800</span><br><span class="line"> 3         0.6       3          1      500</span><br><span class="line"> 4         0.8       2          1      300</span><br><span class="line"> 5         1         1          1      100</span><br><span class="line"> 1         0.4       9          2      800</span><br><span class="line"> 1         0.4       10         2      800</span><br><span class="line"> 3         0.6       7          2      600</span><br><span class="line"> 4         0.8       6          2      500</span><br><span class="line"> 5         1         8          2      300</span><br></pre></td></tr></table></figure><h3 id="前后函数"><a href="#前后函数" class="headerlink" title="前后函数"></a>前后函数</h3><ul><li>前后函数: <code>lead()</code>, <code>lag()</code><ul><li>用途: 分区中位于当前n行(lead) / 后n行(lag)的记录值</li><li>使用场景: 查询上一个订单距离当前订单的时间间隔</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    order_id,</span><br><span class="line">    user_no,</span><br><span class="line">    amount,</span><br><span class="line">    create_date,</span><br><span class="line">    last_date,</span><br><span class="line">    <span class="keyword">DATEDIFF</span>( create_date, last_date ) <span class="keyword">AS</span> diff </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        order_id,</span><br><span class="line">        user_no,</span><br><span class="line">        amount,</span><br><span class="line">        create_date,</span><br><span class="line">        lag( create_date, <span class="number">1</span> ) <span class="keyword">over</span> w <span class="keyword">AS</span> last_date </span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    orders <span class="keyword">window</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_date ) </span><br><span class="line">    ) t;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">order<span class="emphasis">_id  user_</span>no  amount    create<span class="emphasis">_date          last_</span>date          diff</span><br><span class="line">  1         1       100    2020-01-01 00:00:00      </span><br><span class="line">  2         1       300    2020-01-02 00:00:00  2020-01-01 00:00:00   1</span><br><span class="line">  3         1       500    2020-01-02 00:00:00  2020-01-02 00:00:00   0</span><br><span class="line">  4         1       800    2020-01-03 00:00:00  2020-01-02 00:00:00   1</span><br><span class="line">  5         1       900    2020-01-04 00:00:00  2020-01-03 00:00:00   1</span><br><span class="line">  6         2       500    2020-01-03 00:00:00      </span><br><span class="line">  7         2       600    2020-01-04 00:00:00  2020-01-03 00:00:00   1</span><br><span class="line">  8         2       300    2020-01-10 00:00:00  2020-01-04 00:00:00   6</span><br><span class="line">  9         2       800    2020-01-16 00:00:00  2020-01-10 00:00:00   6</span><br><span class="line">  10        2       800    2020-01-22 00:00:00  2020-01-16 00:00:00   6</span><br></pre></td></tr></table></figure><p>内层SQL先通过lag函数得到上一次订单的日期，外层SQL再将本次订单和上次订单日期做差得到时间间隔diff。</p><h3 id="头尾函数"><a href="#头尾函数" class="headerlink" title="头尾函数"></a>头尾函数</h3><ul><li>头尾函数: <code>first_val(expr)</code>, <code>last_val(expr)</code><ul><li>用途: 得到分区中的第一个/最后一个指定参数的值</li><li>使用场景: 查询截止到当前订单, 按照日期顺序第一个订单和最后一个订单的订单金额</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        order_id,user_no,amount,create_date,</span><br><span class="line">        <span class="keyword">FIRST_VALUE</span>(amount) <span class="keyword">over</span> w <span class="keyword">as</span> first_amount,</span><br><span class="line">        <span class="keyword">LAST_VALUE</span>(amount) <span class="keyword">over</span> w <span class="keyword">as</span> last_amount</span><br><span class="line">    <span class="keyword">FROM</span> orders </span><br><span class="line">    <span class="keyword">window</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> create_date ) </span><br><span class="line">) t;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">order<span class="emphasis">_id  user_</span>no  amount   create<span class="emphasis">_date         first_</span>amount  last_amount</span><br><span class="line">  1         1        100    2020-01-01 00:00:00    100             100</span><br><span class="line">  2         1        300    2020-01-02 00:00:00    100             500</span><br><span class="line">  3         1        500    2020-01-02 00:00:00    100             500</span><br><span class="line">  4         1        800    2020-01-03 00:00:00    100             800</span><br><span class="line">  5         1        900    2020-01-04 00:00:00    100             900</span><br><span class="line">  6         2        500    2020-01-03 00:00:00    500             500</span><br><span class="line">  7         2        600    2020-01-04 00:00:00    500             600</span><br><span class="line">  8         2        300    2020-01-10 00:00:00    500             300</span><br><span class="line">  9         2        800    2020-01-16 00:00:00    500             800</span><br><span class="line">  10        2        800    2020-01-22 00:00:00    500             800</span><br></pre></td></tr></table></figure><p>结果和预期一致，比如order_id为4的记录，<code>first_amount</code>和<code>last_amount</code>分别记录了用户‘1’截止到时间2018-01-03 00:00:00为止，第一条订单金额100和最后一条订单金额800，<strong>注意这里是按时间排序的最早订单和最晚订单</strong>，并不是最小金额和最大金额订单。</p><h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ul><li>其他函数: <code>nth_value(expr,n)</code>, <code>nfile(n)</code></li></ul><blockquote><p><code>nth_value(expr,n)</code></p><ul><li>用途: 返回窗口中第N个expr的值,expr可以是表达式,也可以是列名</li><li>应用场景: 每个用户订单显示本用户金额第二和第三的订单金额</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        order_id,user_no,amount,create_date,</span><br><span class="line">        <span class="keyword">NTH_VALUE</span>(amount,<span class="number">2</span>) <span class="keyword">over</span> w <span class="keyword">as</span> second_amount,</span><br><span class="line">        <span class="keyword">NTH_VALUE</span>(amount,<span class="number">3</span>) <span class="keyword">over</span> w <span class="keyword">as</span> third_amount</span><br><span class="line">    <span class="keyword">FROM</span> orders </span><br><span class="line">    <span class="keyword">window</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> amount ) </span><br><span class="line">) t;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">order<span class="emphasis">_id  user_</span>no  amount    create<span class="emphasis">_date          second_</span>amount   third_amount</span><br><span class="line">  1          1       100     2020-01-01 00:00:00                    </span><br><span class="line">  2          1       300     2020-01-02 00:00:00     300            </span><br><span class="line">  3          1       500     2020-01-02 00:00:00     300            500</span><br><span class="line">  4          1       800     2020-01-03 00:00:00     300            500</span><br><span class="line">  5          1       900     2020-01-04 00:00:00     300            500</span><br><span class="line">  8          2       300     2020-01-10 00:00:00                    </span><br><span class="line">  6          2       500     2020-01-03 00:00:00     500            </span><br><span class="line">  7          2       600     2020-01-04 00:00:00     500            600</span><br><span class="line">  9          2       800     2020-01-16 00:00:00     500            600</span><br><span class="line">  10         2       800     2020-01-22 00:00:00     500            600</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul><li>用途: 在窗口中每条记录动态应用聚合函数(sum/avg/max/min/count)，可以动态计算在指定的窗口内的各种聚合函数值</li><li>使用场景: 每个用户按照订单id，截止到当前的累计订单金额/平均订单金额/最大订单金额/最小订单金额/订单数是多少？</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        order_id,user_no,amount,create_date,</span><br><span class="line">        <span class="keyword">sum</span>(amount) <span class="keyword">over</span> w <span class="keyword">as</span> sum1,</span><br><span class="line">        <span class="keyword">avg</span>(amount) <span class="keyword">over</span> w <span class="keyword">as</span> avg1,</span><br><span class="line">        <span class="keyword">max</span>(amount) <span class="keyword">over</span> w <span class="keyword">as</span> max1,</span><br><span class="line">        <span class="keyword">min</span>(amount) <span class="keyword">over</span> w <span class="keyword">as</span> min1,</span><br><span class="line">        <span class="keyword">count</span>(amount) <span class="keyword">over</span> w <span class="keyword">as</span> count1</span><br><span class="line">    <span class="keyword">FROM</span> orders </span><br><span class="line">    <span class="keyword">window</span> w <span class="keyword">AS</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> user_no <span class="keyword">ORDER</span> <span class="keyword">BY</span> order_id ) </span><br><span class="line">) t;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">order<span class="emphasis">_id  user_</span>no  amount  create_date           sum1  avg1    max1   min1  count1</span><br><span class="line">  1         1       100    2020-01-01 00:00:00   100    100    100    100    1</span><br><span class="line">  2         1       300    2020-01-02 00:00:00   400    200    300    100    2</span><br><span class="line">  3         1       500    2020-01-02 00:00:00   900    300    500    100    3</span><br><span class="line">  4         1       800    2020-01-03 00:00:00   1700   425    800    100    4</span><br><span class="line">  5         1       900    2020-01-04 00:00:00   2600   520    900    100    5</span><br><span class="line">  6         2       500    2020-01-03 00:00:00   500    500    500    500    1</span><br><span class="line">  7         2       600    2020-01-04 00:00:00   1100   550    600    500    2</span><br><span class="line">  8         2       300    2020-01-10 00:00:00   1400   466    600    300    3</span><br><span class="line">  9         2       800    2020-01-16 00:00:00   2200   550    800    300    4</span><br><span class="line">  10        2       800    2020-01-22 00:00:00   3000   600    800    300    5</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="窗口函数语法"><a href="#窗口函数语法" class="headerlink" title="窗口函数语法"></a>窗口函数语法</h3><blockquote><p>&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt; order by &lt;用于排序的列名&gt;)</p></blockquote><ul><li>&lt;窗口函数&gt;的位置,可以放以下两种函数:<ol><li>专用的窗口函数, 比如 <code>rank()</code>, <code>dense_rank()</code>, <code>row_number()</code>等</li><li>聚合函数, 如 <code>sum</code>,<code>avg</code>,<code>count</code>,<code>max</code>,<code>min</code>等  </li></ol></li></ul><h3 id="窗口函数的功能"><a href="#窗口函数的功能" class="headerlink" title="窗口函数的功能"></a>窗口函数的功能</h3><ul><li><ol><li>同时具有 <code>分组(partition by)</code> 和 <code>排序(order by)</code> 的功能</li></ol></li><li><ol start="2"><li>不减少原表的行数, 所以经常用来每组内排名</li></ol></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://help.aliyun.com/document_detail/34994.html" target="_blank" rel="noopener">阿里云窗口函数</a></li><li><a href="https://www.begtut.com/mysql/mysql-window-functions.html" target="_blank" rel="noopener">MySQL 窗口函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;窗口函数再深入,结合案例详解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.caoxl.com/categories/MySQL/"/>
    
    
      <category term="MySQL8" scheme="http://blog.caoxl.com/tags/MySQL8/"/>
    
      <category term="窗口函数" scheme="http://blog.caoxl.com/tags/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>DNMP Docker-Compose</title>
    <link href="http://blog.caoxl.com/2022/06/14/DNMP-Docker-Compose/"/>
    <id>http://blog.caoxl.com/2022/06/14/DNMP-Docker-Compose/</id>
    <published>2022-06-14T01:45:21.000Z</published>
    <updated>2022-06-14T01:49:02.672Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>DNMP（Docker + Nginx/Openresty + MySQL5,8 + PHP5,7,8 + Redis + ElasticSearch + MongoDB + RabbitMQ）是一款全功能的LNMP一键安装程序，支持Arm CPU。<br><a href="https://github.com/yeszao/dnmp" target="_blank" rel="noopener">DNMP</a></p></blockquote><a id="more"></a><h2 id="记录我自己的DNMP"><a href="#记录我自己的DNMP" class="headerlink" title="记录我自己的DNMP"></a>记录我自己的DNMP</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./services/nginx</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">NGINX_VERSION:</span> <span class="string">$&#123;NGINX_VERSION&#125;</span></span><br><span class="line">        <span class="attr">CONTAINER_PACKAGE_URL:</span> <span class="string">$&#123;CONTAINER_PACKAGE_URL&#125;</span></span><br><span class="line">        <span class="attr">NGINX_INSTALL_APPS:</span> <span class="string">$&#123;NGINX_INSTALL_APPS&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;NGINX_HTTP_HOST_PORT&#125;:80"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;NGINX_HTTPS_HOST_PORT&#125;:443"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;SOURCE_DIR&#125;:/www/:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;NGINX_SSL_CERTIFICATE_DIR&#125;:/ssl:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;NGINX_CONFD_DIR&#125;:/etc/nginx/conf.d/:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;NGINX_CONF_FILE&#125;:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;NGINX_FASTCGI_PHP_CONF&#125;:/etc/nginx/fastcgi-php.conf:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;NGINX_FASTCGI_PARAMS&#125;:/etc/nginx/fastcgi_params:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;NGINX_LOG_DIR&#125;:/var/log/nginx/:rw</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">php:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./services/php</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">PHP_VERSION:</span> <span class="string">php:$&#123;PHP_VERSION&#125;-fpm-alpine</span></span><br><span class="line">        <span class="attr">CONTAINER_PACKAGE_URL:</span> <span class="string">$&#123;CONTAINER_PACKAGE_URL&#125;</span></span><br><span class="line">        <span class="attr">PHP_EXTENSIONS:</span> <span class="string">$&#123;PHP_EXTENSIONS&#125;</span></span><br><span class="line">        <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">php</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9501</span></span><br><span class="line">    <span class="attr">extra_hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"www.site1.com:172.17.0.1"</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8010:8010"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9501:9501"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9502:9502"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9503:9503"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9801:9801"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9802:9802"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;SOURCE_DIR&#125;:/www/:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;PHP_PHP_CONF_FILE&#125;:/usr/local/etc/php/php.ini:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;PHP_FPM_CONF_FILE&#125;:/usr/local/etc/php-fpm.d/www.conf:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;PHP_LOG_DIR&#125;:/var/log/php</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DATA_DIR&#125;/composer:/tmp/composer</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SYS_PTRACE</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:$&#123;MYSQL_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;MYSQL_HOST_PORT&#125;:3306"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;MYSQL_CONF_FILE&#125;:/etc/mysql/conf.d/mysql.cnf:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DATA_DIR&#125;/mysql:/var/lib/mysql/:rw</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">"$&#123;MYSQL_ROOT_PASSWORD&#125;"</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mysql5:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:$&#123;MYSQL5_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql5</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;MYSQL5_HOST_PORT&#125;:3306"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;MYSQL5_CONF_FILE&#125;:/etc/mysql/conf.d/mysql.cnf:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DATA_DIR&#125;/mysql5:/var/lib/mysql/:rw</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">"$&#123;MYSQL5_ROOT_PASSWORD&#125;"</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:$&#123;REDIS_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;REDIS_HOST_PORT&#125;:6379"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;REDIS_CONF_FILE&#125;:/etc/redis.conf:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DATA_DIR&#125;/redis:/data/:rw</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">entrypoint:</span> <span class="string">["redis-server",</span> <span class="string">"/etc/redis.conf"</span><span class="string">]</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rabbitmq:$&#123;RABBITMQ_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rabbitmq</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;RABBITMQ_HOST_PORT_C&#125;:5672"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;RABBITMQ_HOST_PORT_S&#125;:15672"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">       <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line">       <span class="attr">RABBITMQ_DEFAULT_USER:</span> <span class="string">"$&#123;RABBITMQ_DEFAULT_USER&#125;"</span></span><br><span class="line">       <span class="attr">RABBITMQ_DEFAULT_PASS:</span> <span class="string">"$&#123;RABBITMQ_DEFAULT_PASS&#125;"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongodb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:$&#123;MONGODB_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">MONGO_INITDB_ROOT_USERNAME:</span> <span class="string">"$&#123;MONGODB_INITDB_ROOT_USERNAME&#125;"</span></span><br><span class="line">        <span class="attr">MONGO_INITDB_ROOT_PASSWORD:</span> <span class="string">"$&#123;MONGODB_INITDB_ROOT_PASSWORD&#125;"</span></span><br><span class="line">        <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DATA_DIR&#125;/mongo:/data/db:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DATA_DIR&#125;/mongo_key:/mongo:rw</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">"$&#123;MONGODB_HOST_PORT&#125;:27017"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">       <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">       <span class="string">--auth</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">elasticsearch:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./services/elasticsearch</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">ELASTICSEARCH_VERSION:</span> <span class="string">$&#123;ELASTICSEARCH_VERSION&#125;</span></span><br><span class="line">        <span class="attr">ELASTICSEARCH_PLUGINS:</span> <span class="string">$&#123;ELASTICSEARCH_PLUGINS&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=$TZ</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.type=single-node</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ES_JAVA_OPTS=-Xms512m -Xmx512m"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DATA_DIR&#125;/esdata:/usr/share/elasticsearch/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;ELASTICSEARCH_CONF_FILE&#125;:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;ELASTICSEARCH_HOST_PORT_C&#125;:9200"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;ELASTICSEARCH_HOST_PORT_S&#125;:9300"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kibana:$&#123;KIBANA_VERSION&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line">      <span class="attr">elasticsearch.hosts:</span> <span class="string">http://elasticsearch:9200</span></span><br><span class="line">      <span class="attr">I18N_LOCALE:</span> <span class="string">"$&#123;KIBANA_I18N_LOCALE&#125;"</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"$&#123;KIBANA_HOST&#125;:5601"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jenkins:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jenkins/jenkins:lts</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;DATA_DIR&#125;/jenkins/:/var/jenkins_home</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/bin/docker:/usr/bin/docker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/lib/x86_64-linux-gnu/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081:8080"</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8081"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"50000"</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">JAVA_OPTS:</span> <span class="string">'-Djava.util.logging.config.file=/var/jenkins_home/log.properties'</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/zookeeper</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"2181:2181"</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9092:9092"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"9999:9999"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">"$TZ"</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_HOST_NAME:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper:2181</span></span><br><span class="line">      <span class="comment"># 非必须，设置</span></span><br><span class="line">      <span class="attr">KAFKA_MESSAGE_MAX_BYTES:</span> <span class="number">20000000</span></span><br><span class="line">      <span class="attr">KAFKA_AUTO_CREATE_TOPICS_ENABLE:</span> <span class="string">"true"</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_PORT:</span> <span class="string">$&#123;KAFKA_HOST_PORT&#125;</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">PLAINTEXT://127.0.0.1:9092</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">PLAINTEXT://:9092</span></span><br><span class="line">      <span class="attr">KAFKA_HEAP_OPTS:</span> <span class="string">"-Xms256m -Xmx256m"</span></span><br><span class="line">      <span class="attr">KAFKA_JMX_PORT:</span> <span class="number">9999</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/kafka:/kafka</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka-manager:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sheepkiller/kafka-manager</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9020</span><span class="string">:9000</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZK_HOSTS:</span> <span class="string">zookeeper:2181</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">kafka</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">node:</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">node:$&#123;NODE_VERSION&#125;</span></span><br><span class="line">   <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">NODE_ENV=production</span></span><br><span class="line">   <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">$&#123;SOURCE_DIR&#125;:/www/:rw</span></span><br><span class="line">   <span class="attr">expose:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">"8082"</span></span><br><span class="line">   <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">   <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">   <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">default:</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;DNMP（Docker + Nginx/Openresty + MySQL5,8 + PHP5,7,8 + Redis + ElasticSearch + MongoDB + RabbitMQ）是一款全功能的LNMP一键安装程序，支持Arm CPU。&lt;br&gt;&lt;a href=&quot;https://github.com/yeszao/dnmp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DNMP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Caoxl" scheme="http://blog.caoxl.com/categories/Caoxl/"/>
    
    
      <category term="Docker" scheme="http://blog.caoxl.com/tags/Docker/"/>
    
      <category term="DNMP" scheme="http://blog.caoxl.com/tags/DNMP/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse</title>
    <link href="http://blog.caoxl.com/2022/05/12/ClickHouse-MySQL/"/>
    <id>http://blog.caoxl.com/2022/05/12/ClickHouse-MySQL/</id>
    <published>2022-05-12T01:36:11.000Z</published>
    <updated>2022-05-12T01:39:01.941Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.caoxl.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.caoxl.com/tags/MySQL/"/>
    
      <category term="ClickHouse" scheme="http://blog.caoxl.com/tags/ClickHouse/"/>
    
  </entry>
  
  <entry>
    <title>AnalyticDB</title>
    <link href="http://blog.caoxl.com/2022/05/12/AnalyticDB-MySQL/"/>
    <id>http://blog.caoxl.com/2022/05/12/AnalyticDB-MySQL/</id>
    <published>2022-05-12T01:35:34.000Z</published>
    <updated>2022-05-12T03:27:48.667Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>AnalyticDB For MySQL 云原生数据仓库<br>以下内容仅是我个人的学习路线,记录一些关键点</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>AnalyticDB 简称ADB; 诞生于 2012 年，2016 年开始商业化发布 <code>2.0</code> 版本，并对外提供服务。2018 年发布 <code>3.0</code> 版本（也是目前的主版本）<br>它支持 100PB 级数据量、实时读写查询、读写数据一致性、数据库自身包含高可用、兼容 SQL2003。在定位上，它是一款 <code>OLAP</code> 数据库</p></blockquote><h2 id="什么是OLAP，什么是OLTP？"><a href="#什么是OLAP，什么是OLTP？" class="headerlink" title="什么是OLAP，什么是OLTP？"></a>什么是OLAP，什么是OLTP？</h2><ul><li><code>OLAP</code>: <code>OnLine Analytical Processing</code> 联机分析处理</li><li><code>OLTP</code>: <code>OnLine Transaction Processing</code> 联机事务处理</li></ul><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><blockquote><p><a href="https://help.aliyun.com/document_detail/188322.html" target="_blank" rel="noopener">AnalyticDB MySQL使用流程</a></p></blockquote><h1 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h1><ul><li>如果需要公网连接集群,需要<a href="https://help.aliyun.com/document_detail/122252.html" target="_blank" rel="noopener">申请公网地址</a></li></ul><h1 id="数据导入导出"><a href="#数据导入导出" class="headerlink" title="数据导入导出"></a>数据导入导出</h1><ul><li><a href="https://help.aliyun.com/document_detail/123754.html" target="_blank" rel="noopener">支持的数据源</a></li></ul><h1 id="SQL偏移表"><a href="#SQL偏移表" class="headerlink" title="SQL偏移表"></a>SQL偏移表</h1><ul><li><a href="https://help.aliyun.com/document_detail/197342.html" target="_blank" rel="noopener">DDL差异</a></li><li><a href="https://help.aliyun.com/document_detail/197345.html" target="_blank" rel="noopener">DML差异</a></li></ul><h1 id="SQL复杂数据类型"><a href="#SQL复杂数据类型" class="headerlink" title="SQL复杂数据类型"></a>SQL复杂数据类型</h1><blockquote><p>为赋能用户、降低用户处理半结构化数据的难度，AnalyticDB MySQL版提供了半结构化数据检索功能即JSON索引。</p></blockquote><ul><li><a href="https://help.aliyun.com/document_detail/124834.html" target="_blank" rel="noopener">JSON</a></li></ul><h1 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h1><ul><li><a href="https://help.aliyun.com/document_detail/120397.html" target="_blank" rel="noopener">窗口函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;AnalyticDB For MySQL 云原生数据仓库&lt;br&gt;以下内容仅是我个人的学习路线,记录一些关键点&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.caoxl.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://blog.caoxl.com/tags/MySQL/"/>
    
      <category term="AnalyticDB" scheme="http://blog.caoxl.com/tags/AnalyticDB/"/>
    
  </entry>
  
  <entry>
    <title>每日算法 2</title>
    <link href="http://blog.caoxl.com/2022/03/18/Daily-Algorithm-2/"/>
    <id>http://blog.caoxl.com/2022/03/18/Daily-Algorithm-2/</id>
    <published>2022-03-18T03:48:25.000Z</published>
    <updated>2022-04-06T01:58:06.467Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>知耻而后勇, 日积月累, 每月一篇博客<br>以下内容, 记录自己刷题过程</p></blockquote><a id="more"></a><h3 id="954-二倍数对数组"><a href="#954-二倍数对数组" class="headerlink" title="954. 二倍数对数组"></a>954. 二倍数对数组</h3><p><a href="https://leetcode-cn.com/problems/array-of-doubled-pairs/" target="_blank" rel="noopener">LeetCode - 954. 二倍数对数组</a></p><blockquote><p>解题思路: 哈希表+排序</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[] $arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">canReorderDoubled</span><span class="params">($arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 对数组中的所有值进行计数</span></span><br><span class="line">        $count = array_count_values($arr);</span><br><span class="line">        <span class="keyword">if</span> ($count[<span class="number">0</span>] % <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        usort($arr, <span class="function"><span class="keyword">function</span> <span class="params">($a, $b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> abs($a) - abs($b);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">foreach</span> ($arr <span class="keyword">as</span> $x) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($count[$x] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ($count[<span class="number">2</span> * $x] &lt; $count[$x]) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 无法找到足够的2x和x配对</span></span><br><span class="line">            $count[$x] -= <span class="number">1</span>;</span><br><span class="line">            $count[<span class="number">2</span> * $x] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="420-强密码检验器"><a href="#420-强密码检验器" class="headerlink" title="420. 强密码检验器"></a>420. 强密码检验器</h3><p><a href="https://leetcode-cn.com/problems/strong-password-checker/" target="_blank" rel="noopener">LeetCode - 420. 强密码检验器</a></p><blockquote><p>解题思路: 分类讨论</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">strongPasswordChecker</span><span class="params">($password)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $hasLower = $hasUpper = $hasDigit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        $n = strlen($password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isLower($password[$i])) &#123;</span><br><span class="line">                $hasLower = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (<span class="keyword">$this</span>-&gt;isUpper($password[$i])) &#123;</span><br><span class="line">                $hasUpper = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> (is_numeric($password[$i])) &#123;</span><br><span class="line">                $hasDigit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $categories = $hasLower + $hasUpper + $hasDigit;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">switch</span> ($n) &#123;</span><br><span class="line">            <span class="keyword">case</span> $n &lt; <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> max(<span class="number">6</span> - $n, <span class="number">3</span> - $categories);</span><br><span class="line">            <span class="keyword">case</span> $n &lt;= <span class="number">20</span>:</span><br><span class="line">                $replace = $cnt = <span class="number">0</span>;</span><br><span class="line">                $cur = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ($password[$i] == $cur) &#123;</span><br><span class="line">                        $cnt++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        $replace += floor($cnt / <span class="number">3</span>);</span><br><span class="line">                        $cnt = <span class="number">1</span>;</span><br><span class="line">                        $cur = $password[$i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                $replace += floor($cnt / <span class="number">3</span>); <span class="comment">// 解决PHP隐式转换问题</span></span><br><span class="line">                <span class="keyword">return</span> max($replace, <span class="number">3</span> - $categories);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 替换次数和删除次数</span></span><br><span class="line">                $replace = <span class="number">0</span>;</span><br><span class="line">                $remove = $n - <span class="number">20</span>;</span><br><span class="line">                <span class="comment">// k mod 3 = 1 的组数,删除2个字符可以减少1次替换操作</span></span><br><span class="line">                $rm2 = $cnt =  <span class="number">0</span>;</span><br><span class="line">                $cur = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ($password[$i] == $cur) &#123;</span><br><span class="line">                        $cnt++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ($remove &gt; <span class="number">0</span> &amp;&amp; $cnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ($cnt % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果是 k mod 3 = 0 的组, 优先删除1个字符, 减少1次替换操作</span></span><br><span class="line">                            $remove--;</span><br><span class="line">                            $replace--;</span><br><span class="line">                        &#125; <span class="keyword">elseif</span> ($cnt % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="comment">// 如果是 k mod 3 = 1 的组, 存下来备用</span></span><br><span class="line">                            $rm2++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    $replace += floor($cnt / <span class="number">3</span>);</span><br><span class="line">                    $cnt = <span class="number">1</span>;</span><br><span class="line">                    $cur = $password[$i];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ($remove &gt; <span class="number">0</span> &amp;&amp; $cnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ($cnt % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        $remove--;</span><br><span class="line">                        $replace--;</span><br><span class="line">                    &#125; <span class="keyword">elseif</span> ($cnt % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        $rm2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                $replace += floor($cnt / <span class="number">3</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用 k mod 3 =1 的组的数量, 由剩余的替换次数, 组数和剩余的删除次数共同决定</span></span><br><span class="line">                $use2 = min(min($replace, $rm2), (int)($remove / <span class="number">2</span>));</span><br><span class="line">                $replace -= $use2;</span><br><span class="line">                $remove -= $use2 * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                $use3 = min($replace, (int)($remove / <span class="number">3</span>));</span><br><span class="line">                $replace -= $use3;</span><br><span class="line">                $remove -= $use3 * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ($n - <span class="number">20</span>) + max($replace, <span class="number">3</span> - $categories);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否小写字母</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isLower</span><span class="params">($char)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ord($char) &gt;= ord(<span class="string">'a'</span>) &amp;&amp; ord($char) &lt;= ord(<span class="string">'z'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否大写字母</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isUpper</span><span class="params">($char)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ord($char) &gt;= ord(<span class="string">'A'</span>) &amp;&amp; ord($char) &lt;= ord(<span class="string">'Z'</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">### 744. 寻找比目标字母大的最小字母</span></span><br><span class="line"></span><br><span class="line">[LeetCode - <span class="number">744.</span> 寻找比目标字母大的最小字母](https:<span class="comment">//leetcode-cn.com/problems/find-smallest-letter-greater-than-target/)</span></span><br><span class="line"></span><br><span class="line">&gt; 解题思路: 线性查找</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String[] $letters</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $target</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">nextGreatestLetter</span><span class="params">($letters, $target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> ($letters <span class="keyword">as</span> $letter) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($letter &gt; $target) &#123;</span><br><span class="line">                <span class="keyword">return</span> $letter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="307-区域和检索-数组可修改"><a href="#307-区域和检索-数组可修改" class="headerlink" title="307. 区域和检索 - 数组可修改"></a>307. 区域和检索 - 数组可修改</h3><p><a href="https://leetcode-cn.com/problems/range-sum-query-mutable/" target="_blank" rel="noopener">LeetCode - 307. 区域和检索 - 数组可修改</a></p><blockquote><p>解题思路: 树状数组</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $nums;</span><br><span class="line">    <span class="keyword">private</span> $n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int[] $nums</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;nums = $nums;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;n = count($nums);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;tree = array_fill(<span class="number">0</span>, <span class="keyword">$this</span>-&gt;n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="keyword">$this</span>-&gt;n; $i++) <span class="keyword">$this</span>-&gt;add($i + <span class="number">1</span>, $nums[$i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lowbit</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $x &amp; (-$x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">query</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ($i = $x; $i &gt; <span class="number">0</span>; $i -= <span class="keyword">$this</span>-&gt;lowbit($i))</span><br><span class="line">            $ans += <span class="keyword">$this</span>-&gt;tree[$i];</span><br><span class="line">        <span class="keyword">return</span> $ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">($x, $u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ($i = $x; $i &lt;= <span class="keyword">$this</span>-&gt;n; $i += <span class="keyword">$this</span>-&gt;lowbit($i))</span><br><span class="line">            <span class="keyword">$this</span>-&gt;tree[$i] += $u;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($index, $val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;add($index + <span class="number">1</span>, $val - <span class="keyword">$this</span>-&gt;nums[$index]);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;nums[$index] = $val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sumRange</span><span class="params">($left, $right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;query($right + <span class="number">1</span>) - <span class="keyword">$this</span>-&gt;query($left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="762-二进制表示中质数个计算置位"><a href="#762-二进制表示中质数个计算置位" class="headerlink" title="762. 二进制表示中质数个计算置位"></a>762. 二进制表示中质数个计算置位</h3><p><a href="https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/" target="_blank" rel="noopener">LeetCode - 762. 二进制表示中质数个计算置位</a></p><blockquote><p>解题思路: 数学+位运算</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">countPrimeSetBits</span><span class="params">($left, $right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ($x = $left; $x &lt;= $right; ++$x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isPrime(<span class="keyword">$this</span>-&gt;bitCount($x))) &#123;</span><br><span class="line">                ++$ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isPrime</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">2</span>; $i ** <span class="number">2</span> &lt;= $x; ++$i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($x % $i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bitCount</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $x = $x - (($x &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        $x = ($x &amp; <span class="number">0x33333333</span>) + (($x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        $x = ($x + ($x &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">        $x = $x + ($x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        $x = $x + ($x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> $x &amp; <span class="number">0x3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="310-最小高度树"><a href="#310-最小高度树" class="headerlink" title="310. 最小高度树"></a>310. 最小高度树</h3><p><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">LeetCode - 310. 最小高度树</a></p><blockquote><p>解题思路: 拓扑排序</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[][] $edges</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findMinHeightTrees</span><span class="params">($n, $edges)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $dict = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($edges <span class="keyword">as</span> $pair) &#123;</span><br><span class="line">            $dict[$pair[<span class="number">0</span>]][$pair[<span class="number">1</span>]] = <span class="keyword">true</span>;</span><br><span class="line">            $dict[$pair[<span class="number">1</span>]][$pair[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (count($dict) &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> ($dict <span class="keyword">as</span> $key =&gt; $nodes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count($nodes) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">foreach</span> ($nodes <span class="keyword">as</span> $node =&gt; $_) &#123;</span><br><span class="line">                        <span class="keyword">unset</span>($dict[$key]);</span><br><span class="line">                        <span class="keyword">unset</span>($dict[$node][$key]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count($dict) == <span class="number">0</span>) <span class="keyword">return</span> [<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> array_keys($dict);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;知耻而后勇, 日积月累, 每月一篇博客&lt;br&gt;以下内容, 记录自己刷题过程&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://blog.caoxl.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="算法" scheme="http://blog.caoxl.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日算法 1</title>
    <link href="http://blog.caoxl.com/2022/03/18/Dail-Algorithm-I/"/>
    <id>http://blog.caoxl.com/2022/03/18/Dail-Algorithm-I/</id>
    <published>2022-03-18T03:48:25.000Z</published>
    <updated>2022-04-01T01:35:24.907Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>知耻而后勇, 日积月累, 每月一篇博客<br>以下内容, 记录自己刷题过程</p></blockquote><a id="more"></a><h3 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720. 词典中最长的单词"></a>720. 词典中最长的单词</h3><p><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary/" target="_blank" rel="noopener">LeetCode - 720. 词典中最长的单词</a></p><ul><li><code>2022/03/17</code></li></ul><blockquote><p>解题思路: 字符串排序 + 哈希集合</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String[] $words</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">longestWord</span><span class="params">($words)</span>: <span class="title">String</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 按字符串长度排序</span></span><br><span class="line">        usort($words, <span class="function"><span class="keyword">function</span> <span class="params">($i, $j)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (strlen($i) != strlen($j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> strlen($i) - strlen($j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 字典序小的在前面</span></span><br><span class="line">            <span class="keyword">return</span>  $i &gt; $j ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        $longest = <span class="string">""</span>;</span><br><span class="line">        $hashset = []; <span class="comment">// 哈希集合</span></span><br><span class="line">        $hashset[] = <span class="string">""</span>; <span class="comment">// 将数组转成哈希集合</span></span><br><span class="line">        <span class="keyword">foreach</span> ($words <span class="keyword">as</span> $word) &#123;</span><br><span class="line">            <span class="comment">// 判断当前单词去掉最后一个字母之后的前缀是否在哈希集合中</span></span><br><span class="line">            <span class="keyword">if</span> (in_array(substr($word, <span class="number">0</span>, strlen($word) - <span class="number">1</span>), $hashset)) &#123;</span><br><span class="line">                $longest = $word;</span><br><span class="line">                $hashset[] = $word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2043-简易银行系统"><a href="#2043-简易银行系统" class="headerlink" title="2043. 简易银行系统"></a>2043. 简易银行系统</h3><p><a href="https://leetcode-cn.com/problems/simple-bank-system/" target="_blank" rel="noopener">LeetCode - 2043. 简易银行系统</a></p><ul><li><code>2022/03/18</code></li></ul><blockquote><p>解题思路: 数组模拟</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[] $balance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($balance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;balance = $balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $account1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $account2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">transfer</span><span class="params">($account1, $account2, $money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// account1 取钱</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;withdraw($account1, $money)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// account1 提现失败</span></span><br><span class="line">        <span class="comment">// account2 存钱</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;deposit($account2, $money)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;deposit($account1, $money); <span class="comment">// 把钱退回account1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">deposit</span><span class="params">($account, $money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;balance[$account - <span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 账户判断</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;balance[$account - <span class="number">1</span>] += $money;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $money</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span><span class="params">($account, $money)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;balance[$account - <span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 账户判断</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;balance[$account - <span class="number">1</span>] &lt; $money) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 余额判断</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;balance[$account - <span class="number">1</span>] -= $money;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Bank object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * $obj = Bank($balance);</span></span><br><span class="line"><span class="comment"> * $ret_1 = $obj-&gt;transfer($account1, $account2, $money);</span></span><br><span class="line"><span class="comment"> * $ret_2 = $obj-&gt;deposit($account, $money);</span></span><br><span class="line"><span class="comment"> * $ret_3 = $obj-&gt;withdraw($account, $money);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="606-根据二叉树创建字符串"><a href="#606-根据二叉树创建字符串" class="headerlink" title="606. 根据二叉树创建字符串"></a>606. 根据二叉树创建字符串</h3><p><a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">LeetCode - 606. 根据二叉树创建字符串</a></p><ul><li><code>2022/03/19</code></li></ul><blockquote><p>解题思路: 递归</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tree2str</span><span class="params">(TreeNode $root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>; <span class="comment">// 二叉树为空</span></span><br><span class="line">        <span class="keyword">if</span> ($root-&gt;left == <span class="string">''</span> &amp;&amp; $root-&gt;right == <span class="string">''</span>) &#123; <span class="comment">// 当前节点左右子树都为空</span></span><br><span class="line">            <span class="keyword">return</span> (string)$root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($root-&gt;right == <span class="keyword">null</span>) &#123; <span class="comment">// 当前右子树为空</span></span><br><span class="line">            <span class="comment">// 只需要考虑左子树</span></span><br><span class="line">            <span class="keyword">return</span> (string)$root-&gt;val . <span class="string">'('</span> . <span class="keyword">$this</span>-&gt;tree2str($root-&gt;left) . <span class="string">')'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (string)$root-&gt;val . <span class="string">"("</span> . <span class="keyword">$this</span>-&gt;tree2str($root-&gt;left) . <span class="string">')('</span> . <span class="keyword">$this</span>-&gt;tree2str($root-&gt;right) . <span class="string">')'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val = <span class="number">0</span>, $left = null, $right = null)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;left = $left;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;right = $right;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路: 迭代</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">tree2str</span><span class="params">($root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ans = <span class="string">''</span>;</span><br><span class="line">        $stack = <span class="keyword">new</span> SplStack();</span><br><span class="line">        $stack-&gt;push($root);</span><br><span class="line">        $vis = [];</span><br><span class="line">        <span class="keyword">while</span> (!$stack-&gt;isEmpty()) &#123;</span><br><span class="line">            $node = $stack-&gt;top();</span><br><span class="line">            <span class="comment">// 严格比较</span></span><br><span class="line">            <span class="keyword">if</span> (in_array($node, $vis, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ($node !== $root) &#123;</span><br><span class="line">                    $ans .= <span class="string">')'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                $stack-&gt;pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $vis[] = $node;</span><br><span class="line">                <span class="keyword">if</span> ($node !== $root) &#123;</span><br><span class="line">                    $ans .= <span class="string">'('</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                $ans .= $node-&gt;val;</span><br><span class="line">                <span class="comment">// 右子树不为空,左子树为空</span></span><br><span class="line">                <span class="keyword">if</span> ($node-&gt;left === <span class="keyword">null</span> &amp;&amp; $node-&gt;right !== <span class="keyword">null</span>) &#123;</span><br><span class="line">                    $ans .= <span class="string">'()'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ($node-&gt;right !== <span class="keyword">null</span>) &#123;</span><br><span class="line">                    $stack-&gt;push($node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ($node-&gt;left !== <span class="keyword">null</span>) &#123;</span><br><span class="line">                    $stack-&gt;push($node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (string)$ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val = <span class="number">0</span>, $left = null, $right = null)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;left = $left;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;right = $right;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2039-网络空闲的时刻"><a href="#2039-网络空闲的时刻" class="headerlink" title="2039. 网络空闲的时刻"></a>2039. 网络空闲的时刻</h3><p><a href="https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/" target="_blank" rel="noopener">LeetCode - 2039. 网络空闲的时刻</a></p><ul><li><code>2022/03/20</code></li></ul><blockquote><p>解题思路: 广度优先搜索<br>我们可以将整个计算机网络视为一个无向图，服务器为图中的节点。根据图中的边对应的关系 edges 即可求出图中任意节点之间的最短距离。利用广度优先搜索求出节点 00 到其他节点的最短距离</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[][] $edges</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[] $patience</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">networkBecomesIdle</span><span class="params">($edges, $patience)</span> </span>&#123;</span><br><span class="line">        $n = count($patience); <span class="comment">// 3</span></span><br><span class="line">        $g = array_fill(<span class="number">0</span>, $n, []); <span class="comment">// [0 =&gt; [], 1 =&gt; [], 2 =&gt; []] </span></span><br><span class="line">        <span class="keyword">foreach</span> ($edges <span class="keyword">as</span> $e) &#123;</span><br><span class="line">            $x = $e[<span class="number">0</span>];</span><br><span class="line">            $y = $e[<span class="number">1</span>];</span><br><span class="line">            $g[$x][] = $y;</span><br><span class="line">            $g[$y][] = $x;</span><br><span class="line">        &#125;</span><br><span class="line">        $vis = array_fill(<span class="number">0</span>, $n, <span class="keyword">false</span>); <span class="comment">// [0 =&gt; false, 1 =&gt; false, 2 =&gt; false]</span></span><br><span class="line">        $vis[<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// [0 =&gt; true, 1 =&gt; false, 2 =&gt; false]</span></span><br><span class="line">        $q = [<span class="number">0</span> =&gt; <span class="number">0</span>];</span><br><span class="line">        <span class="comment">// // 广度优先搜索求解最短的距离，然后计算最后一个能发出去的信息的时间+最短距离*2+1的传递时间</span></span><br><span class="line">        <span class="keyword">for</span> ($dist = <span class="number">1</span>; $q !== []; $dist++) &#123;</span><br><span class="line">            $tmp = $q;</span><br><span class="line">            $q = [];</span><br><span class="line">            <span class="keyword">foreach</span> ($tmp <span class="keyword">as</span> $x) &#123;</span><br><span class="line">                <span class="keyword">foreach</span> ($g[$x] <span class="keyword">as</span> $v) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ($vis[$v]) <span class="keyword">continue</span>;</span><br><span class="line">                    $vis[$v] = <span class="keyword">true</span>;</span><br><span class="line">                    $q[] = $v;</span><br><span class="line">                    <span class="comment">// floor 解决PHP隐式转换问题</span></span><br><span class="line">                    $ans = max($ans, floor(($dist*<span class="number">2</span> - <span class="number">1</span>) / $patience[$v]) * $patience[$v] + $dist*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a>653. 两数之和 IV - 输入 BST</h3><p><a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">LeetCode - 653. 两数之和 IV - 输入 BST</a></p><ul><li><code>2022/03/21</code></li></ul><blockquote><p>解题思路: 深度优先搜索 + 哈希表</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public $val = null;</span></span><br><span class="line"><span class="comment"> *     public $left = null;</span></span><br><span class="line"><span class="comment"> *     public $right = null;</span></span><br><span class="line"><span class="comment"> *     function __construct($val = 0, $left = null, $right = null) &#123;</span></span><br><span class="line"><span class="comment"> *         $this-&gt;val = $val;</span></span><br><span class="line"><span class="comment"> *         $this-&gt;left = $left;</span></span><br><span class="line"><span class="comment"> *         $this-&gt;right = $right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findTarget</span><span class="params">($root, $k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $array[] = <span class="string">""</span>; <span class="comment">// 哈希集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;dfs($root, $k, $array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">($root, $k, &amp;$array)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($root-&gt;val === <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (in_array(($k - $root-&gt;val), $array)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $array[] = $root-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;dfs($root-&gt;left, $k, $array) || <span class="keyword">$this</span>-&gt;dfs($root-&gt;right, $k, $array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路: 广度优先搜索 + 哈希表</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     public $val = null;</span></span><br><span class="line"><span class="comment"> *     public $left = null;</span></span><br><span class="line"><span class="comment"> *     public $right = null;</span></span><br><span class="line"><span class="comment"> *     function __construct($val = 0, $left = null, $right = null) &#123;</span></span><br><span class="line"><span class="comment"> *         $this-&gt;val = $val;</span></span><br><span class="line"><span class="comment"> *         $this-&gt;left = $left;</span></span><br><span class="line"><span class="comment"> *         $this-&gt;right = $right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findTarget</span><span class="params">($root, $k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $set[] = <span class="string">''</span>; <span class="comment">// 哈希表</span></span><br><span class="line">        $queue = <span class="keyword">new</span> SplQueue();</span><br><span class="line">        $queue-&gt;push($root);</span><br><span class="line">        <span class="keyword">while</span> (!$queue-&gt;isEmpty()) &#123;</span><br><span class="line">            $node = $queue-&gt;shift();</span><br><span class="line">            <span class="keyword">if</span> (in_array(($k - $node-&gt;val), $set)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            array_push($set, $node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> ($node-&gt;left) &#123;</span><br><span class="line">                $queue-&gt;push($node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ($node-&gt;right) &#123;</span><br><span class="line">                $queue-&gt;push($node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2038-如果相邻两个颜色均相同则删除当前颜色"><a href="#2038-如果相邻两个颜色均相同则删除当前颜色" class="headerlink" title="2038. 如果相邻两个颜色均相同则删除当前颜色"></a>2038. 如果相邻两个颜色均相同则删除当前颜色</h3><p><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/" target="_blank" rel="noopener">LeetCode - 2038. 如果相邻两个颜色均相同则删除当前颜色</a></p><ul><li><code>2022/03/22</code></li></ul><blockquote><p>解题思路: 贪心算法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $colors</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">winnerOfGame</span><span class="params">($colors)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $freq = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">        $cur = <span class="string">'C'</span>;</span><br><span class="line">        $cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当 Alice 的操作数大于 Bob 的操作数时，Alice 获胜；否则，Bob 获胜。</span></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; strlen($colors); $i++) &#123;</span><br><span class="line">            $c = $colors[$i];</span><br><span class="line">            <span class="keyword">if</span> ($c !== $cur) &#123;</span><br><span class="line">                $cur = $c;</span><br><span class="line">                $cnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $cnt += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ($cnt &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// ord('A') - ord('A') = 0</span></span><br><span class="line">                    <span class="comment">// ord('B') - ord('A') = 1</span></span><br><span class="line">                    $freq[ord($cur) - ord(<span class="string">'A'</span>)] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $freq[<span class="number">0</span>] &gt; $freq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="440-字典序的第K小数字"><a href="#440-字典序的第K小数字" class="headerlink" title="440. 字典序的第K小数字"></a>440. 字典序的第K小数字</h3><p><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/" target="_blank" rel="noopener">LeetCode - 440. 字典序的第K小数字</a></p><ul><li>什么是字典序？<blockquote><p>简而言之，就是根据数字的前缀进行排序</p></blockquote></li></ul><blockquote><p>解题思路: 字典树思想</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findKthNumber</span><span class="params">($n, $k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $cur = <span class="number">1</span>;</span><br><span class="line">        $k--;</span><br><span class="line">        <span class="keyword">while</span> ($k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            $steps = <span class="keyword">$this</span>-&gt;getSteps($cur, $n);</span><br><span class="line">            <span class="keyword">if</span> ($steps &lt;= $k) &#123;</span><br><span class="line">                $k -= $steps;</span><br><span class="line">                $cur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $cur *= <span class="number">10</span>;</span><br><span class="line">                $k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getSteps</span><span class="params">($cur, $n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $first = $last = $cur;</span><br><span class="line">        <span class="keyword">while</span> ($first &lt;= $n) &#123;</span><br><span class="line">            $steps += min($last, $n) - $first + <span class="number">1</span>;</span><br><span class="line">            $first *= <span class="number">10</span>;</span><br><span class="line">            $last = $last * <span class="number">10</span> + <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="661-图片平滑器"><a href="#661-图片平滑器" class="headerlink" title="661. 图片平滑器"></a>661. 图片平滑器</h3><p><a href="https://leetcode-cn.com/problems/image-smoother/" target="_blank" rel="noopener">LeetCode - 661. 图片平滑器</a></p><blockquote><p>解题思路: 遍历</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[][] $img</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer[][]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">imageSmoother</span><span class="params">($img)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $h = count($img); <span class="comment">// 长度</span></span><br><span class="line">        $w = count($img[<span class="number">0</span>]); <span class="comment">// 宽度</span></span><br><span class="line"></span><br><span class="line">        $ret = [];</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $h; $i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; $w; $j++) &#123;</span><br><span class="line">                $count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">foreach</span>([$i - <span class="number">1</span>, $i, $i + <span class="number">1</span>] <span class="keyword">as</span> $iv) &#123;</span><br><span class="line">                    <span class="keyword">foreach</span>([$j - <span class="number">1</span>, $j, $j + <span class="number">1</span>] <span class="keyword">as</span> $jv) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ($iv &gt;= <span class="number">0</span> &amp;&amp; $iv &lt; $h &amp;&amp; $jv &gt;= <span class="number">0</span> &amp;&amp; $jv &lt; $w) &#123;</span><br><span class="line">                            <span class="comment">// 下标在数组范围内</span></span><br><span class="line">                            $ret[$i][$j] += $img[$iv][$jv];</span><br><span class="line">                            $count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                $ret[$i][$j] = floor($ret[$i][$j]/$count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h3><p><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">LeetCode - 172. 阶乘后的零</a></p><blockquote><p>解题思路: 质因数</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trailingZeroes</span><span class="params">($n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// n! 尾零的数量即为 n! 中因子 10 的个数，而 10=2×5，因此转换成求 n! 中质因子 2 的个数和质因子 5 的个数的较小值。</span></span><br><span class="line">        <span class="keyword">while</span> ($n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            $n = (int)($n/<span class="number">5</span>);</span><br><span class="line">            $num += $n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682. 棒球比赛"></a>682. 棒球比赛</h3><p><a href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" rel="noopener">LeetCode - 682. 棒球比赛</a></p><blockquote><p>解题思路: 链表长度</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     public $val = 0;</span></span><br><span class="line"><span class="comment"> *     public $next = null;</span></span><br><span class="line"><span class="comment"> *     function __construct($val = 0, $next = null) &#123;</span></span><br><span class="line"><span class="comment"> *         $this-&gt;val = $val;</span></span><br><span class="line"><span class="comment"> *         $this-&gt;next = $next;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeNthFromEnd</span><span class="params">($head, $n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, $head);</span><br><span class="line">        $length = <span class="keyword">$this</span>-&gt;getLength($head); <span class="comment">// 链表长度</span></span><br><span class="line">        $cur = $dummyHead;</span><br><span class="line">        <span class="comment">// 第 L−n+1 个节点时，它就是我们需要删除的节点</span></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $length - $n + <span class="number">1</span>; $i++) &#123;</span><br><span class="line">            $cur = $cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        $cur-&gt;next = $cur-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getLength</span><span class="params">($head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ($head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            $head = $head-&gt;next;</span><br><span class="line">            $length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路: 栈</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNthFromEnd</span><span class="params">($head, $n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, $head);</span><br><span class="line">    $cur = $dummyHead;</span><br><span class="line">    $stack = <span class="keyword">new</span> SplStack();</span><br><span class="line">    <span class="keyword">while</span> ($cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        $stack-&gt;push($cur);</span><br><span class="line">        $cur = $cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">        $stack-&gt;pop();</span><br><span class="line">    &#125;</span><br><span class="line">    $pre = $stack-&gt;top();</span><br><span class="line">    $pre-&gt;next = $pre-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路: 双指针 </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNthFromEnd</span><span class="params">($head, $n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, $head);</span><br><span class="line">    $first  = $head;</span><br><span class="line">    $second = $dummyHead;</span><br><span class="line">    <span class="comment">// first指针, 先走n个节点</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">        $first = $first-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// first遍历结束, second正好在倒数第n个节点</span></span><br><span class="line">    <span class="keyword">while</span> ($first != <span class="keyword">null</span>) &#123;</span><br><span class="line">        $first  = $first-&gt;next;</span><br><span class="line">        $second = $second-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    $second-&gt;next = $second-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2028-找出缺失的观测数据"><a href="#2028-找出缺失的观测数据" class="headerlink" title="2028. 找出缺失的观测数据"></a>2028. 找出缺失的观测数据</h3><p><a href="https://leetcode-cn.com/problems/find-missing-observations/" target="_blank" rel="noopener">LeetCode - 2028. 找出缺失的观测数据</a></p><blockquote><p>解题思路: 模拟构造</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[] $rolls</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $mean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">missingRolls</span><span class="params">($rolls, $mean, $n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $missSum = ($mean * ($n + count($rolls))) - array_sum($rolls); <span class="comment">// 缺失数据总和</span></span><br><span class="line">        <span class="keyword">if</span> ($missSum &lt; $n || $missSum &gt; $n*<span class="number">6</span>) <span class="keyword">return</span> []; <span class="comment">// 每次观测数据的范围是 1 到 6</span></span><br><span class="line">        $avg  = (int)($missSum / $n);</span><br><span class="line">        $less = $missSum % $n;</span><br><span class="line">        $ans  = array_fill(<span class="number">0</span>, $n, $avg);</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">            $ans[$i] = $avg + ($i &lt; $less ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="693-交替位二进制数"><a href="#693-交替位二进制数" class="headerlink" title="693. 交替位二进制数"></a>693. 交替位二进制数</h3><p><a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/" target="_blank" rel="noopener">LeetCode - 693. 交替位二进制数</a></p><blockquote><p>解题思路: 位运算</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hasAlternatingBits</span><span class="params">($n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $tmp = $n ^ ($n &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ($tmp &amp; ($tmp + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2024-考试的最大困扰度"><a href="#2024-考试的最大困扰度" class="headerlink" title="2024. 考试的最大困扰度"></a>2024. 考试的最大困扰度</h3><p><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/" target="_blank" rel="noopener">LeetCode - 2024. 考试的最大困扰度</a></p><blockquote><p>解题思路: 滑动窗口</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $answerKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">maxConsecutiveAnswers</span><span class="params">($answerKey, $k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max(<span class="keyword">$this</span>-&gt;maxConsecutiveChar($answerKey, $k, <span class="string">'T'</span>), <span class="keyword">$this</span>-&gt;maxConsecutiveChar($answerKey, $k, <span class="string">'F'</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">maxConsecutiveChar</span><span class="params">($answerKey, $k, $byte)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $ans = $left = $sum = <span class="number">0</span>;</span><br><span class="line">        $n = strlen($answerKey);</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($answerKey[$i] != $byte) $sum++;</span><br><span class="line">            <span class="keyword">while</span> ($sum &gt; $k) &#123;</span><br><span class="line">                <span class="keyword">if</span> ($answerKey[$left] != $byte) $sum--;</span><br><span class="line">                $left++;</span><br><span class="line">            &#125;</span><br><span class="line">            $ans = max($ans, $i - $left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1606-找到处理最多请求的服务器"><a href="#1606-找到处理最多请求的服务器" class="headerlink" title="1606. 找到处理最多请求的服务器"></a>1606. 找到处理最多请求的服务器</h3><p><a href="https://leetcode-cn.com/problems/find-servers-that-handled-most-number-of-requests/" target="_blank" rel="noopener">LeetCode - 1606. 找到处理最多请求的服务器</a></p><blockquote><p>解题思路: </p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="728-自除数"><a href="#728-自除数" class="headerlink" title="728. 自除数"></a>728. 自除数</h3><p><a href="https://leetcode-cn.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">LeetCode - 728. 自除数</a></p><blockquote><p>解题思路: 模拟</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">selfDividingNumbers</span><span class="params">($left, $right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $array = [];</span><br><span class="line">        <span class="keyword">for</span> ($num = $left; $left &lt;= $right; $num = ++$left) &#123;</span><br><span class="line">            <span class="keyword">while</span> ($num) &#123;</span><br><span class="line">                $mod = $num % <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">if</span> ($mod == <span class="number">0</span> || $left % $mod != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                $num = (int)($num / <span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            $array[] = $left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;知耻而后勇, 日积月累, 每月一篇博客&lt;br&gt;以下内容, 记录自己刷题过程&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://blog.caoxl.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="算法" scheme="http://blog.caoxl.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动算法面试题 I</title>
    <link href="http://blog.caoxl.com/2022/03/10/Byte-Dance-Algorithm-I/"/>
    <id>http://blog.caoxl.com/2022/03/10/Byte-Dance-Algorithm-I/</id>
    <published>2022-03-10T09:35:02.000Z</published>
    <updated>2022-03-14T02:38:13.192Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>世上无难事只怕有心人</p></blockquote><a id="more"></a><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h3><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LeetCode - 3.无重复字符的最长子串</a></p><blockquote><p>解题思路: 滑动窗口</p></blockquote><p>我们可以定义字符到索引的映射 当我们找到重复的字符时，我们可以立即跳过该窗口。<br>也就是说, 如果 str[i] 在[i,j]范围内有与<code>i</code>重复的字符, 我们不需要逐渐增加<code>j</code>;我们可以直接跳过[i, j]范围内的所有元素, 并将<code>j</code>变成<code>i+1</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longestSubstring</span><span class="params">($str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $len = strlen($str);</span><br><span class="line">    $i = <span class="number">0</span>;</span><br><span class="line">    $j = <span class="number">0</span>;</span><br><span class="line">    $maxStrLen = <span class="number">0</span>;</span><br><span class="line">    $set = [];</span><br><span class="line">    <span class="keyword">while</span> ($i &lt; $len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array_key_exists($str[$i], $set)) &#123;</span><br><span class="line">            $j = max($j, $set[$str[$i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        $maxStrLen = max($maxStrLen, $i - $j + <span class="number">1</span>);</span><br><span class="line">        $set[$str[$i]] = $i + <span class="number">1</span>;</span><br><span class="line">        $i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $maxStrLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25.K个一组翻转链表"></a>25.K个一组翻转链表</h3><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LeetCode - 25.K个一组翻转链表</a></p><blockquote><p>解题思路: 辅助栈</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseKGroup</span><span class="params">($head, $k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($head === <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    $stack = <span class="keyword">new</span> SplStack();</span><br><span class="line">    $dumpy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    $pre   = $dumpy;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        $count = <span class="number">0</span>;</span><br><span class="line">        $tmp = $head;</span><br><span class="line">        <span class="keyword">while</span> ($tmp !== <span class="keyword">null</span> &amp;&amp; $count &lt; $k) &#123;</span><br><span class="line">            $stack-&gt;push($tmp);</span><br><span class="line">            $tmp = $tmp-&gt;next;</span><br><span class="line">            $count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($count != $k) &#123;</span><br><span class="line">            $pre-&gt;next = $head;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!$stack-&gt;isEmpty()) &#123;</span><br><span class="line">            $pre-&gt;next = $stack-&gt;pop();</span><br><span class="line">            $pre = $pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $pre-&gt;next = $tmp;</span><br><span class="line">        $head = $tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $dumpy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><p><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCode - 15.三数之和</a></p><ul><li>解题思路: 排序 + 双指针</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">threeSum</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $res = [];</span><br><span class="line">    sort($nums);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; count($nums); $i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($nums[$i] &gt; <span class="number">0</span>) <span class="keyword">return</span> $res;</span><br><span class="line">        <span class="keyword">if</span> ($i &gt; <span class="number">0</span> &amp;&amp; $nums[$i] == $nums[$i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        $left = $i + <span class="number">1</span>;</span><br><span class="line">        $right = count($nums) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ($left &lt; $right) &#123;</span><br><span class="line">            $sum = $nums[$i] + $nums[$left] + $nums[$right];</span><br><span class="line">            <span class="keyword">if</span> ($sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                $left++;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> ($sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                $right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $res[] = [$nums[$i], $nums[$left], $nums[$right]];</span><br><span class="line">                <span class="keyword">while</span> ($left &lt; $right &amp;&amp; $nums[$left] == $nums[$left + <span class="number">1</span>]) $left++;</span><br><span class="line">                <span class="keyword">while</span> ($left &lt; $right &amp;&amp; $nums[$right] == $nums[$right - <span class="number">1</span>]) $right--;</span><br><span class="line">                $left++;</span><br><span class="line">                $right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="43-接雨水"><a href="#43-接雨水" class="headerlink" title="43.接雨水"></a>43.接雨水</h3><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LeetCode - 43.接雨水</a></p><blockquote><p>解题思路: 双指针</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $height</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trap</span><span class="params">($height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $heightLen = sizeof($height);</span><br><span class="line"></span><br><span class="line">    $iLeftMax  = $height[<span class="number">0</span>];</span><br><span class="line">    $jRightMax = $height[$heightLen<span class="number">-1</span>];</span><br><span class="line">    $res = <span class="number">0</span>;</span><br><span class="line">    $left = <span class="number">0</span>; <span class="comment">// 左指针</span></span><br><span class="line">    $right = $heightLen - <span class="number">1</span>; <span class="comment">// 右指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ($left &lt;= $right) &#123;</span><br><span class="line">        $iLeftMax  = max($height[$left], $iLeftMax);</span><br><span class="line">        $jRightMax = max($height[$right], $jRightMax);</span><br><span class="line">        <span class="keyword">if</span> ($iLeftMax &lt; $jRightMax) &#123;</span><br><span class="line">            $res += $iLeftMax - $height[$left];</span><br><span class="line">            $left++; <span class="comment">// 移动左指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $res += $jRightMax-$height[$right];</span><br><span class="line">            $right--; <span class="comment">// 移动右指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>$res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设两柱子分别为 i，j。那么就有 <code>iLeftMax</code>, <code>iRightMax</code>, <code>jLeftMx</code>,<code>jRightMax</code> 这个变量。由于 j&gt;i ，故 <code>jLeftMax&gt;=iLeftMax</code>，<code>iRightMax&gt;=jRightMax</code>.</p><p>那么，如果 <code>iLeftMax&gt;jRightMax</code>，则必有 <code>jLeftMax &gt;= jRightMax</code>，所有我们能接 j 点的水。</p><p>如果 <code>jRightMax&gt;iLeftMax</code>，则必有 <code>iRightMax &gt;= iLeftMax</code>，所以我们能接 i 点的水。</p><p>而上面我们实际上只用到了 <strong>iLeftMax</strong>，<strong>jRightMax</strong> 两个变量，故我们维护这两个即可</p><h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415.字符串相加"></a>415.字符串相加</h3><p><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">LeetCode - 415.字符串相加</a></p><blockquote><p>解题思路: 从后向前，对应的位置的数字相加，如果结果大于 9，需要进位</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String $num1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String $num2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addStrings</span><span class="params">($num1, $num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $len1 = strlen($num1);</span><br><span class="line">    $len2 = strlen($num2);</span><br><span class="line">    <span class="keyword">if</span> ($len1 == <span class="number">0</span>) <span class="keyword">return</span> $num2;</span><br><span class="line">    <span class="keyword">if</span> ($len2 == <span class="number">0</span>) <span class="keyword">return</span> $num1;</span><br><span class="line">    <span class="comment">// 从最低位开始处理</span></span><br><span class="line">    $i = $len1 - <span class="number">1</span>;</span><br><span class="line">    $j = $len2 - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 进位标记</span></span><br><span class="line">    $carry = <span class="number">0</span>;</span><br><span class="line">    $return = <span class="string">''</span>;</span><br><span class="line">    <span class="comment">// 使用该判断条件，一次遍历处理完所有情况</span></span><br><span class="line">    <span class="keyword">while</span> ($i &gt;= <span class="number">0</span> || $j &gt;= <span class="number">0</span> || $carry) &#123;</span><br><span class="line">        $sum = $carry;</span><br><span class="line">        <span class="keyword">if</span> ($i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            $sum += substr($num1, $i, <span class="number">1</span>);</span><br><span class="line">            $i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            $sum += substr($num2, $j, <span class="number">1</span>);</span><br><span class="line">            $j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进位处理</span></span><br><span class="line">        $carry = floor($sum / <span class="number">10</span>);</span><br><span class="line">        $return = $sum % <span class="number">10</span> . $return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103.二叉树的锯齿形层次遍历"></a>103.二叉树的锯齿形层次遍历</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">LeetCode - 103.二叉树的锯齿形层次遍历</a></p><blockquote><p>解题思路: 利用「双端队列」的数据结构来维护当前层节点值输出的顺序。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer[][]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">zigzagLevelOrder</span><span class="params">($root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $query = [[$root, <span class="number">1</span>]];</span><br><span class="line">    $result = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($root)) &#123;</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">empty</span>($query)) &#123;</span><br><span class="line">        [$node, $level] = array_shift($query);</span><br><span class="line">        <span class="keyword">if</span> ($node-&gt;left) &#123;</span><br><span class="line">            $query[] = [$node-&gt;left, $level + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($node-&gt;right) &#123;</span><br><span class="line">            $query[] = [$node-&gt;right, $level + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        $result[$level][] = $node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> ($result <span class="keyword">as</span> $index =&gt; $value) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($index % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            $result[$index] = array_reverse($value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">LeetCode - 121.买卖股票的最佳时机</a></p><blockquote><p>解题思路: 动态规划</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $prices   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span><span class="params">($prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $dp = []; <span class="comment">// 状态转移数组</span></span><br><span class="line">    $dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 不持有股票的利润</span></span><br><span class="line">    $dp[<span class="number">0</span>][<span class="number">1</span>] = -$prices[<span class="number">0</span>]; <span class="comment">// 持有股票的利润</span></span><br><span class="line">    $pricesLen = sizeof($prices);</span><br><span class="line">    <span class="keyword">if</span> ($pricesLen ==<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $pricesLen; $i++) &#123;</span><br><span class="line">        $dp[$i][<span class="number">0</span>] = max($dp[$i<span class="number">-1</span>][<span class="number">0</span>],$dp[$i<span class="number">-1</span>][<span class="number">1</span>] + $prices[$i]); <span class="comment">// 状态转移</span></span><br><span class="line">        $dp[$i][<span class="number">1</span>] = max($dp[$i<span class="number">-1</span>][<span class="number">1</span>], -$prices[$i]); <span class="comment">// 状态转移</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $dp[$pricesLen<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode - 206.反转链表</a></p><blockquote><p>解题思路: 递归</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span><span class="params">($head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($head-&gt;next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $head;</span><br><span class="line">    &#125;</span><br><span class="line">    $last = <span class="keyword">$this</span>-&gt;reverseList($head-&gt;next);</span><br><span class="line">    $head-&gt;next-&gt;next = $head;</span><br><span class="line">    $head-&gt;next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路: 迭代</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span><span class="params">($head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="comment">// 我们可以申请两个指针，第一个指针叫 prev，最初是指向 null 的。</span></span><br><span class="line">    <span class="comment">// 第二个指针 cur 指向 head，然后不断遍历 cur。</span></span><br><span class="line">    <span class="comment">// 每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。</span></span><br><span class="line">    <span class="comment">// 都迭代完了 (cur 变成 null 了)，pre 就是最后一个节点了。</span></span><br><span class="line">    $prev = <span class="keyword">null</span>;</span><br><span class="line">    $cur = $head;</span><br><span class="line">    <span class="keyword">while</span> ($cur) &#123;</span><br><span class="line">        $next = $cur-&gt;next;</span><br><span class="line">        $cur-&gt;next = $prev;</span><br><span class="line">        $prev = $cur;</span><br><span class="line">        $cur = $next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode - 1.两数之和</a></p><blockquote><p>解题思路: 暴力枚举</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array $nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> integer $target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> array|int[]|string[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">twoSum</span><span class="params">($nums, $target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $length = count($nums);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $length; $i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> ($j = $i + <span class="number">1</span>; $j &lt; $length; $j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($nums[$i] + $nums[$j] == $target) &#123;</span><br><span class="line">                <span class="keyword">return</span> [$i, $j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h3><p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">LeetCode - 199.二叉树的右视图</a></p><blockquote><p>解题思路: 层序队列+遍历</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rightSideView</span><span class="params">($root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($root === <span class="keyword">null</span>) <span class="keyword">return</span> [];</span><br><span class="line"></span><br><span class="line">    $queue = <span class="keyword">new</span> SplQueue(); <span class="comment">// 队列</span></span><br><span class="line">    $queue-&gt;enqueue([$root, <span class="number">0</span>]); <span class="comment">// 节点和层序号一起入队</span></span><br><span class="line">    $ret = []; <span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">while</span> (!$queue-&gt;isEmpty()) &#123;</span><br><span class="line">        $item = $queue-&gt;dequeue();</span><br><span class="line">        $ret[$item[<span class="number">1</span>]] = $item[<span class="number">0</span>]-&gt;val; <span class="comment">// 一直覆盖保存,最后就是最后边的值</span></span><br><span class="line">        <span class="keyword">if</span> ($item[<span class="number">0</span>]-&gt;left)</span><br><span class="line">            $queue-&gt;enqueue([$item[<span class="number">0</span>]-&gt;left, $item[<span class="number">1</span>]+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> ($item[<span class="number">0</span>]-&gt;right)</span><br><span class="line">            $queue-&gt;enqueue([$item[<span class="number">0</span>]-&gt;right, $item[<span class="number">1</span>]+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h3><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">LeetCode - 160.相交链表</a></p><blockquote><p>解题思路: 双指针</p></blockquote><p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $headA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $headB</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersectionNode</span><span class="params">($headA, $headB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 为空判断</span></span><br><span class="line">    <span class="keyword">if</span> ($headA === <span class="keyword">null</span> || $headB === <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $ha = $headA;</span><br><span class="line">    $hb = $headB;</span><br><span class="line">    <span class="comment">// 采用全等比较，比较地址</span></span><br><span class="line">    <span class="keyword">while</span> ($ha !== $hb) &#123;</span><br><span class="line">        $ha = ($ha === <span class="keyword">null</span>) ? $headB : $ha-&gt;next;</span><br><span class="line">        $hb = ($hb === <span class="keyword">null</span>) ? $headA : $hb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相交节点</span></span><br><span class="line">    <span class="keyword">return</span> $ha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215.数组中的第k个最大元素"></a>215.数组中的第k个最大元素</h3><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">LeetCode - 215.数组中的第k个最大元素</a></p><blockquote><p>解题思路: 暴力排序</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKthLargest</span><span class="params">($nums, $k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rsort($nums);</span><br><span class="line">    <span class="keyword">return</span> $nums[$k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路: 堆排序</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findKthLargest</span><span class="params">($nums, $k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $n = count($nums);</span><br><span class="line">    $heap = <span class="keyword">new</span> SplMinHeap();</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; ++$i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($heap-&gt;count() &lt; $k) &#123;</span><br><span class="line">            $heap-&gt;insert($nums[$i]);</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($heap-&gt;top() &lt; $nums[$i]) &#123;</span><br><span class="line">            $heap-&gt;extract();</span><br><span class="line">            $heap-&gt;insert($nums[$i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $heap-&gt;top();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">LeetCode - 232.用栈实现队列</a></p><blockquote><p>解题思路: 双栈模拟队列</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $queue1 = <span class="keyword">null</span>; <span class="comment">// 存放数据的栈</span></span><br><span class="line">    <span class="keyword">private</span> $queue2 = <span class="keyword">null</span>; <span class="comment">// 辅助栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;queue1 = <span class="keyword">new</span> SplStack();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;queue2 = <span class="keyword">new</span> SplStack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;queue1-&gt;push($x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// pop时借助辅助栈完成</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            $val = <span class="keyword">$this</span>-&gt;queue1-&gt;pop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;queue1-&gt;isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;queue2-&gt;push($val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;queue2-&gt;isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;queue1-&gt;push(<span class="keyword">$this</span>-&gt;queue2-&gt;pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;queue1-&gt;bottom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;queue1-&gt;isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146.LRU缓存机制"></a>146.LRU缓存机制</h3><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LeetCode - 146.LRU缓存机制</a></p><blockquote><p>解题思路: 哈希表 + 双向链表</p></blockquote><ul><li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li><li>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</li></ul><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">LeetCode - 53. 最大子数组和</a></p><blockquote><p>解题思路: 动态规划</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxSubArray</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $maxNum = $nums[<span class="number">0</span>];</span><br><span class="line">    $tmp = $nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($nums <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($k === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($tmp &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">            $tmp = $tmp + $v;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $tmp = $v;</span><br><span class="line">        &#125;</span><br><span class="line">        $maxNum = $maxNum &gt; $tmp ? $maxNum : $tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155.最小栈"></a>155.最小栈</h3><p><a href="https://leetcode-cn.com/problems/min-stack/solution/phpshuang-zhan-jie-fa-by-mek1986-syuo/" target="_blank" rel="noopener">LeetCode - 155.最小栈</a></p><blockquote><p>解题思路: 辅助栈<br>要做出这道题目，首先要理解栈结构先进后出的性质。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $stack1 = <span class="keyword">null</span>; <span class="comment">// 保存所有数据</span></span><br><span class="line">    <span class="keyword">private</span> $stack2 = <span class="keyword">null</span>; <span class="comment">// 保存相对较小值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;stack1 = <span class="keyword">new</span> SplStack();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;stack2 = <span class="keyword">new</span> SplStack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">($x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;stack1-&gt;push($x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;stack2-&gt;isEmpty() || $x &lt;= <span class="keyword">$this</span>-&gt;stack2-&gt;top()) &#123;</span><br><span class="line">            <span class="comment">// 压入栈2</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;stack2-&gt;push($x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $val = <span class="keyword">$this</span>-&gt;stack1-&gt;pop();</span><br><span class="line">        <span class="keyword">if</span> ($val == <span class="keyword">$this</span>-&gt;stack2-&gt;top()) &#123;</span><br><span class="line">            <span class="comment">// 栈2数据弹出</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;stack2-&gt;pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;stack1-&gt;top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;stack2-&gt;top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><p><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">LeetCode - 20.有效的括号</a></p><blockquote><p>解题思路: 辅助栈</p></blockquote><p>我们遍历给定的字符串 ss。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $str_map = [</span><br><span class="line">        <span class="string">')'</span> =&gt; <span class="string">'('</span>,</span><br><span class="line">        <span class="string">'&#125;'</span> =&gt; <span class="string">'&#123;'</span>,</span><br><span class="line">        <span class="string">']'</span> =&gt; <span class="string">'['</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $stack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isValid</span><span class="params">($s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 当为空, 直接返回true</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($s)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 不是偶数,返回false</span></span><br><span class="line">        <span class="keyword">if</span> ((strlen($s) % <span class="number">2</span>) != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 定义一个栈</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;stack = <span class="keyword">new</span> SplStack();</span><br><span class="line">        <span class="comment">// 分割字符串为数组</span></span><br><span class="line">        $str_arr = str_split($s);</span><br><span class="line">        <span class="keyword">foreach</span> ($str_arr <span class="keyword">as</span> $str) &#123;</span><br><span class="line">            <span class="comment">// 当为左边括号时,入栈</span></span><br><span class="line">            <span class="keyword">if</span> (!array_key_exists($str, <span class="keyword">$this</span>-&gt;str_map)) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;stack-&gt;push($str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 当为右边括号时,如果栈不为空且等于栈顶元素,栈顶元素出栈,否则返回false</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;stack-&gt;isEmpty() &amp;&amp; <span class="keyword">$this</span>-&gt;str_map[$str] == <span class="keyword">$this</span>-&gt;stack-&gt;top()) &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;stack-&gt;pop();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断栈是否为空,为空返回true,否则返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;stack-&gt;isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">LeetCode - 141.环形链表</a></p><blockquote><p>解题思路: 快慢指针</p></blockquote><p>我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasCycle</span><span class="params">($head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    $slow = $head;</span><br><span class="line">    $fast = $head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> ($fast != <span class="keyword">null</span> &amp;&amp; $fast-&gt;next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        $slow = $slow-&gt;next;</span><br><span class="line">        $fast = $fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> ($fast === $slow) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">LeetCode - 105.从前序与中序遍历序列构造二叉树</a></p><blockquote><p>解题思路: 递归</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class Solution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">buildTree</span><span class="params">($preorder, $inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $len = sizeof($preorder);</span><br><span class="line">        $hashmap = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($inorder <span class="keyword">as</span> $k =&gt; $v) &#123;</span><br><span class="line">            <span class="comment">// 构建中序遍历索引查找表</span></span><br><span class="line">            $hashmap[$v] = $k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_buildTree($preorder, <span class="number">0</span>, $len<span class="number">-1</span>, $inorder, <span class="number">0</span>, $len<span class="number">-1</span>, $hashmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_buildTree</span><span class="params">($preorder, $preStart, $preEnd, $inorder, $inStart, $inEnd, $hashmap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> ($preStart-&gt;$preEnd || $inStart-&gt;$inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        $root = <span class="keyword">new</span> TreeNode($preorder[$preStart]);</span><br><span class="line">        $inRoot = $hashmap[$root-&gt;val];</span><br><span class="line">        $numsLeft = $inRoot-$inStart;</span><br><span class="line">        $root-&gt;left = <span class="keyword">$this</span>-&gt;_buildTree($preorder, $preStart + <span class="number">1</span>, $preStart + $numsLeft,$inorder,$inStart, $inRoot<span class="number">-1</span>, $hashmap);</span><br><span class="line">        $root-&gt;right = <span class="keyword">$this</span>-&gt;_buildTree($preorder, $preStart + $numsLeft + <span class="number">1</span>, $preEnd, $inorder,$inRoot+<span class="number">1</span>,$inEnd, $hashmap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $right = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val = <span class="number">0</span>, $left = null, $right = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;left = $left;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;right = $right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300.最长上升子序列"></a>300.最长上升子序列</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LeetCode - 300.最长递增子序列</a></p><blockquote><p>解题思路: 动态规划</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lengthOfLIS</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $numsLen = sizeof($nums);</span><br><span class="line">    <span class="keyword">if</span> ($numsLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    $dp = array_fill(<span class="number">0</span>, $numsLen, <span class="number">1</span>); <span class="comment">// 状态转移数组</span></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $numsLen; $i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; $i; $j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($nums[$i] &gt; $nums[$j]) &#123;</span><br><span class="line">                $dp[$i] = max($dp[$i], <span class="number">1</span> + $dp[$j]); <span class="comment">// 状态转移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max($dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h3><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode - 21.合并两个有序链表</a></p><blockquote><p>解题思路: 引用-迭代法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $list1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $list2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTwoLists</span><span class="params">($l1, $l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $dummyHead = <span class="keyword">new</span> ListNode(<span class="keyword">null</span>);</span><br><span class="line">    $cur = $dummyHead;</span><br><span class="line">    <span class="keyword">while</span> ($l1 !== <span class="keyword">null</span> &amp;&amp; $l2 !== <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($l1-&gt;val &lt;= $l2-&gt;val) &#123;</span><br><span class="line">            $cur-&gt;next = $l1;</span><br><span class="line">            $l1 = $l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $cur-&gt;next = $l2;</span><br><span class="line">            $l2 = $l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        $cur = $cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($l1 !== <span class="keyword">null</span>) &#123;</span><br><span class="line">        $cur-&gt;next = $l1;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ($l2 !== <span class="keyword">null</span>) &#123;</span><br><span class="line">        $cur-&gt;next = $l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h3><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode - 5.最长回文子串</a></p><blockquote><p>解题思路: 中心扩展算法</p></blockquote><p>我们枚举所有的「回文中心」并尝试「扩展」，直到无法扩展为止，此时的回文串长度即为此「回文中心」下的最长回文串长度。我们对所有的长度求出最大值，即可得到最终的答案。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class Solution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">longestPalindrome</span><span class="params">($s)</span> </span>&#123;</span><br><span class="line">        $str_len = strlen($s);</span><br><span class="line">        <span class="keyword">if</span> ($str_len &lt;= <span class="number">1</span>) <span class="keyword">return</span> $s;</span><br><span class="line"></span><br><span class="line">        $start  = <span class="number">0</span>; <span class="comment">//开始截取位</span></span><br><span class="line">        $offset = <span class="number">0</span>; <span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $str_len; $i ++) &#123;</span><br><span class="line">            $len1 = <span class="keyword">$this</span>-&gt;centerExpand($s, $str_len, $i, $i);</span><br><span class="line">            $len2 = <span class="keyword">$this</span>-&gt;centerExpand($s, $str_len, $i, $i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($len1 &gt; $len2 &amp;&amp; $len1 &gt; $offset) &#123;</span><br><span class="line">                <span class="comment">// 开始位置 = 当前坐标-回文长度的一半位置</span></span><br><span class="line">                $start = $i - ($len1 - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                $offset = $len1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ($len1 &lt;= $len2 &amp;&amp; $len2 &gt; $offset) &#123;</span><br><span class="line">                <span class="comment">// 开始位置 = 回文长度的一半位置</span></span><br><span class="line">                $start = $i - $len2/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                $offset = $len2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> substr($s, $start, $offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中心扩散</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">centerExpand</span><span class="params">($str, $len, $left, $right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( $left &gt;= <span class="number">0</span> &amp;&amp; $right &lt; $len &amp;&amp; $str[$left] == $str[$right] ) &#123;</span><br><span class="line">            $right ++;</span><br><span class="line">            $left --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $right - $left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h3><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode - 236.二叉树的最近公共祖先</a></p><blockquote><p>解题思路: 递归遍历<br>因为我们是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $p</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $q</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> TreeNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lowestCommonAncestor</span><span class="params">($root, $p, $q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($root == <span class="keyword">null</span>) &#123; <span class="comment">//递归结束</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ($root === $p || $root === $q) &#123; <span class="comment">//递归结束</span></span><br><span class="line">            <span class="keyword">return</span> $root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $left  = <span class="keyword">$this</span>-&gt;lowestCommonAncestor($root-&gt;left, $p, $q);</span><br><span class="line">        $right = <span class="keyword">$this</span>-&gt;lowestCommonAncestor($root-&gt;right, $p, $q);</span><br><span class="line">        <span class="keyword">if</span> ($left != <span class="keyword">null</span> &amp;&amp; $right != <span class="keyword">null</span>) &#123; <span class="comment">//第一种情况</span></span><br><span class="line">            <span class="keyword">return</span> $root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($left == <span class="keyword">null</span> &amp;&amp; $right == <span class="keyword">null</span>) &#123; <span class="comment">//第二种情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $left == <span class="keyword">null</span> ? $right : $left; <span class="comment">//第三种情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $val = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $left = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $right = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($value)</span> </span>&#123; <span class="keyword">$this</span>-&gt;val = $value; &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a>151.翻转字符串里的单词</h3><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">LeetCode - 151.翻转字符串里的单词</a></p><blockquote><p>解题思路: 使用语言特性<br><code>split</code>(拆分), <code>reverse</code>(反转), <code>join</code>连接</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String $s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseWords</span><span class="params">($s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $sArr = explode(<span class="string">' '</span>, $s);</span><br><span class="line">    $res = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">foreach</span>($sArr <span class="keyword">as</span> $str) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($str === <span class="string">''</span>) <span class="keyword">continue</span>;</span><br><span class="line">        $res = $str . <span class="string">' '</span> . $res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trim($res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">LeetCode - 101.对称二叉树</a></p><blockquote><p>解题思路: 递归</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isSymmetric</span><span class="params">($root)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;check($root, $root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">($left, $right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($left === <span class="keyword">null</span> &amp;&amp; $right === <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ($left === <span class="keyword">null</span> || $right === <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ($left-&gt;val !== $right-&gt;val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;check($left-&gt;left, $right-&gt;right)</span><br><span class="line">            &amp;&amp; <span class="keyword">$this</span>-&gt;check($left-&gt;right, $right-&gt;left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h3><p><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">LeetCode - 200.岛屿数量</a></p><blockquote><p>解题思路: 深度优先遍历DFS</p></blockquote><p>先遍历，查到的第一个陆地标记为2，开始深度搜索，查找周围的陆地，如果有就标记为2，全部标记完成以后就找到了一块陆地，下次再找到1则是第二块陆地了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String[][] $grid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">numIslands</span><span class="params">($grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> ($grid <span class="keyword">as</span> $y =&gt; &amp;$row) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> ($row <span class="keyword">as</span> $x =&gt; &amp;$cell) &#123;</span><br><span class="line">                <span class="keyword">if</span> ($cell == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;flipIslands($grid, $y, $x);</span><br><span class="line">                    $num ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flipIslands</span><span class="params">(&amp;$grid, $y, $x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">isset</span>($grid[$y][$x]) &amp;&amp; $grid[$y][$x] == <span class="number">1</span>) &#123;</span><br><span class="line">            $grid[$y][$x] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>($grid[$y][$x+<span class="number">1</span>]) &amp;&amp; $grid[$y][$x+<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;flipIslands($grid, $y, $x+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>($grid[$y][$x<span class="number">-1</span>]) &amp;&amp; $grid[$y][$x<span class="number">-1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;flipIslands($grid, $y, $x<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>($grid[$y+<span class="number">1</span>][$x]) &amp;&amp; $grid[$y+<span class="number">1</span>][$x] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;flipIslands($grid, $y+<span class="number">1</span>, $x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>($grid[$y<span class="number">-1</span>][$x]) &amp;&amp; $grid[$y<span class="number">-1</span>][$x] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;flipIslands($grid, $y<span class="number">-1</span>, $x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; 解题思路: 广度优先遍历BFS</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String[][] $grid</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">numIslands</span><span class="params">($grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $rows = count($grid);</span><br><span class="line">        <span class="keyword">if</span> ($rows == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        $cols = count($grid[<span class="number">0</span>]);</span><br><span class="line">        $count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 四个方向数组</span></span><br><span class="line">        $directions = [[<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]];</span><br><span class="line">        <span class="comment">// 辅助队列</span></span><br><span class="line">        $queue = <span class="keyword">new</span> SplQueue();</span><br><span class="line">        <span class="comment">// 访问数组</span></span><br><span class="line">        $visited = array_fill(<span class="number">0</span>, $rows, array_fill(<span class="number">0</span>, $cols, <span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $rows; ++$i) &#123;</span><br><span class="line">            <span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; $cols; ++$j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!$visited[$i][$j] &amp;&amp; $grid[$i][$j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    $count++;</span><br><span class="line">                    $visited[$i][$j] = <span class="keyword">true</span>;</span><br><span class="line">                    $queue-&gt;enqueue($i * $cols + $j);</span><br><span class="line">                    <span class="keyword">while</span> ($queue-&gt;count()) &#123;</span><br><span class="line">                        $cur = $queue-&gt;dequeue();</span><br><span class="line">                        $x = (int) ($cur / $cols);</span><br><span class="line">                        $y = $cur % $cols;</span><br><span class="line">                        <span class="keyword">for</span> ($k = <span class="number">0</span>; $k &lt; <span class="number">4</span>; ++$k) &#123;</span><br><span class="line">                            $newX = $x + $directions[$k][<span class="number">0</span>];</span><br><span class="line">                            $newY = $y + $directions[$k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;inArea($newX, $newY, $grid)</span><br><span class="line">                                &amp;&amp; !$visited[$newX][$newY]</span><br><span class="line">                                &amp;&amp; $grid[$newX][$newY] == <span class="string">'1'</span></span><br><span class="line">                            ) &#123;</span><br><span class="line">                                $visited[$newX][$newY] = <span class="keyword">true</span>;</span><br><span class="line">                                $queue-&gt;enqueue($newX * $cols + $newY);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">inArea</span><span class="params">($x, $y, $grid)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($x &lt; <span class="number">0</span> || $y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ($x &gt;= count($grid) || $y &gt;= count($grid[<span class="number">0</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h3><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">LeetCode - 46.全排列</a></p><blockquote><p>解题思路: 回溯算法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class Solution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer[][]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">permute</span><span class="params">($nums)</span> // 深度优先遍历</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $numsLen = sizeof($nums);</span><br><span class="line">        <span class="keyword">if</span> ($numsLen == <span class="number">0</span>) <span class="keyword">return</span> []; <span class="comment">// 递归结束</span></span><br><span class="line">        <span class="keyword">if</span> ($numsLen == <span class="number">1</span>) <span class="keyword">return</span> [$nums]; <span class="comment">// 递归结束</span></span><br><span class="line">        $ret = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($nums <span class="keyword">as</span> $key =&gt; $num) &#123;</span><br><span class="line">            $tempNums = $nums;</span><br><span class="line">            <span class="keyword">unset</span>($nums[$key]);</span><br><span class="line">            $res = <span class="keyword">$this</span>-&gt;permute($nums); <span class="comment">// 递归</span></span><br><span class="line">            $nums = $tempNums;</span><br><span class="line">            <span class="comment">// 处理返回结果</span></span><br><span class="line">            <span class="keyword">foreach</span> ($res <span class="keyword">as</span> $v) &#123;</span><br><span class="line">                array_unshift($v, $num);</span><br><span class="line">                $ret[] = $v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">LeetCode - 198.打家劫舍</a></p><blockquote><p>解题思路: 动态规划</p></blockquote><p>小偷挑选要偷的房子，且不能偷相邻的两栋房子，方案无非两种:</p><ul><li>方案一：挑选的房子中包含最后一栋； </li><li>方案二：挑选的房子中不包含最后一栋；</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rob</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $n = count($nums);</span><br><span class="line">    <span class="keyword">if</span> ($n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ($n == <span class="number">1</span>) reset($nums);</span><br><span class="line">    <span class="keyword">if</span> ($n == <span class="number">2</span>) <span class="keyword">return</span> max($nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp 数组定义：当前有 i 个房屋，第 i 个房屋偷和不偷可以获取的最大数值</span></span><br><span class="line">    <span class="comment">// 状态转移方程： dp[i] = max(dp[i-1], dp[i-2] + nums[i])</span></span><br><span class="line">    $dp = [];</span><br><span class="line">    $dp[<span class="number">0</span>] = reset($nums);</span><br><span class="line">    $dp[<span class="number">1</span>] = max($nums[<span class="number">0</span>], $nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">2</span>; $i &lt; $n; ++$i) &#123;</span><br><span class="line">        $dp[$i] = max($dp[$i - <span class="number">1</span>], $dp[$i - <span class="number">2</span>] + $nums[$i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $dp[$n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h3><p><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">LeetCode - 54.螺旋矩阵</a></p><blockquote><p>解题思路: 按层模拟</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[][] $matrix</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiralOrder</span><span class="params">($matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $ans = [];</span><br><span class="line">    $u = $l = <span class="number">0</span>;</span><br><span class="line">    $d = count($matrix) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ($d &lt; <span class="number">0</span>) <span class="keyword">return</span> $ans;</span><br><span class="line">    $r = count($matrix[<span class="number">0</span>]) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> ($i = $l; $i &lt;= $r; ++$i) $ans[] = $matrix[$u][$i];</span><br><span class="line">        <span class="keyword">if</span> (++$u &gt; $d) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> ($i = $u; $i &lt;= $d; ++$i) $ans[] = $matrix[$i][$r];</span><br><span class="line">        <span class="keyword">if</span> (--$r &lt; $l) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> ($i = $r; $i &gt;= $l; --$i) $ans[] = $matrix[$d][$i];</span><br><span class="line">        <span class="keyword">if</span> (--$d &lt; $u) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> ($i = $d; $i &gt;= $u; --$i) $ans[] = $matrix[$i][$l];</span><br><span class="line">        <span class="keyword">if</span> (++$l &gt; $r) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LeetCode - 98.验证二叉搜索树</a></p><blockquote><p>解题思路: 中序遍历</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isValidBST</span><span class="params">($root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $res = [];</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dfs($root, $res);</span><br><span class="line">        $len = sizeof($res);</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $len; $i++)&#123;<span class="comment">//判断是否是一个升序数组，且没重复元素</span></span><br><span class="line">            <span class="keyword">if</span> ($res[$i] &lt;= $res[$i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">($root, &amp;$out)</span> // 深度优先遍历</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($root == <span class="keyword">null</span>) <span class="comment">//递归终止</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dfs($root-&gt;left, $out);</span><br><span class="line">        $out[] = $root-&gt;val;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dfs($root-&gt;right, $out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69.x的平方根"></a>69.x的平方根</h3><p><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">LeetCode - 69.x的平方根</a></p><blockquote><p>解题思路: 二分查找</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySqrt</span><span class="params">($x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($x &lt;= <span class="number">1</span>) <span class="keyword">return</span> $x;</span><br><span class="line">    $l = <span class="number">1</span>;</span><br><span class="line">    $r = floor($x / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ($l &lt; $r) &#123;</span><br><span class="line">        <span class="comment">// 取右中位数，否则会死循环</span></span><br><span class="line">        $mid = $l + floor(($r - $l + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ($mid == $x / $mid) <span class="keyword">return</span> $mid;</span><br><span class="line">        <span class="keyword">if</span> ($mid &lt; $x / $mid) &#123;</span><br><span class="line">            $l = $mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $r = $mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="113-路径总和II"><a href="#113-路径总和II" class="headerlink" title="113.路径总和II"></a>113.路径总和II</h3><p><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">LeetCode - 113.路径总和II</a></p><blockquote><p>解题思路: DFS 深度优先遍历</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $ans = [];</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pathSum</span><span class="params">($root, $sum)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dfs($root, $sum, []);    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">dfs</span><span class="params">($root, $sum, $path)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($root === <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        $path[] = $root-&gt;val;</span><br><span class="line">        <span class="comment">// 遍历到叶子节点，终止</span></span><br><span class="line">        <span class="keyword">if</span> ($root-&gt;left === <span class="keyword">null</span> &amp;&amp; $root-&gt;right === <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($root-&gt;val === $sum) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;ans[] = $path;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;dfs($root-&gt;left, $sum - $root-&gt;val, $path);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dfs($root-&gt;right, $sum - $root-&gt;val, $path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165.比较版本号"></a>165.比较版本号</h3><p><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">LeetCode - 165.比较版本号</a></p><blockquote><p>解题思路: 字符串分割<br>注意根据题目要求，如果版本号不存在某个下标处的修订号，则该修订号视为 0</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String $version1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> String $version2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compareVersion</span><span class="params">($version1, $version2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $arr1 = explode(<span class="string">'.'</span>, $version1);</span><br><span class="line">    $arr2 = explode(<span class="string">'.'</span>, $version2);</span><br><span class="line"></span><br><span class="line">    $cnt1 = count($arr1);</span><br><span class="line">    $cnt2 = count($arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($cnt1 &gt; $cnt2) &#123;</span><br><span class="line">        $diff = $cnt1 - $cnt2;</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $diff; $i++) &#123;</span><br><span class="line">            array_push($arr2, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ($cnt1 &lt; $cnt2) &#123;</span><br><span class="line">        $diff = $cnt2 - $cnt1;</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $diff; $i++) &#123;</span><br><span class="line">            array_push($arr1, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $cnt1 = count($arr1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $cnt1; $i++) &#123;</span><br><span class="line">        $v1 = intval($arr1[$i]);</span><br><span class="line">        $v2 = intval($arr2[$i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($v1 != $v2) &#123;</span><br><span class="line">            <span class="keyword">return</span> $v1 &gt; $v2 ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h3><p><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">LeetCode - 剑指 Offer 22. 链表中倒数第k个节点</a></p><blockquote><p>解题思路: 双指针<br>提前指针从头节点，先走(k-1)步，落后指针随后一起走，当提前指针到达链表尾端时，落后节点刚好落在倒数第k个节点的位置。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> Integer $k</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getKthFromEnd</span><span class="params">($head, $k)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 边界情况处理，从而提高代码的健壮性</span></span><br><span class="line"><span class="keyword">if</span> ($head == <span class="keyword">null</span> || $k == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$aheadNode = $head;</span><br><span class="line">$behindNode = $head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// aheadNode 提前节点先走k步</span></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $k - <span class="number">1</span>; $i++) &#123;</span><br><span class="line"><span class="keyword">if</span> ($aheadNode-&gt;next != <span class="keyword">null</span>) &#123;</span><br><span class="line">$aheadNode = $aheadNode-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 链表中没有足够的k个节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提前和落后指针一起走</span></span><br><span class="line"><span class="keyword">while</span> ($aheadNode-&gt;next != <span class="keyword">null</span>) &#123;</span><br><span class="line">$aheadNode = $aheadNode-&gt;next;</span><br><span class="line">$behindNode = $behindNode-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">      $head = $behindNode;</span><br><span class="line">      <span class="keyword">return</span> $head;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="92-反转链表II"><a href="#92-反转链表II" class="headerlink" title="92.反转链表II"></a>92.反转链表II</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">LeetCode - 92.反转链表II</a></p><blockquote><p>解题思路: 一次遍历「穿针引线」反转链表（头插法）</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseBetween</span><span class="params">($head, $m, $n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    $dummy-&gt;next = $head;</span><br><span class="line">    $pre = $dummy;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">1</span>; $i &lt; $m; $i++) &#123;</span><br><span class="line">        $pre = $pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    $head = $pre-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> ($i = $m; $i &lt; $n; $i++) &#123;</span><br><span class="line">        $nex = $head-&gt;next;</span><br><span class="line">        $head-&gt;next = $nex-&gt;next;</span><br><span class="line">        $nex-&gt;next = $pre-&gt;next;</span><br><span class="line">        $pre-&gt;next = $nex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> $dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">LeetCode - 234.回文链表</a></p><blockquote><p>解题思路: 双指针</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span><span class="params">($head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $len = <span class="number">0</span>;</span><br><span class="line">    $p = $head;</span><br><span class="line">    <span class="keyword">while</span>($p) &#123;<span class="comment">//计算链表长度</span></span><br><span class="line">        $len++;</span><br><span class="line">        $p = $p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    $mid = floor($len / <span class="number">2</span>); <span class="comment">//中间值</span></span><br><span class="line">    $prev = <span class="keyword">null</span>;</span><br><span class="line">    $p = $head;</span><br><span class="line">    $q = $head;</span><br><span class="line">    $i = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">while</span>($i &lt; $mid) &#123;</span><br><span class="line">        <span class="comment">// 将mid值之前的节点的next指针都翻转</span></span><br><span class="line">        $q = $q-&gt;next;</span><br><span class="line">        $p-&gt;next = $prev;            </span><br><span class="line">        $prev = $p;</span><br><span class="line">        $p = $q;            </span><br><span class="line">        $i++;                           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ($len%<span class="number">2</span> != <span class="number">0</span>) &#123; <span class="comment">//元素奇偶个数判断</span></span><br><span class="line">        $q = $q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>($prev) &#123; <span class="comment">//前后指针prev和q同时移动判断            </span></span><br><span class="line">        <span class="keyword">if</span> ($prev-&gt;val != $q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        $prev = $prev-&gt;next;</span><br><span class="line">        $q = $q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h3><p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">LeetCode - 169.多数元素</a></p><blockquote><p>解题思路: 取排序后的数组中间元素即可</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">majorityElement</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort($nums);</span><br><span class="line">    <span class="keyword">return</span> $nums[floor(count($nums) / <span class="number">2</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路: 哈希表</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">majorityElement</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// hash table</span></span><br><span class="line">    $hash = [];</span><br><span class="line">    <span class="keyword">foreach</span> ($nums <span class="keyword">as</span> $num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">isset</span>($hash[$num])) $hash[$num] = <span class="number">0</span>;</span><br><span class="line">        $hash[$num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array_search(max($hash), $hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="470-用rand7-实现rand10"><a href="#470-用rand7-实现rand10" class="headerlink" title="470.用rand7()实现rand10()"></a>470.用rand7()实现rand10()</h3><p><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/" target="_blank" rel="noopener">LeetCode - 470.用rand7()实现rand10()</a></p><blockquote><p>解题思路: 拒绝采样</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rand10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        $row = rand7();</span><br><span class="line">        $col = rand7();</span><br><span class="line">        $idx = ($row - <span class="number">1</span>) * <span class="number">7</span> + $col;</span><br><span class="line">        <span class="keyword">if</span> ($idx &lt;= <span class="number">40</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + ($idx - <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41.缺失的第一个正数"></a>41.缺失的第一个正数</h3><p><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">LeetCode - 41.缺失的第一个正数</a></p><blockquote><p>解题思路: 哈希表</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstMissingPositive</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $n = count($nums);</span><br><span class="line">    <span class="keyword">if</span> (!in_array(<span class="number">1</span>, $nums)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt;= $n; $i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($nums[$i] &lt;= <span class="number">0</span> || $nums[$i] &gt; $n) &#123;</span><br><span class="line">            $nums[$i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">        $a = abs($nums[$i]) - <span class="number">1</span>;</span><br><span class="line">        $nums[$a] = - abs($nums[$a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($nums[$i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> $i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode - 142.环形链表II</a></p><blockquote><p>解题思路: 快慢指针</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode $head</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detectCycle</span><span class="params">($head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $fast = $slow = $head;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($fast === <span class="keyword">null</span> || $fast-&gt;next === <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        $fast = $fast-&gt;next-&gt;next;</span><br><span class="line">        $slow = $slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> ($fast === $slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $fast = $head;</span><br><span class="line">    <span class="keyword">while</span> ($fast !== $slow) &#123;</span><br><span class="line">        $fast = $fast-&gt;next;</span><br><span class="line">        $slow = $slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PHP Fatal error:  Nesting level too deep - recursive dependency? in solution.php</p></blockquote><h3 id="240-搜索二维码矩阵II"><a href="#240-搜索二维码矩阵II" class="headerlink" title="240.搜索二维码矩阵II"></a>240.搜索二维码矩阵II</h3><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">LeetCode - 240.搜索二维码矩阵II</a></p><blockquote><p>解题思路: Z 字形查找</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[][] $matrix</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchMatrix</span><span class="params">($matrix, $target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $m = count($matrix); <span class="comment">//行</span></span><br><span class="line">    $n = count($matrix[<span class="number">0</span>]); <span class="comment">//列</span></span><br><span class="line"></span><br><span class="line">    $x = <span class="number">0</span>; <span class="comment">//初始第一行</span></span><br><span class="line">    $y = $n - <span class="number">1</span>; <span class="comment">//最后一列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ($x &lt; $m &amp;&amp; $y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ($matrix[$x][$y] === $target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($matrix[$x][$y] &gt; $target) &#123;<span class="comment">//左移一列</span></span><br><span class="line">            $y--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//下移一行;</span></span><br><span class="line">            $x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-合并k个升序链表"><a href="#23-合并k个升序链表" class="headerlink" title="23.合并k个升序链表"></a>23.合并k个升序链表</h3><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">LeetCode - 23.合并k个升序链表</a></p><blockquote><p>解题思路: 最小堆</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ListNode[] $lists</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ListNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeKLists</span><span class="params">($lists)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($lists)) <span class="keyword">return</span> [];</span><br><span class="line">    $dummyHead = <span class="keyword">new</span> ListNode(<span class="keyword">null</span>); <span class="comment">// 虚拟头结点</span></span><br><span class="line">    $p = $dummyHead;      </span><br><span class="line">    $heap = <span class="keyword">new</span> SplMinHeap(); <span class="comment">// 最小堆</span></span><br><span class="line">    <span class="keyword">foreach</span> ($lists <span class="keyword">as</span> $item) &#123;                           </span><br><span class="line">        <span class="keyword">while</span> ($item) &#123;</span><br><span class="line">            $heap-&gt;insert($item-&gt;val); <span class="comment">// 加入堆中</span></span><br><span class="line">            $item = $item-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;             </span><br><span class="line">    <span class="keyword">while</span> (!$heap-&gt;isEmpty()) &#123; <span class="comment">// 依次拿出所有数据       </span></span><br><span class="line">        $p-&gt;next = <span class="keyword">new</span> ListNode($heap-&gt;extract());</span><br><span class="line">        $p=$p-&gt;next;</span><br><span class="line">    &#125;              </span><br><span class="line">           </span><br><span class="line">    <span class="keyword">return</span> $dummyHead-&gt;next; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h3><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode - 88.合并两个有序数组</a></p><blockquote><p>解题思路: 直接合并后排序</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer $n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span><span class="params">(&amp;$nums1, $m, $nums2, $n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; $i++) &#123;</span><br><span class="line">        $nums1[$m + $i] = $nums2[$i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort($nums1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> $nums1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79.单词搜索"></a>79.单词搜索</h3><p><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">LeetCode - 79.单词搜索</a></p><blockquote><p>解题思路: 回溯算法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $mark = [];</span><br><span class="line">    <span class="keyword">public</span> $board = [];</span><br><span class="line">    <span class="keyword">public</span> $direct = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">-1</span>, <span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">public</span> $m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> $n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String[][] $board</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> String $word</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">exist</span><span class="params">($board, $word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 回溯算法</span></span><br><span class="line">        <span class="keyword">if</span> (!$board) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;board = $board;</span><br><span class="line">        $m = <span class="keyword">$this</span>-&gt;m = count($board);</span><br><span class="line">        $n = <span class="keyword">$this</span>-&gt;n = count($board[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $m; $i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; $n; $j++) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;mark[$i][$j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $m; $i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> ($j = <span class="number">0</span>; $j &lt; $n; $j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ($board[$i][$j] == $word[<span class="number">0</span>]) &#123;<span class="comment">// 首次匹配</span></span><br><span class="line">                    <span class="keyword">$this</span>-&gt;mark[$i][$j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;backtrace($i, $j, substr($word, <span class="number">1</span>))) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">$this</span>-&gt;mark[$i][$j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">backtrace</span><span class="params">($i, $j, $word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strlen($word) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;direct <span class="keyword">as</span> $direct) &#123;</span><br><span class="line">            $_i = $i + $direct[<span class="number">0</span>];</span><br><span class="line">            $_j = $j + $direct[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ($_i &gt;= <span class="number">0</span> &amp;&amp; $_j &gt;= <span class="number">0</span> &amp;&amp; $_i &lt; <span class="keyword">$this</span>-&gt;m &amp;&amp; $_j &lt; <span class="keyword">$this</span>-&gt;n &amp;&amp; <span class="keyword">$this</span>-&gt;board[$_i][$_j] == $word[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;mark[$_i][$_j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;mark[$_i][$_j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;backtrace($_i, $_j, substr($word, <span class="number">1</span>))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;mark[$_i][$_j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114.二叉树展开为链表"></a>114.二叉树展开为链表</h3><p><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">LeetCode - 114.二叉树展开为链表</a></p><blockquote><p>解题思路: 前序遍历<br>操作原有$root变量，使得所有子树节点都变成右子树的。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> TreeNode $root</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flatten</span><span class="params">($root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ($root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($root-&gt;left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                $root = $root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $pre = $root-&gt;left;</span><br><span class="line">                <span class="keyword">while</span> ($pre-&gt;right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    $pre = $pre-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                $pre-&gt;right = $root-&gt;right;</span><br><span class="line">                $root-&gt;right = $root-&gt;left;</span><br><span class="line">                $root-&gt;left = <span class="keyword">null</span>;</span><br><span class="line">                $root = $root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h3><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">LeetCode - 239.滑动窗口最大值</a></p><blockquote><p>解题思路: 单调递减队列</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Integer $k</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Integer[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">maxSlidingWindow</span><span class="params">($nums, $k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $res = [];</span><br><span class="line">        $queue = <span class="keyword">new</span> MyQueue;</span><br><span class="line">        <span class="comment">// 前k个元素入列 </span></span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $k; $i++) &#123; </span><br><span class="line">            $queue-&gt;push($nums[$i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录前k的元素的最大值</span></span><br><span class="line">        $res[] = $queue-&gt;top();</span><br><span class="line">        <span class="keyword">for</span> ($i = $k; $i &lt; count($nums); $i++) &#123;</span><br><span class="line">            $queue-&gt;pop($nums[$i - $k]); <span class="comment">// 窗口最左端的元素出列</span></span><br><span class="line">            $queue-&gt;push($nums[$i]);     <span class="comment">// 窗口最右端的元素入列</span></span><br><span class="line">            $res[] = $queue-&gt;top();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单调递减队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $queue;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;queue = <span class="keyword">new</span> SplQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进一个新元素如果比入口元素大，要将入口元素弹出，直到新元素比入口元素小</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">($val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">$this</span>-&gt;queue-&gt;isEmpty() &amp;&amp; $val &gt; <span class="keyword">$this</span>-&gt;queue-&gt;top()) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;queue-&gt;pop(); <span class="comment">// 入口元素弹出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;queue-&gt;enqueue($val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pop</span><span class="params">($val)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;queue-&gt;isEmpty() &amp;&amp; <span class="keyword">$this</span>-&gt;queue-&gt;bottom() == $val) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;queue-&gt;dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;queue-&gt;bottom();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h3><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">LeetCode - 34.在排序数组中查找元素的第一个和最后一个位置</a></p><blockquote><p>解题思路: 二分查找</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchRange</span><span class="params">($nums, $target)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $n = count($nums);</span><br><span class="line">    <span class="keyword">if</span> ($n === <span class="number">0</span> || $target &lt; $nums[<span class="number">0</span>] || $target &gt; end($nums)) <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    $left = <span class="number">0</span>;</span><br><span class="line">    $right = $n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环终止条件是 left=right</span></span><br><span class="line">    <span class="keyword">while</span> ($left &lt; $right) &#123;</span><br><span class="line">        <span class="comment">// left=mid 时需要上取整</span></span><br><span class="line">        $mid = $left + floor(($right - $left) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 找到把 mid 排除掉的方法</span></span><br><span class="line">        <span class="keyword">if</span> ($nums[$mid] &lt; $target) &#123;</span><br><span class="line">            <span class="comment">// 目标值可能位于区间 [mid+1, right]</span></span><br><span class="line">            $left = $mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 目标值可能位于 [left, mid]</span></span><br><span class="line">            $right = $mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($nums[$left] !== $target) <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> ($l === $n - <span class="number">1</span>) <span class="keyword">return</span> [$l, $l];</span><br><span class="line">    $l = $left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个 (区间下边界可以收缩)</span></span><br><span class="line">    $left = $l;</span><br><span class="line">    $right = $n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环终止条件是 left=right</span></span><br><span class="line">    <span class="keyword">while</span> ($left &lt; $right) &#123;</span><br><span class="line">        <span class="comment">// left=mid 时需要上取整</span></span><br><span class="line">        $mid = $left + floor(($right - $left + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> ($nums[$mid] &gt; $target) &#123;</span><br><span class="line">            <span class="comment">// 目标值可能位于 [left, mid-1]</span></span><br><span class="line">            $right = $mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 目标值可能位于区间 [mid, right]</span></span><br><span class="line">            $left = $mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [$l, $left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h3><p><a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">LeetCode - 739.每日温度</a></p><blockquote><p>解题思路: 正向遍历，最小栈解法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dailyTemperatures</span><span class="params">($T)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $n = count($T);</span><br><span class="line">        $ans = array_fill(<span class="number">0</span>, $n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ($n == <span class="number">0</span>) <span class="keyword">return</span> $ans;</span><br><span class="line">        $stack = <span class="keyword">new</span> SplStack();</span><br><span class="line">        <span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; $n; ++$i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!$stack-&gt;isEmpty() &amp;&amp; $T[$stack-&gt;top()] &lt; $T[$i]) &#123;</span><br><span class="line">                <span class="comment">// 出栈</span></span><br><span class="line">                $top = $stack-&gt;pop();</span><br><span class="line">                $ans[$top] = $i - $top;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $stack-&gt;push($i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解题思路: 逆向遍历，最大栈解法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dailyTemperatures</span><span class="params">($T)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $n = count($T);</span><br><span class="line">        $ans = array_fill(<span class="number">0</span>, $n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ($n == <span class="number">0</span>) <span class="keyword">return</span> $ans;</span><br><span class="line">        $stack = <span class="keyword">new</span> SplStack();</span><br><span class="line">        <span class="keyword">for</span> ($i = $n - <span class="number">1</span>; $i &gt;= <span class="number">0</span>; --$i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!$stack-&gt;isEmpty() &amp;&amp; $T[$stack-&gt;top()] &lt;= $T[$i]) &#123;</span><br><span class="line">                $stack-&gt;pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            $ans[$i] = $stack-&gt;isEmpty() ? <span class="number">0</span> : $stack-&gt;top() - $i;</span><br><span class="line">            $stack-&gt;push($i); <span class="comment">// 下标入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> $ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a>287. 寻找重复数</h3><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode - 287. 寻找重复数</a></p><blockquote><p>解题思路: 双指针<br>类似双指针的解法，但直接在原数组上标记，将已访问过的数组值置为0，在第二次访问到的时候可以直接返回。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Integer[] $nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Integer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDuplicate</span><span class="params">($nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//取第一个数作为起点开始，实际上随机取一个也是可以的，不一定要从0开始</span></span><br><span class="line">    $index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//题目已经限定了，数组内所有值都在[1,n]之间，不可能出现0或者负数</span></span><br><span class="line">    <span class="keyword">while</span> ($nums[$index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//将数组的值作为下一个坐标，并将当前值改为0，如果下一次访问到的时候就知道是第二次访问</span></span><br><span class="line">        $next = $nums[$index];</span><br><span class="line">        $nums[$index] = <span class="number">0</span>;</span><br><span class="line">        $index = $next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/336117700" target="_blank" rel="noopener">字节跳动面试高频算法题汇总</a></li><li><a href="https://github.com/lewiscrow/WorkHardAndFindJob/blob/master/%E5%A4%8D%E4%B9%A0/%E9%9D%A2%E8%AF%95/%E6%89%8B%E6%92%95%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E6%97%B6%E5%87%BA%E7%8E%B0%E8%BF%87%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98.md" target="_blank" rel="noopener">手撕字节跳动面试时出现过的算法题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;世上无难事只怕有心人&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动面试题 I</title>
    <link href="http://blog.caoxl.com/2022/03/10/Byte-Dance-Interview-I/"/>
    <id>http://blog.caoxl.com/2022/03/10/Byte-Dance-Interview-I/</id>
    <published>2022-03-10T01:37:50.000Z</published>
    <updated>2022-03-10T09:35:30.422Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>机会留给有准备的人</p></blockquote><a id="more"></a><h2 id="一面-约1h"><a href="#一面-约1h" class="headerlink" title="一面(约1h)"></a>一面(约1h)</h2><h3 id="在面对未知的流量暴增-可以预先怎么处理"><a href="#在面对未知的流量暴增-可以预先怎么处理" class="headerlink" title="在面对未知的流量暴增, 可以预先怎么处理"></a>在面对未知的流量暴增, 可以预先怎么处理</h3><h4 id="流量暴增的原因"><a href="#流量暴增的原因" class="headerlink" title="流量暴增的原因?"></a>流量暴增的原因?</h4><ul><li><ol><li>不可预测流量: 网站被恶意刷量; CDN回源抓取数据; 合作业务平台调取平台数据等;</li></ol></li><li><ol start="2"><li>可预测流量: 突然爆发的社会热点;营销活动的宣传</li></ol></li></ul><p>不管是可预测流量还是不可预测流量都会表现在<strong>带宽</strong>和<strong>网站整体架构</strong>的应对方案上</p><ul><li>如果是由于带宽原因引起, 由于网站的并发量太高,达到了服务器的吞吐极限, 导致服务器宕机;这时就需要临时申请加大带宽,做负载均衡分流</li><li><p>如果由于外网请求数据库,导致数据库频繁读写,数据库处理能力低,导致大量请求积压;如果是这种情况就需要优化SQL, 存储过程等;如果是请求过大就需要考虑做集群;</p></li><li><p>面对可预测流量的暴增:</p><ul><li>增加后端应用服务器的数量, 数据库读写分离, 分库分表</li></ul></li></ul><h4 id="预备方案"><a href="#预备方案" class="headerlink" title="预备方案"></a>预备方案</h4><ul><li>流量估算</li><li>降级方案</li><li>限流方案</li></ul><p>参考: <a href="https://www.cnblogs.com/dadonggg/p/8651909.html" target="_blank" rel="noopener">如何应对网站流量暴增</a></p><h3 id="如何限流-限流算法-对于ddos攻击怎么处理"><a href="#如何限流-限流算法-对于ddos攻击怎么处理" class="headerlink" title="如何限流, 限流算法, 对于ddos攻击怎么处理"></a>如何限流, 限流算法, 对于ddos攻击怎么处理</h3><ul><li>计数器</li><li>滑动窗口</li><li>漏桶</li><li>令牌</li></ul><p>参考: <a href="https://www.cnblogs.com/dadonggg/p/8651909.html" target="_blank" rel="noopener">限流方案</a></p><h4 id="ddos攻击处理"><a href="#ddos攻击处理" class="headerlink" title="ddos攻击处理"></a>ddos攻击处理</h4><p>高防IP流量迁移</p><ul><li>遇到1G以下的攻击，使用防火墙就可以搞定（或者使用一些免费的云防御产品）</li><li>流量1G—10G时可以选择机房进行流量迁移和清洗</li><li>大于10G时使用高防CDN（云防御）是相对最靠谱并且价钱最能接受的</li></ul><p>参考: <a href="https://blog.csdn.net/higeek/article/details/83143897" target="_blank" rel="noopener">分享：一次从遭遇DDoS攻击到解决的亲身经历</a><br>参考: <a href="https://www.cnblogs.com/viter/archive/2018/11/14/9957214.html" target="_blank" rel="noopener">记一次DDOS攻击防御实录</a></p><h3 id="PHP数组的底层实现"><a href="#PHP数组的底层实现" class="headerlink" title="PHP数组的底层实现"></a>PHP数组的底层实现</h3><ul><li><code>hashTable</code></li></ul><blockquote><p>PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。</p></blockquote><p>PHP 数组的底层实现是散列表（也叫 hashTable 哈希表)，散列表是根据键（Key）直接访问内存存储位置的数据结构，它的key - value 之间存在一个映射函数，可以根据 key 通过映射函数得到的散列值直接索引到对应的 value 值，无需通过关键字比较，在理想情况下，不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O(1)。</p><p>到这里有个问题出现了：存储在散列表里的元素是无序的，PHP 数组如何做到按顺序读取的呢？</p><p>答案是中间映射表</p><ul><li>参考: <a href="https://segmentfault.com/a/1190000020175662" target="_blank" rel="noopener">PHP7 数组的底层实现</a></li></ul><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><blockquote><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。<br>简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。<br>本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p></blockquote><ul><li>首先答事务是什么, 然后答分布式事务是什么</li></ul><h3 id="RPC相对于传统的API调用的优点"><a href="#RPC相对于传统的API调用的优点" class="headerlink" title="RPC相对于传统的API调用的优点"></a>RPC相对于传统的API调用的优点</h3><blockquote><p>RPC (Remote Procedure Call 远程过程调用)<br>简单理解就是: 一个节点请求另外一个节点提供的服务 本地过程调用</p></blockquote><ul><li><p>区别:</p><ul><li>REST (HTTP-Based)</li><li>RPC (Socket-Based)</li></ul></li><li><p>RPC优点</p><ul><li><ol><li>方便使用RPC调用远程函数, 并得到相应的结果,就像调用本地方法一样</li></ol></li><li><ol start="2"><li>编写分布式应用程序更加简单,容易,因为RPC将所有的网络代码都隐藏到了存根函数中</li></ol></li><li><ol start="3"><li>RPC是跨语言的</li></ol></li></ul></li></ul><h3 id="服务调度中心的感知与动态上下线"><a href="#服务调度中心的感知与动态上下线" class="headerlink" title="服务调度中心的感知与动态上下线"></a>服务调度中心的感知与动态上下线</h3><ul><li>zookeeper</li></ul><blockquote><p>在实际的生产环境中我们一般都是集群环境部署的，同一个程序我们会部署在相同的几台服务器中，这时我们可以通过负载均衡服务器去调度，但是我们并不能很快速的获知哪台服务器挂掉了，这时我们就可以使用zookeeper来解决这个问题。</p></blockquote><p>参考: <a href="https://www.cnblogs.com/GodHeng/p/8797100.html" target="_blank" rel="noopener">分布式服务动态上下线感知</a></p><h3 id="MySQL的索引-为什么是B-而不是平衡二叉树"><a href="#MySQL的索引-为什么是B-而不是平衡二叉树" class="headerlink" title="MySQL的索引, 为什么是B+而不是平衡二叉树"></a>MySQL的索引, 为什么是B+而不是平衡二叉树</h3><ul><li>B+数的磁盘读写代价更低: B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</li><li>B+树的查询效率更加稳定: 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li><li>B+树的数据都存储在叶子节点中,分支节点均为索引,方便扫库,只需要扫一遍叶子节点即可</li></ul><blockquote><p>B树在提高了IO性能的同时并没有解决元素遍历的效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。</p></blockquote><p>参考: <a href="https://www.cnblogs.com/tiancai/p/9024351.html" target="_blank" rel="noopener">为什么MySQL数据库索引选择使用B+树？</a><br>参考: <a href="https://blog.csdn.net/jacke121/article/details/78268602" target="_blank" rel="noopener">快速理解平衡二叉树、B-tree、B+tree、B*tree</a></p><h3 id="索引查找在Linux的磁盘上是怎么操作的"><a href="#索引查找在Linux的磁盘上是怎么操作的" class="headerlink" title="索引查找在Linux的磁盘上是怎么操作的"></a>索引查找在Linux的磁盘上是怎么操作的</h3><blockquote><p>根据<strong>文件路径</strong>查询索引节点</p></blockquote><p>参考: <a href="https://blog.csdn.net/qq_38410730/article/details/81416195" target="_blank" rel="noopener">【Linux】Linux根据文件路径查找索引节点</a></p><h3 id="聚簇索引相对于B-索引的优点"><a href="#聚簇索引相对于B-索引的优点" class="headerlink" title="聚簇索引相对于B+索引的优点"></a>聚簇索引相对于B+索引的优点</h3><blockquote><p>InnoDB默认会为每个表创建这样一个索引，叫做聚簇索引。<br>聚簇索引只能在搜索条件是主键值时才能发挥作用。</p></blockquote><p>加了主键以后，整个表变成了一个索引，也就是所谓的「聚簇索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚簇索引索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。</p><p>因为由存储引擎实现索引，所以，并不是所有的引擎都支持聚簇索引。目前，只有<strong>solidDB</strong>和<strong>InnoDB</strong>（MySQL的支持）。</p><p>非聚簇索引和聚簇索引的区别在于: 通过聚簇索引可以查到需要查找的数据， 而通过非聚簇索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据</p><p>参考: <a href="https://blog.csdn.net/u014454538/article/details/88917492" target="_blank" rel="noopener">数据库索引（索引的优缺点、创建原则、B树与B+树、聚簇索引与非聚簇索引）</a></p><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>当我们需要根据指定列查询完整的用户记录时，我们需要根据二级索引查找到记录的主键值，然后再根据主键值使用聚簇索引查询完整的用户记录，这一过程叫做<strong>回表</strong>。</p><h3 id="如何分析SQL执行慢的原因"><a href="#如何分析SQL执行慢的原因" class="headerlink" title="如何分析SQL执行慢的原因"></a>如何分析SQL执行慢的原因</h3><ul><li>SQL偶尔执行慢<ul><li>网络抖动</li><li>Innodb脏页刷新  </li><li>操作等待锁资源</li></ul></li><li>SQL一直执行慢<ul><li>首先肯定,这个SQL肯定有问题, 需要排查原因</li><li>SQL执行没有索引</li><li>SQL执行走了索引, 但是类型是<code>ALL</code></li><li>单表数据量过大 (InnoDB的数据表数量级超过千万后，性能会出现下降，核心是由于B+Tree的数据结构导致的)</li></ul></li></ul><p>参考: <a href="https://blog.csdn.net/wtopps/article/details/103434390" target="_blank" rel="noopener">SQL执行慢的原因分析</a></p><h3 id="Redis连接时的connect和pconnect的区别"><a href="#Redis连接时的connect和pconnect的区别" class="headerlink" title="Redis连接时的connect和pconnect的区别"></a>Redis连接时的connect和pconnect的区别</h3><ul><li><code>connect</code>: 脚本结束后连接就释放了</li><li><p><code>pconnect</code>: 脚本结束后连接不释放,连接保持再php-fpm的进程中</p></li><li><p>本站<a href="https://blog.caoxl.com/2022/03/03/PHP-Eight-Legged-Essay/#redis-%E7%9A%84-connect-%E5%92%8C-pconnect-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8Cpconnect-%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%88%E6%BB%B4%E6%BB%B4-%E9%99%8C%E9%99%8C%EF%BC%89">pconnect 有什么问题</a></p></li></ul><p>参考: <a href="https://www.cnblogs.com/lovebing/p/6250281.html" target="_blank" rel="noopener">Redis中connect与pconnect区别？</a></p><h3 id="Redis有哪些结构时间复杂度较高"><a href="#Redis有哪些结构时间复杂度较高" class="headerlink" title="Redis有哪些结构时间复杂度较高"></a>Redis有哪些结构时间复杂度较高</h3><blockquote><p>时间复杂度由低到高:<br>常数阶O(1) &lt; 对数阶O(logN) &lt; 线性阶O(n) &lt; 线性对数阶O(nlogN) &lt; 平方阶O(n²) &lt; 立方阶O(n³) &lt; K次方阶O(n^k) &lt; 指数阶(2^n)</p></blockquote><ul><li><code>String</code>: 最高是O(n) (<code>mset</code>, <code>msetnx</code>)</li><li><code>List</code>: 最高是O(n) (<code>lpush</code>, <code>lrange</code>)</li><li><code>Hash</code>: 最高是O(n) (<code>hmset/hmget</code>, <code>hdel</code>, <code>hgetall</code>, <code>hkeys/hvals</code>)</li><li><code>Set</code>: 最高是O(n) (<code>sadd</code>, <code>srem</code>, <code>srandmember</code>, <code>spop</code>)</li><li><code>SortedSet</code>: 最高是O(nlogN) (<code>zadd</code>, <code>zrem</code>)</li></ul><h3 id="Redis-hash的实现"><a href="#Redis-hash的实现" class="headerlink" title="Redis hash的实现"></a>Redis hash的实现</h3><blockquote><p>Redis的数据库就是使用<strong>字典</strong>作为底层实现的，通过key和value的键值对形式，代表了数据库中全部数据。而且，所有对数据库的增、删、查、改的命令，都是建立在对字典的操作上。</p></blockquote><p>参考: <a href="https://www.cnblogs.com/ourroad/p/4891648.html" target="_blank" rel="noopener">Redis之Hash数据结构</a></p><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>在1个10G大小的文件中, 存储的都是int型的数据, 如何在内存使用小于8M的情况进行排序</p><p>参考: <a href="https://www.cnblogs.com/dream-of-cambridge/articles/8042311.html" target="_blank" rel="noopener">归并排序，外排序，10G文件500M内存的排序</a></p><h3 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h3><p>以微博为例, 有1个亿的用户,同事用户之间有关注和粉丝,用户的关注和取关操作比较频繁, 如何设计架构和API接口</p><p>参考: <a href="https://blog.csdn.net/bigtree_3721/article/details/79779249" target="_blank" rel="noopener">新浪微博技术架构分析和设计</a></p><h2 id="二面-约1-5h"><a href="#二面-约1-5h" class="headerlink" title="二面 (约1.5h)"></a>二面 (约1.5h)</h2><blockquote><p>二面主要以自己的项目为切入点，进一步考察你对项目中知识点的把握程度</p></blockquote><h3 id="守护进程是什么-怎么实现"><a href="#守护进程是什么-怎么实现" class="headerlink" title="守护进程是什么, 怎么实现"></a>守护进程是什么, 怎么实现</h3><blockquote><p>守护进程（Daemon）是运行在后台的一种特殊进程，也称为精灵进程。</p></blockquote><p>实现守护进程的一般步骤:</p><ol><li>父进程fork出子进程并exit退出</li><li>子进程调用setsid创建新会话</li><li>子进程调用系统函数chdir将根目录”/“修改成为子进程的工作目录</li><li>子进程调用系统函数umask将该进程的umask设置为0</li><li>子进程关闭从父进程继承的所有不需要的文件描述符</li></ol><p>参考: <a href="https://www.jianshu.com/p/d9bfbee5e915" target="_blank" rel="noopener">实现守护进程</a><br>参考: <a href="https://blog.csdn.net/m0_37925202/article/details/80214095" target="_blank" rel="noopener">守护进程详解及其代码实现</a></p><h3 id="PHP是否适合做守护进程-为什么-内存管理这一块"><a href="#PHP是否适合做守护进程-为什么-内存管理这一块" class="headerlink" title="PHP是否适合做守护进程, 为什么 (内存管理这一块)"></a>PHP是否适合做守护进程, 为什么 (内存管理这一块)</h3><blockquote><p>不适合, 可能有内存泄露问题</p></blockquote><h3 id="PHP的垃圾回收机制"><a href="#PHP的垃圾回收机制" class="headerlink" title="PHP的垃圾回收机制"></a>PHP的垃圾回收机制</h3><p>1.引用计数 2.写时拷贝</p><h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ol><li>匿名管道</li><li>高级管道</li><li>命名管道</li><li>消息队列</li><li>信号量</li><li>信号</li><li>共享内存</li><li>套接字</li></ol><p>参考: <a href="https://cloud.tencent.com/developer/article/1690556" target="_blank" rel="noopener">进程间8种通信方式详解</a><br>参考: <a href="https://www.cnblogs.com/zgq0/p/8780893.html" target="_blank" rel="noopener">进程间的五种通信方式介绍</a></p><h3 id="共享内存是怎么实现的"><a href="#共享内存是怎么实现的" class="headerlink" title="共享内存是怎么实现的"></a>共享内存是怎么实现的</h3><blockquote><p>共享内存（share memory）是一种最为高效的进程间通信方式，是因为进程能够直接对内存进行读写，且不需要进行数据的保存与复制。</p></blockquote><p>共享内存的实现较为简单，一共分为两个步骤：</p><ol><li>创建共享内存: 通过函数<code>shmget()</code>从内存中获取一块共享内存区域,该函数返回值为共享内存的ID</li><li>映射共享内存: 通过函数<code>shmat()</code>将上一步获取的共享内存映射到具体的内存空间</li></ol><h3 id="怎么查看Linux服务器的负载-及判断哪些操作引起的负载过高"><a href="#怎么查看Linux服务器的负载-及判断哪些操作引起的负载过高" class="headerlink" title="怎么查看Linux服务器的负载, 及判断哪些操作引起的负载过高"></a>怎么查看Linux服务器的负载, 及判断哪些操作引起的负载过高</h3><p>查看服务器负载有多种命令，w或者uptime都可以直接展示负载</p><ul><li><code>uptime</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZuf6e3565o1e3wg8p9os5Z ~]# uptime</span><br><span class="line">14:57:56 up 82 days, 23:22,  1 user,  load average: 0.08, 0.07, 0.01</span><br></pre></td></tr></table></figure><p>load average分别对应于过去1分钟，5分钟，15分钟的负载平均值。</p><ul><li><code>w</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZuf6e3565o1e3wg8p9os5Z ~]# w</span><br><span class="line">14:59:40 up 82 days, 23:24,  1 user,  load average: 0.01, 0.05, 0.00</span><br><span class="line">USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    183.62.22.202    14:59    0.00s  0.00s  0.00s w</span><br></pre></td></tr></table></figure><p>这两个命令只是单纯的反映出负载，linux提供了更为强大，也更为实用的top命令来查看服务器负载。</p><ul><li><code>top</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 15:00:51 up 82 days, 23:25,  1 user,  load average: 0.11, 0.08, 0.01</span><br><span class="line">Tasks: 495 total,   1 running, 494 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  2.8%us,  0.7%sy,  0.0%ni, 96.5%id,  0.0%wa,  0.0%hi,  0.1%si,  0.0%st</span><br><span class="line">Mem:  15930632k total, 15374752k used,   555880k free,   326284k buffers</span><br><span class="line">Swap:        0k total,        0k used,        0k free, 11117084k cached</span><br></pre></td></tr></table></figure><ul><li>Tasks行展示了目前的进程总数及所处状态，要注意zombie，表示僵尸进程，不为0则表示有进程出现问题。</li><li>Cpu(s)行展示了当前CPU的状态，us表示用户进程占用CPU比例，sy表示内核进程占用CPU比例，id表示空闲CPU百分比，wa表示IO等待所占用的CPU时间的百分比。wa占用</li><li>Mem行展示了当前内存的状态，total是总的内存大小，userd是已使用的，free是剩余的，buffers是目录缓存。</li><li>Swap行同Mem行，cached表示缓存，用户已打开的文件。</li></ul><p>在top命令下，按1，则可以展示出服务器有多少CPU，及每个CPU的使用情况</p><blockquote><p>一般而言，服务器的合理负载是CPU核数*2。也就是说对于8核的CPU，负载在16以内表明机器运行很稳定流畅。如果负载超过16了，就说明服务器的运行有一定的压力了。</p></blockquote><h4 id="判断哪些操作引起的负载过高"><a href="#判断哪些操作引起的负载过高" class="headerlink" title="判断哪些操作引起的负载过高"></a>判断哪些操作引起的负载过高</h4><ul><li><code>vmstat</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZuf62rvlhskrte5956lmlZ ~]# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----</span><br><span class="line">r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">0  0      0 4397908 381736 29914792    0    0     0     4    0    0  3  1 96  0  0</span><br></pre></td></tr></table></figure><ul><li>r 列表示运行和等待cpu时间片的进程数，如果长期大于1，说明cpu不足，需要增加cpu。</li><li>b 列表示在等待资源的进程数，比如正在等待I/O、或者内存交换等。</li><li>us 列显示了用户方式下所花费 CPU 时间的百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，需要考虑优化用户的程序</li><li>sy 列显示了内核进程所花费的cpu时间的百分比。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足。</li></ul><p>参考: <a href="https://blog.csdn.net/truelove12358/article/details/50502248" target="_blank" rel="noopener">linux 下查看系统资源和负载,以及性能监控</a></p><h3 id="MySQL的IO过高怎么优化-分库分表及分区"><a href="#MySQL的IO过高怎么优化-分库分表及分区" class="headerlink" title="MySQL的IO过高怎么优化, 分库分表及分区"></a>MySQL的IO过高怎么优化, 分库分表及分区</h3><p>参考: <a href="https://blog.csdn.net/designer01/article/details/82772620" target="_blank" rel="noopener">mysql分区、分表、分库、数据分片</a></p><p>分库后的问题</p><ul><li>分布式事务</li><li>跨库Join</li><li>排序,分页,分组</li></ul><h3 id="MySQL的索引结果-MyISAM和Innodb的索引结构-Innodb为什么必须要有主键索引"><a href="#MySQL的索引结果-MyISAM和Innodb的索引结构-Innodb为什么必须要有主键索引" class="headerlink" title="MySQL的索引结果, MyISAM和Innodb的索引结构, Innodb为什么必须要有主键索引"></a>MySQL的索引结果, MyISAM和Innodb的索引结构, Innodb为什么必须要有主键索引</h3><ul><li>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址</li><li>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同<ul><li>第一个重大区别是InnoDB的数据文件本身就是索引文件</li><li>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址</li></ul></li></ul><p>参考: <a href="https://www.cnblogs.com/olinux/p/5217186.html" target="_blank" rel="noopener">MySQL中myisam和innodb的主键索引有什么区别？</a></p><h3 id="添加索引-为什么可以减少io操作-磁盘页"><a href="#添加索引-为什么可以减少io操作-磁盘页" class="headerlink" title="添加索引, 为什么可以减少io操作 (磁盘页)"></a>添加索引, 为什么可以减少io操作 (磁盘页)</h3><p>DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p><h3 id="Nginx的负载均衡算法"><a href="#Nginx的负载均衡算法" class="headerlink" title="Nginx的负载均衡算法"></a>Nginx的负载均衡算法</h3><ul><li><code>轮询round robin</code> (默认): 轮询方式，依次将请求分配到各个后台服务器中，默认的负载均衡方式。</li><li><code>权重weight</code>: 根据权重来分发请求到不同的机器中，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</li><li><code>ip_hash</code>: 根据请求者ip的hash值将请求发送到后台服务器中，可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</li><li><code>url_hash</code>: 根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高。</li><li><code>fair</code>: 根据后台响应时间来分发请求，响应时间短的分发的请求多。</li></ul><p>参考: <a href="https://blog.csdn.net/chenyulancn/article/details/70800991" target="_blank" rel="noopener">Nginx的五种负载算法</a></p><h3 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h3><p>查找一个字符串中最长的无重复字符串</p><p>我们可以定义字符到索引的映射 当我们找到重复的字符时，我们可以立即跳过该窗口。<br>也就是说, 如果 str[i] 在[i,j]范围内有与<code>i</code>重复的字符, 我们不需要逐渐增加<code>j</code>;我们可以直接跳过[i, j]范围内的所有元素, 并将<code>j</code>变成<code>i+1</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longestSubstring</span><span class="params">($str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $len = strlen($str);</span><br><span class="line">    $i = <span class="number">0</span>;</span><br><span class="line">    $j = <span class="number">0</span>;</span><br><span class="line">    $maxStrLen = <span class="number">0</span>;</span><br><span class="line">    $set = [];</span><br><span class="line">    <span class="keyword">while</span> ($i &lt; $len) &#123;</span><br><span class="line">        <span class="comment">// PHP中 [(下标)] 符号不仅可以应用于数组和对象，还可以应用于字符串</span></span><br><span class="line">        <span class="keyword">if</span> (array_key_exists($str[$i], $set)) &#123;</span><br><span class="line">            $j = max($j, $set[$str[$i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        $maxStrLen = max($maxStrLen, $i - $j + <span class="number">1</span>);</span><br><span class="line">        $set[$str[$i]] = $i + <span class="number">1</span>;</span><br><span class="line">        $i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $maxStrLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三面-约0-6h"><a href="#三面-约0-6h" class="headerlink" title="三面 (约0.6h)"></a>三面 (约0.6h)</h2><blockquote><p>三面与二面的内容差不多，没有更深的问题，但是，需要注重细节，同时三面面试官有时间会放烟雾弹，坚定自己的立场就好</p></blockquote><h3 id="在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中"><a href="#在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中" class="headerlink" title="在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中"></a>在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中</h3><h3 id="设计一个定时任务管理器"><a href="#设计一个定时任务管理器" class="headerlink" title="设计一个定时任务管理器"></a>设计一个定时任务管理器</h3><p>参考: <a href="https://studygolang.com/articles/9523" target="_blank" rel="noopener">golang实践-如何实现高性能的定时任务管理器</a></p><h3 id="算法题-2"><a href="#算法题-2" class="headerlink" title="算法题"></a>算法题</h3><p>经典赛马问题,8个赛道,64匹马,比赛多少次可以找出前四名</p><ol><li>赛8场, 每场后4名淘汰 (8次)</li><li>选择每组的第一名再出来跑一次，这样落后的第一名所在的整组都可以排除 (1次)</li><li>组间的第一名有了名次关系，可以发现一定不属于前4名，因为都在他们前面。同理可排除。同时是最快的，一定属于前4。那接下来只需在剩下的9匹中找出前3 (1次)</li><li>除去，其余8匹跑一次。如果在第3名或者更后，那说明已经选出了前3名，也不用再跑了，否则再取前3和一起跑一次，即可得结果。(1次)</li></ol><blockquote><p>最多11次一定可以选出最快的4匹</p></blockquote><p>参考: <a href="https://cloud.tencent.com/developer/article/1819253" target="_blank" rel="noopener">腾讯面试题：64匹马，8赛道，找出最快的4匹最少要几次?</a></p><h2 id="Hr面-约0-5h"><a href="#Hr面-约0-5h" class="headerlink" title="Hr面 (约0.5h)"></a>Hr面 (约0.5h)</h2><blockquote><p>这个就是见仁见智了</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;机会留给有准备的人&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试八股文</title>
    <link href="http://blog.caoxl.com/2022/03/03/PHP-Eight-Legged-Essay/"/>
    <id>http://blog.caoxl.com/2022/03/03/PHP-Eight-Legged-Essay/</id>
    <published>2022-03-03T06:34:35.000Z</published>
    <updated>2022-03-09T09:48:21.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>面试造火箭 上班拧螺丝<br>“茴香豆的『回』字有几种写法你知道么”</p></blockquote><a id="more"></a><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><h3 id="php-fpm-的生命周期，创建进程方式，各自的优缺点（腾讯-百度-滴滴-陌陌）"><a href="#php-fpm-的生命周期，创建进程方式，各自的优缺点（腾讯-百度-滴滴-陌陌）" class="headerlink" title="php-fpm 的生命周期，创建进程方式，各自的优缺点（腾讯 百度 滴滴 陌陌）"></a>php-fpm 的生命周期，创建进程方式，各自的优缺点（腾讯 百度 滴滴 陌陌）</h3><blockquote><p>PHP-FPM是一种多进程模型，主要由Master进程以及Worker进程组成，所有的cgi请求都会交由Worker进程处理。Master进程主要维护worker进程。<br>而worker进程的工作方式是抢占/竞争的方式，当一个accept请求过来的时候，谁先拿到算谁的，拿到后转化为FastCGIRequest，交由脚本处理。</p></blockquote><h4 id="php生命周期"><a href="#php生命周期" class="headerlink" title="php生命周期"></a>php生命周期</h4><p>数据初始化(MINT) =&gt; 请求初始化(RINT) =&gt; 编译脚本 (RSHUTDOWN) =&gt; 执行代码(MSHUTDOWN)</p><ul><li><a href="https://www.abelzhou.com/php/php-fpm-lifespan/#" target="_blank" rel="noopener">PHP-FPM 生命周期</a></li></ul><h4 id="static-静态模式"><a href="#static-静态模式" class="headerlink" title="static 静态模式"></a>static 静态模式</h4><p>启动的时候创建固定数量的worker进程,实际请求大于worker进程的时候 <strong>包warning</strong></p><h4 id="ondemand-按需分配模式"><a href="#ondemand-按需分配模式" class="headerlink" title="ondemand 按需分配模式"></a>ondemand 按需分配模式</h4><p>启动的时候不会创建worker进程, 根据需要创建,释放在idle_timeout之后</p><p>这样不能及时的释放连接和建立连接需要消耗资源</p><h4 id="dynamic-动态模式-默认"><a href="#dynamic-动态模式-默认" class="headerlink" title="dynamic 动态模式(默认)"></a>dynamic 动态模式(默认)</h4><p>启动的是创建指定数量的worker进程, 根据情况合理的worker,定期检测worker,关闭闲置连接</p><ul><li><a href="https://www.its404.com/article/qq_39787367/104009809" target="_blank" rel="noopener">PHP-FPM三种运行模式</a></li></ul><h3 id="php-数组遍历为什么能保证有序（滴滴）"><a href="#php-数组遍历为什么能保证有序（滴滴）" class="headerlink" title="php 数组遍历为什么能保证有序（滴滴）"></a>php 数组遍历为什么能保证有序（滴滴）</h3><p>为了实现插入与遍历的顺序一致性，在PHP7中，增加了一个中间映射层，它的大小与哈希表相同，存储了元素在bucket中最终存储的位置，我们把它叫做<strong>映射表</strong>。</p><ul><li><a href="https://www.laruence.com/2009/08/23/1065.html" target="_blank" rel="noopener">深入理解PHP之数组(遍历顺序)</a></li></ul><h3 id="php-怎么实现的弱类型，怎么实现一个扩展（腾讯）"><a href="#php-怎么实现的弱类型，怎么实现一个扩展（腾讯）" class="headerlink" title="php 怎么实现的弱类型，怎么实现一个扩展（腾讯）"></a>php 怎么实现的弱类型，怎么实现一个扩展（腾讯）</h3><h4 id="实现php弱类型变量"><a href="#实现php弱类型变量" class="headerlink" title="实现php弱类型变量"></a>实现php弱类型变量</h4><ol><li>通过Zend引擎用C实现弱类型，在ZE中用结构体zval来保存</li><li>通过Zend引擎是判别、存储PHP中的多种数据类型，根据type来选择获取【zvalue_value】的值</li></ol><h4 id="实现一个扩展"><a href="#实现一个扩展" class="headerlink" title="实现一个扩展"></a>实现一个扩展</h4><ul><li><a href="https://juejin.cn/post/7036991318991749128#heading-5" target="_blank" rel="noopener">解析PHP原生扩展开发</a></li></ul><h3 id="常见魔术方法和函数（腾讯-滴滴）"><a href="#常见魔术方法和函数（腾讯-滴滴）" class="headerlink" title="常见魔术方法和函数（腾讯 滴滴）"></a>常见魔术方法和函数（腾讯 滴滴）</h3><ul><li><code>__construct()</code>: 类的构造函数</li><li><code>__destruct()</code>: 类的析构函数</li><li><code>__call()</code>: 当调用一个未定义或不可达方法时， __call () 方法将被调用。</li><li><code>__callStatic()</code>: 当调用一个未定义或不可达的静态方法时， __callStatic () 方法将被调用。</li><li><code>__get()</code>: 当获取一个类的成员变量时， __get () 方法将被调用。</li><li><code>__set()</code>: 当赋值一个类的成员变量时， __set () 方法将被调用。</li><li><code>__isset()</code>: 当调用 isset () 或 empty () 对一个未定义或不可达的成员赋值时， __isset () 方法将被调用。</li><li><code>__unset()</code>: 当调用 reset () 对一个未定义或不可达的成员更新时， __unset () 方法将被调用。</li><li><code>__sleep()</code>: 当执行序列化 serialize () 时，__sleep () 方法将首先被调用。</li><li><code>__wakeup()</code>: 当执行反序列化 deserialization () 时， __wakeup () 方法将首先被调用。</li><li><code>__toString()</code>: 当使用 echo 方法直接输出显示对象时，__toString () 方法首先被调用。</li><li><code>__invoke()</code>: 使用调用函数（function）访问一个对象时， __invoke () 方法将首先被调用。</li><li><code>__set_state()</code>: 当调用 var_export () 方法时，__set_state () 方法将被调用。</li><li><code>__clone()</code>: 当对象被复制赋值时，__clone () 方法将被调用。</li><li><code>__autoload()</code>: 试图载入一个未定义的类时调用。</li><li><code>__debugInfo()</code>: 输出 debug 信息。</li></ul><ul><li><a href="https://learnku.com/php/t/40919" target="_blank" rel="noopener">16 个 PHP 开发者必知必会的魔术方法</a></li></ul><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="有哪些事务隔离级别，Mysql-的事务隔离级别是怎么实现的？（每家都问）"><a href="#有哪些事务隔离级别，Mysql-的事务隔离级别是怎么实现的？（每家都问）" class="headerlink" title="有哪些事务隔离级别，Mysql 的事务隔离级别是怎么实现的？（每家都问）"></a>有哪些事务隔离级别，Mysql 的事务隔离级别是怎么实现的？（每家都问）</h3><blockquote><p>事务的隔离性由锁来实现。 原子性、一致性、持久性通过数据库的redo log和undo log来实现。 redo log称为重做日志，用来保证事务的原子性和持久性，undo log用来保证事务的一致性。 MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化</p></blockquote><ul><li>未提交读(RU)</li><li>提交读(RC)</li><li>可重复读(RR)</li><li>序列化读(S)</li></ul><ul><li><a href="https://segmentfault.com/a/1190000025156465" target="_blank" rel="noopener">深入理解MySQL中事务隔离级别的实现原理</a></li></ul><h3 id="索引原理（每家都问）"><a href="#索引原理（每家都问）" class="headerlink" title="索引原理（每家都问）"></a>索引原理（每家都问）</h3><blockquote><p>索引的本质是一种排好序的数据结构</p></blockquote><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><ul><li>Hash索引</li><li>二叉树</li><li>B树</li><li>B+树 (MySQL 中最常用的索引的数据结构是 B+ 树)</li></ul><ul><li><a href="https://juejin.cn/post/6931901822231642125" target="_blank" rel="noopener">MySQL索引原理，一篇从头到尾讲清楚</a></li></ul><h3 id="分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）"><a href="#分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）" class="headerlink" title="分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）"></a>分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）</h3><h4 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h4><blockquote><p>常见的分布式生成唯一ID的方式很多，最常见的雪花算法Snowflake、滴滴Tinyid、美团Leaf。以雪花算法举例来说，一毫秒可以生成4194304多个ID。</p></blockquote><h3 id="MVCC-和间隙锁原理（滴滴-字节-百度）"><a href="#MVCC-和间隙锁原理（滴滴-字节-百度）" class="headerlink" title="MVCC 和间隙锁原理（滴滴 字节 百度）"></a>MVCC 和间隙锁原理（滴滴 字节 百度）</h3><blockquote><p>多版本并发控制（MVCC）是一种解决读-写冲突的无锁并发控制<br>每一行记录都有两个隐藏列：创建版本号和回滚指针。事务开启后存在一个事务id。多个并发事务同时操作某行，不同的事务对该行update操作会产生多个版本，然后通过回滚指针组成undo log链。而MVCC的快照读正是通过事务id和创建版本号从而实现的快照读。</p></blockquote><p><strong>注意：只有RR隔离级别才存在间隙锁。</strong></p><h3 id="explain-的-type-字段有哪些（知乎）"><a href="#explain-的-type-字段有哪些（知乎）" class="headerlink" title="explain 的 type 字段有哪些（知乎）"></a>explain 的 type 字段有哪些（知乎）</h3><ul><li><code>system</code>: 系统表,少量数据,往往不需要进行磁盘IO</li><li><code>const</code>: 常量连接</li><li><code>eq_ref</code>: 主键索引(primary key)或者非空唯一索引(unique not null)等值扫描</li><li><code>ref</code>: 非主键非唯一索引等值扫描</li><li><code>range</code>: 范围扫描</li><li><code>index</code>: 索引树扫描</li><li><code>ALL</code>: 全表扫描(full table scan)</li></ul><h4 id="type扫描方式由快到慢"><a href="#type扫描方式由快到慢" class="headerlink" title="type扫描方式由快到慢"></a><code>type</code>扫描方式由快到慢</h4><blockquote><p><code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code></p></blockquote><ul><li><a href="https://juejin.cn/post/6844904149864169486" target="_blank" rel="noopener">Mysql Explain之type详解</a></li></ul><h3 id="update-语句的执行流程，binlog-的作用和几种格式（滴滴）"><a href="#update-语句的执行流程，binlog-的作用和几种格式（滴滴）" class="headerlink" title="update 语句的执行流程，binlog 的作用和几种格式（滴滴）"></a>update 语句的执行流程，binlog 的作用和几种格式（滴滴）</h3><ul><li><a href="https://cdn.learnku.com/uploads/images/202007/16/66421/IA2zMmze89.png!large" target="_blank" rel="noopener">update 语句的执行流程</a></li></ul><h4 id="binlog-的作用和几种格式"><a href="#binlog-的作用和几种格式" class="headerlink" title="binlog 的作用和几种格式"></a>binlog 的作用和几种格式</h4><p>binlog一般情况下分为三种格式，分别是<code>row</code>格式、<code>statement</code>格式、<code>mixed</code>格式</p><ul><li><code>row格式</code>: 此格式不记录sql语句上下文相关信息，仅保存哪条记录被修改。</li><li><code>statement</code>: 该格式下每一条会修改数据的sql都会记录在binlog中。</li><li><code>mixed</code>: 该格式是以上两种level的混合使用，一般的语句修改使用statement格式保存binlog，当statement无法完成主从复制的操作时(设计一些函数时)，则采用Row格式保存binlog</li></ul><h3 id="主从同步的原理和问题（字节-滴滴-陌陌）"><a href="#主从同步的原理和问题（字节-滴滴-陌陌）" class="headerlink" title="主从同步的原理和问题（字节 滴滴 陌陌）"></a>主从同步的原理和问题（字节 滴滴 陌陌）</h3><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><ol><li>在主库上把数据更改记录到二进制日志binary log中，具体是在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中去，Mysql会按照事务提交的顺序来记录二进制日志的。日志记录好之后，主库通知存储引擎提交事务。</li><li>从库会启动一个IO线程，该线程会连接到主库。而主库上的binlog dump线程会去读取主库本地的binlog日志文件中的更新事件。发往从库，从库接收到日志之后会将其记录到本地的中继日志relay-log当中。</li><li>从库中的SQL线程读取中继日志relay-log中的事件，将其重放到从库中。（在5.6版本之前SQL线程是单线程的，使得主从之间延迟更大）</li></ol><ul><li><a href="https://www.cnblogs.com/idoljames/p/11694039.html" target="_blank" rel="noopener">Mysql主从复制原理及同步延迟问题</a></li></ul><h4 id="延迟问题"><a href="#延迟问题" class="headerlink" title="延迟问题"></a>延迟问题</h4><ul><li><p>延迟的产生:</p><ul><li>当主库的TPS并发较高时，由于主库上面是多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的处理速度（生产者比消费者快，导致商品堆积）。</li></ul></li><li><p>延迟的解决:</p><ul><li>网络方面：将从库分布在相同局域网内或网络延迟较小的环境中。</li><li>硬件方面：从库配置更好的硬件，提升随机写的性能</li><li>配置方面：从库配置sync_binlog=0，innodb_flush_log_at_trx_commit=2，logs-slave-updates=0，增大innodb_buffer_pool_size，让更多操作在Mysql内存中完成，减少磁盘操作。或者升级Mysql5.7版本使用并行复制</li><li>架构方面：比如在事务当中尽量对主库读写，其他非事务中的读在从库。消除一部分延迟带来的数据库不一致。增加缓存降低一些从库的负载。</li></ul></li></ul><h3 id="发生死锁的原因以及如何解决（滴滴-顺丰）"><a href="#发生死锁的原因以及如何解决（滴滴-顺丰）" class="headerlink" title="发生死锁的原因以及如何解决（滴滴 顺丰）"></a>发生死锁的原因以及如何解决（滴滴 顺丰）</h3><h4 id="发生死锁的原因"><a href="#发生死锁的原因" class="headerlink" title="发生死锁的原因"></a>发生死锁的原因</h4><ol><li>互斥条件</li><li>不可剥夺条件(不可抢占)</li><li>部分分配</li><li>循环等待</li></ol><h4 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h4><ol><li>通过协议来预防或避免死锁，确保系统不会进入死锁状态。</li><li>可以允许系统进入死锁状态，然后检测它，并加以恢复。</li><li>可以忽视这个问题，认为死锁不可能在系统内发生</li></ol><ul><li><a href="http://c.biancheng.net/view/1236.html" target="_blank" rel="noopener">什么是死锁，死锁的原因及解决办法（含四个必要条件）</a></li></ul><h3 id="如何优化大-offset（陌陌）"><a href="#如何优化大-offset（陌陌）" class="headerlink" title="如何优化大 offset（陌陌）"></a>如何优化大 offset（陌陌）</h3><p>当offset特别大时，这条语句的执行效率会明显减低，而且效率是随着offset的增大而降低的。</p><p>MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，当offset特别大，然后单条数据也很大的时候，每次查询需要获取的数据就越多，自然就会很慢。</p><ul><li>解决方法<br>先获取主键列表，再通过主键查询目标数据，即使offset很大，也是获取了很多的主键，而不是所有的字段数据，相对而言效率会提升很多。</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select 需要的字段 </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    select &lt;a.<span class="built_in">id</span> 或 b.<span class="built_in">id</span>&gt; <span class="keyword">as</span> <span class="built_in">id</span></span><br><span class="line">    <span class="keyword">from</span> a join b <span class="keyword">on</span> a.<span class="built_in">id</span>=b.<span class="built_in">id</span></span><br><span class="line">    <span class="keyword">where</span> &lt;筛选条件&gt;</span><br><span class="line">    order <span class="keyword">by</span> &lt;一些字段&gt;</span><br><span class="line">    limit &lt;limit_param&gt; <span class="built_in">offset</span> &lt;offset_param&gt;</span><br><span class="line">) c join a <span class="keyword">on</span>  c.<span class="built_in">id</span>=a.<span class="built_in">id</span></span><br><span class="line">    join b <span class="keyword">on</span> c.<span class="built_in">id</span>=b.<span class="built_in">id</span></span><br><span class="line">    order <span class="keyword">by</span> &lt;一些字段&gt;</span><br></pre></td></tr></table></figure><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="缓存如何保证一致性（每家都问）"><a href="#缓存如何保证一致性（每家都问）" class="headerlink" title="缓存如何保证一致性（每家都问）"></a>缓存如何保证一致性（每家都问）</h3><ol><li>执行顺序的问题：先更新缓存还是先更新数据库？</li><li>更新缓存的策略问题：当缓存中的内容变化时，是选择修改缓存(update)，还是直接淘汰缓存(delete)？</li></ol><p><strong>针对这两点问题，一共可以分为四种方案：</strong></p><ol><li>先更新缓存，再更新数据库</li><li>先更新数据库，再更新缓存</li><li>先淘汰缓存，再更新数据库 (适用于对一致性要求高的业务)</li><li>先更新数据库，再淘汰缓存</li></ol><ul><li><a href="https://developer.aliyun.com/article/712285" target="_blank" rel="noopener">如何保证缓存(redis)与数据库(MySQL)的一致性</a></li></ul><h3 id="用过-redis-哪些数据结构，使用场景是什么（每家都问）"><a href="#用过-redis-哪些数据结构，使用场景是什么（每家都问）" class="headerlink" title="用过 redis 哪些数据结构，使用场景是什么（每家都问）"></a>用过 redis 哪些数据结构，使用场景是什么（每家都问）</h3><ul><li><code>string</code>(字符串): 常见的key-value存储</li><li><code>list</code>(列表): <ul><li>消息队列: <code>lpop</code>和<code>rpush</code>或者反过来，<code>lpush</code>和<code>rpop</code>）能实现队列的功能</li><li>朋友圈点赞列表, 评论列表, 排行榜</li></ul></li><li><code>hash</code>(字典): <ul><li>购物车: <code>hset [key] [field] [value]</code> 命令， 可以实现以用户Id，商品Id为field，商品数量为value，恰好构成了购物车的3个要素。</li><li>存储对象：hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。</li></ul></li><li><code>set</code>(集合): <ul><li>好友、关注、粉丝、感兴趣的人集合<br>1) <code>sinter</code>命令可以获得A和B两个用户的共同好友；<br>2) <code>sismember</code>命令可以判断A是否是B的好友；<br>3) <code>scard</code>命令可以获取好友数量；<br>4) 关注时，<code>smove</code>命令可以将B从A的粉丝集合转移到A的好友集合</li><li>首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个</li><li>存储某活动中中奖的用户ID ，因为有去重功能，可以保证同一个用户不会中奖两次。</li></ul></li><li><code>zset</code>(有序集合):<ul><li><code>zset</code> 可以用做排行榜，但是和list不同的是zset它能够实现动态的排序，例如： 可以用来存储粉丝列表，value 值是粉丝的用户 ID，score 是关注时间，我们可以对粉丝列表按关注时间进行排序。</li></ul></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/145384563" target="_blank" rel="noopener">Redis 5种数据结构 及使用场景分析</a></li></ul><h3 id="redis-的-connect-和-pconnect-的区别，pconnect-有什么问题（滴滴-陌陌）"><a href="#redis-的-connect-和-pconnect-的区别，pconnect-有什么问题（滴滴-陌陌）" class="headerlink" title="redis 的 connect 和 pconnect 的区别，pconnect 有什么问题（滴滴 陌陌）"></a>redis 的 connect 和 pconnect 的区别，pconnect 有什么问题（滴滴 陌陌）</h3><ul><li><code>connect</code>: 脚本结束之后连接就释放了</li><li><code>pconnect</code>: 脚本结束之后连接不释放，连接保持在php-fpm进程中</li></ul><p><strong>pconnect 有什么问题</strong></p><ol><li>当使用pconnect时，连接会被重用，连接的生命周期是fpm进程的生命周期，而非一次php的执行</li><li>如果代码中使用pconnect， close的作用仅是使当前php不能再进行redis请求，但无法真正关闭redis长连接，连接在后续请求中仍然会被重用，直至fpm进程生命周期结束。</li></ol><h3 id="redis-如何实现分布式锁，有什么问题（陌陌）"><a href="#redis-如何实现分布式锁，有什么问题（陌陌）" class="headerlink" title="redis 如何实现分布式锁，有什么问题（陌陌）"></a>redis 如何实现分布式锁，有什么问题（陌陌）</h3><p>利用 Redis 的 <code>SETNX</code> 命令，此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功。而基于 Redis 多机实现的分布式锁 <code>Redlock</code>，是 Redis 的作者 antirez 为了规范 Redis 分布式锁的实现，提出的一个更安全有效的实现机制</p><blockquote><p>不管是哪种实现方式，均需要实现加锁、解锁、锁超时这三个分布式锁的核心要素</p></blockquote><ul><li><a href="http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/" target="_blank" rel="noopener">深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了</a></li></ul><h3 id="redis-为什么用跳表实现有序集合？原理，用有序集合的场景（字节-滴滴）"><a href="#redis-为什么用跳表实现有序集合？原理，用有序集合的场景（字节-滴滴）" class="headerlink" title="redis 为什么用跳表实现有序集合？原理，用有序集合的场景（字节 滴滴）"></a>redis 为什么用跳表实现有序集合？原理，用有序集合的场景（字节 滴滴）</h3><ul><li><ol><li>按照区间来查找数据这个操作，红黑树的效率没有跳表高</li></ol></li><li><ol start="2"><li>跳表更容易代码实现</li></ol></li><li><ol start="3"><li>跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗</li></ol></li><li><p><a href="https://juejin.cn/post/6962735884844138533#heading-8" target="_blank" rel="noopener">Redis 选择用跳表来实现有序集合的原因</a></p></li></ul><h4 id="跳表数据结构"><a href="#跳表数据结构" class="headerlink" title="跳表数据结构"></a>跳表数据结构</h4><ul><li>跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现是基于“二分查找”的链表操作</li><li>跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)</li><li>跳表的空间复杂度是 O(n)，不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</li><li>虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</li></ul><h3 id="主从同步的原理，哨兵和集群的区别（滴滴）"><a href="#主从同步的原理，哨兵和集群的区别（滴滴）" class="headerlink" title="主从同步的原理，哨兵和集群的区别（滴滴）"></a>主从同步的原理，哨兵和集群的区别（滴滴）</h3><ul><li>主从复制: 读写分离，备份，一个Master可以有多个Slaves。</li><li>哨兵: 监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li><li>集群: 为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li></ul><blockquote><p>哨兵(sentinel)着眼于高可用; 集群(cluster)提高并发量</p></blockquote><ul><li><a href="https://juejin.cn/post/6844904097116585991" target="_blank" rel="noopener">一文掌握Redis主从复制、哨兵、Cluster三种集群模式</a></li></ul><h3 id="redis-cluster-用的什么协议同步数据，哨兵的选举呢（陌陌）"><a href="#redis-cluster-用的什么协议同步数据，哨兵的选举呢（陌陌）" class="headerlink" title="redis cluster 用的什么协议同步数据，哨兵的选举呢（陌陌）"></a>redis cluster 用的什么协议同步数据，哨兵的选举呢（陌陌）</h3><blockquote><p>Gossip协议 又称 epidemic 协议（epidemic protocol）</p></blockquote><h4 id="哨兵选举"><a href="#哨兵选举" class="headerlink" title="哨兵选举"></a>哨兵选举</h4><p>主节点被标记为 Fail 后，对应的从节点会发起投票，竞争升主。历经从节点拉票、主节点投票、投票裁决等环节，最终完成选举。</p><ol><li>从节点拉票</li><li>拉票优先级</li><li>主节点投票</li><li>根据投票结果决策</li><li>选举失败</li><li>选举算法 (选举新主节点的算法是基于 Raft 算法的 Leader Election 方法来实现的)</li></ol><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%AE%8C%EF%BC%89/04%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20Gossip%20%E5%92%8C%20Redis%20%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">分布式一致性协议 Gossip 和 Redis 集群原理解析</a></li></ul><h3 id="rdb-和-aof-的原理（滴滴-高德）"><a href="#rdb-和-aof-的原理（滴滴-高德）" class="headerlink" title="rdb 和 aof 的原理（滴滴 高德）"></a>rdb 和 aof 的原理（滴滴 高德）</h3><ul><li><code>RDB</code>: 生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dump.rdb</li><li><code>AOF</code>: 记录 Redis 除了查询以外的所有写命令，并在Redis 服务启动时，通过重新执行这些命令来还原数据。</li></ul><p><strong>区别</strong></p><ul><li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li><li>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式追加记录，可以打开文件看到详细的操作记录。</li></ul><ul><li><a href="https://segmentfault.com/a/1190000018388385" target="_blank" rel="noopener">RDB 和 AOF 持久化的原理是什么？我应该用哪一个？它们的优缺点？</a></li></ul><h3 id="数据过期和淘汰策略（滴滴-高德-字节）"><a href="#数据过期和淘汰策略（滴滴-高德-字节）" class="headerlink" title="数据过期和淘汰策略（滴滴 高德 字节）"></a>数据过期和淘汰策略（滴滴 高德 字节）</h3><h4 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h4><blockquote><p>Redis中主要使用 <strong>定期删除</strong> + <strong>惰性删除</strong> 两种数据过期清除策略</p></blockquote><ul><li>定期删除：redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果有过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。</li><li>惰性删除：定期删除可能导致很多过期的key 到了时间并没有被删除掉。这时就要使用到惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且过期了，是的话就删除。</li></ul><h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><blockquote><p>Redis共提供了8中缓存淘汰策略，其中 volatile-lfu 和 allkeys-lfu 是Redis 4.0版本新增的<br>通常情况下推荐优先使用 allkeys-lru 策略。</p></blockquote><ul><li><code>noeviction</code>: 不进行淘汰数据</li><li><code>volatile-ttl</code>: 在设置了过期时间的键值对中，移除即将过期的键值对</li><li><code>volatile-random</code>: 在设置了过期时间的键值对中，随机移除某个键值对</li><li><code>volatile-lru</code>: 在设置了过期时间的键值对中，移除最近最少使用的键值对</li><li><code>volatile-lfu</code>: 在设置了过期时间的键值对中，移除最近最不频繁使用的键值对</li><li><code>allkeys-random</code>: 在所有键值对中，随机移除某个key</li><li><code>allkeys-lru</code>: 在所有的键值对中，移除最近最少使用的键值对。</li><li><code>allkeys-lfu</code>: 在所有的键值对中，移除最近最不频繁使用的键值对</li></ul><ul><li><a href="https://blog.csdn.net/a745233700/article/details/85413179" target="_blank" rel="noopener">Redis的数据过期清除策略 与 内存淘汰策略</a></li></ul><h3 id="缓存雪崩-击穿-穿透（滴滴-陌陌）"><a href="#缓存雪崩-击穿-穿透（滴滴-陌陌）" class="headerlink" title="缓存雪崩 击穿 穿透（滴滴 陌陌）"></a>缓存雪崩 击穿 穿透（滴滴 陌陌）</h3><ul><li><a href="https://blog.caoxl.com/2019/08/29/Caching-Related-Issues-And-Solutions/">缓存 相关问题/解决方案</a></li></ul><h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><h3 id="深度分页会有什么问题（滴滴-百度-陌陌）"><a href="#深度分页会有什么问题（滴滴-百度-陌陌）" class="headerlink" title="深度分页会有什么问题（滴滴 百度 陌陌）"></a>深度分页会有什么问题（滴滴 百度 陌陌）</h3><p>深度分页问题大致可以分为两类</p><ul><li>随机深度分页: 随机跳转页面</li><li>滚动深度分页: 只能一页一页往下查询</li></ul><h4 id="from-size"><a href="#from-size" class="headerlink" title="from/size"></a>from/size</h4><p>es 目前支持最大的 skip 值是 max_result_window ，默认 为 10000 。也就是当 from + size &gt; max_result_window 时，es 将返回错误</p><h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4><p>使用scroll，每次只能获取一页的内容，然后会返回一个scrollid，根据scrollid可以不断地获取下一页的内容，所以scroll并不适用于有跳页的情景。但是在真正的使用场景中，第10000条数据已经是很后面的数据了，可以“折衷”一下，不提供跳转页面功能，只能下一页的翻页。</p><blockquote><p>Scroll方式通过一次查询请求后维护一个临时的索引快照的search context<br>此后的增删查改操作并不会影响这个快照数据信息，后续的查询只需要根据游标去取数据，直到结果集中返回的 hits 字段为空，就表示遍历结束。效率比较高。在5.x之后，还可以通过slice分片来实现并行导出。</p></blockquote><h4 id="search-after"><a href="#search-after" class="headerlink" title="search_after"></a>search_after</h4><p>searchAfter的方式通过维护一个实时游标来避免scroll的缺点，它可以用于实时请求和高并发场景。</p><p>它的缺点是不能够随机跳转分页，只能是一页一页的向后翻，并且需要至少指定一个唯一不重复字段来排序(注:每个文档具有一个唯一值的字段应该用作排序规范的仲裁器。否则，具有相同排序值的文档的排序顺序将是未定义的。建议的方法是使用字段_id，它肯定包含每个文档的一个唯一值)。</p><h3 id="倒排索引的原理（字节-高德）"><a href="#倒排索引的原理（字节-高德）" class="headerlink" title="倒排索引的原理（字节 高德）"></a>倒排索引的原理（字节 高德）</h3><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html#inverted-index" target="_blank" rel="noopener">倒排索引</a></li></ul><p>倒排索引由两个部分组成：单词词典和倒排文件。</p><ul><li>单词词典: 单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</li><li>倒排文件: 所有单词的倒排列表顺序的存储在磁盘的某个文件里，这个文件即被称为倒排文件，倒排文件是存储倒排索引的物理文件。</li></ul><h3 id="lsm-树原理（字节）"><a href="#lsm-树原理（字节）" class="headerlink" title="lsm 树原理（字节）"></a>lsm 树原理（字节）</h3><blockquote><p>LSM树（Log Structured Merge Tree，结构化合并树）的思想非常朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘（由此提升了写性能），是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销。</p></blockquote><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><h3 id="kafka-的架构，大致储存结构（高德-字节-滴滴）"><a href="#kafka-的架构，大致储存结构（高德-字节-滴滴）" class="headerlink" title="kafka 的架构，大致储存结构（高德 字节 滴滴）"></a>kafka 的架构，大致储存结构（高德 字节 滴滴）</h3><h3 id="如果消费者数超过分区数会怎么样？（顺丰-滴滴）"><a href="#如果消费者数超过分区数会怎么样？（顺丰-滴滴）" class="headerlink" title="如果消费者数超过分区数会怎么样？（顺丰 滴滴）"></a>如果消费者数超过分区数会怎么样？（顺丰 滴滴）</h3><h3 id="怎么保证数据的可靠投递？（陌陌-字节）"><a href="#怎么保证数据的可靠投递？（陌陌-字节）" class="headerlink" title="怎么保证数据的可靠投递？（陌陌 字节）"></a>怎么保证数据的可靠投递？（陌陌 字节）</h3><h3 id="消费者的-offset-存在哪里？（字节-腾讯-陌陌）"><a href="#消费者的-offset-存在哪里？（字节-腾讯-陌陌）" class="headerlink" title="消费者的 offset 存在哪里？（字节 腾讯 陌陌）"></a>消费者的 offset 存在哪里？（字节 腾讯 陌陌）</h3><h3 id="如何通过-offset-定位消息？（字节）"><a href="#如何通过-offset-定位消息？（字节）" class="headerlink" title="如何通过 offset 定位消息？（字节）"></a>如何通过 offset 定位消息？（字节）</h3><h3 id="时间轮的原理（陌陌-顺丰）"><a href="#时间轮的原理（陌陌-顺丰）" class="headerlink" title="时间轮的原理（陌陌 顺丰）"></a>时间轮的原理（陌陌 顺丰）</h3><h3 id="kafka-写入高性能的原因，sendfile-和-mmap-原理，为什么不用-splice（滴滴）"><a href="#kafka-写入高性能的原因，sendfile-和-mmap-原理，为什么不用-splice（滴滴）" class="headerlink" title="kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice（滴滴）"></a>kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice（滴滴）</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="https-原理，tls-握手需要几个-rtt？（滴滴-百度）"><a href="#https-原理，tls-握手需要几个-rtt？（滴滴-百度）" class="headerlink" title="https 原理，tls 握手需要几个 rtt？（滴滴 百度）"></a>https 原理，tls 握手需要几个 rtt？（滴滴 百度）</h3><blockquote><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。</p><ul><li><a href="https://juejin.cn/post/6844903830916694030" target="_blank" rel="noopener">深入理解HTTPS工作原理</a> </li></ul></blockquote><blockquote><p>SSL(Secure Socket Layer 安全套接字层) / TLS(Transport Layer Security 传输层安全协议)<br>RTT(Round Trip Time 往返时间)</p></blockquote><p>TLS 握手就需要消耗两个 RTT<br>在 TLS 1.2 中，我们需要 2-RTT 才能建立 TLS 连接10，但是 TLS 1.3 通过优化协议，将两次往返延迟降低至一次</p><ul><li><a href="https://draveness.me/whys-the-design-https-latency/" target="_blank" rel="noopener">为什么 HTTPS 需要 7 次握手以及 9 倍时延</a></li></ul><p>总结一下 HTTPS 协议需要 9 倍时延才能完成通信的原因：</p><ol><li>TCP 协议需要通过三次握手建立 TCP 连接保证通信的可靠性（1.5-RTT）</li><li>TLS 协议会在 TCP 协议之上通过四次握手建立 TLS 连接保证通信的安全性（2-RTT）</li><li>HTTP 协议会在 TCP 和 TLS 上通过一次往返发送请求并接收响应（1-RTT）</li></ol><h3 id="浏览器访问某个网址的详细过程，四次挥手（腾讯-滴滴）"><a href="#浏览器访问某个网址的详细过程，四次挥手（腾讯-滴滴）" class="headerlink" title="浏览器访问某个网址的详细过程，四次挥手（腾讯 滴滴）"></a>浏览器访问某个网址的详细过程，四次挥手（腾讯 滴滴）</h3><ol><li>获得域名所对应的IP地址，若DNS缓存中没有相关数据，则浏览器向DNS服务器发出DNS请求，以获取域名所对应的IP地址。</li><li>浏览器与域名地址建立TCP连接，三次握手</li><li>HTTP访问</li><li>断开TCP链接, 四次挥手</li></ol><h3 id="http2-和-quic-原理（字节）"><a href="#http2-和-quic-原理（字节）" class="headerlink" title="http2 和 quic 原理（字节）"></a>http2 和 quic 原理（字节）</h3><h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><ol><li>二进制分帧(Binary Format)</li><li>多路复用(Multiplexing)/连接共享</li><li>头部压缩(Header Compression)</li><li>压缩原理</li><li>请求优先级(Request Priorities)</li><li>服务端推送(Server Push)</li></ol><h4 id="Quic"><a href="#Quic" class="headerlink" title="Quic"></a>Quic</h4><blockquote><p>Quic (Quick Udp Internet Connection 快速UDP互联网连接)</p></blockquote><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势</p><ol><li>减少了 TCP 三次握手及 TLS 握手时间</li><li>改进的拥塞控制</li><li>避免队头阻塞的多路复用</li><li>连接迁移</li><li>前向冗余纠错</li></ol><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="分布式事务怎么处理（高德-陌陌）"><a href="#分布式事务怎么处理（高德-陌陌）" class="headerlink" title="分布式事务怎么处理（高德 陌陌）"></a>分布式事务怎么处理（高德 陌陌）</h3><h3 id="简述-raft-原理（陌陌）"><a href="#简述-raft-原理（陌陌）" class="headerlink" title="简述 raft 原理（陌陌）"></a>简述 raft 原理（陌陌）</h3><h3 id="分布式-id-的几种实现和优缺点（滴滴）"><a href="#分布式-id-的几种实现和优缺点（滴滴）" class="headerlink" title="分布式 id 的几种实现和优缺点（滴滴）"></a>分布式 id 的几种实现和优缺点（滴滴）</h3><h3 id="降级-限流-熔断实现原理（高德-陌陌）"><a href="#降级-限流-熔断实现原理（高德-陌陌）" class="headerlink" title="降级 限流 熔断实现原理（高德 陌陌）"></a>降级 限流 熔断实现原理（高德 陌陌）</h3><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计秒杀系统，需要支持-100W-以上-QPS（滴滴）"><a href="#设计秒杀系统，需要支持-100W-以上-QPS（滴滴）" class="headerlink" title="设计秒杀系统，需要支持 100W 以上 QPS（滴滴）"></a>设计秒杀系统，需要支持 100W 以上 QPS（滴滴）</h3><h3 id="设计微博首页，需要拉取所有关注用户的最近-20-条微博（百度）"><a href="#设计微博首页，需要拉取所有关注用户的最近-20-条微博（百度）" class="headerlink" title="设计微博首页，需要拉取所有关注用户的最近 20 条微博（百度）"></a>设计微博首页，需要拉取所有关注用户的最近 20 条微博（百度）</h3><h3 id="抢红包算法设计（百度-滴滴）"><a href="#抢红包算法设计（百度-滴滴）" class="headerlink" title="抢红包算法设计（百度 滴滴）"></a>抢红包算法设计（百度 滴滴）</h3><h3 id="设计一个短链系统（百度）"><a href="#设计一个短链系统（百度）" class="headerlink" title="设计一个短链系统（百度）"></a>设计一个短链系统（百度）</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="布隆过滤器的实现原理和使用场景（滴滴）"><a href="#布隆过滤器的实现原理和使用场景（滴滴）" class="headerlink" title="布隆过滤器的实现原理和使用场景（滴滴）"></a>布隆过滤器的实现原理和使用场景（滴滴）</h3><h3 id="进程间通信有哪几种方式（腾讯）"><a href="#进程间通信有哪几种方式（腾讯）" class="headerlink" title="进程间通信有哪几种方式（腾讯）"></a>进程间通信有哪几种方式（腾讯）</h3><h3 id="进程线程协程区别（滴滴-知乎）"><a href="#进程线程协程区别（滴滴-知乎）" class="headerlink" title="进程线程协程区别（滴滴 知乎）"></a>进程线程协程区别（滴滴 知乎）</h3><h3 id="lvs-原理，如何保证高可用（滴滴）"><a href="#lvs-原理，如何保证高可用（滴滴）" class="headerlink" title="lvs 原理，如何保证高可用（滴滴）"></a>lvs 原理，如何保证高可用（滴滴）</h3><h3 id="502-504-什么原因，如何处理（滴滴-百度-腾讯-顺丰）"><a href="#502-504-什么原因，如何处理（滴滴-百度-腾讯-顺丰）" class="headerlink" title="502 504 什么原因，如何处理（滴滴 百度 腾讯 顺丰）"></a>502 504 什么原因，如何处理（滴滴 百度 腾讯 顺丰）</h3><h3 id="给你两个一模一样的玻璃球，求出-100-层楼哪一层开始玻璃球会被摔碎（腾讯）"><a href="#给你两个一模一样的玻璃球，求出-100-层楼哪一层开始玻璃球会被摔碎（腾讯）" class="headerlink" title="给你两个一模一样的玻璃球，求出 100 层楼哪一层开始玻璃球会被摔碎（腾讯）"></a>给你两个一模一样的玻璃球，求出 100 层楼哪一层开始玻璃球会被摔碎（腾讯）</h3><h3 id="一致性-hash-原理，怎么解决节点少数据倾斜的问题（滴滴-陌陌）"><a href="#一致性-hash-原理，怎么解决节点少数据倾斜的问题（滴滴-陌陌）" class="headerlink" title="一致性 hash 原理，怎么解决节点少数据倾斜的问题（滴滴 陌陌）"></a>一致性 hash 原理，怎么解决节点少数据倾斜的问题（滴滴 陌陌）</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;面试造火箭 上班拧螺丝&lt;br&gt;“茴香豆的『回』字有几种写法你知道么”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 死信队列 延迟队列 惰性队列</title>
    <link href="http://blog.caoxl.com/2022/02/18/RabbitMQ-Learn-More-III/"/>
    <id>http://blog.caoxl.com/2022/02/18/RabbitMQ-Learn-More-III/</id>
    <published>2022-02-18T09:08:42.000Z</published>
    <updated>2022-02-18T09:41:21.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本篇是RabbitMQ 再深入III</p></blockquote><a id="more"></a><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><blockquote><p>死信队列: DLX, dead-letter-exchange</p></blockquote><h2 id="死信队列的产生"><a href="#死信队列的产生" class="headerlink" title="死信队列的产生"></a>死信队列的产生</h2><ol><li>消息被拒绝(<code>basic.reject</code> / <code>basic.nack</code>)，并且<code>requeue = false</code></li><li>消息TTL过期</li><li>队列达到最大长度</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">RabbitMQ</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">require_once</span> <span class="string">'../vendor/autoload.php'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">Exception</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Wire</span>\<span class="title">AMQPTable</span>;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Class RabbitMQ</span><br><span class="line"> * @package RabbitMQ</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">RabbitMQ</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line">    /**</span><br><span class="line">     * 生产延迟消息队列</span><br><span class="line">     * @param array $message_data</span><br><span class="line">     * @param int $ttl 单位: 秒</span><br><span class="line">     * @param int $max_delay_second 单位: 秒</span><br><span class="line">     * @param bool $need_time_suffix</span><br><span class="line">     * @throws Exception</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delayProduce</span><span class="params">(array $message_data, int $ttl, int $max_delay_second = <span class="number">0</span>, bool $need_time_suffix = false)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $connection = <span class="keyword">new</span> AMQPStreamConnection(<span class="string">'rabbitmq'</span>, <span class="number">5672</span>, <span class="string">'banana'</span>, <span class="string">'123456'</span>, <span class="string">'banana'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $channel = $connection-&gt;channel();</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $queue = <span class="string">'dead_letter_queue'</span>;</span></span><br><span class="line"><span class="php">        $exchange_name = <span class="string">'dead_letter_exchange'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $delay_table = <span class="keyword">new</span> AMQPTable();</span></span><br><span class="line"><span class="php">        <span class="comment">// 设置死信交换机</span></span></span><br><span class="line"><span class="php">        $delay_table-&gt;set(<span class="string">'x-dead-letter-exchange'</span>, <span class="string">"delay_$exchange_name"</span>);</span></span><br><span class="line"><span class="php">        <span class="comment">// 设置死信路由键</span></span></span><br><span class="line"><span class="php">        $delay_table-&gt;set(<span class="string">'x-dead-letter-routing-key'</span>, <span class="string">"delay_$queue"</span>);</span></span><br><span class="line"><span class="php">        <span class="comment">// 死信队列消息存活时间, 单位: 毫秒</span></span></span><br><span class="line"><span class="php">        $delay_table-&gt;set(<span class="string">'x-message-ttl'</span>, $max_delay_second * <span class="number">1000</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $suffix = $need_time_suffix ? <span class="string">"_&#123;$ttl&#125;"</span> : <span class="string">''</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">        <span class="comment">// 普通队列, 消息过期写入死信队列</span></span></span><br><span class="line"><span class="php">        $channel-&gt;queue_declare(<span class="string">"ttl_&#123;$queue&#125;&#123;$suffix&#125;"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, $delay_table);</span></span><br><span class="line"><span class="php">        <span class="comment">// 这里是ttl队列, 所以交换机这里要durable是false</span></span></span><br><span class="line"><span class="php">        $channel-&gt;exchange_declare(<span class="string">"ttl_&#123;$exchange_name&#125;&#123;$suffix&#125;"</span>, <span class="string">'direct'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">        $channel-&gt;queue_bind(<span class="string">"ttl_&#123;$queue&#125;&#123;$suffix&#125;"</span>,  <span class="string">"ttl_&#123;$exchange_name&#125;&#123;$suffix&#125;"</span>, <span class="string">"ttl_&#123;$queue&#125;&#123;$suffix&#125;"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        <span class="comment">// 死信队列, 正常消耗</span></span></span><br><span class="line"><span class="php">        $channel-&gt;queue_declare(<span class="string">"delay_$queue"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">        $channel-&gt;exchange_declare(<span class="string">"delay_&#123;$exchange_name&#125;"</span>, <span class="string">'direct'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">        $channel-&gt;queue_bind(<span class="string">"delay_&#123;$queue&#125;"</span>, <span class="string">"delay_&#123;$exchange_name&#125;"</span>, <span class="string">"delay_&#123;$queue&#125;"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        <span class="comment">// 消息过期时间</span></span></span><br><span class="line"><span class="php">        <span class="comment">// 1. 若消息在队列头: 消息过期时间与队列消息过期时间取最小值</span></span></span><br><span class="line"><span class="php">        <span class="comment">// 例如: x-message-ttl=30000, expiration=5000, 则5秒过期</span></span></span><br><span class="line"><span class="php">        <span class="comment">// 2. 若消息在队列中: 先消耗之前的消息,才能消耗,即使已过期也继续等待</span></span></span><br><span class="line"><span class="php">        <span class="comment">// 例如: x-message-ttl=30000 expiration: 消息1=25000 消息2=5000, 则两个消息均25秒过期</span></span></span><br><span class="line"><span class="php">        $message = <span class="keyword">new</span> AMQPMessage(</span></span><br><span class="line"><span class="php">            serialize($message_data),</span></span><br><span class="line"><span class="php">            [</span></span><br><span class="line"><span class="php">                <span class="string">'content_type'</span> =&gt; <span class="string">'text/plain'</span>,</span></span><br><span class="line"><span class="php">                <span class="string">'expiration'</span> =&gt; $ttl * <span class="number">1000</span>, <span class="comment">// 单位: 毫秒</span></span></span><br><span class="line"><span class="php">                <span class="string">'delivery_mode'</span> =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT</span></span><br><span class="line"><span class="php">            ]</span></span><br><span class="line"><span class="php">        );</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $channel-&gt;basic_publish($message, <span class="string">"ttl_&#123;$exchange_name&#125;&#123;$suffix&#125;"</span>, <span class="string">"ttl_&#123;$queue&#125;&#123;$suffix&#125;"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $channel-&gt;close();</span></span><br><span class="line"><span class="php">        $connection-&gt;close();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">$message_data = [<span class="string">'Test Dead Letter'</span>];</span></span><br><span class="line"><span class="php">$ttl = <span class="number">5</span>;</span></span><br><span class="line"><span class="php">$max_delay_second = <span class="number">30</span>;</span></span><br><span class="line"><span class="php">$need_time_suffix = <span class="keyword">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="php">    (<span class="keyword">new</span> RabbitMQ())-&gt;delayProduce($message_data, $ttl, $max_delay_second, $need_time_suffix);</span></span><br><span class="line"><span class="php">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">echo</span> <span class="string">"异常消息: "</span> . $e-&gt;getMessage();</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><p>使用DLX（死信交换机）+TTL（消息超时时间）实现</p><blockquote><p>假如一条消息需要延迟 30 分钟执行，我们就设置这条消息的有效期为 30 分钟，同时为这条消息配置死信交换机和死信 routing_key，并且不为这个消息队列设置消费者，那么 30 分钟后，这条消息由于没有被消费者消费而进入死信队列，此时我们有一个消费者就在“蹲点”这个死信队列，消息一进入死信队列，就立马被消费了。</p></blockquote><h1 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h1><blockquote><p>惰性队列会尽可能的将消息存入磁盘中，在消费者消费到相应的消息时才会被加载到内存中。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$table = new AMQPTable();</span><br><span class="line">$table-&gt;set('x-queue-mode', "lazy");</span><br><span class="line">$channel-&gt;queue_declare($queueName, false, true, false, false, false, $table);</span><br><span class="line">$channel-&gt;queue_bind($queueName, $exchangeName, $routingKey);</span><br></pre></td></tr></table></figure><ul><li><p>优点</p><ul><li><ol><li>它可以存储更多消息支持更长队列因为消息在硬盘中。</li></ol></li><li><ol start="2"><li>惰性队列可以避免消息堆积导致的内存崩溃。</li></ol></li></ul></li><li><p>缺点</p><ul><li><ol><li>需要i/o 增加磁盘i/o。</li></ol></li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://codeantenna.com/a/hleDRA33XX" target="_blank" rel="noopener">RabbitMQ 惰性队列</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇是RabbitMQ 再深入III&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.caoxl.com/tags/RabbitMQ/"/>
    
      <category term="死信队列" scheme="http://blog.caoxl.com/tags/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="延迟队列" scheme="http://blog.caoxl.com/tags/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    
      <category term="惰性队列" scheme="http://blog.caoxl.com/tags/%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>MySQL8 CTE和窗口函数的用法</title>
    <link href="http://blog.caoxl.com/2022/01/06/MySQL8-CTE-WF/"/>
    <id>http://blog.caoxl.com/2022/01/06/MySQL8-CTE-WF/</id>
    <published>2022-01-06T02:00:34.000Z</published>
    <updated>2022-05-12T01:37:45.189Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>普通统计函数在每个分组内只能返回一条记录。而新增加的窗口函数和CTE函数可以一个分组返回多条函数。</p></blockquote><a id="more"></a><h1 id="窗口函数-amp-CTE实操"><a href="#窗口函数-amp-CTE实操" class="headerlink" title="窗口函数&amp;CTE实操"></a>窗口函数&amp;CTE实操</h1><ul><li>一张表结构如下</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc mytest;</span><br><span class="line">+--------+------------------+------+-----+---------+----------------+</span><br><span class="line">| Field  | Type             | Null | Key | Default | Extra          |</span><br><span class="line">+--------+------------------+------+-----+---------+----------------+</span><br><span class="line">| id     | int(11) unsigned | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name   | varchar(255)     | NO   |     | NULL    |                |</span><br><span class="line">| course | varchar(255)     | NO   |     | NULL    |                |</span><br><span class="line">| score  | decimal(10,0)    | NO   |     | NULL    |                |</span><br><span class="line">+--------+------------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><ul><li>它有以下数据</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from mytest;</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">| id | name   | course | score |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">|  1 | 汤姆 | 数学 | 100   |</span><br><span class="line">|  2 | 汤姆 | 语文 | 90    |</span><br><span class="line">|  3 | 汤姆 | 英语 | 80    |</span><br><span class="line">|  4 | 汤姆 | 化学 | 100   |</span><br><span class="line">|  5 | 汤姆 | 物理 | 99    |</span><br><span class="line">|  6 | 杰克 | 数学 | 90    |</span><br><span class="line">|  7 | 杰克 | 语文 | 100   |</span><br><span class="line">|  8 | 杰克 | 英语 | 80    |</span><br><span class="line">|  9 | 杰克 | 化学 | 90    |</span><br><span class="line">| 10 | 杰克 | 物理 | 70    |</span><br><span class="line">| 11 | 可可 | 数学 | 90    |</span><br><span class="line">| 12 | 可可 | 语文 | 92    |</span><br><span class="line">| 13 | 可可 | 英语 | 93    |</span><br><span class="line">| 14 | 可可 | 化学 | 94    |</span><br><span class="line">| 15 | 可可 | 物理 | 75    |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">15 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>问题: 要查询出每一科最高分学生的学号，姓名，成绩和科目。在MySQL8之前主要是通过下面的方式来实现。</p><p>答案1: MySql 8之前的方法</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   SELECT x.id,x.NAME,x.course,x.score FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line"><span class="code">t.*,</span></span><br><span class="line">IF</span><br><span class="line"><span class="code">( @_course = t.course, @rn := @rn + 1, @rn := 1 ) AS rn,</span></span><br><span class="line"><span class="code">@_course := t.course AS _course </span></span><br><span class="line">FROM</span><br><span class="line"><span class="code">( SELECT t.* FROM mytest t ORDER BY course, score DESC ) t,</span></span><br><span class="line"><span class="code">( SELECT @rn := 0 rn, @_course := '' ) b </span></span><br><span class="line">) x </span><br><span class="line">   WHERE rn = 1 ORDER BY course;</span><br><span class="line">   </span><br><span class="line">   +----+--------+--------+-------+</span><br><span class="line">   | id | NAME   | course | score |</span><br><span class="line">   +----+--------+--------+-------+</span><br><span class="line">   |  4 | 汤姆   | 化学   |   100 |</span><br><span class="line">   |  1 | 汤姆   | 数学   |   100 |</span><br><span class="line">   |  5 | 汤姆   | 物理   |    99 |</span><br><span class="line">   | 13 | 可可   | 英语   |    93 |</span><br><span class="line">   |  7 | 杰克   | 语文   |   100 |</span><br><span class="line">   +----+--------+--------+-------+</span><br><span class="line">   5 rows in set, 5 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>这个sql虽然高效，但是可读性不强。接下来我们来看看窗口函数怎么实现</p><p>答案2: 使用窗口函数ROW_NUMBER</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line"> id,name,course,score </span><br><span class="line">FROM</span><br><span class="line"><span class="code">    ( SELECT *,row_number() over ( PARTITION BY course ORDER BY score DESC ) AS rn FROM mytest ) t </span></span><br><span class="line">WHERE</span><br><span class="line"><span class="code">    rn = 1;</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">| id | name   | course | score |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">|  4 | 汤姆   | 化学   |   100 |</span><br><span class="line">|  1 | 汤姆   | 数学   |   100 |</span><br><span class="line">|  5 | 汤姆   | 物理   |    99 |</span><br><span class="line">| 13 | 可可   | 英语   |    93 |</span><br><span class="line">|  7 | 杰克   | 语文   |   100 |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>答案3: 使用CTE方式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WITH cte AS ( SELECT *,row_number() over ( PARTITION BY course ORDER BY score DESC ) AS rn FROM mytest ) </span><br><span class="line">SELECT id,name,course,score FROM cte WHERE rn = 1;</span><br><span class="line"></span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">| id | name   | course | score |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">|  4 | 汤姆   | 化学   |   100 |</span><br><span class="line">|  1 | 汤姆   | 数学   |   100 |</span><br><span class="line">|  5 | 汤姆   | 物理   |    99 |</span><br><span class="line">| 13 | 可可   | 英语   |    93 |</span><br><span class="line">|  7 | 杰克   | 语文   |   100 |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>通过对比上面的三种答案，发现CTE和窗口函数极大简化了我们的sql语句。我们的sql更容易读懂。</p><h1 id="通用表表达式（Common-Table-Expressions）"><a href="#通用表表达式（Common-Table-Expressions）" class="headerlink" title="通用表表达式（Common Table Expressions）"></a>通用表表达式（Common Table Expressions）</h1><p>复杂的查询会使用嵌入式表，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   SELECT t1.<span class="emphasis">*,t2.*</span> FROM</span><br><span class="line">( SELECT col1 FROM table1 ) t1,</span><br><span class="line">( SELECT col2 FROM table2 ) t2;</span><br></pre></td></tr></table></figure><p>而有了 CTE，我们可以这样写：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WITH</span><br><span class="line">t1 AS (SELECT col1 FROM table1),</span><br><span class="line">t2 AS (SELECT col2 FROM table2)</span><br><span class="line">SELECT t1.<span class="emphasis">*, t2.*</span> FROM t1, t2;</span><br></pre></td></tr></table></figure><p>这样看上去层次和区域都更加分明，改起来也更清晰的知道要改哪一部分。</p><h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><h2 id="什么是窗口函数"><a href="#什么是窗口函数" class="headerlink" title="什么是窗口函数"></a>什么是窗口函数</h2><p>窗口函数引入的其实不只是几个函数，而是一套完整的语法，窗口函数是此语法中的一部分。</p><blockquote><p>窗口函数 over 窗口表达式。</p></blockquote><p>over是窗口函数语法的关键字。</p><h2 id="窗口函数-1"><a href="#窗口函数-1" class="headerlink" title="窗口函数"></a>窗口函数</h2><ul><li><ol><li>序号函数: <code>row_number()</code>, <code>rank()</code>, <code>dense_rank()</code></li></ol></li><li><ol start="2"><li>分布函数: <code>percent_rank()</code>, <code>cume_dist()</code></li></ol></li><li><ol start="3"><li>前后函数: <code>lead()</code>, <code>lag()</code></li></ol></li><li><ol start="4"><li>头尾函数: <code>fist_val()</code>, <code>last_val()</code></li></ol></li><li><ol start="5"><li>其他函数: <code>nth_value()</code>, <code>nfile()</code></li></ol></li></ul><h3 id="窗口函数的两种写法"><a href="#窗口函数的两种写法" class="headerlink" title="窗口函数的两种写法"></a>窗口函数的两种写法</h3><ol><li>over关键词后直接定义窗口</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">  row<span class="emphasis">_number() over (partition by user_</span>no order by amount desc),</span><br><span class="line">  order_id</span><br><span class="line">from order_tab;</span><br></pre></td></tr></table></figure><ol start="2"><li>over关键字后使用窗口别名：</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line"><span class="code">    row_number() over w,</span></span><br><span class="line"><span class="code">    order_id</span></span><br><span class="line">from order_tab</span><br><span class="line">WINDOW w AS (partition by user_no order by amount desc);</span><br></pre></td></tr></table></figure><h2 id="窗口表达式语法"><a href="#窗口表达式语法" class="headerlink" title="窗口表达式语法"></a>窗口表达式语法</h2><h3 id="PARTITION-BY子句"><a href="#PARTITION-BY子句" class="headerlink" title="PARTITION BY子句"></a>PARTITION BY子句</h3><p>PARTITION BY子句是用来分组的，从字面上来看，应该叫分区。理解上可以类比group by。</p><p>某行记录所在的分区就是这行对应的窗口。一个窗口可以包含多行，就像group by分的组一样。</p><blockquote><p>PARTITION BY &lt;<code>expression</code>&gt;[{,&lt;<code>expression</code>&gt;…}]</p></blockquote><p>其中的<code>expression</code>表达式，可以是列名，也可以是某个计算结果。如果是列名，就代表简单的按照列的值分区。<br>可以支持按照多个表达式或列来分区。<br>根据每行记录的值，可以确定每行属于哪个分区，也就是哪个窗口。</p><h3 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h3><p>order by子句是排序用的，决定了属于同一个窗口的行记录的排序方式。语法很简单：</p><blockquote><p>ORDER BY &lt;<code>expression</code>&gt; [ASC|DESC] [{,&lt;<code>expression</code>&gt;…}]</p></blockquote><p>和MySQL中原有的order by关键字意思差不多。原有的order by关键字是所有查询结果一起排序，窗口函数的order by子句是对某个窗口中的行记录进行排序。</p><h3 id="frame子句"><a href="#frame子句" class="headerlink" title="frame子句"></a>frame子句</h3><p>frame子句定义了窗口中的一个子窗口，子集。这个稍微麻烦点，语法是：</p><blockquote><p>frame_unit {&lt;<code>frame_start</code>&gt;|&lt;<code>frame_between</code>&gt;}</p></blockquote><ul><li><code>frame_unit</code>有两种选择，<strong>ROWS</strong>和<strong>RANGE</strong>，ROWS代表按起止位置标识子集，RANGE代表按起止值标识子集。</li><li><code>frame_start</code>标识子窗口的开始位置，结束位置默认是当前行。</li><li><code>frame_between</code>是用BETWEEN AND关键字来标识子窗口的起止位置。</li></ul><h2 id="窗口函数介绍"><a href="#窗口函数介绍" class="headerlink" title="窗口函数介绍"></a>窗口函数介绍</h2><h3 id="序号函数-row-number-rank-dense-rank"><a href="#序号函数-row-number-rank-dense-rank" class="headerlink" title="序号函数: row_number(), rank(), dense_rank()"></a>序号函数: <code>row_number()</code>, <code>rank()</code>, <code>dense_rank()</code></h3><blockquote><p>序号函数的作用是显示分区中每行的行号。</p></blockquote><ul><li><code>row_number()</code>：排序字段相同时，行号随机排，下一行行号正常加1。显然此函数得到的行号是连续的。</li><li><code>rank()</code>：排序字段相同时，行号相同，下一行行号按照排名确定。这个逻辑比较像是现实中的排名规则，当出现并列冠军时，第三个人排名第三，没有亚军。显然此函数得到的行号是不连续的。</li><li><code>dense_rank()</code>：排序字段相同时，行号相同，下一行行号顺序加1。也就是出现冠军时，第三个人排名是第二。显然此函数得到的行号是连续的。</li></ul><h3 id="分布函数-percent-rank-cume-dist"><a href="#分布函数-percent-rank-cume-dist" class="headerlink" title="分布函数: percent_rank(), cume_dist()"></a>分布函数: <code>percent_rank()</code>, <code>cume_dist()</code></h3><blockquote><p>分布函数得到的是一个百分比，计算公式用到rank()函数。</p></blockquote><ul><li><code>percent_rank()</code>: 实际计算公式：(rank()-1)/(rows-1)</li><li><code>cume_dist()</code>: 实际计算公式：rank()/rows</li></ul><h3 id="前后函数-lead-lag"><a href="#前后函数-lead-lag" class="headerlink" title="前后函数: lead(), lag()"></a>前后函数: <code>lead()</code>, <code>lag()</code></h3><ul><li><code>lead(expr,n)</code>: 代表当前行前面第n行记录的expr表达式（或字段值）。</li><li><code>lag(expr,n)</code>: 代表当前行后面的第n行记录的expr表达式（或字段值）。</li></ul><p>比如lead(add_time,1)就代表当前行前面一行的add_time字段。</p><h3 id="头尾函数-fist-val-last-val"><a href="#头尾函数-fist-val-last-val" class="headerlink" title="头尾函数: fist_val(), last_val()"></a>头尾函数: <code>fist_val()</code>, <code>last_val()</code></h3><ul><li><code>first_val(expr)</code>: 代表分区第一行记录的expr表达式（或字段值）。</li><li><code>last_val(expr)</code>: 代表分区最后一行记录的expr表达式（或字段值）。</li></ul><h3 id="其他函数-nth-value-nfile"><a href="#其他函数-nth-value-nfile" class="headerlink" title="其他函数: nth_value(), nfile()"></a>其他函数: <code>nth_value()</code>, <code>nfile()</code></h3><ul><li><code>nth_value(expr,n)</code>: 代表区间第n条记录的expr表达式（或字段值）。<br>比如：nth_value(amount,2)代表区间第二行的amount字段。</li><li><code>nfile(n)</code>: 代表把区间列分为n个组，返回组号。  </li></ul><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><ul><li><a href="https://mysql.bookhub.zone/#/README" target="_blank" rel="noopener">MySQL 8.0 中文手册</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/with.html" target="_blank" rel="noopener">MySQL8 WITH (Common Table Expressions)</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html" target="_blank" rel="noopener">MySQL8 窗口函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;普通统计函数在每个分组内只能返回一条记录。而新增加的窗口函数和CTE函数可以一个分组返回多条函数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.caoxl.com/categories/MySQL/"/>
    
    
      <category term="MySQL8" scheme="http://blog.caoxl.com/tags/MySQL8/"/>
    
      <category term="CTE" scheme="http://blog.caoxl.com/tags/CTE/"/>
    
      <category term="窗口函数" scheme="http://blog.caoxl.com/tags/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存那点破事</title>
    <link href="http://blog.caoxl.com/2021/12/24/Redis-Something/"/>
    <id>http://blog.caoxl.com/2021/12/24/Redis-Something/</id>
    <published>2021-12-24T08:51:06.000Z</published>
    <updated>2021-12-24T09:58:25.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载, 原文地址<a href="https://blog.csdn.net/itomge/article/details/122118060" target="_blank" rel="noopener">Redis缓存那点破事 ， 绝杀面试官 25 问</a></p></blockquote><a id="more"></a><h2 id="Redis-有哪些特性？"><a href="#Redis-有哪些特性？" class="headerlink" title="Redis 有哪些特性？"></a>Redis 有哪些特性？</h2><ul><li>性能高， 读的速度是100000次/s，写的速度是80000次/s</li><li>数据持久化，支持RDB 、AOF</li><li>支持事务。通过<code>MULTI</code>和<code>EXEC</code>指令包起来。</li><li>多种数据结构类型</li><li>主从复制</li><li>其他特性：发布/订阅、通知、key过期等</li></ul><h2 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h2><ul><li>完全基于内存，没有磁盘IO上的开销，异步持久化除外</li><li>单线程，避免多个线程切换的性能损耗</li><li>非阻塞的IO多路复用机制</li><li>底层的数据存储结构优化，使用原生的数据结构提升性能。</li></ul><h2 id="Redis-底层的基础数据结构有哪些？"><a href="#Redis-底层的基础数据结构有哪些？" class="headerlink" title="Redis 底层的基础数据结构有哪些？"></a>Redis 底层的基础数据结构有哪些？</h2><ul><li>字符串。没有采用C语言的传统字符串，而是自己实现的一个简单动态字符串SDS的抽象类型，并保存了长度信息。</li><li>链表（linkedlist）。双向无环链表结构，每个链表的节点由一个listNode结构来表示，每个节点都有前置和后置节点的指针</li><li>字典（hashtable）。保存键值对的抽象数据结构，底层使用hash表，每个字典带有两个hash表，供平时使用和rehash时使用。</li><li>跳跃表（skiplist）。跳跃表是有序集合的底层实现之一。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表 信息(表头、表尾节点、⻓度等)，zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1- 32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。</li><li>整数集合（intset）。用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</li><li>压缩列表（ziplist）。为节约内存而开发的顺序性数据结构，可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li></ul><h2 id="Redis-支持哪些数据类型？"><a href="#Redis-支持哪些数据类型？" class="headerlink" title="Redis 支持哪些数据类型？"></a>Redis 支持哪些数据类型？</h2><p>五种常用数据类型：<code>String</code>、<code>Hash</code>、<code>Set</code>、<code>List</code>、<code>SortedSet</code>。三种特殊的数据类型：<code>Bitmap</code>、<code>HyperLogLog</code>、<code>Geospatial</code>，其中<code>Bitmap</code>、<code>HyperLogLog</code>的底层都是 <code>String</code> 数据类型，<code>Geospatial</code> 底层是 <code>Sorted Set</code> 数据类型。</p><ul><li>字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：ziplist、linkedlist</li><li>哈希对象hash：ziplist、hashtable</li><li>集合对象set：intset、hashtable</li><li>有序集合对象zset：ziplist、skiplist</li></ul><h2 id="Redis-常用的-5-种数据结构和应用场景？"><a href="#Redis-常用的-5-种数据结构和应用场景？" class="headerlink" title="Redis 常用的 5 种数据结构和应用场景？"></a>Redis 常用的 5 种数据结构和应用场景？</h2><ul><li><code>String</code>：缓存、计数器、分布式锁等</li><li><code>List</code>：链表、队列、微博关注人时间轴列表等</li><li><code>List</code>：链表、队列、微博关注人时间轴列表等</li><li><code>Set</code>：去重、赞、踩、共同好友等</li><li><code>Zset</code>：访问量排行榜、点击量排行榜等</li></ul><h2 id="为什么采用单线程？"><a href="#为什么采用单线程？" class="headerlink" title="为什么采用单线程？"></a>为什么采用单线程？</h2><p>官方回复，CPU不会成为Redis的制约瓶颈，Redis主要受内存、网络限制。例如，在一个普通的 Linux 系统上，使用pipelining 可以每秒传递 100 万个请求，所以如果您的应用程序主要使用 O(N) 或 O(log(N)) 命令，则几乎不会使用太多 CPU，属于IO密集型系统。</p><h2 id="Redis-6-0-之后又改用多线程呢"><a href="#Redis-6-0-之后又改用多线程呢" class="headerlink" title="Redis 6.0 之后又改用多线程呢?"></a>Redis 6.0 之后又改用多线程呢?</h2><p>Redis的多线程主要是处理数据的读写、协议解析。执行命令还是采用单线程顺序执行。</p><p>主要是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程进行一些周边预处理，提升了IO的读写效率，从而提高了整体的吞吐量。antirez 在 RedisConf 2019 分享时提到，Redis 6 引入的多线程 IO 对性能提升至少一倍以上。</p><h2 id="过期键Key-的删除策略有哪些？"><a href="#过期键Key-的删除策略有哪些？" class="headerlink" title="过期键Key 的删除策略有哪些？"></a>过期键Key 的删除策略有哪些？</h2><p>有3种过期删除策略。惰性删除、定期删除、定时删除</p><ul><li><code>惰性删除</code>。使用key时才进行检查，如果已经过期，则删除。缺点：过期的key如果没有被访问到，一直无法删除，一直占用内存，造成空间浪费。</li><li><code>定期删除</code>。每隔一段时间做一次检查，删除过期的key，每次只是随机取一些key去检查。</li><li><code>定时删除</code>。为每个key设置过期时间，同时创建一个定时器。一旦到期，立即执行删除。缺点：如果过期键比较多时，占用CPU较多，对服务的性能有很大影响。</li></ul><h2 id="如果Redis的内存空间不足，淘汰机制"><a href="#如果Redis的内存空间不足，淘汰机制" class="headerlink" title="如果Redis的内存空间不足，淘汰机制?"></a>如果Redis的内存空间不足，淘汰机制?</h2><ul><li><code>volatile-lru</code>：从已设置过期时间的key中，移出最近最少使用的key进行淘汰</li><li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li><code>volatile-ttl</code>：从已设置过期时间的key中，移出将要过期的key</li><li><code>volatile-random</code>：从已设置过期时间的key中，随机选择key淘汰</li><li><code>allkeys-random</code>：从key中随机选择key进行淘汰</li><li><code>no-eviction</code>：禁止淘汰数据。当内存达到阈值的时候，新写入操作报错</li><li><code>volatile-lfu</code>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰(LFU(Least Frequently Used)算法，也就是最频繁被访问的数据将来最有可能被访问到)</li><li><code>allkeys-lfu</code>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。</li></ul><h2 id="Redis-突然挂了怎么解决？"><a href="#Redis-突然挂了怎么解决？" class="headerlink" title="Redis 突然挂了怎么解决？"></a>Redis 突然挂了怎么解决？</h2><ul><li>从系统可用性角度思考，Redis Cluster引入主备机制，当主节点挂了后，自动切换到备用节点，继续提供服务</li><li>Client端引入本地缓存，通过开关切换，避免Redis突然挂掉，高并发流量把数据库打挂。</li></ul><h2 id="Redis-持久化有哪些方式？"><a href="#Redis-持久化有哪些方式？" class="headerlink" title="Redis 持久化有哪些方式？"></a>Redis 持久化有哪些方式？</h2><ul><li>快照<code>RDB</code>。将某个时间点上的数据库状态保存到<code>RDB</code>文件中，<code>RDB</code>文件是一个压缩的二进制文件，保存在磁盘上。当Redis崩溃时，可用于恢复数据。通过<code>SAVE</code>或<code>BGSAVE</code>来生成<code>RDB</code>文件。<ul><li><code>SAVE</code>：会阻塞redis进程，直到RDB文件创建完毕，在进程阻塞期间，redis不能处理任何命令请求。</li><li><code>BGSAVE</code>：会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。</li></ul></li><li>只追加文件<code>AOF</code>。以日志的形式记录每个写操作（非读操作）。当不同节点同步数据时，读取日志文件的内容将写指令从前到后执行一次，即可完成数据恢复。</li></ul><h2 id="Redis-常用场景"><a href="#Redis-常用场景" class="headerlink" title="Redis 常用场景"></a>Redis 常用场景</h2><ul><li>1、缓存，有句话说的好，「性能不够，缓存来凑」</li><li>2、分布式锁，利用Redis 的 <code>setnx</code></li><li>3、分布式session</li><li>4、计数器，通过incr命令</li><li>5、排行榜，Redis 的 有序集合</li><li>6、其他</li></ul><h2 id="Redis-缓存要注意的七大经典问题？"><a href="#Redis-缓存要注意的七大经典问题？" class="headerlink" title="Redis 缓存要注意的七大经典问题？"></a>Redis 缓存要注意的七大经典问题？</h2><p>列举了亿级系统，高访问量情况下Redis缓存可能会遇到哪些问题？以及对应的解决方案。</p><ul><li>1、缓存集中失效</li><li>2、缓存穿透</li><li>3、缓存雪崩</li><li>4、缓存热点</li><li>5、缓存大Key</li><li>6、缓存数据的一致性</li><li>7、数据并发竞争预热</li></ul><h2 id="Redis-集群方案有哪几种？"><a href="#Redis-集群方案有哪几种？" class="headerlink" title="Redis 集群方案有哪几种？"></a>Redis 集群方案有哪几种？</h2><ul><li>主从复制模式</li><li>Sentinel（哨兵）模式</li><li>Redis Cluster模式</li></ul><h2 id="Redis-主从数据同步（主从复制）的过程？"><a href="#Redis-主从数据同步（主从复制）的过程？" class="headerlink" title="Redis 主从数据同步（主从复制）的过程？"></a>Redis 主从数据同步（主从复制）的过程？</h2><ul><li>1、slave启动后，向master发送sync命令</li><li>2、master收到sync之后，执行bgsave保存快照，生成RDB全量文件</li><li>3、master把slave的写命令记录到缓存</li><li>4、bgsave执行完毕之后，发送RDB文件到slave，slave执行</li><li>5、master发送缓冲区的写命令给slave，slave接收命令并执行，完成复制初始化。</li><li>6、此后，master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性</li></ul><h2 id="主从复制的优缺点？"><a href="#主从复制的优缺点？" class="headerlink" title="主从复制的优缺点？"></a>主从复制的优缺点？</h2><ul><li>优点:<ul><li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li><li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li></ul></li><li>缺点:<ul><li>不具备自动容错与恢复功能，master 节点宕机后，需要手动指定新的 master</li><li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li><li>难以支持在线扩容，Redis的容量受限于单机配置</li></ul></li></ul><h2 id="Sentinel（哨兵）模式的优缺点？"><a href="#Sentinel（哨兵）模式的优缺点？" class="headerlink" title="Sentinel（哨兵）模式的优缺点？"></a>Sentinel（哨兵）模式的优缺点？</h2><p>哨兵模式基于主从复制模式，增加了<strong>哨兵来监控</strong>与<strong>自动处理故障</strong>。</p><ul><li>优点:<ul><li>哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有</li><li>master 挂掉可以自动进行切换，系统可用性更高</li></ul></li><li>缺点:<ul><li>Redis的容量受限于单机配置</li><li>需要额外的资源来启动sentinel进程</li></ul></li></ul><h2 id="Redis-Cluster-模式的优缺点？"><a href="#Redis-Cluster-模式的优缺点？" class="headerlink" title="Redis Cluster 模式的优缺点？"></a>Redis Cluster 模式的优缺点？</h2><p>实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。</p><ul><li>优点:<ul><li>无中心架构，数据按照slot分布在多个节点</li><li>集群中的每个节点都是平等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li><li>可线性扩展到1000多个节点，节点可动态添加或删除</li><li>能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换</li></ul></li><li>缺点<ul><li>数据通过异步复制，不保证数据的强一致性</li><li>slave充当 “冷备”，不对外提供读、写服务，只作为故障转移使用。</li><li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好</li><li>key事务操作支持有限，只支持多key在同一节点的事务操作，多key分布在不同节点时无法使用事务功能</li><li>不支持多数据库空间，一台redis可以支持16个db，集群模式下只能使用一个，即db 0。Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</li></ul></li></ul><h2 id="Redis-如何做扩容？"><a href="#Redis-如何做扩容？" class="headerlink" title="Redis 如何做扩容？"></a>Redis 如何做扩容？</h2><p>为了避免数据迁移失效，通常使用一致性哈希实现动态扩容缩容，有效减少需要迁移的Key数量。</p><p>但是Cluster 模式，采用固定Slot槽位方式（16384个），对每个key计算CRC16值，然后对16384取模，然后根据slot值找到目标机器，扩容时，我们只需要迁移一部分的slot到新节点即可。</p><h2 id="Redis-的集群原理"><a href="#Redis-的集群原理" class="headerlink" title="Redis 的集群原理?"></a>Redis 的集群原理?</h2><p>一个redis集群由多个节点<code>node</code>组成，而多个<code>node</code>之间通过<code>cluster meet</code>命令来进行连接，组成一个集群。</p><p>数据存储通过分片的形式，整个集群分成了<code>16384</code>个slot，每个节点负责一部分槽位。整个槽位的信息会同步到所有节点中。</p><p>key与slot的映射关系：</p><ul><li>健值对 key，进行 <code>CRC16</code> 计算，计算出一个 16 bit 的值</li><li>将 16 bit 的值对 16384 取模，得到 0 ～ 16383 的数表示 key 对应的哈希槽</li></ul><h2 id="Redis-如何做到高可用？"><a href="#Redis-如何做到高可用？" class="headerlink" title="Redis 如何做到高可用？"></a>Redis 如何做到高可用？</h2><p>哨兵机制。具有自动故障转移、集群监控、消息通知等功能。</p><p>哨兵可以同时监视所有的主、从服务器，当某个master下线时，自动提升对应的slave为master，然后由新master对外提供服务。</p><h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>Redis事务是一组命令的集合，将多个命令打包，然后把这些命令按顺序添加到队列中，并且按顺序执行这些命令。</p><p>Redis事务中没有像Mysql关系型数据库事务隔离级别的概念，不能保证原子性操作，也没有像Mysql那样执行事务失败会进行回滚操作</p><h2 id="Redis-事务执行流程？"><a href="#Redis-事务执行流程？" class="headerlink" title="Redis 事务执行流程？"></a>Redis 事务执行流程？</h2><p>通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。</p><p>具体过程：</p><ul><li>服务端收到客户端请求，事务以<code>MULTI</code>开始</li><li>如果正处于事务状态时，则会把后续命令放入队列同时返回给客户端<code>QUEUED</code>，反之则直接执行这 个命令</li><li>当收到客户端的<code>EXEC</code>命令时，才会将队列里的命令取出、顺序执行，执行完将当前状态从事务状态改为非事务状态</li><li>如果收到 <code>DISCARD</code> 命令，放弃执行队列中的命令，可以理解为Mysql的回滚操作，并且将当前的状态从事务状态改为非事务状态</li></ul><h2 id="如何实现一个分布式锁？"><a href="#如何实现一个分布式锁？" class="headerlink" title="如何实现一个分布式锁？"></a>如何实现一个分布式锁？</h2><ul><li>1、数据库表，性能比较差</li><li>2、使用Lua脚本 (包含 SETNX + EXPIRE 两条指令)</li><li>3、SET的扩展命令（SET key value [EX][PX] [NX|XX]）</li><li>4、Redlock 框架</li><li>5、Zookeeper Curator框架提供了现成的分布式锁</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载, 原文地址&lt;a href=&quot;https://blog.csdn.net/itomge/article/details/122118060&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis缓存那点破事 ， 绝杀面试官 25 问&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.caoxl.com/tags/PHP/"/>
    
      <category term="Redis" scheme="http://blog.caoxl.com/tags/Redis/"/>
    
      <category term="缓存" scheme="http://blog.caoxl.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 再深入 II</title>
    <link href="http://blog.caoxl.com/2021/07/07/RabbitMQ-Learn-More-II/"/>
    <id>http://blog.caoxl.com/2021/07/07/RabbitMQ-Learn-More-II/</id>
    <published>2021-07-07T02:00:57.000Z</published>
    <updated>2021-07-07T07:42:04.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>之前有多篇RabbitMQ的学习, 实践是检验真理的唯一标准, 所以本篇是实践篇<br><a href="https://blog.caoxl.com/2019/08/07/Message-Queue-RabbitMQ/">消息队列之 RabbitMQ</a><br><a href="https://blog.caoxl.com/2020/04/03/RabbitMq-Actual-Combat-1/">RabbitMQ 实战记录</a><br><a href="https://blog.caoxl.com/2020/04/08/RabbitMQ-Learn-More/">RabbitMq 再深入</a></p></blockquote><a id="more"></a><h1 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 建立连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> AMQPStreamConnection($host, $port, $user, $password, $vhost);</span><br></pre></td></tr></table></figure><ul><li><code>$host</code>:  RabbitMQ服务器主机ID地址</li><li><code>$port</code>:  RabbitMQ服务器端口</li><li><code>$user</code>:  连接RabbitMQ服务器的用户名</li><li><code>$password</code>:  连接RabbitMQ服务器的用户密码</li><li><code>$vhost</code>: 连接RabbitMQ服务器的vhost(服务器可以有多个vhost，虚拟主机，类似nginx的vhost)</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 1.2 建立信道</span><br><span class="line">$channel = $conn-&gt;channel($channel_id);</span><br></pre></td></tr></table></figure><ul><li><code>$channel_id</code>:  信道ID, 不传则获取$channel[“”]信道,再无则循环$this-&gt;channel数组，下标从1到最大信道数找第一个不是<code>AMQPChannel</code>对象的下标，实例化并返回<code>AMQPChannel</code>对象，无则抛出异常<code>No free channel ids</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.3 声明交换机</span></span><br><span class="line">$channel-&gt;exchange_declare(</span><br><span class="line">    $exchange_name,</span><br><span class="line">    $type,</span><br><span class="line">    $passive = <span class="keyword">false</span>,</span><br><span class="line">    $durable = <span class="keyword">false</span>,</span><br><span class="line">    $auto_delete = <span class="keyword">false</span>,</span><br><span class="line">    $internal = <span class="keyword">false</span>,</span><br><span class="line">    $nowait = <span class="keyword">false</span>,</span><br><span class="line">    $arguments = <span class="keyword">array</span>(),</span><br><span class="line">    $ticket = <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>$exchange_name</code>:  交换机名称</li><li><code>$type</code>:  交换机类型<ul><li><code>direct</code>: (默认)直接交换器，工作方式类似于单播，<code>exchange</code>会将消息发送完全匹配<code>route_key</code>的<code>queue</code>;</li><li><code>fanout</code>: 广播式交换器，不管消息的<code>route_key</code>设置为什么，<code>exchange</code>都会将消息转发给所有绑定的<code>queue</code>;</li><li><code>topic</code>: 主题交换机, 工作方式类似于组播, <code>exchange</code>会将消息转发和<code>route_key</code>匹配模式相同的所有队列;</li><li><code>headers</code>: 根据消息体的header匹配</li></ul></li><li><code>$passive</code>:  是否检测同名队列</li><li><code>$durable</code>:  交换机是否开启持久化</li><li><code>$auto_delete</code>:  通道关闭后是否删除队列</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.4 声明队列</span></span><br><span class="line">$channel-&gt;queue_declare(</span><br><span class="line">    $queue_name = <span class="string">''</span>,</span><br><span class="line">    $passive = <span class="keyword">false</span>,</span><br><span class="line">    $durable = <span class="keyword">false</span>,</span><br><span class="line">    $exclusive = <span class="keyword">false</span>,</span><br><span class="line">    $auto_delete = <span class="keyword">true</span>,</span><br><span class="line">    $nowait = <span class="keyword">false</span>,</span><br><span class="line">    $arguments = <span class="keyword">array</span>(),</span><br><span class="line">    $ticket = <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>$queue_name</code>:  队列名称</li><li><code>$passive</code>:  是否检测同名队列</li><li><code>$durable</code>:  是否开启队列持久化</li><li><code>$exclusive</code>:  队列是否可以被其他队列访问</li><li><code>$auto_delete</code>: 通道关闭后是否删除队列</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.5 创建要发送的消息, 可以创建多个消息</span></span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage($data, $properties);</span><br><span class="line"><span class="comment">// 单个发送</span></span><br><span class="line">$channel-&gt;basic_publish($msg, $exchange = <span class="string">''</span>, $routing_key = <span class="string">''</span>, $mandatory = <span class="keyword">false</span>, $immediate = <span class="keyword">false</span>, $ticket = <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 多个发送</span></span><br><span class="line"><span class="comment">// 1.多次调用 $channel-&gt;batch_basic_publish($msg, $exchange = '', $routing_key = '', $mandatory = false, $immediate = false, $ticket = null)</span></span><br><span class="line"><span class="comment">// 内部实现:往$this-&gt;batch_messages[]塞</span></span><br><span class="line"><span class="comment">// 2.再调用一次$channel-&gt;publish_batch(), 完成发送</span></span><br></pre></td></tr></table></figure><ul><li><code>$data</code>:  要发送的消息</li><li><code>$properties</code>:  设置的属性, 比如设置该消息持久化 <code>[&#39;delivery_mode&#39; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT]</code></li><li><code>$msg</code>:  消息内容</li><li><code>$exchange</code>:  交换机</li><li><code>$routing_key</code>:  路由键</li><li><code>$mandatory</code>:  匹配不到队列时,是否立即丢弃消息</li><li><code>$immediate</code>:  队列无消费者时,是否立即丢弃消息</li><li><code>$ticket</code>:  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.6 路由绑定</span></span><br><span class="line">$channel-&gt;queue_bind(</span><br><span class="line">    $queue,</span><br><span class="line">    $exchange, </span><br><span class="line">    $routing_key = <span class="string">''</span>, </span><br><span class="line">    $nowait = <span class="keyword">false</span>,</span><br><span class="line">    $arguments = <span class="keyword">array</span>(),</span><br><span class="line">    $ticket = <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>$queue</code>:  队列名</li><li><code>$exchange</code>:  交换机名</li><li><code>$routing_key</code>:  路由键</li><li><code>$nowait</code>:  声明队列无需等待</li><li><code>$arguments</code>:  其他参数</li><li><code>$ticket</code>:  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.7 消费消息</span></span><br><span class="line">$channel-&gt;basic_consume(</span><br><span class="line">    $queue = <span class="string">',</span></span><br><span class="line"><span class="string">    $consumer_tag = '</span>,</span><br><span class="line">    $no_local = <span class="keyword">false</span>,</span><br><span class="line">    $no_ack = <span class="keyword">false</span>,</span><br><span class="line">    $exclusive = <span class="keyword">false</span>,</span><br><span class="line">    $nowait = <span class="keyword">false</span>,</span><br><span class="line">    $callback = <span class="keyword">null</span>,</span><br><span class="line">    $ticket = <span class="keyword">null</span>,</span><br><span class="line">    $arguments = <span class="keyword">array</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>$queue</code>:  被消费队列名称</li><li><code>$consumer_tag</code>:  消费者客户端身份标识，用于区分多个客户端</li><li><code>$no_local</code>:  这个功能属于AMQP的标准，但是RabbitMQ并没有做实现</li><li><code>$no_ack</code>:  收到消息后，是否不需要回复确认即被认为被消费</li><li><code>$exclusive</code>:  收到消息后，是否不需要回复确认即被认为被消费</li><li><code>$nowait</code>:  不返回执行结果，但是如果排他开启的话，则必须需要等待结果的，如果两个一起开就会报错</li><li><code>$callback</code>:  回调逻辑处理函数</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.8 手动ack示例</span></span><br><span class="line">$callback = <span class="function"><span class="keyword">function</span> <span class="params">($msg)</span> </span>&#123;</span><br><span class="line">    sleep($msg-&gt;body); </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">" [x] Received sleep "</span>, $msg-&gt;body, <span class="string">"\n"</span>;</span><br><span class="line">    $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;basic_ack($msg-&gt;delivery_info[<span class="string">'delivery_tag'</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">" [x] Ack "</span>.<span class="string">"\n"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.9 限制分发示例</span></span><br><span class="line"><span class="comment">// 限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。</span></span><br><span class="line">$channel-&gt;basic_qos(<span class="keyword">null</span>, <span class="number">1</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h1 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h1><h2 id="无交换机-直接队列"><a href="#无交换机-直接队列" class="headerlink" title="无交换机, 直接队列"></a>无交换机, 直接队列</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $connection = <span class="keyword">new</span> AMQPStreamConnection(<span class="string">'localhost'</span>, <span class="number">5672</span>, <span class="string">'guest'</span>, <span class="string">'guest'</span>);</span><br><span class="line">    $channel = $connection-&gt;channel();</span><br><span class="line">    $channel-&gt;queue_declare(<span class="string">'hello'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    $msg = <span class="keyword">new</span> AMQPMessage(<span class="string">'Hello World!'</span>);</span><br><span class="line">    $channel-&gt;basic_publish($msg, <span class="string">''</span>, <span class="string">'hello'</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">" [x] Sent 'Hello World!'\n"</span>;</span><br><span class="line">    $channel-&gt;close();</span><br><span class="line">    $connection-&gt;close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">consume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $connection = <span class="keyword">new</span> AMQPStreamConnection(<span class="string">'localhost'</span>, <span class="number">5672</span>, <span class="string">'guest'</span>, <span class="string">'guest'</span>);</span><br><span class="line">    $channel = $connection-&gt;channel();</span><br><span class="line">    $channel-&gt;queue_declare(<span class="string">'hello'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>, <span class="string">"\n"</span>;</span><br><span class="line">    $callback = <span class="function"><span class="keyword">function</span> <span class="params">($msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">" [x] Received "</span>, $msg-&gt;body, <span class="string">"\n"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    $channel-&gt;basic_consume(<span class="string">'hello'</span>, <span class="string">''</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, $callback);</span><br><span class="line">    <span class="keyword">while</span> (count($channel-&gt;callbacks)) &#123;</span><br><span class="line">        $channel-&gt;wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作队列按消费能力分发"><a href="#工作队列按消费能力分发" class="headerlink" title="工作队列按消费能力分发"></a>工作队列按消费能力分发</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者和消费者均增加</span></span><br><span class="line">$channel-&gt;basic_qos(<span class="keyword">null</span>, <span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 即可。</span></span><br></pre></td></tr></table></figure><h2 id="fanout广播示例-注册行为"><a href="#fanout广播示例-注册行为" class="headerlink" title="fanout广播示例 注册行为"></a><code>fanout</code>广播示例 注册行为</h2><p>例如注册后需要发送欢迎短信和邮件，将注册行为广播至短信和邮件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="comment">// 定义交换机</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'register'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage(<span class="string">'register event'</span>);</span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">'register'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册短信消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'register'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'register.sms'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'register.sms'</span>, <span class="string">'register'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册邮件消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'register'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'register.mail'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'register.mail'</span>, <span class="string">'register'</span>);</span><br></pre></td></tr></table></figure><h2 id="topic模糊匹配示例-日志分级"><a href="#topic模糊匹配示例-日志分级" class="headerlink" title="topic模糊匹配示例 日志分级"></a><code>topic</code>模糊匹配示例 日志分级</h2><p>例如我想一个消费者接受所有日志，一个消费者只接收error级别日志</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义交换机</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log'</span>, <span class="string">'topic'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$num = rand(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> ($num%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    $level = <span class="string">'error'</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($num%<span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    $level = <span class="string">'warning'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $level = <span class="string">'common'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage(<span class="string">'log event '</span> . $level);</span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">'log'</span>, <span class="string">'log.'</span>.$level);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全量日志消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log'</span>, <span class="string">'topic'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'log.all'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'log.all'</span>, <span class="string">'log'</span>, <span class="string">'log.*'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error日志消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log'</span>, <span class="string">'topic'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'log.error'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'log.error'</span>, <span class="string">'log'</span>, <span class="string">'log.error'</span>);</span><br></pre></td></tr></table></figure><h2 id="headers匹配示例-日志分级"><a href="#headers匹配示例-日志分级" class="headerlink" title="headers匹配示例 日志分级"></a><code>headers</code>匹配示例 日志分级</h2><p>例如我想一个消费者接受所有日志，一个消费者只接收error级别日志</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="comment">// 定义交换机</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log2'</span>, <span class="string">'headers'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$num = rand(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> ($num%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    $level = <span class="string">'error'</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($num%<span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    $level = <span class="string">'warning'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $level = <span class="string">'common'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage(<span class="string">'log2 event '</span>.$level);</span><br><span class="line">$bindArguments = [</span><br><span class="line">    <span class="string">'level'</span> =&gt; $level,</span><br><span class="line">    <span class="string">'type'</span>  =&gt; <span class="string">'log'</span></span><br><span class="line">];</span><br><span class="line">$headers = <span class="keyword">new</span> AMQPTable($bindArguments);</span><br><span class="line">$msg-&gt;set(<span class="string">'application_headers'</span>, $bindArguments);</span><br><span class="line"></span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">'log2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全量日志消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log2'</span>, <span class="string">'headers'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'log2.all'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$bindArguments = [</span><br><span class="line">    <span class="string">'type'</span> =&gt; <span class="string">'log'</span>,</span><br><span class="line">    <span class="comment">//'x-match' =&gt; 'any'</span></span><br><span class="line">];</span><br><span class="line">$headers = <span class="keyword">new</span> AMQPTable($bindArguments);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'log2.all'</span>, <span class="string">'log2'</span>, <span class="string">''</span>, <span class="keyword">false</span>, $headers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error日志消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log2'</span>, <span class="string">'headers'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'log2.error'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$bindArguments = [</span><br><span class="line">    <span class="string">'type'</span> =&gt; <span class="string">'log'</span>,</span><br><span class="line">    <span class="string">'level'</span> =&gt; <span class="string">'error'</span>,</span><br><span class="line">    <span class="string">'x-match'</span> =&gt; <span class="string">'any'</span></span><br><span class="line">];</span><br><span class="line">$headers = <span class="keyword">new</span> AMQPTable($bindArguments);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'log2.error'</span>, <span class="string">'log2'</span>, <span class="string">''</span>, <span class="keyword">false</span>, $headers);</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个没有消费者，5s后消息过期的队列</span></span><br><span class="line">$arguments = <span class="keyword">new</span> AMQPTable([</span><br><span class="line">    <span class="string">'x-dead-letter-exchange'</span>    =&gt; <span class="string">'dead'</span>,</span><br><span class="line">    <span class="string">'x-message-tl'</span>              =&gt; <span class="number">5000</span>, <span class="comment">// 消息存活时间(毫秒)</span></span><br><span class="line">    <span class="string">'x-dead-letter-routing-key'</span> =&gt; <span class="string">'dead'</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列, 不要交换机</span></span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'no_consume'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$now = time();</span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage($now);</span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">''</span>, <span class="string">'no_consume'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">" [x] Sent no_consume :"</span>.date(<span class="string">'Y-m-d H:i:s'</span>, $now).<span class="string">"\n"</span>;</span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$connection-&gt;close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'dead'</span>, <span class="string">'topic'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'dead.all'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'dead.all'</span>, <span class="string">'dead'</span>, <span class="string">'dead'</span>);</span><br><span class="line">$channel-&gt;basic_qos(<span class="keyword">null</span>, <span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>, <span class="string">"\n"</span>;</span><br><span class="line">$callback = <span class="function"><span class="keyword">function</span> <span class="params">($msg)</span> </span>&#123;</span><br><span class="line">    var_dump(<span class="string">'msg:'</span>.date(<span class="string">'Y-m-d H:i:s'</span>, $msg-&gt;body));</span><br><span class="line">    var_dump(<span class="string">'now:'</span>.date(<span class="string">'Y-m-d H:i:s'</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">" [x] Received log error "</span>, $msg-&gt;body, <span class="string">"\n"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$channel-&gt;basic_consume(<span class="string">'dead.all'</span>, <span class="string">''</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, $callback);</span><br><span class="line"><span class="keyword">while</span>(count($channel-&gt;callbacks)) &#123;</span><br><span class="line">    $channel-&gt;wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rabbitmq和redis用作消息队列的区别"><a href="#rabbitmq和redis用作消息队列的区别" class="headerlink" title="rabbitmq和redis用作消息队列的区别"></a>rabbitmq和redis用作消息队列的区别</h1><ul><li>可靠性</li></ul><blockquote><p>redis: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中<br>rabbitmq: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中</p></blockquote><ul><li>实时性</li></ul><blockquote><p>redis: 实时性高，redis作为高效的缓存服务器，所有数据都存在在服务器中，所以它具有更高的实时性</p></blockquote><ul><li>持久性</li></ul><blockquote><p>redis: redis的持久化是针对于整个redis缓存的内容，它有RDB和AOF两种持久化方式（redis持久化方式，后续更新），可以将整个redis实例持久化到磁盘，以此来做数据备份，防止异常情况下导致数据丢失。<br>rabbitmq: 队列，消息都可以选择性持久化，持久化粒度更小，更灵活；</p></blockquote><ul><li>总结:</li></ul><blockquote><p>redis: 轻量级, 低延迟, 高并发, 低可靠性;<br>rabbitmq: 重量级, 高可靠, 异步, 不保证实时性;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前有多篇RabbitMQ的学习, 实践是检验真理的唯一标准, 所以本篇是实践篇&lt;br&gt;&lt;a href=&quot;https://blog.caoxl.com/2019/08/07/Message-Queue-RabbitMQ/&quot;&gt;消息队列之 RabbitMQ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.caoxl.com/2020/04/03/RabbitMq-Actual-Combat-1/&quot;&gt;RabbitMQ 实战记录&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.caoxl.com/2020/04/08/RabbitMQ-Learn-More/&quot;&gt;RabbitMq 再深入&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="消息队列" scheme="http://blog.caoxl.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://blog.caoxl.com/tags/RabbitMQ/"/>
    
  </entry>
  
</feed>
