<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep It Simple And Stupid</title>
  
  <subtitle>Caoxl-Hexo-caoxl.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.caoxl.com/"/>
  <updated>2022-03-09T09:48:21.757Z</updated>
  <id>http://blog.caoxl.com/</id>
  
  <author>
    <name>CAO XIAN LIANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP面试八股文</title>
    <link href="http://blog.caoxl.com/2022/03/03/PHP-Eight-Legged-Essay/"/>
    <id>http://blog.caoxl.com/2022/03/03/PHP-Eight-Legged-Essay/</id>
    <published>2022-03-03T06:34:35.000Z</published>
    <updated>2022-03-09T09:48:21.757Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>面试造火箭 上班拧螺丝<br>“茴香豆的『回』字有几种写法你知道么”</p></blockquote><a id="more"></a><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><h3 id="php-fpm-的生命周期，创建进程方式，各自的优缺点（腾讯-百度-滴滴-陌陌）"><a href="#php-fpm-的生命周期，创建进程方式，各自的优缺点（腾讯-百度-滴滴-陌陌）" class="headerlink" title="php-fpm 的生命周期，创建进程方式，各自的优缺点（腾讯 百度 滴滴 陌陌）"></a>php-fpm 的生命周期，创建进程方式，各自的优缺点（腾讯 百度 滴滴 陌陌）</h3><blockquote><p>PHP-FPM是一种多进程模型，主要由Master进程以及Worker进程组成，所有的cgi请求都会交由Worker进程处理。Master进程主要维护worker进程。<br>而worker进程的工作方式是抢占/竞争的方式，当一个accept请求过来的时候，谁先拿到算谁的，拿到后转化为FastCGIRequest，交由脚本处理。</p></blockquote><h4 id="php生命周期"><a href="#php生命周期" class="headerlink" title="php生命周期"></a>php生命周期</h4><p>数据初始化(MINT) =&gt; 请求初始化(RINT) =&gt; 编译脚本 (RSHUTDOWN) =&gt; 执行代码(MSHUTDOWN)</p><ul><li><a href="https://www.abelzhou.com/php/php-fpm-lifespan/#" target="_blank" rel="noopener">PHP-FPM 生命周期</a></li></ul><h4 id="static-静态模式"><a href="#static-静态模式" class="headerlink" title="static 静态模式"></a>static 静态模式</h4><p>启动的时候创建固定数量的worker进程,实际请求大于worker进程的时候 <strong>包warning</strong></p><h4 id="ondemand-按需分配模式"><a href="#ondemand-按需分配模式" class="headerlink" title="ondemand 按需分配模式"></a>ondemand 按需分配模式</h4><p>启动的时候不会创建worker进程, 根据需要创建,释放在idle_timeout之后</p><p>这样不能及时的释放连接和建立连接需要消耗资源</p><h4 id="dynamic-动态模式-默认"><a href="#dynamic-动态模式-默认" class="headerlink" title="dynamic 动态模式(默认)"></a>dynamic 动态模式(默认)</h4><p>启动的是创建指定数量的worker进程, 根据情况合理的worker,定期检测worker,关闭闲置连接</p><ul><li><a href="https://www.its404.com/article/qq_39787367/104009809" target="_blank" rel="noopener">PHP-FPM三种运行模式</a></li></ul><h3 id="php-数组遍历为什么能保证有序（滴滴）"><a href="#php-数组遍历为什么能保证有序（滴滴）" class="headerlink" title="php 数组遍历为什么能保证有序（滴滴）"></a>php 数组遍历为什么能保证有序（滴滴）</h3><p>为了实现插入与遍历的顺序一致性，在PHP7中，增加了一个中间映射层，它的大小与哈希表相同，存储了元素在bucket中最终存储的位置，我们把它叫做<strong>映射表</strong>。</p><ul><li><a href="https://www.laruence.com/2009/08/23/1065.html" target="_blank" rel="noopener">深入理解PHP之数组(遍历顺序)</a></li></ul><h3 id="php-怎么实现的弱类型，怎么实现一个扩展（腾讯）"><a href="#php-怎么实现的弱类型，怎么实现一个扩展（腾讯）" class="headerlink" title="php 怎么实现的弱类型，怎么实现一个扩展（腾讯）"></a>php 怎么实现的弱类型，怎么实现一个扩展（腾讯）</h3><h4 id="实现php弱类型变量"><a href="#实现php弱类型变量" class="headerlink" title="实现php弱类型变量"></a>实现php弱类型变量</h4><ol><li>通过Zend引擎用C实现弱类型，在ZE中用结构体zval来保存</li><li>通过Zend引擎是判别、存储PHP中的多种数据类型，根据type来选择获取【zvalue_value】的值</li></ol><h4 id="实现一个扩展"><a href="#实现一个扩展" class="headerlink" title="实现一个扩展"></a>实现一个扩展</h4><ul><li><a href="https://juejin.cn/post/7036991318991749128#heading-5" target="_blank" rel="noopener">解析PHP原生扩展开发</a></li></ul><h3 id="常见魔术方法和函数（腾讯-滴滴）"><a href="#常见魔术方法和函数（腾讯-滴滴）" class="headerlink" title="常见魔术方法和函数（腾讯 滴滴）"></a>常见魔术方法和函数（腾讯 滴滴）</h3><ul><li><code>__construct()</code>: 类的构造函数</li><li><code>__destruct()</code>: 类的析构函数</li><li><code>__call()</code>: 当调用一个未定义或不可达方法时， __call () 方法将被调用。</li><li><code>__callStatic()</code>: 当调用一个未定义或不可达的静态方法时， __callStatic () 方法将被调用。</li><li><code>__get()</code>: 当获取一个类的成员变量时， __get () 方法将被调用。</li><li><code>__set()</code>: 当赋值一个类的成员变量时， __set () 方法将被调用。</li><li><code>__isset()</code>: 当调用 isset () 或 empty () 对一个未定义或不可达的成员赋值时， __isset () 方法将被调用。</li><li><code>__unset()</code>: 当调用 reset () 对一个未定义或不可达的成员更新时， __unset () 方法将被调用。</li><li><code>__sleep()</code>: 当执行序列化 serialize () 时，__sleep () 方法将首先被调用。</li><li><code>__wakeup()</code>: 当执行反序列化 deserialization () 时， __wakeup () 方法将首先被调用。</li><li><code>__toString()</code>: 当使用 echo 方法直接输出显示对象时，__toString () 方法首先被调用。</li><li><code>__invoke()</code>: 使用调用函数（function）访问一个对象时， __invoke () 方法将首先被调用。</li><li><code>__set_state()</code>: 当调用 var_export () 方法时，__set_state () 方法将被调用。</li><li><code>__clone()</code>: 当对象被复制赋值时，__clone () 方法将被调用。</li><li><code>__autoload()</code>: 试图载入一个未定义的类时调用。</li><li><code>__debugInfo()</code>: 输出 debug 信息。</li></ul><ul><li><a href="https://learnku.com/php/t/40919" target="_blank" rel="noopener">16 个 PHP 开发者必知必会的魔术方法</a></li></ul><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="有哪些事务隔离级别，Mysql-的事务隔离级别是怎么实现的？（每家都问）"><a href="#有哪些事务隔离级别，Mysql-的事务隔离级别是怎么实现的？（每家都问）" class="headerlink" title="有哪些事务隔离级别，Mysql 的事务隔离级别是怎么实现的？（每家都问）"></a>有哪些事务隔离级别，Mysql 的事务隔离级别是怎么实现的？（每家都问）</h3><blockquote><p>事务的隔离性由锁来实现。 原子性、一致性、持久性通过数据库的redo log和undo log来实现。 redo log称为重做日志，用来保证事务的原子性和持久性，undo log用来保证事务的一致性。 MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化</p></blockquote><ul><li>未提交读(RU)</li><li>提交读(RC)</li><li>可重复读(RR)</li><li>序列化读(S)</li></ul><ul><li><a href="https://segmentfault.com/a/1190000025156465" target="_blank" rel="noopener">深入理解MySQL中事务隔离级别的实现原理</a></li></ul><h3 id="索引原理（每家都问）"><a href="#索引原理（每家都问）" class="headerlink" title="索引原理（每家都问）"></a>索引原理（每家都问）</h3><blockquote><p>索引的本质是一种排好序的数据结构</p></blockquote><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><ul><li>Hash索引</li><li>二叉树</li><li>B树</li><li>B+树 (MySQL 中最常用的索引的数据结构是 B+ 树)</li></ul><ul><li><a href="https://juejin.cn/post/6931901822231642125" target="_blank" rel="noopener">MySQL索引原理，一篇从头到尾讲清楚</a></li></ul><h3 id="分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）"><a href="#分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）" class="headerlink" title="分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）"></a>分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）</h3><h4 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h4><blockquote><p>常见的分布式生成唯一ID的方式很多，最常见的雪花算法Snowflake、滴滴Tinyid、美团Leaf。以雪花算法举例来说，一毫秒可以生成4194304多个ID。</p></blockquote><h3 id="MVCC-和间隙锁原理（滴滴-字节-百度）"><a href="#MVCC-和间隙锁原理（滴滴-字节-百度）" class="headerlink" title="MVCC 和间隙锁原理（滴滴 字节 百度）"></a>MVCC 和间隙锁原理（滴滴 字节 百度）</h3><blockquote><p>多版本并发控制（MVCC）是一种解决读-写冲突的无锁并发控制<br>每一行记录都有两个隐藏列：创建版本号和回滚指针。事务开启后存在一个事务id。多个并发事务同时操作某行，不同的事务对该行update操作会产生多个版本，然后通过回滚指针组成undo log链。而MVCC的快照读正是通过事务id和创建版本号从而实现的快照读。</p></blockquote><p><strong>注意：只有RR隔离级别才存在间隙锁。</strong></p><h3 id="explain-的-type-字段有哪些（知乎）"><a href="#explain-的-type-字段有哪些（知乎）" class="headerlink" title="explain 的 type 字段有哪些（知乎）"></a>explain 的 type 字段有哪些（知乎）</h3><ul><li><code>system</code>: 系统表,少量数据,往往不需要进行磁盘IO</li><li><code>const</code>: 常量连接</li><li><code>eq_ref</code>: 主键索引(primary key)或者非空唯一索引(unique not null)等值扫描</li><li><code>ref</code>: 非主键非唯一索引等值扫描</li><li><code>range</code>: 范围扫描</li><li><code>index</code>: 索引树扫描</li><li><code>ALL</code>: 全表扫描(full table scan)</li></ul><h4 id="type扫描方式由快到慢"><a href="#type扫描方式由快到慢" class="headerlink" title="type扫描方式由快到慢"></a><code>type</code>扫描方式由快到慢</h4><blockquote><p><code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code></p></blockquote><ul><li><a href="https://juejin.cn/post/6844904149864169486" target="_blank" rel="noopener">Mysql Explain之type详解</a></li></ul><h3 id="update-语句的执行流程，binlog-的作用和几种格式（滴滴）"><a href="#update-语句的执行流程，binlog-的作用和几种格式（滴滴）" class="headerlink" title="update 语句的执行流程，binlog 的作用和几种格式（滴滴）"></a>update 语句的执行流程，binlog 的作用和几种格式（滴滴）</h3><ul><li><a href="https://cdn.learnku.com/uploads/images/202007/16/66421/IA2zMmze89.png!large" target="_blank" rel="noopener">update 语句的执行流程</a></li></ul><h4 id="binlog-的作用和几种格式"><a href="#binlog-的作用和几种格式" class="headerlink" title="binlog 的作用和几种格式"></a>binlog 的作用和几种格式</h4><p>binlog一般情况下分为三种格式，分别是<code>row</code>格式、<code>statement</code>格式、<code>mixed</code>格式</p><ul><li><code>row格式</code>: 此格式不记录sql语句上下文相关信息，仅保存哪条记录被修改。</li><li><code>statement</code>: 该格式下每一条会修改数据的sql都会记录在binlog中。</li><li><code>mixed</code>: 该格式是以上两种level的混合使用，一般的语句修改使用statement格式保存binlog，当statement无法完成主从复制的操作时(设计一些函数时)，则采用Row格式保存binlog</li></ul><h3 id="主从同步的原理和问题（字节-滴滴-陌陌）"><a href="#主从同步的原理和问题（字节-滴滴-陌陌）" class="headerlink" title="主从同步的原理和问题（字节 滴滴 陌陌）"></a>主从同步的原理和问题（字节 滴滴 陌陌）</h3><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><ol><li>在主库上把数据更改记录到二进制日志binary log中，具体是在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中去，Mysql会按照事务提交的顺序来记录二进制日志的。日志记录好之后，主库通知存储引擎提交事务。</li><li>从库会启动一个IO线程，该线程会连接到主库。而主库上的binlog dump线程会去读取主库本地的binlog日志文件中的更新事件。发往从库，从库接收到日志之后会将其记录到本地的中继日志relay-log当中。</li><li>从库中的SQL线程读取中继日志relay-log中的事件，将其重放到从库中。（在5.6版本之前SQL线程是单线程的，使得主从之间延迟更大）</li></ol><ul><li><a href="https://www.cnblogs.com/idoljames/p/11694039.html" target="_blank" rel="noopener">Mysql主从复制原理及同步延迟问题</a></li></ul><h4 id="延迟问题"><a href="#延迟问题" class="headerlink" title="延迟问题"></a>延迟问题</h4><ul><li><p>延迟的产生:</p><ul><li>当主库的TPS并发较高时，由于主库上面是多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的处理速度（生产者比消费者快，导致商品堆积）。</li></ul></li><li><p>延迟的解决:</p><ul><li>网络方面：将从库分布在相同局域网内或网络延迟较小的环境中。</li><li>硬件方面：从库配置更好的硬件，提升随机写的性能</li><li>配置方面：从库配置sync_binlog=0，innodb_flush_log_at_trx_commit=2，logs-slave-updates=0，增大innodb_buffer_pool_size，让更多操作在Mysql内存中完成，减少磁盘操作。或者升级Mysql5.7版本使用并行复制</li><li>架构方面：比如在事务当中尽量对主库读写，其他非事务中的读在从库。消除一部分延迟带来的数据库不一致。增加缓存降低一些从库的负载。</li></ul></li></ul><h3 id="发生死锁的原因以及如何解决（滴滴-顺丰）"><a href="#发生死锁的原因以及如何解决（滴滴-顺丰）" class="headerlink" title="发生死锁的原因以及如何解决（滴滴 顺丰）"></a>发生死锁的原因以及如何解决（滴滴 顺丰）</h3><h4 id="发生死锁的原因"><a href="#发生死锁的原因" class="headerlink" title="发生死锁的原因"></a>发生死锁的原因</h4><ol><li>互斥条件</li><li>不可剥夺条件(不可抢占)</li><li>部分分配</li><li>循环等待</li></ol><h4 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h4><ol><li>通过协议来预防或避免死锁，确保系统不会进入死锁状态。</li><li>可以允许系统进入死锁状态，然后检测它，并加以恢复。</li><li>可以忽视这个问题，认为死锁不可能在系统内发生</li></ol><ul><li><a href="http://c.biancheng.net/view/1236.html" target="_blank" rel="noopener">什么是死锁，死锁的原因及解决办法（含四个必要条件）</a></li></ul><h3 id="如何优化大-offset（陌陌）"><a href="#如何优化大-offset（陌陌）" class="headerlink" title="如何优化大 offset（陌陌）"></a>如何优化大 offset（陌陌）</h3><p>当offset特别大时，这条语句的执行效率会明显减低，而且效率是随着offset的增大而降低的。</p><p>MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，当offset特别大，然后单条数据也很大的时候，每次查询需要获取的数据就越多，自然就会很慢。</p><ul><li>解决方法<br>先获取主键列表，再通过主键查询目标数据，即使offset很大，也是获取了很多的主键，而不是所有的字段数据，相对而言效率会提升很多。</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select 需要的字段 </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    select &lt;a.<span class="built_in">id</span> 或 b.<span class="built_in">id</span>&gt; <span class="keyword">as</span> <span class="built_in">id</span></span><br><span class="line">    <span class="keyword">from</span> a join b <span class="keyword">on</span> a.<span class="built_in">id</span>=b.<span class="built_in">id</span></span><br><span class="line">    <span class="keyword">where</span> &lt;筛选条件&gt;</span><br><span class="line">    order <span class="keyword">by</span> &lt;一些字段&gt;</span><br><span class="line">    limit &lt;limit_param&gt; <span class="built_in">offset</span> &lt;offset_param&gt;</span><br><span class="line">) c join a <span class="keyword">on</span>  c.<span class="built_in">id</span>=a.<span class="built_in">id</span></span><br><span class="line">    join b <span class="keyword">on</span> c.<span class="built_in">id</span>=b.<span class="built_in">id</span></span><br><span class="line">    order <span class="keyword">by</span> &lt;一些字段&gt;</span><br></pre></td></tr></table></figure><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="缓存如何保证一致性（每家都问）"><a href="#缓存如何保证一致性（每家都问）" class="headerlink" title="缓存如何保证一致性（每家都问）"></a>缓存如何保证一致性（每家都问）</h3><ol><li>执行顺序的问题：先更新缓存还是先更新数据库？</li><li>更新缓存的策略问题：当缓存中的内容变化时，是选择修改缓存(update)，还是直接淘汰缓存(delete)？</li></ol><p><strong>针对这两点问题，一共可以分为四种方案：</strong></p><ol><li>先更新缓存，再更新数据库</li><li>先更新数据库，再更新缓存</li><li>先淘汰缓存，再更新数据库 (适用于对一致性要求高的业务)</li><li>先更新数据库，再淘汰缓存</li></ol><ul><li><a href="https://developer.aliyun.com/article/712285" target="_blank" rel="noopener">如何保证缓存(redis)与数据库(MySQL)的一致性</a></li></ul><h3 id="用过-redis-哪些数据结构，使用场景是什么（每家都问）"><a href="#用过-redis-哪些数据结构，使用场景是什么（每家都问）" class="headerlink" title="用过 redis 哪些数据结构，使用场景是什么（每家都问）"></a>用过 redis 哪些数据结构，使用场景是什么（每家都问）</h3><ul><li><code>string</code>(字符串): 常见的key-value存储</li><li><code>list</code>(列表): <ul><li>消息队列: <code>lpop</code>和<code>rpush</code>或者反过来，<code>lpush</code>和<code>rpop</code>）能实现队列的功能</li><li>朋友圈点赞列表, 评论列表, 排行榜</li></ul></li><li><code>hash</code>(字典): <ul><li>购物车: <code>hset [key] [field] [value]</code> 命令， 可以实现以用户Id，商品Id为field，商品数量为value，恰好构成了购物车的3个要素。</li><li>存储对象：hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。</li></ul></li><li><code>set</code>(集合): <ul><li>好友、关注、粉丝、感兴趣的人集合<br>1) <code>sinter</code>命令可以获得A和B两个用户的共同好友；<br>2) <code>sismember</code>命令可以判断A是否是B的好友；<br>3) <code>scard</code>命令可以获取好友数量；<br>4) 关注时，<code>smove</code>命令可以将B从A的粉丝集合转移到A的好友集合</li><li>首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个</li><li>存储某活动中中奖的用户ID ，因为有去重功能，可以保证同一个用户不会中奖两次。</li></ul></li><li><code>zset</code>(有序集合):<ul><li><code>zset</code> 可以用做排行榜，但是和list不同的是zset它能够实现动态的排序，例如： 可以用来存储粉丝列表，value 值是粉丝的用户 ID，score 是关注时间，我们可以对粉丝列表按关注时间进行排序。</li></ul></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/145384563" target="_blank" rel="noopener">Redis 5种数据结构 及使用场景分析</a></li></ul><h3 id="redis-的-connect-和-pconnect-的区别，pconnect-有什么问题（滴滴-陌陌）"><a href="#redis-的-connect-和-pconnect-的区别，pconnect-有什么问题（滴滴-陌陌）" class="headerlink" title="redis 的 connect 和 pconnect 的区别，pconnect 有什么问题（滴滴 陌陌）"></a>redis 的 connect 和 pconnect 的区别，pconnect 有什么问题（滴滴 陌陌）</h3><ul><li><code>connect</code>: 脚本结束之后连接就释放了</li><li><code>pconnect</code>: 脚本结束之后连接不释放，连接保持在php-fpm进程中</li></ul><p><strong>pconnect 有什么问题</strong></p><ol><li>当使用pconnect时，连接会被重用，连接的生命周期是fpm进程的生命周期，而非一次php的执行</li><li>如果代码中使用pconnect， close的作用仅是使当前php不能再进行redis请求，但无法真正关闭redis长连接，连接在后续请求中仍然会被重用，直至fpm进程生命周期结束。</li></ol><h3 id="redis-如何实现分布式锁，有什么问题（陌陌）"><a href="#redis-如何实现分布式锁，有什么问题（陌陌）" class="headerlink" title="redis 如何实现分布式锁，有什么问题（陌陌）"></a>redis 如何实现分布式锁，有什么问题（陌陌）</h3><p>利用 Redis 的 <code>SETNX</code> 命令，此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功。而基于 Redis 多机实现的分布式锁 <code>Redlock</code>，是 Redis 的作者 antirez 为了规范 Redis 分布式锁的实现，提出的一个更安全有效的实现机制</p><blockquote><p>不管是哪种实现方式，均需要实现加锁、解锁、锁超时这三个分布式锁的核心要素</p></blockquote><ul><li><a href="http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/" target="_blank" rel="noopener">深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了</a></li></ul><h3 id="redis-为什么用跳表实现有序集合？原理，用有序集合的场景（字节-滴滴）"><a href="#redis-为什么用跳表实现有序集合？原理，用有序集合的场景（字节-滴滴）" class="headerlink" title="redis 为什么用跳表实现有序集合？原理，用有序集合的场景（字节 滴滴）"></a>redis 为什么用跳表实现有序集合？原理，用有序集合的场景（字节 滴滴）</h3><ul><li><ol><li>按照区间来查找数据这个操作，红黑树的效率没有跳表高</li></ol></li><li><ol start="2"><li>跳表更容易代码实现</li></ol></li><li><ol start="3"><li>跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗</li></ol></li><li><p><a href="https://juejin.cn/post/6962735884844138533#heading-8" target="_blank" rel="noopener">Redis 选择用跳表来实现有序集合的原因</a></p></li></ul><h4 id="跳表数据结构"><a href="#跳表数据结构" class="headerlink" title="跳表数据结构"></a>跳表数据结构</h4><ul><li>跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现是基于“二分查找”的链表操作</li><li>跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)</li><li>跳表的空间复杂度是 O(n)，不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</li><li>虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</li></ul><h3 id="主从同步的原理，哨兵和集群的区别（滴滴）"><a href="#主从同步的原理，哨兵和集群的区别（滴滴）" class="headerlink" title="主从同步的原理，哨兵和集群的区别（滴滴）"></a>主从同步的原理，哨兵和集群的区别（滴滴）</h3><ul><li>主从复制: 读写分离，备份，一个Master可以有多个Slaves。</li><li>哨兵: 监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li><li>集群: 为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li></ul><blockquote><p>哨兵(sentinel)着眼于高可用; 集群(cluster)提高并发量</p></blockquote><ul><li><a href="https://juejin.cn/post/6844904097116585991" target="_blank" rel="noopener">一文掌握Redis主从复制、哨兵、Cluster三种集群模式</a></li></ul><h3 id="redis-cluster-用的什么协议同步数据，哨兵的选举呢（陌陌）"><a href="#redis-cluster-用的什么协议同步数据，哨兵的选举呢（陌陌）" class="headerlink" title="redis cluster 用的什么协议同步数据，哨兵的选举呢（陌陌）"></a>redis cluster 用的什么协议同步数据，哨兵的选举呢（陌陌）</h3><blockquote><p>Gossip协议 又称 epidemic 协议（epidemic protocol）</p></blockquote><h4 id="哨兵选举"><a href="#哨兵选举" class="headerlink" title="哨兵选举"></a>哨兵选举</h4><p>主节点被标记为 Fail 后，对应的从节点会发起投票，竞争升主。历经从节点拉票、主节点投票、投票裁决等环节，最终完成选举。</p><ol><li>从节点拉票</li><li>拉票优先级</li><li>主节点投票</li><li>根据投票结果决策</li><li>选举失败</li><li>选举算法 (选举新主节点的算法是基于 Raft 算法的 Leader Election 方法来实现的)</li></ol><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%AE%8C%EF%BC%89/04%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20Gossip%20%E5%92%8C%20Redis%20%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">分布式一致性协议 Gossip 和 Redis 集群原理解析</a></li></ul><h3 id="rdb-和-aof-的原理（滴滴-高德）"><a href="#rdb-和-aof-的原理（滴滴-高德）" class="headerlink" title="rdb 和 aof 的原理（滴滴 高德）"></a>rdb 和 aof 的原理（滴滴 高德）</h3><ul><li><code>RDB</code>: 生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dump.rdb</li><li><code>AOF</code>: 记录 Redis 除了查询以外的所有写命令，并在Redis 服务启动时，通过重新执行这些命令来还原数据。</li></ul><p><strong>区别</strong></p><ul><li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li><li>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式追加记录，可以打开文件看到详细的操作记录。</li></ul><ul><li><a href="https://segmentfault.com/a/1190000018388385" target="_blank" rel="noopener">RDB 和 AOF 持久化的原理是什么？我应该用哪一个？它们的优缺点？</a></li></ul><h3 id="数据过期和淘汰策略（滴滴-高德-字节）"><a href="#数据过期和淘汰策略（滴滴-高德-字节）" class="headerlink" title="数据过期和淘汰策略（滴滴 高德 字节）"></a>数据过期和淘汰策略（滴滴 高德 字节）</h3><h4 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h4><blockquote><p>Redis中主要使用 <strong>定期删除</strong> + <strong>惰性删除</strong> 两种数据过期清除策略</p></blockquote><ul><li>定期删除：redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果有过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。</li><li>惰性删除：定期删除可能导致很多过期的key 到了时间并没有被删除掉。这时就要使用到惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且过期了，是的话就删除。</li></ul><h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><blockquote><p>Redis共提供了8中缓存淘汰策略，其中 volatile-lfu 和 allkeys-lfu 是Redis 4.0版本新增的<br>通常情况下推荐优先使用 allkeys-lru 策略。</p></blockquote><ul><li><code>noeviction</code>: 不进行淘汰数据</li><li><code>volatile-ttl</code>: 在设置了过期时间的键值对中，移除即将过期的键值对</li><li><code>volatile-random</code>: 在设置了过期时间的键值对中，随机移除某个键值对</li><li><code>volatile-lru</code>: 在设置了过期时间的键值对中，移除最近最少使用的键值对</li><li><code>volatile-lfu</code>: 在设置了过期时间的键值对中，移除最近最不频繁使用的键值对</li><li><code>allkeys-random</code>: 在所有键值对中，随机移除某个key</li><li><code>allkeys-lru</code>: 在所有的键值对中，移除最近最少使用的键值对。</li><li><code>allkeys-lfu</code>: 在所有的键值对中，移除最近最不频繁使用的键值对</li></ul><ul><li><a href="https://blog.csdn.net/a745233700/article/details/85413179" target="_blank" rel="noopener">Redis的数据过期清除策略 与 内存淘汰策略</a></li></ul><h3 id="缓存雪崩-击穿-穿透（滴滴-陌陌）"><a href="#缓存雪崩-击穿-穿透（滴滴-陌陌）" class="headerlink" title="缓存雪崩 击穿 穿透（滴滴 陌陌）"></a>缓存雪崩 击穿 穿透（滴滴 陌陌）</h3><ul><li><a href="https://blog.caoxl.com/2019/08/29/Caching-Related-Issues-And-Solutions/">缓存 相关问题/解决方案</a></li></ul><h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><h3 id="深度分页会有什么问题（滴滴-百度-陌陌）"><a href="#深度分页会有什么问题（滴滴-百度-陌陌）" class="headerlink" title="深度分页会有什么问题（滴滴 百度 陌陌）"></a>深度分页会有什么问题（滴滴 百度 陌陌）</h3><p>深度分页问题大致可以分为两类</p><ul><li>随机深度分页: 随机跳转页面</li><li>滚动深度分页: 只能一页一页往下查询</li></ul><h4 id="from-size"><a href="#from-size" class="headerlink" title="from/size"></a>from/size</h4><p>es 目前支持最大的 skip 值是 max_result_window ，默认 为 10000 。也就是当 from + size &gt; max_result_window 时，es 将返回错误</p><h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4><p>使用scroll，每次只能获取一页的内容，然后会返回一个scrollid，根据scrollid可以不断地获取下一页的内容，所以scroll并不适用于有跳页的情景。但是在真正的使用场景中，第10000条数据已经是很后面的数据了，可以“折衷”一下，不提供跳转页面功能，只能下一页的翻页。</p><blockquote><p>Scroll方式通过一次查询请求后维护一个临时的索引快照的search context<br>此后的增删查改操作并不会影响这个快照数据信息，后续的查询只需要根据游标去取数据，直到结果集中返回的 hits 字段为空，就表示遍历结束。效率比较高。在5.x之后，还可以通过slice分片来实现并行导出。</p></blockquote><h4 id="search-after"><a href="#search-after" class="headerlink" title="search_after"></a>search_after</h4><p>searchAfter的方式通过维护一个实时游标来避免scroll的缺点，它可以用于实时请求和高并发场景。</p><p>它的缺点是不能够随机跳转分页，只能是一页一页的向后翻，并且需要至少指定一个唯一不重复字段来排序(注:每个文档具有一个唯一值的字段应该用作排序规范的仲裁器。否则，具有相同排序值的文档的排序顺序将是未定义的。建议的方法是使用字段_id，它肯定包含每个文档的一个唯一值)。</p><h3 id="倒排索引的原理（字节-高德）"><a href="#倒排索引的原理（字节-高德）" class="headerlink" title="倒排索引的原理（字节 高德）"></a>倒排索引的原理（字节 高德）</h3><ul><li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html#inverted-index" target="_blank" rel="noopener">倒排索引</a></li></ul><p>倒排索引由两个部分组成：单词词典和倒排文件。</p><ul><li>单词词典: 单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</li><li>倒排文件: 所有单词的倒排列表顺序的存储在磁盘的某个文件里，这个文件即被称为倒排文件，倒排文件是存储倒排索引的物理文件。</li></ul><h3 id="lsm-树原理（字节）"><a href="#lsm-树原理（字节）" class="headerlink" title="lsm 树原理（字节）"></a>lsm 树原理（字节）</h3><blockquote><p>LSM树（Log Structured Merge Tree，结构化合并树）的思想非常朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘（由此提升了写性能），是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销。</p></blockquote><h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><h3 id="kafka-的架构，大致储存结构（高德-字节-滴滴）"><a href="#kafka-的架构，大致储存结构（高德-字节-滴滴）" class="headerlink" title="kafka 的架构，大致储存结构（高德 字节 滴滴）"></a>kafka 的架构，大致储存结构（高德 字节 滴滴）</h3><h3 id="如果消费者数超过分区数会怎么样？（顺丰-滴滴）"><a href="#如果消费者数超过分区数会怎么样？（顺丰-滴滴）" class="headerlink" title="如果消费者数超过分区数会怎么样？（顺丰 滴滴）"></a>如果消费者数超过分区数会怎么样？（顺丰 滴滴）</h3><h3 id="怎么保证数据的可靠投递？（陌陌-字节）"><a href="#怎么保证数据的可靠投递？（陌陌-字节）" class="headerlink" title="怎么保证数据的可靠投递？（陌陌 字节）"></a>怎么保证数据的可靠投递？（陌陌 字节）</h3><h3 id="消费者的-offset-存在哪里？（字节-腾讯-陌陌）"><a href="#消费者的-offset-存在哪里？（字节-腾讯-陌陌）" class="headerlink" title="消费者的 offset 存在哪里？（字节 腾讯 陌陌）"></a>消费者的 offset 存在哪里？（字节 腾讯 陌陌）</h3><h3 id="如何通过-offset-定位消息？（字节）"><a href="#如何通过-offset-定位消息？（字节）" class="headerlink" title="如何通过 offset 定位消息？（字节）"></a>如何通过 offset 定位消息？（字节）</h3><h3 id="时间轮的原理（陌陌-顺丰）"><a href="#时间轮的原理（陌陌-顺丰）" class="headerlink" title="时间轮的原理（陌陌 顺丰）"></a>时间轮的原理（陌陌 顺丰）</h3><h3 id="kafka-写入高性能的原因，sendfile-和-mmap-原理，为什么不用-splice（滴滴）"><a href="#kafka-写入高性能的原因，sendfile-和-mmap-原理，为什么不用-splice（滴滴）" class="headerlink" title="kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice（滴滴）"></a>kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice（滴滴）</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="https-原理，tls-握手需要几个-rtt？（滴滴-百度）"><a href="#https-原理，tls-握手需要几个-rtt？（滴滴-百度）" class="headerlink" title="https 原理，tls 握手需要几个 rtt？（滴滴 百度）"></a>https 原理，tls 握手需要几个 rtt？（滴滴 百度）</h3><blockquote><p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。</p><ul><li><a href="https://juejin.cn/post/6844903830916694030" target="_blank" rel="noopener">深入理解HTTPS工作原理</a> </li></ul></blockquote><blockquote><p>SSL(Secure Socket Layer 安全套接字层) / TLS(Transport Layer Security 传输层安全协议)<br>RTT(Round Trip Time 往返时间)</p></blockquote><p>TLS 握手就需要消耗两个 RTT<br>在 TLS 1.2 中，我们需要 2-RTT 才能建立 TLS 连接10，但是 TLS 1.3 通过优化协议，将两次往返延迟降低至一次</p><ul><li><a href="https://draveness.me/whys-the-design-https-latency/" target="_blank" rel="noopener">为什么 HTTPS 需要 7 次握手以及 9 倍时延</a></li></ul><p>总结一下 HTTPS 协议需要 9 倍时延才能完成通信的原因：</p><ol><li>TCP 协议需要通过三次握手建立 TCP 连接保证通信的可靠性（1.5-RTT）</li><li>TLS 协议会在 TCP 协议之上通过四次握手建立 TLS 连接保证通信的安全性（2-RTT）</li><li>HTTP 协议会在 TCP 和 TLS 上通过一次往返发送请求并接收响应（1-RTT）</li></ol><h3 id="浏览器访问某个网址的详细过程，四次挥手（腾讯-滴滴）"><a href="#浏览器访问某个网址的详细过程，四次挥手（腾讯-滴滴）" class="headerlink" title="浏览器访问某个网址的详细过程，四次挥手（腾讯 滴滴）"></a>浏览器访问某个网址的详细过程，四次挥手（腾讯 滴滴）</h3><ol><li>获得域名所对应的IP地址，若DNS缓存中没有相关数据，则浏览器向DNS服务器发出DNS请求，以获取域名所对应的IP地址。</li><li>浏览器与域名地址建立TCP连接，三次握手</li><li>HTTP访问</li><li>断开TCP链接, 四次挥手</li></ol><h3 id="http2-和-quic-原理（字节）"><a href="#http2-和-quic-原理（字节）" class="headerlink" title="http2 和 quic 原理（字节）"></a>http2 和 quic 原理（字节）</h3><h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><ol><li>二进制分帧(Binary Format)</li><li>多路复用(Multiplexing)/连接共享</li><li>头部压缩(Header Compression)</li><li>压缩原理</li><li>请求优先级(Request Priorities)</li><li>服务端推送(Server Push)</li></ol><h4 id="Quic"><a href="#Quic" class="headerlink" title="Quic"></a>Quic</h4><blockquote><p>Quic (Quick Udp Internet Connection 快速UDP互联网连接)</p></blockquote><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势</p><ol><li>减少了 TCP 三次握手及 TLS 握手时间</li><li>改进的拥塞控制</li><li>避免队头阻塞的多路复用</li><li>连接迁移</li><li>前向冗余纠错</li></ol><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="分布式事务怎么处理（高德-陌陌）"><a href="#分布式事务怎么处理（高德-陌陌）" class="headerlink" title="分布式事务怎么处理（高德 陌陌）"></a>分布式事务怎么处理（高德 陌陌）</h3><h3 id="简述-raft-原理（陌陌）"><a href="#简述-raft-原理（陌陌）" class="headerlink" title="简述 raft 原理（陌陌）"></a>简述 raft 原理（陌陌）</h3><h3 id="分布式-id-的几种实现和优缺点（滴滴）"><a href="#分布式-id-的几种实现和优缺点（滴滴）" class="headerlink" title="分布式 id 的几种实现和优缺点（滴滴）"></a>分布式 id 的几种实现和优缺点（滴滴）</h3><h3 id="降级-限流-熔断实现原理（高德-陌陌）"><a href="#降级-限流-熔断实现原理（高德-陌陌）" class="headerlink" title="降级 限流 熔断实现原理（高德 陌陌）"></a>降级 限流 熔断实现原理（高德 陌陌）</h3><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计秒杀系统，需要支持-100W-以上-QPS（滴滴）"><a href="#设计秒杀系统，需要支持-100W-以上-QPS（滴滴）" class="headerlink" title="设计秒杀系统，需要支持 100W 以上 QPS（滴滴）"></a>设计秒杀系统，需要支持 100W 以上 QPS（滴滴）</h3><h3 id="设计微博首页，需要拉取所有关注用户的最近-20-条微博（百度）"><a href="#设计微博首页，需要拉取所有关注用户的最近-20-条微博（百度）" class="headerlink" title="设计微博首页，需要拉取所有关注用户的最近 20 条微博（百度）"></a>设计微博首页，需要拉取所有关注用户的最近 20 条微博（百度）</h3><h3 id="抢红包算法设计（百度-滴滴）"><a href="#抢红包算法设计（百度-滴滴）" class="headerlink" title="抢红包算法设计（百度 滴滴）"></a>抢红包算法设计（百度 滴滴）</h3><h3 id="设计一个短链系统（百度）"><a href="#设计一个短链系统（百度）" class="headerlink" title="设计一个短链系统（百度）"></a>设计一个短链系统（百度）</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="布隆过滤器的实现原理和使用场景（滴滴）"><a href="#布隆过滤器的实现原理和使用场景（滴滴）" class="headerlink" title="布隆过滤器的实现原理和使用场景（滴滴）"></a>布隆过滤器的实现原理和使用场景（滴滴）</h3><h3 id="进程间通信有哪几种方式（腾讯）"><a href="#进程间通信有哪几种方式（腾讯）" class="headerlink" title="进程间通信有哪几种方式（腾讯）"></a>进程间通信有哪几种方式（腾讯）</h3><h3 id="进程线程协程区别（滴滴-知乎）"><a href="#进程线程协程区别（滴滴-知乎）" class="headerlink" title="进程线程协程区别（滴滴 知乎）"></a>进程线程协程区别（滴滴 知乎）</h3><h3 id="lvs-原理，如何保证高可用（滴滴）"><a href="#lvs-原理，如何保证高可用（滴滴）" class="headerlink" title="lvs 原理，如何保证高可用（滴滴）"></a>lvs 原理，如何保证高可用（滴滴）</h3><h3 id="502-504-什么原因，如何处理（滴滴-百度-腾讯-顺丰）"><a href="#502-504-什么原因，如何处理（滴滴-百度-腾讯-顺丰）" class="headerlink" title="502 504 什么原因，如何处理（滴滴 百度 腾讯 顺丰）"></a>502 504 什么原因，如何处理（滴滴 百度 腾讯 顺丰）</h3><h3 id="给你两个一模一样的玻璃球，求出-100-层楼哪一层开始玻璃球会被摔碎（腾讯）"><a href="#给你两个一模一样的玻璃球，求出-100-层楼哪一层开始玻璃球会被摔碎（腾讯）" class="headerlink" title="给你两个一模一样的玻璃球，求出 100 层楼哪一层开始玻璃球会被摔碎（腾讯）"></a>给你两个一模一样的玻璃球，求出 100 层楼哪一层开始玻璃球会被摔碎（腾讯）</h3><h3 id="一致性-hash-原理，怎么解决节点少数据倾斜的问题（滴滴-陌陌）"><a href="#一致性-hash-原理，怎么解决节点少数据倾斜的问题（滴滴-陌陌）" class="headerlink" title="一致性 hash 原理，怎么解决节点少数据倾斜的问题（滴滴 陌陌）"></a>一致性 hash 原理，怎么解决节点少数据倾斜的问题（滴滴 陌陌）</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;面试造火箭 上班拧螺丝&lt;br&gt;“茴香豆的『回』字有几种写法你知道么”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 死信队列 延迟队列 惰性队列</title>
    <link href="http://blog.caoxl.com/2022/02/18/RabbitMQ-Learn-More-III/"/>
    <id>http://blog.caoxl.com/2022/02/18/RabbitMQ-Learn-More-III/</id>
    <published>2022-02-18T09:08:42.000Z</published>
    <updated>2022-02-18T09:41:21.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本篇是RabbitMQ 再深入III</p></blockquote><a id="more"></a><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><blockquote><p>死信队列: DLX, dead-letter-exchange</p></blockquote><h2 id="死信队列的产生"><a href="#死信队列的产生" class="headerlink" title="死信队列的产生"></a>死信队列的产生</h2><ol><li>消息被拒绝(<code>basic.reject</code> / <code>basic.nack</code>)，并且<code>requeue = false</code></li><li>消息TTL过期</li><li>队列达到最大长度</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">RabbitMQ</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">require_once</span> <span class="string">'../vendor/autoload.php'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">Exception</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Wire</span>\<span class="title">AMQPTable</span>;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Class RabbitMQ</span><br><span class="line"> * @package RabbitMQ</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">RabbitMQ</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line">    /**</span><br><span class="line">     * 生产延迟消息队列</span><br><span class="line">     * @param array $message_data</span><br><span class="line">     * @param int $ttl 单位: 秒</span><br><span class="line">     * @param int $max_delay_second 单位: 秒</span><br><span class="line">     * @param bool $need_time_suffix</span><br><span class="line">     * @throws Exception</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delayProduce</span><span class="params">(array $message_data, int $ttl, int $max_delay_second = <span class="number">0</span>, bool $need_time_suffix = false)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $connection = <span class="keyword">new</span> AMQPStreamConnection(<span class="string">'rabbitmq'</span>, <span class="number">5672</span>, <span class="string">'banana'</span>, <span class="string">'123456'</span>, <span class="string">'banana'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $channel = $connection-&gt;channel();</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $queue = <span class="string">'dead_letter_queue'</span>;</span></span><br><span class="line"><span class="php">        $exchange_name = <span class="string">'dead_letter_exchange'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $delay_table = <span class="keyword">new</span> AMQPTable();</span></span><br><span class="line"><span class="php">        <span class="comment">// 设置死信交换机</span></span></span><br><span class="line"><span class="php">        $delay_table-&gt;set(<span class="string">'x-dead-letter-exchange'</span>, <span class="string">"delay_$exchange_name"</span>);</span></span><br><span class="line"><span class="php">        <span class="comment">// 设置死信路由键</span></span></span><br><span class="line"><span class="php">        $delay_table-&gt;set(<span class="string">'x-dead-letter-routing-key'</span>, <span class="string">"delay_$queue"</span>);</span></span><br><span class="line"><span class="php">        <span class="comment">// 死信队列消息存活时间, 单位: 毫秒</span></span></span><br><span class="line"><span class="php">        $delay_table-&gt;set(<span class="string">'x-message-ttl'</span>, $max_delay_second * <span class="number">1000</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $suffix = $need_time_suffix ? <span class="string">"_&#123;$ttl&#125;"</span> : <span class="string">''</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">        <span class="comment">// 普通队列, 消息过期写入死信队列</span></span></span><br><span class="line"><span class="php">        $channel-&gt;queue_declare(<span class="string">"ttl_&#123;$queue&#125;&#123;$suffix&#125;"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, $delay_table);</span></span><br><span class="line"><span class="php">        <span class="comment">// 这里是ttl队列, 所以交换机这里要durable是false</span></span></span><br><span class="line"><span class="php">        $channel-&gt;exchange_declare(<span class="string">"ttl_&#123;$exchange_name&#125;&#123;$suffix&#125;"</span>, <span class="string">'direct'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">        $channel-&gt;queue_bind(<span class="string">"ttl_&#123;$queue&#125;&#123;$suffix&#125;"</span>,  <span class="string">"ttl_&#123;$exchange_name&#125;&#123;$suffix&#125;"</span>, <span class="string">"ttl_&#123;$queue&#125;&#123;$suffix&#125;"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        <span class="comment">// 死信队列, 正常消耗</span></span></span><br><span class="line"><span class="php">        $channel-&gt;queue_declare(<span class="string">"delay_$queue"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">        $channel-&gt;exchange_declare(<span class="string">"delay_&#123;$exchange_name&#125;"</span>, <span class="string">'direct'</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>);</span></span><br><span class="line"><span class="php">        $channel-&gt;queue_bind(<span class="string">"delay_&#123;$queue&#125;"</span>, <span class="string">"delay_&#123;$exchange_name&#125;"</span>, <span class="string">"delay_&#123;$queue&#125;"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        <span class="comment">// 消息过期时间</span></span></span><br><span class="line"><span class="php">        <span class="comment">// 1. 若消息在队列头: 消息过期时间与队列消息过期时间取最小值</span></span></span><br><span class="line"><span class="php">        <span class="comment">// 例如: x-message-ttl=30000, expiration=5000, 则5秒过期</span></span></span><br><span class="line"><span class="php">        <span class="comment">// 2. 若消息在队列中: 先消耗之前的消息,才能消耗,即使已过期也继续等待</span></span></span><br><span class="line"><span class="php">        <span class="comment">// 例如: x-message-ttl=30000 expiration: 消息1=25000 消息2=5000, 则两个消息均25秒过期</span></span></span><br><span class="line"><span class="php">        $message = <span class="keyword">new</span> AMQPMessage(</span></span><br><span class="line"><span class="php">            serialize($message_data),</span></span><br><span class="line"><span class="php">            [</span></span><br><span class="line"><span class="php">                <span class="string">'content_type'</span> =&gt; <span class="string">'text/plain'</span>,</span></span><br><span class="line"><span class="php">                <span class="string">'expiration'</span> =&gt; $ttl * <span class="number">1000</span>, <span class="comment">// 单位: 毫秒</span></span></span><br><span class="line"><span class="php">                <span class="string">'delivery_mode'</span> =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT</span></span><br><span class="line"><span class="php">            ]</span></span><br><span class="line"><span class="php">        );</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $channel-&gt;basic_publish($message, <span class="string">"ttl_&#123;$exchange_name&#125;&#123;$suffix&#125;"</span>, <span class="string">"ttl_&#123;$queue&#125;&#123;$suffix&#125;"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="php">        $channel-&gt;close();</span></span><br><span class="line"><span class="php">        $connection-&gt;close();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">$message_data = [<span class="string">'Test Dead Letter'</span>];</span></span><br><span class="line"><span class="php">$ttl = <span class="number">5</span>;</span></span><br><span class="line"><span class="php">$max_delay_second = <span class="number">30</span>;</span></span><br><span class="line"><span class="php">$need_time_suffix = <span class="keyword">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="php">    (<span class="keyword">new</span> RabbitMQ())-&gt;delayProduce($message_data, $ttl, $max_delay_second, $need_time_suffix);</span></span><br><span class="line"><span class="php">&#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">echo</span> <span class="string">"异常消息: "</span> . $e-&gt;getMessage();</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><p>使用DLX（死信交换机）+TTL（消息超时时间）实现</p><blockquote><p>假如一条消息需要延迟 30 分钟执行，我们就设置这条消息的有效期为 30 分钟，同时为这条消息配置死信交换机和死信 routing_key，并且不为这个消息队列设置消费者，那么 30 分钟后，这条消息由于没有被消费者消费而进入死信队列，此时我们有一个消费者就在“蹲点”这个死信队列，消息一进入死信队列，就立马被消费了。</p></blockquote><h1 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h1><blockquote><p>惰性队列会尽可能的将消息存入磁盘中，在消费者消费到相应的消息时才会被加载到内存中。</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$table = new AMQPTable();</span><br><span class="line">$table-&gt;set('x-queue-mode', "lazy");</span><br><span class="line">$channel-&gt;queue_declare($queueName, false, true, false, false, false, $table);</span><br><span class="line">$channel-&gt;queue_bind($queueName, $exchangeName, $routingKey);</span><br></pre></td></tr></table></figure><ul><li><p>优点</p><ul><li><ol><li>它可以存储更多消息支持更长队列因为消息在硬盘中。</li></ol></li><li><ol start="2"><li>惰性队列可以避免消息堆积导致的内存崩溃。</li></ol></li></ul></li><li><p>缺点</p><ul><li><ol><li>需要i/o 增加磁盘i/o。</li></ol></li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://codeantenna.com/a/hleDRA33XX" target="_blank" rel="noopener">RabbitMQ 惰性队列</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇是RabbitMQ 再深入III&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="RabbitMQ" scheme="http://blog.caoxl.com/tags/RabbitMQ/"/>
    
      <category term="死信队列" scheme="http://blog.caoxl.com/tags/%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="延迟队列" scheme="http://blog.caoxl.com/tags/%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
    
      <category term="惰性队列" scheme="http://blog.caoxl.com/tags/%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>MySQL8 CTE和窗口函数的用法</title>
    <link href="http://blog.caoxl.com/2022/01/06/MySQL8-CTE-WF/"/>
    <id>http://blog.caoxl.com/2022/01/06/MySQL8-CTE-WF/</id>
    <published>2022-01-06T02:00:34.000Z</published>
    <updated>2022-01-06T06:15:08.846Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>普通统计函数在每个分组内只能返回一条记录。而新增加的窗口函数和CTE函数可以一个分组返回多条函数。</p><a id="more"></a><h1 id="窗口函数-amp-CTE实操"><a href="#窗口函数-amp-CTE实操" class="headerlink" title="窗口函数&amp;CTE实操"></a>窗口函数&amp;CTE实操</h1><ul><li>一张表结构如下</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc mytest;</span><br><span class="line">+--------+------------------+------+-----+---------+----------------+</span><br><span class="line">| Field  | Type             | Null | Key | Default | Extra          |</span><br><span class="line">+--------+------------------+------+-----+---------+----------------+</span><br><span class="line">| id     | int(11) unsigned | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name   | varchar(255)     | NO   |     | NULL    |                |</span><br><span class="line">| course | varchar(255)     | NO   |     | NULL    |                |</span><br><span class="line">| score  | decimal(10,0)    | NO   |     | NULL    |                |</span><br><span class="line">+--------+------------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><ul><li>它有以下数据</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from mytest;</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">| id | name   | course | score |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">|  1 | 汤姆 | 数学 | 100   |</span><br><span class="line">|  2 | 汤姆 | 语文 | 90    |</span><br><span class="line">|  3 | 汤姆 | 英语 | 80    |</span><br><span class="line">|  4 | 汤姆 | 化学 | 100   |</span><br><span class="line">|  5 | 汤姆 | 物理 | 99    |</span><br><span class="line">|  6 | 杰克 | 数学 | 90    |</span><br><span class="line">|  7 | 杰克 | 语文 | 100   |</span><br><span class="line">|  8 | 杰克 | 英语 | 80    |</span><br><span class="line">|  9 | 杰克 | 化学 | 90    |</span><br><span class="line">| 10 | 杰克 | 物理 | 70    |</span><br><span class="line">| 11 | 可可 | 数学 | 90    |</span><br><span class="line">| 12 | 可可 | 语文 | 92    |</span><br><span class="line">| 13 | 可可 | 英语 | 93    |</span><br><span class="line">| 14 | 可可 | 化学 | 94    |</span><br><span class="line">| 15 | 可可 | 物理 | 75    |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">15 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>问题: 要查询出每一科最高分学生的学号，姓名，成绩和科目。在MySQL8之前主要是通过下面的方式来实现。</p><p>答案1: MySql 8之前的方法</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   SELECT x.id,x.NAME,x.course,x.score FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line"><span class="code">t.*,</span></span><br><span class="line">IF</span><br><span class="line"><span class="code">( @_course = t.course, @rn := @rn + 1, @rn := 1 ) AS rn,</span></span><br><span class="line"><span class="code">@_course := t.course AS _course </span></span><br><span class="line">FROM</span><br><span class="line"><span class="code">( SELECT t.* FROM mytest t ORDER BY course, score DESC ) t,</span></span><br><span class="line"><span class="code">( SELECT @rn := 0 rn, @_course := '' ) b </span></span><br><span class="line">) x </span><br><span class="line">   WHERE rn = 1 ORDER BY course;</span><br><span class="line">   </span><br><span class="line">   +----+--------+--------+-------+</span><br><span class="line">   | id | NAME   | course | score |</span><br><span class="line">   +----+--------+--------+-------+</span><br><span class="line">   |  4 | 汤姆   | 化学   |   100 |</span><br><span class="line">   |  1 | 汤姆   | 数学   |   100 |</span><br><span class="line">   |  5 | 汤姆   | 物理   |    99 |</span><br><span class="line">   | 13 | 可可   | 英语   |    93 |</span><br><span class="line">   |  7 | 杰克   | 语文   |   100 |</span><br><span class="line">   +----+--------+--------+-------+</span><br><span class="line">   5 rows in set, 5 warnings (0.00 sec)</span><br></pre></td></tr></table></figure><p>这个sql虽然高效，但是可读性不强。接下来我们来看看窗口函数怎么实现</p><p>答案2: 使用窗口函数ROW_NUMBER</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line"> id,name,course,score </span><br><span class="line">FROM</span><br><span class="line"><span class="code">    ( SELECT *,row_number() over ( PARTITION BY course ORDER BY score DESC ) AS rn FROM mytest ) t </span></span><br><span class="line">WHERE</span><br><span class="line"><span class="code">    rn = 1;</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">| id | name   | course | score |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">|  4 | 汤姆   | 化学   |   100 |</span><br><span class="line">|  1 | 汤姆   | 数学   |   100 |</span><br><span class="line">|  5 | 汤姆   | 物理   |    99 |</span><br><span class="line">| 13 | 可可   | 英语   |    93 |</span><br><span class="line">|  7 | 杰克   | 语文   |   100 |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>答案3: 使用CTE方式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WITH cte AS ( SELECT *,row_number() over ( PARTITION BY course ORDER BY score DESC ) AS rn FROM mytest ) </span><br><span class="line">SELECT id,name,course,score FROM cte WHERE rn = 1;</span><br><span class="line"></span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">| id | name   | course | score |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">|  4 | 汤姆   | 化学   |   100 |</span><br><span class="line">|  1 | 汤姆   | 数学   |   100 |</span><br><span class="line">|  5 | 汤姆   | 物理   |    99 |</span><br><span class="line">| 13 | 可可   | 英语   |    93 |</span><br><span class="line">|  7 | 杰克   | 语文   |   100 |</span><br><span class="line">+----+--------+--------+-------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>通过对比上面的三种答案，发现CTE和窗口函数极大简化了我们的sql语句。我们的sql更容易读懂。</p><h1 id="通用表表达式（Common-Table-Expressions）"><a href="#通用表表达式（Common-Table-Expressions）" class="headerlink" title="通用表表达式（Common Table Expressions）"></a>通用表表达式（Common Table Expressions）</h1><p>复杂的查询会使用嵌入式表，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   SELECT t1.<span class="emphasis">*,t2.*</span> FROM</span><br><span class="line">( SELECT col1 FROM table1 ) t1,</span><br><span class="line">( SELECT col2 FROM table2 ) t2;</span><br></pre></td></tr></table></figure><p>而有了 CTE，我们可以这样写：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WITH</span><br><span class="line">t1 AS (SELECT col1 FROM table1),</span><br><span class="line">t2 AS (SELECT col2 FROM table2)</span><br><span class="line">SELECT t1.<span class="emphasis">*, t2.*</span> FROM t1, t2;</span><br></pre></td></tr></table></figure><p>这样看上去层次和区域都更加分明，改起来也更清晰的知道要改哪一部分。</p><h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><h2 id="什么是窗口函数"><a href="#什么是窗口函数" class="headerlink" title="什么是窗口函数"></a>什么是窗口函数</h2><p>窗口函数引入的其实不只是几个函数，而是一套完整的语法，窗口函数是此语法中的一部分。</p><blockquote><p>窗口函数 over 窗口表达式。</p></blockquote><p>over是窗口函数语法的关键字。</p><h2 id="窗口函数-1"><a href="#窗口函数-1" class="headerlink" title="窗口函数"></a>窗口函数</h2><ul><li><ol><li>序号函数: <code>row_number()</code>, <code>rank()</code>, <code>dense_rank()</code></li></ol></li><li><ol start="2"><li>分布函数: <code>percent_rank()</code>, <code>cume_dist()</code></li></ol></li><li><ol start="3"><li>前后函数: <code>lead()</code>, <code>lag()</code></li></ol></li><li><ol start="4"><li>头尾函数: <code>fist_val()</code>, <code>last_val()</code></li></ol></li><li><ol start="5"><li>其他函数: <code>nth_value()</code>, <code>nfile()</code></li></ol></li></ul><h3 id="窗口函数的两种写法"><a href="#窗口函数的两种写法" class="headerlink" title="窗口函数的两种写法"></a>窗口函数的两种写法</h3><ol><li>over关键词后直接定义窗口</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">  row<span class="emphasis">_number() over (partition by user_</span>no order by amount desc),</span><br><span class="line">  order_id</span><br><span class="line">from order_tab;</span><br></pre></td></tr></table></figure><ol start="2"><li>over关键字后使用窗口别名：</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line"><span class="code">    row_number() over w,</span></span><br><span class="line"><span class="code">    order_id</span></span><br><span class="line">from order_tab</span><br><span class="line">WINDOW w AS (partition by user_no order by amount desc);</span><br></pre></td></tr></table></figure><h2 id="窗口表达式语法"><a href="#窗口表达式语法" class="headerlink" title="窗口表达式语法"></a>窗口表达式语法</h2><h3 id="PARTITION-BY子句"><a href="#PARTITION-BY子句" class="headerlink" title="PARTITION BY子句"></a>PARTITION BY子句</h3><p>PARTITION BY子句是用来分组的，从字面上来看，应该叫分区。理解上可以类比group by。</p><p>某行记录所在的分区就是这行对应的窗口。一个窗口可以包含多行，就像group by分的组一样。</p><blockquote><p>PARTITION BY &lt;<code>expression</code>&gt;[{,&lt;<code>expression</code>&gt;…}]</p></blockquote><p>其中的<code>expression</code>表达式，可以是列名，也可以是某个计算结果。如果是列名，就代表简单的按照列的值分区。<br>可以支持按照多个表达式或列来分区。<br>根据每行记录的值，可以确定每行属于哪个分区，也就是哪个窗口。</p><h3 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h3><p>order by子句是排序用的，决定了属于同一个窗口的行记录的排序方式。语法很简单：</p><blockquote><p>ORDER BY &lt;<code>expression</code>&gt; [ASC|DESC] [{,&lt;<code>expression</code>&gt;…}]</p></blockquote><p>和MySQL中原有的order by关键字意思差不多。原有的order by关键字是所有查询结果一起排序，窗口函数的order by子句是对某个窗口中的行记录进行排序。</p><h3 id="frame子句"><a href="#frame子句" class="headerlink" title="frame子句"></a>frame子句</h3><p>frame子句定义了窗口中的一个子窗口，子集。这个稍微麻烦点，语法是：</p><blockquote><p>frame_unit {&lt;<code>frame_start</code>&gt;|&lt;<code>frame_between</code>&gt;}</p></blockquote><ul><li><code>frame_unit</code>有两种选择，<strong>ROWS</strong>和<strong>RANGE</strong>，ROWS代表按起止位置标识子集，RANGE代表按起止值标识子集。</li><li><code>frame_start</code>标识子窗口的开始位置，结束位置默认是当前行。</li><li><code>frame_between</code>是用BETWEEN AND关键字来标识子窗口的起止位置。</li></ul><h2 id="窗口函数介绍"><a href="#窗口函数介绍" class="headerlink" title="窗口函数介绍"></a>窗口函数介绍</h2><h3 id="序号函数-row-number-rank-dense-rank"><a href="#序号函数-row-number-rank-dense-rank" class="headerlink" title="序号函数: row_number(), rank(), dense_rank()"></a>序号函数: <code>row_number()</code>, <code>rank()</code>, <code>dense_rank()</code></h3><blockquote><p>序号函数的作用是显示分区中每行的行号。</p></blockquote><ul><li><code>row_number()</code>：排序字段相同时，行号随机排，下一行行号正常加1。显然此函数得到的行号是连续的。</li><li><code>rank()</code>：排序字段相同时，行号相同，下一行行号按照排名确定。这个逻辑比较像是现实中的排名规则，当出现并列冠军时，第三个人排名第三，没有亚军。显然此函数得到的行号是不连续的。</li><li><code>dense_rank()</code>：排序字段相同时，行号相同，下一行行号顺序加1。也就是出现冠军时，第三个人排名是第二。显然此函数得到的行号是连续的。</li></ul><h3 id="分布函数-percent-rank-cume-dist"><a href="#分布函数-percent-rank-cume-dist" class="headerlink" title="分布函数: percent_rank(), cume_dist()"></a>分布函数: <code>percent_rank()</code>, <code>cume_dist()</code></h3><blockquote><p>分布函数得到的是一个百分比，计算公式用到rank()函数。</p></blockquote><ul><li><code>percent_rank()</code>: 实际计算公式：(rank()-1)/(rows-1)</li><li><code>cume_dist()</code>: 实际计算公式：rank()/rows</li></ul><h3 id="前后函数-lead-lag"><a href="#前后函数-lead-lag" class="headerlink" title="前后函数: lead(), lag()"></a>前后函数: <code>lead()</code>, <code>lag()</code></h3><ul><li><code>lead(expr,n)</code>: 代表当前行前面第n行记录的expr表达式（或字段值）。</li><li><code>lag(expr,n)</code>: 代表当前行后面的第n行记录的expr表达式（或字段值）。</li></ul><p>比如lead(add_time,1)就代表当前行前面一行的add_time字段。</p><h3 id="头尾函数-fist-val-last-val"><a href="#头尾函数-fist-val-last-val" class="headerlink" title="头尾函数: fist_val(), last_val()"></a>头尾函数: <code>fist_val()</code>, <code>last_val()</code></h3><ul><li><code>first_val(expr)</code>: 代表分区第一行记录的expr表达式（或字段值）。</li><li><code>last_val(expr)</code>: 代表分区最后一行记录的expr表达式（或字段值）。</li></ul><h3 id="其他函数-nth-value-nfile"><a href="#其他函数-nth-value-nfile" class="headerlink" title="其他函数: nth_value(), nfile()"></a>其他函数: <code>nth_value()</code>, <code>nfile()</code></h3><ul><li><code>nth_value(expr,n)</code>: 代表区间第n条记录的expr表达式（或字段值）。<br>比如：nth_value(amount,2)代表区间第二行的amount字段。</li><li><code>nfile(n)</code>: 代表把区间列分为n个组，返回组号。  </li></ul><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><ul><li><a href="https://mysql.bookhub.zone/#/README" target="_blank" rel="noopener">MySQL 8.0 中文手册</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/with.html" target="_blank" rel="noopener">MySQL8 WITH (Common Table Expressions)</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html" target="_blank" rel="noopener">MySQL8 窗口函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;普通统计函数在每个分组内只能返回一条记录。而新增加的窗口函数和CTE函数可以一个分组返回多条函数。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://blog.caoxl.com/categories/MySQL/"/>
    
    
      <category term="MySQL8" scheme="http://blog.caoxl.com/tags/MySQL8/"/>
    
      <category term="CTE" scheme="http://blog.caoxl.com/tags/CTE/"/>
    
      <category term="窗口函数" scheme="http://blog.caoxl.com/tags/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存那点破事</title>
    <link href="http://blog.caoxl.com/2021/12/24/Redis-Something/"/>
    <id>http://blog.caoxl.com/2021/12/24/Redis-Something/</id>
    <published>2021-12-24T08:51:06.000Z</published>
    <updated>2021-12-24T09:58:25.569Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>转载, 原文地址<a href="https://blog.csdn.net/itomge/article/details/122118060" target="_blank" rel="noopener">Redis缓存那点破事 ， 绝杀面试官 25 问</a></p></blockquote><a id="more"></a><h2 id="Redis-有哪些特性？"><a href="#Redis-有哪些特性？" class="headerlink" title="Redis 有哪些特性？"></a>Redis 有哪些特性？</h2><ul><li>性能高， 读的速度是100000次/s，写的速度是80000次/s</li><li>数据持久化，支持RDB 、AOF</li><li>支持事务。通过<code>MULTI</code>和<code>EXEC</code>指令包起来。</li><li>多种数据结构类型</li><li>主从复制</li><li>其他特性：发布/订阅、通知、key过期等</li></ul><h2 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h2><ul><li>完全基于内存，没有磁盘IO上的开销，异步持久化除外</li><li>单线程，避免多个线程切换的性能损耗</li><li>非阻塞的IO多路复用机制</li><li>底层的数据存储结构优化，使用原生的数据结构提升性能。</li></ul><h2 id="Redis-底层的基础数据结构有哪些？"><a href="#Redis-底层的基础数据结构有哪些？" class="headerlink" title="Redis 底层的基础数据结构有哪些？"></a>Redis 底层的基础数据结构有哪些？</h2><ul><li>字符串。没有采用C语言的传统字符串，而是自己实现的一个简单动态字符串SDS的抽象类型，并保存了长度信息。</li><li>链表（linkedlist）。双向无环链表结构，每个链表的节点由一个listNode结构来表示，每个节点都有前置和后置节点的指针</li><li>字典（hashtable）。保存键值对的抽象数据结构，底层使用hash表，每个字典带有两个hash表，供平时使用和rehash时使用。</li><li>跳跃表（skiplist）。跳跃表是有序集合的底层实现之一。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表 信息(表头、表尾节点、⻓度等)，zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1- 32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。</li><li>整数集合（intset）。用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</li><li>压缩列表（ziplist）。为节约内存而开发的顺序性数据结构，可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li></ul><h2 id="Redis-支持哪些数据类型？"><a href="#Redis-支持哪些数据类型？" class="headerlink" title="Redis 支持哪些数据类型？"></a>Redis 支持哪些数据类型？</h2><p>五种常用数据类型：<code>String</code>、<code>Hash</code>、<code>Set</code>、<code>List</code>、<code>SortedSet</code>。三种特殊的数据类型：<code>Bitmap</code>、<code>HyperLogLog</code>、<code>Geospatial</code>，其中<code>Bitmap</code>、<code>HyperLogLog</code>的底层都是 <code>String</code> 数据类型，<code>Geospatial</code> 底层是 <code>Sorted Set</code> 数据类型。</p><ul><li>字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串</li><li>列表对象list：ziplist、linkedlist</li><li>哈希对象hash：ziplist、hashtable</li><li>集合对象set：intset、hashtable</li><li>有序集合对象zset：ziplist、skiplist</li></ul><h2 id="Redis-常用的-5-种数据结构和应用场景？"><a href="#Redis-常用的-5-种数据结构和应用场景？" class="headerlink" title="Redis 常用的 5 种数据结构和应用场景？"></a>Redis 常用的 5 种数据结构和应用场景？</h2><ul><li><code>String</code>：缓存、计数器、分布式锁等</li><li><code>List</code>：链表、队列、微博关注人时间轴列表等</li><li><code>List</code>：链表、队列、微博关注人时间轴列表等</li><li><code>Set</code>：去重、赞、踩、共同好友等</li><li><code>Zset</code>：访问量排行榜、点击量排行榜等</li></ul><h2 id="为什么采用单线程？"><a href="#为什么采用单线程？" class="headerlink" title="为什么采用单线程？"></a>为什么采用单线程？</h2><p>官方回复，CPU不会成为Redis的制约瓶颈，Redis主要受内存、网络限制。例如，在一个普通的 Linux 系统上，使用pipelining 可以每秒传递 100 万个请求，所以如果您的应用程序主要使用 O(N) 或 O(log(N)) 命令，则几乎不会使用太多 CPU，属于IO密集型系统。</p><h2 id="Redis-6-0-之后又改用多线程呢"><a href="#Redis-6-0-之后又改用多线程呢" class="headerlink" title="Redis 6.0 之后又改用多线程呢?"></a>Redis 6.0 之后又改用多线程呢?</h2><p>Redis的多线程主要是处理数据的读写、协议解析。执行命令还是采用单线程顺序执行。</p><p>主要是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程进行一些周边预处理，提升了IO的读写效率，从而提高了整体的吞吐量。antirez 在 RedisConf 2019 分享时提到，Redis 6 引入的多线程 IO 对性能提升至少一倍以上。</p><h2 id="过期键Key-的删除策略有哪些？"><a href="#过期键Key-的删除策略有哪些？" class="headerlink" title="过期键Key 的删除策略有哪些？"></a>过期键Key 的删除策略有哪些？</h2><p>有3种过期删除策略。惰性删除、定期删除、定时删除</p><ul><li><code>惰性删除</code>。使用key时才进行检查，如果已经过期，则删除。缺点：过期的key如果没有被访问到，一直无法删除，一直占用内存，造成空间浪费。</li><li><code>定期删除</code>。每隔一段时间做一次检查，删除过期的key，每次只是随机取一些key去检查。</li><li><code>定时删除</code>。为每个key设置过期时间，同时创建一个定时器。一旦到期，立即执行删除。缺点：如果过期键比较多时，占用CPU较多，对服务的性能有很大影响。</li></ul><h2 id="如果Redis的内存空间不足，淘汰机制"><a href="#如果Redis的内存空间不足，淘汰机制" class="headerlink" title="如果Redis的内存空间不足，淘汰机制?"></a>如果Redis的内存空间不足，淘汰机制?</h2><ul><li><code>volatile-lru</code>：从已设置过期时间的key中，移出最近最少使用的key进行淘汰</li><li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li><code>volatile-ttl</code>：从已设置过期时间的key中，移出将要过期的key</li><li><code>volatile-random</code>：从已设置过期时间的key中，随机选择key淘汰</li><li><code>allkeys-random</code>：从key中随机选择key进行淘汰</li><li><code>no-eviction</code>：禁止淘汰数据。当内存达到阈值的时候，新写入操作报错</li><li><code>volatile-lfu</code>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰(LFU(Least Frequently Used)算法，也就是最频繁被访问的数据将来最有可能被访问到)</li><li><code>allkeys-lfu</code>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。</li></ul><h2 id="Redis-突然挂了怎么解决？"><a href="#Redis-突然挂了怎么解决？" class="headerlink" title="Redis 突然挂了怎么解决？"></a>Redis 突然挂了怎么解决？</h2><ul><li>从系统可用性角度思考，Redis Cluster引入主备机制，当主节点挂了后，自动切换到备用节点，继续提供服务</li><li>Client端引入本地缓存，通过开关切换，避免Redis突然挂掉，高并发流量把数据库打挂。</li></ul><h2 id="Redis-持久化有哪些方式？"><a href="#Redis-持久化有哪些方式？" class="headerlink" title="Redis 持久化有哪些方式？"></a>Redis 持久化有哪些方式？</h2><ul><li>快照<code>RDB</code>。将某个时间点上的数据库状态保存到<code>RDB</code>文件中，<code>RDB</code>文件是一个压缩的二进制文件，保存在磁盘上。当Redis崩溃时，可用于恢复数据。通过<code>SAVE</code>或<code>BGSAVE</code>来生成<code>RDB</code>文件。<ul><li><code>SAVE</code>：会阻塞redis进程，直到RDB文件创建完毕，在进程阻塞期间，redis不能处理任何命令请求。</li><li><code>BGSAVE</code>：会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。</li></ul></li><li>只追加文件<code>AOF</code>。以日志的形式记录每个写操作（非读操作）。当不同节点同步数据时，读取日志文件的内容将写指令从前到后执行一次，即可完成数据恢复。</li></ul><h2 id="Redis-常用场景"><a href="#Redis-常用场景" class="headerlink" title="Redis 常用场景"></a>Redis 常用场景</h2><ul><li>1、缓存，有句话说的好，「性能不够，缓存来凑」</li><li>2、分布式锁，利用Redis 的 <code>setnx</code></li><li>3、分布式session</li><li>4、计数器，通过incr命令</li><li>5、排行榜，Redis 的 有序集合</li><li>6、其他</li></ul><h2 id="Redis-缓存要注意的七大经典问题？"><a href="#Redis-缓存要注意的七大经典问题？" class="headerlink" title="Redis 缓存要注意的七大经典问题？"></a>Redis 缓存要注意的七大经典问题？</h2><p>列举了亿级系统，高访问量情况下Redis缓存可能会遇到哪些问题？以及对应的解决方案。</p><ul><li>1、缓存集中失效</li><li>2、缓存穿透</li><li>3、缓存雪崩</li><li>4、缓存热点</li><li>5、缓存大Key</li><li>6、缓存数据的一致性</li><li>7、数据并发竞争预热</li></ul><h2 id="Redis-集群方案有哪几种？"><a href="#Redis-集群方案有哪几种？" class="headerlink" title="Redis 集群方案有哪几种？"></a>Redis 集群方案有哪几种？</h2><ul><li>主从复制模式</li><li>Sentinel（哨兵）模式</li><li>Redis Cluster模式</li></ul><h2 id="Redis-主从数据同步（主从复制）的过程？"><a href="#Redis-主从数据同步（主从复制）的过程？" class="headerlink" title="Redis 主从数据同步（主从复制）的过程？"></a>Redis 主从数据同步（主从复制）的过程？</h2><ul><li>1、slave启动后，向master发送sync命令</li><li>2、master收到sync之后，执行bgsave保存快照，生成RDB全量文件</li><li>3、master把slave的写命令记录到缓存</li><li>4、bgsave执行完毕之后，发送RDB文件到slave，slave执行</li><li>5、master发送缓冲区的写命令给slave，slave接收命令并执行，完成复制初始化。</li><li>6、此后，master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性</li></ul><h2 id="主从复制的优缺点？"><a href="#主从复制的优缺点？" class="headerlink" title="主从复制的优缺点？"></a>主从复制的优缺点？</h2><ul><li>优点:<ul><li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li><li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li></ul></li><li>缺点:<ul><li>不具备自动容错与恢复功能，master 节点宕机后，需要手动指定新的 master</li><li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li><li>难以支持在线扩容，Redis的容量受限于单机配置</li></ul></li></ul><h2 id="Sentinel（哨兵）模式的优缺点？"><a href="#Sentinel（哨兵）模式的优缺点？" class="headerlink" title="Sentinel（哨兵）模式的优缺点？"></a>Sentinel（哨兵）模式的优缺点？</h2><p>哨兵模式基于主从复制模式，增加了<strong>哨兵来监控</strong>与<strong>自动处理故障</strong>。</p><ul><li>优点:<ul><li>哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有</li><li>master 挂掉可以自动进行切换，系统可用性更高</li></ul></li><li>缺点:<ul><li>Redis的容量受限于单机配置</li><li>需要额外的资源来启动sentinel进程</li></ul></li></ul><h2 id="Redis-Cluster-模式的优缺点？"><a href="#Redis-Cluster-模式的优缺点？" class="headerlink" title="Redis Cluster 模式的优缺点？"></a>Redis Cluster 模式的优缺点？</h2><p>实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。</p><ul><li>优点:<ul><li>无中心架构，数据按照slot分布在多个节点</li><li>集群中的每个节点都是平等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li><li>可线性扩展到1000多个节点，节点可动态添加或删除</li><li>能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换</li></ul></li><li>缺点<ul><li>数据通过异步复制，不保证数据的强一致性</li><li>slave充当 “冷备”，不对外提供读、写服务，只作为故障转移使用。</li><li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好</li><li>key事务操作支持有限，只支持多key在同一节点的事务操作，多key分布在不同节点时无法使用事务功能</li><li>不支持多数据库空间，一台redis可以支持16个db，集群模式下只能使用一个，即db 0。Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</li></ul></li></ul><h2 id="Redis-如何做扩容？"><a href="#Redis-如何做扩容？" class="headerlink" title="Redis 如何做扩容？"></a>Redis 如何做扩容？</h2><p>为了避免数据迁移失效，通常使用一致性哈希实现动态扩容缩容，有效减少需要迁移的Key数量。</p><p>但是Cluster 模式，采用固定Slot槽位方式（16384个），对每个key计算CRC16值，然后对16384取模，然后根据slot值找到目标机器，扩容时，我们只需要迁移一部分的slot到新节点即可。</p><h2 id="Redis-的集群原理"><a href="#Redis-的集群原理" class="headerlink" title="Redis 的集群原理?"></a>Redis 的集群原理?</h2><p>一个redis集群由多个节点<code>node</code>组成，而多个<code>node</code>之间通过<code>cluster meet</code>命令来进行连接，组成一个集群。</p><p>数据存储通过分片的形式，整个集群分成了<code>16384</code>个slot，每个节点负责一部分槽位。整个槽位的信息会同步到所有节点中。</p><p>key与slot的映射关系：</p><ul><li>健值对 key，进行 <code>CRC16</code> 计算，计算出一个 16 bit 的值</li><li>将 16 bit 的值对 16384 取模，得到 0 ～ 16383 的数表示 key 对应的哈希槽</li></ul><h2 id="Redis-如何做到高可用？"><a href="#Redis-如何做到高可用？" class="headerlink" title="Redis 如何做到高可用？"></a>Redis 如何做到高可用？</h2><p>哨兵机制。具有自动故障转移、集群监控、消息通知等功能。</p><p>哨兵可以同时监视所有的主、从服务器，当某个master下线时，自动提升对应的slave为master，然后由新master对外提供服务。</p><h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>Redis事务是一组命令的集合，将多个命令打包，然后把这些命令按顺序添加到队列中，并且按顺序执行这些命令。</p><p>Redis事务中没有像Mysql关系型数据库事务隔离级别的概念，不能保证原子性操作，也没有像Mysql那样执行事务失败会进行回滚操作</p><h2 id="Redis-事务执行流程？"><a href="#Redis-事务执行流程？" class="headerlink" title="Redis 事务执行流程？"></a>Redis 事务执行流程？</h2><p>通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。</p><p>具体过程：</p><ul><li>服务端收到客户端请求，事务以<code>MULTI</code>开始</li><li>如果正处于事务状态时，则会把后续命令放入队列同时返回给客户端<code>QUEUED</code>，反之则直接执行这 个命令</li><li>当收到客户端的<code>EXEC</code>命令时，才会将队列里的命令取出、顺序执行，执行完将当前状态从事务状态改为非事务状态</li><li>如果收到 <code>DISCARD</code> 命令，放弃执行队列中的命令，可以理解为Mysql的回滚操作，并且将当前的状态从事务状态改为非事务状态</li></ul><h2 id="如何实现一个分布式锁？"><a href="#如何实现一个分布式锁？" class="headerlink" title="如何实现一个分布式锁？"></a>如何实现一个分布式锁？</h2><ul><li>1、数据库表，性能比较差</li><li>2、使用Lua脚本 (包含 SETNX + EXPIRE 两条指令)</li><li>3、SET的扩展命令（SET key value [EX][PX] [NX|XX]）</li><li>4、Redlock 框架</li><li>5、Zookeeper Curator框架提供了现成的分布式锁</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载, 原文地址&lt;a href=&quot;https://blog.csdn.net/itomge/article/details/122118060&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis缓存那点破事 ， 绝杀面试官 25 问&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.caoxl.com/tags/PHP/"/>
    
      <category term="Redis" scheme="http://blog.caoxl.com/tags/Redis/"/>
    
      <category term="缓存" scheme="http://blog.caoxl.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 再深入 II</title>
    <link href="http://blog.caoxl.com/2021/07/07/RabbitMQ-Learn-More-II/"/>
    <id>http://blog.caoxl.com/2021/07/07/RabbitMQ-Learn-More-II/</id>
    <published>2021-07-07T02:00:57.000Z</published>
    <updated>2021-07-07T07:42:04.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>之前有多篇RabbitMQ的学习, 实践是检验真理的唯一标准, 所以本篇是实践篇<br><a href="https://blog.caoxl.com/2019/08/07/Message-Queue-RabbitMQ/">消息队列之 RabbitMQ</a><br><a href="https://blog.caoxl.com/2020/04/03/RabbitMq-Actual-Combat-1/">RabbitMQ 实战记录</a><br><a href="https://blog.caoxl.com/2020/04/08/RabbitMQ-Learn-More/">RabbitMq 再深入</a></p></blockquote><a id="more"></a><h1 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1 建立连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> AMQPStreamConnection($host, $port, $user, $password, $vhost);</span><br></pre></td></tr></table></figure><ul><li><code>$host</code>:  RabbitMQ服务器主机ID地址</li><li><code>$port</code>:  RabbitMQ服务器端口</li><li><code>$user</code>:  连接RabbitMQ服务器的用户名</li><li><code>$password</code>:  连接RabbitMQ服务器的用户密码</li><li><code>$vhost</code>: 连接RabbitMQ服务器的vhost(服务器可以有多个vhost，虚拟主机，类似nginx的vhost)</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 1.2 建立信道</span><br><span class="line">$channel = $conn-&gt;channel($channel_id);</span><br></pre></td></tr></table></figure><ul><li><code>$channel_id</code>:  信道ID, 不传则获取$channel[“”]信道,再无则循环$this-&gt;channel数组，下标从1到最大信道数找第一个不是<code>AMQPChannel</code>对象的下标，实例化并返回<code>AMQPChannel</code>对象，无则抛出异常<code>No free channel ids</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.3 声明交换机</span></span><br><span class="line">$channel-&gt;exchange_declare(</span><br><span class="line">    $exchange_name,</span><br><span class="line">    $type,</span><br><span class="line">    $passive = <span class="keyword">false</span>,</span><br><span class="line">    $durable = <span class="keyword">false</span>,</span><br><span class="line">    $auto_delete = <span class="keyword">false</span>,</span><br><span class="line">    $internal = <span class="keyword">false</span>,</span><br><span class="line">    $nowait = <span class="keyword">false</span>,</span><br><span class="line">    $arguments = <span class="keyword">array</span>(),</span><br><span class="line">    $ticket = <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>$exchange_name</code>:  交换机名称</li><li><code>$type</code>:  交换机类型<ul><li><code>direct</code>: (默认)直接交换器，工作方式类似于单播，<code>exchange</code>会将消息发送完全匹配<code>route_key</code>的<code>queue</code>;</li><li><code>fanout</code>: 广播式交换器，不管消息的<code>route_key</code>设置为什么，<code>exchange</code>都会将消息转发给所有绑定的<code>queue</code>;</li><li><code>topic</code>: 主题交换机, 工作方式类似于组播, <code>exchange</code>会将消息转发和<code>route_key</code>匹配模式相同的所有队列;</li><li><code>headers</code>: 根据消息体的header匹配</li></ul></li><li><code>$passive</code>:  是否检测同名队列</li><li><code>$durable</code>:  交换机是否开启持久化</li><li><code>$auto_delete</code>:  通道关闭后是否删除队列</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.4 声明队列</span></span><br><span class="line">$channel-&gt;queue_declare(</span><br><span class="line">    $queue_name = <span class="string">''</span>,</span><br><span class="line">    $passive = <span class="keyword">false</span>,</span><br><span class="line">    $durable = <span class="keyword">false</span>,</span><br><span class="line">    $exclusive = <span class="keyword">false</span>,</span><br><span class="line">    $auto_delete = <span class="keyword">true</span>,</span><br><span class="line">    $nowait = <span class="keyword">false</span>,</span><br><span class="line">    $arguments = <span class="keyword">array</span>(),</span><br><span class="line">    $ticket = <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>$queue_name</code>:  队列名称</li><li><code>$passive</code>:  是否检测同名队列</li><li><code>$durable</code>:  是否开启队列持久化</li><li><code>$exclusive</code>:  队列是否可以被其他队列访问</li><li><code>$auto_delete</code>: 通道关闭后是否删除队列</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.5 创建要发送的消息, 可以创建多个消息</span></span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage($data, $properties);</span><br><span class="line"><span class="comment">// 单个发送</span></span><br><span class="line">$channel-&gt;basic_publish($msg, $exchange = <span class="string">''</span>, $routing_key = <span class="string">''</span>, $mandatory = <span class="keyword">false</span>, $immediate = <span class="keyword">false</span>, $ticket = <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 多个发送</span></span><br><span class="line"><span class="comment">// 1.多次调用 $channel-&gt;batch_basic_publish($msg, $exchange = '', $routing_key = '', $mandatory = false, $immediate = false, $ticket = null)</span></span><br><span class="line"><span class="comment">// 内部实现:往$this-&gt;batch_messages[]塞</span></span><br><span class="line"><span class="comment">// 2.再调用一次$channel-&gt;publish_batch(), 完成发送</span></span><br></pre></td></tr></table></figure><ul><li><code>$data</code>:  要发送的消息</li><li><code>$properties</code>:  设置的属性, 比如设置该消息持久化 <code>[&#39;delivery_mode&#39; =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT]</code></li><li><code>$msg</code>:  消息内容</li><li><code>$exchange</code>:  交换机</li><li><code>$routing_key</code>:  路由键</li><li><code>$mandatory</code>:  匹配不到队列时,是否立即丢弃消息</li><li><code>$immediate</code>:  队列无消费者时,是否立即丢弃消息</li><li><code>$ticket</code>:  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.6 路由绑定</span></span><br><span class="line">$channel-&gt;queue_bind(</span><br><span class="line">    $queue,</span><br><span class="line">    $exchange, </span><br><span class="line">    $routing_key = <span class="string">''</span>, </span><br><span class="line">    $nowait = <span class="keyword">false</span>,</span><br><span class="line">    $arguments = <span class="keyword">array</span>(),</span><br><span class="line">    $ticket = <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>$queue</code>:  队列名</li><li><code>$exchange</code>:  交换机名</li><li><code>$routing_key</code>:  路由键</li><li><code>$nowait</code>:  声明队列无需等待</li><li><code>$arguments</code>:  其他参数</li><li><code>$ticket</code>:  </li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.7 消费消息</span></span><br><span class="line">$channel-&gt;basic_consume(</span><br><span class="line">    $queue = <span class="string">',</span></span><br><span class="line"><span class="string">    $consumer_tag = '</span>,</span><br><span class="line">    $no_local = <span class="keyword">false</span>,</span><br><span class="line">    $no_ack = <span class="keyword">false</span>,</span><br><span class="line">    $exclusive = <span class="keyword">false</span>,</span><br><span class="line">    $nowait = <span class="keyword">false</span>,</span><br><span class="line">    $callback = <span class="keyword">null</span>,</span><br><span class="line">    $ticket = <span class="keyword">null</span>,</span><br><span class="line">    $arguments = <span class="keyword">array</span>()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>$queue</code>:  被消费队列名称</li><li><code>$consumer_tag</code>:  消费者客户端身份标识，用于区分多个客户端</li><li><code>$no_local</code>:  这个功能属于AMQP的标准，但是RabbitMQ并没有做实现</li><li><code>$no_ack</code>:  收到消息后，是否不需要回复确认即被认为被消费</li><li><code>$exclusive</code>:  收到消息后，是否不需要回复确认即被认为被消费</li><li><code>$nowait</code>:  不返回执行结果，但是如果排他开启的话，则必须需要等待结果的，如果两个一起开就会报错</li><li><code>$callback</code>:  回调逻辑处理函数</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.8 手动ack示例</span></span><br><span class="line">$callback = <span class="function"><span class="keyword">function</span> <span class="params">($msg)</span> </span>&#123;</span><br><span class="line">    sleep($msg-&gt;body); </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">" [x] Received sleep "</span>, $msg-&gt;body, <span class="string">"\n"</span>;</span><br><span class="line">    $msg-&gt;delivery_info[<span class="string">'channel'</span>]-&gt;basic_ack($msg-&gt;delivery_info[<span class="string">'delivery_tag'</span>]);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">" [x] Ack "</span>.<span class="string">"\n"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.9 限制分发示例</span></span><br><span class="line"><span class="comment">// 限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。</span></span><br><span class="line">$channel-&gt;basic_qos(<span class="keyword">null</span>, <span class="number">1</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h1 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h1><h2 id="无交换机-直接队列"><a href="#无交换机-直接队列" class="headerlink" title="无交换机, 直接队列"></a>无交换机, 直接队列</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $connection = <span class="keyword">new</span> AMQPStreamConnection(<span class="string">'localhost'</span>, <span class="number">5672</span>, <span class="string">'guest'</span>, <span class="string">'guest'</span>);</span><br><span class="line">    $channel = $connection-&gt;channel();</span><br><span class="line">    $channel-&gt;queue_declare(<span class="string">'hello'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    $msg = <span class="keyword">new</span> AMQPMessage(<span class="string">'Hello World!'</span>);</span><br><span class="line">    $channel-&gt;basic_publish($msg, <span class="string">''</span>, <span class="string">'hello'</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">" [x] Sent 'Hello World!'\n"</span>;</span><br><span class="line">    $channel-&gt;close();</span><br><span class="line">    $connection-&gt;close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">consume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $connection = <span class="keyword">new</span> AMQPStreamConnection(<span class="string">'localhost'</span>, <span class="number">5672</span>, <span class="string">'guest'</span>, <span class="string">'guest'</span>);</span><br><span class="line">    $channel = $connection-&gt;channel();</span><br><span class="line">    $channel-&gt;queue_declare(<span class="string">'hello'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>, <span class="string">"\n"</span>;</span><br><span class="line">    $callback = <span class="function"><span class="keyword">function</span> <span class="params">($msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">" [x] Received "</span>, $msg-&gt;body, <span class="string">"\n"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    $channel-&gt;basic_consume(<span class="string">'hello'</span>, <span class="string">''</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, $callback);</span><br><span class="line">    <span class="keyword">while</span> (count($channel-&gt;callbacks)) &#123;</span><br><span class="line">        $channel-&gt;wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作队列按消费能力分发"><a href="#工作队列按消费能力分发" class="headerlink" title="工作队列按消费能力分发"></a>工作队列按消费能力分发</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者和消费者均增加</span></span><br><span class="line">$channel-&gt;basic_qos(<span class="keyword">null</span>, <span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 即可。</span></span><br></pre></td></tr></table></figure><h2 id="fanout广播示例-注册行为"><a href="#fanout广播示例-注册行为" class="headerlink" title="fanout广播示例 注册行为"></a><code>fanout</code>广播示例 注册行为</h2><p>例如注册后需要发送欢迎短信和邮件，将注册行为广播至短信和邮件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="comment">// 定义交换机</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'register'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage(<span class="string">'register event'</span>);</span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">'register'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册短信消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'register'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'register.sms'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'register.sms'</span>, <span class="string">'register'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册邮件消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'register'</span>, <span class="string">'fanout'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'register.mail'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'register.mail'</span>, <span class="string">'register'</span>);</span><br></pre></td></tr></table></figure><h2 id="topic模糊匹配示例-日志分级"><a href="#topic模糊匹配示例-日志分级" class="headerlink" title="topic模糊匹配示例 日志分级"></a><code>topic</code>模糊匹配示例 日志分级</h2><p>例如我想一个消费者接受所有日志，一个消费者只接收error级别日志</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义交换机</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log'</span>, <span class="string">'topic'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$num = rand(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> ($num%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    $level = <span class="string">'error'</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($num%<span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    $level = <span class="string">'warning'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $level = <span class="string">'common'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage(<span class="string">'log event '</span> . $level);</span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">'log'</span>, <span class="string">'log.'</span>.$level);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全量日志消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log'</span>, <span class="string">'topic'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'log.all'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'log.all'</span>, <span class="string">'log'</span>, <span class="string">'log.*'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error日志消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log'</span>, <span class="string">'topic'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'log.error'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'log.error'</span>, <span class="string">'log'</span>, <span class="string">'log.error'</span>);</span><br></pre></td></tr></table></figure><h2 id="headers匹配示例-日志分级"><a href="#headers匹配示例-日志分级" class="headerlink" title="headers匹配示例 日志分级"></a><code>headers</code>匹配示例 日志分级</h2><p>例如我想一个消费者接受所有日志，一个消费者只接收error级别日志</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="comment">// 定义交换机</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log2'</span>, <span class="string">'headers'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$num = rand(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> ($num%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    $level = <span class="string">'error'</span>;</span><br><span class="line">&#125; <span class="keyword">elseif</span> ($num%<span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    $level = <span class="string">'warning'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $level = <span class="string">'common'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage(<span class="string">'log2 event '</span>.$level);</span><br><span class="line">$bindArguments = [</span><br><span class="line">    <span class="string">'level'</span> =&gt; $level,</span><br><span class="line">    <span class="string">'type'</span>  =&gt; <span class="string">'log'</span></span><br><span class="line">];</span><br><span class="line">$headers = <span class="keyword">new</span> AMQPTable($bindArguments);</span><br><span class="line">$msg-&gt;set(<span class="string">'application_headers'</span>, $bindArguments);</span><br><span class="line"></span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">'log2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全量日志消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log2'</span>, <span class="string">'headers'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'log2.all'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$bindArguments = [</span><br><span class="line">    <span class="string">'type'</span> =&gt; <span class="string">'log'</span>,</span><br><span class="line">    <span class="comment">//'x-match' =&gt; 'any'</span></span><br><span class="line">];</span><br><span class="line">$headers = <span class="keyword">new</span> AMQPTable($bindArguments);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'log2.all'</span>, <span class="string">'log2'</span>, <span class="string">''</span>, <span class="keyword">false</span>, $headers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// error日志消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'log2'</span>, <span class="string">'headers'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'log2.error'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$bindArguments = [</span><br><span class="line">    <span class="string">'type'</span> =&gt; <span class="string">'log'</span>,</span><br><span class="line">    <span class="string">'level'</span> =&gt; <span class="string">'error'</span>,</span><br><span class="line">    <span class="string">'x-match'</span> =&gt; <span class="string">'any'</span></span><br><span class="line">];</span><br><span class="line">$headers = <span class="keyword">new</span> AMQPTable($bindArguments);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'log2.error'</span>, <span class="string">'log2'</span>, <span class="string">''</span>, <span class="keyword">false</span>, $headers);</span><br></pre></td></tr></table></figure><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个没有消费者，5s后消息过期的队列</span></span><br><span class="line">$arguments = <span class="keyword">new</span> AMQPTable([</span><br><span class="line">    <span class="string">'x-dead-letter-exchange'</span>    =&gt; <span class="string">'dead'</span>,</span><br><span class="line">    <span class="string">'x-message-tl'</span>              =&gt; <span class="number">5000</span>, <span class="comment">// 消息存活时间(毫秒)</span></span><br><span class="line">    <span class="string">'x-dead-letter-routing-key'</span> =&gt; <span class="string">'dead'</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列, 不要交换机</span></span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'no_consume'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$now = time();</span><br><span class="line">$msg = <span class="keyword">new</span> AMQPMessage($now);</span><br><span class="line">$channel-&gt;basic_publish($msg, <span class="string">''</span>, <span class="string">'no_consume'</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">" [x] Sent no_consume :"</span>.date(<span class="string">'Y-m-d H:i:s'</span>, $now).<span class="string">"\n"</span>;</span><br><span class="line">$channel-&gt;close();</span><br><span class="line">$connection-&gt;close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">$channel-&gt;exchange_declare(<span class="string">'dead'</span>, <span class="string">'topic'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_declare(<span class="string">'dead.all'</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">$channel-&gt;queue_bind(<span class="string">'dead.all'</span>, <span class="string">'dead'</span>, <span class="string">'dead'</span>);</span><br><span class="line">$channel-&gt;basic_qos(<span class="keyword">null</span>, <span class="number">1</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>, <span class="string">"\n"</span>;</span><br><span class="line">$callback = <span class="function"><span class="keyword">function</span> <span class="params">($msg)</span> </span>&#123;</span><br><span class="line">    var_dump(<span class="string">'msg:'</span>.date(<span class="string">'Y-m-d H:i:s'</span>, $msg-&gt;body));</span><br><span class="line">    var_dump(<span class="string">'now:'</span>.date(<span class="string">'Y-m-d H:i:s'</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">" [x] Received log error "</span>, $msg-&gt;body, <span class="string">"\n"</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$channel-&gt;basic_consume(<span class="string">'dead.all'</span>, <span class="string">''</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, $callback);</span><br><span class="line"><span class="keyword">while</span>(count($channel-&gt;callbacks)) &#123;</span><br><span class="line">    $channel-&gt;wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rabbitmq和redis用作消息队列的区别"><a href="#rabbitmq和redis用作消息队列的区别" class="headerlink" title="rabbitmq和redis用作消息队列的区别"></a>rabbitmq和redis用作消息队列的区别</h1><ul><li>可靠性</li></ul><blockquote><p>redis: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中<br>rabbitmq: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中</p></blockquote><ul><li>实时性</li></ul><blockquote><p>redis: 实时性高，redis作为高效的缓存服务器，所有数据都存在在服务器中，所以它具有更高的实时性</p></blockquote><ul><li>持久性</li></ul><blockquote><p>redis: redis的持久化是针对于整个redis缓存的内容，它有RDB和AOF两种持久化方式（redis持久化方式，后续更新），可以将整个redis实例持久化到磁盘，以此来做数据备份，防止异常情况下导致数据丢失。<br>rabbitmq: 队列，消息都可以选择性持久化，持久化粒度更小，更灵活；</p></blockquote><ul><li>总结:</li></ul><blockquote><p>redis: 轻量级, 低延迟, 高并发, 低可靠性;<br>rabbitmq: 重量级, 高可靠, 异步, 不保证实时性;</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前有多篇RabbitMQ的学习, 实践是检验真理的唯一标准, 所以本篇是实践篇&lt;br&gt;&lt;a href=&quot;https://blog.caoxl.com/2019/08/07/Message-Queue-RabbitMQ/&quot;&gt;消息队列之 RabbitMQ&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.caoxl.com/2020/04/03/RabbitMq-Actual-Combat-1/&quot;&gt;RabbitMQ 实战记录&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.caoxl.com/2020/04/08/RabbitMQ-Learn-More/&quot;&gt;RabbitMq 再深入&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="消息队列" scheme="http://blog.caoxl.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="RabbitMQ" scheme="http://blog.caoxl.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor 再深入</title>
    <link href="http://blog.caoxl.com/2021/07/05/Supervisor-II/"/>
    <id>http://blog.caoxl.com/2021/07/05/Supervisor-II/</id>
    <published>2021-07-05T09:38:46.000Z</published>
    <updated>2021-07-06T02:16:13.944Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>之前做过一篇 <a href="http://blog.caoxl.com/2019/11/06/Supervisor-For-Laravels/">http://blog.caoxl.com/2019/11/06/Supervisor-For-Laravels/</a>, 今天更深入的学习下Supervisor</p></blockquote><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install supervisor</span><br></pre></td></tr></table></figure><p>显示如下，就证明安装成功了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ supervisord -v              </span><br><span class="line">4.2.2</span><br></pre></td></tr></table></figure><h1 id="配置-amp-启动"><a href="#配置-amp-启动" class="headerlink" title="配置&amp;启动"></a>配置&amp;启动</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>supervisor</code>的主配置文件在<code>/usr/local/etc/supervisord.conf</code>;<br>配置文件在最后一行可以修改新增子配置文件,默认在 <code>/usr/local/etc/supervisor.d/*.ini</code> 也可以 <code>/usr/local/etc/supervisor.d/*.conf</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = /usr/local/etc/supervisor.d/*.conf</span><br></pre></td></tr></table></figure><h2 id="启动supervisord"><a href="#启动supervisord" class="headerlink" title="启动supervisord"></a>启动supervisord</h2><ul><li>手动启动, 需要指定主配置文件</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /usr/local/etc/supervisord.conf</span><br></pre></td></tr></table></figure><ul><li>自动随系统系统 (推荐)</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start supervisor</span><br></pre></td></tr></table></figure><ul><li>查看服务</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep supervisord</span><br><span class="line">501 85725     1   0  5:28PM ??         0:00.78 /usr/local/Cellar/python@3.9/3.9.5/Frameworks/Python.framework/Versions/3.9/Resources/Python.app/Contents/MacOS/Python /usr/local/opt/supervisor/bin/supervisord -c /usr/local/etc/supervisord.conf --nodaemon</span><br></pre></td></tr></table></figure><h2 id="启动supervisorctl"><a href="#启动supervisorctl" class="headerlink" title="启动supervisorctl"></a>启动supervisorctl</h2><ul><li>配置文件立即生效</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl update</span><br><span class="line"></span><br><span class="line"><span class="section"># 或</span></span><br><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure><ul><li>查看后台进程</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl status</span><br></pre></td></tr></table></figure><ul><li>对进程的控制</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 将all换成相应的program名称，则就是对相应的程序进行启动、关闭和重启</span></span><br><span class="line">supervisorctl start|stop|restart all</span><br></pre></td></tr></table></figure><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>以<code>test_shell</code>为例启动进程</p><ol><li>编辑配置文件 <code>/usr/local/etc/supervisor.d/shell.conf</code></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:test_shell]</span><br><span class="line">process<span class="emphasis">_name=%(program_</span>name)s</span><br><span class="line">command=sh /Users/caoxl/WWW/DNMP/www/test.com/shell/test.sh</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">user=caoxl</span><br><span class="line">numprocs=1</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout<span class="emphasis">_logfile=/var/log/supervisor/test_</span>shell.log</span><br></pre></td></tr></table></figure><ol start="2"><li>立即生效</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure><ol start="3"><li>查看结果</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl status</span><br><span class="line">test_shell                       RUNNING   pid 86587, uptime 0:00:03</span><br></pre></td></tr></table></figure><h2 id="program配置文件说明"><a href="#program配置文件说明" class="headerlink" title="program配置文件说明"></a>program配置文件说明</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">;*为必须填写项</span><br><span class="line">;*[program:应用名称]</span><br><span class="line">[program:test_shell]</span><br><span class="line"></span><br><span class="line">;当numprocs为1时,process<span class="emphasis">_name=%(program_</span>name)s</span><br><span class="line">;当numprocs&gt;=2时,%(program<span class="emphasis">_name)s_</span>%(process_num)02d</span><br><span class="line">process<span class="emphasis">_name=%(program_</span>name)s</span><br><span class="line"></span><br><span class="line">;*命令路径,如果使用python启动的程序应该为 python /home/test.py,</span><br><span class="line">;不建议放入/home/user/, 对于非user用户一般情况下是不能访问</span><br><span class="line">command=sh /Users/caoxl/WWW/DNMP/www/test.com/shell/test.sh</span><br><span class="line"></span><br><span class="line">;使用supervisor还有一个更大的好处就是，可以快速开启多个进程，配置参数如下：</span><br><span class="line">;进程数量,表示对同一个配置开启1个线程。</span><br><span class="line">numprocs=1</span><br><span class="line"></span><br><span class="line">;执行目录,若有/home/supervisor_test/test1.py</span><br><span class="line">;将directory设置成/home/supervisor_test</span><br><span class="line">;则command只需设置成python test1.py</span><br><span class="line">;否则command必须设置成绝对执行目录</span><br><span class="line">directory=/tmp</span><br><span class="line"></span><br><span class="line">;掩码:--- -w- -w-, 转换后rwx r-x w-x</span><br><span class="line">umask=022</span><br><span class="line"></span><br><span class="line">;优先级,值越高,最后启动,最先被关闭,默认值999</span><br><span class="line">priority=999</span><br><span class="line"></span><br><span class="line">;如果是true,当supervisor启动时,程序将会自动启动</span><br><span class="line">autostart=true</span><br><span class="line"></span><br><span class="line">;*自动重启</span><br><span class="line">autorestart=true</span><br><span class="line"></span><br><span class="line">;启动延时执行,默认1秒</span><br><span class="line">startsecs=10</span><br><span class="line"></span><br><span class="line">;启动尝试次数,默认3次</span><br><span class="line">startretries=3</span><br><span class="line"></span><br><span class="line">;当退出码是0,2时,执行重启,默认值0,2</span><br><span class="line">exitcodes=0,2</span><br><span class="line"></span><br><span class="line">;停止信号,默认TERM</span><br><span class="line">;中断:INT(类似于Ctrl+C)(kill -INT pid),退出后会将写文件或日志(推荐)</span><br><span class="line">;终止:TERM(kill -TERM pid)</span><br><span class="line">;挂起:HUP(kill -HUP pid),注意与Ctrl+Z/kill -stop pid不同</span><br><span class="line">;从容停止:QUIT(kill -QUIT pid)</span><br><span class="line">;KILL, USR1, USR2其他见命令(kill -l),说明1</span><br><span class="line">stopsignal=TERM</span><br><span class="line">stopwaitsecs=10</span><br><span class="line"></span><br><span class="line">;*以root用户执行</span><br><span class="line">user=caoxl</span><br><span class="line"></span><br><span class="line">;有时候用 Supervisor 托管的程序还会有子进程（如 Tornado），如果只杀死主进程，子进程就可能变成孤儿进程。</span><br><span class="line">;通过这两项配置(改为true)来确保所有子进程都能正确停止,默认是false：</span><br><span class="line">stopasgroup=false</span><br><span class="line">killasgroup=false</span><br><span class="line"></span><br><span class="line">;重定向,把stderr重定向到stdout，默认false；</span><br><span class="line">redirect_stderr=true</span><br><span class="line"></span><br><span class="line">;标准日志输出</span><br><span class="line">stdout<span class="emphasis">_logfile=/var/log/supervisor/test_</span>shell.log</span><br><span class="line"></span><br><span class="line">;标准日志文件大小，默认50MB</span><br><span class="line">stdout<span class="emphasis">_logfile_</span>maxbytes=1MB</span><br><span class="line">;标准日志文件大小，默认50MB</span><br><span class="line">stdout<span class="emphasis">_logfile_</span>backups=10</span><br><span class="line">stdout<span class="emphasis">_capture_</span>maxbytes=1MB</span><br><span class="line">;标准日志输出</span><br><span class="line">stderr_logfile=/a/path</span><br><span class="line">stderr<span class="emphasis">_logfile_</span>maxbytes=1MB</span><br><span class="line">stderr<span class="emphasis">_logfile_</span>backups=10</span><br><span class="line">stderr<span class="emphasis">_capture_</span>maxbytes=1MB</span><br><span class="line"></span><br><span class="line">;环境变量设置</span><br><span class="line">environment=A="1",B="2"</span><br><span class="line">serverurl=AUTO</span><br></pre></td></tr></table></figure><h1 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h1><h2 id="ERROR-spawn-error"><a href="#ERROR-spawn-error" class="headerlink" title="ERROR (spawn error)"></a>ERROR (spawn error)</h2><blockquote><p>权限问题,查看下设置的目录权限,日志权限等</p></blockquote><ul><li>使用<code>supervisorctl tail program_name stderr</code>命令查看错误信息</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl tail test_shell stderr</span><br><span class="line">test_shell: ERROR (no log file)</span><br></pre></td></tr></table></figure><h2 id="supervisor-error-class-‘FileNotFoundError’-…"><a href="#supervisor-error-class-‘FileNotFoundError’-…" class="headerlink" title="supervisor error: class ‘FileNotFoundError’ …"></a>supervisor error: class ‘FileNotFoundError’ …</h2><p>一般使用<code>supervisord -c /usr/local/etc/supervisord.conf</code>会出现, 仔细检查<code>supervisord.conf</code>文件里面的子进程配置文件,检查路径有没有问题</p><h2 id="supervisor-提示：xxx-ERROR-no-such-process"><a href="#supervisor-提示：xxx-ERROR-no-such-process" class="headerlink" title="supervisor 提示：xxx: ERROR (no such process)"></a>supervisor 提示：xxx: ERROR (no such process)</h2><p>增加了新的配置文件xxx.conf后，使用<code>supervisorctl start xxx</code> 提示 “xxx: ERROR (no such process)”。</p><p>使用<code>supervisorctl start all</code>也不行。</p><blockquote><p>在新增配置文件后，要使用<code>supervisorctl update</code>命令，使用此命令后会自动加载新的配置，并且启动该进程。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://segmentfault.com/a/1190000014756941" target="_blank" rel="noopener">Supervisor进程管理工具安装配置</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前做过一篇 &lt;a href=&quot;http://blog.caoxl.com/2019/11/06/Supervisor-For-Laravels/&quot;&gt;http://blog.caoxl.com/2019/11/06/Supervisor-For-Laravels/&lt;/a&gt;, 今天更深入的学习下Supervisor&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="supervisor" scheme="http://blog.caoxl.com/tags/supervisor/"/>
    
      <category term="supervisord" scheme="http://blog.caoxl.com/tags/supervisord/"/>
    
      <category term="supervisorctl" scheme="http://blog.caoxl.com/tags/supervisorctl/"/>
    
  </entry>
  
  <entry>
    <title>性能测试工具 wrk,ab 压测结果比较</title>
    <link href="http://blog.caoxl.com/2021/06/29/Pressure-Test/"/>
    <id>http://blog.caoxl.com/2021/06/29/Pressure-Test/</id>
    <published>2021-06-29T09:30:13.000Z</published>
    <updated>2021-06-30T06:21:40.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>wrk,ab,locust,jmeter 压测结果比较</p></blockquote><a id="more"></a><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h2><blockquote><p>wrk 是一款针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I/O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">brew install wrk</span><br><span class="line"></span><br><span class="line">wrk -v</span><br><span class="line">wrk  [kqueue] Copyright (C) 2012 Will Glozer</span><br><span class="line">Usage: wrk &lt;options&gt; &lt;url&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  Connections <span class="keyword">to</span> keep open   </span><br><span class="line">    -d, --duration    &lt;T&gt;  Duration of test           </span><br><span class="line">    -t, --threads     &lt;N&gt;  Number of threads <span class="keyword">to</span> use   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  Load Lua<span class="built_in"> script </span>file       </span><br><span class="line">    -H, --header      &lt;H&gt;  <span class="builtin-name">Add</span> header <span class="keyword">to</span> request      </span><br><span class="line">        --latency          <span class="builtin-name">Print</span> latency statistics   </span><br><span class="line">        --timeout     &lt;T&gt;  Socket/request timeout     </span><br><span class="line">    -v, --version          <span class="builtin-name">Print</span> version details      </span><br><span class="line">                                                      </span><br><span class="line">  Numeric arguments may include a SI unit (1k, 1M, 1G)</span><br><span class="line">  Time arguments may include a time unit (2s, 2m, 2h)</span><br></pre></td></tr></table></figure><h2 id="ab-Apache-Bench"><a href="#ab-Apache-Bench" class="headerlink" title="ab (Apache Bench)"></a>ab (Apache Bench)</h2><blockquote><p>ab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。</p></blockquote><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进入httpd目录</span><br><span class="line">./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line">ab -V</span><br><span class="line">This <span class="keyword">is</span> ApacheBench, Version <span class="number">2.3</span> &lt;$Revision: <span class="number">655654</span> $&gt;</span><br><span class="line">Copyright <span class="number">1996</span> Adam Twiss, Zeus Technology Ltd, http:<span class="comment">//www.zeustech.net/</span></span><br><span class="line">Licensed to The Apache Software Foundation, http:<span class="comment">//www.apache.org/</span></span><br></pre></td></tr></table></figure><h1 id="wrk-1"><a href="#wrk-1" class="headerlink" title="wrk"></a>wrk</h1><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% wrk -v</span><br><span class="line">wrk  [kqueue] Copyright (C) <span class="number">2012</span> Will Glozer</span><br><span class="line">Usage: wrk &lt;options&gt; &lt;url&gt;                            </span><br><span class="line">  Options:                                            </span><br><span class="line">    -c, --connections &lt;N&gt;  Connections to keep open   </span><br><span class="line">    -d, --duration    &lt;T&gt;  Duration of test           </span><br><span class="line">    -t, --threads     &lt;N&gt;  Number of threads to use   </span><br><span class="line">                                                      </span><br><span class="line">    -s, --script      &lt;S&gt;  Load Lua script file       </span><br><span class="line">    -H, --header      &lt;H&gt;  <span class="keyword">Add</span><span class="bash"> header to request      </span></span><br><span class="line">        --latency          Print latency statistics   </span><br><span class="line">        --timeout     &lt;T&gt;  Socket/request timeout     </span><br><span class="line">    -v, --version          Print version details      </span><br><span class="line">                                                      </span><br><span class="line">  Numeric arguments may include a SI unit (<span class="number">1</span>k, <span class="number">1</span>M, <span class="number">1</span>G)</span><br><span class="line">  Time arguments may include a time unit (<span class="number">2</span>s, <span class="number">2</span>m, <span class="number">2</span>h)</span><br></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c：总的连接数（每个线程处理的连接数=总连接数/线程数）</span><br><span class="line">-d：测试的持续时间，如<span class="number">2</span>s(<span class="number">2</span>second)，<span class="number">2</span>m(<span class="number">2</span>minute)，<span class="number">2</span>h(hour)，默认为s</span><br><span class="line">-t：需要执行的线程总数，默认为<span class="number">2</span>，一般线程数不宜过多. 核数的<span class="number">2</span>到<span class="number">4</span>倍足够了. 多了反而因为线程切换过多造成效率降低</span><br><span class="line">-s：执行Lua脚本，这里写lua脚本的路径和名称，后面会给出案例</span><br><span class="line">-H：需要添加的头信息，注意header的语法，举例，-H “token: abcdef”</span><br><span class="line">—timeout：超时的时间</span><br><span class="line">—latency：显示延迟统计信息</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">% wrk -t <span class="number">5</span> -c <span class="number">300</span> -d <span class="number">60</span> --latency http://localhost:<span class="number">9801</span>/                                         <span class="number">1</span> ↵</span><br><span class="line">Running <span class="number">1</span>m test @ http://localhost:<span class="number">9801</span>/</span><br><span class="line">  <span class="number">5</span> threads and <span class="number">300</span> connections</span><br><span class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</span><br><span class="line">    Latency   <span class="number">288.03</span>ms  <span class="number">140.21</span>ms   <span class="number">1.34</span>s    <span class="number">87.31</span>%</span><br><span class="line">    Req/Sec   <span class="number">221.94</span>     <span class="number">86.65</span>   <span class="number">560.00</span>     <span class="number">70.71</span>%</span><br><span class="line">  Latency Distribution</span><br><span class="line">     <span class="number">50</span>%  <span class="number">257.29</span>ms</span><br><span class="line">     <span class="number">75</span>%  <span class="number">312.34</span>ms</span><br><span class="line">     <span class="number">90</span>%  <span class="number">411.33</span>ms</span><br><span class="line">     <span class="number">99</span>%  <span class="number">920.93</span>ms</span><br><span class="line">  <span class="number">64748</span> requests in <span class="number">1.00</span>m, <span class="number">11.73</span>MB read</span><br><span class="line">  Socket errors: connect <span class="number">0</span>, read <span class="number">173</span>, write <span class="number">15</span>, timeout <span class="number">0</span></span><br><span class="line">Requests/sec:   <span class="number">1078.37</span></span><br><span class="line">Transfer/sec:    <span class="number">200.09</span>KB</span><br></pre></td></tr></table></figure><h2 id="返回结果说明"><a href="#返回结果说明" class="headerlink" title="返回结果说明"></a>返回结果说明</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Latency：响应时间</span><br><span class="line">Req/Sec：每个线程每秒钟的执行的连接数</span><br><span class="line">Avg：平均</span><br><span class="line">Max：最大</span><br><span class="line">Stdev：标准差</span><br><span class="line">+/- Stdev： 正负一个标准差占比</span><br><span class="line">Requests/sec：每秒请求数（也就是QPS），等于总请求数/测试总耗时</span><br><span class="line">Latency Distribution，如果命名中添加了—latency就会出现相关信息</span><br></pre></td></tr></table></figure><blockquote><p>300 个连接数跑 60 秒：Request/sec(每秒请求数)：1078.37</p></blockquote><h1 id="ab"><a href="#ab" class="headerlink" title="ab"></a>ab</h1><h2 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">% ab --help</span><br><span class="line">ab: wrong number of arguments</span><br><span class="line">Usage: ab [options] [http[s]://]hostname[:port]/path</span><br><span class="line">Options are:</span><br><span class="line">    -n requests     Number of requests to perform</span><br><span class="line">    -c concurrency  Number of multiple requests to make</span><br><span class="line">    -t timelimit    Seconds to max. wait for responses</span><br><span class="line">    -b windowsize   Size of TCP send/receive buffer, in bytes</span><br><span class="line">    -p postfile     File containing data to POST. Remember also to set -T</span><br><span class="line">    -u putfile      File containing data to PUT. Remember also to set -T</span><br><span class="line">    -T content-type Content-type header for POSTing, eg.</span><br><span class="line">                    <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">                    Default is <span class="string">'text/plain'</span></span><br><span class="line">    -v verbosity    How much troubleshooting info to print</span><br><span class="line">    -w              Print out results in HTML tables</span><br><span class="line">    -i              Use HEAD instead of GET</span><br><span class="line">    -x attributes   String to insert as table attributes</span><br><span class="line">    -y attributes   String to insert as tr attributes</span><br><span class="line">    -z attributes   String to insert as td or th attributes</span><br><span class="line">    -C attribute    <span class="keyword">Add</span><span class="bash"> cookie, eg. <span class="string">'Apache=1234. (repeatable)</span></span></span><br><span class="line">    -H attribute    <span class="keyword">Add</span><span class="bash"> Arbitrary header line, eg. <span class="string">'Accept-Encoding: gzip'</span></span></span><br><span class="line">                    Inserted after all normal header lines. (repeatable)</span><br><span class="line">    -A attribute    <span class="keyword">Add</span><span class="bash"> Basic WWW Authentication, the attributes</span></span><br><span class="line">                    are a colon separated username and password.</span><br><span class="line">    -P attribute    <span class="keyword">Add</span><span class="bash"> Basic Proxy Authentication, the attributes</span></span><br><span class="line">                    are a colon separated username and password.</span><br><span class="line">    -X proxy:port   Proxyserver and port number to use</span><br><span class="line">    -V              Print version number and exit</span><br><span class="line">    -k              Use HTTP KeepAlive feature</span><br><span class="line">    -d              Do not show percentiles served table.</span><br><span class="line">    -S              Do not show confidence estimators and warnings.</span><br><span class="line">    -g filename     Output collected data to gnuplot format file.</span><br><span class="line">    -e filename     Output CSV file with percentages served</span><br><span class="line">    -r              Don<span class="string">'t exit on socket receive errors.</span></span><br><span class="line"><span class="string">    -h              Display usage information (this message)</span></span><br><span class="line"><span class="string">    -Z ciphersuite  Specify SSL/TLS cipher suite (See openssl ciphers)</span></span><br><span class="line"><span class="string">    -f protocol     Specify SSL/TLS protocol</span></span><br><span class="line"><span class="string">                    (SSL2, SSL3, TLS1, TLS1.1, TLS1.2 or ALL)</span></span><br></pre></td></tr></table></figure><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n 表示请求总数(与-t参数可任选其一)</span><br><span class="line">-c 表示并发数</span><br><span class="line">-t 标识请求时间</span><br><span class="line">-p:模拟post请求，文件格式为gid=<span class="number">2</span>&amp;status=<span class="number">1</span>,配合-T使用</span><br><span class="line">-T:post数据所使用的Content-Type头信息，如-T <span class="string">'application/x-www-form-urlencoded'</span></span><br></pre></td></tr></table></figure><h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">% ab -c <span class="number">300</span> -t <span class="number">60</span> https://hexo.lilis.xin/                                                       <span class="number">54</span> ↵</span><br><span class="line">This is ApacheBench, Version <span class="number">2.3</span> &lt;$Revision: <span class="number">655654</span> $&gt;</span><br><span class="line">Copyright <span class="number">1996</span> Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"></span><br><span class="line">Benchmarking hexo.lilis.xin (be patient)</span><br><span class="line">Finished <span class="number">1803</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Server Software:        GitHub.com      <span class="comment"># 测试服务器的名字</span></span><br><span class="line">Server Hostname:        hexo.lilis.xin  <span class="comment"># 请求的URL主机名</span></span><br><span class="line">Server Port:            <span class="number">443</span>     <span class="comment"># web服务器监听的端口</span></span><br><span class="line">SSL/TLS Protocol:       TLSv1.<span class="number">2</span>,ECDHE-RSA-AES128-GCM-SHA256,<span class="number">2048</span>,<span class="number">128</span></span><br><span class="line"></span><br><span class="line">Document Path:          /       <span class="comment"># 请求的URL中的根绝对路径</span></span><br><span class="line">Document Length:        <span class="number">31290</span> bytes     <span class="comment"># HTTP响应数据的正文长度</span></span><br><span class="line"></span><br><span class="line">Concurrency Level:      <span class="number">300</span>     <span class="comment"># 并发用户数, 这是我们设置的参数之一</span></span><br><span class="line">Time taken for tests:   <span class="number">60.023</span> seconds  <span class="comment"># 所有这些请求被处理完成所花费的总时间</span></span><br><span class="line">Complete requests:      <span class="number">1803</span>    <span class="comment"># 总请求数量, 这是我们设置的参数之一</span></span><br><span class="line">Failed requests:        <span class="number">0</span>       <span class="comment"># 表示失败的请求数量, 这里的失败是指的请求在连接服务器、发送数据等环节发生异常，以及无响应后超时的情况</span></span><br><span class="line">Write errors:           <span class="number">0</span></span><br><span class="line">Total transferred:      <span class="number">60468718</span> bytes  <span class="comment"># 所有请求的响应数据长度总和。包括每个HTTP响应数据的头信息和正文数据的长度</span></span><br><span class="line">HTML transferred:       <span class="number">59089320</span> bytes  <span class="comment"># 所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度</span></span><br><span class="line">Requests per second:    <span class="number">30.04</span> [<span class="comment">#/sec] (mean)    # 吞吐率, 计算公式: Complete requests/Time taken for tests 总请求数/处理完成这些请求数所花费的时间</span></span><br><span class="line">Time per request:       <span class="number">9987.262</span> [ms] (mean)    <span class="comment"># 用户平均请求等待时间, 计算公式: Time token for tests/（Complete requests/Concurrency Level）。处理完成所有请求数所花费的时间/（总请求数/并发用户数）</span></span><br><span class="line">Time per request:       <span class="number">33.291</span> [ms] (mean, across all concurrent requests)  <span class="comment"># 服务器平均请求等待时间, 计算公式: Time taken for tests/Complete requests，正好是吞吐率的倒数</span></span><br><span class="line">Transfer rate:          <span class="number">983.81</span> [Kbytes/sec] received    <span class="comment"># 表示这些请求在单位时间内从服务器获取的数据长度</span></span><br><span class="line"></span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:      <span class="number">486</span> <span class="number">3009</span> <span class="number">3112.2</span>   <span class="number">2212</span>   <span class="number">33168</span></span><br><span class="line">Processing:   <span class="number">220</span> <span class="number">5512</span> <span class="number">4516.1</span>   <span class="number">4517</span>   <span class="number">47154</span></span><br><span class="line">Waiting:      <span class="number">115</span>  <span class="number">503</span> <span class="number">883.0</span>    <span class="number">183</span>   <span class="number">18372</span></span><br><span class="line">Total:        <span class="number">745</span> <span class="number">8521</span> <span class="number">5710.0</span>   <span class="number">7448</span>   <span class="number">47759</span></span><br><span class="line"></span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line">  <span class="number">50</span>%   <span class="number">7447</span></span><br><span class="line">  <span class="number">66</span>%   <span class="number">9253</span></span><br><span class="line">  <span class="number">75</span>%  <span class="number">10799</span></span><br><span class="line">  <span class="number">80</span>%  <span class="number">11569</span></span><br><span class="line">  <span class="number">90</span>%  <span class="number">15143</span></span><br><span class="line">  <span class="number">95</span>%  <span class="number">19453</span></span><br><span class="line">  <span class="number">98</span>%  <span class="number">25129</span></span><br><span class="line">  <span class="number">99</span>%  <span class="number">29527</span></span><br><span class="line"> <span class="number">100</span>%  <span class="number">47759</span> (longest request)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;wrk,ab,locust,jmeter 压测结果比较&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="加分技能" scheme="http://blog.caoxl.com/categories/%E5%8A%A0%E5%88%86%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="压力测试" scheme="http://blog.caoxl.com/tags/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    
      <category term="wrk" scheme="http://blog.caoxl.com/tags/wrk/"/>
    
      <category term="ab" scheme="http://blog.caoxl.com/tags/ab/"/>
    
  </entry>
  
  <entry>
    <title>聊聊高并发</title>
    <link href="http://blog.caoxl.com/2021/06/29/High-Concurrency/"/>
    <id>http://blog.caoxl.com/2021/06/29/High-Concurrency/</id>
    <published>2021-06-29T02:27:54.000Z</published>
    <updated>2021-06-29T07:39:48.010Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>高并发，几乎是每个程序员都想拥有的经验。原因很简单：随着流量变大，会遇到各种各样的技术问题，比如接口响应超时、CPU load 升高、GC 频繁、死锁、大数据量存储等等，这些问题能推动我们在技术深度上不断精进。</p></blockquote><a id="more"></a><h1 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发 ?"></a>什么是高并发 ?</h1><blockquote><p>高并发 (High Concurrency): 高并发意味着大流量，需要运用技术手段抵抗流量的冲击，这些手段好比操作流量，能让流量更平稳地被系统所处理，带给用户更好的体验。</p></blockquote><p>我们常见的高并发场景有：淘宝的双11、春运时的抢票、微博大V的热点新闻等。除了这些典型事情，每秒几十万请求的秒杀系统、每天千万级的订单系统、每天亿级日活的信息流系统等，都可以归为高并发。</p><p>高并发相关常用的一些指标有响应时间（Response Time），吞吐量（Throughput），每秒查询率QPS（Query Per Second），并发用户数等</p><h2 id="那到底多大并发才算高并发呢"><a href="#那到底多大并发才算高并发呢" class="headerlink" title="那到底多大并发才算高并发呢 ?"></a>那到底多大并发才算高并发呢 ?</h2><ol><li><p>不能只看数字,要看具体的业务场景.不能说 10W QPS 的秒杀是高并发，而 1W QPS 的信息流就不是高并发。信息流场景涉及复杂的推荐模型和各种人工策略，它的业务逻辑可能比秒杀场景复杂 10 倍不止。因此，不在同一个维度，没有任何比较意义。</p></li><li><p>业务都是从 0 到 1 做起来的，并发量和 QPS 只是参考指标，最重要的是：在业务量逐渐变成原来的 10 倍、100 倍的过程中，你是否用到了高并发的处理方法去严谨你的系统，从架构设计、编码实现、甚至产品方案等维度去预防和解决高并发引起的问题？</p></li></ol><h1 id="如何提升系统的并发能力"><a href="#如何提升系统的并发能力" class="headerlink" title="如何提升系统的并发能力 ?"></a>如何提升系统的并发能力 ?</h1><p>互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。</p><h2 id="垂直扩展"><a href="#垂直扩展" class="headerlink" title="垂直扩展"></a>垂直扩展</h2><ul><li>垂直扩展：提升单机处理能力。垂直扩展的方式又有两种：<ul><li><ol><li>增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G;</li></ol></li><li><ol start="2"><li>提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；</li></ol></li></ul></li></ul><h2 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h2><ul><li>水平扩展：只要增加服务器数量，就能线性扩充系统性能。</li></ul><h1 id="实践方案"><a href="#实践方案" class="headerlink" title="实践方案"></a>实践方案</h1><h2 id="高性能的实践方案"><a href="#高性能的实践方案" class="headerlink" title="高性能的实践方案"></a>高性能的实践方案</h2><ol><li>集群部署, 通过负载均衡减轻单机压力</li><li>多级缓存, 包括静态数据使用CDN,本地缓存,分布式缓存等, 以及对缓存场景中的热点 key、缓存穿透、缓存并发、数据一致性等问题的处理。</li><li>分库分表和索引优化, 以及借助搜索引擎解决复杂查询问题</li><li>考虑 NoSQL 数据库的使用，比如 HBase、TiDB 等，但是团队必须熟悉这些组件，且有较强的运维能力。</li><li>异步化, 将次要流程通过多线程, MQ, 甚至延迟任务进行异步处理</li><li>限流, 需要先考虑业务是否允许限流,比如秒杀场景是允许的），包括前端限流、Nginx 接入层的限流、服务端的限流。</li><li>对流量进行削峰填谷，通过 MQ 承接流量。</li><li>并发处理，通过多线程将串行逻辑并行化</li><li>预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。</li><li>缓存预热，通过异步任务提前预热数据到本地缓存或者分布式缓存中。</li><li>减少 IO 次数，比如数据库和缓存的批量读写、RPC 的批量接口支持、或者通过冗余数据的方式干掉 RPC 调用。</li><li>减少 IO 时的数据包大小，包括采用轻量级的通信协议、合适的数据结构、去掉接口中的多余字段、减少缓存 key 的大小、压缩缓存 value 等。</li><li>程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For 循环的计算逻辑优化，或者采用更高效的算法。</li><li>各种池化技术的使用和池大小的设置，包括 HTTP 请求池、线程池（考虑 CPU 密集型还是 IO 密集型设置核心参数）、数据库和 Redis 连接池等。</li><li>JVM 优化，包括新生代和老年代的大小、GC 算法的选择等，尽可能减少 GC 频率和耗时。</li><li>锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。</li></ol><h2 id="高可用的实践方案"><a href="#高可用的实践方案" class="headerlink" title="高可用的实践方案"></a>高可用的实践方案</h2><ol><li>对等节点的故障转移，Nginx 和服务治理框架均支持一个节点失败后访问另一个节点。</li><li>非对等节点的故障转移，通过心跳检测并实施主备切换（比如 redis 的哨兵模式或者集群模式、MySQL 的主从切换等）。</li><li>接口层面的超时设置、重试策略和幂等设计。</li><li>降级处理：保证核心服务，牺牲非核心服务，必要时进行熔断；或者核心链路出问题时，有备选链路。</li><li>限流处理：对超过系统处理能力的请求直接拒绝或者返回错误码。</li><li>MQ 场景的消息可靠性保证，包括 producer 端的重试机制、broker 侧的持久化、consumer 端的 ack 机制等</li><li>灰度发布，能支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量。</li><li>监控报警：全方位的监控体系，包括最基础的 CPU、内存、磁盘、网络的监控，以及 Web 服务器、JVM、数据库、各类中间件的监控和业务指标的监控。</li><li>灾备演练：类似当前的“混沌工程”，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题。</li></ol><h2 id="高扩展的实践方案"><a href="#高扩展的实践方案" class="headerlink" title="高扩展的实践方案"></a>高扩展的实践方案</h2><ol><li>合理的分层架构：比如上面谈到的互联网最常见的分层架构，另外还能进一步按照数据访问层、业务逻辑层对微服务做更细粒度的分层（但是需要评估性能，会存在网络多一跳的情况）。</li><li>存储层的拆分：按照业务维度做垂直拆分、按照数据特征维度进一步做水平拆分（分库分表）。</li><li>业务层的拆分：最常见的是按照业务维度拆（比如电商场景的商品服务、订单服务等），也可以按照核心接口和非核心接口拆，还可以按照请求去拆（比如 To C 和 To B，APP 和 H5）。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;高并发，几乎是每个程序员都想拥有的经验。原因很简单：随着流量变大，会遇到各种各样的技术问题，比如接口响应超时、CPU load 升高、GC 频繁、死锁、大数据量存储等等，这些问题能推动我们在技术深度上不断精进。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.caoxl.com/tags/PHP/"/>
    
      <category term="高并发" scheme="http://blog.caoxl.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试题 II</title>
    <link href="http://blog.caoxl.com/2021/06/24/Interview-Questions-For-BAT-II/"/>
    <id>http://blog.caoxl.com/2021/06/24/Interview-Questions-For-BAT-II/</id>
    <published>2021-06-24T04:06:35.000Z</published>
    <updated>2021-06-25T03:44:53.137Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>保持学习, 保持警惕, 居安思危, 走出舒适区.</p></blockquote><a id="more"></a><h1 id="来自鸡哥的面试-百度"><a href="#来自鸡哥的面试-百度" class="headerlink" title="来自鸡哥的面试 (百度)"></a>来自鸡哥的面试 (百度)</h1><h2 id="FAST-CGI工作原理"><a href="#FAST-CGI工作原理" class="headerlink" title="FAST-CGI工作原理 ?"></a>FAST-CGI工作原理 ?</h2><ul><li>首先理解什么是CGI</li></ul><blockquote><p>CGI(Common Gateway Interface: 通用网关接口)<br>是Web 服务器运行时外部程序的规范,按CGI 编写的程序可以扩展服务器功能。</p></blockquote><ul><li>CGI协议的缺陷</li></ul><blockquote><p>每次处理用户请求，都需要重新 fork CGI 子进程、销毁 CGI 子进程。<br>一系列的 I/O 开销降低了网络的吞吐量，造成了资源的浪费，在大并发时会产生严重的性能问题。</p></blockquote><ul><li>什么是Fast-CGI</li></ul><blockquote><p>常驻型CGI协议;协议采用 进程间通信(IPC) 来处理用户的请求</p></blockquote><h3 id="FastCGI协议运行原理"><a href="#FastCGI协议运行原理" class="headerlink" title="FastCGI协议运行原理"></a>FastCGI协议运行原理</h3><ul><li>FastCGI 进程管理器启动时会创建一个 主（Master） 进程和多个 CGI 解释器进程（Worker 进程），然后等待 Web 服务器的连接。</li><li>Web 服务器接收 HTTP 请求后，将 CGI 报文通过 套接字（UNIX 或 TCP Socket）进行通信，将环境变量和请求数据写入标准输入,转发到 CGI 解释器进程。</li><li>CGI 解释器进程完成处理后将标准输出和错误信息从同一连接返回给 Web 服务器。</li><li>CGI 解释器进程等待下一个 HTTP 请求的到来。</li></ul><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM ?"></a>PHP-FPM ?</h3><blockquote><p>php-fpm (PHP-FastCGI Process Manager:  FastCGI 进程管理器)<br>php-fpm是FastCGI的实现，并提供了进程管理的功能。<br>php-fpm进程管理器有两种进程组成，一个 Master 进程和多个 Worker 进程。Master 进程负责监听端口，接收来自 Web 服务器的请求，然后指派具体的 Worker 进程处理请求；worker 进程则一般有多个 (依据配置决定进程数)，每个进程内部都嵌入了一个 PHP 解释器，用来执行 PHP 代码。</p></blockquote><h3 id="Nginx-服务器如何与-FastCGI-协同工作"><a href="#Nginx-服务器如何与-FastCGI-协同工作" class="headerlink" title="Nginx 服务器如何与 FastCGI 协同工作"></a>Nginx 服务器如何与 FastCGI 协同工作</h3><blockquote><p>Nginx 服务器无法直接与 FastCGI 服务器进行通信，需要启用 ngx_http_fastcgi_module 模块进行代理配置，才能将请求发送给 FastCGI 服务。</p></blockquote><h2 id="tcp怎么保障可靠性"><a href="#tcp怎么保障可靠性" class="headerlink" title="tcp怎么保障可靠性 ?"></a>tcp怎么保障可靠性 ?</h2><p>TCP 是通过下面几个特性保证数据传输的可靠性：</p><ul><li>序列号和确认应答信号</li><li>超时重发控制</li><li>连接管理</li><li>滑动窗口控制</li><li>流量控制</li><li>拥塞控制 </li></ul><p><a href="https://cloud.tencent.com/developer/article/1591989" target="_blank" rel="noopener">TCP协议可靠性是如何保证之滑动窗口，超时重发，序列号确认应答信号</a></p><h2 id="HTTP状态码502、504的区别"><a href="#HTTP状态码502、504的区别" class="headerlink" title="HTTP状态码502、504的区别 ?"></a>HTTP状态码502、504的区别 ?</h2><h3 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h3><p>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</p><blockquote><p>nginx无法与php-fpm进行连接。<br>nginx在连接php-fpm一段时间后发现与php-fpm的连接被断开。</p></blockquote><h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。</p><h3 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h3><p>当服务器作为网关，不能及时得到响应时返回此错误代码</p><blockquote><p>504即nginx超过了自己设置的超时时间，不等待php-fpm的返回结果，直接给客户端返回504错误。但是此时php-fpm依然还在处理请求（在没有超出自己的超时时间的情况下）。</p></blockquote><h2 id="http响应头connection的作用"><a href="#http响应头connection的作用" class="headerlink" title="http响应头connection的作用 ?"></a>http响应头connection的作用 ?</h2><blockquote><p>当client和server通信时对于长链接如何进行处理<br>在http1.1中，client和server都是默认对方支持长链接的， 如果client使用http1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close.</p></blockquote><p>HTTP Connection的close设置允许客户端或服务器中任何一方关闭底层的连接双方都会要求在处理请求后关闭它们的TCP连接。</p><h2 id="top里面的参数"><a href="#top里面的参数" class="headerlink" title="top里面的参数 ?"></a>top里面的参数 ?</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">top</span> <span class="bullet">-</span> <span class="number">15</span><span class="string">:29:38</span> <span class="string">up</span> <span class="number">21</span> <span class="string">min,</span>  <span class="number">1</span> <span class="string">user,</span>  <span class="attr">load average:</span> <span class="number">0.34</span><span class="string">,</span> <span class="number">0.36</span><span class="string">,</span> <span class="number">0.42</span></span><br><span class="line"><span class="attr">Tasks:</span> <span class="number">151</span> <span class="string">total,</span>   <span class="number">2</span> <span class="string">running,</span> <span class="number">149</span> <span class="string">sleeping,</span>   <span class="number">0</span> <span class="string">stopped,</span>   <span class="number">0</span> <span class="string">zombie</span></span><br><span class="line"><span class="string">%Cpu(s):</span>  <span class="number">0.0</span> <span class="string">us,</span>  <span class="number">0.0</span> <span class="string">sy,</span>  <span class="number">0.0</span> <span class="string">ni,100.0</span> <span class="string">id,</span>  <span class="number">0.0</span> <span class="string">wa,</span>  <span class="number">0.0</span> <span class="string">hi,</span>  <span class="number">0.0</span> <span class="string">si,</span>  <span class="number">0.0</span> <span class="string">st</span></span><br><span class="line"><span class="attr">KiB Mem :</span>  <span class="number">3880924</span> <span class="string">total,</span>   <span class="number">393196</span> <span class="string">free,</span>  <span class="number">2112048</span> <span class="string">used,</span>  <span class="number">1375680</span> <span class="string">buff/cache</span></span><br><span class="line"><span class="attr">KiB Swap:</span>  <span class="number">2097148</span> <span class="string">total,</span>  <span class="number">2097148</span> <span class="string">free,</span>        <span class="number">0</span> <span class="string">used.</span>  <span class="number">1439300</span> <span class="string">avail</span> <span class="string">Mem</span></span><br></pre></td></tr></table></figure><ul><li>第一行是任务队列信息</li><li>第二行是进程信息</li><li>第三行是CPU信息</li><li>第四,五行是内存信息</li></ul><h2 id="lsof-ps-netstat-的区别"><a href="#lsof-ps-netstat-的区别" class="headerlink" title="lsof ps netstat 的区别 ?"></a>lsof ps netstat 的区别 ?</h2><ul><li><code>lsof</code>:（列出打开文件lists openfiles）能看到pid和用户(有权限控制，只能看到本用户)，可以找到哪个进程占用了这个端口</li><li><code>ps</code>:（process）查看有终端控制的所有进程</li><li><code>netstat</code>: 用于显示各种网络相关信息，如网络连接，路由表，接口状态</li></ul><h2 id="php脚本解析流程"><a href="#php脚本解析流程" class="headerlink" title="php脚本解析流程 ?"></a>php脚本解析流程 ?</h2><p>抛开各个SAPI实现上的差异，PHP程序的执行流程可以简单归结如下：</p><ol><li>程序启动, Zend引擎和核心组件初始化</li><li>扩展初始化(MINT)</li><li>收到请求,扩展激活(RINIT)</li><li>解析,执行PHP脚本</li><li>请求结束, 扩展停用 (RSHUTDOWN)</li><li>卸载扩展 (MSHUTDOWN)</li><li>程序关闭</li></ol><h2 id="php的引用是怎么实现的"><a href="#php的引用是怎么实现的" class="headerlink" title="php的引用是怎么实现的 ?"></a>php的引用是怎么实现的 ?</h2><blockquote><p>在PHP中引用意味着用不同的名字访问同一个变量的内容；</p></blockquote><h2 id="destruct-触发机制"><a href="#destruct-触发机制" class="headerlink" title="__destruct() 触发机制 ?"></a>__destruct() 触发机制 ?</h2><p>当销毁一个对象时才会调用对象的析构函数，一般情况下，销毁一个对象的触发时机为</p><ol><li>主动调用<code>unset($obj)</code></li><li>主动调用<code>$obj = null</code></li><li>程序自动结束</li></ol><h2 id="应用进程和内核的关系"><a href="#应用进程和内核的关系" class="headerlink" title="应用进程和内核的关系 ?"></a>应用进程和内核的关系 ?</h2><ul><li>应用进程即用户态进程，运行于操作系统之上，通过系统调用与操作系统进行交互</li><li>内核即操作系统内核，用于控制计算机硬件。</li></ul><h2 id="普通索引的查询流程"><a href="#普通索引的查询流程" class="headerlink" title="普通索引的查询流程 ?"></a>普通索引的查询流程 ?</h2><h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><ul><li>普通索引: 查找到满足条件的第一个记录后，需要查找下一个记录， 直到碰到第一个不满足条件的记录。</li><li>唯一索引: 由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索</li></ul><h3 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h3><ul><li>普通索引: 唯一索引的更新就不能使用 change buffer，只有普通索引可以使用</li><li>唯一索引: 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。</li></ul><h3 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h3><ul><li>普通索引: 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li><li>唯一索引: 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束</li></ul><h3 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h3><blockquote><p>写缓存（Change Buffer） 是一种特殊的数据结构，用于在对数据变更时，如果数据所在的数据页没有在 buffer pool 中的话，在不影响数据一致性的前提下，InnoDB 引擎会将对数据的操作缓存在 Change Buffer 中，这样就省去了从磁盘中读入这个数据页。</p></blockquote><h2 id="Docker网段冲突"><a href="#Docker网段冲突" class="headerlink" title="Docker网段冲突 ?"></a>Docker网段冲突 ?</h2><p>docker默认网段是172.17，和公司的网段冲突，因此解决的办法其实也挺简单的，要么换公司网段，要么换docker网段，是个正常人都会选择换docker网段</p><h3 id="方案一：不改docker网段，创建不和公司网段冲突的docker子网段"><a href="#方案一：不改docker网段，创建不和公司网段冲突的docker子网段" class="headerlink" title="方案一：不改docker网段，创建不和公司网段冲突的docker子网段"></a>方案一：不改docker网段，创建不和公司网段冲突的docker子网段</h3><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver=bridge --subnet=<span class="number">192.161</span>.<span class="number">0.0</span>/<span class="number">16</span> monitor_net</span><br></pre></td></tr></table></figure><p>docker network create –driver=bridge –subnet=192.161.0.0/16 monitor_net</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -it --name &lt;容器名&gt; ---network monitor_net  &lt;镜像名</span></span><br></pre></td></tr></table></figure><p>在docker-compose同样通过networks指定，形如下</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">    version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="symbol">networks:</span></span><br><span class="line"><span class="symbol">   monitor:</span></span><br><span class="line">   <span class="meta">#使用已经存在的网络</span></span><br><span class="line"><span class="symbol">     external:</span></span><br><span class="line"><span class="symbol">       name:</span> monitor_net  </span><br><span class="line"></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">    prometheus:</span></span><br><span class="line"><span class="symbol">        image:</span> prom/prometheus</span><br><span class="line"><span class="symbol">        container_name:</span> prometheus</span><br><span class="line"><span class="symbol">        hostname:</span> prometheus</span><br><span class="line"><span class="symbol">        privileged:</span> true</span><br><span class="line"><span class="symbol">        restart:</span> always</span><br><span class="line"><span class="symbol">        volumes:</span></span><br><span class="line">            - <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/src/</span>config/prometheus.yml:<span class="meta-keyword">/etc/</span>prometheus/prometheus.yml</span><br><span class="line">            - <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/src/</span>config/node_down.yml:<span class="meta-keyword">/etc/</span>prometheus/node_down.yml</span><br><span class="line"><span class="symbol">        ports:</span></span><br><span class="line">            - <span class="string">"9091:9090"</span></span><br><span class="line"><span class="symbol">        networks:</span></span><br><span class="line">            - monitor</span><br><span class="line"><span class="symbol">        links:</span></span><br><span class="line">            - alertmanager</span><br><span class="line">            - node-exporter</span><br></pre></td></tr></table></figure><h3 id="方案二：修改docker默认网段"><a href="#方案二：修改docker默认网段" class="headerlink" title="方案二：修改docker默认网段"></a>方案二：修改docker默认网段</h3><ol><li>停止docker</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><ol start="2"><li>删除原有网桥</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link del docker0 down</span><br></pre></td></tr></table></figure><ol start="3"><li>vim /etc/docker/daemon.json，添加形如下内容</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"bip"</span>:<span class="string">"192.161.20.1/24"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>重启docker服务</li></ol><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="Docker-for-mac"><a href="#Docker-for-mac" class="headerlink" title="Docker for mac"></a>Docker for mac</h3><p>如果本地环境是 Docker for mac，依次打开 Preferences -&gt; Daemon -&gt; Advanced ，增加配置 <code>&quot;bip&quot; : &quot;172.16.10.1/24&quot;</code>，从而避免网段冲突的问题。</p><h3 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker-machine"></a>docker-machine</h3><p>编辑文件<code>/etc/docker/daemon.json</code>，增加 <code>{&quot;bip&quot; : &quot;172.16.10.1/24&quot;}</code>，然后退出虚拟机，重启docker-machine即可成功修改网段。</p><h1 id="来自鸡哥的面试-SHEIN"><a href="#来自鸡哥的面试-SHEIN" class="headerlink" title="来自鸡哥的面试 (SHEIN)"></a>来自鸡哥的面试 (SHEIN)</h1><h2 id="进程-线程-协程的区别"><a href="#进程-线程-协程的区别" class="headerlink" title="进程, 线程, 协程的区别 ?"></a>进程, 线程, 协程的区别 ?</h2><h3 id="进程是什么？"><a href="#进程是什么？" class="headerlink" title="进程是什么？"></a>进程是什么？</h3><p>进程就是应用程序的启动实例。<br>例如：打开一个软件，就是开启了一个进程。<br>进程拥有代码和打开的文件资源，数据资源，独立的内存空间。</p><h3 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么?"></a>线程是什么?</h3><p>线程属于进程，是程序的执行者。<br>一个进程至少包含一个主线程，也可以有更多的子线程。<br>线程有两种调度策略，一是：分时调度，二是：抢占式调度。</p><h3 id="协程是什么？"><a href="#协程是什么？" class="headerlink" title="协程是什么？"></a>协程是什么？</h3><p>协程是轻量级线程，协程的创建、切换、挂起、销毁全部为内存操作，消耗是非常低的。<br>协程是属于线程，协程是在线程里执行的。<br>协程的调度是用户手动切换的，所以又叫用户空间线程。<br>协程的调度策略是：协作式调度。</p><h2 id="什么是缓存雪崩-缓存穿透-缓存击穿"><a href="#什么是缓存雪崩-缓存穿透-缓存击穿" class="headerlink" title="什么是缓存雪崩,缓存穿透,缓存击穿 ?"></a>什么是缓存雪崩,缓存穿透,缓存击穿 ?</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>缓存在某一个时刻出现大规模的key失效<br>那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。</p></blockquote><ul><li>解决方案</li></ul><p>(1): 事前</p><ol><li>设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。</li><li>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</li><li>热点数据缓存永远不过期。</li><li>保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。</li></ol><p>(2): 事中</p><ol><li>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</li><li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</li></ol><p>(3): 事后</p><ol><li>开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><blockquote><p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p></blockquote><ul><li>解决方案</li></ul><ol><li>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</li><li>热点数据缓存永远不过期。</li></ol><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><blockquote><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p></blockquote><ul><li>解决方案</li></ul><ol><li>将无效的key存放进Redis中</li><li>使用布隆过滤器</li></ol><h3 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h3><blockquote><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p></blockquote><h3 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h3><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p><p>在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。</p><h2 id="B-tree是什么-优缺点"><a href="#B-tree是什么-优缺点" class="headerlink" title="B+tree是什么 ? 优缺点?"></a>B+tree是什么 ? 优缺点?</h2><p>首先注意：B树就是B-树，”-“是个连字符号，不是减号。</p><p>B-树是一种平衡的多路查找(又称排序)树，在文件系统中有所应用。主要用作文件的索引。其中的B就表示平衡(Balance)</p><p>B+树有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了。</p><ul><li>优点</li></ul><ol><li>单次请求涉及的磁盘IO次数少（出度d大，且非叶子节点不包含表数据，树的高度小）</li><li>查询效率稳定（任何关键字的查询必须走从根结点到叶子结点，查询路径长度相同）</li><li>遍历效率高（从符合条件的某个叶子节点开始遍历即可）</li></ol><ul><li>缺点</li></ul><ol><li>B+树最大的性能问题在于会产生大量的随机IO，主要存在以下两种情况<ul><li>主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片；</li><li>即使主键是有序递增的，大量写请求的分布仍是随机的；</li></ul></li></ol><h2 id="什么是死信队列"><a href="#什么是死信队列" class="headerlink" title="什么是死信队列 ?"></a>什么是死信队列 ?</h2><blockquote><p>死信队列：没有被及时消费的消息存放的队列</p></blockquote><ul><li>消息被拒绝（basic.reject/ basic.nack）并且不再重新投递 requeue=false</li><li>TTL(time-to-live) 消息超时未消费</li><li>达到最大队列长度</li></ul><blockquote><p>消息变成死信后，会被重新投递（publish）到另一个交换机上（Exchange）,这个交换机往往被称为DLX(dead-letter-exchange)“死信交换机”，然后交换机根据绑定规则转发到对应的队列上，监听该队列就可以被重新消费。</p><p>生产者–&gt;发送消息–&gt;交换机–&gt;队列–&gt;变成死信队列–&gt;DLX交换机–&gt;队列–&gt;监听–&gt;消费者</p></blockquote><h2 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略 ?"></a>Redis的过期策略 ?</h2><ul><li>定时过期: 每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除<ul><li>优点: 该策略可以立即清除过期的数据，对内存很友好</li><li>缺点 但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li></ul></li><li>惰性过期: 只有当访问一个key时，才会判断该key是否已过期，过期则清除。<ul><li>优点: 该策略可以最大化地节省CPU资源，却对内存非常不友好。</li><li>缺点: 极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li></ul></li><li>定期过期: 每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。<ul><li>优点: 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点 定期删除过期key–处理”惰性删除”的缺点。</li><li>缺点: 在内存友好方面，不如”定时删除”，因为是随机遍历一些key，因此存在部分key过期，但遍历key时，没有被遍历到，过期的key仍在内存中。在CPU时间友好方面，不如”惰性删除”，定期删除也会暂用CPU性能消耗。</li></ul></li></ul><blockquote><p>Redis中同时使用了惰性过期和定期过期两种过期策略。</p></blockquote><h3 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h3><ul><li><code>noeviction</code>：当内存不足以容纳新写入数据时，新写入操作会报错。</li><li><code>allkeys-lru</code>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li><li><code>allkeys-random</code>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li><li><code>volatile-lru</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li><code>volatile-random</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li><code>volatile-ttl</code>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除</li></ul><h2 id="Laravel的队列实现原理"><a href="#Laravel的队列实现原理" class="headerlink" title="Laravel的队列实现原理 ?"></a>Laravel的队列实现原理 ?</h2><blockquote><p>redis的延迟队列一般是通过有序集合zset实现的</p></blockquote><h1 id="更早的一些面试题"><a href="#更早的一些面试题" class="headerlink" title="更早的一些面试题"></a>更早的一些面试题</h1><h2 id="Mysql负载均衡-主从复制问题"><a href="#Mysql负载均衡-主从复制问题" class="headerlink" title="Mysql负载均衡,主从复制问题"></a>Mysql负载均衡,主从复制问题</h2><h2 id="非关系型数据库的优缺点"><a href="#非关系型数据库的优缺点" class="headerlink" title="非关系型数据库的优缺点?"></a>非关系型数据库的优缺点?</h2><ul><li>先说说关系型数据库优点</li></ul><ol><li>都是使用表结构，格式一致，易于维护。</li><li>使用通用的 SQL 语言操作，使用方便，可用于复杂查询。</li><li>数据存储在磁盘中，安全。</li></ol><ul><li>非关系型数据库优点</li></ul><ol><li>非关系型数据库存储数据的格式可以是 key-value 形式、文档形式、图片形式等。使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。</li><li>速度快，效率高。 NoSQL 可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘。</li><li>海量数据的维护和处理非常轻松。</li><li>非关系型数据库具有扩展简单、高并发、高稳定性、成本低廉的优势。</li><li>可以实现数据的分布式处理。</li></ol><ul><li>非关系型数据库缺点</li></ul><ol><li>非关系型数据库暂时不提供 SQL 支持，学习和使用成本较高。</li><li>非关系数据库没有事务处理，没有保证数据的完整性和安全性。适合处理海量数据，但是不一定安全。</li><li>功能没有关系型数据库完善。</li></ol><h2 id="Redis的类型以及应用场景"><a href="#Redis的类型以及应用场景" class="headerlink" title="Redis的类型以及应用场景"></a>Redis的类型以及应用场景</h2><ul><li><a href="https://laravelacademy.org/books/high-performance-redis" target="_blank" rel="noopener">高性能 Redis 实战</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;保持学习, 保持警惕, 居安思危, 走出舒适区.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 通过binlog恢复数据</title>
    <link href="http://blog.caoxl.com/2021/03/24/MySQL-Restore-By-Binlog/"/>
    <id>http://blog.caoxl.com/2021/03/24/MySQL-Restore-By-Binlog/</id>
    <published>2021-03-24T09:19:17.000Z</published>
    <updated>2021-03-25T09:18:09.991Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日常开发，运维中，经常会出现误删数据的情况。误删数据的类型大致可分为以下几类：</p><ul><li>使用 <code>delete</code> 误删行</li><li>使用 <code>drop table</code> 或 <code>truncate table</code> 误删表</li><li>使用 <code>drop database</code> 语句误删数据库</li><li>使用 <code>rm</code> 命令误删整个 MySQL 实例。</li></ul><a id="more"></a><h1 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h1><p>通过了解 binlog 日志的相关配置，简单掌握通过 binlog 对数据库进行数据恢复操作；</p><h1 id="mysql-日志文件"><a href="#mysql-日志文件" class="headerlink" title="mysql 日志文件"></a>mysql 日志文件</h1><p>mysql 主要有以下几种日志：</p><ul><li>错误日志：记录 mysql 运行过程中的错误信息</li><li>一般查询日志：记录 mysql 正在运行的语句，包括查询、修改、更新等的每条 sql</li><li>慢查询日志：记录查询比较耗时的 SQL 语句</li><li>binlog 日志：记录数据修改记录，包括创建表、数据更新等</li></ul><p>这些日志均需要在 my.cnf 文件进行配置，如果不知道 mysql 的配置文件路径，可以使用 mysql 命令进行查找，</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="params">--verbose</span> <span class="params">--help</span> | grep -A 1 'Default options’ <span class="comment">#该命令会罗列出my.cnf顺序查找的路径。</span></span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[WWW] mysql --verbose --help | grep -A 1 <span class="string">'Default options'</span></span><br><span class="line">Default options are read <span class="keyword">from</span> the following files <span class="keyword">in</span> the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /Applications/MAMP/conf/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><h1 id="binlog-日志"><a href="#binlog-日志" class="headerlink" title="binlog 日志"></a>binlog 日志</h1><p><code>binlog</code> 就是 <code>binary log</code>，二进制日志文件，记录所有数据库更新语句，包括表更新和记录更新，即数据操纵语言 (DML)，<code>binlog</code> 主要用于数据恢复和配置主从复制等；</p><blockquote><ul><li>数据恢复：当数据库误删或者发生不可描述的事情时，可以通过 binlog 恢复到某个时间点的数据。</li><li>主从复制：当有数据库更新之后，主库通过 binlog 记录并通知从库进行更新，从而保证主从数据库数据一致；</li></ul></blockquote><p>mysql 按照功能分为服务层模块和存储引擎层模块，服务层负责客户端连接、SQL 语句处理优化等操作，存储引擎层负责数据的存储和查询；</p><p>binlog 属于服务层模块的日志，即引擎无关性，所有数据引擎的数据更改都会记录 binlog 日志。</p><p>当数据库发生崩溃时，如果使用 InnoDB 引擎，binlog 日志还可以检验 InnoDB 的 redo 日志的 commit 情况。</p><h1 id="binlog-日志开启"><a href="#binlog-日志开启" class="headerlink" title="binlog 日志开启"></a>binlog 日志开启</h1><h2 id="日志开启方式"><a href="#日志开启方式" class="headerlink" title="日志开启方式"></a>日志开启方式</h2><ol><li>添加配置</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log_bin</span>=<span class="literal">ON</span></span><br><span class="line"><span class="attr">log_bin_basename</span>=/path/bin-log</span><br><span class="line"><span class="attr">log_bin_index</span>=/path/bin-log.index</span><br></pre></td></tr></table></figure><ol start="2"><li>仅仅设置log-bin参数</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>-bin=/<span class="built_in">path</span>/bin-<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>当开启 binlog 日志之后，mysql 会创建一个 log_bin_index 指定的 .index 文件和多个二进制日志文件，index 中按顺序记录了 mysql 使用的所有 binlog 文件。binlog 日志则会以指定的名称 (或默认值) 加自增的数字作为后缀，ex：<code>bin-log.000001</code>，当发生下述三种情况时，binlog 日志便会进行重建</p><blockquote><p>文件大小达到 <code>max_binlog_size</code> 参数的值<br>执行 flush logs 命令<br>重启 mysql 服务</p></blockquote><p>实例:</p><ul><li>设置log-bin参数</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log-bin</span> = /Users/caoxl/WWW/mysqlbinlog/mysql-binlog</span><br><span class="line"><span class="attr">binlog_format</span> = row</span><br></pre></td></tr></table></figure><ul><li>查看log-bin是否开启</li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="emphasis">'log_bin'</span>;</span><br><span class="line"><span class="code">+---------------+</span>-------+</span><br><span class="line">| Variable<span class="emphasis">_name | Value |</span></span><br><span class="line"><span class="emphasis">+---------------+-------+</span></span><br><span class="line"><span class="emphasis">| log_</span>bin       | OFF   |</span><br><span class="line"><span class="code">+---------------+</span>-------+</span><br><span class="line">1 row in set (0.20 sec)</span><br><span class="line"><span class="code"> </span></span><br><span class="line">mysql&gt; show variables like <span class="emphasis">'log_bin'</span>;</span><br><span class="line"><span class="code">+---------------+</span>-------+</span><br><span class="line">| Variable<span class="emphasis">_name | Value |</span></span><br><span class="line"><span class="emphasis">+---------------+-------+</span></span><br><span class="line"><span class="emphasis">| log_</span>bin       | ON    |</span><br><span class="line"><span class="code">+---------------+</span>-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><h2 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h2><p>通过参数 <code>binlog_format</code> 参数的值，可以设置 <code>binlog</code> 的格式，可选值有 <code>statement</code>、<code>row</code>、<code>mixed</code></p><ul><li><code>statement</code> 格式：记录数据库执行的原始 SQL 语句</li><li><code>row</code> 格式：记录具体的行的修改，这个为目前默认值</li><li><code>mixed</code> 格式：因为上边两种格式各有优缺点，所以就出现了 mixed 格式</li></ul><h1 id="binlog-日志查看工具：mysqlbinlog"><a href="#binlog-日志查看工具：mysqlbinlog" class="headerlink" title="binlog 日志查看工具：mysqlbinlog"></a>binlog 日志查看工具：mysqlbinlog</h1><p>因为 binlog 是二进制文件，不能像其他文件一样，直接打开查看。但 mysql 提供了 binlog 查看工具 mysqlbinlog，可以解析二进制文件。当然不同格式的日志解析结果是不一样的；</p><ol><li>statement 格式日志，执行 <code>mysqlbinlog /path/bin-log.000001</code>，可以直接看到原始执行的 SQL 语句</li><li>row 格式日志，则可读性没有那么好，但仍可通过参数使文档更加可读 <code>mysqlbinlog -v /path/bin-log.000001</code></li></ol><p><code>mysqlbinlog</code> 两对非常重要的参数</p><ol><li><code>--start-datetime</code> &amp; <code>--stop-datetime</code> 解析某一个时间段内的 binlog；</li><li><code>--start-position</code> &amp; <code>--stop-position</code> 解析在两个 position 之间的 binlog；</li></ol><h1 id="使用-binlog-恢复数据"><a href="#使用-binlog-恢复数据" class="headerlink" title="使用 binlog 恢复数据"></a>使用 binlog 恢复数据</h1><p>使用 <code>binlog</code> 恢复数据，本质上就是通过 <code>binlog</code> 找到所有 DML 操作，去掉错误的 SQL 语句，然后重走一遍长征路，就可以将数据恢复；</p><h2 id="通过-MySQL-Cli-查询-BINLOG-信息"><a href="#通过-MySQL-Cli-查询-BINLOG-信息" class="headerlink" title="通过 MySQL Cli 查询 BINLOG 信息"></a>通过 MySQL Cli 查询 BINLOG 信息</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 查询 BINLOG 格式</span><br><span class="line">mysql&gt; show variables like <span class="emphasis">'binlog_format'</span>;</span><br><span class="line"><span class="code">+---------------+</span>-------+</span><br><span class="line">| Variable<span class="emphasis">_name | Value |</span></span><br><span class="line"><span class="emphasis">+---------------+-------+</span></span><br><span class="line"><span class="emphasis">| binlog_</span>format | ROW   |</span><br><span class="line"><span class="code">+---------------+</span>-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 查询当前数据库中 BINLOG 名称及大小</span><br><span class="line">mysql&gt; show binary logs;</span><br><span class="line"><span class="code">+---------------------+</span>-----------+</span><br><span class="line">| Log<span class="emphasis">_name            | File_</span>size |</span><br><span class="line"><span class="code">+---------------------+</span>-----------+</span><br><span class="line">| mysql-binlog.000001 |       177 |</span><br><span class="line">| mysql-binlog.000002 |       177 |</span><br><span class="line">| mysql-binlog.000003 |      2120 |</span><br><span class="line">| mysql-binlog.000004 |       154 |</span><br><span class="line"><span class="code">+---------------------+</span>-----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 查看 master 正在写入的 BINLOG 信息</span><br><span class="line">mysql&gt; show master status\G;</span><br><span class="line"><span class="bullet">*************************** </span>1. row **************************<span class="strong">*</span></span><br><span class="line"><span class="strong">             File: mysql-binlog.000004</span></span><br><span class="line"><span class="strong">         Position: 154</span></span><br><span class="line"><span class="strong">     Binlog_Do_DB: </span></span><br><span class="line"><span class="strong"> Binlog_Ignore_DB: </span></span><br><span class="line"><span class="strong">Executed_Gtid_Set: </span></span><br><span class="line"><span class="strong">1 row in set (0.00 sec)</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">ERROR: </span></span><br><span class="line"><span class="strong">No query specified</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong"># 通过 offset 查看 BINLOG 信息</span></span><br><span class="line"><span class="strong">mysql&gt; show BINLOG events in 'mysql-binlog.000004' limit 1,  10;</span></span><br><span class="line"><span class="strong">+---------------------+-----+----------------+-----------+-------------+------+</span></span><br><span class="line"><span class="strong">| Log_name            | Pos | Event_type     | Server_id | End_log_pos | Info |</span></span><br><span class="line"><span class="strong">+---------------------+-----+----------------+-----------+-------------+------+</span></span><br><span class="line"><span class="strong">| mysql-binlog.000004 | 123 | Previous_gtids |         1 |         154 |      |</span></span><br><span class="line"><span class="strong">+---------------------+-----+----------------+-----------+-------------+------+</span></span><br><span class="line"><span class="strong">1 row in set (0.00 sec)</span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong"># 通过 position 查看 binlog 信息</span></span><br><span class="line"><span class="strong">mysql&gt; show BINLOG events in 'mysql-binlog.000004' from 1 limit 10;</span></span><br><span class="line"><span class="strong">+---------------------+-----+----------------+-----------+-------------+---------------------------------------+</span></span><br><span class="line"><span class="strong">| Log_name            | Pos | Event_type     | Server_id | End_log_pos | Info                                  |</span></span><br><span class="line"><span class="strong">+---------------------+-----+----------------+-----------+-------------+---------------------------------------+</span></span><br><span class="line"><span class="strong">| mysql-binlog.000004 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.26-log, Binlog ver: 4 |</span></span><br><span class="line"><span class="strong">| mysql-binlog.000004 | 123 | Previous_gtids |         1 |         154 |                                       |</span></span><br><span class="line"><span class="strong">+---------------------+-----+----------------+-----------+-------------+---------------------------------------+</span></span><br><span class="line"><span class="strong">2 rows in set (0.00 sec)</span></span><br></pre></td></tr></table></figure><h2 id="通过-mysqlbinlog-查询-BINLOG-信息"><a href="#通过-mysqlbinlog-查询-BINLOG-信息" class="headerlink" title="通过 mysqlbinlog 查询 BINLOG 信息"></a>通过 mysqlbinlog 查询 BINLOG 信息</h2><p>在介绍 <code>mysqlbinlog</code> 工具使用前，先来看下 BINLOG 文件的内容：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询 BINLOG 的信息</span></span><br><span class="line"><span class="attribute">mysqlbinlog</span> --<span class="literal">no</span>-defaults mysql-binlog.<span class="number">000004</span> | less</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># at <span class="number">219</span></span><br><span class="line">#<span class="number">210325</span> <span class="number">15</span>:<span class="number">43</span>:<span class="number">01</span> server id <span class="number">1</span>  end_log_pos <span class="number">293</span> CRC32 <span class="number">0x1ccf5f28</span> Querythread_id=<span class="number">149</span>exec_time=<span class="number">0</span>error_code=<span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><code>at</code> 表示 offset 或者说事件开始的起始位置</li><li><code>210325 15:43:01 server id 1</code> 表示 server 1 开始执行事件的日期</li><li><code>end_log_pos 293</code> 表示事件的结束位置 + 1，或者说是下一个事件的起始位置。</li><li><code>exec_time</code> 表示在 master 上花费的时间，在 salve 上，记录的时间是从 Master 记录开始，一直到 Slave 结束完成所花费的时间。</li><li><code>error_code=0</code> 表示没有错误发生。</li></ul><h2 id="导出-BINLOG-日志，用于分析和排查-sql-语句："><a href="#导出-BINLOG-日志，用于分析和排查-sql-语句：" class="headerlink" title="导出 BINLOG 日志，用于分析和排查 sql 语句："></a>导出 BINLOG 日志，用于分析和排查 sql 语句：</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="params">--no-defaults</span> <span class="params">--base64-output=decode-rows</span> -v \</span><br><span class="line"> <span class="params">--start-datetime</span>  <span class="string">"2021-03-25 14:00:00"</span> \</span><br><span class="line"> mysql-binlog.000004 &gt; <span class="string">/path/binlog_raw.sql</span></span><br></pre></td></tr></table></figure><h1 id="数据实操"><a href="#数据实操" class="headerlink" title="数据实操"></a>数据实操</h1><p>恢复的大致流程如下:</p><blockquote><ol><li>创建数据库和表，并插入数据。</li><li>误删一条数据</li><li>继续插入数据。</li><li>误删表。</li><li>最后将原来以及之后插入的数据进行恢复。</li></ol></blockquote><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><ul><li>准备数据库，表及数据：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建临时数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> test_binlog \</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">charset</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建临时表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`sync_test`</span> (<span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) \</span><br><span class="line"><span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT, <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  \</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) ) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sync_test (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="literal">null</span>, <span class="string">'xiaoa'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sync_test (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="literal">null</span>, <span class="string">'xiaob'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sync_test (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="literal">null</span>, <span class="string">'xiaoc'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看添加的数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> sync_test;</span><br></pre></td></tr></table></figure><h2 id="删除表或者数据"><a href="#删除表或者数据" class="headerlink" title="删除表或者数据"></a>删除表或者数据</h2><ul><li>误删操作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 name=xiaoc 的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> sync_test <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入几条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sync_test (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="literal">null</span>, <span class="string">'xiaod'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sync_test (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="literal">null</span>, <span class="string">'xiaoe'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sync_test (<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span> (<span class="literal">null</span>, <span class="string">'xiaof'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> sync_test;</span><br></pre></td></tr></table></figure><h2 id="数据的恢复"><a href="#数据的恢复" class="headerlink" title="数据的恢复"></a>数据的恢复</h2><p>在执行数据恢复前，如果操作的是生产环境，会有如下的建议：</p><ul><li>使用 <code>flush logs</code> 命令，替换当前主库中正在使用的 <code>binlog</code> 文件，好处如下：<ul><li>可将误删操作，定位在一个 BINLOG 文件中，便于之后的数据分析和恢复。</li><li>避免操作正在被使用的 BINLOG 文件，防止发生意外情况。</li></ul></li><li>数据的恢复不要在生产库中执行，先在临时库恢复，确认无误后，再倒回生产库。防止对数据的二次伤害。</li></ul><p>通常来说，恢复主要有两个步骤：</p><ol><li>在临时库中，恢复定期执行的全量备份数据。</li><li>然后基于全量备份的数据点，通过 BINLOG 来恢复误操作和正常的数据。</li></ol><h3 id="使用-BINLOG-做数据恢复前"><a href="#使用-BINLOG-做数据恢复前" class="headerlink" title="使用 BINLOG 做数据恢复前"></a>使用 BINLOG 做数据恢复前</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看正在使用的 Binlog 文件</span></span><br><span class="line">mysql&gt; show master status\G;</span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">** 1. row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line"><span class="code">             File: mysql-binlog.000004</span></span><br><span class="line"><span class="code">         Position: 3325</span></span><br><span class="line"><span class="code">     Binlog_Do_DB: </span></span><br><span class="line"> Binlog<span class="emphasis">_Ignore_</span>DB: </span><br><span class="line">Executed<span class="emphasis">_Gtid_</span>Set: </span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"><span class="section"># 显示结果是: mysql-binlog.000004</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 执行 flush logs 操作，生成新的 BINLOG</span></span><br><span class="line">mysql&gt; flush logs;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看正在使用的 Binlog 文件</span></span><br><span class="line">mysql&gt; show master status\G;</span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">** 1. row **</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line"><span class="code">             File: mysql-binlog.000005</span></span><br><span class="line"><span class="code">         Position: 154</span></span><br><span class="line"><span class="code">     Binlog_Do_DB: </span></span><br><span class="line"> Binlog<span class="emphasis">_Ignore_</span>DB: </span><br><span class="line">Executed<span class="emphasis">_Gtid_</span>Set: </span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"><span class="section"># 显示结果是: mysql-binlog.000005</span></span><br></pre></td></tr></table></figure><h3 id="确定恢复数据的步骤"><a href="#确定恢复数据的步骤" class="headerlink" title="确定恢复数据的步骤"></a>确定恢复数据的步骤</h3><p>这里主要是有两条误删的操作，数据行的误删和表的误删。有两种方式进行恢复。</p><ul><li>方式一：首先恢复到删除表操作之前的位置，然后再单独恢复误删的数据行。</li><li>方式二：首先恢复到误删数据行的之前的位置，然后跳过误删事件再恢复数据表操作之前的位置。</li></ul><p>这里采用方式一的方案进行演示，由于是演示，就不额外找一个临时库进行全量恢复了，直接进行操作。</p><h3 id="查询创建表的事件位置和删除表的事件位置"><a href="#查询创建表的事件位置和删除表的事件位置" class="headerlink" title="查询创建表的事件位置和删除表的事件位置"></a>查询创建表的事件位置和删除表的事件位置</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据时间确定位置信息</span></span><br><span class="line">mysqlbinlog <span class="params">--no-defaults</span> <span class="params">--base64-output=decode-rows</span> -v \</span><br><span class="line"> <span class="params">--start-datetime</span>  <span class="string">"2021-03-25 14:00:00"</span> \</span><br><span class="line"> <span class="params">--database</span> test_binlog  mysql-binlog.000005 | less</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出SQL,方便分析</span></span><br><span class="line">mysqlbinlog <span class="params">--no-defaults</span> <span class="params">--base64-output=decode-rows</span> -v \</span><br><span class="line"> <span class="params">--start-datetime</span>  <span class="string">"2021-03-25 14:00:00"</span> \</span><br><span class="line"> mysql-binlog.000001 &gt; <span class="string">/your-path/binlog_raw.sql</span></span><br></pre></td></tr></table></figure><h4 id="创建表的开始位置"><a href="#创建表的开始位置" class="headerlink" title="创建表的开始位置:"></a>创建表的开始位置:</h4><p><img src="https://caoxl.com/imgs/create_table.png" alt="创建表的开始位置"></p><h4 id="创建表的结束位置"><a href="#创建表的结束位置" class="headerlink" title="创建表的结束位置:"></a>创建表的结束位置:</h4><p><img src="https://caoxl.com/imgs/drop_table.png" alt="创建表的结束位置"></p><h4 id="插入-name-39-xiaoc-39-的位置："><a href="#插入-name-39-xiaoc-39-的位置：" class="headerlink" title="插入 name=&#39;xiaoc&#39; 的位置："></a>插入 <code>name=&#39;xiaoc&#39;</code> 的位置：</h4><p><img src="https://caoxl.com/imgs/insert_table.png" alt="插入 `name=&#39;xiaoc&#39;` 的位置"></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据位置导出 SQL 文件</span></span><br><span class="line">mysqlbinlog <span class="params">--no-defaults</span> <span class="params">--base64-output=decode-rows</span> -v \</span><br><span class="line"> <span class="params">--start-position</span> <span class="string">"398"</span> <span class="params">--stop-position</span> <span class="string">"2699"</span> \</span><br><span class="line"> <span class="params">--database</span> test_binlog  mysql-binlog.000005 \</span><br><span class="line"> &gt; <span class="string">/your-path/test_binlog_step1.sql</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mysqlbinlog <span class="params">--no-defaults</span> <span class="params">--base64-output=decode-rows</span> -v \</span><br><span class="line"> <span class="params">--start-position</span> <span class="string">"1279"</span> <span class="params">--stop-position</span> <span class="string">"1563"</span> \</span><br><span class="line"> <span class="params">--database</span> test_binlog  mysql-binlog.000005 \</span><br><span class="line"> &gt; <span class="string">/your-path/test_binlog_step2.sql</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 mysql 进行恢复</span></span><br><span class="line">mysql -u root -p &lt; <span class="string">/your-path//test_binlog_step1.sql</span></span><br><span class="line">mysql -u root -p &lt; <span class="string">/your-path//test_binlog_step2.sql</span></span><br></pre></td></tr></table></figure><blockquote><p>MySQL 5.7 中无论是否打开 GTID 的配置，在每次事务开启时，都首先会出 GTID 的一个事务，用于并行复制。所以在确定导出开始事务位置时，要算上这个事件。<br>在使用 –stop-position 导出时，会导出在指定位置的前一个事件，所以这里要推后一个事务。<br>对于 DML 的语句，主要结束位置要算上 COMMIT 的位置。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常开发，运维中，经常会出现误删数据的情况。误删数据的类型大致可分为以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;delete&lt;/code&gt; 误删行&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;drop table&lt;/code&gt; 或 &lt;code&gt;truncate table&lt;/code&gt; 误删表&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;drop database&lt;/code&gt; 语句误删数据库&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;rm&lt;/code&gt; 命令误删整个 MySQL 实例。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="MySQL" scheme="http://blog.caoxl.com/tags/MySQL/"/>
    
      <category term="Binlog" scheme="http://blog.caoxl.com/tags/Binlog/"/>
    
  </entry>
  
  <entry>
    <title>梁超 作品集</title>
    <link href="http://blog.caoxl.com/2020/12/23/Liangchao-UI-PM-Resume/"/>
    <id>http://blog.caoxl.com/2020/12/23/Liangchao-UI-PM-Resume/</id>
    <published>2020-12-23T02:54:40.000Z</published>
    <updated>2020-12-23T02:59:31.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>梁超 2019-2020作品集</p></blockquote><a id="more"></a><p><img src="https://caoxl.oss-cn-shenzhen.aliyuncs.com/%E4%B9%90%E4%B9%90/lc_hd.jpg" alt="作品集"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;梁超 2019-2020作品集&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="caoxl" scheme="http://blog.caoxl.com/categories/caoxl/"/>
    
    
      <category term="梁超" scheme="http://blog.caoxl.com/tags/%E6%A2%81%E8%B6%85/"/>
    
      <category term="UI" scheme="http://blog.caoxl.com/tags/UI/"/>
    
      <category term="产品" scheme="http://blog.caoxl.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试题 I</title>
    <link href="http://blog.caoxl.com/2020/11/12/Interview-Questions-For-BAT-I/"/>
    <id>http://blog.caoxl.com/2020/11/12/Interview-Questions-For-BAT-I/</id>
    <published>2020-11-12T02:19:14.000Z</published>
    <updated>2020-11-12T07:36:07.853Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>保持学习, 保持警惕, 居安思危, 走出舒适区.</p></blockquote><a id="more"></a><h1 id="字节一面"><a href="#字节一面" class="headerlink" title="字节一面"></a>字节一面</h1><h2 id="在面对未知的流量暴增，可以预先怎么处理"><a href="#在面对未知的流量暴增，可以预先怎么处理" class="headerlink" title="在面对未知的流量暴增，可以预先怎么处理"></a>在面对未知的流量暴增，可以预先怎么处理</h2><p>如果流量突然飙大，总有一个资源会遇到瓶颈。按照经验大概出问题地方是DB，磁盘IO、CPU、带宽、连接数、内存其中的一个或几个。</p><h3 id="流量暴涨的原因"><a href="#流量暴涨的原因" class="headerlink" title="流量暴涨的原因"></a>流量暴涨的原因</h3><p>一般情况下，引起网站流量暴增大致为以下两种情况</p><ul><li>不可预测流量（网站被恶意刷量；CDN回源抓取数据；合作业务平台调取平台数据等）</li><li>可预测流量（突然爆发的社会热点，营销活动的宣传；）</li></ul><p>不管是可预测流量还是不可预测流量都会表现在带宽和网站整体架构的应对方案上</p><p>如果由于带宽原因引起，由于网站的并发量太高，达到服务器的吞吐极限，导致服务器宕机，这时需要做<strong>临时申请加大带宽，然后负载均衡分流</strong>。</p><p>如果由于外网请求数据库，导致数据库频繁读写，数据库处理能力低，导致大量请求积压；如果是这种情况，就需要优化SQL，存储过程等，如果是请求过大，就要考虑做集群等。</p><p>可预测流量的暴增也会拖慢网页的打开速度，甚至导致网站服务器宕机。要应对正常流量暴增，在流量高峰期到来之前就可以适当的调整，一般针对应用服务器的调整可以防止单点，负载均衡，高可用，增加后端web<br>应用服务器数量，数据库读写分离，分库分表等，防止流量暴增导致服务器挂掉</p><h3 id="防止流量暴涨预备方案"><a href="#防止流量暴涨预备方案" class="headerlink" title="防止流量暴涨预备方案"></a>防止流量暴涨预备方案</h3><h4 id="流量估算"><a href="#流量估算" class="headerlink" title="流量估算"></a>流量估算</h4><blockquote><p>作为一个经验充足的老运维，可以把设计流量<em>3作为系统压力的下限，即实现完了要压测，压测得到的结果要达到设计流量 </em> 3（ <em> 4， </em> 5都可以），比如服务器在IDC机房，在签合同之前就可以说明当流量异常的时候，提供一定的缓冲带宽，如果是云服务器，可以临时加带宽。<br>关键是要给系统留些缓冲。一旦发生了什么，不至于挂的太惨。此时，一般会得到一个带缓存的业务服务系统。考虑到缓存高于后台服务2～3个数量级的性能优势，多撑几倍流量一般不成问题。</p></blockquote><h4 id="降级方案"><a href="#降级方案" class="headerlink" title="降级方案"></a>降级方案</h4><h4 id="限流方案"><a href="#限流方案" class="headerlink" title="限流方案"></a>限流方案</h4><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/dadonggg/p/8651909.html" target="_blank" rel="noopener">如何应对网站流量暴增</a></li></ul><h2 id="如何限流，限流算法，对于ddos攻击怎么处理"><a href="#如何限流，限流算法，对于ddos攻击怎么处理" class="headerlink" title="如何限流，限流算法，对于ddos攻击怎么处理"></a>如何限流，限流算法，对于ddos攻击怎么处理</h2><h3 id="如何限流"><a href="#如何限流" class="headerlink" title="如何限流"></a>如何限流</h3><ul><li>计数器</li><li>滑动窗口</li><li>漏桶</li><li><p>令牌</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/dadonggg/p/8651909.html" target="_blank" rel="noopener">如何应对网站流量暴增</a></p></li></ul><h3 id="ddos处理"><a href="#ddos处理" class="headerlink" title="ddos处理"></a>ddos处理</h3><blockquote><p>遇到1G以下的攻击，使用防火墙就可以搞定（或者使用一些免费的云防御产品）；流量1G—10G时可以选择机房进行流量迁移和清洗；大于10G时使用高防CDN（云防御）是相对最靠谱并且价钱最能接受的。</p></blockquote><ul><li><p><strong>参考</strong>: <a href="https://blog.csdn.net/higeek/article/details/83143897" target="_blank" rel="noopener">一次从遭遇DDoS攻击到解决的亲身经历</a></p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/viter/archive/2018/11/14/9957214.html" target="_blank" rel="noopener">记一次DDOS攻击防御实录</a></p></li></ul><h2 id="PHP数组的底层实现"><a href="#PHP数组的底层实现" class="headerlink" title="PHP数组的底层实现"></a>PHP数组的底层实现</h2><blockquote><p>PHP 数组的底层实现是散列表（也叫 hashTable )，散列表是根据键（Key）直接访问内存存储位置的数据结构，它的key - value 之间存在一个映射函数，可以根据 key 通过映射函数得到的散列值直接索引到对应的 value 值，无需通过关键字比较，在理想情况下，不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O(1)。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://segmentfault.com/a/1190000020175662" target="_blank" rel="noopener">PHP7 数组的底层实现</a></li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。<br>  简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。<br>  本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://developer.51cto.com/art/201808/581174.htm" target="_blank" rel="noopener">收藏 | 第一次有人把“分布式事务”讲的这么简单明了</a></li></ul><h2 id="RPC相对于传统的API调用的优点"><a href="#RPC相对于传统的API调用的优点" class="headerlink" title="RPC相对于传统的API调用的优点"></a>RPC相对于传统的API调用的优点</h2><p>REST（HTTP-Based）、RPC（Socket-Based）</p><table><thead><tr><th style="text-align:left">接口类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td style="text-align:left">REST</td><td>RESTful API充分利用了HTTP协议的设计,使用了面向资源的接口设计,相对于传统RPC降低了接口设计的复杂度</td><td>RESTful API面向资源设计接口,而对于一些复杂操作来说,接口设计难度将大于RPC形式</td></tr><tr><td style="text-align:left">RPC</td><td>1) 方便使用RPC来调用远程函数,冰得到对应的结果,就像调用本地方法一样 2) 编写分布式应用程序更加简单容易,因为RPC将所有的网络代码都隐藏到了存根函数中,开发人员不必关注通信等细节 3) RPC是跨语言的</td><td>1) 交互方式单一,不能进行复杂多模块之间的协议交互 2) 开发难度,RPC框架肯定高于基于简单HTTP协议的REST接口</td></tr></tbody></table><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/weixin_43185598/article/details/88537824" target="_blank" rel="noopener">Rest和RPC接口区别</a></li></ul><h2 id="服务调度中心的感知与动态上下线"><a href="#服务调度中心的感知与动态上下线" class="headerlink" title="服务调度中心的感知与动态上下线"></a>服务调度中心的感知与动态上下线</h2><ul><li><p>zookeeper</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/dengpengbo/p/10443547.html" target="_blank" rel="noopener">zookeeper实现动态感知服务器上下线</a></p></li><li><strong>参考</strong>: <a href="https://www.cnblogs.com/GodHeng/p/8797100.html" target="_blank" rel="noopener">分布式服务动态上下线感知</a></li></ul><h2 id="MySQL的索引，为什么是B-而不是平衡二叉树"><a href="#MySQL的索引，为什么是B-而不是平衡二叉树" class="headerlink" title="MySQL的索引，为什么是B+而不是平衡二叉树"></a>MySQL的索引，为什么是B+而不是平衡二叉树</h2><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/tiancai/p/9024351.html" target="_blank" rel="noopener">为什么MySQL数据库索引选择使用B+树？</a></li><li><strong>参考</strong>: <a href="https://blog.csdn.net/jacke121/article/details/78268602" target="_blank" rel="noopener">快速理解平衡二叉树、B-tree、B+tree、B*tree</a></li></ul><h2 id="索引查找在Linux的磁盘上是怎么操作的"><a href="#索引查找在Linux的磁盘上是怎么操作的" class="headerlink" title="索引查找在Linux的磁盘上是怎么操作的"></a>索引查找在Linux的磁盘上是怎么操作的</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/qq_38410730/article/details/81416195" target="_blank" rel="noopener">【Linux】Linux根据文件路径查找索引节点</a></li></ul><h2 id="聚簇索引相对于B-索引的优点"><a href="#聚簇索引相对于B-索引的优点" class="headerlink" title="聚簇索引相对于B+索引的优点"></a>聚簇索引相对于B+索引的优点</h2><ul><li><strong>参考</strong>: <a href="https://my.oschina.net/xiaoyoung/blog/3046779" target="_blank" rel="noopener">浅谈聚簇索引和非聚簇索引的区别</a></li></ul><h2 id="如何分析SQL执行慢的原因"><a href="#如何分析SQL执行慢的原因" class="headerlink" title="如何分析SQL执行慢的原因"></a>如何分析SQL执行慢的原因</h2><h2 id="Redis连接时的connect与pconnect的区别"><a href="#Redis连接时的connect与pconnect的区别" class="headerlink" title="Redis连接时的connect与pconnect的区别"></a>Redis连接时的<code>connect</code>与<code>pconnect</code>的区别</h2><ul><li><code>connect</code>：脚本结束之后连接就释放了</li><li><p><code>pconnect</code>：脚本结束之后连接不释放，连接保持在php-fpm进程中。</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/lovebing/p/6250281.html" target="_blank" rel="noopener">Redis中connect与pconnect区别？</a></p></li></ul><h2 id="Redis有哪些结构时间复杂度较高"><a href="#Redis有哪些结构时间复杂度较高" class="headerlink" title="Redis有哪些结构时间复杂度较高"></a>Redis有哪些结构时间复杂度较高</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/andy86869/article/details/88366513" target="_blank" rel="noopener">Redis基础 常用类型 时间复杂度</a></li></ul><h2 id="Redis-hash的实现"><a href="#Redis-hash的实现" class="headerlink" title="Redis hash的实现"></a>Redis hash的实现</h2><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/ourroad/p/4891648.html" target="_blank" rel="noopener">Redis之Hash数据结构</a></li></ul><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><blockquote><p>在1个10G大小的文件中，存储的都是int型的数据，如何在内存使用小于8M的情况下进行排序</p></blockquote><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/dream-of-cambridge/articles/8042311.html" target="_blank" rel="noopener">归并排序，外排序，10G文件500M内存的排序</a></li><li><strong>参考</strong>: <a href="https://www.cnblogs.com/Vae1990Silence/p/4423450.html" target="_blank" rel="noopener">腾讯面试题：10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。</a></li></ul><h2 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h2><blockquote><p>以微博为例，有1个亿的用户，同时用户之间有关注和粉丝，用户的关注和取关操作比较频繁，如何设计架构和API接口</p></blockquote><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/bigtree_3721/article/details/79779249" target="_blank" rel="noopener">新浪微博技术架构分析和设计</a></li></ul><h1 id="字节二面"><a href="#字节二面" class="headerlink" title="字节二面"></a>字节二面</h1><h2 id="守护进程是什么，怎么实现"><a href="#守护进程是什么，怎么实现" class="headerlink" title="守护进程是什么，怎么实现"></a>守护进程是什么，怎么实现</h2><blockquote><p>守护进程（Daemon）是运行在后台的一种特殊进程，也称为精灵进程。是生存期较长的一种进程，常常在系统自举时启动，仅在系统关闭时终止。没有控制终端，仅仅在后台运行，Linux有很多守护进程执行日常事务活动，是不受终端控制的进程。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/m0_37925202/article/details/80214095" target="_blank" rel="noopener">守护进程详解及其代码实现</a></li></ul><h2 id="PHP是否适合做守护进程，为什么（内存管理这一块）"><a href="#PHP是否适合做守护进程，为什么（内存管理这一块）" class="headerlink" title="PHP是否适合做守护进程，为什么（内存管理这一块）"></a>PHP是否适合做守护进程，为什么（内存管理这一块）</h2><p>不适合,因为PHP本身不是常驻内存</p><h2 id="PHP的垃圾回收机制"><a href="#PHP的垃圾回收机制" class="headerlink" title="PHP的垃圾回收机制"></a>PHP的垃圾回收机制</h2><ul><li><strong>参考</strong>: <a href="https://m.php.cn/topic/php7/425508.html" target="_blank" rel="noopener">php7 垃圾回收机制详解</a></li></ul><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul><li><p>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC</p></li><li><p><strong>参考</strong>: <a href="https://blog.csdn.net/wm12345645/article/details/82381407" target="_blank" rel="noopener">Liunx 六大进程间通信方式</a></p></li></ul><h2 id="共享内存是怎么实现的"><a href="#共享内存是怎么实现的" class="headerlink" title="共享内存是怎么实现的"></a>共享内存是怎么实现的</h2><blockquote><p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/zgq0/p/8780893.html" target="_blank" rel="noopener">进程间的五种通信方式介绍</a></li></ul><h2 id="怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高"><a href="#怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高" class="headerlink" title="怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高"></a>怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/truelove12358/article/details/50502248" target="_blank" rel="noopener">linux 下查看系统资源和负载,以及性能监控</a></li></ul><h2 id="MySQL的IO过高怎么优化，分库分表及分区"><a href="#MySQL的IO过高怎么优化，分库分表及分区" class="headerlink" title="MySQL的IO过高怎么优化，分库分表及分区"></a>MySQL的IO过高怎么优化，分库分表及分区</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/designer01/article/details/82772620" target="_blank" rel="noopener">mysql分区、分表、分库、数据分片</a></li></ul><h2 id="MySQL的索引结构，myisam的索引结构，-innodb的索引结构，innodb为什么必须要有主键索引"><a href="#MySQL的索引结构，myisam的索引结构，-innodb的索引结构，innodb为什么必须要有主键索引" class="headerlink" title="MySQL的索引结构，myisam的索引结构， innodb的索引结构，innodb为什么必须要有主键索引"></a>MySQL的索引结构，myisam的索引结构， innodb的索引结构，innodb为什么必须要有主键索引</h2><ul><li>MyISAM: 使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址</li><li><p>InnoDB: 也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/olinux/p/5217186.html" target="_blank" rel="noopener">MySQL中myisam和innodb的主键索引有什么区别？</a></p></li></ul><h2 id="添加索引，为什么可以减少io操作（磁盘页）"><a href="#添加索引，为什么可以减少io操作（磁盘页）" class="headerlink" title="添加索引，为什么可以减少io操作（磁盘页）"></a>添加索引，为什么可以减少io操作（磁盘页）</h2><blockquote><p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/m0_38128121/article/details/79663261" target="_blank" rel="noopener">数据库添加索引为什么能加快查询速度</a></li></ul><h2 id="nginx的负载均衡算法"><a href="#nginx的负载均衡算法" class="headerlink" title="nginx的负载均衡算法"></a>nginx的负载均衡算法</h2><ul><li><code>round robin(默认)</code>: 轮询方式，依次将请求分配到各个后台服务器中，默认的负载均衡方式。 </li><li><code>weight</code>: 根据权重来分发请求到不同的机器中，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。  </li><li><code>ip_hash</code>: 根据请求者ip的hash值将请求发送到后台服务器中，可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</li><li><code>url_hash</code>: 根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高。</li><li><p><code>fair</code>: 根据后台响应时间来分发请求，响应时间短的分发的请求多。</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/DarrenChan/p/8967412.html" target="_blank" rel="noopener">nginx负载均衡的五种算法</a></p></li></ul><h2 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h2><blockquote><p>查找一个字符串中最长的无重复字串</p></blockquote><h1 id="字节三面"><a href="#字节三面" class="headerlink" title="字节三面"></a>字节三面</h1><h2 id="在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中"><a href="#在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中" class="headerlink" title="在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中"></a>在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/qq_32169593/article/details/80987070" target="_blank" rel="noopener">从一字符串中找出其无重复最长子串字符及长度</a></li></ul><h2 id="设计一个定时任务管理器"><a href="#设计一个定时任务管理器" class="headerlink" title="设计一个定时任务管理器"></a>设计一个定时任务管理器</h2><ul><li><strong>参考</strong>: <a href="https://studygolang.com/articles/9523" target="_blank" rel="noopener">golang实践-如何实现高性能的定时任务管理器</a></li></ul><h1 id="滴滴2020PHP面试题"><a href="#滴滴2020PHP面试题" class="headerlink" title="滴滴2020PHP面试题"></a>滴滴2020PHP面试题</h1><h2 id="处理算法题，最大无重复子串，链表的值交换"><a href="#处理算法题，最大无重复子串，链表的值交换" class="headerlink" title="处理算法题，最大无重复子串，链表的值交换"></a>处理算法题，最大无重复子串，链表的值交换</h2><h2 id="遇到过线上服务器CPU飙高的情况没有，如何处理"><a href="#遇到过线上服务器CPU飙高的情况没有，如何处理" class="headerlink" title="遇到过线上服务器CPU飙高的情况没有，如何处理"></a>遇到过线上服务器CPU飙高的情况没有，如何处理</h2><blockquote><p>登录服务器，执行top命令，查看CPU占用情况；定位线程；定位代码，解决问题</p></blockquote><h2 id="对线程池的理解，项目中哪个地方使用了，如何使用的，用的框架中的哪个实现类，为什么用这个"><a href="#对线程池的理解，项目中哪个地方使用了，如何使用的，用的框架中的哪个实现类，为什么用这个" class="headerlink" title="对线程池的理解，项目中哪个地方使用了，如何使用的，用的框架中的哪个实现类，为什么用这个"></a>对线程池的理解，项目中哪个地方使用了，如何使用的，用的框架中的哪个实现类，为什么用这个</h2><ul><li>1)创建/销毁线程伴随着系统开销，过于频繁的创建/销毁线程，会很大程度上影响处理效率</li><li>2)线程并发数量过多，抢占系统资源从而导致阻塞</li><li>3)对线程进行一些简单的管理, 延时执行 定时循环执行</li></ul><h2 id="对MySQL索引的理解、对组合索引的理解、索引的最佳实践"><a href="#对MySQL索引的理解、对组合索引的理解、索引的最佳实践" class="headerlink" title="对MySQL索引的理解、对组合索引的理解、索引的最佳实践"></a>对MySQL索引的理解、对组合索引的理解、索引的最佳实践</h2><ul><li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</li><li>非聚簇索引：不是聚簇索引，就是非聚簇索引</li></ul><h2 id="分布式锁的实现、对比Redis分布式锁-amp-ZK分布式锁"><a href="#分布式锁的实现、对比Redis分布式锁-amp-ZK分布式锁" class="headerlink" title="分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁"></a>分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁</h2><ul><li>基于数据库实现；</li><li>基于缓存（Redis等）实现；</li><li>基于Zookeeper实现；</li></ul><h2 id="怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？"><a href="#怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？" class="headerlink" title="怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？"></a>怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？</h2><ul><li>服务间调用,服务发现,服务容错,服务部署,数据调用</li></ul><h2 id="如何理解网关，网关带来的好处和坏处，如何解决"><a href="#如何理解网关，网关带来的好处和坏处，如何解决" class="headerlink" title="如何理解网关，网关带来的好处和坏处，如何解决"></a>如何理解网关，网关带来的好处和坏处，如何解决</h2><ul><li>高性能，可横向扩展</li><li>高可靠，业务不中断</li><li>插件化的API安全控制</li><li>灵活的数据编排</li><li>精细化流控</li><li>API版本管理</li><li>API数据分析</li><li>高效插件化路由算法</li><li>安全认证，防攻击</li><li>API访问控制</li><li>Swagger导入导出</li></ul><h2 id="掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式"><a href="#掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式" class="headerlink" title="掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式"></a>掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式</h2><blockquote><p>单例模式，工程模式，注册模式，适配器模式，观察者模式，策略模式</p></blockquote><h2 id="如何设计一个秒杀系统？"><a href="#如何设计一个秒杀系统？" class="headerlink" title="如何设计一个秒杀系统？"></a>如何设计一个秒杀系统？</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>nginx负载均衡，将请求分发到各个服务器，减轻压力。</li><li>js、css压缩，减少流量以及请求次数。</li><li>js、css压缩，减少流量以及请求次数。</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>采用redis缓存，可以提前将某些秒杀的数据加载到缓存。如库存先加载到缓存，判断缓存里的库存，成功后再继续，同时为了防止大量访问redis，可以用共享变量标识是否卖完，如卖完了，则直接返回，不用访问redis。</li><li>页面缓存，即将页面直接缓存到redis，或者页面静态化，即前后端分离。</li><li>开启浏览器缓存。</li></ul><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li>使用消息队列，例rabbitmq进行消峰。</li><li>利用验证码防止恶意刷单，可以有效降低单位时间内访问次数。</li><li>地址隐藏，防止知道地址后提前购买以及多刷。</li><li>一定时间内限制url访问次数。</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>利用行级锁，先扣库存，成功后再创建订单，防止超卖。</li><li>唯一索引，防止重复购买。</li><li>数据库读写分离，如mycat。</li></ul><h2 id="假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？"><a href="#假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？" class="headerlink" title="假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？"></a>假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？</h2><blockquote><p>分布式ID</p></blockquote><p>将订单数据划分成两大类型：分别是热数据和冷数据。</p><p>热数据：3个月内的订单数据，查询实时性较高。</p><p>冷数据A：3个月 ~ 12个月前的订单数据，查询频率不高。</p><p>冷数据B：1年前的订单数据，几乎不会查询，只有偶尔的查询需求。</p><h2 id="MySQL事务隔离级别、MVCC？"><a href="#MySQL事务隔离级别、MVCC？" class="headerlink" title="MySQL事务隔离级别、MVCC？"></a>MySQL事务隔离级别、MVCC？</h2><ul><li>数据库事务的隔离级别ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</li><li>SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>分布式架构、高可扩展、高性能、高并发、服务器性能调优、Laravel、TP6、Yii2、Redis、Swoole、Swoft、RabbitMQ、Kafka、Mysql优化、shell脚本、Docker、微服务、Nginx</p><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><ul><li><a href="https://www.nowcoder.com/discuss/356733?type=2" target="_blank" rel="noopener">字节PHP/Golang社招面经</a></li><li><a href="https://my.oschina.net/u/4178721/blog/4423526" target="_blank" rel="noopener">2020面试题之滴滴后端PHP职位</a></li><li><a href="https://www.php.cn/toutiao-415522.html" target="_blank" rel="noopener">2020腾讯PHP面试题（附答案）</a></li><li><a href="https://www.lagou.com/lgeduarticle/31777.html" target="_blank" rel="noopener">2019腾讯PHP面试题（附答案）</a></li><li><a href="https://gitee.com/OSCYuanChuangHui/2018_lecturer_ppt/raw/master/2019.12.15%20%E6%B7%B1%E5%9C%B3%E5%B9%B4%E7%BB%88%E7%9B%9B%E5%85%B8/%E4%B8%BB%E4%BC%9A%E5%9C%BA/3.%202020%20%E5%B9%B4%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%20PHP%E2%80%94%E2%80%94%E9%9F%A9%E5%A4%A9%E5%B3%B0.pdf" target="_blank" rel="noopener">2020 年如何正确使用 PHP——韩天峰</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;保持学习, 保持警惕, 居安思危, 走出舒适区.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP单元测试 (一) 基础</title>
    <link href="http://blog.caoxl.com/2020/10/29/PHP-Unit-I-Basic/"/>
    <id>http://blog.caoxl.com/2020/10/29/PHP-Unit-I-Basic/</id>
    <published>2020-10-29T06:12:49.000Z</published>
    <updated>2020-10-29T09:02:02.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。</p></blockquote><a id="more"></a><h1 id="测试DEMO"><a href="#测试DEMO" class="headerlink" title="测试DEMO"></a>测试DEMO</h1><ul><li><code>Transfer.php</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Controller</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Transfer</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $accountA = <span class="number">100</span>;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $accountB = <span class="number">100</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aToB</span><span class="params">(int $money)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;accountA -= $money;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;accountB += $money;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bToA</span><span class="params">(int $money)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;accountB -= $money;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;accountA += $money;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAccountA</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;accountA;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAccountB</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;accountB;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>TransferTest.php</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">Controller</span>\<span class="title">Transfer</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">TransferTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $transferObj;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setUp</span><span class="params">()</span> : <span class="title">void</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;transferObj = <span class="keyword">new</span> Transfer();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testAtoB</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $originalA = <span class="keyword">$this</span>-&gt;transferObj-&gt;getAccountA();</span></span><br><span class="line"><span class="php">        $originalB = <span class="keyword">$this</span>-&gt;transferObj-&gt;getAccountB();</span></span><br><span class="line"></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;transferObj-&gt;aToB(<span class="number">10</span>);</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;assertEquals($originalA - <span class="number">10</span>, <span class="keyword">$this</span>-&gt;transferObj-&gt;getAccountA());</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;assertEquals($originalB + <span class="number">10</span>, <span class="keyword">$this</span>-&gt;transferObj-&gt;getAccountB());</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>执行测试:</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHPUnit 9.5-gd3b55c36f by Sebastian Bergmann and contributors.</span><br><span class="line"></span><br><span class="line">.                                                                   1 / 1 (100%)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Time:</span> 00:00.029, Memory: 8.00 MB</span><br><span class="line"></span><br><span class="line">OK (1 test, 2 assertions)</span><br></pre></td></tr></table></figure><h1 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h1><h2 id="基境"><a href="#基境" class="headerlink" title="基境"></a>基境</h2><blockquote><p><a href="https://phpunit.readthedocs.io/en/9.3/fixtures.html" target="_blank" rel="noopener">https://phpunit.readthedocs.io/en/9.3/fixtures.html</a></p></blockquote><p>PHPUnit 支持共享建立基境的代码。</p><p>提供了以下几个模板方法：</p><ul><li><code>setUpBeforeClass</code>: 测试用例类的第一个测试运行之前执行</li><li><code>tearDownAfterClass</code>:  测试用例类的最后一个测试运行之后执行</li><li><code>setUp</code>: 每个测试方法运行之前执行</li><li><code>tearDown</code>: 每个测试方法运行之后执行</li></ul><p><strong>注意：每个测试方法都是在一个全新的测试类实例上运行的</strong></p><h3 id="全局状态"><a href="#全局状态" class="headerlink" title="全局状态"></a>全局状态</h3><blockquote><p><a href="https://phpunit.readthedocs.io/en/9.3/fixtures.html#global-state" target="_blank" rel="noopener">https://phpunit.readthedocs.io/en/9.3/fixtures.html#global-state</a></p></blockquote><ul><li>全局变量：有时候测试代码中用到了全局变量（$_GLOBALS），但是如果对这里面的变量进行了修改，可能会导致其他测试方法出现问题，那么怎么保证每个测试方法都使用的是一样的全局变量呢？ 通过：<code>@backupGlobals disabled|enabled</code> 它可标注在：<ul><li>测试类: 作用范围为整个测试类</li><li>测试方法: 作用范围为这个方法</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @backupGlobals disabled</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line">    /**</span><br><span class="line">     * @backupGlobals enabled</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testThatInteractsWithGlobalVariables</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><p>支持设置 “全局变量黑名单” 黑名单中的全局变量将被排除于备份与还原操作之外：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @backupGlobals disabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $backupGlobalsBlacklist = [<span class="symbol">'globalVariabl</span>e'];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @backupGlobals enabled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public function testThatInteractsWithGlobalVariables()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于全局变量的备份和还原的原理是使用了：<code>serialize()</code> 与 <code>unserialize()</code>。</p><ul><li><p><strong>注意</strong>：</p><ul><li>对于无法被序列化的对象放入 <code>$GLOBALS</code> 数组内时，备份操作就会出问题。比如：<code>PDO</code></li><li>在方法（例如 <code>setUp()</code>）内对 <code>$backupGlobalsBlacklist</code> 属性进行设置是无效的</li></ul></li><li><p>类的静态属性 。对于类的静态属性的备份和还原可以通过：<code>@backupStaticAttributes enabled|disabled</code><br>作用对象：在测试开始时已声明的所有类（而不仅是测试类自身），且只作用于静态类属性，不作用于函数内声明的静态变量。<br>使用位置和 <code>backupGlobals</code> 一致：</p><ul><li>测试类</li><li>测试方法<br>只有启用了 <code>@backupStaticAttributes</code> 的测试方法才会在方法之前执行此操作。如果在此之前运行的某个没有启用 <code>@backupStaticAttributes</code> 的测试方法改变了静态属性的值，那么被备份及还原的将会是这个改变后的值</li></ul></li></ul><p>同样提供了黑名单支持：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $backupStaticAttributesBlacklist = [</span><br><span class="line">      <span class="symbol">'classNam</span>e' =&gt; [<span class="symbol">'attributeNam</span>e']</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>使用 <code>@depends</code> 声明测试方法所依赖的其他测试方法。 依赖方法的返回值，会作为被依赖方法的参数，其顺序和 <code>@depends</code> 的顺序一致，但是不会影响代码的执行顺序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"depends1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"depends2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@depends</span> testOne</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@depends</span> testTwo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testDepends</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertEquals([<span class="string">'depends1'</span>, <span class="string">'depends2'</span>], func_get_args());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Time:</span> 00:00.315, Memory: 6.00 MB</span><br><span class="line"></span><br><span class="line">OK (3 tests, 3 assertions)</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：<ul><li>当被依赖的测试方法失败时，不会再执行依赖方法的测试。</li><li>如果被依赖方法返回的是对象，默认是引用传递，如果希望传递对象的副本时，使用： <code>@depends clone</code></li></ul></li></ul><h2 id="数据供给器"><a href="#数据供给器" class="headerlink" title="数据供给器"></a>数据供给器</h2><p>使用 <code>@dataProvider</code> 声明数据供给器。 对应的方法需要返回：</p><ul><li>数组（每个元素也是数组）</li><li>可遍历的对象（实现了迭代接口）</li></ul><p>然后测试时，会将每次迭代器提供的一组数据进行测试，直到全部遍历完毕。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $sum</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dataProvider</span> additionProvider</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testSum</span><span class="params">($a, $b, $sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertEquals($sum, $a + $b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">additionProvider</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Failed</span> <span class="string">asserting</span> <span class="string">that</span> <span class="number">2</span> <span class="string">matches</span> <span class="string">expected</span> <span class="number">3</span><span class="string">.</span></span><br><span class="line"><span class="string">Expected</span> <span class="string">:3</span></span><br><span class="line"><span class="string">Actual</span>   <span class="string">:2</span></span><br><span class="line"><span class="string">&lt;Click</span> <span class="string">to</span> <span class="string">see</span> <span class="string">difference&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="string">/Users/caoxl/WWW/test.com/tests/MyTest.php:56</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Time:</span> <span class="number">00</span><span class="string">:00.403,</span> <span class="attr">Memory:</span> <span class="number">8.00</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">FAILURES!</span></span><br><span class="line"><span class="attr">Tests:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Assertions:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Failures:</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure><ul><li>注意:<ul><li>和 <code>@depends</code> 同时使用时，<code>@provider</code> 提供的参数会优先于 <code>@depends</code> 提供的参数，并且，依赖关系提供的参数不会变化。</li></ul></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Depends1'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@depends</span> testOne</span></span><br><span class="line"><span class="comment">* <span class="doctag">@dataProvider</span> additionProvider</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testSum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertEquals([<span class="string">'Provider1'</span>, <span class="string">'Depends1'</span>], func_get_args());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会测试两次，第一此传递：Provider1，第二次传递：Provider2</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">additionProvider</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      [<span class="string">'Provider1'</span>],</span><br><span class="line">      [<span class="string">'Provider2'</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PHPUnit</span> <span class="number">9.5</span><span class="string">-gd3b55c36f</span> <span class="string">by</span> <span class="string">Sebastian</span> <span class="string">Bergmann</span> <span class="string">and</span> <span class="string">contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="string">Failed</span> <span class="string">asserting</span> <span class="string">that</span> <span class="string">two</span> <span class="string">arrays</span> <span class="string">are</span> <span class="string">equal.</span></span><br><span class="line"><span class="string">&lt;Click</span> <span class="string">to</span> <span class="string">see</span> <span class="string">difference&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="string">/Users/caoxl/WWW/test.com/tests/MyTest.php:57</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Time:</span> <span class="number">00</span><span class="string">:00.378,</span> <span class="attr">Memory:</span> <span class="number">8.00</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">FAILURES!</span></span><br><span class="line"><span class="attr">Tests:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Assertions:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Failures:</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure><h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>异常测试有两种方式：</p><ul><li>在代码中使用: <code>$this-&gt;expectException(InvalidArgumentException::class);</code></li><li>使用标注：<code>@expectException</code></li></ul><p>断言方法/标注：</p><ul><li><code>expectException</code></li><li><code>expectExceptionCode</code></li><li><code>expectExceptionMessage</code></li><li><code>expectExceptionMessageRegExp</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testException1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectException(InvalidArgumentException::class);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectExceptionMessage(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@expectedException</span> InvalidArgumentException</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@expectedExceptionMessage</span> hi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testException2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidArgumentException(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不允许对 ：<code>Exception</code> 类进行测试，异常类越明确越好。</p><h2 id="错误调试"><a href="#错误调试" class="headerlink" title="错误调试"></a>错误调试</h2><p>默认情况下，在测试过程中如果触发到了 <code>PHP</code> 的错误/警告，<code>PHPUnit</code> 会将其转换为异常：</p><ul><li><code>PHPUnit\Framework\Error\Notice</code></li><li><code>PHPUnit\Framework\Error\Warning</code></li><li><code>PHPUnit\Framework\Error\Error</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectException(Error::class);</span><br><span class="line">    <span class="comment">// 触发一个错误</span></span><br><span class="line">    <span class="keyword">include</span> <span class="string">'file_not_existing_file.php'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果:</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Time:</span> 00:00.319, Memory: 8.00 MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FAILURES!</span><br><span class="line">Tests: 1, Assertions: 1, Failures: 1.</span><br></pre></td></tr></table></figure><h2 id="输出内容测试"><a href="#输出内容测试" class="headerlink" title="输出内容测试"></a>输出内容测试</h2><p>有时候，想要断言 某方法的运行过程中生成了预期的输出（例如，通过 <code>echo</code> 或 <code>print</code>）。<code>PHPUnit\Framework\TestCase</code> 类使用 PHP 的 输出缓冲 特性来为此提供必要的功能支持。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOutput1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectOutputString(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOutput2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectOutputRegex(<span class="string">"/\d+/"</span>);</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// testOutput2</span><br><span class="line">Failed asserting that 'Hello World' matches PCRE pattern "/\d+/".</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Time:</span> 00:00.368, Memory: 8.00 MB</span><br><span class="line"></span><br><span class="line">FAILURES!</span><br><span class="line">Tests: 1, Assertions: 1, Failures: 1.</span><br></pre></td></tr></table></figure><h2 id="标记未完成-与-跳过"><a href="#标记未完成-与-跳过" class="headerlink" title="标记未完成 与 跳过"></a>标记未完成 与 跳过</h2><ul><li>标记未完成</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testMark</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 在这里停止</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;markTestIncomplete(<span class="string">"后续还未完成"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PHPUnit</span> <span class="number">9.5</span><span class="string">-gd3b55c36f</span> <span class="string">by</span> <span class="string">Sebastian</span> <span class="string">Bergmann</span> <span class="string">and</span> <span class="string">contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="string">后续还未完成</span></span><br><span class="line"></span><br><span class="line"> <span class="string">/Users/caoxl/WWW/test.com/tests/MyTest.php:114</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">Time:</span> <span class="number">00</span><span class="string">:00.393,</span> <span class="attr">Memory:</span> <span class="number">8.00</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line"><span class="string">OK,</span> <span class="string">but</span> <span class="string">incomplete,</span> <span class="string">skipped,</span> <span class="string">or</span> <span class="string">risky</span> <span class="string">tests!</span></span><br><span class="line"><span class="attr">Tests:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Assertions:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Incomplete:</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure><ul><li>跳过测试</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setUp</span><span class="params">()</span>: void</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!extension_loaded(<span class="string">'mysqli'</span>)) &#123;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;markTestSkipped(<span class="string">"MySQLi 扩展不可用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PHPUnit</span> <span class="number">9.5</span><span class="string">-gd3b55c36f</span> <span class="string">by</span> <span class="string">Sebastian</span> <span class="string">Bergmann</span> <span class="string">and</span> <span class="string">contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="string">MySQLi</span> <span class="string">扩展不可用</span></span><br><span class="line"></span><br><span class="line"> <span class="string">/Users/caoxl/WWW/test.com/tests/MyTest.php:24</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Time:</span> <span class="number">00</span><span class="string">:00.425,</span> <span class="attr">Memory:</span> <span class="number">8.00</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line"><span class="string">OK,</span> <span class="string">but</span> <span class="string">incomplete,</span> <span class="string">skipped,</span> <span class="string">or</span> <span class="string">risky</span> <span class="string">tests!</span></span><br><span class="line"><span class="attr">Tests:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Assertions:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">Skipped:</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHPUnit" scheme="http://blog.caoxl.com/tags/PHPUnit/"/>
    
      <category term="单元测试" scheme="http://blog.caoxl.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP 单元测试</title>
    <link href="http://blog.caoxl.com/2020/10/27/PHP-Unit-Test/"/>
    <id>http://blog.caoxl.com/2020/10/27/PHP-Unit-Test/</id>
    <published>2020-10-27T08:30:20.000Z</published>
    <updated>2020-10-27T08:47:00.729Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>朋友，你听说过安。。。不是，写过单元测试吗。</p><p>单元测试是开发过程中必不可少的一环，一个项目有良好的单元测试代码，重构的勇气都大很多。这次写一篇小文来介绍一下 PHP 的单元测试工具 PHPUnit 的使用。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 PHPUnit 的方式很简单，使用 composer 可以一行代码就可以安装。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require --dev phpunit/phpunit</span><br></pre></td></tr></table></figure><p>安装之后，在 <code>vendor/bin</code> 目录下有一个 <code>phpunit</code> 的可执行文件，这个就是 <code>phpunit</code> 本体了</p><p>假设我们项目的目录结构如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  phpunit tree .</span><br><span class="line"></span><br><span class="line">├── controller</span><br><span class="line">├── model</span><br><span class="line">├── service</span><br><span class="line">├── test</span><br><span class="line">└── vendor</span><br><span class="line">├── composer.json</span><br></pre></td></tr></table></figure><p>其中我们的单元测试代码都放在 test 目录下。使用 composer 来为我们解决 autoload 的问题</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"autoload"</span>: &#123;</span><br><span class="line">    <span class="attr">"psr-4"</span>: &#123;</span><br><span class="line">      <span class="attr">"Controller\\"</span>: <span class="string">"controller/"</span>,</span><br><span class="line">      <span class="attr">"Model\\"</span>: <span class="string">"model/"</span>,</span><br><span class="line">      <span class="attr">"Service\\"</span>: <span class="string">"service/"</span>,</span><br><span class="line">      <span class="attr">"Test\\"</span>: <span class="string">"test/"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>好了，假设我们现在进行开发，在 service 目录中添加了一个 CalculateService 的文件，并且编写了一个 abs 的函数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Service</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">CalculateService</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">abs</span><span class="params">($num)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> abs($num);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><p>现在我们对 abs 函数进行单元测试，PHPUnit 规定了一个测试类必须遵守如下的规定：</p><ul><li>单元测试类名必须以 <code>Test</code> 结尾，必须继承 <code>\PHPUnit\Framework\TestCase</code> 基类。</li><li>每个测试函数必须以 <code>test</code> 开头。</li></ul><p>上面的规定是必须遵守的，如果代码没有遵守规定 PHPUnit 不会把他当做单元测试代码。除了以上的两条，还有一些良好的编码习惯可以参考：</p><ul><li>单元测试代码都放在 <code>test</code> 目录下。</li><li>每个单元测试类以被测试的类名开头。例如被测试类为 <code>CalculateService</code>，那么单元测试类应该为 <code>CalculateServiceTest</code>。</li><li>每个单元测试函数应该为被测试函数名结尾。例如被测试函数为 <code>abs</code>，那么单元测试函数应该为 <code>testAbs</code>。</li></ul><p>根据上面的规范，编写单元测试代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">Service</span>\<span class="title">CalculateService</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">CalculateServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testAbs</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $calculateService = <span class="keyword">new</span> CalculateService();</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="number">4</span>, $calculateService-&gt;abs(<span class="number">4</span>));</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的测试代码中，调用了我们要测试的函数 <code>abs</code>，然后断言 <code>$calculateService-&gt;abs(4)</code> 的结果为 <code>4</code>。在 phpstorm 中直接在 <code>testAbs</code> 函数处右键选择 <code>run CalculateServiceTest</code> 执行：</p><p>发现在控制台会输出如下内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time: <span class="number">00</span>:<span class="number">00.068</span>, Memory: <span class="number">6.00</span> MB</span><br><span class="line"> </span><br><span class="line">OK (<span class="number">1</span> test, <span class="number">1</span> assertion)</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>表明 <code>abs</code> 通过了 <code>$calculateService-&gt;abs(4) == 4</code> 的测试用例。<strong>这里注意一点，这里并不表明 abs 函数已经通过测试，一个良好的测试应该包含多个测试用例来覆盖尽可能多的可能性</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;朋友，你听说过安。。。不是，写过单元测试吗。&lt;/p&gt;
&lt;p&gt;单元测试是开发过程中必不可少的一环，一个项目有良好的单元测试代码，重构的勇气都大很多。这次写一篇小文来介绍一下 PHP 的单元测试工具 PHPUnit 的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.caoxl.com/tags/PHP/"/>
    
      <category term="单元测试" scheme="http://blog.caoxl.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>做一顿饭来理解协程</title>
    <link href="http://blog.caoxl.com/2020/10/26/Learn-Swoole-Coroutine/"/>
    <id>http://blog.caoxl.com/2020/10/26/Learn-Swoole-Coroutine/</id>
    <published>2020-10-26T07:06:04.000Z</published>
    <updated>2020-10-26T07:15:10.915Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><blockquote><p>协程可以简单理解为线程，只不过这个线程是用户态的，不需要操作系统参与，创建销毁和切换的成本非常低，和线程不同的是协程没法利用多核 cpu 的，想利用多核 cpu 需要依赖 <code>Swoole</code> 的多进程模型。—— swoole 协程一章</p></blockquote><a id="more"></a><h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><p>可以把协程看成一道小学数学的一道题目：“合理安排时间”，来我们先做一道题目：</p><blockquote><p>小明下班后回家煮饭，煲汤需要 10 分钟，煮饭需要 8 分钟， 炒菜需要 5 分钟，，请问小明最少需要多少分钟能煮好饭？</p></blockquote><blockquote><p>下面用 <code>sleep()</code> 模拟 IO 操作</p></blockquote><h1 id="同步版煮饭"><a href="#同步版煮饭" class="headerlink" title="同步版煮饭"></a>同步版煮饭</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncCook</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cook</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $startTime = time();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"开始煲汤..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"汤好了..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"开始煮饭..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"饭熟了..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"放油..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"煎鱼..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"放盐..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"出锅..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        var_dump(<span class="string">'总耗时：'</span> . (time() - $startTime) . <span class="string">' 分钟'</span>);<span class="keyword">die</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sync = <span class="keyword">new</span> SyncCook();</span><br><span class="line">$sync-&gt;cook();</span><br></pre></td></tr></table></figure><blockquote><p>总耗时：23 分钟</p></blockquote><p>代码很容易看懂，等待汤煮好之后再煮饭，然后再等待饭煮好再炒菜，生活中不会这样操作吧？这就要引入协程来解决这个问题了。</p><h1 id="协程版煮饭"><a href="#协程版煮饭" class="headerlink" title="协程版煮饭"></a>协程版煮饭</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span>\<span class="title">WaitGroup</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwooleCook</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cook</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $startTime = time();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启一键协程化: https://wiki.swoole.com/#/runtime?id=swoole_hook_all</span></span><br><span class="line">        Swoole\Runtime::enableCoroutine($flags = SWOOLE_HOOK_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个协程容器: https://wiki.swoole.com/#/coroutine/scheduler</span></span><br><span class="line">        <span class="comment">// 相当于进入厨房</span></span><br><span class="line">        Co\run(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 等待结果: https://wiki.swoole.com/#/coroutine/wait_group?id=waitgroup</span></span><br><span class="line">            <span class="comment">// 记录哪道菜做好了，哪道菜还需要多长时间</span></span><br><span class="line">            $wg = <span class="keyword">new</span> WaitGroup();</span><br><span class="line">            <span class="comment">// 保存数据的结果</span></span><br><span class="line">            <span class="comment">// 装好的菜</span></span><br><span class="line">            $result = [];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一下煲汤(记录一个任务)</span></span><br><span class="line">            $wg-&gt;add();</span><br><span class="line">            <span class="comment">// 创建一个煲汤任务(开启一个新的协程)</span></span><br><span class="line">            Coroutine::create(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($wg, &amp;$result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"开始煲汤..."</span> . PHP_EOL;</span><br><span class="line">                <span class="comment">// 煲汤需要6分钟，所以我们也不用在这里等汤煮好，</span></span><br><span class="line">                <span class="comment">// 直接去做下一个任务：炒菜(协程切换)</span></span><br><span class="line">                sleep(<span class="number">8</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"汤好了..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 装盘</span></span><br><span class="line">                $result[<span class="string">'soup'</span>] = <span class="string">'一锅汤'</span>;</span><br><span class="line">                $wg-&gt;done(); <span class="comment">// 标记任务完成</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一下煮饭(记录一个任务)</span></span><br><span class="line">            $wg-&gt;add();</span><br><span class="line">            <span class="comment">// 创建一个煮饭任务(开启一个新的协程)</span></span><br><span class="line">            Coroutine::create(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($wg, &amp;$result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"开始煮饭..."</span> . PHP_EOL;</span><br><span class="line">                <span class="comment">// 煮饭需要5分钟，所以我们不用在这里等饭煮熟，放在这里一会再来看看好了没有</span></span><br><span class="line">                <span class="comment">// 我们先去煲汤(协程切换)</span></span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"饭熟了..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 装盘</span></span><br><span class="line">                $result[<span class="string">'rice'</span>] = <span class="string">'一锅米饭'</span>;</span><br><span class="line">                $wg-&gt;done(); <span class="comment">// 标记任务完成</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一下炒菜</span></span><br><span class="line">            $wg-&gt;add();</span><br><span class="line">            <span class="comment">// 创建一个炒菜任务(再开启一个新的协程)</span></span><br><span class="line">            Coroutine::create(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($wg, &amp;$result)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 煎鱼的过程必须放在一个协程里面执行，如果不是的话可能鱼还没煎好就出锅了</span></span><br><span class="line">                <span class="comment">// 因为开启协程后，IO全是异步了，在此demo中每次遇到sleep都会挂起当前协程</span></span><br><span class="line">                <span class="comment">// 切换到下一个协程执行。</span></span><br><span class="line">                <span class="comment">// 例如把出锅这一步开启一个新协程执行，则在煎鱼的时候鱼，鱼就出锅了。</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"放油..."</span> . PHP_EOL;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"煎鱼..."</span> . PHP_EOL;</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"放盐..."</span> . PHP_EOL;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"出锅..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 装盘</span></span><br><span class="line">                $result[<span class="string">'food'</span>] = <span class="string">'鱼香肉丝'</span>;</span><br><span class="line">                $wg-&gt;done();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待全部任务完成</span></span><br><span class="line">            $wg-&gt;wait();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回数据(上菜！)</span></span><br><span class="line">            var_dump($result);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        var_dump(<span class="string">'总耗时：'</span> . (time() - $startTime) . <span class="string">' 分钟'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$swoole = <span class="keyword">new</span> SwooleCook();</span><br><span class="line">$swoole-&gt;cook();</span><br></pre></td></tr></table></figure><blockquote><p>总耗时：10 分钟</p></blockquote><p>答：小明最少需要 10 分钟能煮好饭。</p><ul><li><a href="https://learnku.com/articles/44836" target="_blank" rel="noopener">原文地址: https://learnku.com/articles/44836</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;协程可以简单理解为线程，只不过这个线程是用户态的，不需要操作系统参与，创建销毁和切换的成本非常低，和线程不同的是协程没法利用多核 cpu 的，想利用多核 cpu 需要依赖 &lt;code&gt;Swoole&lt;/code&gt; 的多进程模型。—— swoole 协程一章&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swoole" scheme="http://blog.caoxl.com/categories/Swoole/"/>
    
    
      <category term="Swoole" scheme="http://blog.caoxl.com/tags/Swoole/"/>
    
      <category term="协程" scheme="http://blog.caoxl.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Coroutine" scheme="http://blog.caoxl.com/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>PHP与Go的语法对比</title>
    <link href="http://blog.caoxl.com/2020/10/26/PHP-vs-Go-Syntax-Comparison/"/>
    <id>http://blog.caoxl.com/2020/10/26/PHP-vs-Go-Syntax-Comparison/</id>
    <published>2020-10-26T03:01:10.000Z</published>
    <updated>2020-10-26T03:50:31.229Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>PHP</code> 是一种动态类型语言，它使新手更容易编写代码。现在的问题是，PHP 开发人员能否从动态类型语言切换到像 Go 这样的静态类型语言？为了找到答案，让我们对比一下 Go 和 PHP 之间的语法差异。</p><p><code>Go</code> 是由 Google 设计的一门静态类型的编译型语言。它有点类似于 C，但是它包含了更多的优点，比如垃圾回收、内存安全、结构类型和并发性。它的并发机制使多核和网络机器能够发挥最大的作用。这是 GoLang 的最佳卖点之一。此外，Go 速度快，表现力强，干净且高效。这也是 Go 如此吸引开发者学习的原因。</p><a id="more"></a><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li><code>Go</code> 同时支持有符号和无符号整数，而 <code>PHP</code> 只支持有符号整数。</li><li>另一个主要区别是数组。<code>Go</code> 对 <code>array</code> 和 <code>map</code> 有单独的类型，而 <code>PHP</code> 数组实际上是有序的 <code>map</code>。</li><li><code>Go</code> 与 <code>PHP</code> 相比没有对象。但是，Go 有一个类似于 <code>object</code> 的 <code>struct</code> 类型。</li></ul><h2 id="PHP-数据类型"><a href="#PHP-数据类型" class="headerlink" title="PHP 数据类型:"></a>PHP 数据类型:</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boolean</span><br><span class="line">string</span><br><span class="line">integer // Signed integer, PHP does<span class="built_in"> not </span>support unsigned integers.</span><br><span class="line">float (also known as <span class="string">"floats"</span>, <span class="string">"doubles"</span>,<span class="built_in"> or </span><span class="string">"real numbers"</span>)</span><br><span class="line">array</span><br><span class="line">object</span><br><span class="line">null</span><br><span class="line">resource</span><br></pre></td></tr></table></figure><h2 id="Go-数据类型"><a href="#Go-数据类型" class="headerlink" title="Go 数据类型:"></a>Go 数据类型:</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span> <span class="comment">// Signed integer</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span> <span class="comment">// Unsigned integers</span></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br><span class="line">array</span><br><span class="line">slices</span><br><span class="line"><span class="keyword">map</span></span><br><span class="line"><span class="keyword">struct</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Go 使用 <code>var</code> 声明全局变量和函数变量。但是，它也支持带有初始化程序的简写语法，但只能在函数内部使用。另一方面，PHP 仅支持带有初始化程序的变量声明。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="comment">// Go               // PHP</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">i</span> int           <span class="variable">$i</span> = <span class="number">0</span>      <span class="comment">// integer</span></span><br><span class="line"><span class="selector-tag">var</span> f float64       <span class="variable">$f</span> = <span class="number">0.0</span>    <span class="comment">// float</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> bool          <span class="variable">$b</span> = false  <span class="comment">// boolean</span></span><br><span class="line"><span class="selector-tag">var</span> s string        <span class="variable">$s</span> = <span class="string">""</span>     <span class="comment">// string</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> [<span class="number">2</span>]string     <span class="variable">$a</span> = []     <span class="comment">// array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短的变量声明</span></span><br><span class="line"><span class="comment">// Go                      // PHP</span></span><br><span class="line"><span class="selector-tag">i</span> := <span class="number">0</span>                     <span class="variable">$i</span> = <span class="number">0</span>      <span class="comment">// integer</span></span><br><span class="line">f := <span class="number">0.0</span>                   <span class="variable">$f</span> = <span class="number">0.0</span>    <span class="comment">// float</span></span><br><span class="line"><span class="selector-tag">b</span> := false                 <span class="variable">$b</span> = false  <span class="comment">// boolean</span></span><br><span class="line">s := <span class="string">""</span>                    <span class="variable">$s</span> = <span class="string">""</span>     <span class="comment">// string</span></span><br><span class="line"><span class="selector-tag">a</span> := [<span class="number">1</span>]string&#123;<span class="string">"hello"</span>&#125;    <span class="variable">$a</span> = []     <span class="comment">// array</span></span><br></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span>             <span class="comment">// Signed integer</span></span><br><span class="line">f := <span class="keyword">float64</span>(i)     <span class="comment">// Float</span></span><br><span class="line">u := <span class="keyword">uint</span>(f)        <span class="comment">// Unsigned integer</span></span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$i = <span class="number">1</span>;</span><br><span class="line">$f = (<span class="keyword">float</span>) $i;    <span class="comment">// 1.0</span></span><br><span class="line">$b = (bool) $f      <span class="comment">// true</span></span><br><span class="line">$s = (<span class="keyword">string</span>) $b    <span class="comment">// "1"</span></span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>Go</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> [<span class="number">2</span>]string</span><br><span class="line"><span class="selector-tag">a</span>[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line"><span class="selector-tag">a</span>[<span class="number">1</span>] = <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="selector-tag">a</span> := [<span class="number">2</span>]string&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line">$a = [</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    <span class="string">"world"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h1><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"first_name"</span>: <span class="string">"Foo"</span>,</span><br><span class="line">    <span class="string">"last_name"</span>: <span class="string">"Bar"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line">$m = [</span><br><span class="line">    <span class="string">"first_name"</span> =&gt; <span class="string">"Foo"</span>,</span><br><span class="line">    <span class="string">"last_name"</span> =&gt; <span class="string">"Bar"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h1><p>Go 不支持对象。但是，您可以使用 <code>structs</code> 实现 <code>object</code> 之类的语法。</p><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    person := Person&#123;<span class="string">"Foo bar"</span>, <span class="string">"Sydney, Australia"</span>&#125;</span><br><span class="line">    fmt.Println(person.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line">$person = <span class="keyword">new</span> stdClass;</span><br><span class="line">$person-&gt;Name = <span class="string">"Foo bar"</span>;</span><br><span class="line">$person-&gt;Address = <span class="string">"Sydney, Australia"</span>;</span><br><span class="line"><span class="keyword">echo</span> $person-&gt;Name;</span><br><span class="line"><span class="comment">// 或使用类型转换</span></span><br><span class="line">$person = (object) [</span><br><span class="line">    <span class="string">'Name'</span> =&gt; <span class="string">"Foo bar"</span>,</span><br><span class="line">    <span class="string">'Address'</span> =&gt; <span class="string">"Sydney, Australia"</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">echo</span> $person-&gt;Name;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go 和 PHP 函数之间的主要区别是； <strong>Go 函数可以返回任意数量的结果，而 PHP 函数只能返回一个结果。</strong> 但是，PHP 可以通过返回数组来模拟相同的功能。</p><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullname</span><span class="params">(firstName <span class="keyword">string</span>, lastName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := fullname(<span class="string">"Foo"</span>, <span class="string">"Bar"</span>)</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fullname</span><span class="params">(string $firstName, string $lastName)</span> : <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $firstName . <span class="string">" "</span> . $lastName;</span><br><span class="line">&#125;</span><br><span class="line">$name = fullname(<span class="string">"Foo"</span>, <span class="string">"Bar"</span>);</span><br><span class="line"><span class="keyword">echo</span> $name;</span><br></pre></td></tr></table></figure><h2 id="返回多个结果"><a href="#返回多个结果" class="headerlink" title="返回多个结果"></a>返回多个结果</h2><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line"><span class="comment">// 返回一个数组以获得多个结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(string $x, string $y)</span>: <span class="title">array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [$y, $x];</span><br><span class="line">&#125;</span><br><span class="line">[$a, $b] = swap(<span class="string">'hello'</span>, <span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">echo</span> $a, $b;</span><br></pre></td></tr></table></figure><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a><code>if-else</code></h2><ul><li>Go</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        fmt.Println(<span class="string">"a is bigger than b"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"a is NOT greater than b"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    compare(<span class="number">12</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span><span class="params">(int $a, int $b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($a &gt; $b) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"a is bigger than b"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"a is NOT greater than b"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">12</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h2><p>根据 Golang 官方教程文档:</p><blockquote><p>Go 的 switch 与 C，C+，Java，JavaScript 和 PHP 中的类似，除了 Go 只运行选中的 case，而不是随后的所有 case。 实际上， <code>break</code> 语句在这些语言中的每个 case<br>后都是必需的，而在 Go 中则是自动补充的。另一个重要的区别是 Go 的 switch cases 不需要是常量，并且涉及的值也不必是整数。</p></blockquote><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line"></span><br><span class="line">    os := runtime.GOOS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> os &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"PHP runs on "</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (PHP_OS) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"OS X."</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Linux."</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> PHP_OS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    $sum += $i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>Go 自身没有 while 循环的语法。相应的，Go 使用 for 循环代替实现 <code>while</code> 循环.</p><ul><li>Go</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">func main() &#123;</span><br><span class="line">    <span class="built_in">sum</span> := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    for <span class="built_in">sum</span> &lt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="built_in">sum</span> += <span class="built_in">sum</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fmt</span>.Println(<span class="built_in">sum</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$sum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ($sum &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    $sum += $sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br></pre></td></tr></table></figure><h2 id="foreach-range"><a href="#foreach-range" class="headerlink" title="foreach/range"></a>foreach/range</h2><p>PHP 使用 <code>foreach</code> 迭代数组和对象。与之对应，Go 使用 <code>range</code> 迭代 slice 或 map。</p><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    colours := []<span class="keyword">string</span>&#123;<span class="string">"Maroon"</span>, <span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Blue"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, colour := <span class="keyword">range</span> colours &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"index: %d, colour: %s\n"</span>, index, colour)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$colours = [<span class="string">"Maroon"</span>, <span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Blue"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($colours <span class="keyword">as</span> $index =&gt; $color) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"index: &#123;$index&#125;, color: &#123;$color&#125;\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://engineering.carsguide.com.au/go-vs-php-syntax-comparison-c1465380b8ff" target="_blank" rel="noopener">原文地址</a></li><li><a href="https://learnku.com/php/t/39590" target="_blank" rel="noopener">译文地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;PHP&lt;/code&gt; 是一种动态类型语言，它使新手更容易编写代码。现在的问题是，PHP 开发人员能否从动态类型语言切换到像 Go 这样的静态类型语言？为了找到答案，让我们对比一下 Go 和 PHP 之间的语法差异。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 是由 Google 设计的一门静态类型的编译型语言。它有点类似于 C，但是它包含了更多的优点，比如垃圾回收、内存安全、结构类型和并发性。它的并发机制使多核和网络机器能够发挥最大的作用。这是 GoLang 的最佳卖点之一。此外，Go 速度快，表现力强，干净且高效。这也是 Go 如此吸引开发者学习的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="Caoxl" scheme="http://blog.caoxl.com/categories/Caoxl/"/>
    
    
      <category term="PHP" scheme="http://blog.caoxl.com/tags/PHP/"/>
    
      <category term="Go" scheme="http://blog.caoxl.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试/笔试题杂记 IX</title>
    <link href="http://blog.caoxl.com/2020/09/23/Interview-Questions-Notes-IX/"/>
    <id>http://blog.caoxl.com/2020/09/23/Interview-Questions-Notes-IX/</id>
    <published>2020-09-23T01:47:07.000Z</published>
    <updated>2020-09-23T06:58:23.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>从问题中思考,从解答中成长</p></blockquote><a id="more"></a><h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><h1 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">计算机网络体系结构</a></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#12-http-%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90" target="_blank" rel="noopener">HTTP 报文组成</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#13-http-%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP 状态码</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#14-%E5%B8%B8%E8%A7%81%E7%9A%84-http-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">常见的 HTTP 方法</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#16-http-%E4%BC%98%E7%BC%BA%E7%82%B9" target="_blank" rel="noopener">HTTP 优缺点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#17-https-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">HTTPS 通信原理</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#18-http-20" target="_blank" rel="noopener">HTTP 2.0</a></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#tcp-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener">TCP 适用场景</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#3-tcp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9" target="_blank" rel="noopener">TCP 的主要特点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#4-%E7%AE%80%E8%BF%B0%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">简述三报文握手建立 TCP 连接</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#5-%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4" target="_blank" rel="noopener">建立 TCP 连接为什么最后还要发送确认</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#6-%E7%AE%80%E8%BF%B0-tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE" target="_blank" rel="noopener">简述 TCP 连接的释放</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#7-time-wait-%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2mls" target="_blank" rel="noopener">TIME-WAIT 是什么，为什么必须等待 2MLS</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#8-tcp-%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">TCP 粘包问题</a></li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#udp-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener">UDP 适用场景</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#2-udp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9" target="_blank" rel="noopener">UDP 的主要特点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#9-udptcp-%E5%8C%BA%E5%88%AB%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener">UDP、TCP 区别，适用场景</a></li></ul><h2 id="IPv4-amp-IPv6"><a href="#IPv4-amp-IPv6" class="headerlink" title="IPv4&amp;IPv6"></a>IPv4&amp;IPv6</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#20-ipv6-%E4%B8%8E-ipv4-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96" target="_blank" rel="noopener">IPv6 与 IPv4 有什么变化</a></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#10-%E5%BB%BA%E7%AB%8B-socket-%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4" target="_blank" rel="noopener">建立 socket 需要哪些步骤</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#19-websocket" target="_blank" rel="noopener">WebSocket</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#22-%E4%BB%80%E4%B9%88%E6%98%AF%E9%95%BF%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">什么是长连接</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#15-get-%E4%B8%8E-post-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">GET 与 POST 请求方式区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">什么是心跳机制</a></li></ul><h1 id="数据机构与算法篇"><a href="#数据机构与算法篇" class="headerlink" title="数据机构与算法篇"></a>数据机构与算法篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#1-%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">概述</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#2-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">实现基础</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#3-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">线性结构</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#4-%E6%A0%91" target="_blank" rel="noopener">树</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#5-%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE" target="_blank" rel="noopener">散列查找</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#6-%E5%9B%BE" target="_blank" rel="noopener">图</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#7-%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">排序</a></li></ul><h1 id="PHP篇"><a href="#PHP篇" class="headerlink" title="PHP篇"></a>PHP篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#echoprintprint_rvar_dump-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">echo、print、print_r、var_dump 区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">单引号和双引号的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#staticselfthis-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">static、self、$this 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#includerequireinclude_oncerequire_once-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">include、require、include_once、require_once 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#publicprotectedprivatefinal-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">public、protected、private、final 区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#mysqlmysqlipdo-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">MySQL、MySQLi、PDO 区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E5%8F%91%E8%B5%B7-http-%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">发起 HTTP 请求有哪几种方式，它们有何区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E5%B8%B8%E8%A7%81%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">常见数组函数</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#cookie-%E5%92%8C-session" target="_blank" rel="noopener">Cookie 和 Session</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">预定义变量</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">传值和传引用的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">构造函数和析构函数</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E8%B0%83%E7%94%A8%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">类的静态调用和实例化调用</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#phpini-%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">php.ini 配置选项</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#502504-%E9%94%99%E8%AF%AF%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">502、504 错误产生原因及解决方式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E4%B8%BB%E6%B5%81-php-%E6%A1%86%E6%9E%B6%E7%89%B9%E7%82%B9" target="_blank" rel="noopener">主流 PHP 框架特点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84orm" target="_blank" rel="noopener">对象关系映射/ORM</a></li></ul><h1 id="Web篇"><a href="#Web篇" class="headerlink" title="Web篇"></a>Web篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#seo-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84" target="_blank" rel="noopener">SEO 有哪些需要注意的</a></li></ul><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">JavaScript 数据类型</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A-javascript-%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8-html-%E5%BA%95%E9%83%A8" target="_blank" rel="noopener">为什么把 JavaScript 文件放在 Html 底部</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#javascript-%E6%93%8D%E4%BD%9C-dom-%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noopener">JavaScript 操作 DOM 的方法有哪些</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#javascript-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noopener">JavaScript 字符串方法有哪些</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#javascript-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">JavaScript 字符串截取方法有哪些？有什么区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-ajax-%E8%AF%B7%E6%B1%82" target="_blank" rel="noopener">如何实现 ajax 请求</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener">同源策略是什么</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">如何解决跨域问题</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noopener">引起内存泄漏的操作有哪些</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F%E6%88%96%E8%80%85%E5%A4%B1%E8%B4%A5" target="_blank" rel="noopener">如何判断网页中图片加载成功或者失败</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD" target="_blank" rel="noopener">如何实现懒加载</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#jsonp-%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">JSONP 原理</a></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#css-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB" target="_blank" rel="noopener">CSS 选择器的分类</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#css-sprite-%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9" target="_blank" rel="noopener">CSS sprite 是什么，有什么优缺点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#display-none-%E4%B8%8E-visibility-hidden-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">display: none 与 visibility: hidden 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#display-block-%E5%92%8C-display-inline-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">display: block 和 display: inline 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#css-%E6%96%87%E4%BB%B6style-%E6%A0%87%E7%AD%BE%E8%A1%8C%E5%86%85-style-%E5%B1%9E%E6%80%A7%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noopener">CSS 文件、style 标签、行内 style 属性优先级</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#link-%E4%B8%8E-import-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">link 与 @import 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#flex-%E4%B8%8E-css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">flex 与 CSS 盒子模型有什么区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#pnggifjpg-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%A6%82%E4%BD%95%E9%80%89" target="_blank" rel="noopener">PNG,GIF,JPG 的区别及如何选</a></li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#vuejs-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">Vue.js 双向绑定原理</a></li></ul><h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">体系结构</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C" target="_blank" rel="noopener">基础操作</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener">数据库设计范式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">数据库设计原则</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#char-%E5%92%8C-varchar-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">char 和 varchar 数据类型区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#left-join-right-joininner-join" target="_blank" rel="noopener">LEFT JOIN 、RIGHT JOIN、INNER JOIN</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#unionunion-all" target="_blank" rel="noopener">UNION、UNION ALL</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%B8%B8%E7%94%A8-mysql-%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">常用 MySQL 函数</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E9%94%81" target="_blank" rel="noopener">锁</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">事务</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">常见存储引擎</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">常见索引</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E8%81%9A%E6%97%8F%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E6%97%8F%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">聚族索引与非聚族索引的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#btree-%E4%B8%8E-btree-btree-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">BTree 与 BTree-/BTree+ 索引原理</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%88%86%E8%A1%A8%E6%95%B0%E9%87%8F%E7%BA%A7" target="_blank" rel="noopener">分表数量级</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#explain-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">EXPLAIN 输出格式</a></li></ul><h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E7%89%B9%E7%82%B9" target="_blank" rel="noopener">Redis 特点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">Redis 支持哪些数据结构</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E4%B8%8E-memcache-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">Redis 与 Memcache 区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5" target="_blank" rel="noopener">持久化策略</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">Redis 事务</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" target="_blank" rel="noopener">如何实现分布式锁</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Redis 过期策略及内存淘汰机制</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#%E4%B8%BA%E4%BB%80%E4%B9%88-redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84" target="_blank" rel="noopener">为什么 Redis 是单线程的</a></li></ul><h1 id="Linux篇"><a href="#Linux篇" class="headerlink" title="Linux篇"></a>Linux篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#linux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">Linux 目录结构</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#linux-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">Linux 基础</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE" target="_blank" rel="noopener">命令与文件查找</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">数据流重定向</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1" target="_blank" rel="noopener">计划任务</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#vim" target="_blank" rel="noopener">Vim</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E8%B4%9F%E8%BD%BD%E6%9F%A5%E7%9C%8B" target="_blank" rel="noopener">负载查看</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">Linux 内存管理</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">进程、线程、协程区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">进程间通信与信号机制</a></li></ul><h1 id="安全篇"><a href="#安全篇" class="headerlink" title="安全篇"></a>安全篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss" target="_blank" rel="noopener">跨站脚本攻击(XSS)</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0csrf" target="_blank" rel="noopener">跨站点请求伪造(CSRF)</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#sql-%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">SQL 注入</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#%E5%BA%94%E7%94%A8%E5%B1%82%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">应用层拒绝服务攻击</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#php-%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">PHP 安全</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0" target="_blank" rel="noopener">伪随机数和真随机数</a></li></ul><h1 id="设计模式篇"><a href="#设计模式篇" class="headerlink" title="设计模式篇"></a>设计模式篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">什么是设计模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">如何理解框架</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E4%B8%BB%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">主要设计模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">怎样选择设计模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">单例模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">抽象工厂模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工厂方法模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">适配器模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">策略模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC" target="_blank" rel="noopener">控制反转</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a></li></ul><h1 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#oauth-20" target="_blank" rel="noopener">OAuth 2.0</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">单点登录</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#rest" target="_blank" rel="noopener">REST</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#api-%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9" target="_blank" rel="noopener">API 版本兼容</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#jwt" target="_blank" rel="noopener">JWT</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#lvs" target="_blank" rel="noopener">LVS</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#ngnix" target="_blank" rel="noopener">Ngnix</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB" target="_blank" rel="noopener">数据库读写分离</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%86%E5%88%86" target="_blank" rel="noopener">数据库拆分</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">一致性哈希</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#redis-%E9%9B%86%E7%BE%A4" target="_blank" rel="noopener">Redis 集群</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" target="_blank" rel="noopener">消息队列</a></li></ul><h1 id="职业规划篇"><a href="#职业规划篇" class="headerlink" title="职业规划篇"></a>职业规划篇</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从问题中思考,从解答中成长&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>他写出了 Vue，却做不对这十道 Vue 笔试题</title>
    <link href="http://blog.caoxl.com/2020/09/10/Vue-The-Test/"/>
    <id>http://blog.caoxl.com/2020/09/10/Vue-The-Test/</id>
    <published>2020-09-10T07:17:23.000Z</published>
    <updated>2020-09-10T07:43:56.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>原文地址: <a href="https://juejin.im/post/6870737289736093710" target="_blank" rel="noopener">他写出了 Vue，却做不对这十道 Vue 笔试题</a></p></blockquote><a id="more"></a><p>这里搬运过来只是方便自己学习.</p><p>上题:</p><ul><li><ol><li><code>Vue</code> 实例的 <code>data</code> 属性，可以在哪些生命周期中获取到？<br>A. <code>beforeCreate</code><br>B. <code>created</code><br>C. <code>beforeMount</code><br>D. <code>mounted</code></li></ol></li></ul><ul><li><ol start="2"><li>下列对 <code>Vue</code> 原理的叙述，哪些是正确的？<br>A. <code>Vue</code> 中的数组变更通知，通过拦截数组操作方法而实现<br>B. 编译器目标是创建渲染函数，渲染函数执行后将得到 <code>VNode</code> 树<br>C. 组件内 <code>data</code> 发生变化时会通知其对应 <code>watcher</code>，执行异步更新<br>D. <code>patching</code> 算法首先进行同层级比较，可能执行的操作是节点的增加、删除和更新</li></ol></li></ul><ul><li><ol start="3"><li>对于 <code>Vue</code> 中响应式数据原理的说法，下列哪项是不正确的？<br>A. 采用数据劫持方式，即 <code>Object.defineProperty()</code> 劫持 <code>data</code> 中各属性，实现响应式数据<br>B. 视图中的变化会通过 <code>watcher</code> 更新 <code>data</code> 中的数据<br>C. 若 <code>data</code> 中某属性多次发生变化，<code>watcher</code> 仅会进入更新队列一次<br>D. 通过编译过程进行依赖收集</li></ol></li></ul><ul><li><ol start="4"><li>下列说法不正确的是哪项？<br>A. <code>key</code> 的作用主要是为了高效地更新虚拟 <code>DOM</code><br>B. 若指定了组件的 <code>template</code> 选项，<code>render</code> 函数不会执行<br>C. 使用 <code>vm.$nextTick</code> 可以确保获得 <code>DOM</code> 异步更新的结果<br>D. 若没有 <code>el</code> 选项，<code>vm.$mount(dom)</code> 可将 <code>Vue</code> 实例挂载于指定元素上</li></ol></li></ul><ul><li><ol start="5"><li>下列关于 <code>Vuex</code> 的描述，不正确的是哪项？<br>A. <code>Vuex</code> 通过 <code>Vue</code> 实现响应式状态，因此只能用于 <code>Vue</code><br>B. <code>Vuex</code> 是一个状态管理模式<br>C. <code>Vuex</code> 主要用于多视图间状态全局共享与管理<br>D. 在 <code>Vuex</code> 中改变状态，可以通过 <code>mutations</code> 和 <code>actions</code></li></ol></li></ul><ul><li><ol start="6"><li>关于 <code>Vue</code> 组件间的参数传递，下列哪项是不正确的？<br>A. 若子组件给父组件传值，可使用 <code>$emit</code> 方法<br>B. 祖孙组件之间可以使用 <code>provide</code> 和 <code>inject</code> 方式跨层级相互传值<br>C. 若子组件使用 <code>$emit(&#39;say&#39;)</code> 派发事件，父组件可使用 <code>@say</code> 监听<br>D. 若父组件给子组件传值，子组件可通过 <code>props</code> 接受数据</li></ol></li></ul><ul><li><ol start="7"><li>下列关于 <code>vue-router</code> 的描述，不正确的是哪项？<br>A. <code>vue-router</code> 的常用模式有 <code>hash</code> 和 <code>history</code> 两种<br>B. 可通过 <code>addRoutes</code> 方法动态添加路由<br>C. 可通过 <code>beforeEnter</code> 对单个组件进行路由守卫<br>D. <code>vue-router</code> 借助 <code>Vue</code> 实现响应式的路由，因此只能用于 <code>Vue</code></li></ol></li></ul><ul><li><ol start="8"><li>下列说法不正确的是哪项？<br>A. 可通过 <code>this.$parent</code> 查找当前组件的父组件<br>B. 可使用 <code>this.$refs</code> 查找命名子组件<br>C. 可使用 <code>this.$children</code> 按顺序查找当前组件的直接子组件<br>D. 可使用 <code>$root</code> 查找根组件，并可配合 <code>children</code> 遍历全部组件</li></ol></li></ul><ul><li><ol start="9"><li>下列关于 <code>v-model</code> 的说法，哪项是不正确的？<br>A. <code>v-model</code> 能实现双向绑定<br>B. <code>v-model</code> 本质上是语法糖，它负责监听用户的输入事件以更新数据<br>C. <code>v-model</code> 是内置指令，不能用在自定义组件上<br>D. 对 <code>input</code> 使用 <code>v-model</code>，实际上是指定其 <code>:value</code> 和 <code>:input</code></li></ol></li></ul><ul><li><ol start="10"><li>关于 <code>Vue</code> 的生命周期，下列哪项是不正确的？<br>A. <code>DOM</code> 渲染在 <code>mounted</code> 中就已经完成了<br>B. <code>Vue</code> 实例从创建到销毁的过程，就是生命周期<br>C. <code>created</code> 表示完成数据观测、属性和方法的运算和初始化事件，此时 <code>$el</code> 属性还未显示出来<br>D. 页面首次加载过程中，会依次触发 <code>beforeCreate</code>，<code>created</code>，<code>beforeMount</code>，<code>mounted</code>，<code>beforeUpdate</code>，<code>updated</code></li></ol></li></ul><ul><li>参考答案</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> BCD</span><br><span class="line"><span class="number">2.</span> ABCD</span><br><span class="line"><span class="number">3.</span> BD</span><br><span class="line"><span class="number">4.</span> B</span><br><span class="line"><span class="number">5.</span> C</span><br><span class="line"><span class="number">6.</span> B</span><br><span class="line"><span class="number">7.</span> C</span><br><span class="line"><span class="number">8.</span> C</span><br><span class="line"><span class="number">9.</span> C</span><br><span class="line"><span class="number">10.</span> D</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.zhihu.com/question/393825440/answer/1214828265" target="_blank" rel="noopener">逐条判定为什么 Dan Abramov 配不上阿里 P7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://juejin.im/post/6870737289736093710&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;他写出了 Vue，却做不对这十道 Vue 笔试题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://blog.caoxl.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://blog.caoxl.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue CLI 3.x 与 2.x的区别</title>
    <link href="http://blog.caoxl.com/2020/09/09/Vue-2x-3x-Diff/"/>
    <id>http://blog.caoxl.com/2020/09/09/Vue-2x-3x-Diff/</id>
    <published>2020-09-09T04:03:30.000Z</published>
    <updated>2020-09-09T07:56:32.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue CLI 3.x 与 2.x的区别</p><a id="more"></a><h1 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h1><ul><li>安装与项目构建</li><li>项目目录变化</li><li>项目配置变化</li></ul><h1 id="安装-amp-项目构建"><a href="#安装-amp-项目构建" class="headerlink" title="安装&amp;项目构建"></a>安装&amp;项目构建</h1><h2 id="CLI安装"><a href="#CLI安装" class="headerlink" title="CLI安装"></a>CLI安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cli 2.x </span></span><br><span class="line"><span class="built_in">npm</span> install -g vue-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># cli 3.x </span></span><br><span class="line"><span class="comment"># 3.x 安装时，如果之前安装了2.x需要卸载2.x再安装</span></span><br><span class="line"><span class="built_in">npm</span> install -g @vue/cli</span><br></pre></td></tr></table></figure><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="cli2-x"><a href="#cli2-x" class="headerlink" title="cli2.x"></a>cli2.x</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue init &lt;template-<span class="built_in">name</span>&gt; &lt;project-<span class="built_in">name</span>&gt;</span><br><span class="line">npm i </span><br><span class="line">npm <span class="built_in">run</span> dev</span><br></pre></td></tr></table></figure><h3 id="cli3-x"><a href="#cli3-x" class="headerlink" title="cli3.x"></a>cli3.x</h3><blockquote><ul><li>安装新增TypeScript配置选项</li><li>新增图形化安装方法</li><li>保留了2.x之前的安装方法</li></ul></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vue</span> <span class="string">create hello-world</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">i</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">run serve</span></span><br><span class="line"><span class="comment"># 使用vue ui创建新项目(3.x新增)</span></span><br><span class="line"><span class="attr">vue</span> <span class="string">ui</span></span><br><span class="line"><span class="comment"># 使用旧版（2.X）创建</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install -g @vue/cli-init</span></span><br><span class="line"><span class="comment"># 'vue init'的运行效果与‘vue-cli@2.x’相同</span></span><br><span class="line"><span class="attr">vue</span> <span class="string">init webpack projectname</span></span><br></pre></td></tr></table></figure><h1 id="3-x后目录结构变化-替换2-x功能的新特性"><a href="#3-x后目录结构变化-替换2-x功能的新特性" class="headerlink" title="3.x后目录结构变化[替换2.x功能的新特性]"></a>3.x后目录结构变化[替换2.x功能的新特性]</h1><h2 id="config目录删除，使用模式的-env文件代替-模式"><a href="#config目录删除，使用模式的-env文件代替-模式" class="headerlink" title="config目录删除，使用模式的.env文件代替[模式]"></a>config目录删除，使用模式的.env文件代替[模式]</h2><p><code>cli3</code>新增模式概念，每个模式在项目中都有对应的配置文件，项目启动时，对应的文件就会加载，与环境变量不同，一个模式可以包括多个环境变量</p><ul><li><p><code>Vue CLI</code> 项目默认有三个模式：</p><ul><li><code>development</code> 模式用于 <code>vue-cli-service serve</code></li><li><code>production</code> 模式用于 <code>vue-cli-service build</code> 和 <code>vue-cli-service test:e2e</code></li><li><code>test</code> 模式用于 <code>vue-cli-service test:unit</code></li></ul></li><li><p>模式需要在启动项目时使用–mode指定</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NODE_ENV</span>=development npm <span class="builtin-name">run</span> serve --mode mymode # 模式包含多个环境变量</span><br></pre></td></tr></table></figure><ul><li>每个模式有多个环境变量，<code>cli3.x</code>为模式与环境变量指定了一个<code>.env</code>配置文件</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.env</span> # 所有环境</span><br><span class="line"><span class="selector-class">.env</span><span class="selector-class">.mode</span> # <span class="selector-tag">mode</span>模式加载的配置文件<span class="selector-attr">[优先级高于.env]</span></span><br><span class="line"><span class="selector-class">.env</span><span class="selector-class">.mode</span><span class="selector-class">.development</span> # <span class="selector-tag">mode</span>模式下，<span class="selector-tag">development</span>环境所加载的配置文件<span class="selector-attr">[优先级最高]</span></span><br></pre></td></tr></table></figure><ul><li><code>.env</code>文件详细信息<ul><li>这些文件是用来代替<code>config</code>目录的</li><li>以<code>VUE_APP_</code>开头的变量可以再代码中通过<code>process.env</code>访问，其他的变量不可访问</li><li><code>process.env</code>始终含有两个特殊变量<code>NODE_ENV</code>和<code>BASE_URL</code></li></ul></li></ul><h2 id="删除static目录-新增public目录"><a href="#删除static目录-新增public目录" class="headerlink" title="删除static目录[新增public目录]"></a>删除static目录[新增public目录]</h2><p>删除了<code>static</code>目录，它的静态资源转移到<code>public</code>目录中，通过<code>/xx.xx</code>可以直接访问</p><h3 id="public详细信息"><a href="#public详细信息" class="headerlink" title="public详细信息"></a><code>public</code>详细信息</h3><ul><li><p><code>index.html</code>入口文件从根目录转到<code>public</code>目录下，它拥有3个特殊插值</p><ul><li><code>&lt;%= VALUE %&gt;</code> 用来做不转义插值；</li><li><code>&lt;%- VALUE %&gt;</code> 用来做 HTML 转义插值；</li><li><code>&lt;% expression %&gt;</code> 用来描述 JavaScript 流程控制</li></ul></li><li><p>静态资源被转移到public目录存放</p></li><li><p><code>cli3</code>项目的静态资源有两种处理方式</p><ul><li>在<code>JavaScript</code>或<code>template/css(vue)</code>中通过相对路径导入。这类资源会被<code>webpack</code>处理（不在public目录）</li><li>放在<code>public</code>目录或者使用绝对路径被导入的静态资源。这类资源会被直接拷贝，不会经过<code>webpack</code>处理</li></ul></li></ul><h2 id="cli3-x项目配置的不同（build目录删除）"><a href="#cli3-x项目配置的不同（build目录删除）" class="headerlink" title="cli3.x项目配置的不同（build目录删除）"></a><code>cli3.x</code>项目配置的不同（<code>build</code>目录删除）</h2><p><code>2.x</code>版本的项目配置是在<code>config</code>和<code>build</code>中完成，但是，到了<code>3.x</code>版本，这两个目录都被删除，如果需要自定义配置，需要自己新建<code>vue.config.js</code>文件</p><ul><li><p><code>publicPath</code></p><ul><li>部署应用包时的基本URL，即<code>webpack</code>的<code>output.publicPath</code></li><li>但，<code>vue</code>项目中其他地方会用到<code>publicPath</code>，所以不要修改<code>webpack</code>的<code>output.publicPath</code></li></ul></li><li><p><code>outputDir</code></p><ul><li><code>build</code>构建的文件存放的目录</li><li>即<code>output.path</code>，但只能修改<code>outputDir</code>，不能修改<code>output.path</code></li></ul></li><li><p><code>assetsDir</code> 编译后，在<code>outputDir</code>目录中存放静态资源的目录</p></li><li><p><code>lintOnSave</code> 配置<code>eslint</code>后，是否每次保存<code>lint</code>代码，默认启动</p></li><li><p><code>runtimeCompiler</code> 是否使用包含运行时编译器的 <code>Vue</code> 构建版本，默认不启动</p></li><li><p><code>configureWebpack</code> &amp; <code>chainWebpack</code></p><ul><li>这两个选项是用来配置<code>webpack</code>内容的，前者是合并对象，后者是链式调用</li><li><code>[cli3.6]webpack</code>的<code>build</code>代码压缩默认不开启，需要设置环境变量为<code>production</code>才会开启</li></ul></li><li><p><code>devServer</code> 支持所有<code>webpack-dev-server</code>选项</p><ul><li>配置项目端口、域名 <code>host、port、https</code></li><li>配置项目跨域代理 <code>proxy</code></li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">module.exports</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8100</span><span class="string">,</span></span><br><span class="line">  <span class="attr">devServer:</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">proxy:</span> <span class="string">'http://localhost:4000'</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="新增功能特性"><a href="#新增功能特性" class="headerlink" title="新增功能特性"></a>新增功能特性</h1><h2 id="快速原型开发"><a href="#快速原型开发" class="headerlink" title="快速原型开发"></a>快速原型开发</h2><p>在<code>cli3.x</code>中可以使用<code>vue serve</code> 和<code>vue build</code>命令对单个<code>*.vue</code> 文件进行快速原型开发</p><h3 id="安装全局依赖"><a href="#安装全局依赖" class="headerlink" title="安装全局依赖"></a>安装全局依赖</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @vue/cli-service-<span class="built_in">global</span></span><br></pre></td></tr></table></figure><h3 id="vue-serve-运行文件"><a href="#vue-serve-运行文件" class="headerlink" title="vue serve 运行文件"></a><code>vue serve</code> 运行文件</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">vue</span> <span class="selector-tag">serve</span> <span class="selector-tag">myComponent</span><span class="selector-class">.vue</span> </span><br><span class="line"><span class="selector-tag">Usage</span>: <span class="selector-tag">serve</span> <span class="selector-attr">[options]</span> <span class="selector-attr">[entry]</span></span><br><span class="line">在开发环境模式下零配置为 <span class="selector-class">.js</span> 或 <span class="selector-class">.vue</span> 文件启动一个服务器</span><br><span class="line"><span class="selector-tag">Options</span>:</span><br><span class="line">  <span class="selector-tag">-o</span>, <span class="selector-tag">--open</span>  打开浏览器</span><br><span class="line">  <span class="selector-tag">-c</span>, <span class="selector-tag">--copy</span>  将本地 <span class="selector-tag">URL</span> 复制到剪切板</span><br><span class="line">  <span class="selector-tag">-h</span>, <span class="selector-tag">--help</span>  输出用法信息</span><br></pre></td></tr></table></figure><h3 id="vue-build-编译文件"><a href="#vue-build-编译文件" class="headerlink" title="vue build 编译文件"></a><code>vue build</code> 编译文件</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vue build myComponent.vue </span><br><span class="line"><span class="symbol">Usage:</span> build [options] [entry]</span><br><span class="line">在生产环境模式下零配置构建一个 .js 或 .vue 文件</span><br><span class="line"><span class="symbol">Options:</span></span><br><span class="line">  -t, --target &lt;target&gt;  构建目标 (app | <span class="class"><span class="keyword">lib</span> | <span class="title">wc</span> | <span class="title">wc</span>-<span class="title">async</span>, 默认值：<span class="title">app</span>)</span></span><br><span class="line">  -n, --name &lt;name&gt;      库的名字或 Web Components 组件的名字 (默认值：入口文件名)</span><br><span class="line">  -d, --dest &lt;dir&gt;       输出目录 (默认值：dist)</span><br><span class="line">  -h, --help             输出用法信息</span><br></pre></td></tr></table></figure><h2 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h2><p><code>vue cli3</code> 新增一个UI图形化管理页面，可以通过它新建项目、管理原有项目的插件</p><h3 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue</span> ui <span class="comment"># 启动图形化界面</span></span><br></pre></td></tr></table></figure><h3 id="管理原有项目（包括2-X项目）"><a href="#管理原有项目（包括2-X项目）" class="headerlink" title="管理原有项目（包括2.X项目）"></a>管理原有项目（包括2.X项目）</h3><ul><li>插件管理（更新，查看）（3.x）</li><li>依赖（module）管理（删除、安装、更新、查看）（2.x、3.x）</li><li>项目配置修改 （3.x）</li><li>项目任务（项目script命令启动、停止操作）（2.x、3.x）</li></ul><h2 id="cli插件"><a href="#cli插件" class="headerlink" title="cli插件"></a><code>cli</code>插件</h2><h3 id="什么是插件"><a href="#什么是插件" class="headerlink" title="什么是插件"></a>什么是插件</h3><ul><li><code>vue cli3.x</code>使用了一套基于插件的架构，cli的相关依赖都是以<code>@vue/cli-plugin-</code>开头的</li><li>插件可以修改内部的 <code>webpack</code> 配置，也可以向 <code>vue-cli-service</code> 注入命令</li><li>在项目创建的过程中列出的特性，绝大部分都是通过插件来实现的</li></ul><h3 id="vue-add-插件的安装"><a href="#vue-add-插件的安装" class="headerlink" title="vue add 插件的安装"></a><code>vue add</code> 插件的安装</h3><p><code>cli3.x</code>项目提供了<code>vue add</code>命令来安装插件</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">add</span> @vue/<span class="keyword">cli</span>-plugin-eslint</span><br></pre></td></tr></table></figure><h3 id="特殊的vue-router和vuex"><a href="#特殊的vue-router和vuex" class="headerlink" title="特殊的vue-router和vuex"></a>特殊的<code>vue-router</code>和<code>vuex</code></h3><p>它们没有对应的插件，但是依旧可以使用<code>vue add</code>在项目中添加它们</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">add</span><span class="bash"> router</span></span><br><span class="line">vue <span class="keyword">add</span><span class="bash"> vuex</span></span><br></pre></td></tr></table></figure><h2 id="配置文件样例"><a href="#配置文件样例" class="headerlink" title="配置文件样例"></a>配置文件样例</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> <span class="params">(dir)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> path.<span class="keyword">join</span>(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">'/'</span>,</span><br><span class="line">  assetsDir: <span class="string">'static'</span>,</span><br><span class="line">  productionSourceMap: false,</span><br><span class="line">  configureWebpack: config =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.VUE_APP_NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      // 为生产环境修改配置...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      // 为开发环境修改配置...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 解析别名处理</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    config.<span class="built_in">resolve</span>.alias</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@img'</span>, <span class="built_in">resolve</span>(<span class="string">'src/assets/img'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@c'</span>, <span class="built_in">resolve</span>(<span class="string">'src/components'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@m'</span>, <span class="built_in">resolve</span>(<span class="string">'src/mixins'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@v'</span>, <span class="built_in">resolve</span>(<span class="string">'src/views'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@s'</span>, <span class="built_in">resolve</span>(<span class="string">'src/store'</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  // 配置高于chainWebpack中关于 css loader 的配置</span><br><span class="line">  <span class="keyword">cs</span><span class="variable">s:</span> &#123;</span><br><span class="line">    // 是否开启支持 foo.module.css 样式</span><br><span class="line">    module<span class="variable">s:</span> false,</span><br><span class="line">    // 是否使用 css 分离插件 ExtractTextPlugin，采用独立样式文件载入，不采用 <span class="symbol">&lt;style&gt;</span> 方式内联至 html 文件中</span><br><span class="line">    extrac<span class="variable">t:</span> true,</span><br><span class="line">    // 是否构建样式地图，false 将提高构建速度</span><br><span class="line">    sourceMap: false,</span><br><span class="line">    // css预设器配置项</span><br><span class="line">    loaderOption<span class="variable">s:</span> &#123;</span><br><span class="line">      <span class="keyword">cs</span><span class="variable">s:</span> &#123;</span><br><span class="line">        // <span class="keyword">options</span> here will <span class="keyword">be</span> passed <span class="keyword">to</span> css-loader</span><br><span class="line">      &#125;,</span><br><span class="line">      postcs<span class="variable">s:</span> &#123;</span><br><span class="line">        // <span class="keyword">options</span> here will <span class="keyword">be</span> passed <span class="keyword">to</span> postcss-loader</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    por<span class="variable">t:</span> <span class="number">8010</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/6844903911808040967#heading-20" target="_blank" rel="noopener">Vue CLI 3.x 与 2.x的区别</a></li><li><a href="https://juejin.im/post/6844904176187605000" target="_blank" rel="noopener">Vue 3教程（适用于Vue 2用户）</a></li><li><a href="https://juejin.im/post/6869521076771094536" target="_blank" rel="noopener">使用Vue3.0，我收获了哪些知识点</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue CLI 3.x 与 2.x的区别&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://blog.caoxl.com/categories/Vue/"/>
    
    
      <category term="前端" scheme="http://blog.caoxl.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://blog.caoxl.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SQL诊断与优化</title>
    <link href="http://blog.caoxl.com/2020/07/28/MySQL-Explain-Notes/"/>
    <id>http://blog.caoxl.com/2020/07/28/MySQL-Explain-Notes/</id>
    <published>2020-07-28T02:16:35.000Z</published>
    <updated>2020-12-23T03:02:57.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Explain-诊断"><a href="#Explain-诊断" class="headerlink" title="Explain 诊断"></a>Explain 诊断</h1><a id="more"></a><p>Explain各参数的含义如下：</p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>id</code></td><td style="text-align:left">执行编号，标识select所属的行。如果在语句中没有子查询或关联查询，只有唯一的select，每行都将显示1.否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置</td></tr><tr><td style="text-align:left"><code>select_type</code></td><td style="text-align:left">显示本行是简单或复杂select，如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUIT</td></tr><tr><td style="text-align:left"><code>table</code></td><td style="text-align:left">访问引用哪个表（引用某个查询，如“derived3”</td></tr><tr><td style="text-align:left"><code>type</code></td><td style="text-align:left">数据访问/读取操作类型（All、index、range、ref、eq_ref、const/system、NULL）</td></tr><tr><td style="text-align:left"><code>possible_key</code></td><td style="text-align:left">揭示哪一些索引可能有利于高效的查找</td></tr><tr><td style="text-align:left"><code>key</code></td><td style="text-align:left">显示mysql实际决定采用哪个索引来优化查询</td></tr><tr><td style="text-align:left"><code>key_len</code></td><td style="text-align:left">显示mysql在索引里使用的字节数</td></tr><tr><td style="text-align:left"><code>ref</code></td><td style="text-align:left">显示了之前的表在key列记录的索引中查找值所用的列或常量</td></tr><tr><td style="text-align:left"><code>rows</code></td><td style="text-align:left">为了找到所需要的行而需要读取的行数，估算值</td></tr><tr><td style="text-align:left"><code>Extra</code></td><td style="text-align:left">额外信息，如using index、filesort等</td></tr></tbody></table><h2 id="select-type-常见类型及其含义"><a href="#select-type-常见类型及其含义" class="headerlink" title="select_type 常见类型及其含义"></a>select_type 常见类型及其含义</h2><ul><li><strong>SIMPLE</strong>: 不包含子查询或者 UNION 操作的查询</li><li><strong>PRIMARY</strong>: 查询中如果包含任何子查询，那么最外层的查询则被标记为 PRIMARY</li><li><strong>SUBQUERY</strong>: 子查询中第一个 SELECT</li><li><strong>DEPENDENT SUBQUERY</strong>: 子查询中的第一个 SELECT，取决于外部查询</li><li><strong>UNION</strong>: UNION 操作的第二个或者之后的查询</li><li><strong>DEPENDENT UNION</strong>: UNION 操作的第二个或者之后的查询,取决于外部查询</li><li><strong>UNION RESULT</strong>: UNION 产生的结果集</li><li><strong>DERIVED</strong>: 出现在 FROM 字句中的子查询</li></ul><h2 id="type常见类型及其含义"><a href="#type常见类型及其含义" class="headerlink" title="type常见类型及其含义"></a>type常见类型及其含义</h2><ul><li><strong>system</strong>: 这是 const 类型的一个特例，只会出现在待查询的表只有一行数据的情况下</li><li><strong>consts</strong>: 常出现在主键或唯一索引与常量值进行比较的场景下，此时查询性能是最优的</li><li><strong>eq_ref</strong>: 当连接使用的是完整的索引并且是 PRIMARY KEY 或 UNIQUE NOT NULL INDEX 时使用它</li><li><strong>ref</strong>：当连接使用的是前缀索引或连接条件不是 PRIMARY KEY 或 UNIQUE INDEX 时则使用它</li><li><strong>ref_or_null</strong>: 类似于 ref 类型的查询，但是附加了对 NULL 值列的查询</li><li><strong>index_merge</strong>: 该联接类型表示使用了索引进行合并优化</li><li><strong>range</strong>: 使用索引进行范围扫描，常见于 between、&gt; 、&lt; 这样的查询条件</li><li><strong>index</strong>: 索引连接类型与 ALL 相同，只是扫描的是索引树，通常出现在索引是该查询的覆盖索引的情况</li><li><strong>ALL</strong>: 全表扫描，效率最差的查找方式</li></ul><p>阿里编码规范要求：<code>至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好</code></p><h2 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h2><p>实际在查询中是否使用到索引的标志字段</p><h2 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h2><p>Extra 列主要用于显示额外的信息，常见信息及其含义如下:</p><ul><li><strong>Using where</strong>: MySQL 服务器会在存储引擎检索行后再进行过滤</li><li><strong>Using filesort</strong>: 通常出现在 GROUP BY 或 ORDER BY<br>语句中，且排序或分组没有基于索引，此时需要使用文件在内存中进行排序，因为使用索引排序的性能好于使用文件排序，所以出现这种情况可以考虑通过添加索引进行优化</li><li><strong>Using index</strong>: 使用了覆盖索引进行查询，此时不需要访问表，从索引中就可以获取到所需的全部数据</li><li><strong>Using index condition</strong>: 查找使用了索引，但是需要回表查询数据</li><li><strong>Using temporary</strong>: 表示需要使用临时表来处理查询，常出现在 GROUP BY 或 ORDER BY 语句中</li></ul><h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="超大分页场景解决方案"><a href="#超大分页场景解决方案" class="headerlink" title="超大分页场景解决方案"></a>超大分页场景解决方案</h2><p>如表中数据需要进行深度分页，如何提高效率？在阿里出品的Java编程规范中写道：</p><blockquote><p>利用延迟关联或者子查询优化超多分页场景</p></blockquote><p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 反例（耗时129.570s）</span><br><span class="line">select * from task_result LIMIT 20000000, 10;</span><br><span class="line"></span><br><span class="line"># 正例（耗时5.114s）</span><br><span class="line">SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id = b.id;</span><br></pre></td></tr></table></figure><blockquote><p>说明<br>task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万</p></blockquote><h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 反例</span></span><br><span class="line">INSERT into person(name,age) values('A',24)</span><br><span class="line">INSERT into person(name,age) values('B',24)</span><br><span class="line">INSERT into person(name,age) values('C',24)</span><br><span class="line"></span><br><span class="line"><span class="section"># 正例</span></span><br><span class="line">INSERT into person(name,age) values('A',24),('B',24),('C',24);</span><br></pre></td></tr></table></figure><blockquote><p>说明<br>比较常规，就不多做说明了</p></blockquote><h2 id="like语句的优化"><a href="#like语句的优化" class="headerlink" title="like语句的优化"></a>like语句的优化</h2><p>like语句一般业务要求都是 <code>&#39;%关键字%&#39;</code> 这种形式，但是依然要思考能否考虑使用右模糊的方式去替代产品的要求，其中阿里的编码规范提到:</p><blockquote><p>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 反例（耗时78.843s）</span></span><br><span class="line">EXPLAIN select * from task_result where taskid LIKE '%tt600e6b601677b5cbfe516a013b8e46%' LIMIT 1;</span><br><span class="line"></span><br><span class="line"><span class="section"># 正例（耗时0.986s）</span></span><br><span class="line">select * from task_result where taskid LIKE 'tt600e6b601677b5cbfe516a013b8e46%' LIMIT 1</span><br><span class="line"></span><br><span class="line"><span class="section">##########################################################################</span></span><br><span class="line"><span class="section"># 对正例的Explain</span></span><br><span class="line">1SIMPLEtask<span class="emphasis">_resultrangeadapt_</span>idadapt_id9899100.00Using index condition</span><br><span class="line"></span><br><span class="line"><span class="section"># 对反例的Explain</span></span><br><span class="line">1SIMPLEtask_resultALL                    3362855411.11Using where</span><br></pre></td></tr></table></figure><blockquote><p>说明<br>task_result表为生产环境的一个表，总数据量为3400万，taskid是一个普通索引列，可见%%这种匹配方式完全无法使用索引，从而进行全表扫描导致效率极低，而正例通过索引查找数据只需要扫描99条数据即可</p></blockquote><h2 id="避免SQL中对where字段进行函数转换或表达式计算"><a href="#避免SQL中对where字段进行函数转换或表达式计算" class="headerlink" title="避免SQL中对where字段进行函数转换或表达式计算"></a>避免SQL中对where字段进行函数转换或表达式计算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 反例</span><br><span class="line">select * from task_result where id + 1 = 15551;</span><br><span class="line"></span><br><span class="line"># 正例</span><br><span class="line">select * from task_result where id = 15550;</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line"># 对正例的Explain</span><br><span class="line">1SIMPLEtask_resultconstPRIMARYPRIMARY8const1100.00</span><br><span class="line"></span><br><span class="line"># 对反例的Explain</span><br><span class="line">1SIMPLEtask_resultALL                33631512  100.00Using where</span><br></pre></td></tr></table></figure><blockquote><p> 说明<br>其实在知道了有SQL优化器之后，我个人感觉这种普通的表达式转换应该可以提前进行处理再进行查询，这样一来就可以用到索引了，但是问题又来了，如果mysql优化器可以提前计算出结果，那么写sql语句的人也一定可以提前计算出结果，所以矛盾点在这个地方，导致5.7版本以前的此种情况都无法使用索引吧，未来可能会对其进行优化</p></blockquote><h2 id="使用-ISNULL-来判断是否为-NULL-值"><a href="#使用-ISNULL-来判断是否为-NULL-值" class="headerlink" title="使用 ISNULL()来判断是否为 NULL 值"></a>使用 ISNULL()来判断是否为 NULL 值</h2><p>说明：NULL 与任何值的直接比较都为 NULL</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1） NULL &lt;&gt; NULL 的返回结果是 NULL，而不是 false。 </span></span><br><span class="line"><span class="section"># 2） NULL = NULL 的返回结果是 NULL，而不是 true。 </span></span><br><span class="line"><span class="section"># 3） NULL &lt;&gt; 1 的返回结果是 NULL，而不是 true。</span></span><br></pre></td></tr></table></figure><h2 id="明明有索引为什么还走全表扫描"><a href="#明明有索引为什么还走全表扫描" class="headerlink" title="明明有索引为什么还走全表扫描"></a>明明有索引为什么还走全表扫描</h2><blockquote><p>MYSQL查询优化器针对查询的数据行占总数据量过多时会转化成全表查询</p></blockquote><h2 id="count-还是-count-id"><a href="#count-还是-count-id" class="headerlink" title="count(*) 还是 count(id)"></a>count(*) 还是 count(id)</h2><blockquote><p>【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*)</p></blockquote><p>count(*) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p><p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行</p><h2 id="字段类型不同导致索引失效"><a href="#字段类型不同导致索引失效" class="headerlink" title="字段类型不同导致索引失效"></a>字段类型不同导致索引失效</h2><blockquote><p>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 正例</span></span><br><span class="line">EXPLAIN SELECT * FROM <span class="code">`user_coll`</span> where pid = '1';</span><br><span class="line">type：ref</span><br><span class="line">ref：const</span><br><span class="line">rows:1</span><br><span class="line">Extra:Using index condition</span><br><span class="line"></span><br><span class="line"><span class="section"># 反例</span></span><br><span class="line">EXPLAIN SELECT * FROM <span class="code">`user_coll`</span> where pid = 1;</span><br><span class="line">type：index</span><br><span class="line">ref：NULL</span><br><span class="line">rows:3(总记录数)</span><br><span class="line">Extra:Using where; Using index</span><br></pre></td></tr></table></figure><blockquote><p>说明<br>pid字段有相应索引，且格式为varchar</p></blockquote><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul><li>自建数据表进行测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</span><br><span class="line">  `name` varchar(255) NOT NULL,</span><br><span class="line">  `class` varchar(255) DEFAULT NULL,</span><br><span class="line">  `page` bigint(20) DEFAULT NULL,</span><br><span class="line">  `status` tinyint(3) unsigned NOT NULL COMMENT &apos;状态：0 正常，1 冻结，2 删除&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</span><br></pre></td></tr></table></figure><ul><li>插入数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ;;</span><br><span class="line">    CREATE PROCEDURE insertData()</span><br><span class="line">    BEGIN</span><br><span class="line">        declare i int;</span><br><span class="line">        set i = 1 ;</span><br><span class="line">        WHILE (i &lt; 1000000) DO</span><br><span class="line">            INSERT INTO student(`name`,class,`page`,`status`)</span><br><span class="line">                VALUES(CONCAT(&apos;class_&apos;, i),</span><br><span class="line">                    CONCAT(&apos;class_&apos;, i),</span><br><span class="line">                i, (SELECT FLOOR(RAND() * 2)));</span><br><span class="line">            set i = i + 1;</span><br><span class="line">        END WHILE;</span><br><span class="line">        commit;</span><br><span class="line">END;;</span><br><span class="line">CALL insertData();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Explain-诊断&quot;&gt;&lt;a href=&quot;#Explain-诊断&quot; class=&quot;headerlink&quot; title=&quot;Explain 诊断&quot;&gt;&lt;/a&gt;Explain 诊断&lt;/h1&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="MySQL" scheme="http://blog.caoxl.com/tags/MySQL/"/>
    
      <category term="Explain" scheme="http://blog.caoxl.com/tags/Explain/"/>
    
  </entry>
  
</feed>
