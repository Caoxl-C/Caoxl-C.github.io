<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep It Simple And Stupid</title>
  
  <subtitle>Caoxl-Hexo-caoxl.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.caoxl.com/"/>
  <updated>2020-12-23T02:59:31.581Z</updated>
  <id>http://blog.caoxl.com/</id>
  
  <author>
    <name>CAO XIAN LIANG</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>梁超 作品集</title>
    <link href="http://blog.caoxl.com/2020/12/23/Liangchao-UI-PM-Resume/"/>
    <id>http://blog.caoxl.com/2020/12/23/Liangchao-UI-PM-Resume/</id>
    <published>2020-12-23T02:54:40.000Z</published>
    <updated>2020-12-23T02:59:31.581Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>梁超 2019-2020作品集</p></blockquote><a id="more"></a><p><img src="https://caoxl.oss-cn-shenzhen.aliyuncs.com/%E4%B9%90%E4%B9%90/lc_hd.jpg" alt="作品集"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;梁超 2019-2020作品集&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="caoxl" scheme="http://blog.caoxl.com/categories/caoxl/"/>
    
    
      <category term="梁超" scheme="http://blog.caoxl.com/tags/%E6%A2%81%E8%B6%85/"/>
    
      <category term="UI" scheme="http://blog.caoxl.com/tags/UI/"/>
    
      <category term="产品" scheme="http://blog.caoxl.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>大厂面试题 I</title>
    <link href="http://blog.caoxl.com/2020/11/12/Interview-Questions-For-BAT-I/"/>
    <id>http://blog.caoxl.com/2020/11/12/Interview-Questions-For-BAT-I/</id>
    <published>2020-11-12T02:19:14.000Z</published>
    <updated>2020-11-12T07:36:07.853Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>保持学习, 保持警惕, 居安思危, 走出舒适区.</p></blockquote><a id="more"></a><h1 id="字节一面"><a href="#字节一面" class="headerlink" title="字节一面"></a>字节一面</h1><h2 id="在面对未知的流量暴增，可以预先怎么处理"><a href="#在面对未知的流量暴增，可以预先怎么处理" class="headerlink" title="在面对未知的流量暴增，可以预先怎么处理"></a>在面对未知的流量暴增，可以预先怎么处理</h2><p>如果流量突然飙大，总有一个资源会遇到瓶颈。按照经验大概出问题地方是DB，磁盘IO、CPU、带宽、连接数、内存其中的一个或几个。</p><h3 id="流量暴涨的原因"><a href="#流量暴涨的原因" class="headerlink" title="流量暴涨的原因"></a>流量暴涨的原因</h3><p>一般情况下，引起网站流量暴增大致为以下两种情况</p><ul><li>不可预测流量（网站被恶意刷量；CDN回源抓取数据；合作业务平台调取平台数据等）</li><li>可预测流量（突然爆发的社会热点，营销活动的宣传；）</li></ul><p>不管是可预测流量还是不可预测流量都会表现在带宽和网站整体架构的应对方案上</p><p>如果由于带宽原因引起，由于网站的并发量太高，达到服务器的吞吐极限，导致服务器宕机，这时需要做<strong>临时申请加大带宽，然后负载均衡分流</strong>。</p><p>如果由于外网请求数据库，导致数据库频繁读写，数据库处理能力低，导致大量请求积压；如果是这种情况，就需要优化SQL，存储过程等，如果是请求过大，就要考虑做集群等。</p><p>可预测流量的暴增也会拖慢网页的打开速度，甚至导致网站服务器宕机。要应对正常流量暴增，在流量高峰期到来之前就可以适当的调整，一般针对应用服务器的调整可以防止单点，负载均衡，高可用，增加后端web<br>应用服务器数量，数据库读写分离，分库分表等，防止流量暴增导致服务器挂掉</p><h3 id="防止流量暴涨预备方案"><a href="#防止流量暴涨预备方案" class="headerlink" title="防止流量暴涨预备方案"></a>防止流量暴涨预备方案</h3><h4 id="流量估算"><a href="#流量估算" class="headerlink" title="流量估算"></a>流量估算</h4><blockquote><p>作为一个经验充足的老运维，可以把设计流量<em>3作为系统压力的下限，即实现完了要压测，压测得到的结果要达到设计流量 </em> 3（ <em> 4， </em> 5都可以），比如服务器在IDC机房，在签合同之前就可以说明当流量异常的时候，提供一定的缓冲带宽，如果是云服务器，可以临时加带宽。<br>关键是要给系统留些缓冲。一旦发生了什么，不至于挂的太惨。此时，一般会得到一个带缓存的业务服务系统。考虑到缓存高于后台服务2～3个数量级的性能优势，多撑几倍流量一般不成问题。</p></blockquote><h4 id="降级方案"><a href="#降级方案" class="headerlink" title="降级方案"></a>降级方案</h4><h4 id="限流方案"><a href="#限流方案" class="headerlink" title="限流方案"></a>限流方案</h4><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/dadonggg/p/8651909.html" target="_blank" rel="noopener">如何应对网站流量暴增</a></li></ul><h2 id="如何限流，限流算法，对于ddos攻击怎么处理"><a href="#如何限流，限流算法，对于ddos攻击怎么处理" class="headerlink" title="如何限流，限流算法，对于ddos攻击怎么处理"></a>如何限流，限流算法，对于ddos攻击怎么处理</h2><h3 id="如何限流"><a href="#如何限流" class="headerlink" title="如何限流"></a>如何限流</h3><ul><li>计数器</li><li>滑动窗口</li><li>漏桶</li><li><p>令牌</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/dadonggg/p/8651909.html" target="_blank" rel="noopener">如何应对网站流量暴增</a></p></li></ul><h3 id="ddos处理"><a href="#ddos处理" class="headerlink" title="ddos处理"></a>ddos处理</h3><blockquote><p>遇到1G以下的攻击，使用防火墙就可以搞定（或者使用一些免费的云防御产品）；流量1G—10G时可以选择机房进行流量迁移和清洗；大于10G时使用高防CDN（云防御）是相对最靠谱并且价钱最能接受的。</p></blockquote><ul><li><p><strong>参考</strong>: <a href="https://blog.csdn.net/higeek/article/details/83143897" target="_blank" rel="noopener">一次从遭遇DDoS攻击到解决的亲身经历</a></p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/viter/archive/2018/11/14/9957214.html" target="_blank" rel="noopener">记一次DDOS攻击防御实录</a></p></li></ul><h2 id="PHP数组的底层实现"><a href="#PHP数组的底层实现" class="headerlink" title="PHP数组的底层实现"></a>PHP数组的底层实现</h2><blockquote><p>PHP 数组的底层实现是散列表（也叫 hashTable )，散列表是根据键（Key）直接访问内存存储位置的数据结构，它的key - value 之间存在一个映射函数，可以根据 key 通过映射函数得到的散列值直接索引到对应的 value 值，无需通过关键字比较，在理想情况下，不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O(1)。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://segmentfault.com/a/1190000020175662" target="_blank" rel="noopener">PHP7 数组的底层实现</a></li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。<br>  简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。<br>  本质上来说，分布式事务就是为了保证不同数据库的数据一致性。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://developer.51cto.com/art/201808/581174.htm" target="_blank" rel="noopener">收藏 | 第一次有人把“分布式事务”讲的这么简单明了</a></li></ul><h2 id="RPC相对于传统的API调用的优点"><a href="#RPC相对于传统的API调用的优点" class="headerlink" title="RPC相对于传统的API调用的优点"></a>RPC相对于传统的API调用的优点</h2><p>REST（HTTP-Based）、RPC（Socket-Based）</p><table><thead><tr><th style="text-align:left">接口类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td style="text-align:left">REST</td><td>RESTful API充分利用了HTTP协议的设计,使用了面向资源的接口设计,相对于传统RPC降低了接口设计的复杂度</td><td>RESTful API面向资源设计接口,而对于一些复杂操作来说,接口设计难度将大于RPC形式</td></tr><tr><td style="text-align:left">RPC</td><td>1) 方便使用RPC来调用远程函数,冰得到对应的结果,就像调用本地方法一样 2) 编写分布式应用程序更加简单容易,因为RPC将所有的网络代码都隐藏到了存根函数中,开发人员不必关注通信等细节 3) RPC是跨语言的</td><td>1) 交互方式单一,不能进行复杂多模块之间的协议交互 2) 开发难度,RPC框架肯定高于基于简单HTTP协议的REST接口</td></tr></tbody></table><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/weixin_43185598/article/details/88537824" target="_blank" rel="noopener">Rest和RPC接口区别</a></li></ul><h2 id="服务调度中心的感知与动态上下线"><a href="#服务调度中心的感知与动态上下线" class="headerlink" title="服务调度中心的感知与动态上下线"></a>服务调度中心的感知与动态上下线</h2><ul><li><p>zookeeper</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/dengpengbo/p/10443547.html" target="_blank" rel="noopener">zookeeper实现动态感知服务器上下线</a></p></li><li><strong>参考</strong>: <a href="https://www.cnblogs.com/GodHeng/p/8797100.html" target="_blank" rel="noopener">分布式服务动态上下线感知</a></li></ul><h2 id="MySQL的索引，为什么是B-而不是平衡二叉树"><a href="#MySQL的索引，为什么是B-而不是平衡二叉树" class="headerlink" title="MySQL的索引，为什么是B+而不是平衡二叉树"></a>MySQL的索引，为什么是B+而不是平衡二叉树</h2><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/tiancai/p/9024351.html" target="_blank" rel="noopener">为什么MySQL数据库索引选择使用B+树？</a></li><li><strong>参考</strong>: <a href="https://blog.csdn.net/jacke121/article/details/78268602" target="_blank" rel="noopener">快速理解平衡二叉树、B-tree、B+tree、B*tree</a></li></ul><h2 id="索引查找在Linux的磁盘上是怎么操作的"><a href="#索引查找在Linux的磁盘上是怎么操作的" class="headerlink" title="索引查找在Linux的磁盘上是怎么操作的"></a>索引查找在Linux的磁盘上是怎么操作的</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/qq_38410730/article/details/81416195" target="_blank" rel="noopener">【Linux】Linux根据文件路径查找索引节点</a></li></ul><h2 id="聚簇索引相对于B-索引的优点"><a href="#聚簇索引相对于B-索引的优点" class="headerlink" title="聚簇索引相对于B+索引的优点"></a>聚簇索引相对于B+索引的优点</h2><ul><li><strong>参考</strong>: <a href="https://my.oschina.net/xiaoyoung/blog/3046779" target="_blank" rel="noopener">浅谈聚簇索引和非聚簇索引的区别</a></li></ul><h2 id="如何分析SQL执行慢的原因"><a href="#如何分析SQL执行慢的原因" class="headerlink" title="如何分析SQL执行慢的原因"></a>如何分析SQL执行慢的原因</h2><h2 id="Redis连接时的connect与pconnect的区别"><a href="#Redis连接时的connect与pconnect的区别" class="headerlink" title="Redis连接时的connect与pconnect的区别"></a>Redis连接时的<code>connect</code>与<code>pconnect</code>的区别</h2><ul><li><code>connect</code>：脚本结束之后连接就释放了</li><li><p><code>pconnect</code>：脚本结束之后连接不释放，连接保持在php-fpm进程中。</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/lovebing/p/6250281.html" target="_blank" rel="noopener">Redis中connect与pconnect区别？</a></p></li></ul><h2 id="Redis有哪些结构时间复杂度较高"><a href="#Redis有哪些结构时间复杂度较高" class="headerlink" title="Redis有哪些结构时间复杂度较高"></a>Redis有哪些结构时间复杂度较高</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/andy86869/article/details/88366513" target="_blank" rel="noopener">Redis基础 常用类型 时间复杂度</a></li></ul><h2 id="Redis-hash的实现"><a href="#Redis-hash的实现" class="headerlink" title="Redis hash的实现"></a>Redis hash的实现</h2><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/ourroad/p/4891648.html" target="_blank" rel="noopener">Redis之Hash数据结构</a></li></ul><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2><blockquote><p>在1个10G大小的文件中，存储的都是int型的数据，如何在内存使用小于8M的情况下进行排序</p></blockquote><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/dream-of-cambridge/articles/8042311.html" target="_blank" rel="noopener">归并排序，外排序，10G文件500M内存的排序</a></li><li><strong>参考</strong>: <a href="https://www.cnblogs.com/Vae1990Silence/p/4423450.html" target="_blank" rel="noopener">腾讯面试题：10G 个整数，乱序排列，要求找出中位数。内存限制为 2G。</a></li></ul><h2 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h2><blockquote><p>以微博为例，有1个亿的用户，同时用户之间有关注和粉丝，用户的关注和取关操作比较频繁，如何设计架构和API接口</p></blockquote><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/bigtree_3721/article/details/79779249" target="_blank" rel="noopener">新浪微博技术架构分析和设计</a></li></ul><h1 id="字节二面"><a href="#字节二面" class="headerlink" title="字节二面"></a>字节二面</h1><h2 id="守护进程是什么，怎么实现"><a href="#守护进程是什么，怎么实现" class="headerlink" title="守护进程是什么，怎么实现"></a>守护进程是什么，怎么实现</h2><blockquote><p>守护进程（Daemon）是运行在后台的一种特殊进程，也称为精灵进程。是生存期较长的一种进程，常常在系统自举时启动，仅在系统关闭时终止。没有控制终端，仅仅在后台运行，Linux有很多守护进程执行日常事务活动，是不受终端控制的进程。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/m0_37925202/article/details/80214095" target="_blank" rel="noopener">守护进程详解及其代码实现</a></li></ul><h2 id="PHP是否适合做守护进程，为什么（内存管理这一块）"><a href="#PHP是否适合做守护进程，为什么（内存管理这一块）" class="headerlink" title="PHP是否适合做守护进程，为什么（内存管理这一块）"></a>PHP是否适合做守护进程，为什么（内存管理这一块）</h2><p>不适合,因为PHP本身不是常驻内存</p><h2 id="PHP的垃圾回收机制"><a href="#PHP的垃圾回收机制" class="headerlink" title="PHP的垃圾回收机制"></a>PHP的垃圾回收机制</h2><ul><li><strong>参考</strong>: <a href="https://m.php.cn/topic/php7/425508.html" target="_blank" rel="noopener">php7 垃圾回收机制详解</a></li></ul><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul><li><p>IPC的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC</p></li><li><p><strong>参考</strong>: <a href="https://blog.csdn.net/wm12345645/article/details/82381407" target="_blank" rel="noopener">Liunx 六大进程间通信方式</a></p></li></ul><h2 id="共享内存是怎么实现的"><a href="#共享内存是怎么实现的" class="headerlink" title="共享内存是怎么实现的"></a>共享内存是怎么实现的</h2><blockquote><p>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://www.cnblogs.com/zgq0/p/8780893.html" target="_blank" rel="noopener">进程间的五种通信方式介绍</a></li></ul><h2 id="怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高"><a href="#怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高" class="headerlink" title="怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高"></a>怎么查看Linux服务器的负载，及判断哪些操作引起的负载过高</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/truelove12358/article/details/50502248" target="_blank" rel="noopener">linux 下查看系统资源和负载,以及性能监控</a></li></ul><h2 id="MySQL的IO过高怎么优化，分库分表及分区"><a href="#MySQL的IO过高怎么优化，分库分表及分区" class="headerlink" title="MySQL的IO过高怎么优化，分库分表及分区"></a>MySQL的IO过高怎么优化，分库分表及分区</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/designer01/article/details/82772620" target="_blank" rel="noopener">mysql分区、分表、分库、数据分片</a></li></ul><h2 id="MySQL的索引结构，myisam的索引结构，-innodb的索引结构，innodb为什么必须要有主键索引"><a href="#MySQL的索引结构，myisam的索引结构，-innodb的索引结构，innodb为什么必须要有主键索引" class="headerlink" title="MySQL的索引结构，myisam的索引结构， innodb的索引结构，innodb为什么必须要有主键索引"></a>MySQL的索引结构，myisam的索引结构， innodb的索引结构，innodb为什么必须要有主键索引</h2><ul><li>MyISAM: 使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址</li><li><p>InnoDB: 也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/olinux/p/5217186.html" target="_blank" rel="noopener">MySQL中myisam和innodb的主键索引有什么区别？</a></p></li></ul><h2 id="添加索引，为什么可以减少io操作（磁盘页）"><a href="#添加索引，为什么可以减少io操作（磁盘页）" class="headerlink" title="添加索引，为什么可以减少io操作（磁盘页）"></a>添加索引，为什么可以减少io操作（磁盘页）</h2><blockquote><p>首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。</p></blockquote><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/m0_38128121/article/details/79663261" target="_blank" rel="noopener">数据库添加索引为什么能加快查询速度</a></li></ul><h2 id="nginx的负载均衡算法"><a href="#nginx的负载均衡算法" class="headerlink" title="nginx的负载均衡算法"></a>nginx的负载均衡算法</h2><ul><li><code>round robin(默认)</code>: 轮询方式，依次将请求分配到各个后台服务器中，默认的负载均衡方式。 </li><li><code>weight</code>: 根据权重来分发请求到不同的机器中，指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。  </li><li><code>ip_hash</code>: 根据请求者ip的hash值将请求发送到后台服务器中，可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</li><li><code>url_hash</code>: 根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高。</li><li><p><code>fair</code>: 根据后台响应时间来分发请求，响应时间短的分发的请求多。</p></li><li><p><strong>参考</strong>: <a href="https://www.cnblogs.com/DarrenChan/p/8967412.html" target="_blank" rel="noopener">nginx负载均衡的五种算法</a></p></li></ul><h2 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h2><blockquote><p>查找一个字符串中最长的无重复字串</p></blockquote><h1 id="字节三面"><a href="#字节三面" class="headerlink" title="字节三面"></a>字节三面</h1><h2 id="在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中"><a href="#在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中" class="headerlink" title="在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中"></a>在一个横向和纵向都是递增的有界二维坐标轴中，如何快速判断某个数是否存在于这个二维坐标中</h2><ul><li><strong>参考</strong>: <a href="https://blog.csdn.net/qq_32169593/article/details/80987070" target="_blank" rel="noopener">从一字符串中找出其无重复最长子串字符及长度</a></li></ul><h2 id="设计一个定时任务管理器"><a href="#设计一个定时任务管理器" class="headerlink" title="设计一个定时任务管理器"></a>设计一个定时任务管理器</h2><ul><li><strong>参考</strong>: <a href="https://studygolang.com/articles/9523" target="_blank" rel="noopener">golang实践-如何实现高性能的定时任务管理器</a></li></ul><h1 id="滴滴2020PHP面试题"><a href="#滴滴2020PHP面试题" class="headerlink" title="滴滴2020PHP面试题"></a>滴滴2020PHP面试题</h1><h2 id="处理算法题，最大无重复子串，链表的值交换"><a href="#处理算法题，最大无重复子串，链表的值交换" class="headerlink" title="处理算法题，最大无重复子串，链表的值交换"></a>处理算法题，最大无重复子串，链表的值交换</h2><h2 id="遇到过线上服务器CPU飙高的情况没有，如何处理"><a href="#遇到过线上服务器CPU飙高的情况没有，如何处理" class="headerlink" title="遇到过线上服务器CPU飙高的情况没有，如何处理"></a>遇到过线上服务器CPU飙高的情况没有，如何处理</h2><blockquote><p>登录服务器，执行top命令，查看CPU占用情况；定位线程；定位代码，解决问题</p></blockquote><h2 id="对线程池的理解，项目中哪个地方使用了，如何使用的，用的框架中的哪个实现类，为什么用这个"><a href="#对线程池的理解，项目中哪个地方使用了，如何使用的，用的框架中的哪个实现类，为什么用这个" class="headerlink" title="对线程池的理解，项目中哪个地方使用了，如何使用的，用的框架中的哪个实现类，为什么用这个"></a>对线程池的理解，项目中哪个地方使用了，如何使用的，用的框架中的哪个实现类，为什么用这个</h2><ul><li>1)创建/销毁线程伴随着系统开销，过于频繁的创建/销毁线程，会很大程度上影响处理效率</li><li>2)线程并发数量过多，抢占系统资源从而导致阻塞</li><li>3)对线程进行一些简单的管理, 延时执行 定时循环执行</li></ul><h2 id="对MySQL索引的理解、对组合索引的理解、索引的最佳实践"><a href="#对MySQL索引的理解、对组合索引的理解、索引的最佳实践" class="headerlink" title="对MySQL索引的理解、对组合索引的理解、索引的最佳实践"></a>对MySQL索引的理解、对组合索引的理解、索引的最佳实践</h2><ul><li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li>聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。</li><li>非聚簇索引：不是聚簇索引，就是非聚簇索引</li></ul><h2 id="分布式锁的实现、对比Redis分布式锁-amp-ZK分布式锁"><a href="#分布式锁的实现、对比Redis分布式锁-amp-ZK分布式锁" class="headerlink" title="分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁"></a>分布式锁的实现、对比Redis分布式锁 &amp; ZK分布式锁</h2><ul><li>基于数据库实现；</li><li>基于缓存（Redis等）实现；</li><li>基于Zookeeper实现；</li></ul><h2 id="怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？"><a href="#怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？" class="headerlink" title="怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？"></a>怎么理解微服务，服务如何划分，可以从哪几个方面去划分，为什么这样划分，微服务带来了哪些好处，哪些坏处，如何看待这个问题？</h2><ul><li>服务间调用,服务发现,服务容错,服务部署,数据调用</li></ul><h2 id="如何理解网关，网关带来的好处和坏处，如何解决"><a href="#如何理解网关，网关带来的好处和坏处，如何解决" class="headerlink" title="如何理解网关，网关带来的好处和坏处，如何解决"></a>如何理解网关，网关带来的好处和坏处，如何解决</h2><ul><li>高性能，可横向扩展</li><li>高可靠，业务不中断</li><li>插件化的API安全控制</li><li>灵活的数据编排</li><li>精细化流控</li><li>API版本管理</li><li>API数据分析</li><li>高效插件化路由算法</li><li>安全认证，防攻击</li><li>API访问控制</li><li>Swagger导入导出</li></ul><h2 id="掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式"><a href="#掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式" class="headerlink" title="掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式"></a>掌握哪些设计模式，常用哪些，项目中如何使用的，为什么用这个，不用那个？手写一个线程安全的单例模式</h2><blockquote><p>单例模式，工程模式，注册模式，适配器模式，观察者模式，策略模式</p></blockquote><h2 id="如何设计一个秒杀系统？"><a href="#如何设计一个秒杀系统？" class="headerlink" title="如何设计一个秒杀系统？"></a>如何设计一个秒杀系统？</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>nginx负载均衡，将请求分发到各个服务器，减轻压力。</li><li>js、css压缩，减少流量以及请求次数。</li><li>js、css压缩，减少流量以及请求次数。</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li>采用redis缓存，可以提前将某些秒杀的数据加载到缓存。如库存先加载到缓存，判断缓存里的库存，成功后再继续，同时为了防止大量访问redis，可以用共享变量标识是否卖完，如卖完了，则直接返回，不用访问redis。</li><li>页面缓存，即将页面直接缓存到redis，或者页面静态化，即前后端分离。</li><li>开启浏览器缓存。</li></ul><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><ul><li>使用消息队列，例rabbitmq进行消峰。</li><li>利用验证码防止恶意刷单，可以有效降低单位时间内访问次数。</li><li>地址隐藏，防止知道地址后提前购买以及多刷。</li><li>一定时间内限制url访问次数。</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>利用行级锁，先扣库存，成功后再创建订单，防止超卖。</li><li>唯一索引，防止重复购买。</li><li>数据库读写分离，如mycat。</li></ul><h2 id="假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？"><a href="#假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？" class="headerlink" title="假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？"></a>假设现在双十一零点，大量下单请求，如何对这些订单进行分库分表，为什么？</h2><blockquote><p>分布式ID</p></blockquote><p>将订单数据划分成两大类型：分别是热数据和冷数据。</p><p>热数据：3个月内的订单数据，查询实时性较高。</p><p>冷数据A：3个月 ~ 12个月前的订单数据，查询频率不高。</p><p>冷数据B：1年前的订单数据，几乎不会查询，只有偶尔的查询需求。</p><h2 id="MySQL事务隔离级别、MVCC？"><a href="#MySQL事务隔离级别、MVCC？" class="headerlink" title="MySQL事务隔离级别、MVCC？"></a>MySQL事务隔离级别、MVCC？</h2><ul><li>数据库事务的隔离级别ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</li><li>SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。</li></ul><h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p>分布式架构、高可扩展、高性能、高并发、服务器性能调优、Laravel、TP6、Yii2、Redis、Swoole、Swoft、RabbitMQ、Kafka、Mysql优化、shell脚本、Docker、微服务、Nginx</p><h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><ul><li><a href="https://www.nowcoder.com/discuss/356733?type=2" target="_blank" rel="noopener">字节PHP/Golang社招面经</a></li><li><a href="https://my.oschina.net/u/4178721/blog/4423526" target="_blank" rel="noopener">2020面试题之滴滴后端PHP职位</a></li><li><a href="https://www.php.cn/toutiao-415522.html" target="_blank" rel="noopener">2020腾讯PHP面试题（附答案）</a></li><li><a href="https://www.lagou.com/lgeduarticle/31777.html" target="_blank" rel="noopener">2019腾讯PHP面试题（附答案）</a></li><li><a href="https://gitee.com/OSCYuanChuangHui/2018_lecturer_ppt/raw/master/2019.12.15%20%E6%B7%B1%E5%9C%B3%E5%B9%B4%E7%BB%88%E7%9B%9B%E5%85%B8/%E4%B8%BB%E4%BC%9A%E5%9C%BA/3.%202020%20%E5%B9%B4%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%20PHP%E2%80%94%E2%80%94%E9%9F%A9%E5%A4%A9%E5%B3%B0.pdf" target="_blank" rel="noopener">2020 年如何正确使用 PHP——韩天峰</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;保持学习, 保持警惕, 居安思危, 走出舒适区.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>PHP单元测试 (一) 基础</title>
    <link href="http://blog.caoxl.com/2020/10/29/PHP-Unit-I-Basic/"/>
    <id>http://blog.caoxl.com/2020/10/29/PHP-Unit-I-Basic/</id>
    <published>2020-10-29T06:12:49.000Z</published>
    <updated>2020-10-29T09:02:02.918Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。</p></blockquote><a id="more"></a><h1 id="测试DEMO"><a href="#测试DEMO" class="headerlink" title="测试DEMO"></a>测试DEMO</h1><ul><li><code>Transfer.php</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Controller</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">Transfer</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $accountA = <span class="number">100</span>;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $accountB = <span class="number">100</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">aToB</span><span class="params">(int $money)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;accountA -= $money;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;accountB += $money;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bToA</span><span class="params">(int $money)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;accountB -= $money;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;accountA += $money;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAccountA</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;accountA;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAccountB</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;accountB;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>TransferTest.php</code></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">Controller</span>\<span class="title">Transfer</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">TransferTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">private</span> $transferObj;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setUp</span><span class="params">()</span> : <span class="title">void</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;transferObj = <span class="keyword">new</span> Transfer();</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testAtoB</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $originalA = <span class="keyword">$this</span>-&gt;transferObj-&gt;getAccountA();</span></span><br><span class="line"><span class="php">        $originalB = <span class="keyword">$this</span>-&gt;transferObj-&gt;getAccountB();</span></span><br><span class="line"></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;transferObj-&gt;aToB(<span class="number">10</span>);</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;assertEquals($originalA - <span class="number">10</span>, <span class="keyword">$this</span>-&gt;transferObj-&gt;getAccountA());</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;assertEquals($originalB + <span class="number">10</span>, <span class="keyword">$this</span>-&gt;transferObj-&gt;getAccountB());</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>执行测试:</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHPUnit 9.5-gd3b55c36f by Sebastian Bergmann and contributors.</span><br><span class="line"></span><br><span class="line">.                                                                   1 / 1 (100%)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Time:</span> 00:00.029, Memory: 8.00 MB</span><br><span class="line"></span><br><span class="line">OK (1 test, 2 assertions)</span><br></pre></td></tr></table></figure><h1 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h1><h2 id="基境"><a href="#基境" class="headerlink" title="基境"></a>基境</h2><blockquote><p><a href="https://phpunit.readthedocs.io/en/9.3/fixtures.html" target="_blank" rel="noopener">https://phpunit.readthedocs.io/en/9.3/fixtures.html</a></p></blockquote><p>PHPUnit 支持共享建立基境的代码。</p><p>提供了以下几个模板方法：</p><ul><li><code>setUpBeforeClass</code>: 测试用例类的第一个测试运行之前执行</li><li><code>tearDownAfterClass</code>:  测试用例类的最后一个测试运行之后执行</li><li><code>setUp</code>: 每个测试方法运行之前执行</li><li><code>tearDown</code>: 每个测试方法运行之后执行</li></ul><p><strong>注意：每个测试方法都是在一个全新的测试类实例上运行的</strong></p><h3 id="全局状态"><a href="#全局状态" class="headerlink" title="全局状态"></a>全局状态</h3><blockquote><p><a href="https://phpunit.readthedocs.io/en/9.3/fixtures.html#global-state" target="_blank" rel="noopener">https://phpunit.readthedocs.io/en/9.3/fixtures.html#global-state</a></p></blockquote><ul><li>全局变量：有时候测试代码中用到了全局变量（$_GLOBALS），但是如果对这里面的变量进行了修改，可能会导致其他测试方法出现问题，那么怎么保证每个测试方法都使用的是一样的全局变量呢？ 通过：<code>@backupGlobals disabled|enabled</code> 它可标注在：<ul><li>测试类: 作用范围为整个测试类</li><li>测试方法: 作用范围为这个方法</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</span></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @backupGlobals disabled</span><br><span class="line"><span class="php"> */</span></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line">    /**</span><br><span class="line">     * @backupGlobals enabled</span><br><span class="line"><span class="php">     */</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testThatInteractsWithGlobalVariables</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><p>支持设置 “全局变量黑名单” 黑名单中的全局变量将被排除于备份与还原操作之外：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @backupGlobals disabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $backupGlobalsBlacklist = [<span class="symbol">'globalVariabl</span>e'];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @backupGlobals enabled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public function testThatInteractsWithGlobalVariables()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于全局变量的备份和还原的原理是使用了：<code>serialize()</code> 与 <code>unserialize()</code>。</p><ul><li><p><strong>注意</strong>：</p><ul><li>对于无法被序列化的对象放入 <code>$GLOBALS</code> 数组内时，备份操作就会出问题。比如：<code>PDO</code></li><li>在方法（例如 <code>setUp()</code>）内对 <code>$backupGlobalsBlacklist</code> 属性进行设置是无效的</li></ul></li><li><p>类的静态属性 。对于类的静态属性的备份和还原可以通过：<code>@backupStaticAttributes enabled|disabled</code><br>作用对象：在测试开始时已声明的所有类（而不仅是测试类自身），且只作用于静态类属性，不作用于函数内声明的静态变量。<br>使用位置和 <code>backupGlobals</code> 一致：</p><ul><li>测试类</li><li>测试方法<br>只有启用了 <code>@backupStaticAttributes</code> 的测试方法才会在方法之前执行此操作。如果在此之前运行的某个没有启用 <code>@backupStaticAttributes</code> 的测试方法改变了静态属性的值，那么被备份及还原的将会是这个改变后的值</li></ul></li></ul><p>同样提供了黑名单支持：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $backupStaticAttributesBlacklist = [</span><br><span class="line">      <span class="symbol">'classNam</span>e' =&gt; [<span class="symbol">'attributeNam</span>e']</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>使用 <code>@depends</code> 声明测试方法所依赖的其他测试方法。 依赖方法的返回值，会作为被依赖方法的参数，其顺序和 <code>@depends</code> 的顺序一致，但是不会影响代码的执行顺序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"depends1"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"depends2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@depends</span> testOne</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@depends</span> testTwo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testDepends</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertEquals([<span class="string">'depends1'</span>, <span class="string">'depends2'</span>], func_get_args());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Time:</span> 00:00.315, Memory: 6.00 MB</span><br><span class="line"></span><br><span class="line">OK (3 tests, 3 assertions)</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：<ul><li>当被依赖的测试方法失败时，不会再执行依赖方法的测试。</li><li>如果被依赖方法返回的是对象，默认是引用传递，如果希望传递对象的副本时，使用： <code>@depends clone</code></li></ul></li></ul><h2 id="数据供给器"><a href="#数据供给器" class="headerlink" title="数据供给器"></a>数据供给器</h2><p>使用 <code>@dataProvider</code> 声明数据供给器。 对应的方法需要返回：</p><ul><li>数组（每个元素也是数组）</li><li>可遍历的对象（实现了迭代接口）</li></ul><p>然后测试时，会将每次迭代器提供的一组数据进行测试，直到全部遍历完毕。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> $sum</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@dataProvider</span> additionProvider</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testSum</span><span class="params">($a, $b, $sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertEquals($sum, $a + $b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">additionProvider</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Failed</span> <span class="string">asserting</span> <span class="string">that</span> <span class="number">2</span> <span class="string">matches</span> <span class="string">expected</span> <span class="number">3</span><span class="string">.</span></span><br><span class="line"><span class="string">Expected</span> <span class="string">:3</span></span><br><span class="line"><span class="string">Actual</span>   <span class="string">:2</span></span><br><span class="line"><span class="string">&lt;Click</span> <span class="string">to</span> <span class="string">see</span> <span class="string">difference&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="string">/Users/caoxl/WWW/test.com/tests/MyTest.php:56</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Time:</span> <span class="number">00</span><span class="string">:00.403,</span> <span class="attr">Memory:</span> <span class="number">8.00</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">FAILURES!</span></span><br><span class="line"><span class="attr">Tests:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Assertions:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Failures:</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure><ul><li>注意:<ul><li>和 <code>@depends</code> 同时使用时，<code>@provider</code> 提供的参数会优先于 <code>@depends</code> 提供的参数，并且，依赖关系提供的参数不会变化。</li></ul></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Depends1'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@depends</span> testOne</span></span><br><span class="line"><span class="comment">* <span class="doctag">@dataProvider</span> additionProvider</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testSum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertEquals([<span class="string">'Provider1'</span>, <span class="string">'Depends1'</span>], func_get_args());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//会测试两次，第一此传递：Provider1，第二次传递：Provider2</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">additionProvider</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      [<span class="string">'Provider1'</span>],</span><br><span class="line">      [<span class="string">'Provider2'</span>],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PHPUnit</span> <span class="number">9.5</span><span class="string">-gd3b55c36f</span> <span class="string">by</span> <span class="string">Sebastian</span> <span class="string">Bergmann</span> <span class="string">and</span> <span class="string">contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="string">Failed</span> <span class="string">asserting</span> <span class="string">that</span> <span class="string">two</span> <span class="string">arrays</span> <span class="string">are</span> <span class="string">equal.</span></span><br><span class="line"><span class="string">&lt;Click</span> <span class="string">to</span> <span class="string">see</span> <span class="string">difference&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="string">/Users/caoxl/WWW/test.com/tests/MyTest.php:57</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Time:</span> <span class="number">00</span><span class="string">:00.378,</span> <span class="attr">Memory:</span> <span class="number">8.00</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">FAILURES!</span></span><br><span class="line"><span class="attr">Tests:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Assertions:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Failures:</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure><h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>异常测试有两种方式：</p><ul><li>在代码中使用: <code>$this-&gt;expectException(InvalidArgumentException::class);</code></li><li>使用标注：<code>@expectException</code></li></ul><p>断言方法/标注：</p><ul><li><code>expectException</code></li><li><code>expectExceptionCode</code></li><li><code>expectExceptionMessage</code></li><li><code>expectExceptionMessageRegExp</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testException1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectException(InvalidArgumentException::class);</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectExceptionMessage(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@expectedException</span> InvalidArgumentException</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@expectedExceptionMessage</span> hi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testException2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidArgumentException(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不允许对 ：<code>Exception</code> 类进行测试，异常类越明确越好。</p><h2 id="错误调试"><a href="#错误调试" class="headerlink" title="错误调试"></a>错误调试</h2><p>默认情况下，在测试过程中如果触发到了 <code>PHP</code> 的错误/警告，<code>PHPUnit</code> 会将其转换为异常：</p><ul><li><code>PHPUnit\Framework\Error\Notice</code></li><li><code>PHPUnit\Framework\Error\Warning</code></li><li><code>PHPUnit\Framework\Error\Error</code></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectException(Error::class);</span><br><span class="line">    <span class="comment">// 触发一个错误</span></span><br><span class="line">    <span class="keyword">include</span> <span class="string">'file_not_existing_file.php'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果:</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Time:</span> 00:00.319, Memory: 8.00 MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FAILURES!</span><br><span class="line">Tests: 1, Assertions: 1, Failures: 1.</span><br></pre></td></tr></table></figure><h2 id="输出内容测试"><a href="#输出内容测试" class="headerlink" title="输出内容测试"></a>输出内容测试</h2><p>有时候，想要断言 某方法的运行过程中生成了预期的输出（例如，通过 <code>echo</code> 或 <code>print</code>）。<code>PHPUnit\Framework\TestCase</code> 类使用 PHP 的 输出缓冲 特性来为此提供必要的功能支持。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOutput1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectOutputString(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testOutput2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;expectOutputRegex(<span class="string">"/\d+/"</span>);</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// testOutput2</span><br><span class="line">Failed asserting that 'Hello World' matches PCRE pattern "/\d+/".</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">Time:</span> 00:00.368, Memory: 8.00 MB</span><br><span class="line"></span><br><span class="line">FAILURES!</span><br><span class="line">Tests: 1, Assertions: 1, Failures: 1.</span><br></pre></td></tr></table></figure><h2 id="标记未完成-与-跳过"><a href="#标记未完成-与-跳过" class="headerlink" title="标记未完成 与 跳过"></a>标记未完成 与 跳过</h2><ul><li>标记未完成</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testMark</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;assertTrue(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 在这里停止</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;markTestIncomplete(<span class="string">"后续还未完成"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PHPUnit</span> <span class="number">9.5</span><span class="string">-gd3b55c36f</span> <span class="string">by</span> <span class="string">Sebastian</span> <span class="string">Bergmann</span> <span class="string">and</span> <span class="string">contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="string">后续还未完成</span></span><br><span class="line"></span><br><span class="line"> <span class="string">/Users/caoxl/WWW/test.com/tests/MyTest.php:114</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">Time:</span> <span class="number">00</span><span class="string">:00.393,</span> <span class="attr">Memory:</span> <span class="number">8.00</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line"><span class="string">OK,</span> <span class="string">but</span> <span class="string">incomplete,</span> <span class="string">skipped,</span> <span class="string">or</span> <span class="string">risky</span> <span class="string">tests!</span></span><br><span class="line"><span class="attr">Tests:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Assertions:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Incomplete:</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure><ul><li>跳过测试</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setUp</span><span class="params">()</span>: void</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!extension_loaded(<span class="string">'mysqli'</span>)) &#123;</span><br><span class="line">        $<span class="keyword">this</span>-&gt;markTestSkipped(<span class="string">"MySQLi 扩展不可用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">PHPUnit</span> <span class="number">9.5</span><span class="string">-gd3b55c36f</span> <span class="string">by</span> <span class="string">Sebastian</span> <span class="string">Bergmann</span> <span class="string">and</span> <span class="string">contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="string">MySQLi</span> <span class="string">扩展不可用</span></span><br><span class="line"></span><br><span class="line"> <span class="string">/Users/caoxl/WWW/test.com/tests/MyTest.php:24</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Time:</span> <span class="number">00</span><span class="string">:00.425,</span> <span class="attr">Memory:</span> <span class="number">8.00</span> <span class="string">MB</span></span><br><span class="line"></span><br><span class="line"><span class="string">OK,</span> <span class="string">but</span> <span class="string">incomplete,</span> <span class="string">skipped,</span> <span class="string">or</span> <span class="string">risky</span> <span class="string">tests!</span></span><br><span class="line"><span class="attr">Tests:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Assertions:</span> <span class="number">0</span><span class="string">,</span> <span class="attr">Skipped:</span> <span class="number">1</span><span class="string">.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHPUnit" scheme="http://blog.caoxl.com/tags/PHPUnit/"/>
    
      <category term="单元测试" scheme="http://blog.caoxl.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP 单元测试</title>
    <link href="http://blog.caoxl.com/2020/10/27/PHP-Unit-Test/"/>
    <id>http://blog.caoxl.com/2020/10/27/PHP-Unit-Test/</id>
    <published>2020-10-27T08:30:20.000Z</published>
    <updated>2020-10-27T08:47:00.729Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>朋友，你听说过安。。。不是，写过单元测试吗。</p><p>单元测试是开发过程中必不可少的一环，一个项目有良好的单元测试代码，重构的勇气都大很多。这次写一篇小文来介绍一下 PHP 的单元测试工具 PHPUnit 的使用。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装 PHPUnit 的方式很简单，使用 composer 可以一行代码就可以安装。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require --dev phpunit/phpunit</span><br></pre></td></tr></table></figure><p>安装之后，在 <code>vendor/bin</code> 目录下有一个 <code>phpunit</code> 的可执行文件，这个就是 <code>phpunit</code> 本体了</p><p>假设我们项目的目录结构如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  phpunit tree .</span><br><span class="line"></span><br><span class="line">├── controller</span><br><span class="line">├── model</span><br><span class="line">├── service</span><br><span class="line">├── test</span><br><span class="line">└── vendor</span><br><span class="line">├── composer.json</span><br></pre></td></tr></table></figure><p>其中我们的单元测试代码都放在 test 目录下。使用 composer 来为我们解决 autoload 的问题</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"autoload"</span>: &#123;</span><br><span class="line">    <span class="attr">"psr-4"</span>: &#123;</span><br><span class="line">      <span class="attr">"Controller\\"</span>: <span class="string">"controller/"</span>,</span><br><span class="line">      <span class="attr">"Model\\"</span>: <span class="string">"model/"</span>,</span><br><span class="line">      <span class="attr">"Service\\"</span>: <span class="string">"service/"</span>,</span><br><span class="line">      <span class="attr">"Test\\"</span>: <span class="string">"test/"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>好了，假设我们现在进行开发，在 service 目录中添加了一个 CalculateService 的文件，并且编写了一个 abs 的函数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Service</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">CalculateService</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">abs</span><span class="params">($num)</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">return</span> abs($num);</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><p>现在我们对 abs 函数进行单元测试，PHPUnit 规定了一个测试类必须遵守如下的规定：</p><ul><li>单元测试类名必须以 <code>Test</code> 结尾，必须继承 <code>\PHPUnit\Framework\TestCase</code> 基类。</li><li>每个测试函数必须以 <code>test</code> 开头。</li></ul><p>上面的规定是必须遵守的，如果代码没有遵守规定 PHPUnit 不会把他当做单元测试代码。除了以上的两条，还有一些良好的编码习惯可以参考：</p><ul><li>单元测试代码都放在 <code>test</code> 目录下。</li><li>每个单元测试类以被测试的类名开头。例如被测试类为 <code>CalculateService</code>，那么单元测试类应该为 <code>CalculateServiceTest</code>。</li><li>每个单元测试函数应该为被测试函数名结尾。例如被测试函数为 <code>abs</code>，那么单元测试函数应该为 <code>testAbs</code>。</li></ul><p>根据上面的规范，编写单元测试代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">namespace</span> <span class="title">Test</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">Service</span>\<span class="title">CalculateService</span>;</span></span><br><span class="line"><span class="php"><span class="keyword">use</span> <span class="title">PHPUnit</span>\<span class="title">Framework</span>\<span class="title">TestCase</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="php"><span class="class"><span class="keyword">class</span> <span class="title">CalculateServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span></span></span></span><br><span class="line"><span class="php">&#123;</span></span><br><span class="line"><span class="php">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testAbs</span><span class="params">()</span></span></span></span><br><span class="line"><span class="php">    &#123;</span></span><br><span class="line"><span class="php">        $calculateService = <span class="keyword">new</span> CalculateService();</span></span><br><span class="line"><span class="php">        <span class="keyword">$this</span>-&gt;assertEquals(<span class="number">4</span>, $calculateService-&gt;abs(<span class="number">4</span>));</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure><p>在上面的测试代码中，调用了我们要测试的函数 <code>abs</code>，然后断言 <code>$calculateService-&gt;abs(4)</code> 的结果为 <code>4</code>。在 phpstorm 中直接在 <code>testAbs</code> 函数处右键选择 <code>run CalculateServiceTest</code> 执行：</p><p>发现在控制台会输出如下内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time: <span class="number">00</span>:<span class="number">00.068</span>, Memory: <span class="number">6.00</span> MB</span><br><span class="line"> </span><br><span class="line">OK (<span class="number">1</span> test, <span class="number">1</span> assertion)</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>表明 <code>abs</code> 通过了 <code>$calculateService-&gt;abs(4) == 4</code> 的测试用例。<strong>这里注意一点，这里并不表明 abs 函数已经通过测试，一个良好的测试应该包含多个测试用例来覆盖尽可能多的可能性</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;朋友，你听说过安。。。不是，写过单元测试吗。&lt;/p&gt;
&lt;p&gt;单元测试是开发过程中必不可少的一环，一个项目有良好的单元测试代码，重构的勇气都大很多。这次写一篇小文来介绍一下 PHP 的单元测试工具 PHPUnit 的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.caoxl.com/tags/PHP/"/>
    
      <category term="单元测试" scheme="http://blog.caoxl.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>做一顿饭来理解协程</title>
    <link href="http://blog.caoxl.com/2020/10/26/Learn-Swoole-Coroutine/"/>
    <id>http://blog.caoxl.com/2020/10/26/Learn-Swoole-Coroutine/</id>
    <published>2020-10-26T07:06:04.000Z</published>
    <updated>2020-10-26T07:15:10.915Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><blockquote><p>协程可以简单理解为线程，只不过这个线程是用户态的，不需要操作系统参与，创建销毁和切换的成本非常低，和线程不同的是协程没法利用多核 cpu 的，想利用多核 cpu 需要依赖 <code>Swoole</code> 的多进程模型。—— swoole 协程一章</p></blockquote><a id="more"></a><h1 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h1><p>可以把协程看成一道小学数学的一道题目：“合理安排时间”，来我们先做一道题目：</p><blockquote><p>小明下班后回家煮饭，煲汤需要 10 分钟，煮饭需要 8 分钟， 炒菜需要 5 分钟，，请问小明最少需要多少分钟能煮好饭？</p></blockquote><blockquote><p>下面用 <code>sleep()</code> 模拟 IO 操作</p></blockquote><h1 id="同步版煮饭"><a href="#同步版煮饭" class="headerlink" title="同步版煮饭"></a>同步版煮饭</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncCook</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cook</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $startTime = time();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"开始煲汤..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"汤好了..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"开始煮饭..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"饭熟了..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"放油..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"煎鱼..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"放盐..."</span> . PHP_EOL;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"出锅..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">        var_dump(<span class="string">'总耗时：'</span> . (time() - $startTime) . <span class="string">' 分钟'</span>);<span class="keyword">die</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$sync = <span class="keyword">new</span> SyncCook();</span><br><span class="line">$sync-&gt;cook();</span><br></pre></td></tr></table></figure><blockquote><p>总耗时：23 分钟</p></blockquote><p>代码很容易看懂，等待汤煮好之后再煮饭，然后再等待饭煮好再炒菜，生活中不会这样操作吧？这就要引入协程来解决这个问题了。</p><h1 id="协程版煮饭"><a href="#协程版煮饭" class="headerlink" title="协程版煮饭"></a>协程版煮饭</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Swoole</span>\<span class="title">Coroutine</span>\<span class="title">WaitGroup</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SwooleCook</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">cook</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $startTime = time();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启一键协程化: https://wiki.swoole.com/#/runtime?id=swoole_hook_all</span></span><br><span class="line">        Swoole\Runtime::enableCoroutine($flags = SWOOLE_HOOK_ALL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个协程容器: https://wiki.swoole.com/#/coroutine/scheduler</span></span><br><span class="line">        <span class="comment">// 相当于进入厨房</span></span><br><span class="line">        Co\run(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 等待结果: https://wiki.swoole.com/#/coroutine/wait_group?id=waitgroup</span></span><br><span class="line">            <span class="comment">// 记录哪道菜做好了，哪道菜还需要多长时间</span></span><br><span class="line">            $wg = <span class="keyword">new</span> WaitGroup();</span><br><span class="line">            <span class="comment">// 保存数据的结果</span></span><br><span class="line">            <span class="comment">// 装好的菜</span></span><br><span class="line">            $result = [];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一下煲汤(记录一个任务)</span></span><br><span class="line">            $wg-&gt;add();</span><br><span class="line">            <span class="comment">// 创建一个煲汤任务(开启一个新的协程)</span></span><br><span class="line">            Coroutine::create(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($wg, &amp;$result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"开始煲汤..."</span> . PHP_EOL;</span><br><span class="line">                <span class="comment">// 煲汤需要6分钟，所以我们也不用在这里等汤煮好，</span></span><br><span class="line">                <span class="comment">// 直接去做下一个任务：炒菜(协程切换)</span></span><br><span class="line">                sleep(<span class="number">8</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"汤好了..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 装盘</span></span><br><span class="line">                $result[<span class="string">'soup'</span>] = <span class="string">'一锅汤'</span>;</span><br><span class="line">                $wg-&gt;done(); <span class="comment">// 标记任务完成</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一下煮饭(记录一个任务)</span></span><br><span class="line">            $wg-&gt;add();</span><br><span class="line">            <span class="comment">// 创建一个煮饭任务(开启一个新的协程)</span></span><br><span class="line">            Coroutine::create(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($wg, &amp;$result)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"开始煮饭..."</span> . PHP_EOL;</span><br><span class="line">                <span class="comment">// 煮饭需要5分钟，所以我们不用在这里等饭煮熟，放在这里一会再来看看好了没有</span></span><br><span class="line">                <span class="comment">// 我们先去煲汤(协程切换)</span></span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"饭熟了..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 装盘</span></span><br><span class="line">                $result[<span class="string">'rice'</span>] = <span class="string">'一锅米饭'</span>;</span><br><span class="line">                $wg-&gt;done(); <span class="comment">// 标记任务完成</span></span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录一下炒菜</span></span><br><span class="line">            $wg-&gt;add();</span><br><span class="line">            <span class="comment">// 创建一个炒菜任务(再开启一个新的协程)</span></span><br><span class="line">            Coroutine::create(<span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($wg, &amp;$result)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 煎鱼的过程必须放在一个协程里面执行，如果不是的话可能鱼还没煎好就出锅了</span></span><br><span class="line">                <span class="comment">// 因为开启协程后，IO全是异步了，在此demo中每次遇到sleep都会挂起当前协程</span></span><br><span class="line">                <span class="comment">// 切换到下一个协程执行。</span></span><br><span class="line">                <span class="comment">// 例如把出锅这一步开启一个新协程执行，则在煎鱼的时候鱼，鱼就出锅了。</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"放油..."</span> . PHP_EOL;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"煎鱼..."</span> . PHP_EOL;</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"放盐..."</span> . PHP_EOL;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"出锅..."</span> . PHP_EOL;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 装盘</span></span><br><span class="line">                $result[<span class="string">'food'</span>] = <span class="string">'鱼香肉丝'</span>;</span><br><span class="line">                $wg-&gt;done();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待全部任务完成</span></span><br><span class="line">            $wg-&gt;wait();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回数据(上菜！)</span></span><br><span class="line">            var_dump($result);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        var_dump(<span class="string">'总耗时：'</span> . (time() - $startTime) . <span class="string">' 分钟'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$swoole = <span class="keyword">new</span> SwooleCook();</span><br><span class="line">$swoole-&gt;cook();</span><br></pre></td></tr></table></figure><blockquote><p>总耗时：10 分钟</p></blockquote><p>答：小明最少需要 10 分钟能煮好饭。</p><ul><li><a href="https://learnku.com/articles/44836" target="_blank" rel="noopener">原文地址: https://learnku.com/articles/44836</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;协程可以简单理解为线程，只不过这个线程是用户态的，不需要操作系统参与，创建销毁和切换的成本非常低，和线程不同的是协程没法利用多核 cpu 的，想利用多核 cpu 需要依赖 &lt;code&gt;Swoole&lt;/code&gt; 的多进程模型。—— swoole 协程一章&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Swoole" scheme="http://blog.caoxl.com/categories/Swoole/"/>
    
    
      <category term="Swoole" scheme="http://blog.caoxl.com/tags/Swoole/"/>
    
      <category term="协程" scheme="http://blog.caoxl.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
      <category term="Coroutine" scheme="http://blog.caoxl.com/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>PHP与Go的语法对比</title>
    <link href="http://blog.caoxl.com/2020/10/26/PHP-vs-Go-Syntax-Comparison/"/>
    <id>http://blog.caoxl.com/2020/10/26/PHP-vs-Go-Syntax-Comparison/</id>
    <published>2020-10-26T03:01:10.000Z</published>
    <updated>2020-10-26T03:50:31.229Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>PHP</code> 是一种动态类型语言，它使新手更容易编写代码。现在的问题是，PHP 开发人员能否从动态类型语言切换到像 Go 这样的静态类型语言？为了找到答案，让我们对比一下 Go 和 PHP 之间的语法差异。</p><p><code>Go</code> 是由 Google 设计的一门静态类型的编译型语言。它有点类似于 C，但是它包含了更多的优点，比如垃圾回收、内存安全、结构类型和并发性。它的并发机制使多核和网络机器能够发挥最大的作用。这是 GoLang 的最佳卖点之一。此外，Go 速度快，表现力强，干净且高效。这也是 Go 如此吸引开发者学习的原因。</p><a id="more"></a><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ul><li><code>Go</code> 同时支持有符号和无符号整数，而 <code>PHP</code> 只支持有符号整数。</li><li>另一个主要区别是数组。<code>Go</code> 对 <code>array</code> 和 <code>map</code> 有单独的类型，而 <code>PHP</code> 数组实际上是有序的 <code>map</code>。</li><li><code>Go</code> 与 <code>PHP</code> 相比没有对象。但是，Go 有一个类似于 <code>object</code> 的 <code>struct</code> 类型。</li></ul><h2 id="PHP-数据类型"><a href="#PHP-数据类型" class="headerlink" title="PHP 数据类型:"></a>PHP 数据类型:</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">boolean</span><br><span class="line">string</span><br><span class="line">integer // Signed integer, PHP does<span class="built_in"> not </span>support unsigned integers.</span><br><span class="line">float (also known as <span class="string">"floats"</span>, <span class="string">"doubles"</span>,<span class="built_in"> or </span><span class="string">"real numbers"</span>)</span><br><span class="line">array</span><br><span class="line">object</span><br><span class="line">null</span><br><span class="line">resource</span><br></pre></td></tr></table></figure><h2 id="Go-数据类型"><a href="#Go-数据类型" class="headerlink" title="Go 数据类型:"></a>Go 数据类型:</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span> <span class="comment">// Signed integer</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span> <span class="comment">// Unsigned integers</span></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// alias for uint8</span></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// alias for int32</span></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br><span class="line">array</span><br><span class="line">slices</span><br><span class="line"><span class="keyword">map</span></span><br><span class="line"><span class="keyword">struct</span></span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>Go 使用 <code>var</code> 声明全局变量和函数变量。但是，它也支持带有初始化程序的简写语法，但只能在函数内部使用。另一方面，PHP 仅支持带有初始化程序的变量声明。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="comment">// Go               // PHP</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">i</span> int           <span class="variable">$i</span> = <span class="number">0</span>      <span class="comment">// integer</span></span><br><span class="line"><span class="selector-tag">var</span> f float64       <span class="variable">$f</span> = <span class="number">0.0</span>    <span class="comment">// float</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> bool          <span class="variable">$b</span> = false  <span class="comment">// boolean</span></span><br><span class="line"><span class="selector-tag">var</span> s string        <span class="variable">$s</span> = <span class="string">""</span>     <span class="comment">// string</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> [<span class="number">2</span>]string     <span class="variable">$a</span> = []     <span class="comment">// array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简短的变量声明</span></span><br><span class="line"><span class="comment">// Go                      // PHP</span></span><br><span class="line"><span class="selector-tag">i</span> := <span class="number">0</span>                     <span class="variable">$i</span> = <span class="number">0</span>      <span class="comment">// integer</span></span><br><span class="line">f := <span class="number">0.0</span>                   <span class="variable">$f</span> = <span class="number">0.0</span>    <span class="comment">// float</span></span><br><span class="line"><span class="selector-tag">b</span> := false                 <span class="variable">$b</span> = false  <span class="comment">// boolean</span></span><br><span class="line">s := <span class="string">""</span>                    <span class="variable">$s</span> = <span class="string">""</span>     <span class="comment">// string</span></span><br><span class="line"><span class="selector-tag">a</span> := [<span class="number">1</span>]string&#123;<span class="string">"hello"</span>&#125;    <span class="variable">$a</span> = []     <span class="comment">// array</span></span><br></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">42</span>             <span class="comment">// Signed integer</span></span><br><span class="line">f := <span class="keyword">float64</span>(i)     <span class="comment">// Float</span></span><br><span class="line">u := <span class="keyword">uint</span>(f)        <span class="comment">// Unsigned integer</span></span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$i = <span class="number">1</span>;</span><br><span class="line">$f = (<span class="keyword">float</span>) $i;    <span class="comment">// 1.0</span></span><br><span class="line">$b = (bool) $f      <span class="comment">// true</span></span><br><span class="line">$s = (<span class="keyword">string</span>) $b    <span class="comment">// "1"</span></span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ul><li>Go</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> [<span class="number">2</span>]string</span><br><span class="line"><span class="selector-tag">a</span>[<span class="number">0</span>] = <span class="string">"Hello"</span></span><br><span class="line"><span class="selector-tag">a</span>[<span class="number">1</span>] = <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="selector-tag">a</span> := [<span class="number">2</span>]string&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line">$a = [</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    <span class="string">"world"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h1><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"first_name"</span>: <span class="string">"Foo"</span>,</span><br><span class="line">    <span class="string">"last_name"</span>: <span class="string">"Bar"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line">$m = [</span><br><span class="line">    <span class="string">"first_name"</span> =&gt; <span class="string">"Foo"</span>,</span><br><span class="line">    <span class="string">"last_name"</span> =&gt; <span class="string">"Bar"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h1 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h1><p>Go 不支持对象。但是，您可以使用 <code>structs</code> 实现 <code>object</code> 之类的语法。</p><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Address <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    person := Person&#123;<span class="string">"Foo bar"</span>, <span class="string">"Sydney, Australia"</span>&#125;</span><br><span class="line">    fmt.Println(person.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line">$person = <span class="keyword">new</span> stdClass;</span><br><span class="line">$person-&gt;Name = <span class="string">"Foo bar"</span>;</span><br><span class="line">$person-&gt;Address = <span class="string">"Sydney, Australia"</span>;</span><br><span class="line"><span class="keyword">echo</span> $person-&gt;Name;</span><br><span class="line"><span class="comment">// 或使用类型转换</span></span><br><span class="line">$person = (object) [</span><br><span class="line">    <span class="string">'Name'</span> =&gt; <span class="string">"Foo bar"</span>,</span><br><span class="line">    <span class="string">'Address'</span> =&gt; <span class="string">"Sydney, Australia"</span></span><br><span class="line">];</span><br><span class="line"><span class="keyword">echo</span> $person-&gt;Name;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go 和 PHP 函数之间的主要区别是； <strong>Go 函数可以返回任意数量的结果，而 PHP 函数只能返回一个结果。</strong> 但是，PHP 可以通过返回数组来模拟相同的功能。</p><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullname</span><span class="params">(firstName <span class="keyword">string</span>, lastName <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := fullname(<span class="string">"Foo"</span>, <span class="string">"Bar"</span>)</span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fullname</span><span class="params">(string $firstName, string $lastName)</span> : <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $firstName . <span class="string">" "</span> . $lastName;</span><br><span class="line">&#125;</span><br><span class="line">$name = fullname(<span class="string">"Foo"</span>, <span class="string">"Bar"</span>);</span><br><span class="line"><span class="keyword">echo</span> $name;</span><br></pre></td></tr></table></figure><h2 id="返回多个结果"><a href="#返回多个结果" class="headerlink" title="返回多个结果"></a>返回多个结果</h2><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := swap(<span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line"><span class="comment">// 返回一个数组以获得多个结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(string $x, string $y)</span>: <span class="title">array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [$y, $x];</span><br><span class="line">&#125;</span><br><span class="line">[$a, $b] = swap(<span class="string">'hello'</span>, <span class="string">'world'</span>);</span><br><span class="line"><span class="keyword">echo</span> $a, $b;</span><br></pre></td></tr></table></figure><h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a><code>if-else</code></h2><ul><li>Go</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        fmt.Println(<span class="string">"a is bigger than b"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"a is NOT greater than b"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    compare(<span class="number">12</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span><span class="params">(int $a, int $b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ($a &gt; $b) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"a is bigger than b"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"a is NOT greater than b"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">compare(<span class="number">12</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a><code>switch</code></h2><p>根据 Golang 官方教程文档:</p><blockquote><p>Go 的 switch 与 C，C+，Java，JavaScript 和 PHP 中的类似，除了 Go 只运行选中的 case，而不是随后的所有 case。 实际上， <code>break</code> 语句在这些语言中的每个 case<br>后都是必需的，而在 Go 中则是自动补充的。另一个重要的区别是 Go 的 switch cases 不需要是常量，并且涉及的值也不必是整数。</p></blockquote><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Print(<span class="string">"Go runs on "</span>)</span><br><span class="line"></span><br><span class="line">    os := runtime.GOOS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> os &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"PHP runs on "</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (PHP_OS) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"OS X."</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Linux."</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">echo</span> PHP_OS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ($i = <span class="number">0</span>; $i &lt; <span class="number">10</span>; $i++) &#123;</span><br><span class="line">    $sum += $i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>Go 自身没有 while 循环的语法。相应的，Go 使用 for 循环代替实现 <code>while</code> 循环.</p><ul><li>Go</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">func main() &#123;</span><br><span class="line">    <span class="built_in">sum</span> := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    for <span class="built_in">sum</span> &lt; <span class="number">100</span> &#123;</span><br><span class="line">        <span class="built_in">sum</span> += <span class="built_in">sum</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fmt</span>.Println(<span class="built_in">sum</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$sum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ($sum &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    $sum += $sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br></pre></td></tr></table></figure><h2 id="foreach-range"><a href="#foreach-range" class="headerlink" title="foreach/range"></a>foreach/range</h2><p>PHP 使用 <code>foreach</code> 迭代数组和对象。与之对应，Go 使用 <code>range</code> 迭代 slice 或 map。</p><ul><li>Go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    colours := []<span class="keyword">string</span>&#123;<span class="string">"Maroon"</span>, <span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Blue"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index, colour := <span class="keyword">range</span> colours &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"index: %d, colour: %s\n"</span>, index, colour)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PHP</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$colours = [<span class="string">"Maroon"</span>, <span class="string">"Red"</span>, <span class="string">"Green"</span>, <span class="string">"Blue"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> ($colours <span class="keyword">as</span> $index =&gt; $color) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"index: &#123;$index&#125;, color: &#123;$color&#125;\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://engineering.carsguide.com.au/go-vs-php-syntax-comparison-c1465380b8ff" target="_blank" rel="noopener">原文地址</a></li><li><a href="https://learnku.com/php/t/39590" target="_blank" rel="noopener">译文地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;PHP&lt;/code&gt; 是一种动态类型语言，它使新手更容易编写代码。现在的问题是，PHP 开发人员能否从动态类型语言切换到像 Go 这样的静态类型语言？为了找到答案，让我们对比一下 Go 和 PHP 之间的语法差异。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; 是由 Google 设计的一门静态类型的编译型语言。它有点类似于 C，但是它包含了更多的优点，比如垃圾回收、内存安全、结构类型和并发性。它的并发机制使多核和网络机器能够发挥最大的作用。这是 GoLang 的最佳卖点之一。此外，Go 速度快，表现力强，干净且高效。这也是 Go 如此吸引开发者学习的原因。&lt;/p&gt;
    
    </summary>
    
      <category term="Caoxl" scheme="http://blog.caoxl.com/categories/Caoxl/"/>
    
    
      <category term="PHP" scheme="http://blog.caoxl.com/tags/PHP/"/>
    
      <category term="Go" scheme="http://blog.caoxl.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试/笔试题杂记 IX</title>
    <link href="http://blog.caoxl.com/2020/09/23/Interview-Questions-Notes-IX/"/>
    <id>http://blog.caoxl.com/2020/09/23/Interview-Questions-Notes-IX/</id>
    <published>2020-09-23T01:47:07.000Z</published>
    <updated>2020-09-23T06:58:23.376Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>从问题中思考,从解答中成长</p></blockquote><a id="more"></a><h1 id="问题列表"><a href="#问题列表" class="headerlink" title="问题列表"></a>问题列表</h1><h1 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">计算机网络体系结构</a></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#12-http-%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90" target="_blank" rel="noopener">HTTP 报文组成</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#13-http-%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP 状态码</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#14-%E5%B8%B8%E8%A7%81%E7%9A%84-http-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">常见的 HTTP 方法</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#16-http-%E4%BC%98%E7%BC%BA%E7%82%B9" target="_blank" rel="noopener">HTTP 优缺点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#17-https-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">HTTPS 通信原理</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#18-http-20" target="_blank" rel="noopener">HTTP 2.0</a></li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#tcp-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener">TCP 适用场景</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#3-tcp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9" target="_blank" rel="noopener">TCP 的主要特点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#4-%E7%AE%80%E8%BF%B0%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">简述三报文握手建立 TCP 连接</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#5-%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4" target="_blank" rel="noopener">建立 TCP 连接为什么最后还要发送确认</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#6-%E7%AE%80%E8%BF%B0-tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE" target="_blank" rel="noopener">简述 TCP 连接的释放</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#7-time-wait-%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2mls" target="_blank" rel="noopener">TIME-WAIT 是什么，为什么必须等待 2MLS</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#8-tcp-%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">TCP 粘包问题</a></li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#udp-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener">UDP 适用场景</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#2-udp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9" target="_blank" rel="noopener">UDP 的主要特点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#9-udptcp-%E5%8C%BA%E5%88%AB%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener">UDP、TCP 区别，适用场景</a></li></ul><h2 id="IPv4-amp-IPv6"><a href="#IPv4-amp-IPv6" class="headerlink" title="IPv4&amp;IPv6"></a>IPv4&amp;IPv6</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#20-ipv6-%E4%B8%8E-ipv4-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96" target="_blank" rel="noopener">IPv6 与 IPv4 有什么变化</a></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#10-%E5%BB%BA%E7%AB%8B-socket-%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4" target="_blank" rel="noopener">建立 socket 需要哪些步骤</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#19-websocket" target="_blank" rel="noopener">WebSocket</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#22-%E4%BB%80%E4%B9%88%E6%98%AF%E9%95%BF%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">什么是长连接</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#15-get-%E4%B8%8E-post-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">GET 与 POST 请求方式区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C.md#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">什么是心跳机制</a></li></ul><h1 id="数据机构与算法篇"><a href="#数据机构与算法篇" class="headerlink" title="数据机构与算法篇"></a>数据机构与算法篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#1-%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">概述</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#2-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">实现基础</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#3-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">线性结构</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#4-%E6%A0%91" target="_blank" rel="noopener">树</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#5-%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE" target="_blank" rel="noopener">散列查找</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#6-%E5%9B%BE" target="_blank" rel="noopener">图</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md#7-%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">排序</a></li></ul><h1 id="PHP篇"><a href="#PHP篇" class="headerlink" title="PHP篇"></a>PHP篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#echoprintprint_rvar_dump-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">echo、print、print_r、var_dump 区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E5%8D%95%E5%BC%95%E5%8F%B7%E5%92%8C%E5%8F%8C%E5%BC%95%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">单引号和双引号的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#staticselfthis-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">static、self、$this 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#includerequireinclude_oncerequire_once-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">include、require、include_once、require_once 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#publicprotectedprivatefinal-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">public、protected、private、final 区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#mysqlmysqlipdo-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">MySQL、MySQLi、PDO 区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E5%8F%91%E8%B5%B7-http-%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">发起 HTTP 请求有哪几种方式，它们有何区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E5%B8%B8%E8%A7%81%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">常见数组函数</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#cookie-%E5%92%8C-session" target="_blank" rel="noopener">Cookie 和 Session</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">预定义变量</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">传值和传引用的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">构造函数和析构函数</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E8%B0%83%E7%94%A8%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">类的静态调用和实例化调用</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#phpini-%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">php.ini 配置选项</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#502504-%E9%94%99%E8%AF%AF%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">502、504 错误产生原因及解决方式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E4%B8%BB%E6%B5%81-php-%E6%A1%86%E6%9E%B6%E7%89%B9%E7%82%B9" target="_blank" rel="noopener">主流 PHP 框架特点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/03.PHP/QA.md#%E5%AF%B9%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84orm" target="_blank" rel="noopener">对象关系映射/ORM</a></li></ul><h1 id="Web篇"><a href="#Web篇" class="headerlink" title="Web篇"></a>Web篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#seo-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84" target="_blank" rel="noopener">SEO 有哪些需要注意的</a></li></ul><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#javascript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">JavaScript 数据类型</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8A%8A-javascript-%E6%96%87%E4%BB%B6%E6%94%BE%E5%9C%A8-html-%E5%BA%95%E9%83%A8" target="_blank" rel="noopener">为什么把 JavaScript 文件放在 Html 底部</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#javascript-%E6%93%8D%E4%BD%9C-dom-%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noopener">JavaScript 操作 DOM 的方法有哪些</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#javascript-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noopener">JavaScript 字符串方法有哪些</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#javascript-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">JavaScript 字符串截取方法有哪些？有什么区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-ajax-%E8%AF%B7%E6%B1%82" target="_blank" rel="noopener">如何实现 ajax 请求</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%98%AF%E4%BB%80%E4%B9%88" target="_blank" rel="noopener">同源策略是什么</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">如何解决跨域问题</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%BC%95%E8%B5%B7%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B" target="_blank" rel="noopener">引起内存泄漏的操作有哪些</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BD%91%E9%A1%B5%E4%B8%AD%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F%E6%88%96%E8%80%85%E5%A4%B1%E8%B4%A5" target="_blank" rel="noopener">如何判断网页中图片加载成功或者失败</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD" target="_blank" rel="noopener">如何实现懒加载</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#jsonp-%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">JSONP 原理</a></li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#css-%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB" target="_blank" rel="noopener">CSS 选择器的分类</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#css-sprite-%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9" target="_blank" rel="noopener">CSS sprite 是什么，有什么优缺点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#display-none-%E4%B8%8E-visibility-hidden-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">display: none 与 visibility: hidden 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#display-block-%E5%92%8C-display-inline-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">display: block 和 display: inline 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#css-%E6%96%87%E4%BB%B6style-%E6%A0%87%E7%AD%BE%E8%A1%8C%E5%86%85-style-%E5%B1%9E%E6%80%A7%E4%BC%98%E5%85%88%E7%BA%A7" target="_blank" rel="noopener">CSS 文件、style 标签、行内 style 属性优先级</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#link-%E4%B8%8E-import-%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">link 与 @import 的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#flex-%E4%B8%8E-css-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">flex 与 CSS 盒子模型有什么区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#pnggifjpg-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%A6%82%E4%BD%95%E9%80%89" target="_blank" rel="noopener">PNG,GIF,JPG 的区别及如何选</a></li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/04.Web/QA.md#vuejs-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">Vue.js 双向绑定原理</a></li></ul><h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">体系结构</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C" target="_blank" rel="noopener">基础操作</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener">数据库设计范式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">数据库设计原则</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#char-%E5%92%8C-varchar-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">char 和 varchar 数据类型区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#left-join-right-joininner-join" target="_blank" rel="noopener">LEFT JOIN 、RIGHT JOIN、INNER JOIN</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#unionunion-all" target="_blank" rel="noopener">UNION、UNION ALL</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%B8%B8%E7%94%A8-mysql-%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">常用 MySQL 函数</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E9%94%81" target="_blank" rel="noopener">锁</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">事务</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">常见存储引擎</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener">常见索引</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E8%81%9A%E6%97%8F%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E6%97%8F%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">聚族索引与非聚族索引的区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#btree-%E4%B8%8E-btree-btree-%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">BTree 与 BTree-/BTree+ 索引原理</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#%E5%88%86%E8%A1%A8%E6%95%B0%E9%87%8F%E7%BA%A7" target="_blank" rel="noopener">分表数量级</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/05.MySQL/QA.md#explain-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">EXPLAIN 输出格式</a></li></ul><h1 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E7%89%B9%E7%82%B9" target="_blank" rel="noopener">Redis 特点</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">Redis 支持哪些数据结构</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E4%B8%8E-memcache-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">Redis 与 Memcache 区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5" target="_blank" rel="noopener">持久化策略</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">Redis 事务</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" target="_blank" rel="noopener">如何实现分布式锁</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#redis-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%8F%8A%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Redis 过期策略及内存淘汰机制</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/06.Redis/QA.md#%E4%B8%BA%E4%BB%80%E4%B9%88-redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84" target="_blank" rel="noopener">为什么 Redis 是单线程的</a></li></ul><h1 id="Linux篇"><a href="#Linux篇" class="headerlink" title="Linux篇"></a>Linux篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#linux-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">Linux 目录结构</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#linux-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">Linux 基础</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE" target="_blank" rel="noopener">命令与文件查找</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">数据流重定向</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1" target="_blank" rel="noopener">计划任务</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#vim" target="_blank" rel="noopener">Vim</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E8%B4%9F%E8%BD%BD%E6%9F%A5%E7%9C%8B" target="_blank" rel="noopener">负载查看</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">Linux 内存管理</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener">进程、线程、协程区别</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/07.Linux/QA.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">进程间通信与信号机制</a></li></ul><h1 id="安全篇"><a href="#安全篇" class="headerlink" title="安全篇"></a>安全篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BBxss" target="_blank" rel="noopener">跨站脚本攻击(XSS)</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0csrf" target="_blank" rel="noopener">跨站点请求伪造(CSRF)</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#sql-%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">SQL 注入</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#%E5%BA%94%E7%94%A8%E5%B1%82%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">应用层拒绝服务攻击</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#php-%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">PHP 安全</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/08.%E5%AE%89%E5%85%A8/QA.md#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E7%9C%9F%E9%9A%8F%E6%9C%BA%E6%95%B0" target="_blank" rel="noopener">伪随机数和真随机数</a></li></ul><h1 id="设计模式篇"><a href="#设计模式篇" class="headerlink" title="设计模式篇"></a>设计模式篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">什么是设计模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%A1%86%E6%9E%B6" target="_blank" rel="noopener">如何理解框架</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E4%B8%BB%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">主要设计模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E6%80%8E%E6%A0%B7%E9%80%89%E6%8B%A9%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">怎样选择设计模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">单例模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">抽象工厂模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">工厂方法模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">适配器模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">策略模式</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC" target="_blank" rel="noopener">控制反转</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/09.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/QA.md#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5" target="_blank" rel="noopener">依赖注入</a></li></ul><h1 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h1><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#oauth-20" target="_blank" rel="noopener">OAuth 2.0</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95" target="_blank" rel="noopener">单点登录</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#rest" target="_blank" rel="noopener">REST</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#api-%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9" target="_blank" rel="noopener">API 版本兼容</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#jwt" target="_blank" rel="noopener">JWT</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#lvs" target="_blank" rel="noopener">LVS</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#ngnix" target="_blank" rel="noopener">Ngnix</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB" target="_blank" rel="noopener">数据库读写分离</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%86%E5%88%86" target="_blank" rel="noopener">数据库拆分</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">一致性哈希</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#redis-%E9%9B%86%E7%BE%A4" target="_blank" rel="noopener">Redis 集群</a></li><li><a href="https://github.com/colinlet/PHP-Interview-QA/blob/master/docs/10.%E6%9E%B6%E6%9E%84/QA.md#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97" target="_blank" rel="noopener">消息队列</a></li></ul><h1 id="职业规划篇"><a href="#职业规划篇" class="headerlink" title="职业规划篇"></a>职业规划篇</h1>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从问题中思考,从解答中成长&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>他写出了 Vue，却做不对这十道 Vue 笔试题</title>
    <link href="http://blog.caoxl.com/2020/09/10/Vue-The-Test/"/>
    <id>http://blog.caoxl.com/2020/09/10/Vue-The-Test/</id>
    <published>2020-09-10T07:17:23.000Z</published>
    <updated>2020-09-10T07:43:56.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>原文地址: <a href="https://juejin.im/post/6870737289736093710" target="_blank" rel="noopener">他写出了 Vue，却做不对这十道 Vue 笔试题</a></p></blockquote><a id="more"></a><p>这里搬运过来只是方便自己学习.</p><p>上题:</p><ul><li><ol><li><code>Vue</code> 实例的 <code>data</code> 属性，可以在哪些生命周期中获取到？<br>A. <code>beforeCreate</code><br>B. <code>created</code><br>C. <code>beforeMount</code><br>D. <code>mounted</code></li></ol></li></ul><ul><li><ol start="2"><li>下列对 <code>Vue</code> 原理的叙述，哪些是正确的？<br>A. <code>Vue</code> 中的数组变更通知，通过拦截数组操作方法而实现<br>B. 编译器目标是创建渲染函数，渲染函数执行后将得到 <code>VNode</code> 树<br>C. 组件内 <code>data</code> 发生变化时会通知其对应 <code>watcher</code>，执行异步更新<br>D. <code>patching</code> 算法首先进行同层级比较，可能执行的操作是节点的增加、删除和更新</li></ol></li></ul><ul><li><ol start="3"><li>对于 <code>Vue</code> 中响应式数据原理的说法，下列哪项是不正确的？<br>A. 采用数据劫持方式，即 <code>Object.defineProperty()</code> 劫持 <code>data</code> 中各属性，实现响应式数据<br>B. 视图中的变化会通过 <code>watcher</code> 更新 <code>data</code> 中的数据<br>C. 若 <code>data</code> 中某属性多次发生变化，<code>watcher</code> 仅会进入更新队列一次<br>D. 通过编译过程进行依赖收集</li></ol></li></ul><ul><li><ol start="4"><li>下列说法不正确的是哪项？<br>A. <code>key</code> 的作用主要是为了高效地更新虚拟 <code>DOM</code><br>B. 若指定了组件的 <code>template</code> 选项，<code>render</code> 函数不会执行<br>C. 使用 <code>vm.$nextTick</code> 可以确保获得 <code>DOM</code> 异步更新的结果<br>D. 若没有 <code>el</code> 选项，<code>vm.$mount(dom)</code> 可将 <code>Vue</code> 实例挂载于指定元素上</li></ol></li></ul><ul><li><ol start="5"><li>下列关于 <code>Vuex</code> 的描述，不正确的是哪项？<br>A. <code>Vuex</code> 通过 <code>Vue</code> 实现响应式状态，因此只能用于 <code>Vue</code><br>B. <code>Vuex</code> 是一个状态管理模式<br>C. <code>Vuex</code> 主要用于多视图间状态全局共享与管理<br>D. 在 <code>Vuex</code> 中改变状态，可以通过 <code>mutations</code> 和 <code>actions</code></li></ol></li></ul><ul><li><ol start="6"><li>关于 <code>Vue</code> 组件间的参数传递，下列哪项是不正确的？<br>A. 若子组件给父组件传值，可使用 <code>$emit</code> 方法<br>B. 祖孙组件之间可以使用 <code>provide</code> 和 <code>inject</code> 方式跨层级相互传值<br>C. 若子组件使用 <code>$emit(&#39;say&#39;)</code> 派发事件，父组件可使用 <code>@say</code> 监听<br>D. 若父组件给子组件传值，子组件可通过 <code>props</code> 接受数据</li></ol></li></ul><ul><li><ol start="7"><li>下列关于 <code>vue-router</code> 的描述，不正确的是哪项？<br>A. <code>vue-router</code> 的常用模式有 <code>hash</code> 和 <code>history</code> 两种<br>B. 可通过 <code>addRoutes</code> 方法动态添加路由<br>C. 可通过 <code>beforeEnter</code> 对单个组件进行路由守卫<br>D. <code>vue-router</code> 借助 <code>Vue</code> 实现响应式的路由，因此只能用于 <code>Vue</code></li></ol></li></ul><ul><li><ol start="8"><li>下列说法不正确的是哪项？<br>A. 可通过 <code>this.$parent</code> 查找当前组件的父组件<br>B. 可使用 <code>this.$refs</code> 查找命名子组件<br>C. 可使用 <code>this.$children</code> 按顺序查找当前组件的直接子组件<br>D. 可使用 <code>$root</code> 查找根组件，并可配合 <code>children</code> 遍历全部组件</li></ol></li></ul><ul><li><ol start="9"><li>下列关于 <code>v-model</code> 的说法，哪项是不正确的？<br>A. <code>v-model</code> 能实现双向绑定<br>B. <code>v-model</code> 本质上是语法糖，它负责监听用户的输入事件以更新数据<br>C. <code>v-model</code> 是内置指令，不能用在自定义组件上<br>D. 对 <code>input</code> 使用 <code>v-model</code>，实际上是指定其 <code>:value</code> 和 <code>:input</code></li></ol></li></ul><ul><li><ol start="10"><li>关于 <code>Vue</code> 的生命周期，下列哪项是不正确的？<br>A. <code>DOM</code> 渲染在 <code>mounted</code> 中就已经完成了<br>B. <code>Vue</code> 实例从创建到销毁的过程，就是生命周期<br>C. <code>created</code> 表示完成数据观测、属性和方法的运算和初始化事件，此时 <code>$el</code> 属性还未显示出来<br>D. 页面首次加载过程中，会依次触发 <code>beforeCreate</code>，<code>created</code>，<code>beforeMount</code>，<code>mounted</code>，<code>beforeUpdate</code>，<code>updated</code></li></ol></li></ul><ul><li>参考答案</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> BCD</span><br><span class="line"><span class="number">2.</span> ABCD</span><br><span class="line"><span class="number">3.</span> BD</span><br><span class="line"><span class="number">4.</span> B</span><br><span class="line"><span class="number">5.</span> C</span><br><span class="line"><span class="number">6.</span> B</span><br><span class="line"><span class="number">7.</span> C</span><br><span class="line"><span class="number">8.</span> C</span><br><span class="line"><span class="number">9.</span> C</span><br><span class="line"><span class="number">10.</span> D</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.zhihu.com/question/393825440/answer/1214828265" target="_blank" rel="noopener">逐条判定为什么 Dan Abramov 配不上阿里 P7</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://juejin.im/post/6870737289736093710&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;他写出了 Vue，却做不对这十道 Vue 笔试题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://blog.caoxl.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://blog.caoxl.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue CLI 3.x 与 2.x的区别</title>
    <link href="http://blog.caoxl.com/2020/09/09/Vue-2x-3x-Diff/"/>
    <id>http://blog.caoxl.com/2020/09/09/Vue-2x-3x-Diff/</id>
    <published>2020-09-09T04:03:30.000Z</published>
    <updated>2020-09-09T07:56:32.250Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Vue CLI 3.x 与 2.x的区别</p><a id="more"></a><h1 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h1><ul><li>安装与项目构建</li><li>项目目录变化</li><li>项目配置变化</li></ul><h1 id="安装-amp-项目构建"><a href="#安装-amp-项目构建" class="headerlink" title="安装&amp;项目构建"></a>安装&amp;项目构建</h1><h2 id="CLI安装"><a href="#CLI安装" class="headerlink" title="CLI安装"></a>CLI安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cli 2.x </span></span><br><span class="line"><span class="built_in">npm</span> install -g vue-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># cli 3.x </span></span><br><span class="line"><span class="comment"># 3.x 安装时，如果之前安装了2.x需要卸载2.x再安装</span></span><br><span class="line"><span class="built_in">npm</span> install -g @vue/cli</span><br></pre></td></tr></table></figure><h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><h3 id="cli2-x"><a href="#cli2-x" class="headerlink" title="cli2.x"></a>cli2.x</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue init &lt;template-<span class="built_in">name</span>&gt; &lt;project-<span class="built_in">name</span>&gt;</span><br><span class="line">npm i </span><br><span class="line">npm <span class="built_in">run</span> dev</span><br></pre></td></tr></table></figure><h3 id="cli3-x"><a href="#cli3-x" class="headerlink" title="cli3.x"></a>cli3.x</h3><blockquote><ul><li>安装新增TypeScript配置选项</li><li>新增图形化安装方法</li><li>保留了2.x之前的安装方法</li></ul></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vue</span> <span class="string">create hello-world</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">i</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">run serve</span></span><br><span class="line"><span class="comment"># 使用vue ui创建新项目(3.x新增)</span></span><br><span class="line"><span class="attr">vue</span> <span class="string">ui</span></span><br><span class="line"><span class="comment"># 使用旧版（2.X）创建</span></span><br><span class="line"><span class="attr">npm</span> <span class="string">install -g @vue/cli-init</span></span><br><span class="line"><span class="comment"># 'vue init'的运行效果与‘vue-cli@2.x’相同</span></span><br><span class="line"><span class="attr">vue</span> <span class="string">init webpack projectname</span></span><br></pre></td></tr></table></figure><h1 id="3-x后目录结构变化-替换2-x功能的新特性"><a href="#3-x后目录结构变化-替换2-x功能的新特性" class="headerlink" title="3.x后目录结构变化[替换2.x功能的新特性]"></a>3.x后目录结构变化[替换2.x功能的新特性]</h1><h2 id="config目录删除，使用模式的-env文件代替-模式"><a href="#config目录删除，使用模式的-env文件代替-模式" class="headerlink" title="config目录删除，使用模式的.env文件代替[模式]"></a>config目录删除，使用模式的.env文件代替[模式]</h2><p><code>cli3</code>新增模式概念，每个模式在项目中都有对应的配置文件，项目启动时，对应的文件就会加载，与环境变量不同，一个模式可以包括多个环境变量</p><ul><li><p><code>Vue CLI</code> 项目默认有三个模式：</p><ul><li><code>development</code> 模式用于 <code>vue-cli-service serve</code></li><li><code>production</code> 模式用于 <code>vue-cli-service build</code> 和 <code>vue-cli-service test:e2e</code></li><li><code>test</code> 模式用于 <code>vue-cli-service test:unit</code></li></ul></li><li><p>模式需要在启动项目时使用–mode指定</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">NODE_ENV</span>=development npm <span class="builtin-name">run</span> serve --mode mymode # 模式包含多个环境变量</span><br></pre></td></tr></table></figure><ul><li>每个模式有多个环境变量，<code>cli3.x</code>为模式与环境变量指定了一个<code>.env</code>配置文件</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.env</span> # 所有环境</span><br><span class="line"><span class="selector-class">.env</span><span class="selector-class">.mode</span> # <span class="selector-tag">mode</span>模式加载的配置文件<span class="selector-attr">[优先级高于.env]</span></span><br><span class="line"><span class="selector-class">.env</span><span class="selector-class">.mode</span><span class="selector-class">.development</span> # <span class="selector-tag">mode</span>模式下，<span class="selector-tag">development</span>环境所加载的配置文件<span class="selector-attr">[优先级最高]</span></span><br></pre></td></tr></table></figure><ul><li><code>.env</code>文件详细信息<ul><li>这些文件是用来代替<code>config</code>目录的</li><li>以<code>VUE_APP_</code>开头的变量可以再代码中通过<code>process.env</code>访问，其他的变量不可访问</li><li><code>process.env</code>始终含有两个特殊变量<code>NODE_ENV</code>和<code>BASE_URL</code></li></ul></li></ul><h2 id="删除static目录-新增public目录"><a href="#删除static目录-新增public目录" class="headerlink" title="删除static目录[新增public目录]"></a>删除static目录[新增public目录]</h2><p>删除了<code>static</code>目录，它的静态资源转移到<code>public</code>目录中，通过<code>/xx.xx</code>可以直接访问</p><h3 id="public详细信息"><a href="#public详细信息" class="headerlink" title="public详细信息"></a><code>public</code>详细信息</h3><ul><li><p><code>index.html</code>入口文件从根目录转到<code>public</code>目录下，它拥有3个特殊插值</p><ul><li><code>&lt;%= VALUE %&gt;</code> 用来做不转义插值；</li><li><code>&lt;%- VALUE %&gt;</code> 用来做 HTML 转义插值；</li><li><code>&lt;% expression %&gt;</code> 用来描述 JavaScript 流程控制</li></ul></li><li><p>静态资源被转移到public目录存放</p></li><li><p><code>cli3</code>项目的静态资源有两种处理方式</p><ul><li>在<code>JavaScript</code>或<code>template/css(vue)</code>中通过相对路径导入。这类资源会被<code>webpack</code>处理（不在public目录）</li><li>放在<code>public</code>目录或者使用绝对路径被导入的静态资源。这类资源会被直接拷贝，不会经过<code>webpack</code>处理</li></ul></li></ul><h2 id="cli3-x项目配置的不同（build目录删除）"><a href="#cli3-x项目配置的不同（build目录删除）" class="headerlink" title="cli3.x项目配置的不同（build目录删除）"></a><code>cli3.x</code>项目配置的不同（<code>build</code>目录删除）</h2><p><code>2.x</code>版本的项目配置是在<code>config</code>和<code>build</code>中完成，但是，到了<code>3.x</code>版本，这两个目录都被删除，如果需要自定义配置，需要自己新建<code>vue.config.js</code>文件</p><ul><li><p><code>publicPath</code></p><ul><li>部署应用包时的基本URL，即<code>webpack</code>的<code>output.publicPath</code></li><li>但，<code>vue</code>项目中其他地方会用到<code>publicPath</code>，所以不要修改<code>webpack</code>的<code>output.publicPath</code></li></ul></li><li><p><code>outputDir</code></p><ul><li><code>build</code>构建的文件存放的目录</li><li>即<code>output.path</code>，但只能修改<code>outputDir</code>，不能修改<code>output.path</code></li></ul></li><li><p><code>assetsDir</code> 编译后，在<code>outputDir</code>目录中存放静态资源的目录</p></li><li><p><code>lintOnSave</code> 配置<code>eslint</code>后，是否每次保存<code>lint</code>代码，默认启动</p></li><li><p><code>runtimeCompiler</code> 是否使用包含运行时编译器的 <code>Vue</code> 构建版本，默认不启动</p></li><li><p><code>configureWebpack</code> &amp; <code>chainWebpack</code></p><ul><li>这两个选项是用来配置<code>webpack</code>内容的，前者是合并对象，后者是链式调用</li><li><code>[cli3.6]webpack</code>的<code>build</code>代码压缩默认不开启，需要设置环境变量为<code>production</code>才会开启</li></ul></li><li><p><code>devServer</code> 支持所有<code>webpack-dev-server</code>选项</p><ul><li>配置项目端口、域名 <code>host、port、https</code></li><li>配置项目跨域代理 <code>proxy</code></li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">module.exports</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8100</span><span class="string">,</span></span><br><span class="line">  <span class="attr">devServer:</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">proxy:</span> <span class="string">'http://localhost:4000'</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="新增功能特性"><a href="#新增功能特性" class="headerlink" title="新增功能特性"></a>新增功能特性</h1><h2 id="快速原型开发"><a href="#快速原型开发" class="headerlink" title="快速原型开发"></a>快速原型开发</h2><p>在<code>cli3.x</code>中可以使用<code>vue serve</code> 和<code>vue build</code>命令对单个<code>*.vue</code> 文件进行快速原型开发</p><h3 id="安装全局依赖"><a href="#安装全局依赖" class="headerlink" title="安装全局依赖"></a>安装全局依赖</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g @vue/cli-service-<span class="built_in">global</span></span><br></pre></td></tr></table></figure><h3 id="vue-serve-运行文件"><a href="#vue-serve-运行文件" class="headerlink" title="vue serve 运行文件"></a><code>vue serve</code> 运行文件</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">vue</span> <span class="selector-tag">serve</span> <span class="selector-tag">myComponent</span><span class="selector-class">.vue</span> </span><br><span class="line"><span class="selector-tag">Usage</span>: <span class="selector-tag">serve</span> <span class="selector-attr">[options]</span> <span class="selector-attr">[entry]</span></span><br><span class="line">在开发环境模式下零配置为 <span class="selector-class">.js</span> 或 <span class="selector-class">.vue</span> 文件启动一个服务器</span><br><span class="line"><span class="selector-tag">Options</span>:</span><br><span class="line">  <span class="selector-tag">-o</span>, <span class="selector-tag">--open</span>  打开浏览器</span><br><span class="line">  <span class="selector-tag">-c</span>, <span class="selector-tag">--copy</span>  将本地 <span class="selector-tag">URL</span> 复制到剪切板</span><br><span class="line">  <span class="selector-tag">-h</span>, <span class="selector-tag">--help</span>  输出用法信息</span><br></pre></td></tr></table></figure><h3 id="vue-build-编译文件"><a href="#vue-build-编译文件" class="headerlink" title="vue build 编译文件"></a><code>vue build</code> 编译文件</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vue build myComponent.vue </span><br><span class="line"><span class="symbol">Usage:</span> build [options] [entry]</span><br><span class="line">在生产环境模式下零配置构建一个 .js 或 .vue 文件</span><br><span class="line"><span class="symbol">Options:</span></span><br><span class="line">  -t, --target &lt;target&gt;  构建目标 (app | <span class="class"><span class="keyword">lib</span> | <span class="title">wc</span> | <span class="title">wc</span>-<span class="title">async</span>, 默认值：<span class="title">app</span>)</span></span><br><span class="line">  -n, --name &lt;name&gt;      库的名字或 Web Components 组件的名字 (默认值：入口文件名)</span><br><span class="line">  -d, --dest &lt;dir&gt;       输出目录 (默认值：dist)</span><br><span class="line">  -h, --help             输出用法信息</span><br></pre></td></tr></table></figure><h2 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h2><p><code>vue cli3</code> 新增一个UI图形化管理页面，可以通过它新建项目、管理原有项目的插件</p><h3 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vue</span> ui <span class="comment"># 启动图形化界面</span></span><br></pre></td></tr></table></figure><h3 id="管理原有项目（包括2-X项目）"><a href="#管理原有项目（包括2-X项目）" class="headerlink" title="管理原有项目（包括2.X项目）"></a>管理原有项目（包括2.X项目）</h3><ul><li>插件管理（更新，查看）（3.x）</li><li>依赖（module）管理（删除、安装、更新、查看）（2.x、3.x）</li><li>项目配置修改 （3.x）</li><li>项目任务（项目script命令启动、停止操作）（2.x、3.x）</li></ul><h2 id="cli插件"><a href="#cli插件" class="headerlink" title="cli插件"></a><code>cli</code>插件</h2><h3 id="什么是插件"><a href="#什么是插件" class="headerlink" title="什么是插件"></a>什么是插件</h3><ul><li><code>vue cli3.x</code>使用了一套基于插件的架构，cli的相关依赖都是以<code>@vue/cli-plugin-</code>开头的</li><li>插件可以修改内部的 <code>webpack</code> 配置，也可以向 <code>vue-cli-service</code> 注入命令</li><li>在项目创建的过程中列出的特性，绝大部分都是通过插件来实现的</li></ul><h3 id="vue-add-插件的安装"><a href="#vue-add-插件的安装" class="headerlink" title="vue add 插件的安装"></a><code>vue add</code> 插件的安装</h3><p><code>cli3.x</code>项目提供了<code>vue add</code>命令来安装插件</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">add</span> @vue/<span class="keyword">cli</span>-plugin-eslint</span><br></pre></td></tr></table></figure><h3 id="特殊的vue-router和vuex"><a href="#特殊的vue-router和vuex" class="headerlink" title="特殊的vue-router和vuex"></a>特殊的<code>vue-router</code>和<code>vuex</code></h3><p>它们没有对应的插件，但是依旧可以使用<code>vue add</code>在项目中添加它们</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vue <span class="keyword">add</span><span class="bash"> router</span></span><br><span class="line">vue <span class="keyword">add</span><span class="bash"> vuex</span></span><br></pre></td></tr></table></figure><h2 id="配置文件样例"><a href="#配置文件样例" class="headerlink" title="配置文件样例"></a>配置文件样例</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> <span class="params">(dir)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> path.<span class="keyword">join</span>(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: <span class="string">'/'</span>,</span><br><span class="line">  assetsDir: <span class="string">'static'</span>,</span><br><span class="line">  productionSourceMap: false,</span><br><span class="line">  configureWebpack: config =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.VUE_APP_NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">      // 为生产环境修改配置...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      // 为开发环境修改配置...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 解析别名处理</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    config.<span class="built_in">resolve</span>.alias</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@img'</span>, <span class="built_in">resolve</span>(<span class="string">'src/assets/img'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@c'</span>, <span class="built_in">resolve</span>(<span class="string">'src/components'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@m'</span>, <span class="built_in">resolve</span>(<span class="string">'src/mixins'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@v'</span>, <span class="built_in">resolve</span>(<span class="string">'src/views'</span>))</span><br><span class="line">      .<span class="keyword">set</span>(<span class="string">'@s'</span>, <span class="built_in">resolve</span>(<span class="string">'src/store'</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  // 配置高于chainWebpack中关于 css loader 的配置</span><br><span class="line">  <span class="keyword">cs</span><span class="variable">s:</span> &#123;</span><br><span class="line">    // 是否开启支持 foo.module.css 样式</span><br><span class="line">    module<span class="variable">s:</span> false,</span><br><span class="line">    // 是否使用 css 分离插件 ExtractTextPlugin，采用独立样式文件载入，不采用 <span class="symbol">&lt;style&gt;</span> 方式内联至 html 文件中</span><br><span class="line">    extrac<span class="variable">t:</span> true,</span><br><span class="line">    // 是否构建样式地图，false 将提高构建速度</span><br><span class="line">    sourceMap: false,</span><br><span class="line">    // css预设器配置项</span><br><span class="line">    loaderOption<span class="variable">s:</span> &#123;</span><br><span class="line">      <span class="keyword">cs</span><span class="variable">s:</span> &#123;</span><br><span class="line">        // <span class="keyword">options</span> here will <span class="keyword">be</span> passed <span class="keyword">to</span> css-loader</span><br><span class="line">      &#125;,</span><br><span class="line">      postcs<span class="variable">s:</span> &#123;</span><br><span class="line">        // <span class="keyword">options</span> here will <span class="keyword">be</span> passed <span class="keyword">to</span> postcss-loader</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    por<span class="variable">t:</span> <span class="number">8010</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/6844903911808040967#heading-20" target="_blank" rel="noopener">Vue CLI 3.x 与 2.x的区别</a></li><li><a href="https://juejin.im/post/6844904176187605000" target="_blank" rel="noopener">Vue 3教程（适用于Vue 2用户）</a></li><li><a href="https://juejin.im/post/6869521076771094536" target="_blank" rel="noopener">使用Vue3.0，我收获了哪些知识点</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vue CLI 3.x 与 2.x的区别&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://blog.caoxl.com/categories/Vue/"/>
    
    
      <category term="前端" scheme="http://blog.caoxl.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Vue" scheme="http://blog.caoxl.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>SQL诊断与优化</title>
    <link href="http://blog.caoxl.com/2020/07/28/MySQL-Explain-Notes/"/>
    <id>http://blog.caoxl.com/2020/07/28/MySQL-Explain-Notes/</id>
    <published>2020-07-28T02:16:35.000Z</published>
    <updated>2020-12-23T03:02:57.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Explain-诊断"><a href="#Explain-诊断" class="headerlink" title="Explain 诊断"></a>Explain 诊断</h1><a id="more"></a><p>Explain各参数的含义如下：</p><table><thead><tr><th style="text-align:left">列名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>id</code></td><td style="text-align:left">执行编号，标识select所属的行。如果在语句中没有子查询或关联查询，只有唯一的select，每行都将显示1.否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置</td></tr><tr><td style="text-align:left"><code>select_type</code></td><td style="text-align:left">显示本行是简单或复杂select，如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUIT</td></tr><tr><td style="text-align:left"><code>table</code></td><td style="text-align:left">访问引用哪个表（引用某个查询，如“derived3”</td></tr><tr><td style="text-align:left"><code>type</code></td><td style="text-align:left">数据访问/读取操作类型（All、index、range、ref、eq_ref、const/system、NULL）</td></tr><tr><td style="text-align:left"><code>possible_key</code></td><td style="text-align:left">揭示哪一些索引可能有利于高效的查找</td></tr><tr><td style="text-align:left"><code>key</code></td><td style="text-align:left">显示mysql实际决定采用哪个索引来优化查询</td></tr><tr><td style="text-align:left"><code>key_len</code></td><td style="text-align:left">显示mysql在索引里使用的字节数</td></tr><tr><td style="text-align:left"><code>ref</code></td><td style="text-align:left">显示了之前的表在key列记录的索引中查找值所用的列或常量</td></tr><tr><td style="text-align:left"><code>rows</code></td><td style="text-align:left">为了找到所需要的行而需要读取的行数，估算值</td></tr><tr><td style="text-align:left"><code>Extra</code></td><td style="text-align:left">额外信息，如using index、filesort等</td></tr></tbody></table><h2 id="select-type-常见类型及其含义"><a href="#select-type-常见类型及其含义" class="headerlink" title="select_type 常见类型及其含义"></a>select_type 常见类型及其含义</h2><ul><li><strong>SIMPLE</strong>: 不包含子查询或者 UNION 操作的查询</li><li><strong>PRIMARY</strong>: 查询中如果包含任何子查询，那么最外层的查询则被标记为 PRIMARY</li><li><strong>SUBQUERY</strong>: 子查询中第一个 SELECT</li><li><strong>DEPENDENT SUBQUERY</strong>: 子查询中的第一个 SELECT，取决于外部查询</li><li><strong>UNION</strong>: UNION 操作的第二个或者之后的查询</li><li><strong>DEPENDENT UNION</strong>: UNION 操作的第二个或者之后的查询,取决于外部查询</li><li><strong>UNION RESULT</strong>: UNION 产生的结果集</li><li><strong>DERIVED</strong>: 出现在 FROM 字句中的子查询</li></ul><h2 id="type常见类型及其含义"><a href="#type常见类型及其含义" class="headerlink" title="type常见类型及其含义"></a>type常见类型及其含义</h2><ul><li><strong>system</strong>: 这是 const 类型的一个特例，只会出现在待查询的表只有一行数据的情况下</li><li><strong>consts</strong>: 常出现在主键或唯一索引与常量值进行比较的场景下，此时查询性能是最优的</li><li><strong>eq_ref</strong>: 当连接使用的是完整的索引并且是 PRIMARY KEY 或 UNIQUE NOT NULL INDEX 时使用它</li><li><strong>ref</strong>：当连接使用的是前缀索引或连接条件不是 PRIMARY KEY 或 UNIQUE INDEX 时则使用它</li><li><strong>ref_or_null</strong>: 类似于 ref 类型的查询，但是附加了对 NULL 值列的查询</li><li><strong>index_merge</strong>: 该联接类型表示使用了索引进行合并优化</li><li><strong>range</strong>: 使用索引进行范围扫描，常见于 between、&gt; 、&lt; 这样的查询条件</li><li><strong>index</strong>: 索引连接类型与 ALL 相同，只是扫描的是索引树，通常出现在索引是该查询的覆盖索引的情况</li><li><strong>ALL</strong>: 全表扫描，效率最差的查找方式</li></ul><p>阿里编码规范要求：<code>至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好</code></p><h2 id="key列"><a href="#key列" class="headerlink" title="key列"></a>key列</h2><p>实际在查询中是否使用到索引的标志字段</p><h2 id="Extra列"><a href="#Extra列" class="headerlink" title="Extra列"></a>Extra列</h2><p>Extra 列主要用于显示额外的信息，常见信息及其含义如下:</p><ul><li><strong>Using where</strong>: MySQL 服务器会在存储引擎检索行后再进行过滤</li><li><strong>Using filesort</strong>: 通常出现在 GROUP BY 或 ORDER BY<br>语句中，且排序或分组没有基于索引，此时需要使用文件在内存中进行排序，因为使用索引排序的性能好于使用文件排序，所以出现这种情况可以考虑通过添加索引进行优化</li><li><strong>Using index</strong>: 使用了覆盖索引进行查询，此时不需要访问表，从索引中就可以获取到所需的全部数据</li><li><strong>Using index condition</strong>: 查找使用了索引，但是需要回表查询数据</li><li><strong>Using temporary</strong>: 表示需要使用临时表来处理查询，常出现在 GROUP BY 或 ORDER BY 语句中</li></ul><h1 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h1><h2 id="超大分页场景解决方案"><a href="#超大分页场景解决方案" class="headerlink" title="超大分页场景解决方案"></a>超大分页场景解决方案</h2><p>如表中数据需要进行深度分页，如何提高效率？在阿里出品的Java编程规范中写道：</p><blockquote><p>利用延迟关联或者子查询优化超多分页场景</p></blockquote><p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 反例（耗时129.570s）</span><br><span class="line">select * from task_result LIMIT 20000000, 10;</span><br><span class="line"></span><br><span class="line"># 正例（耗时5.114s）</span><br><span class="line">SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id = b.id;</span><br></pre></td></tr></table></figure><blockquote><p>说明<br>task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万</p></blockquote><h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 反例</span></span><br><span class="line">INSERT into person(name,age) values('A',24)</span><br><span class="line">INSERT into person(name,age) values('B',24)</span><br><span class="line">INSERT into person(name,age) values('C',24)</span><br><span class="line"></span><br><span class="line"><span class="section"># 正例</span></span><br><span class="line">INSERT into person(name,age) values('A',24),('B',24),('C',24);</span><br></pre></td></tr></table></figure><blockquote><p>说明<br>比较常规，就不多做说明了</p></blockquote><h2 id="like语句的优化"><a href="#like语句的优化" class="headerlink" title="like语句的优化"></a>like语句的优化</h2><p>like语句一般业务要求都是 <code>&#39;%关键字%&#39;</code> 这种形式，但是依然要思考能否考虑使用右模糊的方式去替代产品的要求，其中阿里的编码规范提到:</p><blockquote><p>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 反例（耗时78.843s）</span></span><br><span class="line">EXPLAIN select * from task_result where taskid LIKE '%tt600e6b601677b5cbfe516a013b8e46%' LIMIT 1;</span><br><span class="line"></span><br><span class="line"><span class="section"># 正例（耗时0.986s）</span></span><br><span class="line">select * from task_result where taskid LIKE 'tt600e6b601677b5cbfe516a013b8e46%' LIMIT 1</span><br><span class="line"></span><br><span class="line"><span class="section">##########################################################################</span></span><br><span class="line"><span class="section"># 对正例的Explain</span></span><br><span class="line">1SIMPLEtask<span class="emphasis">_resultrangeadapt_</span>idadapt_id9899100.00Using index condition</span><br><span class="line"></span><br><span class="line"><span class="section"># 对反例的Explain</span></span><br><span class="line">1SIMPLEtask_resultALL                    3362855411.11Using where</span><br></pre></td></tr></table></figure><blockquote><p>说明<br>task_result表为生产环境的一个表，总数据量为3400万，taskid是一个普通索引列，可见%%这种匹配方式完全无法使用索引，从而进行全表扫描导致效率极低，而正例通过索引查找数据只需要扫描99条数据即可</p></blockquote><h2 id="避免SQL中对where字段进行函数转换或表达式计算"><a href="#避免SQL中对where字段进行函数转换或表达式计算" class="headerlink" title="避免SQL中对where字段进行函数转换或表达式计算"></a>避免SQL中对where字段进行函数转换或表达式计算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 反例</span><br><span class="line">select * from task_result where id + 1 = 15551;</span><br><span class="line"></span><br><span class="line"># 正例</span><br><span class="line">select * from task_result where id = 15550;</span><br><span class="line"></span><br><span class="line">##########################################################################</span><br><span class="line"># 对正例的Explain</span><br><span class="line">1SIMPLEtask_resultconstPRIMARYPRIMARY8const1100.00</span><br><span class="line"></span><br><span class="line"># 对反例的Explain</span><br><span class="line">1SIMPLEtask_resultALL                33631512  100.00Using where</span><br></pre></td></tr></table></figure><blockquote><p> 说明<br>其实在知道了有SQL优化器之后，我个人感觉这种普通的表达式转换应该可以提前进行处理再进行查询，这样一来就可以用到索引了，但是问题又来了，如果mysql优化器可以提前计算出结果，那么写sql语句的人也一定可以提前计算出结果，所以矛盾点在这个地方，导致5.7版本以前的此种情况都无法使用索引吧，未来可能会对其进行优化</p></blockquote><h2 id="使用-ISNULL-来判断是否为-NULL-值"><a href="#使用-ISNULL-来判断是否为-NULL-值" class="headerlink" title="使用 ISNULL()来判断是否为 NULL 值"></a>使用 ISNULL()来判断是否为 NULL 值</h2><p>说明：NULL 与任何值的直接比较都为 NULL</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1） NULL &lt;&gt; NULL 的返回结果是 NULL，而不是 false。 </span></span><br><span class="line"><span class="section"># 2） NULL = NULL 的返回结果是 NULL，而不是 true。 </span></span><br><span class="line"><span class="section"># 3） NULL &lt;&gt; 1 的返回结果是 NULL，而不是 true。</span></span><br></pre></td></tr></table></figure><h2 id="明明有索引为什么还走全表扫描"><a href="#明明有索引为什么还走全表扫描" class="headerlink" title="明明有索引为什么还走全表扫描"></a>明明有索引为什么还走全表扫描</h2><blockquote><p>MYSQL查询优化器针对查询的数据行占总数据量过多时会转化成全表查询</p></blockquote><h2 id="count-还是-count-id"><a href="#count-还是-count-id" class="headerlink" title="count(*) 还是 count(id)"></a>count(*) 还是 count(id)</h2><blockquote><p>【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*)</p></blockquote><p>count(*) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p><p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行</p><h2 id="字段类型不同导致索引失效"><a href="#字段类型不同导致索引失效" class="headerlink" title="字段类型不同导致索引失效"></a>字段类型不同导致索引失效</h2><blockquote><p>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 正例</span></span><br><span class="line">EXPLAIN SELECT * FROM <span class="code">`user_coll`</span> where pid = '1';</span><br><span class="line">type：ref</span><br><span class="line">ref：const</span><br><span class="line">rows:1</span><br><span class="line">Extra:Using index condition</span><br><span class="line"></span><br><span class="line"><span class="section"># 反例</span></span><br><span class="line">EXPLAIN SELECT * FROM <span class="code">`user_coll`</span> where pid = 1;</span><br><span class="line">type：index</span><br><span class="line">ref：NULL</span><br><span class="line">rows:3(总记录数)</span><br><span class="line">Extra:Using where; Using index</span><br></pre></td></tr></table></figure><blockquote><p>说明<br>pid字段有相应索引，且格式为varchar</p></blockquote><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul><li>自建数据表进行测试</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;,</span><br><span class="line">  `name` varchar(255) NOT NULL,</span><br><span class="line">  `class` varchar(255) DEFAULT NULL,</span><br><span class="line">  `page` bigint(20) DEFAULT NULL,</span><br><span class="line">  `status` tinyint(3) unsigned NOT NULL COMMENT &apos;状态：0 正常，1 冻结，2 删除&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4</span><br></pre></td></tr></table></figure><ul><li>插入数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ;;</span><br><span class="line">    CREATE PROCEDURE insertData()</span><br><span class="line">    BEGIN</span><br><span class="line">        declare i int;</span><br><span class="line">        set i = 1 ;</span><br><span class="line">        WHILE (i &lt; 1000000) DO</span><br><span class="line">            INSERT INTO student(`name`,class,`page`,`status`)</span><br><span class="line">                VALUES(CONCAT(&apos;class_&apos;, i),</span><br><span class="line">                    CONCAT(&apos;class_&apos;, i),</span><br><span class="line">                i, (SELECT FLOOR(RAND() * 2)));</span><br><span class="line">            set i = i + 1;</span><br><span class="line">        END WHILE;</span><br><span class="line">        commit;</span><br><span class="line">END;;</span><br><span class="line">CALL insertData();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Explain-诊断&quot;&gt;&lt;a href=&quot;#Explain-诊断&quot; class=&quot;headerlink&quot; title=&quot;Explain 诊断&quot;&gt;&lt;/a&gt;Explain 诊断&lt;/h1&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="MySQL" scheme="http://blog.caoxl.com/tags/MySQL/"/>
    
      <category term="Explain" scheme="http://blog.caoxl.com/tags/Explain/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7下编译安装PHP8</title>
    <link href="http://blog.caoxl.com/2020/06/28/Install-PHP8-In-CentOS7/"/>
    <id>http://blog.caoxl.com/2020/06/28/Install-PHP8-In-CentOS7/</id>
    <published>2020-06-28T08:31:14.000Z</published>
    <updated>2020-06-28T09:54:27.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>CentOS7下编译安装PHP8</p></blockquote><a id="more"></a><h1 id="下载-amp-解压缩"><a href="#下载-amp-解压缩" class="headerlink" title="下载&amp;解压缩"></a>下载&amp;解压缩</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://downloads.php.net/~pollita/php-8.0.0alpha1.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf php-8.0.0alpha1.tar.gz</span><br><span class="line"></span><br><span class="line">cd php-8.0.0alpha1/</span><br></pre></td></tr></table></figure><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/php/php8 \</span><br><span class="line">--with-config-file-path=/usr/local/php/php8 \</span><br><span class="line">--enable-mbstring  \</span><br><span class="line">--enable-ftp  \</span><br><span class="line">--enable-gd   \</span><br><span class="line">--enable-gd-jis-conv \</span><br><span class="line">--enable-mysqlnd \</span><br><span class="line">--enable-pdo   \</span><br><span class="line">--enable-sockets   \</span><br><span class="line">--enable-fpm   \</span><br><span class="line">--enable-xml  \</span><br><span class="line">--enable-soap  \</span><br><span class="line">--enable-pcntl   \</span><br><span class="line">--enable-cli   \</span><br><span class="line">--with-openssl  \</span><br><span class="line">--with-mysqli=mysqlnd   \</span><br><span class="line">--with-pdo-mysql=mysqlnd   \</span><br><span class="line">--with-pear   \</span><br><span class="line">--with-zlib  \</span><br><span class="line">--with-iconv  \</span><br><span class="line">--with-curl  \</span><br><span class="line">;</span><br></pre></td></tr></table></figure><ul><li>输出:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">| License:                                                           |</span><br><span class="line">| This software is subject to the PHP License, available in this     |</span><br><span class="line">| distribution in the file LICENSE. By continuing this installation  |</span><br><span class="line">| process, you are bound by the terms of this license agreement.     |</span><br><span class="line">| If you do not agree with the terms of this license, you must abort |</span><br><span class="line">| the installation process at this point.                            |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line"></span><br><span class="line">Thank you for using PHP.</span><br></pre></td></tr></table></figure><blockquote><p>编译错误, 谷歌一下.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li>复制配置文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp php.ini-production /usr/local/php/php8/php.ini</span><br></pre></td></tr></table></figure><ul><li>打开错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vim /usr/local/php/php8/php.ini</span><br><span class="line">display_errors = On</span><br></pre></td></tr></table></figure><ul><li>复制fpm的启动脚本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ./sapi/fpm/init.d.php-fpm /usr/local/php/php8/bin/php-fpm-8</span><br></pre></td></tr></table></figure><ul><li>增加执行权限</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><ul><li>设置软连接</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># php-fpm</span><br><span class="line">ln -s /usr/local/php/php8/bin/php-fpm-8 /etc/init.d/php-fpm-8</span><br><span class="line"># php.ini</span><br><span class="line">ln -s /usr/local/php/php8/etc/php.ini /etc/php/php8.ini</span><br></pre></td></tr></table></figure><ul><li>修改php-fpm配置文件：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/php/php8/etc</span><br><span class="line">cp php-fpm.conf/default php-fpm.conf</span><br><span class="line">vim php-fpm.conf</span><br><span class="line"># 去掉 pid = run/php-fpm.pid 前面的分号</span><br><span class="line"># 修改启动用户：</span><br><span class="line">user=www-www</span><br><span class="line">group=www-www</span><br></pre></td></tr></table></figure><h1 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h1><h2 id="No-package-39-oniguruma-39-found"><a href="#No-package-39-oniguruma-39-found" class="headerlink" title="No package &#39;oniguruma&#39; found"></a><code>No package &#39;oniguruma&#39; found</code></h2><ul><li><ol><li>yum安装rpm包</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/o/oniguruma-5.9.5-3.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/o/oniguruma-devel-5.9.5-3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>备用下载</p><ul><li><code>oniguruma</code>：<code>http://down.24kplus.com/linux/oniguruma/oniguruma-6.7.0-1.el7.x86_64.rpm</code></li><li><code>oniguruma-devel</code>：<code>http://down.24kplus.com/linux/oniguruma/oniguruma-devel-6.7.0-1.el7.x86_64.rpm</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.24kplus.com/linux/1614.html" target="_blank" rel="noopener">CentOS 7/8 安装 oniguruma 和 oniguruma-devel</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CentOS7下编译安装PHP8&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://blog.caoxl.com/tags/PHP/"/>
    
      <category term="PHP8" scheme="http://blog.caoxl.com/tags/PHP8/"/>
    
  </entry>
  
  <entry>
    <title>深入MySQL锁</title>
    <link href="http://blog.caoxl.com/2020/06/23/Deep-Going-MySQL-Lock/"/>
    <id>http://blog.caoxl.com/2020/06/23/Deep-Going-MySQL-Lock/</id>
    <published>2020-06-23T03:16:11.000Z</published>
    <updated>2020-06-23T07:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>高并发场景下锁机制是怎么保证数据的一致性的和事务隔离性的?</p></blockquote><a id="more"></a><h1 id="锁种类"><a href="#锁种类" class="headerlink" title="锁种类"></a>锁种类</h1><blockquote><ul><li>按照<strong>锁的粒度</strong>划分：<code>表锁</code>、<code>页锁</code>、<code>行锁</code>；</li><li>按照<strong>使用的方式</strong>划分：<code>共享锁</code>和<code>排它锁</code>；</li><li>按照<strong>思想</strong>划分：<code>乐观锁</code>和<code>悲观锁</code>。</li></ul></blockquote><h2 id="按锁的粒度划分"><a href="#按锁的粒度划分" class="headerlink" title="按锁的粒度划分"></a>按锁的粒度划分</h2><ul><li><code>「表锁」</code>是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。</li></ul><p>Mysql中<code>「MyISAM储存引擎就支持表锁」</code>，MyISAM的表锁模式有两种：<code>「表共享读锁」</code>和<code>「表独占写锁」</code>。</p><p>当一个线程获取到MyISAM表的读锁的时候，会阻塞其他用户对该表的写操作，但是不会阻塞其它用户对该用户的读操作。</p><p>相反的，当一个线程获取到MyISAM表的写锁的时候，就会阻塞其它用户的读写操作对其它的线程具有排它性。</p><ul><li><p><code>「页锁」</code>的粒度是介于行锁和表锁之间的一种锁，因为页锁是在BDB中支持的一种锁机制，也很少被人提及和使用，所以这里制作概述，不做详解。</p></li><li><p><code>「行锁」</code>是粒度最小的锁机制，行锁的加锁开销性能大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。</p></li></ul><p>行锁是InnoDB默认的支持的锁机制，MyISAM不支持行锁，这个也是InnoDB和MyISAM的区别之一。</p><h2 id="按锁的使用方式划分"><a href="#按锁的使用方式划分" class="headerlink" title="按锁的使用方式划分"></a>按锁的使用方式划分</h2><blockquote><p>行锁在使用的方式上可以划分为：「<code>共享读锁（S锁）</code>「和」<code>排它写锁（X锁）</code>」。</p></blockquote><p>当一个事务对Mysql中的一条数据行加上了<code>S锁</code>，当前事务不能修改该行数据只能执行度操作，其他事务只能对该行数据加S锁不能加X锁。</p><p>若是一个事务对一行数据加了<code>X锁</code>，该事物能够对该行数据执行读和写操作，其它事务不能对该行数据加任何的锁，既不能读也不能写。</p><h2 id="按锁的思想划分"><a href="#按锁的思想划分" class="headerlink" title="按锁的思想划分"></a>按锁的思想划分</h2><p>「悲观锁和乐观锁是在很多框架都存在的一种思想，不要狭义地认为它们是某一种框架的锁机制」。</p><p>数据库管理系统中为了控制并发，保证在多个事务执行时的数据一致性以及事务的隔离性，使用悲观锁和乐观锁来解决并发场景下的问题。</p><p>Mysql中「<strong>悲观锁的实现是基于Mysql自身的锁机制实现，而乐观锁需要程序员自己去实现的锁机制</strong>」，最常见的乐观锁实现就锁机制是「<strong>使用版本号实现</strong>」。</p><h1 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h1><p>MyISAM中默认支持的表级锁有两种：<strong>「共享读锁」</strong> 和 <strong>「独占写锁」</strong>。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。</p><p>Mysql中平时读写操作都是隐式的进行加锁和解锁操作，Mysql已经自动帮我们实现加锁和解锁操作了，若是想要测试锁机制，我们就要显示的自己控制锁机制。</p><p>Mysql中可以通过以下sql来显示的在事务中显式的进行加锁和解锁操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 显式的添加表级读锁</span><br><span class="line">LOCK TABLE 表名 READ</span><br><span class="line"></span><br><span class="line">// 显示的添加表级写锁</span><br><span class="line">LOCK TABLE 表名 WRITE</span><br><span class="line"></span><br><span class="line">// 显式的解锁（当一个事务commit的时候也会自动解锁）</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>下面我们就来测试一下MyISAM中的表级锁机制，首先创建一个测试表<code>employee</code> ，这里要指定存储引擎为MyISAM，并插入两条测试数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 创建一个测试表</span><br><span class="line">CREATE TABLE IF NOT EXISTS employee (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    name VARCHAR(40),</span><br><span class="line">    money INT</span><br><span class="line">)ENGINE MyISAM;</span><br><span class="line"></span><br><span class="line">-- 插入两条测试数据</span><br><span class="line">INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 8888);</span><br><span class="line">INSERT INTO employee(name, money) VALUES(&apos;lc&apos;, 9999);</span><br></pre></td></tr></table></figure><p>查看一下，表结果如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee;</span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  1 | caoxl |  8888 |</span><br><span class="line">|  2 | lc    |  9999 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h2 id="MyISAM表级写锁"><a href="#MyISAM表级写锁" class="headerlink" title="MyISAM表级写锁"></a>MyISAM表级写锁</h2><ul><li><ol><li>与此同时再开启一个session窗口，然后在第一个窗口执行下面的sql，在session1中给表添加写锁：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; LOCK TABLE employee WRITE;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>可以在session2中进行查询或者插入、更新该表数据，可以发现都会处于等待状态，也就是session1锁住了整个表，导致session2只能等待：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee;</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>在session1中进行查询、插入、更新数据，都可以执行成功：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 插入</span><br><span class="line">MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;caolx&apos;, 1111);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">-- 更新</span><br><span class="line">MariaDB [test]&gt; UPDATE employee set name=&apos;caoxllc&apos; where id=1; </span><br><span class="line">Query OK, 1 row affected (0.14 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">-- 查询</span><br><span class="line">MariaDB [test]&gt; SELECT * FROM employee;</span><br><span class="line">+----+---------+-------+</span><br><span class="line">| id | name    | money |</span><br><span class="line">+----+---------+-------+</span><br><span class="line">|  1 | caoxllc |  8888 |</span><br><span class="line">|  2 | lc      |  9999 |</span><br><span class="line">|  3 | caolx   |  1111 |</span><br><span class="line">+----+---------+-------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p><strong>「总结：」</strong> 从上面的测试结果显示 <strong>「当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作」</strong>。</p><h2 id="MyISAM表级共享读锁"><a href="#MyISAM表级共享读锁" class="headerlink" title="MyISAM表级共享读锁"></a>MyISAM表级共享读锁</h2><ul><li><ol><li>接下来测试一下表级共享读锁，同样还是利用上面的测试数据，第一步还是在session1给表加读锁。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; LOCK TABLE employee read;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>然后在session1中尝试进行插入、更新数据，发现都会报错，只能查询数据。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 查询</span><br><span class="line">MariaDB [test]&gt; select * from employee;</span><br><span class="line">+----+---------+-------+</span><br><span class="line">| id | name    | money |</span><br><span class="line">+----+---------+-------+</span><br><span class="line">|  1 | caoxllc |  8888 |</span><br><span class="line">|  2 | lc      |  9999 |</span><br><span class="line">|  3 | caolx   |  1111 |</span><br><span class="line">+----+---------+-------+</span><br><span class="line">3 rows in set (7 min 12.28 sec)</span><br><span class="line">-- 插入</span><br><span class="line">MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;lxlc&apos;, 2222);</span><br><span class="line">ERROR 1099 (HY000): Table &apos;employee&apos; was locked with a READ lock and can&apos;t be updated</span><br><span class="line">-- 更新</span><br><span class="line">MariaDB [test]&gt; UPDATE employee set name=&apos;lxlc&apos; where id=1;</span><br><span class="line">ERROR 1099 (HY000): Table &apos;employee&apos; was locked with a READ lock and can&apos;t be updated</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>最后在session2中尝试进行插入、更新数据，程序都会进入等待状态，只能查询数据，直到session1解锁表session2才能插入、更新数据。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;lxlc&apos;, 2222);</span><br></pre></td></tr></table></figure><p><strong>「总结：」</strong> 从上面的测试结果显示 <strong>「当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁」</strong>。</p><h2 id="MyISAM表级锁竞争情况"><a href="#MyISAM表级锁竞争情况" class="headerlink" title="MyISAM表级锁竞争情况"></a>MyISAM表级锁竞争情况</h2><p>MyISAM存储引擎中，可以通过查询变量来查看并发场景锁的争夺情况，具体执行下面的sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; show status like &apos;table%&apos;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Table_locks_immediate | 37    |</span><br><span class="line">| Table_locks_waited    | 2     |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">2 rows in set (0.27 sec)</span><br></pre></td></tr></table></figure><p>主要是查看<code>table_locks_waited</code>和<code>table_locks_immediate</code>的值的大小分析锁的竞争情况。</p><ul><li><code>Table_locks_immediate</code>: 表示能够立即获得表级锁的锁请求次数；</li><li><code>Table_locks_waited</code>: 表示不能立即获取表级锁而需要等待的锁请求次数分析，<strong>「值越大竞争就越严重」</strong>。</li></ul><h2 id="并发插入"><a href="#并发插入" class="headerlink" title="并发插入"></a>并发插入</h2><p>通过上面的操作演示，详细的说明了表级共享锁和表级写锁的特点。但是在平时的执行sql的时候，这些 <strong>「解锁和释放锁都是Mysql底层隐式的执行的」</strong>。</p><p>上面的演示只是为了证明显式的执行事务的过程共享锁和表级写锁的加锁和解锁的特点，实际并不会这么做的。</p><p>在我们平时执行select语句的时候就会隐式的加读锁，执行增、删、改的操作时就会隐式的执行加写锁。<br>MyISAM存储引擎中，虽然读写操作是串行化的，但是它也支持并发插入，这个需要设置内部变量<code>concurrent_insert</code>的值。</p><p>它的值有三个值<code>0</code>、<code>1</code>、<code>2</code>。可以通过以下的sql查看<code>concurrent_insert</code>的默认值为 <strong>「AUTO(或者1)」</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; show variables like &quot;%concurrent_insert&quot;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| concurrent_insert | AUTO  |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">1 row in set (0.25 sec)</span><br></pre></td></tr></table></figure><p><code>concurrent_insert</code>的值为:</p><ul><li><code>NEVER (or 0)</code>表示不支持比并发插入；</li><li><code>AUTO(或者1）</code>表示在MyISAM表中没有被删除的行，运行另一个线程从表尾插入数据；</li><li><code>ALWAYS (or 2)</code>表示不管是否有删除的行，都允许在表尾插入数据。</li></ul><h2 id="锁调度"><a href="#锁调度" class="headerlink" title="锁调度"></a>锁调度</h2><p>MyISAM存储引擎中，<strong>「假如同时一个读请求，一个写请求过来的话，它会优先处理写请求」</strong>，因为MyISAM存储引擎中认为<strong>写请求比读请求重要</strong>。</p><p>这样就会导致，<strong>「假如大量的读写请求过来，就会导致读请求长时间的等待，或者”线程饿死”，因此MyISAM不适合运用于大量读写操作的场景」</strong>，这样会导致长时间读取不到用户数据，用户体验感极差。</p><p>当然可以通过设置<code>low-priority-updates</code>参数，设置请求链接的优先级，使得Mysql优先处理读请求。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><blockquote><p>InnoDB和MyISAM不同的是，<strong>InnoDB支持「行锁」和「事务」</strong></p></blockquote><p>InnoDB中除了有<code>「表锁」</code>和<code>「行级锁」</code>的概念，还有<code>Gap Lock（间隙锁）</code>、<code>Next-key Lock锁</code>，<strong>「间隙锁主要用于范围查询的时候，锁住查询的范围，并且间隙锁也是解决幻读的方案」</strong>。</p><p>InnoDB中的行级锁是 <strong>「对索引加的锁，在不通过索引查询数据的时候，InnoDB就会使用表锁」</strong>。</p><p><strong>「但是通过索引查询的时候是否使用索引，还要看Mysql的执行计划」</strong>，Mysql的优化器会判断是一条sql执行的最佳策略。</p><p>若是Mysql觉得执行索引查询还不如全表扫描速度快，那么Mysql就会使用全表扫描来查询，这是即使sql语句中使用了索引，最后还是执行为全表扫描，加的是表锁。</p><h2 id="InnoDB行锁和表锁"><a href="#InnoDB行锁和表锁" class="headerlink" title="InnoDB行锁和表锁"></a>InnoDB行锁和表锁</h2><p>InnoDB的行锁也是分为行级 <strong>「共享读锁（S锁）「和」排它写锁（X锁）」</strong>，原理特点和MyISAM的表级锁两种模式是一样的。</p><p>若想显式的给表加行级读锁和写锁，可以执行下面的sql语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 给查询sql显示添加读锁</span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line">// 给查询sql显示添加写锁</span><br><span class="line">select ... for update；</span><br></pre></td></tr></table></figure><ul><li><ol><li>下面我们直接进入锁机制的测试阶段，还是创建一个测试表，并插入两条数据：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 先把原来的MyISAM表给删除了</span><br><span class="line">DROP TABLE IF EXISTS employee;</span><br><span class="line">CREATE TABLE IF NOT EXISTS employee (</span><br><span class="line">    id INT PRIMARY KEY auto_increment,</span><br><span class="line">    name VARCHAR(40),</span><br><span class="line">    money INT</span><br><span class="line">)ENGINE INNODB;</span><br><span class="line"></span><br><span class="line">// 插入测试数据</span><br><span class="line">INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 1000);</span><br><span class="line">INSERT INTO employee(name, money) VALUES(&apos;lc&apos;, 2000);</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>创建的表中可以看出对表中的字段只有id添加了主键索引，接着就是在session1窗口执行<code>begin</code>开启事务，并执行下面的sql语句：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select * from employee where name=&apos;caoxl&apos; for update;</span><br><span class="line">MariaDB [test]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">-- 使用非索引字段查询，并显式的添加写锁</span><br><span class="line">MariaDB [test]&gt; select * from employee where name=&apos;caolx&apos; for update;</span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  1 | caolx |  1000 |</span><br><span class="line">|  2 | caolx |  2000 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>然后在session2中执行update语句，上面查询的式id=1的数据行，下面update的是id=1的数据行，会发现程序也会进入等待状态：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; update employee set name=&apos;caoxl&apos; where id = 1;</span><br></pre></td></tr></table></figure><p>可见若是 <strong>「使用非索引查询，直接就是使用的表级锁」</strong>，锁住了整个表。</p><ul><li><ol start="4"><li>若是session1使用的是id来查询，如下所示：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee where id=&apos;1&apos; for update;  </span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  1 | caolx |  1000 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">1 row in set (0.14 sec)</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>那么session2是可以成功update其它数据行的，但是这里我建议使用数据量大的表进行测试，因为前面我说过了 <strong>「是否执行索引还得看Mysql的执行计划，对于一些小表的操作，可能就直接使用全表扫描」</strong>。</li></ol></li></ul><ul><li><ol start="6"><li>还有一种情况就是：假如我们给name字段也加上了普通索引，那么通过普通索引来查询数据，并且查询到多行数据，拿它是锁这多行数据还是锁整个表呢？</li></ol></li></ul><p>下面我们来测试一下，首先给「name字段添加普通索引」，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; alter table employee add index index_name(name);</span><br><span class="line">Query OK, 0 rows affected (0.22 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><ul><li><ol start="7"><li>并插入一条新的数据name值与id=2的值相同，并显式的加锁，如下所示：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 3000);</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [test]&gt; select * from employee;                        </span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  1 | caolx |  1000 |</span><br><span class="line">|  2 | caoxl |  2000 |</span><br><span class="line">|  3 | caoxl |  3000 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [test]&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [test]&gt; select * from employee where name=&apos;caoxl&apos; for update;</span><br><span class="line">+----+-------+-------+</span><br><span class="line">| id | name  | money |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">|  2 | caoxl |  2000 |</span><br><span class="line">|  3 | caoxl |  3000 |</span><br><span class="line">+----+-------+-------+</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><ul><li><ol start="8"><li>当update其它数据行name值不是<code>caoxl</code>的也会进入等待状态，并且通过explain来查看是否name=’caoxl’有执行索引，可以看到sql语句是有执行索引条件的。</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; MariaDB [test]&gt; explain update employee set name=&apos;lc&apos; where id = 1;</span><br><span class="line">+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id   | select_type | table    | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|    1 | SIMPLE      | employee | range | PRIMARY       | PRIMARY | 4       | NULL |    1 | Using where |</span><br><span class="line">+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>执行非索引条件查询执行的是表锁。</li><li>执行索引查询是否是加行锁，还得看Mysql的执行计划，可以通过explain关键字来查看。</li><li>用普通键索引的查询，遇到索引值相同的，也会对其他的操作数据行的产生影响。</li></ul><h2 id="InnoDB间隙锁"><a href="#InnoDB间隙锁" class="headerlink" title="InnoDB间隙锁"></a>InnoDB间隙锁</h2><p>当我们使用范围条件查询而不是等值条件查询的时候，InnoDB就会给符合条件的范围索引加锁，在条件范围内并不存的记录就叫做”间隙（GAP）”</p><p>大家大概都知道在事务的四大隔离级别中，不可重复读会产生幻读的现象，只能通过提高隔离级别到串行化来解决幻读现象。</p><p>但是Mysql中的不可重复是已经解决了幻读问题，它通过引入间隙锁的实现来解决幻读，通过给符合条件的间隙加锁，防止再次查询的时候出现新数据产生幻读的问题。</p><p>例如我们执行下面的sql语句，就会对id大于100的记录加锁，在id&gt;100的记录中肯定是有不存在的间隙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from  employee where id &gt; 100 for update;</span><br></pre></td></tr></table></figure><ul><li><ol><li>接着来测试间隙锁，新增一个字段num，并将num添加为普通索引、修改之前的数据使得num之间的值存在间隙，操作如下sql所示：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table employee add num int not null default 0;</span><br><span class="line">update employee set num = 1 where id = 1;</span><br><span class="line">update employee set num = 1 where id = 2;</span><br><span class="line">update employee set num = 3 where id = 3;</span><br><span class="line">insert into employee values(4,&apos;kris&apos;,4000,5);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee;                        </span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">| id | name  | money | num |</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">|  1 | caolx |  1000 |   1 |</span><br><span class="line">|  2 | caoxl |  2000 |   1 |</span><br><span class="line">|  3 | caoxl |  3000 |   3 |</span><br><span class="line">|  4 | kris  |  4000 |   5 |</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>接着在session1的窗口开启事务，并执行下面操作：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [test]&gt; select * from employee where num=3 for update;</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">| id | name  | money | num |</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">|  3 | caoxl |  3000 |   3 |</span><br><span class="line">+----+-------+-------+-----+</span><br><span class="line">1 row in set (0.05 sec)</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>同时打开窗口session2，并执行新增语句：</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into employee values(5,&apos;ceshi&apos;,5000,2);  // 程序出现等待</span><br><span class="line">insert into employee values(5,&apos;ceshi&apos;,5000,4);  // 程序出现等待</span><br><span class="line">insert into employee values(5,&apos;ceshi&apos;,5000,6);  // 新增成功</span><br><span class="line">insert into employee values(6,&apos;ceshi&apos;,5000,0);  // 新增成功</span><br></pre></td></tr></table></figure><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁在InnoDB中才会出现死锁，MyISAM是不会出现死锁，因为MyISAM支持的是表锁，一次性获取了所有得锁，其它的线程只能排队等候。</p><p>而InnoDB默认支持行锁，获取锁是分步的，并不是一次性获取所有得锁，因此在锁竞争的时候就会出现死锁的情况。</p><p>虽然InnoDB会出现死锁，但是并不影响InnoDB最受欢成为迎的存储引擎，MyISAM可以理解为串行化操作，读写有序，因此支持的并发性能低下。</p><h2 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h2><p>首先要解决死锁问题，在程序的设计上，当发现程序有高并发的访问某一个表时，尽量对该表的执行操作串行化，或者锁升级，一次性获取所有的锁资源。</p><p>然后也可以设置参数<code>innodb_lock_wait_timeout</code>，超时时间，并且将参数<code>innodb_deadlock_detect</code>打开，当发现死锁的时候，自动回滚其中的某一个事务。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面详细的介绍了<code>MyISAM</code>和<code>InnoDB</code>两种存储引擎的锁机制的实现，并进行了测试。</p><p><code>MyISAM</code>的表锁分为两种模式：<strong>「共享读锁」</strong> 和 <strong>「排它写锁」</strong>。获取的读锁的线程对该数据行只能读，不能修改，其它线程也只能对该数据行加读锁。</p><p>获取到写锁的线程对该数据行既能读也能写，对其他线程对该数据行的读写具有排它性。</p><p><strong>MyISAM中默认写优先于读操作</strong>，因此<code>MyISAM</code>一般不适合运用于大量读写操作的程序中。</p><p><code>InnoDB</code>的行锁虽然会出现死锁的可能，但是<code>InnoDB</code>的支持的并发性能比<code>MyISAM</code>好，行锁的粒度最小，一定的方法和措施可以解决死锁的发生，极大的发挥<code>InnoDB</code>的性能。</p><p><code>InnoDB</code>中引入了<strong>间隙锁</strong>的概念来决解出现幻读的问题，也引入事务的特性，通过事务的四种隔离级别，来降低锁冲突，提高并发性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;高并发场景下锁机制是怎么保证数据的一致性的和事务隔离性的?&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="MySQL锁" scheme="http://blog.caoxl.com/tags/MySQL%E9%94%81/"/>
    
      <category term="共享锁" scheme="http://blog.caoxl.com/tags/%E5%85%B1%E4%BA%AB%E9%94%81/"/>
    
      <category term="排他锁" scheme="http://blog.caoxl.com/tags/%E6%8E%92%E4%BB%96%E9%94%81/"/>
    
      <category term="行锁" scheme="http://blog.caoxl.com/tags/%E8%A1%8C%E9%94%81/"/>
    
      <category term="表锁" scheme="http://blog.caoxl.com/tags/%E8%A1%A8%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 面试题 II</title>
    <link href="http://blog.caoxl.com/2020/06/18/MySQL-Interview-Questions-II/"/>
    <id>http://blog.caoxl.com/2020/06/18/MySQL-Interview-Questions-II/</id>
    <published>2020-06-18T06:19:56.000Z</published>
    <updated>2020-06-18T08:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="非关系型数据库和关系型数据库区别，优势比较"><a href="#非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="非关系型数据库和关系型数据库区别，优势比较"></a>非关系型数据库和关系型数据库区别，优势比较</h1><a id="more"></a><h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><p>非关系型数据库（感觉翻译不是很准确）称为 <code>NoSQL</code>，也就是 Not Only SQL，不仅仅是 SQL。非关系型数据库不需要写一些复杂的 SQL 语句，其内部存储方式是以 <code>key-value</code> 的形式存在可以把它想象成电话本的形式，每个人名（key）对应电话（value）。常见的非关系型数据库主要有 <strong>Hbase</strong>、<strong>Redis</strong>、<strong>MongoDB</strong> 等。非关系型数据库不需要经过 SQL 的重重解析，所以性能很高；非关系型数据库的可扩展性比较强，数据之间没有耦合性，遇见需要新加字段的需求，就直接增加一个 <code>key-value</code> 键值对即可。</p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>关系型数据库以<code>表格</code>的形式存在，以<code>行</code>和<code>列</code>的形式存取数据，关系型数据库这一系列的行和列被称为表，无数张表组成了<code>数据库</code>，常见的关系型数据库有 <strong>Oracle</strong>、<strong>DB2</strong>、<strong>Microsoft SQL Server</strong>、<strong>MySQL</strong>等。关系型数据库能够支持复杂的 SQL 查询，能够体现出数据之间、表之间的关联关系；关系型数据库也支持事务，便于提交或者回滚。</p><h1 id="MySQL-事务四大特性"><a href="#MySQL-事务四大特性" class="headerlink" title="MySQL 事务四大特性"></a>MySQL 事务四大特性</h1><p>一说到 MySQL 事务，你肯定能想起来四大特性：<code>原子性</code>、<code>一致性</code>、<code>隔离性</code>、<code>持久性</code>，下面再对这事务的四大特性做一个描述</p><ul><li><code>原子性(Atomicity)</code>: 原子性指的就是 MySQL 中的包含事务的操作要么<code>全部成功</code>、要么全部<code>失败回滚</code>，因此事务的操作如果成功就必须要全部应用到数据库，如果操作失败则不能对数据库有任何影响。</li><li><code>一致性(Consistency)</code>：一致性指的是一个事务在执行前后其状态一致。比如 A 和 B 加起来的钱一共是 1000 元，那么不管 A 和 B 之间如何转账，转多少次，事务结束后两个用户的钱加起来还得是 1000，这就是事务的一致性。</li><li><code>持久性(Durability)</code>: 持久性指的是一旦事务提交，那么发生的改变就是永久性的，即使数据库遇到特殊情况比如故障的时候也不会产生干扰。</li><li><code>隔离性(Isolation)</code>：隔离性需要重点说一下，当多个事务同时进行时，就有可能出现<code>脏读(dirty read)</code>、<code>不可重复读(non-repeatable read)</code>、<code>幻读(phantom read)</code> 的情况，为了解决这些并发问题，提出了隔离性的概念。</li></ul><h1 id="MySQL-常见存储引擎的区别"><a href="#MySQL-常见存储引擎的区别" class="headerlink" title="MySQL 常见存储引擎的区别"></a>MySQL 常见存储引擎的区别</h1><p>MySQL 常见的存储引擎，可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW ENGINES;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">9 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure><p>可以看到，InnoDB 是 MySQL 默认支持的存储引擎，支持<strong>事务、行级锁定和外键</strong>。</p><h2 id="MyISAM-存储引擎的特点"><a href="#MyISAM-存储引擎的特点" class="headerlink" title="MyISAM 存储引擎的特点"></a>MyISAM 存储引擎的特点</h2><p>在 5.1 版本之前，MyISAM 是 MySQL 的默认存储引擎，MyISAM 并发性比较差，使用的场景比较少，主要特点是</p><ul><li>不支持<code>事务</code>操作，ACID 的特性也就不存在了，这一设计是为了性能和效率考虑的。</li><li>不支持<code>外键</code>操作，如果强行增加外键，MySQL 不会报错，只不过外键不起作用。</li><li>MyISAM 默认的锁粒度是<code>表级锁</code>，所以并发性能比较差，加锁比较快，锁冲突比较少，不太容易发生死锁的情况。</li><li>MyISAM 会在磁盘上存储三个文件，文件名和表名相同，扩展名分别是 <code>.frm(存储表定义)</code>、<code>.MYD(MYData,存储数据)</code>、<code>MYI(MyIndex,存储索引)</code>。这里需要特别注意的是 MyISAM 只缓存<code>索引文件</code>，并不缓存数据文件。</li><li>MyISAM 支持的索引类型有 <code>全局索引(Full-Text)</code>、<code>B-Tree 索引</code>、<code>R-Tree 索引</code><ul><li><code>Full-Text 索引</code>：它的出现是为了解决针对文本的模糊查询效率较低的问题。</li><li><code>B-Tree 索引</code>：所有的索引节点都按照平衡树的数据结构来存储，所有的索引数据节点都在叶节点</li><li><code>R-Tree索引</code>：它的存储方式和 B-Tree 索引有一些区别，主要设计用于存储空间和多维数据的字段做索引,目前的 MySQL 版本仅支持 geometry 类型的字段作索引，相对于 BTREE，RTREE 的优势在于范围查找。</li></ul></li><li>数据库所在主机如果宕机，MyISAM 的数据文件容易损坏，而且难以恢复。</li><li>增删改查性能方面：SELECT 性能较高，适用于查询较多的情况</li></ul><h2 id="InnoDB-存储引擎的特点"><a href="#InnoDB-存储引擎的特点" class="headerlink" title="InnoDB 存储引擎的特点"></a>InnoDB 存储引擎的特点</h2><p>自从 MySQL 5.1 之后，默认的存储引擎变成了 InnoDB 存储引擎，相对于 MyISAM，InnoDB 存储引擎有了较大的改变，它的主要特点是</p><ul><li>支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是<code>可重复读(repetable-read)</code>、通过MVCC（并发版本控制）来实现的。能够解决<code>脏读</code>和<code>不可重复读</code>的问题。</li><li>InnoDB 支持外键操作。</li><li>InnoDB 默认的锁粒度<code>行级锁</code>，并发性能比较好，会发生死锁的情况。</li><li>和 MyISAM 一样的是，InnoDB 存储引擎也有 <code>.frm</code>文件存储表结构 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。</li><li>InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。</li><li>InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。</li><li>增删改查性能方面，如果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。</li></ul><h2 id="MyISAM-和-InnoDB-存储引擎的对比"><a href="#MyISAM-和-InnoDB-存储引擎的对比" class="headerlink" title="MyISAM 和 InnoDB 存储引擎的对比"></a>MyISAM 和 InnoDB 存储引擎的对比</h2><ul><li><code>锁粒度方面</code>：由于锁粒度不同，InnoDB 比 MyISAM 支持更高的并发；InnoDB 的锁粒度为行锁、MyISAM 的锁粒度为表锁、行锁需要对每一行进行加锁，所以锁的开销更大，但是能解决脏读和不可重复读的问题，相对来说也更容易发生死锁</li><li><code>可恢复性上</code>：由于 InnoDB 是有事务日志的，所以在产生由于数据库崩溃等条件后，可以根据日志文件进行恢复。而 MyISAM 则没有事务日志。</li><li><code>查询性能上</code>：MyISAM 要优于 InnoDB，因为 InnoDB 在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而 MyISAM 可以直接定位到数据所在的内存地址，可以直接找到数据。</li><li><code>表结构文件上</code>： MyISAM 的表结构文件包括：<code>.frm</code>(表结构定义),<code>.MYI</code>(索引),<code>.MYD</code>(数据)；而 InnoDB 的表数据文件为:<code>.ibd</code>和<code>.frm</code>(表结构定义)；</li></ul><h1 id="MySQL-基础架构"><a href="#MySQL-基础架构" class="headerlink" title="MySQL 基础架构"></a>MySQL 基础架构</h1><p><img src="http://caoxl.com/imgs/mysql.jpg" alt="mysql"></p><p>大致上来说，MySQL 可以分为<code>Server</code>层和<code>存储引擎</code>层。</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器，包括大多数 MySQL 中的核心功能，所有跨存储引擎的功能也在这一层实现，包括<strong>存储过程、触发器、视图</strong>等。</p><p>存储引擎层包括 MySQL 常见的存储引擎，包括 <strong>MyISAM、InnoDB 和 Memory</strong> 等，最常用的是 InnoDB，也是现在 MySQL 的默认存储引擎。存储引擎也可以在创建表的时候手动指定，比如下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t (i INT) ENGINE = &lt;Storage Engine&gt;;</span><br></pre></td></tr></table></figure><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>首先需要在 MySQL 客户端登陆才能使用，所以需要一个<code>连接器</code>来连接用户和 MySQL 数据库，我们一般是使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p 密码</span><br></pre></td></tr></table></figure><p>来进行 MySQL 登陆，和服务端建立连接。在完成 <code>TCP 握手</code> 后，连接器会根据你输入的用户名和密码验证你的登录身份。如果用户名或者密码错误，MySQL 就会提示 <strong>Access denied for user</strong>，来结束执行。如果登录成功后，MySQL 会根据权限表中的记录来判定你的权限。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>连接完成后，你就可以执行 SQL 语句了，这行逻辑就会来到第二步：<code>查询缓存</code>。</p><p>MySQL 在得到一个执行请求后，会首先去 <code>查询缓存</code> 中查找，是否执行过这条 SQL 语句，之前执行过的语句以及结果会以 <code>key-value</code> 对的形式，被直接放在内存中。key 是查询语句，value 是查询的结果。如果通过 key 能够查找到这条 SQL 语句，就直接返回 SQL 的执行结果。</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果就会被放入查询缓存中。可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，效率会很高。</p><p><img src="http://caoxl.com/imgs/mysql_sql.jpg" alt="SQL 查询"></p><p>但是查询缓存不建议使用</p><p>为什么呢？因为只要在 MySQL 中对某一张表执行了更新操作，那么所有的查询缓存就会失效，对于更新频繁的数据库来说，查询缓存的命中率很低。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询，就开始执行真正的 SQL 语句。</p><ul><li>首先，MySQL 会根据你写的 <code>SQL</code> 语句进行解析，分析器会先做 <code>词法分析</code>，你写的 SQL 就是由多个字符串和空格组成的一条 <code>SQL</code> 语句，MySQL 需要识别出里面的字符串是什么，代表什么。</li><li>然后进行 <code>语法分析</code>，根据词法分析的结果， 语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果 <code>SQL</code> 语句不正确，就会提示 <strong>You have an error in your SQL syntax</strong></li></ul><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过分析器的词法分析和语法分析后，你这条 <code>SQL</code> 就<code>合法</code>了，MySQL 就知道你要做什么了。但是在执行前，还需要进行优化器的处理，优化器会判断你使用了哪种索引，使用了何种连接，优化器的作用就是确定效率最高的执行方案。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你的 <code>SQL</code> 语句<code>是否合法</code>，你想要做什么操作，通过优化器知道了该怎么做效率最高，然后就进入了执行阶段，开始执行这条 <code>SQL</code> 语句</p><p>在执行阶段，MySQL 首先会判断你有没有执行这条语句的权限，没有权限的话，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。对于有索引的表，执行的逻辑也差不多。</p><p>至此，MySQL 对于一条语句的执行过程也就完成了。</p><h1 id="SQL-的执行顺序"><a href="#SQL-的执行顺序" class="headerlink" title="SQL 的执行顺序"></a>SQL 的执行顺序</h1><p>我们在编写一个查询语句的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">    &lt; select_list &gt;</span><br><span class="line">FROM</span><br><span class="line">    &lt; left_table &gt; &lt; join_type &gt;</span><br><span class="line">JOIN &lt; right_table &gt; ON &lt; join_condition &gt;</span><br><span class="line">WHERE</span><br><span class="line">    &lt; where_condition &gt;</span><br><span class="line">GROUP BY</span><br><span class="line">    &lt; group_by_list &gt;</span><br><span class="line">HAVING</span><br><span class="line">    &lt; having_condition &gt;</span><br><span class="line">ORDER BY</span><br><span class="line">    &lt; order_by_condition &gt;</span><br><span class="line">LIMIT &lt; limit_number &gt;</span><br></pre></td></tr></table></figure><h2 id="FROM-连接"><a href="#FROM-连接" class="headerlink" title="FROM 连接"></a>FROM 连接</h2><p>首先，对 SELECT 语句执行查询时，对 <code>FROM</code> 关键字两边的表执行连接，会形成<code>笛卡尔积</code>，这时候会产生一个虚表<strong>VT1</strong>(<code>virtual table</code>)</p><blockquote><p>首先先来解释一下什么是<code>笛卡尔积</code><br>  现在我们有两个集合 A = {0,1} , B = {2,3,4}<br>  那么，集合 A <em> B 得到的结果就是<br>  A </em> B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)};<br>  B <em> A = {(2,0)、{2,1}、{3,0}、{3,1}、{4,0}、(4,1)};<br>  上面 A </em> B 和 B <em> A 的结果就可以称为两个集合相乘的 <code>笛卡尔积</code><br>  我们可以得出结论，A 集合和 B 集合相乘，包含了集合 A 中的元素和集合 B 中元素之和，也就是 A 元素的个数 </em> B 元素的个数</p></blockquote><p>再来解释一下什么是虚表</p><blockquote><p>在 MySQL 中，有三种类型的表<br>  一种是<code>永久表</code>，永久表就是创建以后用来长期保存数据的表<br>  一种是<code>临时表</code>，临时表也有两类，一种是和永久表一样，只保存临时数据，但是能够长久存在的；还有一种是临时创建的，SQL 语句执行完成就会删除。<br>  一种是<code>虚表</code>，虚表其实就是视图，数据可能会来自多张表的执行结果。</p></blockquote><h2 id="ON-过滤"><a href="#ON-过滤" class="headerlink" title="ON 过滤"></a>ON 过滤</h2><p>然后对 FROM 连接的结果进行 ON 筛选，创建 <strong>VT2</strong>，把符合记录的条件存在 <strong>VT2</strong> 中。</p><h2 id="JOIN-连接"><a href="#JOIN-连接" class="headerlink" title="JOIN 连接"></a>JOIN 连接</h2><p>第三步，如果是 <code>OUTER JOIN(left join、right join)</code> ，那么这一步就将添加外部行，如果是 <code>left join</code> 就把 ON 过滤条件的左表添加进来，如果是 <code>right join</code> ，就把右表添加进来，从而生成新的虚拟表 <strong>VT3</strong>。</p><h2 id="WHERE-过滤"><a href="#WHERE-过滤" class="headerlink" title="WHERE 过滤"></a>WHERE 过滤</h2><p>第四步，是执行 <code>WHERE</code> 过滤器，对上一步生产的虚拟表引用 <code>WHERE</code> 筛选，生成虚拟表 <strong>VT4</strong>。</p><p>WHERE 和 ON 的区别</p><ul><li>如果有外部列，ON 针对过滤的是关联表，主表(保留表)会返回所有的列;</li><li>如果没有添加外部列，两者的效果是一样的;</li></ul><p>应用</p><ul><li>对主表的过滤应该使用 WHERE;</li><li>对于关联表，先条件查询后连接则用 ON，先连接后条件查询则用 WHERE;</li></ul><h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>根据 <code>group by</code> 字句中的列，会对 <strong>VT4</strong> 中的记录进行分组操作，产生虚拟机表 <strong>VT5</strong>。如果应用了<code>group by</code>，那么后面的所有步骤都只能得到的 <strong>VT5</strong> 的列或者是聚合函数（<code>count</code>、<code>sum</code>、<code>avg</code>等）。</p><h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>紧跟着 <code>GROUP BY</code> 字句后面的是 <code>HAVING</code>，使用 HAVING 过滤，会把符合条件的放在 <strong>VT6</strong></p><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p>第七步才会执行 <code>SELECT</code> 语句，将 <strong>VT6</strong> 中的结果按照 <code>SELECT</code> 进行刷选，生成 <strong>VT7</strong></p><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>在第八步中，会对 <strong>TV7</strong> 生成的记录进行去重操作，生成 <strong>VT8</strong>。事实上如果应用了 <code>group by</code> 子句那么 <code>distinct</code> 是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</p><h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><p>应用 <code>order by</code> 子句。按照 <code>order_by_condition</code> 排序 <strong>VT8</strong>，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。</p><p><img src="http://caoxl.com/imgs/mysql_exec.jpg" alt="SQL 执行过程"></p><h1 id="什么是临时表，何时删除临时表"><a href="#什么是临时表，何时删除临时表" class="headerlink" title="什么是临时表，何时删除临时表"></a>什么是临时表，何时删除临时表</h1><p>什么是临时表？MySQL 在执行 SQL 语句的过程中，通常会临时创建一些<code>存储中间结果集</code>的表，临时表只对当前连接可见，在连接关闭时，临时表会被删除并释放所有表空间。</p><p>临时表分为两种：一种是<code>内存临时表</code>，一种是<code>磁盘临时表</code>，什么区别呢？内存临时表使用的是 MEMORY 存储引擎，而临时表采用的是 MyISAM 存储引擎。</p><blockquote><p>MEMORY 存储引擎：<code>memory</code> 是 MySQL 中一类特殊的存储引擎，它使用存储在内容中的内容来创建表，而且<strong>数据全部放在内存中</strong>。每个基于 MEMORY 存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为 <code>frm</code> 类型。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于 MEMORY 的表的生命周期很短，一般是一次性的。</p></blockquote><p>MySQL 会在下面这几种情况产生临时表</p><ul><li>使用 <code>UNION</code> 查询：<code>UNION</code> 有两种，一种是<code>UNION</code> ，一种是 <code>UNION ALL</code> ，它们都用于联合查询；区别是 使用 <code>UNION</code> 会去掉两个表中的重复数据，相当于对结果集做了一下<code>去重(distinct)</code>。使用 <code>UNION ALL</code>，则不会排重，返回所有的行。使用 <code>UNION</code> 查询会产生临时表。</li><li>使用 <code>TEMPTABLE</code> 算法或者是 <code>UNION</code> 查询中的视图。<code>TEMPTABLE</code> 算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要 <code>MySQL</code> 要先创建好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行相应的查询。</li><li><code>ORDER BY</code> 和 <code>GROUP BY</code> 的子句不一样时也会产生临时表。</li><li><code>DISTINCT</code> 查询并且加上 <code>ORDER BY</code> 时；</li><li><code>SQL</code>中用到 <code>SQL_SMALL_RESULT</code> 选项时；如果查询结果比较小的时候，可以加上 <code>SQL_SMALL_RESULT</code> 来优化，产生临时表</li><li><code>FROM</code> 中的子查询；</li><li><code>EXPLAIN</code> 查看执行计划结果的 <code>Extra</code> 列中，如果使用 <code>Using Temporary</code> 就表示会用到临时表。</li></ul><h1 id="MySQL-常见索引类型"><a href="#MySQL-常见索引类型" class="headerlink" title="MySQL 常见索引类型"></a>MySQL 常见索引类型</h1><p>索引是存储在一张表中特定列上的<code>数据结构</code>，索引是在列上创建的。并且，索引是一种数据结构。</p><p>在 MySQL 中，主要有下面这几种索引</p><ul><li><code>全局索引(FULLTEXT)</code>：全局索引，目前只有 MyISAM 引擎支持全局索引，它的出现是为了解决针对文本的模糊查询效率较低的问题。</li><li><code>哈希索引(HASH)</code>：哈希索引是 MySQL 中用到的唯一 key-value 键值对的数据结构，很适合作为索引。HASH 索引具有一次定位的好处，不需要像树那样逐个节点查找，但是这种查找适合应用于查找单个键的情况，对于范围查找，HASH 索引的性能就会很低。</li><li><code>B-Tree 索引</code>：B 就是 Balance 的意思，BTree 是一种平衡树，它有很多变种，最常见的就是 B+ Tree，它被 MySQL 广泛使用。</li><li><code>R-Tree 索引</code>：R-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种，相对于 B-Tree 来说，R-Tree 的优势在于范围查找。</li></ul><h1 id="varchar-和-char-的区别和使用场景"><a href="#varchar-和-char-的区别和使用场景" class="headerlink" title="varchar 和 char 的区别和使用场景"></a>varchar 和 char 的区别和使用场景</h1><p>MySQL 中没有 nvarchar 数据类型，所以直接比较的是 varchar 和 char 的区别</p><ul><li><code>char</code> ：表示的是定长的字符串，当你输入小于指定的数目，比如你指定的数目是 <code>char(6)</code>，当你输入小于 6 个字符的时候，<code>char</code> 会在你最后一个字符后面补空值。当你输入超过指定允许最大长度后，MySQL 会报错</li><li><code>varchar</code>： <code>varchar</code> 指的是长度为 n 个字节的可变长度，并且是非<code>Unicode</code>的字符数据。n 的值是介于 1 - 8000 之间的数值。存储大小为实际大小。</li></ul><p>使用 <code>char</code> 存储定长的数据非常方便、<code>char</code> 检索效率高，无论你存储的数据是否到了 10 个字节，都要去占用 10 字节的空间</p><p>使用 <code>varchar</code> 可以存储变长的数据，但存储效率没有 <code>char</code> 高。</p><h1 id="什么是-内连接、外连接、交叉连接、笛卡尔积"><a href="#什么是-内连接、外连接、交叉连接、笛卡尔积" class="headerlink" title="什么是 内连接、外连接、交叉连接、笛卡尔积"></a>什么是 内连接、外连接、交叉连接、笛卡尔积</h1><p>连接的方式主要有三种：<strong>外连接</strong>、<strong>内链接</strong>、<strong>交叉连接</strong></p><ul><li><code>外连接(OUTER JOIN)</code>：外连接分为三种，分别是<code>左外连接(LEFT OUTER JOIN 或 LEFT JOIN)</code>、<code>右外连接(RIGHT OUTER JOIN 或 RIGHT JOIN)</code> 、<code>全外连接(FULL OUTER JOIN 或 FULL JOIN)</code></li></ul><p><strong>MySQL 暂不支持全外连接</strong></p><ul><li><code>内连接(INNER JOIN)</code>：结合两个表中相同的字段，返回关联字段相符的记录。</li><li><p><code>笛卡尔积(Cartesian product)</code>： 我在上面提到了笛卡尔积，为了方便，下面再列出来一下。</p></li><li><p>交叉连接的原文是<code>Cross join</code> ，就是笛卡尔积在 SQL 中的实现，SQL中使用关键字<code>CROSS JOIN</code>来表示交叉连接，在交叉连接中，随便增加一个表的字段，都会对结果造成很大的影响。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_Class a CROSS JOIN t_Student b WHERE a.classid=b.classid</span><br></pre></td></tr></table></figure><p>或者不用 CROSS JOIN，直接用 FROM 也能表示交叉连接的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t_Class a ,t_Student b WHERE a.classid=b.classid</span><br></pre></td></tr></table></figure><p>如果表中字段比较多，不适宜用交叉连接，交叉连接的效率比较差。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;非关系型数据库和关系型数据库区别，优势比较&quot;&gt;&lt;a href=&quot;#非关系型数据库和关系型数据库区别，优势比较&quot; class=&quot;headerlink&quot; title=&quot;非关系型数据库和关系型数据库区别，优势比较&quot;&gt;&lt;/a&gt;非关系型数据库和关系型数据库区别，优势比较&lt;/h1&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="MySQL" scheme="http://blog.caoxl.com/tags/MySQL/"/>
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 面试题 I</title>
    <link href="http://blog.caoxl.com/2020/06/18/MySQL-Interview-Questions-I/"/>
    <id>http://blog.caoxl.com/2020/06/18/MySQL-Interview-Questions-I/</id>
    <published>2020-06-18T02:09:36.000Z</published>
    <updated>2020-06-18T06:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>原文地址:<a href="https://juejin.im/post/5ec15ab9f265da7bc60e1910" target="_blank" rel="noopener">100道MySQL数据库经典面试题解析（收藏版）</a></p></blockquote><a id="more"></a><h1 id="MySQL-索引使用有哪些注意事项呢？"><a href="#MySQL-索引使用有哪些注意事项呢？" class="headerlink" title="MySQL 索引使用有哪些注意事项呢？"></a>MySQL 索引使用有哪些注意事项呢？</h1><p>可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则</p><h2 id="索引哪些情况会失效"><a href="#索引哪些情况会失效" class="headerlink" title="索引哪些情况会失效"></a>索引哪些情况会失效</h2><ul><li>查询条件包含or，可能导致索引失效</li><li>如果字段类型是字符串，where时一定用引号括起来，否则索引失效</li><li>like通配符可能导致索引失效。</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用mysql的内置函数，索引失效。</li><li>对索引列运算（如，+、-、*、/），索引失效。</li><li>索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。</li><li>索引字段上使用is null， is not null，可能导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>mysql估计使用全表扫描要比使用索引快,则不使用索引。</li></ul><h2 id="索引不适合哪些场景"><a href="#索引不适合哪些场景" class="headerlink" title="索引不适合哪些场景"></a>索引不适合哪些场景</h2><ul><li>数据量少的不适合加索引</li><li>更新比较频繁的也不适合加索引</li><li>区分度低的字段不适合加索引（如性别）</li></ul><h2 id="索引的一些潜规则"><a href="#索引的一些潜规则" class="headerlink" title="索引的一些潜规则"></a>索引的一些潜规则</h2><ul><li>覆盖索引</li><li>回表</li><li>索引数据结构（B+树）</li><li>最左前缀原则</li><li>索引下推</li></ul><h1 id="MySQL-遇到过死锁问题吗，你是如何解决的？"><a href="#MySQL-遇到过死锁问题吗，你是如何解决的？" class="headerlink" title="MySQL 遇到过死锁问题吗，你是如何解决的？"></a>MySQL 遇到过死锁问题吗，你是如何解决的？</h1><ul><li>查看死锁日志<code>show engine innodb status;</code></li><li>找出死锁Sql</li><li>分析sql加锁情况</li><li>模拟死锁案发</li><li>分析死锁日志</li><li>分析死锁结果</li></ul><h1 id="日常工作中你是怎么优化SQL的？"><a href="#日常工作中你是怎么优化SQL的？" class="headerlink" title="日常工作中你是怎么优化SQL的？"></a>日常工作中你是怎么优化SQL的？</h1><ul><li>加索引</li><li>避免返回不必要的数据</li><li>适当分批量进行</li><li>优化sql结构</li><li>分库分表</li><li>读写分离</li></ul><h1 id="说说分库与分表的设计"><a href="#说说分库与分表的设计" class="headerlink" title="说说分库与分表的设计"></a>说说分库与分表的设计</h1><p>分库分表方案，分库分表中间件，分库分表可能遇到的问题</p><h2 id="分库分表方案"><a href="#分库分表方案" class="headerlink" title="分库分表方案:"></a>分库分表方案:</h2><ul><li>水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</li><li>水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</li><li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li><li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。</li></ul><h2 id="常用的分库分表中间件："><a href="#常用的分库分表中间件：" class="headerlink" title="常用的分库分表中间件："></a>常用的分库分表中间件：</h2><ul><li>sharding-jdbc（当当）</li><li>Mycat</li><li>TDDL（淘宝）</li><li>Oceanus(58同城数据库中间件)</li><li>vitess（谷歌开发的数据库中间件）</li><li>Atlas(Qihoo 360)</li></ul><h2 id="分库分表可能遇到的问题"><a href="#分库分表可能遇到的问题" class="headerlink" title="分库分表可能遇到的问题"></a>分库分表可能遇到的问题</h2><ul><li>事务问题：需要用分布式事务啦</li><li>跨节点Join的问题：解决这一问题可以分两次查询实现</li><li>跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</li><li>数据迁移，容量规划，扩容等问题</li><li>ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID</li><li>跨分片的排序分页问题（后台加大pagesize处理？）</li></ul><h1 id="InnoDB与MyISAM的区别"><a href="#InnoDB与MyISAM的区别" class="headerlink" title="InnoDB与MyISAM的区别"></a>InnoDB与MyISAM的区别</h1><ul><li>InnoDB支持事务，MyISAM不支持事务</li><li>InnoDB支持外键，MyISAM不支持外键</li><li>InnoDB支持 MVCC(多版本并发控制)，MyISAM 不支持</li><li>select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。</li><li>InnoDB不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）</li><li>InnoDB支持表、行级锁，而MyISAM支持表级锁</li><li>InnoDB表必须有主键，而MyISAM可以没有主键</li><li>InnoDB表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。</li><li>InnoDB按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。</li><li>InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li></ul><h1 id="数据库索引的原理，为什么要用-B-树，为什么不用二叉树？"><a href="#数据库索引的原理，为什么要用-B-树，为什么不用二叉树？" class="headerlink" title="数据库索引的原理，为什么要用 B+树，为什么不用二叉树？"></a>数据库索引的原理，为什么要用 B+树，为什么不用二叉树？</h1><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？</p><h2 id="为什么不是一般二叉树？"><a href="#为什么不是一般二叉树？" class="headerlink" title="为什么不是一般二叉树？"></a>为什么不是一般二叉树？</h2><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><h2 id="为什么不是平衡二叉树呢？"><a href="#为什么不是平衡二叉树呢？" class="headerlink" title="为什么不是平衡二叉树呢？"></a>为什么不是平衡二叉树呢？</h2><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p><h2 id="那为什么不是B树而是B-树呢？"><a href="#那为什么不是B树而是B-树呢？" class="headerlink" title="那为什么不是B树而是B+树呢？"></a>那为什么不是B树而是B+树呢？</h2><ul><li><p>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</p></li><li><p>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p></li></ul><h1 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h1><ul><li>一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。</li><li>聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</li><li>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li><li>聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；</li></ul><h1 id="limit-1000000-加载很慢的话，你是怎么解决的呢？"><a href="#limit-1000000-加载很慢的话，你是怎么解决的呢？" class="headerlink" title="limit 1000000 加载很慢的话，你是怎么解决的呢？"></a>limit 1000000 加载很慢的话，你是怎么解决的呢？</h1><ul><li>方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id，name from employee where id&gt;1000000 limit 10.</span><br></pre></td></tr></table></figure><ul><li>方案二：在业务允许的情况下限制页数：</li></ul><p>建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</p><ul><li>方案三：order by + 索引（id为索引）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id，name from employee order by id  limit 1000000，10</span><br></pre></td></tr></table></figure><ul><li>方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id</span><br></pre></td></tr></table></figure><h1 id="如何选择合适的分布式主键方案呢？"><a href="#如何选择合适的分布式主键方案呢？" class="headerlink" title="如何选择合适的分布式主键方案呢？"></a>如何选择合适的分布式主键方案呢？</h1><ul><li>数据库自增长序列或字段。</li><li>UUID</li><li>Redis生成ID</li><li>Twitter的snowflake算法</li><li>利用zookeeper生成唯一ID</li><li>MongoDB的ObjectId</li></ul><h1 id="事务的隔离级别有哪些？MySQL的默认隔离级别是什么？"><a href="#事务的隔离级别有哪些？MySQL的默认隔离级别是什么？" class="headerlink" title="事务的隔离级别有哪些？MySQL的默认隔离级别是什么？"></a>事务的隔离级别有哪些？MySQL的默认隔离级别是什么？</h1><ul><li>读未提交（Read Uncommitted）</li><li>读已提交（Read Committed）</li><li>可重复读（Repeatable Read）</li><li>串行化（Serializable）</li></ul><p>Mysql默认的事务隔离级别是可重复读(Repeatable Read)</p><h1 id="什么是幻读，脏读，不可重复读呢？"><a href="#什么是幻读，脏读，不可重复读呢？" class="headerlink" title="什么是幻读，脏读，不可重复读呢？"></a>什么是幻读，脏读，不可重复读呢？</h1><ul><li>事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是<strong>脏读</strong></li><li>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是<strong>不可重复读</strong>。</li><li>事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是<strong>幻读</strong>。</li></ul><h1 id="在高并发情况下，如何做到安全的修改同一行数据？"><a href="#在高并发情况下，如何做到安全的修改同一行数据？" class="headerlink" title="在高并发情况下，如何做到安全的修改同一行数据？"></a>在高并发情况下，如何做到安全的修改同一行数据？</h1><p>要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行记录。一般有悲观锁和乐观锁两种方案~</p><h2 id="使用悲观锁"><a href="#使用悲观锁" class="headerlink" title="使用悲观锁"></a>使用悲观锁</h2><p>悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如，可以使用select…for update ~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from User where name = &apos;jay&apos; for update</span><br></pre></td></tr></table></figure><p>以上这条sql语句会锁定了User表中所有符合检索条件（name=’jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。</p><h2 id="使用乐观锁"><a href="#使用乐观锁" class="headerlink" title="使用乐观锁"></a>使用乐观锁</h2><p>乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><h1 id="数据库的乐观锁和悲观锁。"><a href="#数据库的乐观锁和悲观锁。" class="headerlink" title="数据库的乐观锁和悲观锁。"></a>数据库的乐观锁和悲观锁。</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><h1 id="SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。"><a href="#SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。" class="headerlink" title="SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。"></a>SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。</h1><ul><li>show status 命令了解各种 sql 的执行频率</li><li>通过慢查询日志定位那些执行效率较低的 sql 语句</li><li>explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故）</li></ul><h1 id="select-for-update有什么含义，会锁表还是锁行还是其他。"><a href="#select-for-update有什么含义，会锁表还是锁行还是其他。" class="headerlink" title="select for update有什么含义，会锁表还是锁行还是其他。"></a>select for update有什么含义，会锁表还是锁行还是其他。</h1><h2 id="select-for-update-含义"><a href="#select-for-update-含义" class="headerlink" title="select for update 含义"></a>select for update 含义</h2><p>select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。</p><p>没用索引/主键的话就是表锁，否则就是是行锁。</p><h2 id="select-for-update-加锁验证"><a href="#select-for-update-加锁验证" class="headerlink" title="select for update 加锁验证"></a>select for update 加锁验证</h2><p>没用索引/主键的话，select for update加的就是表锁</p><h1 id="MySQL事务得四大特性以及实现原理"><a href="#MySQL事务得四大特性以及实现原理" class="headerlink" title="MySQL事务得四大特性以及实现原理"></a>MySQL事务得四大特性以及实现原理</h1><ul><li>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</li><li>隔离性： 多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。</li><li>持久性： 表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li></ul><h2 id="事务ACID特性的实现思想"><a href="#事务ACID特性的实现思想" class="headerlink" title="事务ACID特性的实现思想"></a>事务ACID特性的实现思想</h2><ul><li>原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。</li><li>持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。</li><li>隔离性：通过锁以及MVCC,使事务相互隔离开。</li><li>一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。</li></ul><h1 id="如果某个表有近千万数据，CRUD比较慢，如何优化。"><a href="#如果某个表有近千万数据，CRUD比较慢，如何优化。" class="headerlink" title="如果某个表有近千万数据，CRUD比较慢，如何优化。"></a>如果某个表有近千万数据，CRUD比较慢，如何优化。</h1><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>某个表有近千万数据，可以考虑优化表结构，分表（水平分表，垂直分表），当然，你这样回答，需要准备好面试官问你的分库分表相关问题呀，如</p><ul><li>分表方案（水平分表，垂直分表，切分规则hash等）</li><li>分库分表中间件（Mycat，sharding-jdbc等）</li><li>分库分表一些问题（事务问题？跨节点Join的问题）</li><li>解决方案（分布式事务等）</li></ul><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>除了分库分表，优化表结构，当然还有所以索引优化等方案~</p><h1 id="如何写sql能够有效的使用到复合索引。"><a href="#如何写sql能够有效的使用到复合索引。" class="headerlink" title="如何写sql能够有效的使用到复合索引。"></a>如何写sql能够有效的使用到复合索引。</h1><p>复合索引，也叫组合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。</p><p>当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where k1=A AND k2=B AND k3=D</span><br></pre></td></tr></table></figure><p>有关于复合索引，我们需要关注查询Sql条件的顺序，确保最左匹配原则有效，同时可以删除不必要的冗余索引。</p><h1 id="MVCC熟悉吗，它的底层原理？"><a href="#MVCC熟悉吗，它的底层原理？" class="headerlink" title="MVCC熟悉吗，它的底层原理？"></a>MVCC熟悉吗，它的底层原理？</h1><p>MVCC,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。</p><h2 id="MVCC需要关注这几个知识点："><a href="#MVCC需要关注这几个知识点：" class="headerlink" title="MVCC需要关注这几个知识点："></a>MVCC需要关注这几个知识点：</h2><ul><li>事务版本号</li><li>表的隐藏列</li><li>undo log</li><li>read view</li></ul><h1 id="MYSQL的主从延迟，你怎么解决？"><a href="#MYSQL的主从延迟，你怎么解决？" class="headerlink" title="MYSQL的主从延迟，你怎么解决？"></a>MYSQL的主从延迟，你怎么解决？</h1><p>主从复制分了五个步骤进行：</p><ul><li>步骤一：主库的更新事件(update、insert、delete)被写到binlog</li><li>步骤二：从库发起连接，连接到主库。</li><li>步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。</li><li>步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log</li><li>步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db</li></ul><h2 id="主从同步延迟的原因"><a href="#主从同步延迟的原因" class="headerlink" title="主从同步延迟的原因"></a>主从同步延迟的原因</h2><p>一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。</p><h2 id="主从同步延迟的解决办法"><a href="#主从同步延迟的解决办法" class="headerlink" title="主从同步延迟的解决办法"></a>主从同步延迟的解决办法</h2><ul><li>主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如<code>sync_binlog=1</code>，<code>innodb_flush_log_at_trx_commit = 1</code> 之类的设置等。</li><li>选择更好的硬件设备作为slave。</li><li>把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。</li><li>增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。</li></ul><h1 id="什么是数据库连接池-为什么需要数据库连接池呢"><a href="#什么是数据库连接池-为什么需要数据库连接池呢" class="headerlink" title="什么是数据库连接池?为什么需要数据库连接池呢?"></a>什么是数据库连接池?为什么需要数据库连接池呢?</h1><p><strong>连接池基本原理</strong>： 数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。</p><h2 id="应用程序和数据库建立连接的过程："><a href="#应用程序和数据库建立连接的过程：" class="headerlink" title="应用程序和数据库建立连接的过程："></a>应用程序和数据库建立连接的过程：</h2><ul><li>通过TCP协议的三次握手和数据库服务器建立连接</li><li>发送数据库用户账号密码，等待数据库验证用户身份</li><li>完成身份验证后，系统可以提交SQL语句到数据库执行</li><li>把连接关闭，TCP四次挥手告别。</li></ul><h2 id="数据库连接池好处："><a href="#数据库连接池好处：" class="headerlink" title="数据库连接池好处："></a>数据库连接池好处：</h2><ul><li>资源重用 (连接复用)</li><li>更快的系统响应速度</li><li>新的资源分配手段</li><li>统一的连接管理，避免数据库连接泄漏</li></ul><h1 id="一条SQL语句在MySQL中如何执行的？"><a href="#一条SQL语句在MySQL中如何执行的？" class="headerlink" title="一条SQL语句在MySQL中如何执行的？"></a>一条SQL语句在MySQL中如何执行的？</h1><h2 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h2><ul><li>先检查该语句是否有权限</li><li>如果没有权限，直接返回错误信息</li><li>如果有权限，在 MySQL8.0 版本以前，会先查询缓存。</li><li>如果没有缓存，分析器进行词法分析，提取 sql 语句select等的关键元素。然后判断sql 语句是否有语法错误，比如关键词是否正确等等。</li><li>优化器进行确定执行方案</li><li>进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会调用数据库引擎接口，返回执行结果。</li></ul><h1 id="InnoDB引擎中的索引策略，了解过吗？"><a href="#InnoDB引擎中的索引策略，了解过吗？" class="headerlink" title="InnoDB引擎中的索引策略，了解过吗？"></a>InnoDB引擎中的索引策略，了解过吗？</h1><ul><li>覆盖索引</li><li>最左前缀原则</li><li>索引下推</li></ul><p>索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><h1 id="数据库存储日期格式时，如何考虑时区转换问题？"><a href="#数据库存储日期格式时，如何考虑时区转换问题？" class="headerlink" title="数据库存储日期格式时，如何考虑时区转换问题？"></a>数据库存储日期格式时，如何考虑时区转换问题？</h1><ul><li><code>datetime</code>类型适合用来记录数据的原始的创建时间，修改记录中其他字段的值，<code>datetime</code>字段的值不会改变，除非手动修改它。</li><li><code>timestamp</code>类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，<code>timestamp</code>字段的值都会被自动更新。</li></ul><h1 id="一条sql执行过长的时间，你如何优化，从哪些方面入手？"><a href="#一条sql执行过长的时间，你如何优化，从哪些方面入手？" class="headerlink" title="一条sql执行过长的时间，你如何优化，从哪些方面入手？"></a>一条sql执行过长的时间，你如何优化，从哪些方面入手？</h1><ul><li>查看是否涉及多表和子查询，优化Sql结构，如去除冗余字段，是否可拆表等</li><li>优化索引结构，看是否可以适当添加索引</li><li>数量大的表，可以考虑进行分离/分表（如交易流水表）</li><li>数据库主从分离，读写分离</li><li>explain分析sql语句，查看执行计划，优化sql</li><li>查看mysql执行日志，分析是否有其他方面的问题</li></ul><h1 id="MYSQL数据库服务器性能分析的方法命令有哪些"><a href="#MYSQL数据库服务器性能分析的方法命令有哪些" class="headerlink" title="MYSQL数据库服务器性能分析的方法命令有哪些?"></a>MYSQL数据库服务器性能分析的方法命令有哪些?</h1><ul><li>Show status, 一些值得监控的变量值：</li></ul><blockquote><ul><li>Bytes_received和Bytes_sent 和服务器之间来往的流量。</li><li>Com_*服务器正在执行的命令。</li><li>Created_*在查询执行期限间创建的临时表和文件。</li><li>Handler_*存储引擎操作。</li><li>Select_*不同类型的联接执行计划。</li><li>Sort_*几种排序信息。</li></ul></blockquote><ul><li>Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况</li></ul><h1 id="Blob和text有什么区别？"><a href="#Blob和text有什么区别？" class="headerlink" title="Blob和text有什么区别？"></a>Blob和text有什么区别？</h1><ul><li>Blob用于存储二进制数据，而Text用于存储大字符串。</li><li>Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。</li><li>text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。</li></ul><h1 id="Mysql中有哪几种锁，列举一下？"><a href="#Mysql中有哪几种锁，列举一下？" class="headerlink" title="Mysql中有哪几种锁，列举一下？"></a>Mysql中有哪几种锁，列举一下？</h1><p>如果按锁粒度划分，有以下3种：</p><ul><li>表锁： 开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</li><li>行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li><li>页锁： 开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li></ul><h1 id="Hash索引和B-树区别是什么？你在设计索引是怎么抉择的？"><a href="#Hash索引和B-树区别是什么？你在设计索引是怎么抉择的？" class="headerlink" title="Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？"></a>Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？</h1><ul><li>B+树可以进行范围查询，Hash索引不能。</li><li>B+树支持联合索引的最左侧原则，Hash索引不支持。</li><li>B+树支持order by排序，Hash索引不支持。</li><li>Hash索引在等值查询上比B+树效率更高。</li><li>B+树使用like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，Hash索引根本无法进行模糊查询。</li></ul><h1 id="mysql-的内连接、左连接、右连接有什么区别？"><a href="#mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="mysql 的内连接、左连接、右连接有什么区别？"></a>mysql 的内连接、左连接、右连接有什么区别？</h1><ul><li>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li><li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li></ul><h1 id="mysql有关权限的表有哪几个呢？"><a href="#mysql有关权限的表有哪几个呢？" class="headerlink" title="mysql有关权限的表有哪几个呢？"></a>mysql有关权限的表有哪几个呢？</h1><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由<code>mysql_install_db</code>脚本初始化。这些权限表分别<code>user</code>，<code>db</code>，<code>table_priv</code>，<code>columns_priv</code>和<code>host</code>。</p><ul><li><code>user</code>权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li><code>db</code>权限表：记录各个帐号在各个数据库上的操作权限。</li><li><code>table_priv</code>权限表：记录数据表级的操作权限。</li><li><code>columns_priv</code>权限表：记录数据列级的操作权限。</li><li><code>host</code>权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h1 id="Mysql的binlog有几种录入格式？分别有什么区别？"><a href="#Mysql的binlog有几种录入格式？分别有什么区别？" class="headerlink" title="Mysql的binlog有几种录入格式？分别有什么区别？"></a>Mysql的binlog有几种录入格式？分别有什么区别？</h1><p>有三种格式哈，statement，row和mixed。</p><ul><li>statement，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li><li>row，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li><li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li></ul><h1 id="InnoDB引擎的4大特性，了解过吗"><a href="#InnoDB引擎的4大特性，了解过吗" class="headerlink" title="InnoDB引擎的4大特性，了解过吗"></a>InnoDB引擎的4大特性，了解过吗</h1><ul><li>插入缓冲（insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h1 id="索引有哪些优缺点？"><a href="#索引有哪些优缺点？" class="headerlink" title="索引有哪些优缺点？"></a>索引有哪些优缺点？</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>唯一索引可以保证数据库表中每一行的数据的唯一性</li><li>索引可以加快数据查询速度，减少查询时间</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>创建索引和维护索引要耗费时间</li><li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间</li><li>以表中的数据进行增、删、改的时候，索引也要动态的维护。</li></ul><h1 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h1><ul><li>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li><li>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</li><li>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</li><li>全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。</li><li>覆盖索引：查询列要被所建的索引覆盖，不必读取数据行</li><li>组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并</li></ul><h1 id="创建索引有什么原则呢？"><a href="#创建索引有什么原则呢？" class="headerlink" title="创建索引有什么原则呢？"></a>创建索引有什么原则呢？</h1><ul><li>最左前缀匹配原则</li><li>频繁作为查询条件的字段才去创建索引</li><li>频繁更新的字段不适合创建索引</li><li>索引列不能参与计算，不能有函数操作</li><li>优先考虑扩展索引，而不是新建索引，避免不必要的索引</li><li>在order by或者group by子句中，创建索引需要注意顺序</li><li>区分度低的数据列不适合做索引列(如性别）</li><li>定义有外键的数据列一定要建立索引。</li><li>对于定义为text、image数据类型的列不要建立索引。</li><li>删除不再使用或者很少使用的索引</li></ul><h1 id="创建索引的三种方式"><a href="#创建索引的三种方式" class="headerlink" title="创建索引的三种方式"></a>创建索引的三种方式</h1><ul><li>在执行CREATE TABLE时创建索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employee` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_name` (`name`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>使用ALTER TABLE命令添加索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column);</span><br></pre></td></tr></table></figure><ul><li>使用CREATE INDEX命令创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column);</span><br></pre></td></tr></table></figure><h1 id="覆盖索引、回表等这些，了解过吗？"><a href="#覆盖索引、回表等这些，了解过吗？" class="headerlink" title="覆盖索引、回表等这些，了解过吗？"></a>覆盖索引、回表等这些，了解过吗？</h1><ul><li>覆盖索引： 查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</li><li>回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。</li></ul><h1 id="为什么要使用视图？什么是视图？"><a href="#为什么要使用视图？什么是视图？" class="headerlink" title="为什么要使用视图？什么是视图？"></a>为什么要使用视图？什么是视图？</h1><h2 id="为什么要使用视图？"><a href="#为什么要使用视图？" class="headerlink" title="为什么要使用视图？"></a>为什么要使用视图？</h2><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。</p><h2 id="什么是视图？"><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a>什么是视图？</h2><p>视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。</p><h1 id="视图有哪些特点？哪些使用场景？"><a href="#视图有哪些特点？哪些使用场景？" class="headerlink" title="视图有哪些特点？哪些使用场景？"></a>视图有哪些特点？哪些使用场景？</h1><h2 id="视图特点："><a href="#视图特点：" class="headerlink" title="视图特点："></a>视图特点：</h2><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表(实表)产生的表(虚表)。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li><li>当视图来自多个基本表时，不允许添加和删除数据。</li></ul><h2 id="视图用途"><a href="#视图用途" class="headerlink" title="视图用途"></a>视图用途</h2><p>简化sql查询，提高开发效率，兼容老的表结构。</p><h2 id="视图的常见使用场景"><a href="#视图的常见使用场景" class="headerlink" title="视图的常见使用场景"></a>视图的常见使用场景</h2><ul><li>重用SQL语句；</li><li>简化复杂的SQL操作。</li><li>使用表的组成部分而不是整个表；</li><li>保护数据</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><h1 id="MySQL中都有哪些触发器？"><a href="#MySQL中都有哪些触发器？" class="headerlink" title="MySQL中都有哪些触发器？"></a>MySQL中都有哪些触发器？</h1><p>MySQL 数据库中有六种触发器：</p><ul><li><code>Before Insert</code></li><li><code>After Insert</code></li><li><code>Before Update</code></li><li><code>After Update</code></li><li><code>Before Delete</code></li><li><code>After Delete</code></li></ul><h1 id="SQL-约束有哪几种呢？"><a href="#SQL-约束有哪几种呢？" class="headerlink" title="SQL 约束有哪几种呢？"></a>SQL 约束有哪几种呢？</h1><ul><li><code>NOT NULL</code>: 约束字段的内容一定不能为NULL。</li><li><code>UNIQUE</code>: 约束字段唯一性，一个表允许有多个 Unique 约束。</li><li><code>PRIMARY KEY</code>: 约束字段唯一，不可重复，一个表只允许存在一个。</li><li><code>FOREIGN KEY</code>: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。</li><li><code>CHECK</code>: 用于控制字段的值范围。</li></ul><h1 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h1><ul><li>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</li><li>Union All：对两个结果集进行并集操作，包括重复行，不进行排序；</li><li>UNION的效率高于 UNION ALL</li></ul><h1 id="SQL的生命周期？"><a href="#SQL的生命周期？" class="headerlink" title="SQL的生命周期？"></a>SQL的生命周期？</h1><ul><li>服务器与数据库建立连接</li><li>数据库进程拿到请求sql</li><li>解析并生成执行计划，执行</li><li>读取数据到内存，并进行逻辑处理</li><li>通过步骤一的连接，发送结果到客户端</li><li>关掉连接，释放资源</li></ul><h1 id="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h1><p>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等</p><h1 id="你们数据库是否支持emoji表情存储，如果不支持，如何操作？"><a href="#你们数据库是否支持emoji表情存储，如果不支持，如何操作？" class="headerlink" title="你们数据库是否支持emoji表情存储，如果不支持，如何操作？"></a>你们数据库是否支持emoji表情存储，如果不支持，如何操作？</h1><p>更换字符集utf8–&gt;utf8mb4</p><h1 id="一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。"><a href="#一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。" class="headerlink" title="一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。"></a>一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</h1><ul><li>如果A表TID是自增长,并且是连续的,B表的ID为索引 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200;</span><br></pre></td></tr></table></figure><ul><li>如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from b , (select tid from a limit 50000,200) a where b.id = a .tid;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="https://juejin.im/post/5de99dd2518825125e1ba49d" target="_blank" rel="noopener">后端程序员必备：索引失效的十大杂症</a></li><li><a href="https://juejin.im/post/5e8b269f518825739379e82c" target="_blank" rel="noopener">手把手教你分析Mysql死锁问题</a></li><li><a href="https://juejin.im/post/5ea16dede51d45470b4ffc5b" target="_blank" rel="noopener">没内鬼，来点干货！SQL优化和诊断</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://juejin.im/post/5ec15ab9f265da7bc60e1910&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;100道MySQL数据库经典面试题解析（收藏版）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="MySQL" scheme="http://blog.caoxl.com/tags/MySQL/"/>
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>三年 Git 使用心得 &amp; 常见问题整理</title>
    <link href="http://blog.caoxl.com/2020/06/15/Git-Use-Notes/"/>
    <id>http://blog.caoxl.com/2020/06/15/Git-Use-Notes/</id>
    <published>2020-06-15T07:45:01.000Z</published>
    <updated>2020-06-15T09:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>原文地址 <a href="https://juejin.im/post/5ee649ff51882542ea2b5108" target="_blank" rel="noopener">三年 Git 使用心得 &amp; 常见问题整理</a></p></blockquote><a id="more"></a><h1 id="Git-流程图"><a href="#Git-流程图" class="headerlink" title="Git 流程图"></a>Git 流程图</h1><p><img src="http://caoxl.com/imgs/git.jpg" alt="git 流程图"></p><ul><li><code>Workspace</code>: 工作区</li><li><code>Index/Stage</code>: 暂存区</li><li><code>Repository</code>: 仓库区(或本地仓库)</li><li><code>Remote</code>: 远程仓库</li></ul><h1 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 配置全局用户</span></span><br><span class="line">git config --global user.name "用户名"</span><br><span class="line">git config --global user.email "git账号"</span><br><span class="line"></span><br><span class="line"><span class="section"># 美化log的输出, 并配置别名</span></span><br><span class="line">alias gll="git log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'";</span><br><span class="line"></span><br><span class="line"><span class="section"># 删除全局配置</span></span><br><span class="line">git config --global --unset alias.xxx</span><br><span class="line">git config --global --unset user.xxx</span><br></pre></td></tr></table></figure><h1 id="查看-Git-信息"><a href="#查看-Git-信息" class="headerlink" title="查看 Git 信息"></a>查看 Git 信息</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统配置</span></span><br><span class="line">git<span class="built_in"> config </span>--list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户配置</span></span><br><span class="line">cat ~/.gitconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前项目的git配置</span></span><br><span class="line">cat .git/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存区的文件</span></span><br><span class="line">git ls-files</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看本地git命令历史</span></span><br><span class="line">git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有git命令</span></span><br><span class="line">git --help -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前HEAD指向</span></span><br><span class="line">cat .git/HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看提交历史</span></span><br><span class="line">git log --online</span><br><span class="line">        <span class="attribute">--grep</span>=<span class="string">"关键字"</span></span><br><span class="line">        --author <span class="string">"username"</span></span><br><span class="line">        --before 1 day/1 week/1 <span class="string">"2020-06-15"</span></span><br></pre></td></tr></table></figure><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">cbff89f (HEAD -&gt; master, origin/master) HEAD@&#123;0&#125;: commit: Laravel7 初始化</span><br><span class="line">8b1a09f HEAD@&#123;1&#125;: commit: Laravel7 初始化</span><br><span class="line">c6dcc6b HEAD@&#123;2&#125;: commit: test jenkins</span><br><span class="line">f76c78d HEAD@&#123;3&#125;: commit (initial): Laravel7 初始化</span><br></pre></td></tr></table></figure><ul><li>显示的是一个 <code>HEAD</code> 指向发生改变的时间列表。在你切换分支、用 <code>git commit</code> 进行提交、以及用 <code>git reset</code> 撤销 <code>commit</code> 时，<code>HEAD</code> 指向会改变，但当你进行 <code>git checkout -- &lt;filename&gt;</code> 撤销或者 <code>git stash</code>  存储文件等操作时，<code>HEAD</code> 并不会改变，这些修改从来没有被提交过，因此 <code>reflog</code> 也无法帮助我们恢复它们。</li><li><code>git reflog</code> 不会永远保持，Git 会定期清理那些 “用不到的” 对象，不要指望几个月前的提交还一直在那里。</li></ul><h2 id="git-log-点线图"><a href="#git-log-点线图" class="headerlink" title="git log 点线图"></a>git log 点线图</h2><ul><li>git 中一条分支就是一个指针，新建一条分支就是基于当前指针新建一个指针</li><li>切换至某个分支 ，就是将 HEAD 指向某条分支（指针）</li><li><p>切换至某个 commit ，就是将 HEAD 指向某个 commit</p></li><li><p>符号解释：</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span>表示一个 commit</span><br><span class="line">|表示分支前进</span><br><span class="line">/表示分叉</span><br><span class="line">\表示合入</span><br><span class="line">|/表示新分支</span><br></pre></td></tr></table></figure><h1 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h1><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 查看工作区和暂存区的状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="meta"># 将工作区的文件提交到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta"># 提交到本地仓库</span></span><br><span class="line">git commit -m <span class="string">"本次提交说明"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># add和commit的合并，便捷写法（未追踪的文件无法直接提交到暂存区/本地仓库）</span></span><br><span class="line">git commit -am <span class="string">"本次提交说明"</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 将本地分支和远程分支进行关联</span></span><br><span class="line">git push -u origin branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 将本地仓库的文件推送到远程分支</span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="meta"># 拉取远程分支的代码</span></span><br><span class="line">git pull origin branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 合并分支</span></span><br><span class="line">git merge branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看所有分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="meta"># 切换分支</span></span><br><span class="line">git checkout branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 临时将工作区文件的修改保存至堆栈中</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="meta"># 将之前保存至堆栈中的文件取出来</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h1 id="Git-常用命令详解"><a href="#Git-常用命令详解" class="headerlink" title="Git 常用命令详解"></a>Git 常用命令详解</h1><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>将工作区的文件添加到暂存区</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区(追踪新增的指定文件)</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区, 包括子目录</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区(追踪所有新增的文件)</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区/暂存区的文件</span></span><br><span class="line">git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名工作区/暂存区的文件</span></span><br><span class="line">git mv [file-origine] [file-renamed]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Git 2.0 以下版本</span></span><br><span class="line"><span class="comment"># 只作用于文件的新增和修改</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="comment"># 只作用于文件的修改和删除</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> -u</span></span><br><span class="line"><span class="comment"># 作用于文件的增删改</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> -A</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Git 2.0版本</span></span><br><span class="line">git <span class="keyword">add</span><span class="bash"> . // 等价于 git add -A</span></span><br></pre></td></tr></table></figure><ul><li><code>git add .</code> ：操作的对象是“当前目录”所有文件变更，”.” 表示当前目录。会监控工作区的状态树，使用它会把工作区的所有变化提交到暂存区，包括文件内容修改（<code>modified</code>）以及新文件（<code>new</code>），但不包括被删除的文件。</li><li><code>git add -u</code> ：操作的对象是整个工作区已经跟踪的文件变更，无论当前位于哪个目录下。仅监控已经被 add 的文件（即 <code>tracked file</code>），它会将被修改的文件（包括文件删除）提交到暂存区。<code>git add -u</code> 不会提交新文件（<code>untracked file</code>）。（<code>git add --update</code> 的缩写）</li><li><code>git add -A</code> ：操作的对象是“整个工作区”所有文件的变更，无论当前位于哪个目录下。是上面两个功能的合集（<code>git add --all</code> 的缩写）。</li></ul><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 查看工作区和暂存区的状态</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将暂存区的文件提交到本地仓库并添加提交说明</span></span><br><span class="line">git <span class="keyword">commit</span> -m <span class="string">"本次提交的说明"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add 和 commit 的合并，便捷写法</span></span><br><span class="line">git <span class="keyword">commit</span> -am <span class="string">"本次提交的说明"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过验证继续提交</span></span><br><span class="line">git <span class="keyword">commit</span> <span class="comment">--no-verify</span></span><br><span class="line">git <span class="keyword">commit</span> -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑器会弹出上一次提交的信息，可以在这里修改提交信息</span></span><br><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复提交, 同时修改提交信息</span></span><br><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend -m "本次提交的说明"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入 --no-edit 标记会修复提交但不修改提交信息, 编辑器不会弹出上一次提交的信息</span></span><br><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend --no-edit</span></span><br></pre></td></tr></table></figure><h2 id="push-amp-pull"><a href="#push-amp-pull" class="headerlink" title="push &amp; pull"></a>push &amp; pull</h2><ul><li>分支推送顺序的写法是 <strong>&lt;来源地&gt;:&lt;目的地&gt;</strong></li></ul><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 将本地仓库的文件推送到远程分支</span></span><br><span class="line"><span class="meta"># 如果远程仓库没有这个分支，会新建一个同名的远程分支</span></span><br><span class="line"><span class="meta"># 如果省略远程分支名，则表示两者同名</span></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line">git push origin branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果省略本地分支名，则表示删除指定的远程分支</span></span><br><span class="line"><span class="meta"># 因为这等同于推送一个空的本地分支到远程分支。</span></span><br><span class="line">git push origin :branch_name</span><br><span class="line"><span class="meta"># 等同于</span></span><br><span class="line">git push origin --delete branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 建立当前分支和远程分支的追踪关系</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta"># 如果当前分支与远程分支存在追踪关系则可以省略分支和 -u </span></span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="meta"># 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机</span></span><br><span class="line">git push --all origin</span><br><span class="line"></span><br><span class="line"><span class="meta"># 拉取所有远程分支到本地镜像仓库中</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="meta"># 拉取并合并项目其他人员的一个分支</span></span><br><span class="line">git pull origin branch_name</span><br><span class="line"><span class="meta"># 等同于 fetch + merge</span></span><br><span class="line">git fetch origin branch_name</span><br><span class="line">git merge origin/branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 如果远程主机的版本比本地版本更新，推送时 Git 会报错，要求先在本地做 git pull 合并差异，</span></span><br><span class="line"><span class="meta"># 然后再推送到远程主机。这时，如果你一定要推送，可以使用 –-force 选项 </span></span><br><span class="line"><span class="meta"># (尽量避免使用)</span></span><br><span class="line">git push --force origin</span><br><span class="line"><span class="meta"># 或</span></span><br><span class="line">git push -f orign</span><br></pre></td></tr></table></figure><h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 查看本地分支</span></span><br><span class="line">git branch | git branch -l</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看所有分支(本地分支+远程分支)</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看所有分支并带上最新的提交信息</span></span><br><span class="line">git branch -av</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看本地分支对应的远程分支</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建分支</span></span><br><span class="line"><span class="meta"># 在别的分支下新建一个分支，新分支会复制当前分支的内容</span></span><br><span class="line"><span class="meta"># 注意：如果当前分支有修改，但是没有提交到仓库，此时修改的内容是不会被复制到新分支的</span></span><br><span class="line">git branch branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 切换分支(切换分支时，本地工作区，仓库都会相应切换到对应分支的内容)</span></span><br><span class="line">git checkout branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建一个 caoxl 分支，并切换到该分支 （新建分支和切换分支的简写）</span></span><br><span class="line">git checkout -b caoxl</span><br><span class="line"></span><br><span class="line"><span class="meta"># 可以看做是基于 master 分支创建一个 caoxl 分支，并切换到该分支</span></span><br><span class="line">git checkout -b caoxl master</span><br><span class="line"></span><br><span class="line"><span class="meta"># 新建一条空分支（详情请看问题列表）</span></span><br><span class="line">git checkout --orphan empty_branch_name</span><br><span class="line">git rm -rf .</span><br><span class="line"></span><br><span class="line"><span class="meta"># 删除本地分支, 会阻止删除保护未合并更改的分支</span></span><br><span class="line">git branch -D branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta"># 删除远程分支</span></span><br><span class="line"><span class="meta"># 推送一个空分支到远程分支，其实就相当于删除远程分支</span></span><br><span class="line">git push orign :远程分支名</span><br><span class="line"><span class="meta"># 或者</span></span><br><span class="line">git push origin --delete 远程分支名</span><br><span class="line"></span><br><span class="line"><span class="meta"># 修改当前分支名</span></span><br><span class="line">git branch -m branch_name</span><br></pre></td></tr></table></figure><h2 id="merge-三种常用合并方法"><a href="#merge-三种常用合并方法" class="headerlink" title="merge 三种常用合并方法"></a>merge 三种常用合并方法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 默认 fast-forward ，HEAD 指针直接指向被合并的分支</span></span><br><span class="line">git merge</span><br><span class="line"></span><br><span class="line"><span class="section"># 禁止快进式合并</span></span><br><span class="line">git merge --no-ff</span><br><span class="line"> </span><br><span class="line">git merge --squash</span><br></pre></td></tr></table></figure><p><img src="http://caoxl.com/imgs/git_merge.jpg" alt="git merge"></p><ul><li><code>fast-forward</code>：会在当前分支的提交历史中添加进被合并分支的提交历史（<strong>得先理解什么时候会发生快速合并，并不是每次 merge 都会发生快速合并</strong>）；</li><li><code>--no-ff</code>：会生成一个新的提交，让当前分支的提交历史不会那么乱；</li><li><code>--squash</code>：不会生成新的提交，会将被合并分支多次提交的内容直接存到工作区和暂存区，由开发者手动去提交，这样当前分支最终只会多出一条提交记录，不会掺杂被合并分支的提交历史</li></ul><h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><ul><li>能够将所有未提交的修改保存至堆栈中，用于后续恢复当前工作区内容</li><li>如果文件没有提交到暂存区（<strong>使用 git add . 追踪新的文件</strong>），使用该命令会提示 <code>No local changes to save</code> ，无法将修改保存到堆栈中</li></ul><blockquote><p><strong>使用场景</strong>： 当你接到一个修复紧急 bug 的任务时候，一般都是先创建一个新的 bug 分支来修复它，然后合并，最后删除。但是，如果当前你正在开发功能中，短时间还无法完成，无法直接提交到仓库，这时候可以先把当前工作区的内容 <code>git stash</code> 一下，然后去修复 bug，修复后，再 <code>git stash pop</code>，恢复之前的工作内容。</p></blockquote><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 将所有未提交的修改（提交到暂存区）保存至堆栈中</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta"># 给本次存储加个备注, 以防时间久了忘了</span></span><br><span class="line">git stash save <span class="string">"存储"</span></span><br><span class="line"><span class="meta"># 存储未追踪的文件</span></span><br><span class="line">git stash -u</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看存储记录</span></span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看工作区和暂存区单个文件的对比</span></span><br><span class="line">git <span class="keyword">diff </span>filename</span><br><span class="line"><span class="comment"># 查看工作区和暂存区所有文件的对比</span></span><br><span class="line">git <span class="keyword">diff</span></span><br><span class="line"><span class="keyword"># </span>查看工作区和暂存区所有文件的对比，并显示出所有有差异的文件列表</span><br><span class="line">git <span class="keyword">diff </span>--stat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存区与上次提交到本地仓库的快照（即最新提交到本地仓库的快照）的对比</span></span><br><span class="line">git <span class="keyword">diff </span>--<span class="keyword">cached/--staged</span></span><br><span class="line"><span class="keyword"># </span>查看工作区与上次提交到本地仓库的快照（即最新提交到本地仓库的快照）的对比</span><br><span class="line">git <span class="keyword">diff </span><span class="keyword">branch_name</span></span><br><span class="line"><span class="keyword"># </span>查看工作区与 HEAD 指向（默认当前分支最新的提交）的对比</span><br><span class="line">git <span class="keyword">diff </span>HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个commit的对比</span></span><br><span class="line">git <span class="keyword">diff </span>commit1..commit2</span><br></pre></td></tr></table></figure><h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有远程主机</span></span><br><span class="line"><span class="string">git </span><span class="string">remote</span></span><br><span class="line"><span class="string">#</span> 查看关联的远程仓库的详细信息</span><br><span class="line"><span class="string">git </span><span class="string">remote </span>-v</span><br><span class="line"><span class="comment"># 删除远程仓库的"关联"</span></span><br><span class="line"><span class="string">git </span><span class="string">remote </span><span class="string">rm </span><span class="string">projectname</span></span><br><span class="line"><span class="string">#</span> 设置远程仓库的<span class="string">"关联"</span></span><br><span class="line"><span class="string">git </span><span class="string">remote </span><span class="built_in">set-url</span> <span class="string">origin </span>&lt;<span class="string">newurl&gt;</span></span><br></pre></td></tr></table></figure><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 默认在 HEAD 上创建一个标签 </span></span><br><span class="line">git tag v1.0</span><br><span class="line"></span><br><span class="line"><span class="section"># 指定一个 commit id 创建一个标签 </span></span><br><span class="line">git tag v0.9 f52c633</span><br><span class="line"></span><br><span class="line"><span class="section"># 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字</span></span><br><span class="line">git tag -a v0.1 -m "version 0.1 released" </span><br><span class="line"></span><br><span class="line"><span class="section"># 查看所有标签</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看单个标签具体信息</span></span><br><span class="line">git show <span class="xml"><span class="tag">&lt;<span class="name">tagname</span>&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="section"># 推送一个本地标签</span></span><br><span class="line">git push origin <span class="xml"><span class="tag">&lt;<span class="name">tagname</span>&gt;</span></span></span><br><span class="line"><span class="section"># 推送全部未推送的本地标签</span></span><br><span class="line">git push origin --tags</span><br><span class="line"></span><br><span class="line"><span class="section"># 删除本地标签</span></span><br><span class="line">git tag -d v0.1</span><br><span class="line"><span class="section"># 因为创建的标签都只存储在本地，不会自动推送到远程。</span></span><br><span class="line"><span class="section"># 所以，打错的标签可以在本地安全删除。</span></span><br><span class="line">git tag -d v0.1</span><br><span class="line"><span class="section"># 删除一个远程标签（先删除本地 tag ，然后再删除远程 tag）</span></span><br><span class="line">git push origin :refs/tags/<span class="xml"><span class="tag">&lt;<span class="name">tagname</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 生成一个撤销最近的一次提交的新提交</span></span><br><span class="line">git revert HEAD</span><br><span class="line"> </span><br><span class="line"><span class="section"># 生成一个撤销最近一次提交的上一次提交的新提交</span></span><br><span class="line">git revert HEAD^</span><br><span class="line"> </span><br><span class="line"><span class="section"># 生成一个撤销最近一次提交的上两次提交的新提交</span></span><br><span class="line">git revert HEAD^^</span><br><span class="line"> </span><br><span class="line"><span class="section"># 生成一个撤销最近一次提交的上n次提交的新提交</span></span><br><span class="line">git revert HEAD~num </span><br><span class="line"></span><br><span class="line"><span class="section"># 生成一个撤销指定提交版本的新提交</span></span><br><span class="line">git revert <span class="xml"><span class="tag">&lt;<span class="name">commit_id</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 生成一个撤销指定提交版本的新提交，执行时不打开默认编辑器，直接使用 Git 自动生成的提交信息</span></span><br><span class="line">git revert <span class="xml"><span class="tag">&lt;<span class="name">commit_id</span>&gt;</span></span> --no-edit</span><br></pre></td></tr></table></figure><h1 id="新建一个-Git-项目的两种方式"><a href="#新建一个-Git-项目的两种方式" class="headerlink" title="新建一个 Git 项目的两种方式"></a>新建一个 Git 项目的两种方式</h1><h2 id="本地新建好-Git-项目，然后关联远程仓库"><a href="#本地新建好-Git-项目，然后关联远程仓库" class="headerlink" title="本地新建好 Git 项目，然后关联远程仓库"></a>本地新建好 Git 项目，然后关联远程仓库</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个Git仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联远程仓库</span></span><br><span class="line">git remote <span class="keyword">add</span><span class="bash"> &lt;name&gt; &lt;git-repo-url&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin https://github.com/xxxxxx</span></span><br></pre></td></tr></table></figure><h2 id="clone-远程仓库"><a href="#clone-远程仓库" class="headerlink" title="clone 远程仓库"></a>clone 远程仓库</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 新建好远程仓库，然后 clone 到本地</span></span><br><span class="line">git clone <span class="xml"><span class="tag">&lt;<span class="name">git-repo-url</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="section"># 将远程仓库下载到（当前 git bash 启动位置下面的）指定文件中，如果没有会自动生成</span></span><br><span class="line">git clone <span class="xml"><span class="tag">&lt;<span class="name">git-repo-url</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;<span class="name">project-name</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="Git-钩子"><a href="#Git-钩子" class="headerlink" title="Git 钩子"></a>Git 钩子</h1><h2 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h2><ul><li><code>pre-commit</code> 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（<code>hook</code>）</li><li>在 <code>commit</code> 之前执行一个函数（<code>callback</code>）。这个函数成功执行完之后，再继续 <code>commit</code>，但是失败之后就阻止 <code>commit</code></li><li>在 <code>.git/hooks/</code>下面有个 <code>pre-commit.sample*</code> ，这个里面就是默认的函数(脚本)样本</li></ul><h2 id="安装-pre-commit"><a href="#安装-pre-commit" class="headerlink" title="安装 pre-commit"></a>安装 pre-commit</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pre-commit --save-dev</span><br></pre></td></tr></table></figure><h2 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h2><p>如果没有在 <code>.git/hooks</code> 目录下生成 <code>pre-commit</code> 文件的话，则要手工创建 <code>node ./node_modules/pre-commit/install.js</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line"><span class="code">    "build": "tsc",</span></span><br><span class="line"><span class="code">    "eslint": "eslint src --ext .ts",</span></span><br><span class="line"><span class="code">    "eslint:fix": "eslint src --ext .ts --fix"</span></span><br><span class="line">  &#125;,</span><br><span class="line"> //在提交代码之前，先执行 scripts 中的 eslint 命令 </span><br><span class="line">  "pre-commit": [</span><br><span class="line"><span class="code">    "eslint"</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="跳过-pre-commit-继续提交代码"><a href="#跳过-pre-commit-继续提交代码" class="headerlink" title="跳过 pre-commit 继续提交代码"></a>跳过 pre-commit 继续提交代码</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 跳过验证</span></span><br><span class="line">git commit --no-verify</span><br><span class="line">git commit -n</span><br></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="将本地新建的项目上传到新建的远程仓库上"><a href="#将本地新建的项目上传到新建的远程仓库上" class="headerlink" title="将本地新建的项目上传到新建的远程仓库上"></a>将本地新建的项目上传到新建的远程仓库上</h2><p>之前没有进行过关联，即没有通过 clone 远程项目到本地再开始做项目，而是先本地新建了一个项目，然后想传到远程仓库上。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 将本地仓库和远程仓库关联起来</span></span><br><span class="line">git remote add origin 远程仓库地址</span><br><span class="line"></span><br><span class="line"><span class="section"># 将本地的 master 分支推送到 origin 主机，同时指定 origin 为默认主机</span></span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line"><span class="section"># 上面的命名执行后，下次再从本地库上传内容的时候只需下面这样就可以了</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="不小心把某些文件上传到远程-git-仓库-想要删除远程仓库中的文件"><a href="#不小心把某些文件上传到远程-git-仓库-想要删除远程仓库中的文件" class="headerlink" title="不小心把某些文件上传到远程 git 仓库/想要删除远程仓库中的文件"></a>不小心把某些文件上传到远程 git 仓库/想要删除远程仓库中的文件</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 删除暂存区和工作区的文件</span></span><br><span class="line">git rm filename</span><br><span class="line"></span><br><span class="line"><span class="section"># 只删除暂存区的文件, 不会删除工作区的文件</span></span><br><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure><h2 id="每次-git-push-都要输入用户名、密码"><a href="#每次-git-push-都要输入用户名、密码" class="headerlink" title="每次 git push 都要输入用户名、密码"></a>每次 git push 都要输入用户名、密码</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 生成公钥</span></span><br><span class="line">ssh-keygen -t rsa -C "xxxxx@xxxxx.com"</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看已生成的公钥</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="section"># 复制已生成的公钥添加到 git 服务器</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 测试ssh是否能够连接成功</span></span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="section"># 设置远程仓库</span></span><br><span class="line">git remote set-url origin git@xxx.com/xxx.git</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://juejin.im/post/5ee649ff51882542ea2b5108&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;三年 Git 使用心得 &amp;amp; 常见问题整理&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Git" scheme="http://blog.caoxl.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>使用 Gitlab+Jenkins 实现自动化构建</title>
    <link href="http://blog.caoxl.com/2020/06/03/Gitlab-Jenkins-AutoBuild/"/>
    <id>http://blog.caoxl.com/2020/06/03/Gitlab-Jenkins-AutoBuild/</id>
    <published>2020-06-03T01:20:01.000Z</published>
    <updated>2020-06-04T06:22:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>使用 Gitlab+Jenkins 实现自动化构建</p></blockquote><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="Jenkins-密钥配置"><a href="#Jenkins-密钥配置" class="headerlink" title="Jenkins 密钥配置"></a>Jenkins 密钥配置</h2><ul><li>设置jenkins的shell终端为/bin/bash</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl ~]# grep jenkins /etc/passwd</span><br><span class="line">jenkins:x:990:987:Jenkins Automation Server:/var/lib/jenkins:/bin/false</span><br></pre></td></tr></table></figure><ul><li>登录到jenkins用户生成密钥</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl ~]# su - jenkins</span><br><span class="line">Last login: Wed Jun  3 15:27:02 CST 2020 on pts/3</span><br><span class="line">[root@caoxl ~]# ssh-keygen -t rsa</span><br><span class="line">[root@caoxl ~]# cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><ul><li>添加公钥到gitlab服务器，用来clone代码</li><li>添加完成之后从gitlab服务器clone下自己的工程，会在.ssh/known_hosts添加gitlab服务器记录</li><li>添加公钥到jenkins服务器root用户，用来执行部署脚本</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 输入以下, 并且输入服务器密码即可</span><br><span class="line">[root@caoxl ~]# ssh-copy-id -i .ssh/id_rsa.pub root@47.107.169.233</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: ".ssh/id_rsa.pub"</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">root@47.107.169.233's password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   "ssh 'root@47.107.169.233'"</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure><h2 id="准备一个脚本"><a href="#准备一个脚本" class="headerlink" title="准备一个脚本"></a>准备一个脚本</h2><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl deploy]# cat /shell/deploy/jenkins_deploy.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "部署脚本被执行"</span><br></pre></td></tr></table></figure><p>注意：如果是生产配置，直接把这个脚本换成对应项目的上线脚本即可，jenkins配置无须修改。</p><ul><li>正式脚本</li></ul><blockquote><p>/bin/sh /shell/deploy/jenkins_deploy.sh ${WORKSPACE} ${JOB_NAME} ${BUILD_NUMBER}</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /$&#123;WORKSPACE&#125;</span><br><span class="line">tar -zcvf /var/www/code<span class="emphasis">_backup/$&#123;JOB_</span>NAME&#125;<span class="emphasis">_$&#123;BUILD_</span>NUMBER&#125;.tar.gz $&#123;JOB_NAME&#125;</span><br><span class="line">tar -zcvf /var/www/code<span class="emphasis">_backup/$&#123;JOB_</span>NAME&#125;<span class="emphasis">_$&#123;BUILD_</span>NUMBER&#125;_bak.tar.gz /var/www/lumen6.caoxl.com</span><br><span class="line">mv /var/www/code<span class="emphasis">_backup/$&#123;JOB_</span>NAME&#125;<span class="emphasis">_$&#123;BUILD_</span>NUMBER&#125;.tar.gz /var/www/</span><br><span class="line">cd /var/www/</span><br><span class="line">tar -zxvf $&#123;JOB<span class="emphasis">_NAME&#125;_</span>$&#123;BUILD_NUMBER&#125;.tar.gz</span><br><span class="line">rm $&#123;JOB<span class="emphasis">_NAME&#125;_</span>$&#123;BUILD_NUMBER&#125;.tar.gz</span><br><span class="line">chown -Rf www:www *</span><br></pre></td></tr></table></figure><h1 id="Jenkins-触发式构建"><a href="#Jenkins-触发式构建" class="headerlink" title="Jenkins 触发式构建"></a>Jenkins 触发式构建</h1><blockquote><p>用于开发环境部署，开发人员push代码或者合并代码到gitlab项目的master分支，jenkins就部署代码到对应服务器。</p></blockquote><h1 id="Jenkins-参数化构建"><a href="#Jenkins-参数化构建" class="headerlink" title="Jenkins 参数化构建"></a>Jenkins 参数化构建</h1><blockquote><p>用于测试环境预上线环境部署，开发push代码或者合并代码到gitlab项目的master分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。</p></blockquote><h1 id="Jenkins-定时构建"><a href="#Jenkins-定时构建" class="headerlink" title="Jenkins 定时构建"></a>Jenkins 定时构建</h1><blockquote><p>用于APP自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就每天凌晨从gitlab拉取最新的APP代码打包。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 Gitlab+Jenkins 实现自动化构建&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Gitlab" scheme="http://blog.caoxl.com/tags/Gitlab/"/>
    
      <category term="Jenkins" scheme="http://blog.caoxl.com/tags/Jenkins/"/>
    
      <category term="自动化构建" scheme="http://blog.caoxl.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 安装部署 Jenkins</title>
    <link href="http://blog.caoxl.com/2020/06/02/Install-Jenkins-In-CentOS7/"/>
    <id>http://blog.caoxl.com/2020/06/02/Install-Jenkins-In-CentOS7/</id>
    <published>2020-06-02T03:40:05.000Z</published>
    <updated>2020-06-02T07:20:23.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Jenkins是一个开源的支持自动化构建、部署等任务的平台。基本上可以说是持续集成（CI）、持续发布（CD）不可或缺的工具。<br><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins 官网</a></p></blockquote><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="本篇环境信息"><a href="#本篇环境信息" class="headerlink" title="本篇环境信息"></a>本篇环境信息</h2><table><thead><tr><th style="text-align:left">工具/环境</th><th style="text-align:left">版本</th></tr></thead><tbody><tr><td style="text-align:left">Linux Server</td><td style="text-align:left">CentOS7</td></tr><tr><td style="text-align:left">Jenkins</td><td style="text-align:left">2.222.4</td></tr><tr><td style="text-align:left">JDK</td><td style="text-align:left">1.8.0_212</td></tr><tr><td style="text-align:left">Nginx</td><td style="text-align:left">1.15.1</td></tr></tbody></table><ul><li>查看JAVA SDK版本</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl ~]# java -version</span><br><span class="line">openjdk version "1.8.0_212"</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_212-b04)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.212-b04, mixed mode)</span><br></pre></td></tr></table></figure><ul><li>查看Nginx版本</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl ~]# /usr/local/nginx/sbin/nginx -V</span><br><span class="line">nginx version: nginx/1.15.1</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) </span><br><span class="line">configure arguments:</span><br></pre></td></tr></table></figure><ul><li>查看Jenkins端口</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl ~]# cat /etc/sysconfig/jenkins | grep "JENKINS_PORT"</span><br><span class="line">JENKINS_PORT="8080"</span><br></pre></td></tr></table></figure><h1 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h1><h2 id="Yum安装"><a href="#Yum安装" class="headerlink" title="Yum安装"></a>Yum安装</h2><ul><li>yum源导入</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#添加Yum源</span></span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line"></span><br><span class="line"><span class="section">#导入密钥</span></span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure><ul><li>安装</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y jenkins</span><br></pre></td></tr></table></figure><h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><p>Jenkins站点的默认监听端口是8080</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --add-port=8080/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h2 id="配置Java可选路径"><a href="#配置Java可选路径" class="headerlink" title="配置Java可选路径"></a>配置Java可选路径</h2><p>因为Jenkins默认的java可选路径不包含我们部署的jdk路径，所以这里要配置一下，不然Jenkins服务会启动失败</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#修改jenkins启动脚本</span></span><br><span class="line">sudo vi /etc/init.d/jenkins</span><br><span class="line"></span><br><span class="line"><span class="section">#修改candidates增加java可选路径：/usr/java/jdk1.8.0_181/bin/java</span></span><br><span class="line">candidates="</span><br><span class="line"><span class="code">    /etc/alternatives/java</span></span><br><span class="line"><span class="code">    /usr/lib/jvm/java-1.8.0/bin/java</span></span><br><span class="line"><span class="code">    /usr/lib/jvm/jre-1.8.0/bin/java</span></span><br><span class="line"><span class="code">    /usr/lib/jvm/java-1.7.0/bin/java</span></span><br><span class="line"><span class="code">    /usr/lib/jvm/jre-1.7.0/bin/java</span></span><br><span class="line"><span class="code">    /usr/lib/jvm/java-11.0/bin/java</span></span><br><span class="line"><span class="code">    /usr/lib/jvm/jre-11.0/bin/java</span></span><br><span class="line"><span class="code">    /usr/lib/jvm/java-11-openjdk-amd64</span></span><br><span class="line"><span class="code">    /usr/bin/java</span></span><br><span class="line">"</span><br></pre></td></tr></table></figure><h2 id="启动Jenkins并设置Jenkins开机启动"><a href="#启动Jenkins并设置Jenkins开机启动" class="headerlink" title="启动Jenkins并设置Jenkins开机启动"></a>启动Jenkins并设置Jenkins开机启动</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#重载服务（由于前面修改了Jenkins启动脚本）</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="section">#启动Jenkins服务</span></span><br><span class="line">sudo systemctl start jenkins</span><br><span class="line"></span><br><span class="line"><span class="section">#将Jenkins服务设置为开机启动</span></span><br><span class="line"><span class="section">#由于Jenkins不是Native Service，所以需要用chkconfig命令而不是systemctl命令</span></span><br><span class="line">sudo /sbin/chkconfig jenkins on</span><br></pre></td></tr></table></figure><p>浏览器输入 <code>http://&lt;ip address&gt;:8080</code> 访问Jenkins</p><h2 id="修改Jenkins端口"><a href="#修改Jenkins端口" class="headerlink" title="修改Jenkins端口"></a>修改Jenkins端口</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br><span class="line">JENKINS_PORT="8080" // 修改成自己需要的端口即可</span><br><span class="line"></span><br><span class="line">// 重新启动jenkins</span><br><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure><h1 id="配置Nginx反向代理Jenkins"><a href="#配置Nginx反向代理Jenkins" class="headerlink" title="配置Nginx反向代理Jenkins"></a>配置Nginx反向代理Jenkins</h1><ul><li>新建配置文件</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#新增Jenkins专用Nginx配置文件</span></span><br><span class="line">sudo vi /etc/nginx/conf.d/jenkins.conf</span><br><span class="line"></span><br><span class="line"><span class="section">#输入以下内容并保存</span></span><br><span class="line">server &#123;</span><br><span class="line"><span class="code">    listen 80;#监听80端口</span></span><br><span class="line"><span class="code">    server_name jenkins.caoxl.com;#监听的域名</span></span><br><span class="line"><span class="code">    access_log  /var/log/nginx/jenkins.access.log main;</span></span><br><span class="line"><span class="code">    error_log  /var/log/nginx/jenkins.error.log error;</span></span><br><span class="line"></span><br><span class="line"><span class="code">    location / &#123; #转发或处理</span></span><br><span class="line"><span class="code">        proxy_pass http://127.0.0.1:8080; </span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    error_page   500 502 503 504  /50x.html;#错误页</span></span><br><span class="line"><span class="code">    location = /50x.html &#123;</span></span><br><span class="line"><span class="code">        root   /usr/share/nginx/html;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重载Nginx配置</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><p>报<code>-bash: nginx: command not found</code>, 解决办法</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl sbin]# vi /etc/profile</span><br><span class="line">export PATH=$PATH:/usr/local/nginx/sbin  // Nginx可执行文件路径</span><br><span class="line">[root@caoxl sbin]# source /etc/profile</span><br></pre></td></tr></table></figure><h1 id="解决Jenkins插件下载慢的问题"><a href="#解决Jenkins插件下载慢的问题" class="headerlink" title="解决Jenkins插件下载慢的问题"></a>解决Jenkins插件下载慢的问题</h1><h2 id="修改插件下载链接"><a href="#修改插件下载链接" class="headerlink" title="修改插件下载链接"></a>修改插件下载链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/jenkins/hudson.model.UpdateCenter.xml</span><br><span class="line"></span><br><span class="line"><span class="section"># 修改</span></span><br><span class="line">https://updates.jenkins.io/update-center.json</span><br><span class="line"><span class="section"># 为</span></span><br><span class="line">http://mirror.xmission.com/jenkins/updates/update-center.json</span><br><span class="line"></span><br><span class="line"><span class="section"># 重新启动jenkins</span></span><br><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure><h2 id="修改default-json"><a href="#修改default-json" class="headerlink" title="修改default.json"></a>修改default.json</h2><p>cd 到<code>updates</code>目录,找到<code>default.json</code>文件</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl updates]# pwd</span><br><span class="line">/var/lib/jenkins/updates</span><br><span class="line">[root@caoxl updates]# ll</span><br><span class="line">total 2.2M</span><br><span class="line">-rw-r--r-- 1 jenkins jenkins 1.9M Jun  2 14:22 default.json</span><br><span class="line">-rw-r--r-- 1 jenkins jenkins 5.3K Jun  2 14:22 hudson.tasks.Maven.MavenInstaller</span><br><span class="line">-rw-r--r-- 1 jenkins jenkins 274K Jun  2 14:53 hudson.tools.JDKInstaller</span><br></pre></td></tr></table></figure><p>使用vi编辑文件，如下，替换所有插件下载的url</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</span><br></pre></td></tr></table></figure><p>替换连接测试url</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</span><br></pre></td></tr></table></figure><p><strong>进入vi先输入<code>:</code>然后再粘贴上边的<code>:</code>后边的命令，注意不要写两个冒号!</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/5aa76e416fb9a028d37512c1" target="_blank" rel="noopener">使用CentOS7安装配置Jenkins</a></li><li><a href="https://ken.io/note/centos7-jenkins-install-tutorial" target="_blank" rel="noopener">CentOS 7 下Jenkins安装部署教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Jenkins是一个开源的支持自动化构建、部署等任务的平台。基本上可以说是持续集成（CI）、持续发布（CD）不可或缺的工具。&lt;br&gt;&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jenkins 官网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="CentOS7" scheme="http://blog.caoxl.com/tags/CentOS7/"/>
    
      <category term="Jenkins" scheme="http://blog.caoxl.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 安装部署 Gitlab</title>
    <link href="http://blog.caoxl.com/2020/06/01/Install-Gitlab-In-Centos7/"/>
    <id>http://blog.caoxl.com/2020/06/01/Install-Gitlab-In-Centos7/</id>
    <published>2020-06-01T01:46:29.000Z</published>
    <updated>2020-06-02T06:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>GitLab一个开源的git仓库管理平台，方便团队协作开发、管理。</p></blockquote><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装基础依赖"><a href="#安装基础依赖" class="headerlink" title="安装基础依赖"></a>安装基础依赖</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 安装基础依赖</span></span><br><span class="line">sudo yum install -y curl policycoreutils-python openssh-server</span><br><span class="line"></span><br><span class="line"><span class="section"># 启动ssh服务&amp;设置为开机启动</span></span><br><span class="line">sudo systemctl enable sshd</span><br><span class="line">sudo systemctl start sshd</span><br></pre></td></tr></table></figure><h2 id="安装Postfix"><a href="#安装Postfix" class="headerlink" title="安装Postfix"></a>安装Postfix</h2><p>Postfix是一个邮件服务器，GitLab发送邮件需要用到</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#安装postfix</span></span><br><span class="line">sudo yum install -y postfix</span><br><span class="line"></span><br><span class="line"><span class="section">#启动postfix并设置为开机启动</span></span><br><span class="line">sudo systemctl enable postfix</span><br><span class="line">sudo systemctl start postfix</span><br></pre></td></tr></table></figure><ul><li>报 <code>Job for postfix.service failed because the control process exited with error code. See &quot;systemctl status postfix.service&quot; and &quot;journalctl -xe&quot; for details.</code>错误, 解决办法:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 修改 /etc/postfix/main.cf 的设置</span></span><br><span class="line">inet_protocols = ipv4</span><br><span class="line">inet_interfaces = all</span><br><span class="line"><span class="section"># 重新启动postfix即可</span></span><br><span class="line">sudo systemctl restart postfix.service</span><br></pre></td></tr></table></figure><h2 id="开放ssh以及http服务（80端口）"><a href="#开放ssh以及http服务（80端口）" class="headerlink" title="开放ssh以及http服务（80端口）"></a>开放ssh以及http服务（80端口）</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#开放ssh、http服务</span></span><br><span class="line">sudo firewall-cmd --add-service=ssh --permanent</span><br><span class="line">sudo firewall-cmd --add-service=http --permanent</span><br><span class="line"></span><br><span class="line"><span class="section">#重载防火墙规则</span></span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><ul><li>报 <code>FirewallD is not running</code>, 解决办法:</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start firewalld</span><br></pre></td></tr></table></figure><h1 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h1><p>本次我们部署的是社区版:<code>gitlab-ce</code>，如果要部署商业版可以把关键字替换为：<code>gitlab-ee</code></p><h2 id="Yum安装GitLab"><a href="#Yum安装GitLab" class="headerlink" title="Yum安装GitLab"></a>Yum安装GitLab</h2><ul><li>添加GitLab社区版Package</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><ul><li>安装GitLab社区版</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y gitlab-ce</span><br></pre></td></tr></table></figure><p>安装成功后会看到gitlab-ce打印了以下图形</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">       *.                  *.</span></span><br><span class="line"><span class="code">      ***                 ***</span></span><br><span class="line"><span class="code">     *****               *****</span></span><br><span class="line"><span class="code">    .******             *******</span></span><br><span class="line"><span class="code">    ********            ********</span></span><br><span class="line">   ,,,,,,,,,<span class="strong">*****</span><span class="strong">*****</span>*,,,,,,,,,</span><br><span class="line">  ,,,,,,,,,,,<span class="strong">*****</span><span class="emphasis">***</span>*,,,,,,,,,,,</span><br><span class="line">  .,,,,,,,,,,,<span class="strong">*****</span>**,,,,,,,,,,,,</span><br><span class="line"><span class="code">      ,,,,,,,,,*****,,,,,,,,,.</span></span><br><span class="line"><span class="code">         ,,,,,,,****,,,,,,</span></span><br><span class="line"><span class="code">            .,,,***,,,,</span></span><br><span class="line"><span class="code">                ,*,.</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="code">     _______ __  __          __</span></span><br><span class="line"><span class="code">    / ____(_) /_/ /   ____ _/ /_</span></span><br><span class="line">   / / <span class="strong">__/ / __</span>/ /   / <span class="strong">__ `/ __</span> \</span><br><span class="line">  / /<span class="emphasis">_/ / / /_</span>/ /<span class="emphasis">___</span>/ /<span class="emphasis">_/ / /_</span>/ /</span><br><span class="line">  \<span class="strong">____/_/\__</span>/<span class="strong">_____</span>/\<span class="strong">__,_/_.__</span>_/</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">Thank you for installing GitLab!</span><br></pre></td></tr></table></figure><h2 id="配置GitLab站点Url"><a href="#配置GitLab站点Url" class="headerlink" title="配置GitLab站点Url"></a>配置GitLab站点Url</h2><p>GitLab默认的配置文件路径是<code>/etc/gitlab/gitlab.rb</code></p><p>默认的站点Url配置项是：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_url 'http://gitlab.example.com'</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#修改配置文件</span></span><br><span class="line">sudo vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"><span class="section">#配置首页地址</span></span><br><span class="line">external_url 'http://gitlab.caoxl.com'</span><br></pre></td></tr></table></figure><ul><li>防火墙开启端口</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@caoxl init.d]# firewall-cmd --add-port=9999/tcp --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h2 id="启动并访问Gitlab"><a href="#启动并访问Gitlab" class="headerlink" title="启动并访问Gitlab"></a>启动并访问Gitlab</h2><ul><li>启动Gitlab</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#重新配置并启动</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line"></span><br><span class="line"><span class="section">#完成后将会看到如下输出</span></span><br><span class="line">Running handlers:</span><br><span class="line">Running handlers complete</span><br><span class="line">Chef Client finished, 3/709 resources updated in 15 seconds</span><br><span class="line">gitlab Reconfigured!</span><br><span class="line"></span><br><span class="line"><span class="section">#启动</span></span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure><ul><li>访问Gitlab</li></ul><p>将设置的域名DNS解析到服务器IP，或者修改本地host将域名指向服务器IP。访问：<code>http://gitlab.caoxl.com</code></p><p>这时候会提示为管理员账号设置密码。管理员账号默认username是<code>root</code>。<br>设置完成之后即可使用<code>root</code>账号登录，登陆后会进入欢迎界面。</p><ul><li>报<code>ruby_block[authorize Grafana with GitLab] action run</code>,解决办法</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># vim /etc/gitlab/gitlab.rb</span></span><br><span class="line">monitoring[<span class="string">'grafana'</span>][<span class="symbol">'enable'</span>] = false</span><br></pre></td></tr></table></figure><ul><li>报 <code>Whoops, GitLab is taking too much time to respond. (502)错误</code>, 解决办法</li></ul><p>原因是端口被其他服务占用了，需要更换配置文件里得到端口 ，并且执行<code>gitlab-ctl reconfigure</code>, <code>gitlab-ctl restart</code> 就可以解决</p><h1 id="GitLab常用配置"><a href="#GitLab常用配置" class="headerlink" title="GitLab常用配置"></a>GitLab常用配置</h1><h2 id="邮件配置"><a href="#邮件配置" class="headerlink" title="邮件配置"></a>邮件配置</h2><p>配置邮箱可以让GitLab在发生相应事件的时候进行邮件通知<br>比如：找回密码、添加邮箱等</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#修改配置文件</span></span><br><span class="line">sudo vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"><span class="section">#邮件配置</span></span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>enable'] = true</span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>address'] = 'smtp.163.com'</span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>port'] = 465</span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>user_name'] = 'yourmail@163.com'</span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>password'] = 'yourpasswd'</span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>domain'] = 'smtp.163.com'</span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>authentication'] = 'login'</span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>enable<span class="emphasis">_starttls_</span>auto'] = true</span><br><span class="line">gitlab<span class="emphasis">_rails['smtp_</span>tls'] = true</span><br><span class="line">gitlab<span class="emphasis">_rails['gitlab_</span>email_enabled'] = true</span><br><span class="line">gitlab<span class="emphasis">_rails['gitlab_</span>email_from'] = 'yourmail@163.com'</span><br><span class="line">gitlab<span class="emphasis">_rails['gitlab_</span>email<span class="emphasis">_display_</span>name'] = 'Gitlab'</span><br><span class="line"></span><br><span class="line"><span class="section">#保存后，重新配置并启动GitLab</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><h2 id="禁用创建组权限"><a href="#禁用创建组权限" class="headerlink" title="禁用创建组权限"></a>禁用创建组权限</h2><p>GitLab默认所有的注册用户都可以创建组。但对于团队来说，通常只会给Leader相关权限。<br>虽然可以在用户管理界面取消权限，但毕竟不方便。我们可以通过配置GitLab默认禁用创建组权限。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#修改配置文件</span></span><br><span class="line">sudo vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line"><span class="section">#开启gitlab_rails['gitlab_default_can_create_group'] 选项，并将值设置为false</span></span><br><span class="line"><span class="section">### GitLab user privileges</span></span><br><span class="line">gitlab<span class="emphasis">_rails['gitlab_</span>default<span class="emphasis">_can_</span>create_group'] = false</span><br><span class="line"></span><br><span class="line"><span class="section">#保存后，重新配置并启动GitLab</span></span><br><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><h2 id="gitlab-ctl常用命令介绍"><a href="#gitlab-ctl常用命令介绍" class="headerlink" title="gitlab-ctl常用命令介绍"></a>gitlab-ctl常用命令介绍</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl cmd</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>check-config</code></td><td style="text-align:left">检查在gitlab中是否有任何配置。在指定版本中删除的rb</td></tr><tr><td style="text-align:left"><code>deploy-page</code></td><td style="text-align:left">安装部署页面</td></tr><tr><td style="text-align:left"><code>diff-config</code></td><td style="text-align:left">将用户配置与包可用配置进行比较</td></tr><tr><td style="text-align:left"><code>remove-accounts</code></td><td style="text-align:left">删除所有用户和组</td></tr><tr><td style="text-align:left"><code>upgrade</code></td><td style="text-align:left">升级</td></tr><tr><td style="text-align:left"><code>once</code></td><td style="text-align:left">如果GitLab服务停止了就启动服务，如果已启动就不做任何操作</td></tr><tr><td style="text-align:left"><code>restart</code></td><td style="text-align:left">重启GitLab服务</td></tr><tr><td style="text-align:left"><code>start</code></td><td style="text-align:left">如果GitLab服务停止了就启动服务，如果已启动就重启服务</td></tr><tr><td style="text-align:left"><code>stop</code></td><td style="text-align:left">停止GitLab服务</td></tr><tr><td style="text-align:left"><code>status</code></td><td style="text-align:left">查看GitLab服务状态</td></tr><tr><td style="text-align:left"><code>reconfigure</code></td><td style="text-align:left">reconfigure重新配置GitLab并启动</td></tr></tbody></table><h1 id="解决Gitlab的Nginx以及自带Nginx冲突问题"><a href="#解决Gitlab的Nginx以及自带Nginx冲突问题" class="headerlink" title="解决Gitlab的Nginx以及自带Nginx冲突问题"></a>解决Gitlab的Nginx以及自带Nginx冲突问题</h1><blockquote><p>vim /etc/gitlab/gitlab.rb</p></blockquote><p>做以下修改:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 禁用Gitlab的nginx</span><br><span class="line">nginx['enable'] = false</span><br><span class="line"></span><br><span class="line">// 设置自建Nginx的用户, 查看用户命令看说明</span><br><span class="line">web<span class="emphasis">_server['external_</span>users'] = ['www']</span><br><span class="line"></span><br><span class="line">// 修改监听方式和监听地址</span><br><span class="line">gitlab<span class="emphasis">_workhorse['listen_</span>network'] = "tcp"</span><br><span class="line">gitlab<span class="emphasis">_workhorse['listen_</span>addr'] = "127.0.0.1:9999"</span><br><span class="line"></span><br><span class="line">// 最后执行下面命令让配置生效：</span><br><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><ul><li><code>说明</code></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/local/nginx/conf/nginx.conf | grep user</span><br></pre></td></tr></table></figure><ul><li>配置Nginx, 新增<code>gitlab.conf</code></li></ul><blockquote><p><a href="https://gitlab.com/gitlab-org/gitlab-recipes/blob/master/web-server/nginx/gitlab-omnibus-nginx.conf" target="_blank" rel="noopener">官网提供配置 - gitlab-omnibus-nginx.conf</a></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">upstream gitlab-workhorse &#123;</span><br><span class="line"><span class="code">    server 127.0.0.1:9999; #根据实际情况修改, 与gitlab.rb中的gitlab_workhorse['listen_addr']一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">## Normal HTTP host</span></span><br><span class="line">server &#123;</span><br><span class="line"><span class="code">    listen 80;</span></span><br><span class="line"><span class="code">    listen [::]:80 default_server;</span></span><br><span class="line"><span class="code">    server_name gitlab.caoxl.com; ## 修改成自己的域名；</span></span><br><span class="line"><span class="code">    server_tokens off; ## Don't show the nginx version number, a security best practice</span></span><br><span class="line"><span class="code">    root /opt/gitlab/embedded/service/gitlab-rails/public;</span></span><br><span class="line"></span><br><span class="line"><span class="code">    ## See app/controllers/application_controller.rb for headers set</span></span><br><span class="line"></span><br><span class="line"><span class="code">    ## Individual nginx logs for this GitLab vhost</span></span><br><span class="line"><span class="code">    access_log  /var/log/nginx/gitlab_access.log; # 根据实际情况修改</span></span><br><span class="line"><span class="code">    error_log   /var/log/nginx/gitlab_error.log;  # 根据实际情况修改</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="code">    location / &#123;</span></span><br><span class="line"><span class="code">        client_max_body_size 0;</span></span><br><span class="line"><span class="code">        gzip off;</span></span><br><span class="line"></span><br><span class="line"><span class="code">        ## https://github.com/gitlabhq/gitlabhq/issues/694</span></span><br><span class="line"><span class="code">        ## Some requests take more than 30 seconds.</span></span><br><span class="line"><span class="code">        proxy_read_timeout      300;</span></span><br><span class="line"><span class="code">        proxy_connect_timeout   300;</span></span><br><span class="line"><span class="code">        proxy_redirect          off;</span></span><br><span class="line"></span><br><span class="line"><span class="code">        proxy_http_version 1.1;</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">        proxy_set_header    Host                $http_host;</span></span><br><span class="line"><span class="code">        proxy_set_header    X-Real-IP           $remote_addr;</span></span><br><span class="line"><span class="code">        proxy_set_header    X-Forwarded-For     $proxy_add_x_forwarded_for;</span></span><br><span class="line"><span class="code">        proxy_set_header    X-Forwarded-Proto   $scheme;</span></span><br><span class="line"></span><br><span class="line"><span class="code">        proxy_pass http://gitlab-workhorse;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重启Nginx: <code>sudo service nginx restart</code></li></ul><h1 id="解决Gitlab访问502问题"><a href="#解决Gitlab访问502问题" class="headerlink" title="解决Gitlab访问502问题"></a>解决Gitlab访问502问题</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R o+x /opt/gitlab/embedded/service//gitlab-rails/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;GitLab一个开源的git仓库管理平台，方便团队协作开发、管理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="必备技能" scheme="http://blog.caoxl.com/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="Gitlab" scheme="http://blog.caoxl.com/tags/Gitlab/"/>
    
      <category term="CentOS7" scheme="http://blog.caoxl.com/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>值得期待的PHP8新特性</title>
    <link href="http://blog.caoxl.com/2020/05/30/Hello-PHP8/"/>
    <id>http://blog.caoxl.com/2020/05/30/Hello-PHP8/</id>
    <published>2020-05-30T01:31:16.000Z</published>
    <updated>2020-05-30T03:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>罗列出 PHP8 中会发生的一些改变：新功能、性能改进和突破性变化。</p></blockquote><a id="more"></a><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><h2 id="联合类型-Union-types"><a href="#联合类型-Union-types" class="headerlink" title="联合类型(Union types)"></a>联合类型(Union types)</h2><p>考虑到 PHP 的动态类型特性，联合类型在很多情况下都很有用。<br>联合类型是两个或多个类型的集合，这些类型指示可以使用这两个类型中的任何一个。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(Foo|Bar $input)</span>: <span class="title">int</span>|<span class="title">float</span></span>;</span><br></pre></td></tr></table></figure><p>请注意，void 永远不能是联合类型的一部分，因为它表示 “根本没有返回值”。</p><p>此外，可以使用 <code>|NULL</code> 或使用现有的 <code>？</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(Foo|null $foo)</span>: <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(?Bar $bar)</span>: <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><blockquote><p>JIT-Just-In-Time 编译器承诺显著提高性能，尽管在 Web 应用可能没有较大的好处。</p></blockquote><h2 id="静态返回类型-Static-return-types"><a href="#静态返回类型-Static-return-types" class="headerlink" title="静态返回类型 (Static return types)"></a>静态返回类型 (Static return types)</h2><p>虽然已经可以返回 self ，但在 PHP8 之前，静态不是有效的返回类型。考虑到 PHP 的动态类型特性，它对许多开发人员都很有用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span>: <span class="title">static</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">static</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="弱映射"><a href="#弱映射" class="headerlink" title="弱映射"></a>弱映射</h2><p>基于在 PHP 7.4 中添加的 <code>WeakRefs</code> RFC 的基础上，在 PHP 8 中 添加了 WeakMap 实现。<code>WeakMap</code> 包含对对象的引用，这不会阻止这些对象被垃圾回收。</p><p>以 ORM 为例，它们经常实现包含对实体类的引用的缓存，以提高实体之间关系的性能。<br>这些实体对象不能被垃圾回收，只要该缓存有对它们的引用，即使缓存是唯一引用它们的东西。</p><p>如果该缓存层改为使用弱引用和映射，则 PHP 将在其他对象不再引用这些对象时对它们进行垃圾回收。<br>特别是在 ORM 的情况下，它可以在一个请求中管理数百个 (如果不是数千个) 实体；弱映射可以提供一种更好、更资源友好的方式来处理这些对象。</p><p>以下是 Weak maps 的用法，RFC 中的一个示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakMap $cache;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getSomethingWithCaching</span><span class="params">(object $obj)</span>: <span class="title">object</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;cache[$obj] ??= <span class="keyword">$this</span>-&gt;computeSomethingExpensive($obj);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以在对象上使用-class"><a href="#可以在对象上使用-class" class="headerlink" title="可以在对象上使用 ::class"></a>可以在对象上使用 <code>::class</code></h2><p>一个小而有用的新特性：现在可以对对象使用 <code>::class</code>，而不必对它们使用 <code>get_class()</code>。<br>它的工作方式与 <code>get_class()</code> 相同。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line">var_dump($foo::class);</span><br></pre></td></tr></table></figure><h2 id="创建-DateTime-对象的接口"><a href="#创建-DateTime-对象的接口" class="headerlink" title="创建 DateTime 对象的接口"></a>创建 DateTime 对象的接口</h2><p>您已经可以使用 <code>DateTime::createFromImmutable($immutableDateTime)</code>，从 <code>DateTimeImmutable</code> 对象创建 <code>DateTime</code> 对象，但是反过来很棘手。</p><p>通过添加 <code>DateTime::createFromInterface()</code> 和 <code>DatetimeImmutable::createFromInterface()</code>，现在有了一种将 <code>DateTime</code> 和 <code>DateTimeImmutable</code> 对象相互转换的通用方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DateTime::createFromInterface(DateTimeInterface $other);</span><br><span class="line"></span><br><span class="line">DateTimeImmutable::createFromInterface(DateTimeInterface $other);</span><br></pre></td></tr></table></figure><h2 id="新的-Stringable-接口"><a href="#新的-Stringable-接口" class="headerlink" title="新的 Stringable 接口"></a>新的 <code>Stringable</code> 接口</h2><p><code>Stringable</code> 接口可用于键入提示任何字符串或实现<code>__toString()</code>。<br>此外，每当类实现 <code>__toString()</code> 时，它都会自动在幕后实现接口，不需要手动实现它。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span>: <span class="title">string</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(Stringable $stringable)</span> </span>&#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"></span><br><span class="line">bar(<span class="keyword">new</span> Foo());</span><br><span class="line">bar(<span class="string">'abc'</span>);</span><br></pre></td></tr></table></figure><h2 id="新的-str-contains-函数"><a href="#新的-str-contains-函数" class="headerlink" title="新的 str_contains() 函数"></a>新的 <code>str_contains()</code> 函数</h2><blockquote><p>有些人可能会说这是早就应该实现的功能，但是我们最终不必再依赖 <code>strpos()</code> 来知道一个字符串是否包含另一个字符串。</p></blockquote><ul><li>以前:</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (strpos(<span class="string">'string with lots of words'</span>, <span class="string">'words'</span>) !== <span class="keyword">false</span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 现在:</span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line">    <span class="keyword">if</span> (str_contains(<span class="string">'string with lots of words'</span>, <span class="string">'words'</span>)) &#123; <span class="comment">/* … */</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="新的-fdiv-函数"><a href="#新的-fdiv-函数" class="headerlink" title="新的 fdiv() 函数"></a>新的 <code>fdiv()</code> 函数</h2><p>新的 <code>fdiv()</code> 函数的作用类似于 <code>fmod()</code> 和 <code>intdiv()</code> 函数，它们<strong>允许被 0 整除</strong>。<br>您将得到 <code>INF</code>、<code>-INF</code> 或 <code>NaN</code> ，而不是错误，具体取决于大小写。</p><h2 id="新的-get-debug-type-函数"><a href="#新的-get-debug-type-函数" class="headerlink" title="新的 get_debug_type() 函数"></a>新的 <code>get_debug_type()</code> 函数</h2><p><code>get_debug_type()</code> 返回一个变量的类型。<br>听起来像是 <code>gettype()</code> 可以实现的功能。<br><code>get_debug_type()</code> 为数组、字符串、匿名类和对象返回更有用的输出。</p><p>例如，在类 <code>\foo\Bar</code> 上调用 <code>gettype()</code> 将返回 <code>Object</code>。<br>使用 <code>get_debug_type()</code> 将返回类名。</p><h2 id="改进-traits-里的抽象方法"><a href="#改进-traits-里的抽象方法" class="headerlink" title="改进 traits 里的抽象方法"></a>改进 <code>traits</code> 里的抽象方法</h2><p>traits 可以指定必须由使用它们的类实现的抽象方法。<br>但是有一个警告：在 PHP8 之前，这些方法实现的签名没有经过验证。<br>在以下代码中有效：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> Test &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(int $input)</span>: <span class="title">int</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsesTrait</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Test</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">($input)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用 traits 并实现其抽象方法时，PHP8 将执行正确的方法签名验证。<br>这意味着您需要改写以下内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsesTrait</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Test</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(int $input)</span>: <span class="title">int</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="token-get-all-的对象接口-RFC"><a href="#token-get-all-的对象接口-RFC" class="headerlink" title="token_get_all() 的对象接口 RFC"></a><code>token_get_all()</code> 的对象接口 RFC</h2><p>函数的作用是：返回值的是一个数组。<br>此 RFC 使用 <code>PhpToken::getall()</code> 方法添加一个 <code>PhpToken</code> 类。<br>此实现使用对象，而不是普通值。<br>它消耗更少的内存，更容易阅读。</p><h2 id="统一错误类型-RFC"><a href="#统一错误类型-RFC" class="headerlink" title="统一错误类型 RFC"></a>统一错误类型 RFC</h2><p>PHP 中的用户定义函数已经抛出 <code>TypeErrors</code>，但是内部函数没有抛出 <code>TypeErrors</code>，而是发出警告并返回 <code>NULL</code>。<br>从 PHP8 开始，内部函数的行为已经保持一致。</p><h2 id="默认错误报告级别"><a href="#默认错误报告级别" class="headerlink" title="默认错误报告级别"></a>默认错误报告级别</h2><p>现在是 <code>E_ALL</code>，而不是除 <code>E_NOTICE</code> 和 <code>E_DEVERATED</code> 之外的所有内容。<br>这意味着可能会弹出许多以前被悄悄忽略的错误，尽管在 PHP8 之前可能已经存在</p><h2 id="运算符不再忽略致命错误"><a href="#运算符不再忽略致命错误" class="headerlink" title="@运算符不再忽略致命错误"></a>@运算符不再忽略致命错误</h2><p>此更改可能会揭示在 PHP8 之前隐藏的错误。请确保在生产服务器上设置 <code>display_errors=off</code></p><h2 id="串联优先级-RFC"><a href="#串联优先级-RFC" class="headerlink" title="串联优先级 RFC"></a>串联优先级 RFC</h2><p>虽然在 PHP7.4 中已不推荐使用，但此更改现在生效。<br>如果你这样写的话：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"sum: "</span> . $a + $b;</span><br></pre></td></tr></table></figure><p>PHP 以前会这样解释它：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> (<span class="string">"sum: "</span> . $a) + $b;</span><br></pre></td></tr></table></figure><p>PHP 8 将会这样解释它：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"sum: "</span> . ($a + $b);</span><br></pre></td></tr></table></figure><h2 id="反射方法签名更改"><a href="#反射方法签名更改" class="headerlink" title="反射方法签名更改"></a>反射方法签名更改</h2><p>反射类的三个方法签名已更改：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReflectionClass::newInstance($args);</span><br><span class="line">ReflectionFunction::invoke($args);</span><br><span class="line">ReflectionMethod::invoke($object, $args);</span><br></pre></td></tr></table></figure><p>现已成为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReflectionClass::newInstance(...$args);</span><br><span class="line">ReflectionFunction::invoke(...$args);</span><br><span class="line">ReflectionMethod::invoke($object, ...$args);</span><br></pre></td></tr></table></figure><p>升级指南指定，如果您扩展了这些类，并且仍然希望同时支持 PHP 7 和 PHP 8，则允许以下签名：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReflectionClass::newInstance($arg = <span class="keyword">null</span>, ...$args);</span><br><span class="line">ReflectionFunction::invoke($arg = <span class="keyword">null</span>, ...$args);</span><br><span class="line">ReflectionMethod::invoke($object, $arg = <span class="keyword">null</span>, ...$args);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;罗列出 PHP8 中会发生的一些改变：新功能、性能改进和突破性变化。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://blog.caoxl.com/categories/PHP/"/>
    
    
      <category term="PHP8" scheme="http://blog.caoxl.com/tags/PHP8/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试/笔试题杂记 VIII</title>
    <link href="http://blog.caoxl.com/2020/05/21/Interview-Questions-Notes-VIII/"/>
    <id>http://blog.caoxl.com/2020/05/21/Interview-Questions-Notes-VIII/</id>
    <published>2020-05-21T03:35:49.000Z</published>
    <updated>2020-05-21T08:07:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>知识嘛就是常问常新.</p></blockquote><a id="more"></a><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL索引-全文索引-聚簇索引"><a href="#MySQL索引-全文索引-聚簇索引" class="headerlink" title="MySQL索引 (全文索引, 聚簇索引)"></a>MySQL索引 (全文索引, 聚簇索引)</h2><h3 id="FULLTEXT"><a href="#FULLTEXT" class="headerlink" title="FULLTEXT"></a>FULLTEXT</h3><p>即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE INDEX创建FULLTEXT索引，要比先为一张表建立FULLTEXT然后再将数据写入的速度快很多。</p><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><ul><li>Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。</li></ul><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</p><ul><li>Hash 索引无法被用来避免数据的排序操作。</li></ul><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；</p><ul><li>Hash 索引不能利用部分索引键查询。</li></ul><p>对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p><ul><li>Hash 索引在任何时候都不能避免表扫描。</li></ul><p>前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p><ul><li>Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。</li></ul><p>对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</p><h3 id="BTREE"><a href="#BTREE" class="headerlink" title="BTREE"></a>BTREE</h3><p>BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中</p><h2 id="MySQL引擎-MyISAM-InnoDB"><a href="#MySQL引擎-MyISAM-InnoDB" class="headerlink" title="MySQL引擎 (MyISAM, InnoDB)"></a>MySQL引擎 (MyISAM, InnoDB)</h2><ul><li><code>MyISAM</code>类型不支持事务处理等高级处理，而<code>InnoDB</code>类型支持.</li><li><code>MyISAM</code>类型的表强调的是性能，其执行数度比<code>InnoDB</code>类型更快.</li><li><code>InnoDB</code>不支持<code>FULLTEXT</code>类型的索引.</li><li><code>InnoDB</code>中不保存表的具体行数，也就是说，执行<code>select count(*) from table</code>时，<code>InnoDB</code>要扫描一遍整个表来计算有多少行，但是<code>MyISAM</code>只要简单的读出保存好的行数即可.</li><li>对于<code>AUTO_INCREMENT</code>类型的字段，InnoDB中必须包含只有该字段的索引，但是在<code>MyISAM</code>表中，可以和其他字段一起建立联合索引。</li><li><code>DELETE FROM table</code>时，<code>InnoDB</code>不会重新建立表，而是一行一行的删除。</li><li><code>LOAD TABLE FROM MASTER</code>操作对<code>InnoDB</code>是不起作用的，解决方法是首先把<code>InnoDB</code>表改成<code>MyISAM</code>表，导入数据后再改成<code>InnoDB</code>表，但是对于使用的额外的<code>InnoDB</code>特性(例如外键)的表不适用.</li><li><code>MyISAM</code>支持表锁，<code>InnoDB</code>支持行锁。</li></ul><h2 id="MySQL优化方式"><a href="#MySQL优化方式" class="headerlink" title="MySQL优化方式"></a>MySQL优化方式</h2><h3 id="MySQL-优化常用方法"><a href="#MySQL-优化常用方法" class="headerlink" title="MySQL 优化常用方法"></a>MySQL 优化常用方法</h3><ol><li>选取最适用的字段属性 </li><li>使用连接（JOIN）来代替子查询(Sub-Queries) </li><li>使用联合(UNION)来代替手动创建的临时表</li><li>事务 </li><li>锁定表</li><li>使用外键 </li><li>使用索引 </li><li>优化的查询语句 </li></ol><h3 id="MySQL-性能优化方案"><a href="#MySQL-性能优化方案" class="headerlink" title="MySQL 性能优化方案"></a>MySQL 性能优化方案</h3><ul><li>列出mysql服务器运行各种状态值</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global status;</span><br></pre></td></tr></table></figure><ul><li>查询mysql服务器配置信息语句</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables;</span><br></pre></td></tr></table></figure><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'slow%';</span><br><span class="line">+---------------------+-------------------------------------------+</span><br><span class="line">| Variable_name       | Value                                     |</span><br><span class="line">+---------------------+-------------------------------------------+</span><br><span class="line">| slow<span class="emphasis">_launch_</span>time    | 2                                         |</span><br><span class="line">| slow<span class="emphasis">_query_</span>log      | ON                                        |</span><br><span class="line">| slow<span class="emphasis">_query_</span>log<span class="emphasis">_file | /home/mysql/data3056/mysql/slow_</span>query.log |</span><br><span class="line">+---------------------+-------------------------------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; show global status like 'slow%';</span><br><span class="line">+---------------------+-------+</span><br><span class="line">| Variable_name       | Value |</span><br><span class="line">+---------------------+-------+</span><br><span class="line">| Slow<span class="emphasis">_launch_</span>threads | 0     |</span><br><span class="line">| Slow_queries        | 52321 |</span><br><span class="line">+---------------------+-------+</span><br></pre></td></tr></table></figure><h4 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'max_connections';</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| max_connections | 4532  |</span><br><span class="line">+-----------------+-------+</span><br></pre></td></tr></table></figure><ul><li>查询一下服务器响应的最大连接数：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'max<span class="emphasis">_used_</span>connections';</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Variable_name        | Value |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| Max<span class="emphasis">_used_</span>connections | 835   |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure><h4 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'created_tmp%';</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Variable_name           | Value     |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Created<span class="emphasis">_tmp_</span>disk_tables | 44999364  |</span><br><span class="line">| Created<span class="emphasis">_tmp_</span>files       | 1763      |</span><br><span class="line">| Created<span class="emphasis">_tmp_</span>tables      | 120658849 |</span><br><span class="line">+-------------------------+-----------+</span><br></pre></td></tr></table></figure><ul><li>查看一下mysql服务器对临时表的配置</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  show variables where variable<span class="emphasis">_name in ('tmp_</span>table<span class="emphasis">_size', 'max_</span>heap<span class="emphasis">_table_</span>size');</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| Variable_name       | Value    |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| max<span class="emphasis">_heap_</span>table_size | 67108864 |</span><br><span class="line">| tmp<span class="emphasis">_table_</span>size      | 2097152  |</span><br><span class="line">+---------------------+----------+</span><br></pre></td></tr></table></figure><h4 id="open-table-情况"><a href="#open-table-情况" class="headerlink" title="open table 情况"></a>open table 情况</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'open%tables%';</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Open_tables   | 1998  |</span><br><span class="line">| Opened_tables | 7704  |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure><blockquote><p><code>open_tables</code> 表示打开表的数量，<code>opened_tables</code>表示打开过的表数量，如果<code>opened_tables</code>数量过大，说明配置中 <code>table_open_cache</code>(5.1.3之前这个值叫做<code>table_cache</code>)值可能太小，我们查询一下服务器<code>table_open_cache</code>：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'table<span class="emphasis">_open_</span>cache';</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| table<span class="emphasis">_open_</span>cache | 2000  |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure><h4 id="进程使用情况"><a href="#进程使用情况" class="headerlink" title="进程使用情况"></a>进程使用情况</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'thread%';</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Threads_cached    | 10    |</span><br><span class="line">| Threads_connected | 736   |</span><br><span class="line">| Threads_created   | 85295 |</span><br><span class="line">| Threads_running   | 3     |</span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure><blockquote><p><code>threads_created</code>表示创建过的线程数，如果发现<code>threads_created</code>值过大的话，表明 mysql服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中<code>thread_cache_size</code>值，</p></blockquote><ul><li>查询服务器 thread_cache_size配置：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'thread<span class="emphasis">_cache_</span>size';</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| thread<span class="emphasis">_cache_</span>size | 100   |</span><br><span class="line">+-------------------+-------+</span><br></pre></td></tr></table></figure><h4 id="查询缓存-query-cache"><a href="#查询缓存-query-cache" class="headerlink" title="查询缓存(query cache)"></a>查询缓存(query cache)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'qcache%';</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Variable_name           | Value     |</span><br><span class="line">+-------------------------+-----------+</span><br><span class="line">| Qcache<span class="emphasis">_free_</span>blocks      | 1         |</span><br><span class="line">| Qcache<span class="emphasis">_free_</span>memory      | 3128864   |</span><br><span class="line">| Qcache_hits             | 0         |</span><br><span class="line">| Qcache_inserts          | 0         |</span><br><span class="line">| Qcache<span class="emphasis">_lowmem_</span>prunes    | 0         |</span><br><span class="line">| Qcache<span class="emphasis">_not_</span>cached       | 712727780 |</span><br><span class="line">| Qcache<span class="emphasis">_queries_</span>in_cache | 0         |</span><br><span class="line">| Qcache<span class="emphasis">_total_</span>blocks     | 1         |</span><br><span class="line">+-------------------------+-----------+</span><br></pre></td></tr></table></figure><ul><li><code>Qcache_free_blocks</code>: 缓存中相邻内存块的个数。数目大说明可能有碎片。flush query cache会对缓存中的碎片进行整理，从而得到一个空闲块。</li><li><code>Qcache_free_memory</code>: 缓存中的空闲内存</li><li><code>Qcache_hits</code>: 每次查询在缓存中命中时就增大</li><li><code>Qcache_inserts</code>: 每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。</li><li><code>Qcache_lowmem_prunes</code>: 缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存 很少。（上面的 free_blocks和free_memory可以告诉您属于哪种情况）</li><li><code>Qcache_not_cached</code>: 不适合进行缓存的查询的数量，通常是由于这些查询不是 select 语句或者用了now()之类的函数。</li><li><code>Qcache_queries_in_cache</code>: 当前缓存的查询（和响应）的数量。</li><li><code>Qcache_total_blocks</code>: 缓存中块的数量。</li></ul><p>再查询一下服务器关于query_cache的配置：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'query_cache%';</span><br><span class="line">+------------------------------+---------+</span><br><span class="line">| Variable_name                | Value   |</span><br><span class="line">+------------------------------+---------+</span><br><span class="line">| query<span class="emphasis">_cache_</span>limit            | 1048576 |</span><br><span class="line">| query<span class="emphasis">_cache_</span>min<span class="emphasis">_res_</span>unit     | 1024    |</span><br><span class="line">| query<span class="emphasis">_cache_</span>size             | 3145728 |</span><br><span class="line">| query<span class="emphasis">_cache_</span>type             | OFF     |</span><br><span class="line">| query<span class="emphasis">_cache_</span>wlock_invalidate | OFF     |</span><br><span class="line">+------------------------------+---------+</span><br></pre></td></tr></table></figure><ul><li><code>query_cache_limit</code>: query_cache_limit</li><li><code>query_cache_min_res_unit</code>: 缓存块的最小大小</li><li><code>query_cache_size</code>: 查询缓存大小</li><li><code>query_cache_type</code>: 缓存类型，决定缓存什么样的查询，示例中表示不缓存 select sql_no_cache 查询</li><li><code>query_cache_wlock_invalidate</code>: 当有其他客户端正在对myisam表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。</li></ul><h4 id="排序使用情况"><a href="#排序使用情况" class="headerlink" title="排序使用情况"></a>排序使用情况</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'sort%';</span><br><span class="line">+-------------------+----------+</span><br><span class="line">| Variable_name     | Value    |</span><br><span class="line">+-------------------+----------+</span><br><span class="line">| Sort<span class="emphasis">_merge_</span>passes | 3948     |</span><br><span class="line">| Sort_range        | 19442930 |</span><br><span class="line">| Sort_rows         | 87116099 |</span><br><span class="line">| Sort_scan         | 1748111  |</span><br><span class="line">+-------------------+----------+</span><br></pre></td></tr></table></figure><h4 id="文件打开数-open-files"><a href="#文件打开数-open-files" class="headerlink" title="文件打开数(open_files)"></a>文件打开数(open_files)</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'open_files';</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Open_files    | 10    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'open<span class="emphasis">_files_</span>limit';</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| open<span class="emphasis">_files_</span>limit | 65535 |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure><p>比较合适的设置：<code>open_files / open_files_limit * 100% &lt;= 75%</code></p><h4 id="表锁情况"><a href="#表锁情况" class="headerlink" title="表锁情况"></a>表锁情况</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'table_locks%';</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Variable_name         | Value    |</span><br><span class="line">+-----------------------+----------+</span><br><span class="line">| Table<span class="emphasis">_locks_</span>immediate | 61629615 |</span><br><span class="line">| Table<span class="emphasis">_locks_</span>waited    | 77       |</span><br><span class="line">+-----------------------+----------+</span><br></pre></td></tr></table></figure><ul><li><code>Table_locks_immediate</code>: 表示立即释放表锁数</li><li><code>Table_locks_waited</code>: 表示需要等待的表锁数</li></ul><p>如果 <code>table_locks_immediate / table_locks_waited &gt; 5000</code>，最好采用<code>innodb</code>引擎，因为<code>innodb</code>是行锁而<code>myisam</code>是表锁，对于高并发写入的应用<code>innodb</code>效果会好些</p><h4 id="表扫描情况"><a href="#表扫描情况" class="headerlink" title="表扫描情况"></a>表扫描情况</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'handler_read%';</span><br><span class="line">+-----------------------+--------------+</span><br><span class="line">| Variable_name         | Value        |</span><br><span class="line">+-----------------------+--------------+</span><br><span class="line">| Handler<span class="emphasis">_read_</span>first    | 177188783    |</span><br><span class="line">| Handler<span class="emphasis">_read_</span>key      | 3542386589   |</span><br><span class="line">| Handler<span class="emphasis">_read_</span>last     | 52930        |</span><br><span class="line">| Handler<span class="emphasis">_read_</span>next     | 445982431928 |</span><br><span class="line">| Handler<span class="emphasis">_read_</span>prev     | 89234087     |</span><br><span class="line">| Handler<span class="emphasis">_read_</span>rnd      | 2283006748   |</span><br><span class="line">| Handler<span class="emphasis">_read_</span>rnd_next | 175219902622 |</span><br><span class="line">+-----------------------+--------------+</span><br></pre></td></tr></table></figure><ul><li>服务器完成的查询请求次数: </li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'com_select';</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| Variable_name | Value     |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| Com_select    | 713039214 |</span><br><span class="line">+---------------+-----------+</span><br></pre></td></tr></table></figure><p>计算表扫描率: </p><blockquote><p>表扫描率 ＝ handler_read_rnd_next / com_select</p></blockquote><h2 id="MySQL-分库分表"><a href="#MySQL-分库分表" class="headerlink" title="MySQL 分库分表"></a>MySQL 分库分表</h2><h3 id="数据库主从"><a href="#数据库主从" class="headerlink" title="数据库主从"></a>数据库主从</h3><p>从数据库(Slave)是主数据库的备份，当主数据库(Master)变化时从数据库要更新，这些数据库软件可以设计更新周期。这是提高信息安全的手段。主从数据库服务器不在一个地理位置上，当发生意外时数据库可以保存。</p><ul><li>主从分工</li></ul><p>其中Master负责写操作的负载，也就是说一切写的操作都在Master上进行，而读的操作则分摊到Slave上进行。</p><ul><li>基本过程</li></ul><ol><li>Mysql的主从同步就是当master（主库）发生数据变化的时候，会实时同步到slave（从库）。</li><li>主从复制可以水平扩展数据库的负载能力，容错，高可用，数据备份。</li><li>不管是delete、update、insert，还是创建函数、存储过程，都是在master上，当master有操作的时候，slave会快速的接受到这些操作，从而做同步。</li></ol><ul><li>用途和条件</li></ul><ol><li>mysql主从复制用途<ul><li>实时灾备，用于故障切换</li><li>读写分离，提供查询服务</li><li>备份，避免影响业务</li></ul></li><li>主从部署必要条件：<ul><li>主库开启binlog日志（设置log-bin参数）</li><li>主从server-id不同</li><li>从库服务器能连通主库</li></ul></li></ol><h4 id="主从形式"><a href="#主从形式" class="headerlink" title="主从形式"></a>主从形式</h4><ul><li>一主一从</li><li>主主复制</li><li>一主多从—扩展系统读取的性能，因为读是在从库读取的;</li><li>多主一从—5.7开始支持</li><li>联级复制</li></ul><h4 id="主从同步的延迟等问题、原因及解决方案："><a href="#主从同步的延迟等问题、原因及解决方案：" class="headerlink" title="主从同步的延迟等问题、原因及解决方案："></a>主从同步的延迟等问题、原因及解决方案：</h4><ul><li>mysql数据库从库同步的延迟问题</li></ul><blockquote><p>MySQL数据库主从同步延迟原理mysql主从同步原理：主库针对写操作，顺序写binlog，从库单线程去主库顺序读”写操作的binlog”，从库取到binlog在本地原样执行（随机写），来保证主从数据逻辑上一致。mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率比较高，下一步，问题来了，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。DML和DDL的IO操作是随即的，不是顺序的，成本高很多，还可能可slave上的其他查询产生lock争用，由于Slave_SQL_Running也是单线程的，所以一个DDL卡主了，需要执行10分钟，那么所有之后的DDL会等待这个DDL执行完才会继续执行，这就导致了延时。有朋友会问：“主库上那个相同的DDL也需要执行10分，为什么slave会延时？”，答案是master可以并发，Slave_SQL_Running线程却不可以。</p></blockquote><ul><li>MySql数据库从库同步的延迟解决方案</li></ul><ol><li>架构方面</li></ol><ul><li>业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</li><li>单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。</li><li>服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</li><li>不同业务的mysql物理上放在不同机器，分散压力。</li><li>使用比主库更好的硬件设备作为slave总结，mysql压力小，延迟自然会变小。</li></ul><ol start="2"><li>硬件方面</li></ol><ul><li>提高服务器性能</li></ul><ol start="3"><li>mysql主从同步加速</li></ol><ul><li>sync_binlog在slave端设置为0</li><li>–logs-slave-updates 从服务器从主服务器接收到的更新不记入它的二进制日志。</li><li>直接禁用slave端的binlog</li><li>slave端，如果使用的存储引擎是innodb，innodb_flush_log_at_trx_commit =2</li></ul><h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>例：QQ的登录表。假设QQ的用户有100亿，如果只有一张表，每个用户登录的时候数据库都要从这100亿中查找，会很慢很慢。如果将这一张表分成100份，每张表有1亿条，就小了很多，比如qq0,qq1,qq1…qq99表。</p><p>用户登录的时候，可以将用户的id%100，那么会得到0-99的数，查询表的时候，将表名qq跟取模的数连接起来，就构建了表名。比如123456789用户，取模的89，那么就到qq89表查询，查询的时间将会大大缩短。</p><p>这就是水平分割。</p><h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。</p><h2 id="MySQL-如何做双机热备和负载均衡"><a href="#MySQL-如何做双机热备和负载均衡" class="headerlink" title="MySQL+如何做双机热备和负载均衡"></a>MySQL+如何做双机热备和负载均衡</h2><blockquote><p><a href="https://juejin.im/post/5ca2f93cf265da307261fae1" target="_blank" rel="noopener">MySQL 主从复制，双机热备</a></p></blockquote><h3 id="双机热备"><a href="#双机热备" class="headerlink" title="双机热备"></a>双机热备</h3><blockquote><p>所谓双机热备其实是一个复制的过程，复制过程中一个服务器充当主服务器，一个或多个服务器充当从服务。 这个复制的过程实质上是从服务器复制主服务器上MySQL的二进制日志（bin-log），并在从服务器上还原主服务器上的sql语句操作，这样只要两个数据库的初态是一样的，就能一直同步。</p></blockquote><p>实现双机热备，原理其实就是做两个机器的互相主从，我们把上述步骤主从对调，然后做一遍就能实现了双机热备了</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li>mysql读写分离</li></ul><p>mysql复制时，产生了多个数据副本（备库），为减少服务器压力，从库用于处理读操作，主库可同时处理读写是mysql集群实现读写分离的常用策略。</p><p>由于备库的复制是异步的，无法实时同步，读写分离的主要难点也在于从库上的脏数据。通常如果使用备库进行读，一般对数据的实时性要求不能太高。对此，mysql提供了几种常见的读写分离方式，例如基于查询的读写分离、基于脏数据、基于会话等，有兴趣可继续研究。</p><p>mysql设置的读写分离，减少了主库的请求量，将大量读的操作发送给从库，实现负载均衡。</p><ul><li>修改DNS</li></ul><p>通过n个服务器IP指定到一个域名，根据请求的不同标识特征，将请求发送给不同的IP服务器进行处理。</p><ul><li>引入中间件</li></ul><p>mysql官方提供了一个mysql负载的中间件，mysql_proxy，也需要在服务器上进行安装，修改配置文件（mysql的服务器IP）,实质与nginx类似，也是一个代理服务器。</p><h2 id="数据表类型有哪些"><a href="#数据表类型有哪些" class="headerlink" title="数据表类型有哪些"></a>数据表类型有哪些</h2><ul><li>MyISAM、InnoDB、HEAP、BOB,ARCHIVE,CSV等</li><li>MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。</li><li>InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。</li></ul><h2 id="MySQL-把一个大表拆分多个表后-如何解决跨表查询效率问题"><a href="#MySQL-把一个大表拆分多个表后-如何解决跨表查询效率问题" class="headerlink" title="MySQL 把一个大表拆分多个表后,如何解决跨表查询效率问题"></a>MySQL 把一个大表拆分多个表后,如何解决跨表查询效率问题</h2><h2 id="MySQL-对于大表-千万级-要怎么优化呢"><a href="#MySQL-对于大表-千万级-要怎么优化呢" class="headerlink" title="MySQL 对于大表(千万级),要怎么优化呢?"></a>MySQL 对于大表(千万级),要怎么优化呢?</h2><ol><li>优化SQL和索引</li><li>加缓存, Memcached, redis等</li><li>主从复制,读写分离</li><li>分库分表</li><li>分布式系统</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>规范设计<ul><li>配置规范</li><li>建表规范</li><li>命名规范</li><li>索引规范</li><li>应用规范</li></ul></li><li>业务层优化<ul><li>业务拆分</li><li>数据拆分</li><li>读多写少优化场景<ul><li>采用缓存</li></ul></li><li>读少写多优化场景<ul><li>采用异步提交模式</li><li>使用队列技术</li><li>降低写入频率</li></ul></li></ul></li><li>架构层优化</li><li>管理优化<ul><li>数据清理如何做</li><li>数据变更如何做</li><li>尽可能避免数据碎片</li></ul></li></ul><h2 id="MySQL-的慢查询问题"><a href="#MySQL-的慢查询问题" class="headerlink" title="MySQL 的慢查询问题"></a>MySQL 的慢查询问题</h2><blockquote><p>其实通过慢查询日志来分析是一种比较简单的方式，如果不想看日志，可以借助工具来完成，<br>  如<code>mysqldumpslow</code>, <code>mysqlsla</code>, <code>myprofi</code>, <code>mysql-explain-slow-log</code>, <code>mysqllogfilter</code>等，感觉自己来分析一个需要丰富的经验，一个浪费时间。</p></blockquote><h2 id="SQL语言分4大类请列举"><a href="#SQL语言分4大类请列举" class="headerlink" title="SQL语言分4大类请列举 ?"></a>SQL语言分4大类请列举 ?</h2><ul><li>DDL–CREATE,DROP,ALTER</li></ul><blockquote><p>DDL 数据库定义语言 (Data Definition Language)</p></blockquote><ul><li>DML–INSERT,UPDATE,DELETE</li></ul><blockquote><p>数据库操纵语言 (Data Manipulation Language)</p></blockquote><ul><li>DQL–SELECT</li></ul><blockquote><p>数据库查询语言 (Data Query Language)</p></blockquote><ul><li>DCL–GRANT,REVOKE,COMMIT,ROLLBACK</li></ul><blockquote><p>数据库控制语言 (Data Control Language)</p></blockquote><h2 id="mysql-请写出数据类型-int-char-varchar-datetime-text-的意思"><a href="#mysql-请写出数据类型-int-char-varchar-datetime-text-的意思" class="headerlink" title="(mysql)请写出数据类型(int char varchar datetime text)的意思;"></a>(mysql)请写出数据类型(int char varchar datetime text)的意思;</h2><ul><li>int : 数值类型</li><li>char : 固定长度字符串类型</li><li>varchar : 可变长度字符串类型</li><li>datetime : 时期时间类型</li><li>text : 文本类型</li></ul><h3 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别:"></a>varchar和char有什么区别:</h3><ul><li>char 长度是固定的，不管你存储的数据是多少他都会是固定的长度。而varchar则是可变长度但他要在总长度上加1字符，这个用来存储位置。</li><li>char 固定长度，所以在处理速度上要比varchar快速很多，但是浪费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;知识嘛就是常问常新.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试/笔试题" scheme="http://blog.caoxl.com/categories/%E9%9D%A2%E8%AF%95-%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://blog.caoxl.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="笔试题" scheme="http://blog.caoxl.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
