<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>php面试八股文 | Keep It Simple And Stupid</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="面试题笔试题">
  
  
  
  
  <meta name="description" content="面试造火箭 上班拧螺丝“茴香豆的『回』字有几种写法你知道么”">
<meta name="keywords" content="面试题,笔试题">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP面试八股文">
<meta property="og:url" content="http://blog.caoxl.com/2022/03/03/PHP-Eight-Legged-Essay/index.html">
<meta property="og:site_name" content="Keep It Simple And Stupid">
<meta property="og:description" content="面试造火箭 上班拧螺丝“茴香豆的『回』字有几种写法你知道么”">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-03-09T09:48:21.757Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHP面试八股文">
<meta name="twitter:description" content="面试造火箭 上班拧螺丝“茴香豆的『回』字有几种写法你知道么”">
  
    <link rel="alternate" href="/atom.xml" title="Keep It Simple And Stupid" type="application/atom+xml">
  

  

  <link rel="icon" href="https://images.unsplash.com/photo-1643801026603-63d4f50be313?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=767&q=80">
  <link rel="apple-touch-icon" href="/https://images.unsplash.com/photo-1643801026603-63d4f50be313?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=767&q=80">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>
  <script src="/js/bootstrap.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">

  
    <link rel="stylesheet" href="/css/dialog.css">
  

  

  
    <link rel="stylesheet" href="/css/header-post.css">
  

  
  
  

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  
  <div id="container">
    <div id="wrap">
      
        <header>

    <div id="allheader" class="navbar navbar-default navbar-static-top" role="navigation">
        <div class="navbar-inner">
          
          <div class="container"> 
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>

            
              <a class="brand" style="
                 margin-top: 0px;"  
                href="#" data-toggle="modal" data-target="#myModal" >
                  <img width="124px" height="124px" alt="Hike News" src="https://images.unsplash.com/photo-1643801026603-63d4f50be313?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=767&q=80">
              </a>
            
            
            <div class="navbar-collapse collapse">
              <ul class="hnav navbar-nav">
                
                  <li> <a class="main-nav-link" href="/">首页</a> </li>
                
                  <li> <a class="main-nav-link" href="/archives">归档</a> </li>
                
                  <li> <a class="main-nav-link" href="/categories">分类</a> </li>
                
                  <li> <a class="main-nav-link" href="/tags">标签</a> </li>
                
                  <li> <a class="main-nav-link" href="/about">关于</a> </li>
                
                  <li><div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div></li>
            </div>
          </div>
                
      </div>
    </div>

</header>



      
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-PHP-Eight-Legged-Essay" style="width: 75%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      PHP面试八股文
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2022/03/03/PHP-Eight-Legged-Essay/" class="article-date">
	  <time datetime="2022-03-03T06:34:35.000Z" itemprop="datePublished">2022-03-03</time>
	</a>

      
    <a class="article-category-link" href="/categories/面试-笔试题/">面试/笔试题</a>

      
	<a class="article-views">
	<span id="busuanzi_container_page_pv">
		阅读量<span id="busuanzi_value_page_pv"></span>
	</span>
	</a>

    </div>

    <div class="article-entry" itemprop="articleBody">
      
        
        
          <blockquote>
<p>面试造火箭 上班拧螺丝<br>“茴香豆的『回』字有几种写法你知道么”</p>
</blockquote>
<a id="more"></a>
<h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><h3 id="php-fpm-的生命周期，创建进程方式，各自的优缺点（腾讯-百度-滴滴-陌陌）"><a href="#php-fpm-的生命周期，创建进程方式，各自的优缺点（腾讯-百度-滴滴-陌陌）" class="headerlink" title="php-fpm 的生命周期，创建进程方式，各自的优缺点（腾讯 百度 滴滴 陌陌）"></a>php-fpm 的生命周期，创建进程方式，各自的优缺点（腾讯 百度 滴滴 陌陌）</h3><blockquote>
<p>PHP-FPM是一种多进程模型，主要由Master进程以及Worker进程组成，所有的cgi请求都会交由Worker进程处理。Master进程主要维护worker进程。<br>而worker进程的工作方式是抢占/竞争的方式，当一个accept请求过来的时候，谁先拿到算谁的，拿到后转化为FastCGIRequest，交由脚本处理。</p>
</blockquote>
<h4 id="php生命周期"><a href="#php生命周期" class="headerlink" title="php生命周期"></a>php生命周期</h4><p>数据初始化(MINT) =&gt; 请求初始化(RINT) =&gt; 编译脚本 (RSHUTDOWN) =&gt; 执行代码(MSHUTDOWN)</p>
<ul>
<li><a href="https://www.abelzhou.com/php/php-fpm-lifespan/#" target="_blank" rel="noopener">PHP-FPM 生命周期</a></li>
</ul>
<h4 id="static-静态模式"><a href="#static-静态模式" class="headerlink" title="static 静态模式"></a>static 静态模式</h4><p>启动的时候创建固定数量的worker进程,实际请求大于worker进程的时候 <strong>包warning</strong></p>
<h4 id="ondemand-按需分配模式"><a href="#ondemand-按需分配模式" class="headerlink" title="ondemand 按需分配模式"></a>ondemand 按需分配模式</h4><p>启动的时候不会创建worker进程, 根据需要创建,释放在idle_timeout之后</p>
<p>这样不能及时的释放连接和建立连接需要消耗资源</p>
<h4 id="dynamic-动态模式-默认"><a href="#dynamic-动态模式-默认" class="headerlink" title="dynamic 动态模式(默认)"></a>dynamic 动态模式(默认)</h4><p>启动的是创建指定数量的worker进程, 根据情况合理的worker,定期检测worker,关闭闲置连接</p>
<ul>
<li><a href="https://www.its404.com/article/qq_39787367/104009809" target="_blank" rel="noopener">PHP-FPM三种运行模式</a></li>
</ul>
<h3 id="php-数组遍历为什么能保证有序（滴滴）"><a href="#php-数组遍历为什么能保证有序（滴滴）" class="headerlink" title="php 数组遍历为什么能保证有序（滴滴）"></a>php 数组遍历为什么能保证有序（滴滴）</h3><p>为了实现插入与遍历的顺序一致性，在PHP7中，增加了一个中间映射层，它的大小与哈希表相同，存储了元素在bucket中最终存储的位置，我们把它叫做<strong>映射表</strong>。</p>
<ul>
<li><a href="https://www.laruence.com/2009/08/23/1065.html" target="_blank" rel="noopener">深入理解PHP之数组(遍历顺序)</a></li>
</ul>
<h3 id="php-怎么实现的弱类型，怎么实现一个扩展（腾讯）"><a href="#php-怎么实现的弱类型，怎么实现一个扩展（腾讯）" class="headerlink" title="php 怎么实现的弱类型，怎么实现一个扩展（腾讯）"></a>php 怎么实现的弱类型，怎么实现一个扩展（腾讯）</h3><h4 id="实现php弱类型变量"><a href="#实现php弱类型变量" class="headerlink" title="实现php弱类型变量"></a>实现php弱类型变量</h4><ol>
<li>通过Zend引擎用C实现弱类型，在ZE中用结构体zval来保存</li>
<li>通过Zend引擎是判别、存储PHP中的多种数据类型，根据type来选择获取【zvalue_value】的值</li>
</ol>
<h4 id="实现一个扩展"><a href="#实现一个扩展" class="headerlink" title="实现一个扩展"></a>实现一个扩展</h4><ul>
<li><a href="https://juejin.cn/post/7036991318991749128#heading-5" target="_blank" rel="noopener">解析PHP原生扩展开发</a></li>
</ul>
<h3 id="常见魔术方法和函数（腾讯-滴滴）"><a href="#常见魔术方法和函数（腾讯-滴滴）" class="headerlink" title="常见魔术方法和函数（腾讯 滴滴）"></a>常见魔术方法和函数（腾讯 滴滴）</h3><ul>
<li><code>__construct()</code>: 类的构造函数</li>
<li><code>__destruct()</code>: 类的析构函数</li>
<li><code>__call()</code>: 当调用一个未定义或不可达方法时， __call () 方法将被调用。</li>
<li><code>__callStatic()</code>: 当调用一个未定义或不可达的静态方法时， __callStatic () 方法将被调用。</li>
<li><code>__get()</code>: 当获取一个类的成员变量时， __get () 方法将被调用。</li>
<li><code>__set()</code>: 当赋值一个类的成员变量时， __set () 方法将被调用。</li>
<li><code>__isset()</code>: 当调用 isset () 或 empty () 对一个未定义或不可达的成员赋值时， __isset () 方法将被调用。</li>
<li><code>__unset()</code>: 当调用 reset () 对一个未定义或不可达的成员更新时， __unset () 方法将被调用。</li>
<li><code>__sleep()</code>: 当执行序列化 serialize () 时，__sleep () 方法将首先被调用。</li>
<li><code>__wakeup()</code>: 当执行反序列化 deserialization () 时， __wakeup () 方法将首先被调用。</li>
<li><code>__toString()</code>: 当使用 echo 方法直接输出显示对象时，__toString () 方法首先被调用。</li>
<li><code>__invoke()</code>: 使用调用函数（function）访问一个对象时， __invoke () 方法将首先被调用。</li>
<li><code>__set_state()</code>: 当调用 var_export () 方法时，__set_state () 方法将被调用。</li>
<li><code>__clone()</code>: 当对象被复制赋值时，__clone () 方法将被调用。</li>
<li><code>__autoload()</code>: 试图载入一个未定义的类时调用。</li>
<li><code>__debugInfo()</code>: 输出 debug 信息。</li>
</ul>
<ul>
<li><a href="https://learnku.com/php/t/40919" target="_blank" rel="noopener">16 个 PHP 开发者必知必会的魔术方法</a></li>
</ul>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="有哪些事务隔离级别，Mysql-的事务隔离级别是怎么实现的？（每家都问）"><a href="#有哪些事务隔离级别，Mysql-的事务隔离级别是怎么实现的？（每家都问）" class="headerlink" title="有哪些事务隔离级别，Mysql 的事务隔离级别是怎么实现的？（每家都问）"></a>有哪些事务隔离级别，Mysql 的事务隔离级别是怎么实现的？（每家都问）</h3><blockquote>
<p>事务的隔离性由锁来实现。 原子性、一致性、持久性通过数据库的redo log和undo log来实现。 redo log称为重做日志，用来保证事务的原子性和持久性，undo log用来保证事务的一致性。 MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化</p>
</blockquote>
<ul>
<li>未提交读(RU)</li>
<li>提交读(RC)</li>
<li>可重复读(RR)</li>
<li>序列化读(S)</li>
</ul>
<ul>
<li><a href="https://segmentfault.com/a/1190000025156465" target="_blank" rel="noopener">深入理解MySQL中事务隔离级别的实现原理</a></li>
</ul>
<h3 id="索引原理（每家都问）"><a href="#索引原理（每家都问）" class="headerlink" title="索引原理（每家都问）"></a>索引原理（每家都问）</h3><blockquote>
<p>索引的本质是一种排好序的数据结构</p>
</blockquote>
<h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><ul>
<li>Hash索引</li>
<li>二叉树</li>
<li>B树</li>
<li>B+树 (MySQL 中最常用的索引的数据结构是 B+ 树)</li>
</ul>
<ul>
<li><a href="https://juejin.cn/post/6931901822231642125" target="_blank" rel="noopener">MySQL索引原理，一篇从头到尾讲清楚</a></li>
</ul>
<h3 id="分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）"><a href="#分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）" class="headerlink" title="分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）"></a>分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）</h3><h4 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h4><blockquote>
<p>常见的分布式生成唯一ID的方式很多，最常见的雪花算法Snowflake、滴滴Tinyid、美团Leaf。以雪花算法举例来说，一毫秒可以生成4194304多个ID。</p>
</blockquote>
<h3 id="MVCC-和间隙锁原理（滴滴-字节-百度）"><a href="#MVCC-和间隙锁原理（滴滴-字节-百度）" class="headerlink" title="MVCC 和间隙锁原理（滴滴 字节 百度）"></a>MVCC 和间隙锁原理（滴滴 字节 百度）</h3><blockquote>
<p>多版本并发控制（MVCC）是一种解决读-写冲突的无锁并发控制<br>每一行记录都有两个隐藏列：创建版本号和回滚指针。事务开启后存在一个事务id。多个并发事务同时操作某行，不同的事务对该行update操作会产生多个版本，然后通过回滚指针组成undo log链。而MVCC的快照读正是通过事务id和创建版本号从而实现的快照读。</p>
</blockquote>
<p><strong>注意：只有RR隔离级别才存在间隙锁。</strong></p>
<h3 id="explain-的-type-字段有哪些（知乎）"><a href="#explain-的-type-字段有哪些（知乎）" class="headerlink" title="explain 的 type 字段有哪些（知乎）"></a>explain 的 type 字段有哪些（知乎）</h3><ul>
<li><code>system</code>: 系统表,少量数据,往往不需要进行磁盘IO</li>
<li><code>const</code>: 常量连接</li>
<li><code>eq_ref</code>: 主键索引(primary key)或者非空唯一索引(unique not null)等值扫描</li>
<li><code>ref</code>: 非主键非唯一索引等值扫描</li>
<li><code>range</code>: 范围扫描</li>
<li><code>index</code>: 索引树扫描</li>
<li><code>ALL</code>: 全表扫描(full table scan)</li>
</ul>
<h4 id="type扫描方式由快到慢"><a href="#type扫描方式由快到慢" class="headerlink" title="type扫描方式由快到慢"></a><code>type</code>扫描方式由快到慢</h4><blockquote>
<p><code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code></p>
</blockquote>
<ul>
<li><a href="https://juejin.cn/post/6844904149864169486" target="_blank" rel="noopener">Mysql Explain之type详解</a></li>
</ul>
<h3 id="update-语句的执行流程，binlog-的作用和几种格式（滴滴）"><a href="#update-语句的执行流程，binlog-的作用和几种格式（滴滴）" class="headerlink" title="update 语句的执行流程，binlog 的作用和几种格式（滴滴）"></a>update 语句的执行流程，binlog 的作用和几种格式（滴滴）</h3><ul>
<li><a href="https://cdn.learnku.com/uploads/images/202007/16/66421/IA2zMmze89.png!large" target="_blank" rel="noopener">update 语句的执行流程</a></li>
</ul>
<h4 id="binlog-的作用和几种格式"><a href="#binlog-的作用和几种格式" class="headerlink" title="binlog 的作用和几种格式"></a>binlog 的作用和几种格式</h4><p>binlog一般情况下分为三种格式，分别是<code>row</code>格式、<code>statement</code>格式、<code>mixed</code>格式</p>
<ul>
<li><code>row格式</code>: 此格式不记录sql语句上下文相关信息，仅保存哪条记录被修改。</li>
<li><code>statement</code>: 该格式下每一条会修改数据的sql都会记录在binlog中。</li>
<li><code>mixed</code>: 该格式是以上两种level的混合使用，一般的语句修改使用statement格式保存binlog，当statement无法完成主从复制的操作时(设计一些函数时)，则采用Row格式保存binlog</li>
</ul>
<h3 id="主从同步的原理和问题（字节-滴滴-陌陌）"><a href="#主从同步的原理和问题（字节-滴滴-陌陌）" class="headerlink" title="主从同步的原理和问题（字节 滴滴 陌陌）"></a>主从同步的原理和问题（字节 滴滴 陌陌）</h3><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><ol>
<li>在主库上把数据更改记录到二进制日志binary log中，具体是在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中去，Mysql会按照事务提交的顺序来记录二进制日志的。日志记录好之后，主库通知存储引擎提交事务。</li>
<li>从库会启动一个IO线程，该线程会连接到主库。而主库上的binlog dump线程会去读取主库本地的binlog日志文件中的更新事件。发往从库，从库接收到日志之后会将其记录到本地的中继日志relay-log当中。</li>
<li>从库中的SQL线程读取中继日志relay-log中的事件，将其重放到从库中。（在5.6版本之前SQL线程是单线程的，使得主从之间延迟更大）</li>
</ol>
<ul>
<li><a href="https://www.cnblogs.com/idoljames/p/11694039.html" target="_blank" rel="noopener">Mysql主从复制原理及同步延迟问题</a></li>
</ul>
<h4 id="延迟问题"><a href="#延迟问题" class="headerlink" title="延迟问题"></a>延迟问题</h4><ul>
<li><p>延迟的产生:</p>
<ul>
<li>当主库的TPS并发较高时，由于主库上面是多线程写入的，而从库的SQL线程是单线程的，导致从库SQL可能会跟不上主库的处理速度（生产者比消费者快，导致商品堆积）。</li>
</ul>
</li>
<li><p>延迟的解决:</p>
<ul>
<li>网络方面：将从库分布在相同局域网内或网络延迟较小的环境中。</li>
<li>硬件方面：从库配置更好的硬件，提升随机写的性能</li>
<li>配置方面：从库配置sync_binlog=0，innodb_flush_log_at_trx_commit=2，logs-slave-updates=0，增大innodb_buffer_pool_size，让更多操作在Mysql内存中完成，减少磁盘操作。或者升级Mysql5.7版本使用并行复制</li>
<li>架构方面：比如在事务当中尽量对主库读写，其他非事务中的读在从库。消除一部分延迟带来的数据库不一致。增加缓存降低一些从库的负载。</li>
</ul>
</li>
</ul>
<h3 id="发生死锁的原因以及如何解决（滴滴-顺丰）"><a href="#发生死锁的原因以及如何解决（滴滴-顺丰）" class="headerlink" title="发生死锁的原因以及如何解决（滴滴 顺丰）"></a>发生死锁的原因以及如何解决（滴滴 顺丰）</h3><h4 id="发生死锁的原因"><a href="#发生死锁的原因" class="headerlink" title="发生死锁的原因"></a>发生死锁的原因</h4><ol>
<li>互斥条件</li>
<li>不可剥夺条件(不可抢占)</li>
<li>部分分配</li>
<li>循环等待</li>
</ol>
<h4 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h4><ol>
<li>通过协议来预防或避免死锁，确保系统不会进入死锁状态。</li>
<li>可以允许系统进入死锁状态，然后检测它，并加以恢复。</li>
<li>可以忽视这个问题，认为死锁不可能在系统内发生</li>
</ol>
<ul>
<li><a href="http://c.biancheng.net/view/1236.html" target="_blank" rel="noopener">什么是死锁，死锁的原因及解决办法（含四个必要条件）</a></li>
</ul>
<h3 id="如何优化大-offset（陌陌）"><a href="#如何优化大-offset（陌陌）" class="headerlink" title="如何优化大 offset（陌陌）"></a>如何优化大 offset（陌陌）</h3><p>当offset特别大时，这条语句的执行效率会明显减低，而且效率是随着offset的增大而降低的。</p>
<p>MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，当offset特别大，然后单条数据也很大的时候，每次查询需要获取的数据就越多，自然就会很慢。</p>
<ul>
<li>解决方法<br>先获取主键列表，再通过主键查询目标数据，即使offset很大，也是获取了很多的主键，而不是所有的字段数据，相对而言效率会提升很多。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select 需要的字段 </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    select &lt;a.<span class="built_in">id</span> 或 b.<span class="built_in">id</span>&gt; <span class="keyword">as</span> <span class="built_in">id</span></span><br><span class="line">    <span class="keyword">from</span> a join b <span class="keyword">on</span> a.<span class="built_in">id</span>=b.<span class="built_in">id</span></span><br><span class="line">    <span class="keyword">where</span> &lt;筛选条件&gt;</span><br><span class="line">    order <span class="keyword">by</span> &lt;一些字段&gt;</span><br><span class="line">    limit &lt;limit_param&gt; <span class="built_in">offset</span> &lt;offset_param&gt;</span><br><span class="line">) c join a <span class="keyword">on</span>  c.<span class="built_in">id</span>=a.<span class="built_in">id</span></span><br><span class="line">    join b <span class="keyword">on</span> c.<span class="built_in">id</span>=b.<span class="built_in">id</span></span><br><span class="line">    order <span class="keyword">by</span> &lt;一些字段&gt;</span><br></pre></td></tr></table></figure>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="缓存如何保证一致性（每家都问）"><a href="#缓存如何保证一致性（每家都问）" class="headerlink" title="缓存如何保证一致性（每家都问）"></a>缓存如何保证一致性（每家都问）</h3><ol>
<li>执行顺序的问题：先更新缓存还是先更新数据库？</li>
<li>更新缓存的策略问题：当缓存中的内容变化时，是选择修改缓存(update)，还是直接淘汰缓存(delete)？</li>
</ol>
<p><strong>针对这两点问题，一共可以分为四种方案：</strong></p>
<ol>
<li>先更新缓存，再更新数据库</li>
<li>先更新数据库，再更新缓存</li>
<li>先淘汰缓存，再更新数据库 (适用于对一致性要求高的业务)</li>
<li>先更新数据库，再淘汰缓存</li>
</ol>
<ul>
<li><a href="https://developer.aliyun.com/article/712285" target="_blank" rel="noopener">如何保证缓存(redis)与数据库(MySQL)的一致性</a></li>
</ul>
<h3 id="用过-redis-哪些数据结构，使用场景是什么（每家都问）"><a href="#用过-redis-哪些数据结构，使用场景是什么（每家都问）" class="headerlink" title="用过 redis 哪些数据结构，使用场景是什么（每家都问）"></a>用过 redis 哪些数据结构，使用场景是什么（每家都问）</h3><ul>
<li><code>string</code>(字符串): 常见的key-value存储</li>
<li><code>list</code>(列表): <ul>
<li>消息队列: <code>lpop</code>和<code>rpush</code>或者反过来，<code>lpush</code>和<code>rpop</code>）能实现队列的功能</li>
<li>朋友圈点赞列表, 评论列表, 排行榜</li>
</ul>
</li>
<li><code>hash</code>(字典): <ul>
<li>购物车: <code>hset [key] [field] [value]</code> 命令， 可以实现以用户Id，商品Id为field，商品数量为value，恰好构成了购物车的3个要素。</li>
<li>存储对象：hash类型的(key, field, value)的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。</li>
</ul>
</li>
<li><code>set</code>(集合): <ul>
<li>好友、关注、粉丝、感兴趣的人集合<br>1) <code>sinter</code>命令可以获得A和B两个用户的共同好友；<br>2) <code>sismember</code>命令可以判断A是否是B的好友；<br>3) <code>scard</code>命令可以获取好友数量；<br>4) 关注时，<code>smove</code>命令可以将B从A的粉丝集合转移到A的好友集合</li>
<li>首页展示随机：美团首页有很多推荐商家，但是并不能全部展示，set类型适合存放所有需要展示的内容，而<code>srandmember</code>命令则可以从中随机获取几个</li>
<li>存储某活动中中奖的用户ID ，因为有去重功能，可以保证同一个用户不会中奖两次。</li>
</ul>
</li>
<li><code>zset</code>(有序集合):<ul>
<li><code>zset</code> 可以用做排行榜，但是和list不同的是zset它能够实现动态的排序，例如： 可以用来存储粉丝列表，value 值是粉丝的用户 ID，score 是关注时间，我们可以对粉丝列表按关注时间进行排序。</li>
</ul>
</li>
</ul>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/145384563" target="_blank" rel="noopener">Redis 5种数据结构 及使用场景分析</a></li>
</ul>
<h3 id="redis-的-connect-和-pconnect-的区别，pconnect-有什么问题（滴滴-陌陌）"><a href="#redis-的-connect-和-pconnect-的区别，pconnect-有什么问题（滴滴-陌陌）" class="headerlink" title="redis 的 connect 和 pconnect 的区别，pconnect 有什么问题（滴滴 陌陌）"></a>redis 的 connect 和 pconnect 的区别，pconnect 有什么问题（滴滴 陌陌）</h3><ul>
<li><code>connect</code>: 脚本结束之后连接就释放了</li>
<li><code>pconnect</code>: 脚本结束之后连接不释放，连接保持在php-fpm进程中</li>
</ul>
<p><strong>pconnect 有什么问题</strong></p>
<ol>
<li>当使用pconnect时，连接会被重用，连接的生命周期是fpm进程的生命周期，而非一次php的执行</li>
<li>如果代码中使用pconnect， close的作用仅是使当前php不能再进行redis请求，但无法真正关闭redis长连接，连接在后续请求中仍然会被重用，直至fpm进程生命周期结束。</li>
</ol>
<h3 id="redis-如何实现分布式锁，有什么问题（陌陌）"><a href="#redis-如何实现分布式锁，有什么问题（陌陌）" class="headerlink" title="redis 如何实现分布式锁，有什么问题（陌陌）"></a>redis 如何实现分布式锁，有什么问题（陌陌）</h3><p>利用 Redis 的 <code>SETNX</code> 命令，此命令同样是原子性操作，只有在 key 不存在的情况下，才能 set 成功。而基于 Redis 多机实现的分布式锁 <code>Redlock</code>，是 Redis 的作者 antirez 为了规范 Redis 分布式锁的实现，提出的一个更安全有效的实现机制</p>
<blockquote>
<p>不管是哪种实现方式，均需要实现加锁、解锁、锁超时这三个分布式锁的核心要素</p>
</blockquote>
<ul>
<li><a href="http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/" target="_blank" rel="noopener">深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了</a></li>
</ul>
<h3 id="redis-为什么用跳表实现有序集合？原理，用有序集合的场景（字节-滴滴）"><a href="#redis-为什么用跳表实现有序集合？原理，用有序集合的场景（字节-滴滴）" class="headerlink" title="redis 为什么用跳表实现有序集合？原理，用有序集合的场景（字节 滴滴）"></a>redis 为什么用跳表实现有序集合？原理，用有序集合的场景（字节 滴滴）</h3><ul>
<li><ol>
<li>按照区间来查找数据这个操作，红黑树的效率没有跳表高</li>
</ol>
</li>
<li><ol start="2">
<li>跳表更容易代码实现</li>
</ol>
</li>
<li><ol start="3">
<li>跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗</li>
</ol>
</li>
<li><p><a href="https://juejin.cn/post/6962735884844138533#heading-8" target="_blank" rel="noopener">Redis 选择用跳表来实现有序集合的原因</a></p>
</li>
</ul>
<h4 id="跳表数据结构"><a href="#跳表数据结构" class="headerlink" title="跳表数据结构"></a>跳表数据结构</h4><ul>
<li>跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现是基于“二分查找”的链表操作</li>
<li>跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)</li>
<li>跳表的空间复杂度是 O(n)，不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</li>
<li>虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</li>
</ul>
<h3 id="主从同步的原理，哨兵和集群的区别（滴滴）"><a href="#主从同步的原理，哨兵和集群的区别（滴滴）" class="headerlink" title="主从同步的原理，哨兵和集群的区别（滴滴）"></a>主从同步的原理，哨兵和集群的区别（滴滴）</h3><ul>
<li>主从复制: 读写分离，备份，一个Master可以有多个Slaves。</li>
<li>哨兵: 监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li>
<li>集群: 为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</li>
</ul>
<blockquote>
<p>哨兵(sentinel)着眼于高可用; 集群(cluster)提高并发量</p>
</blockquote>
<ul>
<li><a href="https://juejin.cn/post/6844904097116585991" target="_blank" rel="noopener">一文掌握Redis主从复制、哨兵、Cluster三种集群模式</a></li>
</ul>
<h3 id="redis-cluster-用的什么协议同步数据，哨兵的选举呢（陌陌）"><a href="#redis-cluster-用的什么协议同步数据，哨兵的选举呢（陌陌）" class="headerlink" title="redis cluster 用的什么协议同步数据，哨兵的选举呢（陌陌）"></a>redis cluster 用的什么协议同步数据，哨兵的选举呢（陌陌）</h3><blockquote>
<p>Gossip协议 又称 epidemic 协议（epidemic protocol）</p>
</blockquote>
<h4 id="哨兵选举"><a href="#哨兵选举" class="headerlink" title="哨兵选举"></a>哨兵选举</h4><p>主节点被标记为 Fail 后，对应的从节点会发起投票，竞争升主。历经从节点拉票、主节点投票、投票裁决等环节，最终完成选举。</p>
<ol>
<li>从节点拉票</li>
<li>拉票优先级</li>
<li>主节点投票</li>
<li>根据投票结果决策</li>
<li>选举失败</li>
<li>选举算法 (选举新主节点的算法是基于 Raft 算法的 Leader Election 方法来实现的)</li>
</ol>
<ul>
<li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%AE%8C%EF%BC%89/04%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20Gossip%20%E5%92%8C%20Redis%20%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">分布式一致性协议 Gossip 和 Redis 集群原理解析</a></li>
</ul>
<h3 id="rdb-和-aof-的原理（滴滴-高德）"><a href="#rdb-和-aof-的原理（滴滴-高德）" class="headerlink" title="rdb 和 aof 的原理（滴滴 高德）"></a>rdb 和 aof 的原理（滴滴 高德）</h3><ul>
<li><code>RDB</code>: 生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dump.rdb</li>
<li><code>AOF</code>: 记录 Redis 除了查询以外的所有写命令，并在Redis 服务启动时，通过重新执行这些命令来还原数据。</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>
<li>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式追加记录，可以打开文件看到详细的操作记录。</li>
</ul>
<ul>
<li><a href="https://segmentfault.com/a/1190000018388385" target="_blank" rel="noopener">RDB 和 AOF 持久化的原理是什么？我应该用哪一个？它们的优缺点？</a></li>
</ul>
<h3 id="数据过期和淘汰策略（滴滴-高德-字节）"><a href="#数据过期和淘汰策略（滴滴-高德-字节）" class="headerlink" title="数据过期和淘汰策略（滴滴 高德 字节）"></a>数据过期和淘汰策略（滴滴 高德 字节）</h3><h4 id="数据过期"><a href="#数据过期" class="headerlink" title="数据过期"></a>数据过期</h4><blockquote>
<p>Redis中主要使用 <strong>定期删除</strong> + <strong>惰性删除</strong> 两种数据过期清除策略</p>
</blockquote>
<ul>
<li>定期删除：redis默认每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果有过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载。</li>
<li>惰性删除：定期删除可能导致很多过期的key 到了时间并没有被删除掉。这时就要使用到惰性删除。在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间并且过期了，是的话就删除。</li>
</ul>
<h4 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h4><blockquote>
<p>Redis共提供了8中缓存淘汰策略，其中 volatile-lfu 和 allkeys-lfu 是Redis 4.0版本新增的<br>通常情况下推荐优先使用 allkeys-lru 策略。</p>
</blockquote>
<ul>
<li><code>noeviction</code>: 不进行淘汰数据</li>
<li><code>volatile-ttl</code>: 在设置了过期时间的键值对中，移除即将过期的键值对</li>
<li><code>volatile-random</code>: 在设置了过期时间的键值对中，随机移除某个键值对</li>
<li><code>volatile-lru</code>: 在设置了过期时间的键值对中，移除最近最少使用的键值对</li>
<li><code>volatile-lfu</code>: 在设置了过期时间的键值对中，移除最近最不频繁使用的键值对</li>
<li><code>allkeys-random</code>: 在所有键值对中，随机移除某个key</li>
<li><code>allkeys-lru</code>: 在所有的键值对中，移除最近最少使用的键值对。</li>
<li><code>allkeys-lfu</code>: 在所有的键值对中，移除最近最不频繁使用的键值对</li>
</ul>
<ul>
<li><a href="https://blog.csdn.net/a745233700/article/details/85413179" target="_blank" rel="noopener">Redis的数据过期清除策略 与 内存淘汰策略</a></li>
</ul>
<h3 id="缓存雪崩-击穿-穿透（滴滴-陌陌）"><a href="#缓存雪崩-击穿-穿透（滴滴-陌陌）" class="headerlink" title="缓存雪崩 击穿 穿透（滴滴 陌陌）"></a>缓存雪崩 击穿 穿透（滴滴 陌陌）</h3><ul>
<li><a href="https://blog.caoxl.com/2019/08/29/Caching-Related-Issues-And-Solutions/">缓存 相关问题/解决方案</a></li>
</ul>
<h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><h3 id="深度分页会有什么问题（滴滴-百度-陌陌）"><a href="#深度分页会有什么问题（滴滴-百度-陌陌）" class="headerlink" title="深度分页会有什么问题（滴滴 百度 陌陌）"></a>深度分页会有什么问题（滴滴 百度 陌陌）</h3><p>深度分页问题大致可以分为两类</p>
<ul>
<li>随机深度分页: 随机跳转页面</li>
<li>滚动深度分页: 只能一页一页往下查询</li>
</ul>
<h4 id="from-size"><a href="#from-size" class="headerlink" title="from/size"></a>from/size</h4><p>es 目前支持最大的 skip 值是 max_result_window ，默认 为 10000 。也就是当 from + size &gt; max_result_window 时，es 将返回错误</p>
<h4 id="scroll"><a href="#scroll" class="headerlink" title="scroll"></a>scroll</h4><p>使用scroll，每次只能获取一页的内容，然后会返回一个scrollid，根据scrollid可以不断地获取下一页的内容，所以scroll并不适用于有跳页的情景。但是在真正的使用场景中，第10000条数据已经是很后面的数据了，可以“折衷”一下，不提供跳转页面功能，只能下一页的翻页。</p>
<blockquote>
<p>Scroll方式通过一次查询请求后维护一个临时的索引快照的search context<br>此后的增删查改操作并不会影响这个快照数据信息，后续的查询只需要根据游标去取数据，直到结果集中返回的 hits 字段为空，就表示遍历结束。效率比较高。在5.x之后，还可以通过slice分片来实现并行导出。</p>
</blockquote>
<h4 id="search-after"><a href="#search-after" class="headerlink" title="search_after"></a>search_after</h4><p>searchAfter的方式通过维护一个实时游标来避免scroll的缺点，它可以用于实时请求和高并发场景。</p>
<p>它的缺点是不能够随机跳转分页，只能是一页一页的向后翻，并且需要至少指定一个唯一不重复字段来排序(注:每个文档具有一个唯一值的字段应该用作排序规范的仲裁器。否则，具有相同排序值的文档的排序顺序将是未定义的。建议的方法是使用字段_id，它肯定包含每个文档的一个唯一值)。</p>
<h3 id="倒排索引的原理（字节-高德）"><a href="#倒排索引的原理（字节-高德）" class="headerlink" title="倒排索引的原理（字节 高德）"></a>倒排索引的原理（字节 高德）</h3><ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/inverted-index.html#inverted-index" target="_blank" rel="noopener">倒排索引</a></li>
</ul>
<p>倒排索引由两个部分组成：单词词典和倒排文件。</p>
<ul>
<li>单词词典: 单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</li>
<li>倒排文件: 所有单词的倒排列表顺序的存储在磁盘的某个文件里，这个文件即被称为倒排文件，倒排文件是存储倒排索引的物理文件。</li>
</ul>
<h3 id="lsm-树原理（字节）"><a href="#lsm-树原理（字节）" class="headerlink" title="lsm 树原理（字节）"></a>lsm 树原理（字节）</h3><blockquote>
<p>LSM树（Log Structured Merge Tree，结构化合并树）的思想非常朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘（由此提升了写性能），是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销。</p>
</blockquote>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><h3 id="kafka-的架构，大致储存结构（高德-字节-滴滴）"><a href="#kafka-的架构，大致储存结构（高德-字节-滴滴）" class="headerlink" title="kafka 的架构，大致储存结构（高德 字节 滴滴）"></a>kafka 的架构，大致储存结构（高德 字节 滴滴）</h3><h3 id="如果消费者数超过分区数会怎么样？（顺丰-滴滴）"><a href="#如果消费者数超过分区数会怎么样？（顺丰-滴滴）" class="headerlink" title="如果消费者数超过分区数会怎么样？（顺丰 滴滴）"></a>如果消费者数超过分区数会怎么样？（顺丰 滴滴）</h3><h3 id="怎么保证数据的可靠投递？（陌陌-字节）"><a href="#怎么保证数据的可靠投递？（陌陌-字节）" class="headerlink" title="怎么保证数据的可靠投递？（陌陌 字节）"></a>怎么保证数据的可靠投递？（陌陌 字节）</h3><h3 id="消费者的-offset-存在哪里？（字节-腾讯-陌陌）"><a href="#消费者的-offset-存在哪里？（字节-腾讯-陌陌）" class="headerlink" title="消费者的 offset 存在哪里？（字节 腾讯 陌陌）"></a>消费者的 offset 存在哪里？（字节 腾讯 陌陌）</h3><h3 id="如何通过-offset-定位消息？（字节）"><a href="#如何通过-offset-定位消息？（字节）" class="headerlink" title="如何通过 offset 定位消息？（字节）"></a>如何通过 offset 定位消息？（字节）</h3><h3 id="时间轮的原理（陌陌-顺丰）"><a href="#时间轮的原理（陌陌-顺丰）" class="headerlink" title="时间轮的原理（陌陌 顺丰）"></a>时间轮的原理（陌陌 顺丰）</h3><h3 id="kafka-写入高性能的原因，sendfile-和-mmap-原理，为什么不用-splice（滴滴）"><a href="#kafka-写入高性能的原因，sendfile-和-mmap-原理，为什么不用-splice（滴滴）" class="headerlink" title="kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice（滴滴）"></a>kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice（滴滴）</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="https-原理，tls-握手需要几个-rtt？（滴滴-百度）"><a href="#https-原理，tls-握手需要几个-rtt？（滴滴-百度）" class="headerlink" title="https 原理，tls 握手需要几个 rtt？（滴滴 百度）"></a>https 原理，tls 握手需要几个 rtt？（滴滴 百度）</h3><blockquote>
<p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。</p>
<ul>
<li><a href="https://juejin.cn/post/6844903830916694030" target="_blank" rel="noopener">深入理解HTTPS工作原理</a> </li>
</ul>
</blockquote>
<blockquote>
<p>SSL(Secure Socket Layer 安全套接字层) / TLS(Transport Layer Security 传输层安全协议)<br>RTT(Round Trip Time 往返时间)</p>
</blockquote>
<p>TLS 握手就需要消耗两个 RTT<br>在 TLS 1.2 中，我们需要 2-RTT 才能建立 TLS 连接10，但是 TLS 1.3 通过优化协议，将两次往返延迟降低至一次</p>
<ul>
<li><a href="https://draveness.me/whys-the-design-https-latency/" target="_blank" rel="noopener">为什么 HTTPS 需要 7 次握手以及 9 倍时延</a></li>
</ul>
<p>总结一下 HTTPS 协议需要 9 倍时延才能完成通信的原因：</p>
<ol>
<li>TCP 协议需要通过三次握手建立 TCP 连接保证通信的可靠性（1.5-RTT）</li>
<li>TLS 协议会在 TCP 协议之上通过四次握手建立 TLS 连接保证通信的安全性（2-RTT）</li>
<li>HTTP 协议会在 TCP 和 TLS 上通过一次往返发送请求并接收响应（1-RTT）</li>
</ol>
<h3 id="浏览器访问某个网址的详细过程，四次挥手（腾讯-滴滴）"><a href="#浏览器访问某个网址的详细过程，四次挥手（腾讯-滴滴）" class="headerlink" title="浏览器访问某个网址的详细过程，四次挥手（腾讯 滴滴）"></a>浏览器访问某个网址的详细过程，四次挥手（腾讯 滴滴）</h3><ol>
<li>获得域名所对应的IP地址，若DNS缓存中没有相关数据，则浏览器向DNS服务器发出DNS请求，以获取域名所对应的IP地址。</li>
<li>浏览器与域名地址建立TCP连接，三次握手</li>
<li>HTTP访问</li>
<li>断开TCP链接, 四次挥手</li>
</ol>
<h3 id="http2-和-quic-原理（字节）"><a href="#http2-和-quic-原理（字节）" class="headerlink" title="http2 和 quic 原理（字节）"></a>http2 和 quic 原理（字节）</h3><h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><ol>
<li>二进制分帧(Binary Format)</li>
<li>多路复用(Multiplexing)/连接共享</li>
<li>头部压缩(Header Compression)</li>
<li>压缩原理</li>
<li>请求优先级(Request Priorities)</li>
<li>服务端推送(Server Push)</li>
</ol>
<h4 id="Quic"><a href="#Quic" class="headerlink" title="Quic"></a>Quic</h4><blockquote>
<p>Quic (Quick Udp Internet Connection 快速UDP互联网连接)</p>
</blockquote>
<p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势</p>
<ol>
<li>减少了 TCP 三次握手及 TLS 握手时间</li>
<li>改进的拥塞控制</li>
<li>避免队头阻塞的多路复用</li>
<li>连接迁移</li>
<li>前向冗余纠错</li>
</ol>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="分布式事务怎么处理（高德-陌陌）"><a href="#分布式事务怎么处理（高德-陌陌）" class="headerlink" title="分布式事务怎么处理（高德 陌陌）"></a>分布式事务怎么处理（高德 陌陌）</h3><h3 id="简述-raft-原理（陌陌）"><a href="#简述-raft-原理（陌陌）" class="headerlink" title="简述 raft 原理（陌陌）"></a>简述 raft 原理（陌陌）</h3><h3 id="分布式-id-的几种实现和优缺点（滴滴）"><a href="#分布式-id-的几种实现和优缺点（滴滴）" class="headerlink" title="分布式 id 的几种实现和优缺点（滴滴）"></a>分布式 id 的几种实现和优缺点（滴滴）</h3><h3 id="降级-限流-熔断实现原理（高德-陌陌）"><a href="#降级-限流-熔断实现原理（高德-陌陌）" class="headerlink" title="降级 限流 熔断实现原理（高德 陌陌）"></a>降级 限流 熔断实现原理（高德 陌陌）</h3><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="设计秒杀系统，需要支持-100W-以上-QPS（滴滴）"><a href="#设计秒杀系统，需要支持-100W-以上-QPS（滴滴）" class="headerlink" title="设计秒杀系统，需要支持 100W 以上 QPS（滴滴）"></a>设计秒杀系统，需要支持 100W 以上 QPS（滴滴）</h3><h3 id="设计微博首页，需要拉取所有关注用户的最近-20-条微博（百度）"><a href="#设计微博首页，需要拉取所有关注用户的最近-20-条微博（百度）" class="headerlink" title="设计微博首页，需要拉取所有关注用户的最近 20 条微博（百度）"></a>设计微博首页，需要拉取所有关注用户的最近 20 条微博（百度）</h3><h3 id="抢红包算法设计（百度-滴滴）"><a href="#抢红包算法设计（百度-滴滴）" class="headerlink" title="抢红包算法设计（百度 滴滴）"></a>抢红包算法设计（百度 滴滴）</h3><h3 id="设计一个短链系统（百度）"><a href="#设计一个短链系统（百度）" class="headerlink" title="设计一个短链系统（百度）"></a>设计一个短链系统（百度）</h3><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="布隆过滤器的实现原理和使用场景（滴滴）"><a href="#布隆过滤器的实现原理和使用场景（滴滴）" class="headerlink" title="布隆过滤器的实现原理和使用场景（滴滴）"></a>布隆过滤器的实现原理和使用场景（滴滴）</h3><h3 id="进程间通信有哪几种方式（腾讯）"><a href="#进程间通信有哪几种方式（腾讯）" class="headerlink" title="进程间通信有哪几种方式（腾讯）"></a>进程间通信有哪几种方式（腾讯）</h3><h3 id="进程线程协程区别（滴滴-知乎）"><a href="#进程线程协程区别（滴滴-知乎）" class="headerlink" title="进程线程协程区别（滴滴 知乎）"></a>进程线程协程区别（滴滴 知乎）</h3><h3 id="lvs-原理，如何保证高可用（滴滴）"><a href="#lvs-原理，如何保证高可用（滴滴）" class="headerlink" title="lvs 原理，如何保证高可用（滴滴）"></a>lvs 原理，如何保证高可用（滴滴）</h3><h3 id="502-504-什么原因，如何处理（滴滴-百度-腾讯-顺丰）"><a href="#502-504-什么原因，如何处理（滴滴-百度-腾讯-顺丰）" class="headerlink" title="502 504 什么原因，如何处理（滴滴 百度 腾讯 顺丰）"></a>502 504 什么原因，如何处理（滴滴 百度 腾讯 顺丰）</h3><h3 id="给你两个一模一样的玻璃球，求出-100-层楼哪一层开始玻璃球会被摔碎（腾讯）"><a href="#给你两个一模一样的玻璃球，求出-100-层楼哪一层开始玻璃球会被摔碎（腾讯）" class="headerlink" title="给你两个一模一样的玻璃球，求出 100 层楼哪一层开始玻璃球会被摔碎（腾讯）"></a>给你两个一模一样的玻璃球，求出 100 层楼哪一层开始玻璃球会被摔碎（腾讯）</h3><h3 id="一致性-hash-原理，怎么解决节点少数据倾斜的问题（滴滴-陌陌）"><a href="#一致性-hash-原理，怎么解决节点少数据倾斜的问题（滴滴-陌陌）" class="headerlink" title="一致性 hash 原理，怎么解决节点少数据倾斜的问题（滴滴 陌陌）"></a>一致性 hash 原理，怎么解决节点少数据倾斜的问题（滴滴 陌陌）</h3>
        
      
    </div>

    <footer class="article-footer">
      
      
      <div>
        <ul class="post-copyright">
          <li class="post-copyright-author">
          <strong>本文作者:  </strong>CAO XIAN LIANG</a>
          </li>
          <li class="post-copyright-link">
          <strong>本文链接:  </strong>
          <a href="/2022/03/03/PHP-Eight-Legged-Essay/" target="_blank" title="PHP面试八股文">http://blog.caoxl.com/2022/03/03/PHP-Eight-Legged-Essay/</a>
          </li>
          <li class="post-copyright-license">
            <strong>版权声明:   </strong>
            本博客所有文章除特别声明外，均采用 <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
            许可协议。转载请注明出处
          </li>
         
        </ul>
<div>

      
      
      
      
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔试题/">笔试题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试题/">面试题</a></li></ul>

      

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/10/Byte-Dance-Interview-I/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          字节跳动面试题 I
        
      </div>
    </a>
  
  
    <a href="/2022/02/18/RabbitMQ-Learn-More-III/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">RabbitMQ 死信队列 延迟队列 惰性队列</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="toc-sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#php"><span class="nav-number">1.</span> <span class="nav-text">php</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#php-fpm-的生命周期，创建进程方式，各自的优缺点（腾讯-百度-滴滴-陌陌）"><span class="nav-number">1.1.</span> <span class="nav-text">php-fpm 的生命周期，创建进程方式，各自的优缺点（腾讯 百度 滴滴 陌陌）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#php生命周期"><span class="nav-number">1.1.1.</span> <span class="nav-text">php生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static-静态模式"><span class="nav-number">1.1.2.</span> <span class="nav-text">static 静态模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ondemand-按需分配模式"><span class="nav-number">1.1.3.</span> <span class="nav-text">ondemand 按需分配模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-动态模式-默认"><span class="nav-number">1.1.4.</span> <span class="nav-text">dynamic 动态模式(默认)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#php-数组遍历为什么能保证有序（滴滴）"><span class="nav-number">1.2.</span> <span class="nav-text">php 数组遍历为什么能保证有序（滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#php-怎么实现的弱类型，怎么实现一个扩展（腾讯）"><span class="nav-number">1.3.</span> <span class="nav-text">php 怎么实现的弱类型，怎么实现一个扩展（腾讯）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现php弱类型变量"><span class="nav-number">1.3.1.</span> <span class="nav-text">实现php弱类型变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现一个扩展"><span class="nav-number">1.3.2.</span> <span class="nav-text">实现一个扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见魔术方法和函数（腾讯-滴滴）"><span class="nav-number">1.4.</span> <span class="nav-text">常见魔术方法和函数（腾讯 滴滴）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mysql"><span class="nav-number">2.</span> <span class="nav-text">mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有哪些事务隔离级别，Mysql-的事务隔离级别是怎么实现的？（每家都问）"><span class="nav-number">2.1.</span> <span class="nav-text">有哪些事务隔离级别，Mysql 的事务隔离级别是怎么实现的？（每家都问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引原理（每家都问）"><span class="nav-number">2.2.</span> <span class="nav-text">索引原理（每家都问）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引的分类"><span class="nav-number">2.2.1.</span> <span class="nav-text">索引的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）"><span class="nav-number">2.3.</span> <span class="nav-text">分库分表的策略，如果要按照分表字段以外的字段作为查询条件怎么办（每家都问）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#唯一主键"><span class="nav-number">2.3.1.</span> <span class="nav-text">唯一主键</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC-和间隙锁原理（滴滴-字节-百度）"><span class="nav-number">2.4.</span> <span class="nav-text">MVCC 和间隙锁原理（滴滴 字节 百度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explain-的-type-字段有哪些（知乎）"><span class="nav-number">2.5.</span> <span class="nav-text">explain 的 type 字段有哪些（知乎）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#type扫描方式由快到慢"><span class="nav-number">2.5.1.</span> <span class="nav-text">type扫描方式由快到慢</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update-语句的执行流程，binlog-的作用和几种格式（滴滴）"><span class="nav-number">2.6.</span> <span class="nav-text">update 语句的执行流程，binlog 的作用和几种格式（滴滴）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#binlog-的作用和几种格式"><span class="nav-number">2.6.1.</span> <span class="nav-text">binlog 的作用和几种格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从同步的原理和问题（字节-滴滴-陌陌）"><span class="nav-number">2.7.</span> <span class="nav-text">主从同步的原理和问题（字节 滴滴 陌陌）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主从复制原理"><span class="nav-number">2.7.1.</span> <span class="nav-text">主从复制原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#延迟问题"><span class="nav-number">2.7.2.</span> <span class="nav-text">延迟问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发生死锁的原因以及如何解决（滴滴-顺丰）"><span class="nav-number">2.8.</span> <span class="nav-text">发生死锁的原因以及如何解决（滴滴 顺丰）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发生死锁的原因"><span class="nav-number">2.8.1.</span> <span class="nav-text">发生死锁的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁处理方法"><span class="nav-number">2.8.2.</span> <span class="nav-text">死锁处理方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何优化大-offset（陌陌）"><span class="nav-number">2.9.</span> <span class="nav-text">如何优化大 offset（陌陌）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis"><span class="nav-number">3.</span> <span class="nav-text">redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存如何保证一致性（每家都问）"><span class="nav-number">3.1.</span> <span class="nav-text">缓存如何保证一致性（每家都问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用过-redis-哪些数据结构，使用场景是什么（每家都问）"><span class="nav-number">3.2.</span> <span class="nav-text">用过 redis 哪些数据结构，使用场景是什么（每家都问）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-的-connect-和-pconnect-的区别，pconnect-有什么问题（滴滴-陌陌）"><span class="nav-number">3.3.</span> <span class="nav-text">redis 的 connect 和 pconnect 的区别，pconnect 有什么问题（滴滴 陌陌）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-如何实现分布式锁，有什么问题（陌陌）"><span class="nav-number">3.4.</span> <span class="nav-text">redis 如何实现分布式锁，有什么问题（陌陌）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-为什么用跳表实现有序集合？原理，用有序集合的场景（字节-滴滴）"><span class="nav-number">3.5.</span> <span class="nav-text">redis 为什么用跳表实现有序集合？原理，用有序集合的场景（字节 滴滴）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#跳表数据结构"><span class="nav-number">3.5.1.</span> <span class="nav-text">跳表数据结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从同步的原理，哨兵和集群的区别（滴滴）"><span class="nav-number">3.6.</span> <span class="nav-text">主从同步的原理，哨兵和集群的区别（滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis-cluster-用的什么协议同步数据，哨兵的选举呢（陌陌）"><span class="nav-number">3.7.</span> <span class="nav-text">redis cluster 用的什么协议同步数据，哨兵的选举呢（陌陌）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#哨兵选举"><span class="nav-number">3.7.1.</span> <span class="nav-text">哨兵选举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rdb-和-aof-的原理（滴滴-高德）"><span class="nav-number">3.8.</span> <span class="nav-text">rdb 和 aof 的原理（滴滴 高德）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据过期和淘汰策略（滴滴-高德-字节）"><span class="nav-number">3.9.</span> <span class="nav-text">数据过期和淘汰策略（滴滴 高德 字节）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据过期"><span class="nav-number">3.9.1.</span> <span class="nav-text">数据过期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#淘汰策略"><span class="nav-number">3.9.2.</span> <span class="nav-text">淘汰策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存雪崩-击穿-穿透（滴滴-陌陌）"><span class="nav-number">3.10.</span> <span class="nav-text">缓存雪崩 击穿 穿透（滴滴 陌陌）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#elasticsearch"><span class="nav-number">4.</span> <span class="nav-text">elasticsearch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#深度分页会有什么问题（滴滴-百度-陌陌）"><span class="nav-number">4.1.</span> <span class="nav-text">深度分页会有什么问题（滴滴 百度 陌陌）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#from-size"><span class="nav-number">4.1.1.</span> <span class="nav-text">from/size</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#scroll"><span class="nav-number">4.1.2.</span> <span class="nav-text">scroll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#search-after"><span class="nav-number">4.1.3.</span> <span class="nav-text">search_after</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#倒排索引的原理（字节-高德）"><span class="nav-number">4.2.</span> <span class="nav-text">倒排索引的原理（字节 高德）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lsm-树原理（字节）"><span class="nav-number">4.3.</span> <span class="nav-text">lsm 树原理（字节）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#kafka"><span class="nav-number">5.</span> <span class="nav-text">kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka-的架构，大致储存结构（高德-字节-滴滴）"><span class="nav-number">5.1.</span> <span class="nav-text">kafka 的架构，大致储存结构（高德 字节 滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如果消费者数超过分区数会怎么样？（顺丰-滴滴）"><span class="nav-number">5.2.</span> <span class="nav-text">如果消费者数超过分区数会怎么样？（顺丰 滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#怎么保证数据的可靠投递？（陌陌-字节）"><span class="nav-number">5.3.</span> <span class="nav-text">怎么保证数据的可靠投递？（陌陌 字节）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消费者的-offset-存在哪里？（字节-腾讯-陌陌）"><span class="nav-number">5.4.</span> <span class="nav-text">消费者的 offset 存在哪里？（字节 腾讯 陌陌）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何通过-offset-定位消息？（字节）"><span class="nav-number">5.5.</span> <span class="nav-text">如何通过 offset 定位消息？（字节）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间轮的原理（陌陌-顺丰）"><span class="nav-number">5.6.</span> <span class="nav-text">时间轮的原理（陌陌 顺丰）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka-写入高性能的原因，sendfile-和-mmap-原理，为什么不用-splice（滴滴）"><span class="nav-number">5.7.</span> <span class="nav-text">kafka 写入高性能的原因，sendfile 和 mmap 原理，为什么不用 splice（滴滴）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络"><span class="nav-number">6.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#https-原理，tls-握手需要几个-rtt？（滴滴-百度）"><span class="nav-number">6.1.</span> <span class="nav-text">https 原理，tls 握手需要几个 rtt？（滴滴 百度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器访问某个网址的详细过程，四次挥手（腾讯-滴滴）"><span class="nav-number">6.2.</span> <span class="nav-text">浏览器访问某个网址的详细过程，四次挥手（腾讯 滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http2-和-quic-原理（字节）"><span class="nav-number">6.3.</span> <span class="nav-text">http2 和 quic 原理（字节）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP2"><span class="nav-number">6.3.1.</span> <span class="nav-text">HTTP2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Quic"><span class="nav-number">6.3.2.</span> <span class="nav-text">Quic</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式系统"><span class="nav-number">7.</span> <span class="nav-text">分布式系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式事务怎么处理（高德-陌陌）"><span class="nav-number">7.1.</span> <span class="nav-text">分布式事务怎么处理（高德 陌陌）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简述-raft-原理（陌陌）"><span class="nav-number">7.2.</span> <span class="nav-text">简述 raft 原理（陌陌）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式-id-的几种实现和优缺点（滴滴）"><span class="nav-number">7.3.</span> <span class="nav-text">分布式 id 的几种实现和优缺点（滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#降级-限流-熔断实现原理（高德-陌陌）"><span class="nav-number">7.4.</span> <span class="nav-text">降级 限流 熔断实现原理（高德 陌陌）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统设计"><span class="nav-number">8.</span> <span class="nav-text">系统设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计秒杀系统，需要支持-100W-以上-QPS（滴滴）"><span class="nav-number">8.1.</span> <span class="nav-text">设计秒杀系统，需要支持 100W 以上 QPS（滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计微博首页，需要拉取所有关注用户的最近-20-条微博（百度）"><span class="nav-number">8.2.</span> <span class="nav-text">设计微博首页，需要拉取所有关注用户的最近 20 条微博（百度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抢红包算法设计（百度-滴滴）"><span class="nav-number">8.3.</span> <span class="nav-text">抢红包算法设计（百度 滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计一个短链系统（百度）"><span class="nav-number">8.4.</span> <span class="nav-text">设计一个短链系统（百度）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">9.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#布隆过滤器的实现原理和使用场景（滴滴）"><span class="nav-number">9.1.</span> <span class="nav-text">布隆过滤器的实现原理和使用场景（滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信有哪几种方式（腾讯）"><span class="nav-number">9.2.</span> <span class="nav-text">进程间通信有哪几种方式（腾讯）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程线程协程区别（滴滴-知乎）"><span class="nav-number">9.3.</span> <span class="nav-text">进程线程协程区别（滴滴 知乎）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lvs-原理，如何保证高可用（滴滴）"><span class="nav-number">9.4.</span> <span class="nav-text">lvs 原理，如何保证高可用（滴滴）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#502-504-什么原因，如何处理（滴滴-百度-腾讯-顺丰）"><span class="nav-number">9.5.</span> <span class="nav-text">502 504 什么原因，如何处理（滴滴 百度 腾讯 顺丰）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#给你两个一模一样的玻璃球，求出-100-层楼哪一层开始玻璃球会被摔碎（腾讯）"><span class="nav-number">9.6.</span> <span class="nav-text">给你两个一模一样的玻璃球，求出 100 层楼哪一层开始玻璃球会被摔碎（腾讯）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性-hash-原理，怎么解决节点少数据倾斜的问题（滴滴-陌陌）"><span class="nav-number">9.7.</span> <span class="nav-text">一致性 hash 原理，怎么解决节点少数据倾斜的问题（滴滴 陌陌）</span></a></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>
      
      <footer id="footer">
  

  <div class="container">
      	<div class="row">
	      <p> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/iTimeTraveler/hexo-theme-hiker" target="_blank">Hexo-theme-hiker</a> </p>
	      <p id="copyRightEn">Copyright &copy; 2017 - 2022 Keep It Simple And Stupid All Rights Reserved.</p>
	      
	      
    		<p class="busuanzi_uv">
				访客数 : <span id="busuanzi_value_site_uv"></span> |  
				访问量 : <span id="busuanzi_value_site_pv"></span>
		    </p>
  		   
		</div>

		
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");
    var allheader = document.getElementById("allheader");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    if (allheader != null) {
      contentdiv.style.minHeight = document.body.offsetHeight - allheader.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    } else {
      contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("footer").offsetHeight + "px";
    }
</script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<script src="/js/scripts.js"></script>




  <script src="/js/dialog.js"></script>








	<div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true" style="display: none;">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="myModalLabel">设置</h2>
      </div>
      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">


      <div class="modal-body">
          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseOne" onclick="javascript:setFontSize();" aria-expanded="true" aria-controls="collapseOne">
              正文字号大小
            </a>
          </div>
          <div id="collapseOne" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingOne">
          <div class="panel-body">
            您已调整页面字体大小
          </div>
        </div>
      


          <div style="margin:6px;">
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseTwo" onclick="javascript:setBackground();" aria-expanded="true" aria-controls="collapseTwo">
              夜间护眼模式
            </a>
        </div>
          <div id="collapseTwo" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingTwo">
          <div class="panel-body">
            夜间模式已经开启，再次单击按钮即可关闭 
          </div>
        </div>

        <div>
            <a data-toggle="collapse" data-parent="#accordion" href="#collapseThree" aria-expanded="true" aria-controls="collapseThree">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关 于&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</a>
        </div>
         <div id="collapseThree" class="panel-collapse collapse" role="tabpanel" aria-labelledby="headingThree">
          <div class="panel-body">
            Keep It Simple And Stupid
          </div>
          <div class="panel-body">
            Copyright © 2022 CAO XIAN LIANG All Rights Reserved.
          </div>
        </div>
      </div>


      <hr style="margin-top:0px; margin-bottom:0px; width:80%; border-top: 1px solid #000;">
      <hr style="margin-top:2px; margin-bottom:0px; width:80%; border-top: 3px solid #000;">
      <div class="modal-footer">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
      </div>
    </div>
  </div>
</div>
  
  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
  
    <a id="menu-switch"><i class="fa fa-bars fa-lg"></i></a>
  
</body>
</html>