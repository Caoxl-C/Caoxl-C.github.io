{"meta":{"title":"Keep It Simple And Stupid","subtitle":"Caoxl-Hexo-caoxl.com","description":"keep calm and think more.\n","author":"CAO XIAN LIANG","url":"http://blog.caoxl.com"},"pages":[{"title":"","date":"2020-07-14T07:25:10.700Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"404.html","permalink":"http://blog.caoxl.com/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"","date":"2020-07-14T07:25:10.915Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"ToMe/2018-07-20-How-To-Pick-Lipstick-To-MyWife.html","permalink":"http://blog.caoxl.com/ToMe/2018-07-20-How-To-Pick-Lipstick-To-MyWife.html","excerpt":"买口红给老婆也是一件快乐的事情, 我喜欢挑口红的这个过程","text":"买口红给老婆也是一件快乐的事情, 我喜欢挑口红的这个过程 口红等级划分1. Louboutin - 萝卜丁 (¥800-1200 左右)2. Serge Lutens - 芦丹氏 (¥700 左右)3. CPB - 肌肤之钥 (¥450 左右)4. TOM FORD - 汤姆福特 (¥380 左右)5. Dior - 迪奥 (¥320 左右) , YSL - 圣罗兰 (¥320 左右)6. ARMANI - 阿玛尼 (¥310 左右), GIVENCHY - 纪梵希 (¥355 左右), CHANEL - 香奈儿 (¥300 左右), LANCOME - 兰蔻 (¥270 左右), Guerlain - 娇兰 (¥320 左右), Estee Lauder - 雅诗兰黛 (¥270 左右)7. Shu-uemura - 植村秀 (¥230 左右), NARS (¥250 左右)8. MAC - 魅可 (¥170 左右)9. Maybelline - 美宝莲 (¥100 左右), L&#39;oreal - 欧莱雅 (¥120 左右)10. CARSLAN - 卡姿兰 (¥100 左右)口红色号推荐Louboutin - 萝卜丁 415s You You 605s Escatin 210 Bell yblloom Serge Lutens - 芦丹氏 Garde rose 明媚玫瑰粉 CPB - 肌肤之钥 CPB 311 TOM FORDDior - 迪奥 Dior 999 Dior 888 Dior 520 YSL - 圣罗兰 方管N49 方管N73 ARMANI - 阿玛尼 400 405 GIVENCHY - 纪梵希 304 CHANEL - 香奈儿Guerlain - 娇兰Estee Lauder 雅诗兰黛Lancome 兰蔻Shu-uemura - 植村秀NARS - 纳斯MAC - 魅可 CHILI SEE SHEER LADY DANGER"},{"title":"About Me","date":"2017-12-29T07:30:30.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.caoxl.com/about/index.html","excerpt":"","text":"Keep It Simple Stupid力求简单易读、准确、有价值，以及，坚持。 力争深入浅出，不过这对于不同水平的人有不同的理解。都以我写作当时的水平和理解能力为参考线。 Mail me via: code0809@163.com 本博客的所有原创作品采用 “知识共享”署名-非商业性使用-相同方式共享3.0协议进行许可"},{"title":"","date":"2020-07-14T07:25:10.918Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"ToMe/ToMe.html","permalink":"http://blog.caoxl.com/ToMe/ToMe.html","excerpt":"","text":"工作经验层面 技术文档规范/代码规范(PSR)/版本控制规范 团队协作/前后端分离 数据库设计文档 技术架构搭建 服务器层面 服务器的选择/配置 LAMP/LNMP 配置搭建 Linux下PHP+MySQL+Nginx环境搭建 Nginx配置、php-fpm配置 Shell脚本的编写 框架层面 La/Lu、TP、Yaf、CI、Yii 框架 不同框架-单元测试代码 框架的选择/比较 代码层面 微信、支付宝、银联支付的接入与开发 (任何公司支付都是一个重点) 敏感技术加密技术、各种加密手段(例如: JWT) swoole扩展 (加分项) MongoDB的使用 静态化设计 (一般官网需要) 数据库优化 (一般情况你只需要考虑建表、字段类型、索引) Redis 缓存、队列、秒杀 (一般商城需要) 网络层面 TCP/IP、HTTP/HTTPS等协议 进程、线程、携程 高并发、大流量问题 版本控制层面 Git、SVN 其他 Python、Go、Java、C/C++、C# 等会其中一门是加分项(要当总监就得会的多) 拥有个人博客 Github、Coding等有自己的开源项目 网页抓取原理及技术 Chrome、Firefox开发者调试工具"},{"title":"","date":"2020-07-14T07:25:10.913Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"ToMe/2018-07-17-To-MyLove-CaoLiangXi.html","permalink":"http://blog.caoxl.com/ToMe/2018-07-17-To-MyLove-CaoLiangXi.html","excerpt":"My Love Cao Liang Xi嘿~ 亲爱的女儿 你今天满月啦!","text":"My Love Cao Liang Xi嘿~ 亲爱的女儿 你今天满月啦! 亲爱的女儿, 你也拥有了属于你的名字 — 曹梁希Day1. 2018-06-17 20:47:00 今天是我的第一个父亲节, 而你是你妈妈送给我的第一个父亲节礼物, 我过的是最开心的父亲节, 而你的妈妈也是最辛苦的一天 Day2. 2018-06-18 这一天, 大早上医生说你检查出新生儿感染了, 才见到你一天就要把你送到儿科(哭哭~~) Day3. 2018-06-19 今天本应该是看不到你的, 因为医院让我带你去二楼做B超, 才能把你带出来透透气,哈哈, 希希你好乖, 那B超的床那么冰你都没有哭, 就是紧紧抓住爸爸的手. Day4. 2018-06-20 周三哼! 医院居然只给周二、周四、周六的下午才能去看你, 所以今天是爸爸第一天,一整天都没有看到你 Day5. 2018-06-21 希希呀, 我们就只能这样看你,还只能看20分钟, 你是真的好乖呀, 在里面都不哭的,(在里面睡觉是什么感觉呀,等你会说话的时候告诉我好不好呀) Day6. 2018-06-22 周五又是一个看不到你的日子, 刚把你送去的时候医生说最少三天, 然后等结果出来又说要3-5天, 然后再等又说说不定要一星期或者两星期. 天呐~ 让你一个人在里面这么久!真是折磨我呀! Day7. 2018-06-23 周六 天气晴哈哈哈~为啥要说今天的天气呢, 因为今天是个好日子呀, 今天我亲爱的希希宝贝出院啦~~ 来一张回家的特写哈 Day8. 2018-06-24 哈哈~~ 今天抓拍到你的笑啦~ 希希~嘻嘻~ Day9. 2018-06-25 小希希~笑嘻嘻~ 哈哈 你睡觉的时候总喜欢偷笑, 你是梦到什么好吃的了吗. 还有你睁眼发呆的时候到底在想什么呀 Day10. 2018-06-26 宝贝啊, 你好小一只啊, 这下就真的是把你捧在手心啦 你那么的小, 但是看起来又是那么的大, 明明才10天大,看起来好像什么都懂一样,看着这个未知的世界 Day11. 2018-06-27 爸爸给你买的衣服都有点大, 哈哈~~ 但是亲爱的女儿你还是慢慢长大吧, 你小小的爸爸才好抱你呀 Day12. 2018-06-28 哟哟哟~ 这是谁家的菇凉呀~~ 长的好秀气呀 WoW~~ WoW~~ WoW~~ WoW~~ WoW~~ WoW~~ Day13. 2018-06-29 你这两只小手 是准备要投降了吗~ 哈哈 爸爸的手机壁纸就是这张啦~ Day14. 2018-06-30 哈哈哈哈哈哈哈~ 爸爸故意拍的一张哭的,故意留一张不一样的哈哈哈~~ Day15. 2018-07-01 希希啊, 你知道吗, 到了白天你就狂睡, 到了晚上你就闹啊闹啊, 你滴妈妈都瘦了十几斤了~~ Day16. 2018-07-02 来一张五连拍~~ 来来来~~摆pose啦 Day17. 2018-07-03 都说女儿是爸爸的贴心小棉袄, 这句话说的一点都没错,不管我多累,看到你的笑容总是能忍不住笑出来,亲爱的女儿谢谢你谢谢你来到我的世界谢谢你为我带来快乐谢谢你做我的女儿 Day18. 2018-07-04 嘿嘿, 你这个手势是准备跳舞给我看吗 Day19. 2018-07-05 这张照片是你老妈拍的哈, 你去说她去, 把我可爱的希宝拍的像个小光头一样 哈哈 Day20. 2018-07-06 喜欢看你每一个样子, 你醒着放空的样子 你睡着的样子 Day21. 2018-07-07你眯着眼的样子 Day22. 2018-07-08 有人说: 新生儿一天一个样, 这是真的. 爸爸每天早上看你一会就要去上班.等我下班回来就感觉你又长大了一点点. Day23. 2018-07-09来来来, 放上希宝的最美侧颜~ Day24. 2018-07-10 哟哟哟~ 个扭个妞的 准备跳舞给我看吗 Day25. 2018-7-11 Day26. 2018-07-12 Day27. 2018-07-13 希希, 你知道这两个娃娃是什么寓意吗. 这两个娃娃都是在你妈妈怀着你的时候得到的 一个小狗是在深圳玩密室逃脱的时候,给的安慰奖.(哈哈你妈妈怀着你的时候到处浪~~)还有一个女孩是在夹娃娃的时候夹到的 这个就是暗示你的到来: 狗年女孩 哈哈哈~~~ Day28. 2018-07-14Day29. 2018-07-15 希希你的头发长长了好多呀, 你妈妈说你炸毛像超级赛亚人~ 哈哈哈哈~~ Day30. 2018-07-16 不知不觉你都快满月啦. Day31. 2018-07-17 满月啦 早上爸爸给你穿上给你新买的衣服, 亲爱的女儿, 你终于满月啦.你一天天长大, 我才发现时间多么宝贵, 你慢慢长大好不好. 曹梁希希希, 爸爸妈妈给你起这个名字不仅仅是说你是我们的希望; 我们更加希望你可以做自己,希望你可以做自己想做的事情, 希望你每天都过的开心."},{"title":"","date":"2020-07-14T07:25:10.916Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"ToMe/Caoxl-Resume.html","permalink":"http://blog.caoxl.com/ToMe/Caoxl-Resume.html","excerpt":"","text":"曹贤亮个人简历个人资料 求职意向: PHP开发工程师 姓名: 曹贤亮 年龄: 24 (已婚) 地址: 广州市天河区珠村富力花园 邮箱: code0809@163.com 自我评价: 两年PHP 开发经验,参与过多个项目的开发，积累一定经验，熟习常见业务处理，能快速融入团队；具有较强开发能力，善于沟通，大学期间曾获得辩论赛最佳辩手，本科就读计算机专业对计算机非常热爱。 期望薪资: 11K-15K (目前薪资11K) 加分项技术博客 http://blog.caoxl.com 个人项目及源码 https://github.com/SoulMate94 证书及荣誉在校期间获得海南省计算机作品赛省级二等奖 工作技能 1.编码习惯优秀,符合PSR代码规范；熟悉 PHP 项目优化。 (代码规范方面/PHP方面) 2.熟练掌握 OOP 和 MVC 项目管理思想，熟悉常用设计模式；(PHP基础方面) 3.熟练掌握 MySQL 数据库系统，熟悉 MySQL 优化；会 MongoDB 的基本使用。 (数据库方面) 4.熟练掌握 Linux 系统的常用命令；熟悉 LNAMP 下的环境配置、应用部署和排错，了解性能调优。 (服务器方面) 5.熟练掌握GIT,SVN版本控制器的使用;会搭建Git Server并配置自动部署。 (版本控制方面) 6.熟悉 Laravel/Lumen 框架，了解 ThinkPHP、Symfony、Swoole 等框架。熟练掌握Laravel-admin搭建后台项目; (框架方面) 7.会使用 Memcached 和 Redis 等缓存技术；(缓存方面) 8.熟练使用Github/GitLab、禅道、Showdoc 等工作流规范团队开发 (团队开发) 9.熟悉七牛云、支付宝/微信支付、阿里云通信等第三方接口开发。 (第三方) 10.熟悉 HTML/CSS/JS，熟练使用 jQuery、Bootstrap 等前端库;了解VueJS、Angular等前端框架。 (前端方面) 尽量控制在10条之内,且记扬长避短, 工作经历真实工作时间 广州美管饮水工程有限公司 (2018/04 – 2018/08) (公司搬迁到增城区,不是为了职业规划 (10k+餐补+停车费)) 广东惠吃猫网络科技有限公司 (2017/05 – 2018/04) (云联惠倒闭,离职,惠吃猫倒闭 (10k)) 大学期间 深圳圆梦云科技有限公司 (2016/09 – 2017/05) (整个大四时间在深圳,感觉深圳压力大 (67千进)) # 省略不写 海南加力科技有限公司 (2015/09 – 2016/06) (大三获奖之后去公司实习 (34千进)) 项目经历2017/05-至今 水可邦小程序(用户端、师傅端);水可邦后台;水可邦APP;水智盒APP;水可邦官网;公司服务器; 惠吃猫APP(用户端、商家端、配送端);后台(总后台、商家后台、代理商后台);惠吃猫官网; 2017/05之前 购购商城(食品电商城);购购商城后台; 易买网(B2C类型商城);易买网商城后台 加力办公OA系统; (负责功能开发,修复BUG,系统调试) 间隔年概念包装与推荐网站;(标准的官网) 教育经历 海南热带海洋学院(2013-2017) 计算机科学与技术 (本科) 兴趣爱好 爱好打篮球、游泳、爬山、看电影 (生活) 逛逛技术论坛, 探讨一些技术问题 (工作) 附录项目描述的话术 作为技术负责人带领技术组前后端成员开发基于 Laravel 的设计师教育平台，负责核心功能数据库设计和程序编码、爬虫技术难点攻克、版本控制、项目部署及基本运维、网站性能优化等职责。 制定并监督实施开发规范，管理前后端协作，参与项目需求分析讨论和可行性评估，并解决团队开发过程中出现的效率性、技术性等问题。 独立负责基于 Laravel/Lumen 后端开发，RESTful 接口文档编写，数据库设计，环境部署，以及第一阶段的后台管理系统开发 负责二次开发基于 江湖外卖的o2o外卖平台。第一期独立负责后台功能、服务端环境部署等职责，第二期开始负责带领技术组全部成员协同开发，解决协作中前后端出现的流程性、技术性问题。 独立负责使用 Laravel-admin开发水可邦平台所有后台功能，环境部署和部分前端特效。 独立负责后台功能开发，环境部署和部分前端开发工作；搭建 GitLab 并管理团队 Git 协作 写在最后非常感谢您花时间阅读我的简历,期待能有机会和您共事 (个人项目及源码详见 https://github.com/SoulMate94)"},{"title":"Linux 命令 「好玩的」","date":"2018-06-06T08:19:52.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-06-Linux-cmd-Fun.html","permalink":"http://blog.caoxl.com/backup/2018-06-06-Linux-cmd-Fun.html","excerpt":"好玩的 Linux 命令持续更新~~~","text":"好玩的 Linux 命令持续更新~~~ wallwall命令用于向系统当前所有打开的终端上输出信息。类似于广播. 12345[root@iZ58vt8oll8aheZ /]# wall hello[root@iZ58vt8oll8aheZ /]# Broadcast message from root@iZ58vt8oll8aheZ (pts/0) (Wed Jun 6 16:18:37 2018):hello mesgmesg命令用于设置当前终端的写权限，即是否让其他用户向本终端发信息。将mesg设置y时，其他用户可利用write命令将信息直接显示在您的屏幕上。 命令参数 -y/n：y表示运行向当前终端写信息，n表示禁止向当前终端写信息。 manman命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。 命令参数 -a: 在所有的man帮助手册中搜索 -f: 等价于whatis指令,显示给定关键字的间断描述信息 -P: 指定内容时使用分页程序 -M: 指定man手册搜索的路径 whatiswhatis命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上。 whatis命令等同于使用man -f命令。 1234[root@iZ58vt8oll8aheZ /]# whatis lsls (1) - list directory contents[root@iZ58vt8oll8aheZ /]# man -f lsls (1) - list directory contents calcal命令用于显示当前日历，或者指定日期的日历。 命令参数 -1: 显示单月输出 -3: 显示临近三个月的日历 -s: 将星期日作为月的第一天 -m: 将星期一作为月的第一天 -j: 显示从1月1日起第多少天 -y: 显示当前年的日历 speedtest-clispeedtest-cli是一个使用python编写的命令行脚本，通过调用speedtest.net测试上下行的接口来完成速度测试，最后我会测试运维生存时间所在服务器的外网速度。项目地址：https://github.com/sivel/speedtest-cli 安装 pip方式 1pip install speedtest－cli easy_install方式 1easy_install speedtest-cli github＋pip方式 12345pip install git+https://github.com/sivel/speedtest-cli.git// 或者git clone https://github.com/sivel/speedtest-cli.gitpython speedtest-cli/setup.py install 下载脚本方式 123456wget -O speedtest-cli https://raw.github.com/sivel/spe ... er/speedtest_cli.pychmod +x speedtest-cli// 或者curl -o speedtest-cli https://raw.github.com/sivel/spe ... er/speedtest_cli.pychmod +x speedtest-cli 实例123456[root@izj6c6djex81rijczh0t8yz ~]# speedtest-cli --list | grep China10267) Interoute VDC (Hong Kong, China) [0.00 km] 2993) Website Solution Limited (Hong Kong, China) [0.00 km]12990) QTS Data Centers (Hong Kong, China) [0.00 km] 1536) STC (Hong Kong, China) [0.00 km] .... 结果解释 6611) China Mobile,Guangdong (Guangzhou, China) [134.80 km] 6611: 服务器id China Mobile: 服务器所属 (这里是中国移动) Guangdong (Guangzhou, China): 服务器所在地址 [134.80 km]: 两台服务器地理位置之间距离，我这台机器在香港，和广州相距134.80公里. 外网速度测试1234567891011[root@izj6c6djex81rijczh0t8yz ~]# speedtest-cli --server=6611 --shareRetrieving speedtest.net configuration...Testing from Alibaba (47.91.221.85)...Retrieving speedtest.net server list...Retrieving information for the selected server...Hosted by China Mobile,Guangdong (Guangzhou) [134.80 km]: 11.005 msTesting download speed................................................................................Download: 86.75 Mbit/sTesting upload speed................................................................................................Upload: 1.80 Mbit/sShare results: http://www.speedtest.net/result/7370743213.png lastblastb命令用于显示用户错误的登录列表，此指令可以发现系统的登录异常 命令参数 -a: 把从何处登入系统的主机名称或ip地址显示在最后一行 -d: 将IP地址转换成主机名称 -f&lt;记录文件&gt;: 指定记录文件 -n&lt;显示列数&gt;或-&lt;显示列表&gt;: 设置列出名单的显示列数 -R: 不显示登入系统的主机名称或IP地址 -x: 显示系统关机,重新开机, 以及执行等级的改变等信息 fingerfinger命令用于查找并显示用户信息。包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独执行finger指令，它会显示本地主机现在所有的用户的登陆信息，包括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。 安装1yum install finger 命令参数 -l: 列出该用户的账号名称, 真实姓名, 用户专属目录,登入所用Shell,登入时间,转信地址,电子邮件状态,还有计划文件和方案文件内容 -m: 排除查找用户的真实姓名 -s: 列出该用户的账号名称,真实姓名,登入终端机,闲置时间,登入时间以及地址和电话 -p: 列出该用户的帐号名称，真实姓名，用户专属目录，登入所用的Shell，登入时间，转信地址，电子邮件状态，但不显示该用户的计划文件和方案文件内容 实例 123[root@izj6c6djex81rijczh0t8yz ~]# fingerLogin Name Tty Idle Login Time Office Office Phone Hostroot root pts/1 Jun 8 10:04 (61.140.75.173) ctrlaltdelctrlaltdel命令用来设置组合键“Ctrl+Alt+Del”的功能。 命令参数 hard: 当按下组合键“Ctrl+Alt+Del”时，立即执行重新启动操作系统，而不是先调用sync系统调用和其他的关机标准操作。 soft: 当按下组合键“Ctrl+Alt+Del”时，首先向init进程发送SIGINT（interrupt）信号。由init进程处理关机操作。 digdig命令是常用的域名查询工具，可以用来测试域名系统工作是否正常。 安装1yum install bind-utils 命令选项 @&lt;服务器地址&gt;: 指定进行域名解析的域名服务器 -b&lt;ip地址&gt;: 当主机具有多个IP地址,指定使用本机的哪个IP地址向域名服务器发送域名查询请求 -f&lt;文件名称&gt;: 指定dig以批处理的方式运行,指定的文件中保存着需要批处理查询的DNS任务信息 -P: 指定域名服务器所使用的端口号 -t&lt;类型&gt;: 指定要查询的DNS数据类型 -x&lt;IP地址&gt;: 执行逆向域名查询 -4: 使用IPv4 -6: 使用IPv6 -h: 显示指令帮助信息 命令参数 主机: 指定要查询的域名主机 查询类型: 指定DNS查询的类型 查询类: 指定查询DNS的class 查询选项: 指定查询选项 netstatnetstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 命令参数 -a/--all: 显示所有连线中的Socket; -A&lt;网络类型&gt;/--&lt;网络类型&gt;: 列出该网络类型连接中的相关地址; -c/--continuous: 持续列出网络状态 -C/--cache: 显示路由器配置的快取信息 -e/--extend: 显示网络其他相关信息 -F/--fib: 显示FIB -g/--groups: 显示多重广播功能群组组员名单 -h/--help: 在线帮助 -i/--interfaces: 显示网络界面信息表单 -l/--listening: 显示监控中的服务器Socket; -M/--masquerade: 显示伪装的网络连线; -n/--numeric: 直接使用ip地址,而不同过域名服务器 -N/--netlink/--symbolic: 显示网络硬件外围设置的服务连接名称 -o/-timers: 显示计时器 -p/--programs: 显示正在使用Socket的程序识别码和程序名称; -r/--route: 显示Routing Table; -s/--statistice: 显示网络工作信息统计表; -u/--udp: 显示TCP传输协议的连线状况 -v/--verbose: 显示指令执行过程 -V/--version: 显示版本信息 -w/--raw: 显示RAW传输协议的连线状况 -x/--unix: 此参数的效果和指定”-A unix”参数相同 --ip/--inet: 此参数的效果和指定”-A inet”参数相同 实例 列出所有端口(包括监听和未监听的) 123netstat -a #列出所有端口netstat -at #列出所有tcp端口netstat -au #列出所有udp端口 列出所有处于监听状态的 Sockets 1234netstat -l #只显示监听端口netstat -lt #只列出所有监听tcp端口netstat -lu #只列出所有监听udp端口netstat -lx #只列出所有监听UNIX端口 显示每个些而已的统计信息 123netstat -s #显示所有端口的统计信息netstat -st #显示TCP端口的统计信息netstat -su #显示UDP端口的统计信息 在netstat输出中显示PID和进程名称 1netstat -pt 在netstat输出中不显示主机,端口和用户名(host,port,user) 1netstat -an 持续输出netstat信息 1netstat -c #每隔一秒输出网络信息 显示系统不支持的地址族(Address Families) 1netstat --verbose 在输出的末尾有如下信息: 1234netstat: no support for `AF IPX' on this system.netstat: no support for `AF AX25' on this system.netstat: no support for `AF X25' on this system.netstat: no support for `AF NETROM' on this system. 显示核心路由信息 1netstat -r whichwhich命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 语法1which (选项) (参数) 选项 -n&lt;文件名长度&gt;: 制定文件名长度, 指定的长度必须大于或等于所有文件中最长的文件名 -p&lt;文件名长度&gt;: 与-n参数相同,但此处的&gt;文件名长度&gt;包含了文件的路径 -w: 指定输出时栏位的宽度 -V: 显示版本信息 参数指令名: 指令名列表 实例 查找文件,显示命令路径 12345[root@izj6c6djex81rijczh0t8yz test]# which pwd/usr/bin/pwd[root@izj6c6djex81rijczh0t8yz test]# which adduser/usr/sbin/adduser 说明： which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！ treetree命令以树状图列出目录的内容。 命令选项 -a: 显示所有文件和目录 -A: 使用ASNI绘图字符显示树状图而非ASCII字符组成 -C: 在文件和目录清单加上色彩, 便于区分各种类型 -d: 先是目录名称而非内容 -D: 列出文件或目录的更改时间 -f: 在每个文件或目录之前, 显示完整的相对路径名称 -F: 在执行文件, 目录, Socket, 符号连接, 管道名称,各种加上”*”,”/“,”@”,”|”号 -i: 不以阶梯状列出文件和目录名称 -I: 不显示符号范本样式或目录名称 -l: 如遇到性质为符号连接的目录,直接列出该连接所指向的原始目录 -n: 不在文件和目录清单上加上色彩 -N: 直接列出文件和目录名称, 包括控制字符 -p: 列出权限表示 -q: 用”?”号取代控制字符,列出文件和目录名称 -s: 列出文件和目录大小 -t: 用文件和目录的更改时间排序 -u: 列出文件或目录的拥有者名称,没有对应的名称时,则显示用户识别码 -x: 将范围局限在现行系统中, 若指定目录下的某些子目录,其存放于另一个文件系统上，则将该目录予以排除在寻找范围外。 命令参数 目录：执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。 timetime命令用于统计给定命令所花费的总时间。 123456[root@izj6c6djex81rijczh0t8yz default]# time lsAliyun images index-back.html index.html phpinfo.php Server.php socket.htmlreal 0m0.002suser 0m0.000ssys 0m0.001s 输出的信息分别显示了该命令所花费的real时间、user时间和sys时间。 real时间是指挂钟时间， 也就是命令开始执行到结束的时间。这个短时间包括其他进程所占用的时间片，和进程被阻塞时所花费的时间。 user时间是指进程花费在用户模式中的CPU时间， 这是唯一真正用于执行进程所花费的时间，其他进程和花费阻塞状态中的时间没有计算在内。 sys时间是指花费在内核模式中的CPU时间， 代表在内核中执系统调用所花费的时间，这也是真正由进程使用的CPU时间。 wc wc命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数，若不指定文件名称，或是所给予的文件名为“-”，则wc指令会从标准输入设备读取数据。 1wc (选项)(参数) 选项 -c/--bytes/--chars: 只显示Bytes数 -l/--lines: 只显示列数 -w/--words: 只显示字数 参数 文件: 需要统计的文件列表"},{"title":"Linux 命令 「top」","date":"2018-06-05T06:08:33.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-06-Linux-cmd-top.html","permalink":"http://blog.caoxl.com/backup/2018-06-06-Linux-cmd-top.html","excerpt":"top显示当前系统正在执行的进程的相关信息","text":"top显示当前系统正在执行的进程的相关信息 命令参数 -b: 批处理 -c: 显示完整的治命令 -I: 忽略失效过程 -s: 保密模式 -S: 累计模式 -i&lt;时间&gt;: 设置间隔时间 -u&lt;用户名&gt;: 指定用户名 -p&lt;进程号&gt;: 指定进程 -n&lt;次数&gt;: 循环显示的次数 说明第一行 top 任务队列信息 13:57:14 - 当前系统时间 up 20 days, 2:08 - 系统 已经运行了20天2小时8分钟(期间未重启) 2 users - 当前有2个用户登录 load average: 1.15 1.42 1.44 - 后面的三个数分别是1分钟, 5分钟, 15分钟的负载情况 load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。 第二行 Tasks 任务(进程) 系统现在共有 85 个进程, 骑士处于运行中的有 1个,51个正在休眠(sleeping),stopped状态的有0个,zombie(僵尸)状态的有0个 第三行 %Cpu(s) 状态信息 5.9% us - 用户空间占用CPU的百分比 0.3% sy - 内核空间占用CPU的百分比 0.0% ni - 改变过优先级的进程占用CPU的百分比 90.3% id - 空闲CPU百分比 0.0% wa - IO等待占用CPU的百分比 0.0% hi - 硬中断(Hardware IRQ)占用CPU的百分比 0.2% si - 软中断(Software Interrupts)占用CPU的百分比 0.0% st - 虚拟 CPU 等待实际 CPU 的时间的百分比 备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！ 第四行 Kib Mem 内存状态 1009956 total - 物理内存总量 520204 free - 空闲的内存总量 329436 used - 使用中的内存总量 160269 buff/cache - 缓存的内存量 第五行 Kib Swap swap 交换分区信息 0 table - 交换区总量 0 free - 空闲的交换区总量 0 used - 使用中的交换区总量 522924 avail Mem - 缓冲的交换区总量 第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。 如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached 1520204+160269+522924 = 1203397 = 1G左右 对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。 第六行 空行第七行 各进程(任务)的状态监控 PID - 进程id USER - 进程所有者 PR - 进程优先级 NI - nice值. 负值表示高优先级, 正值表示低优先级 VIRT - 进程使用的虚拟内存总量, 单位(kb). VIRT=SWAP+RES RES - 进程使用的,未被换出的物理内存大小,单位(kb). RES=CODE+DATA SHR - 共享内存大小, 单位(kb). S - 进程状态. D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 %CPU - 上次更新到现在的CPU时间占用百分比 %MEM - 进程使用的物理内存百分比 TIME - 进程使用的CPU时间总计, 单位1/100秒 COMMAND - 进程名称 (命令名/命令行)"},{"title":"Linux 命令 「crontab」","date":"2018-06-07T05:42:57.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-07-Linux-cmd-crontab.html","permalink":"http://blog.caoxl.com/backup/2018-06-07-Linux-cmd-crontab.html","excerpt":"crontabcrontab命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似","text":"crontabcrontab命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似 命令参数 -e: 编辑该用户的计时器设置 -l: 列出该用户的计时器设置 -r: 删除该用户的计时器设置 -u&lt;用户名称&gt;: 指定要设定计时器的用户名称 Linux下的任务调度分为两类：系统任务调度和用户任务调度。 系统任务调度系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。 /etc/crontab文件内容: 123456789101112131415SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=rootHOME=/# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 记忆口令: 分 时 日 月 周 cmd 参数解读 第一行SHELL变量指定了系统要使用哪个shell，这里是bash. 第二行PATH变量指定了系统执行命令的路径 第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户 第四行的HOME变量指定了在执行命令或者脚本时使用的主目录(可以省略) 特殊字符 星号(*): 代表所有可能的值. 例如: month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号(,): 可以用逗号隔开的值指定一个列表范围, 例如: “1,2,4,5,6” 中杠(-): 可以用整数之间的中杠表示一个整数范围, 例如 “2-6”表示”2,3,4,5,6” 正斜线(/): 可以用正斜线指定时间的间隔频率, 例如: “0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用， 例如: */10，如果用在minute字段，表示每十分钟执行一次。 用户任务调度所有用户定义的crontab文件都被保存在/var/spool/cron目录中。其文件名与用户名一致，使用者权限文件如下： 123/etc/cron.deny 该文件中所列用户不允许使用crontab命令/etc/cron.allow 该文件中所列用户允许使用crontab命令/var/spool/cron/ 所有用户crontab文件存放的目录,以用户名命名 crond服务 /sbin/service crond start 启动服务 /sbin/service crond stop 关闭服务 /sbin/service crond resatrt 重启服务 /sbin/service crond reload 重新载入配置 service crond status 查看crontab服务状态 service crond start 手动启动crontab服务 ntsysv 查看crontab服务是否设置为开机启动 chkconfig -level 35 crond on 加入开机自动启动 实例 每一分钟执行一次 (固定间隔) 1* * * * * command 每晚的21:30重启smb (指定时间) 130 21 * * * /etc/init.d/smb restart 每天18 : 00至23 : 00之间每隔30分钟重启smb (时间区域内固定间隔) 10,30 18-23 * * * /etc/init.d/smb restart"},{"title":"Linux 命令 「systemctl」","date":"2018-06-07T02:54:23.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-07-Linux-cmd-systemctl.html","permalink":"http://blog.caoxl.com/backup/2018-06-07-Linux-cmd-systemctl.html","excerpt":"systemclsystemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。","text":"systemclsystemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。 命令 使某服务自动启动: systemctl enable httpd.service 使某服务不自动启动: systemctl disable httpd.service 检查服务状态: systemctl status httpd.service (服务详细信息) systemctl is-active httpd.service (仅显示是否Active) 显示所有已启动的服务: systemctl list-units --type=service 启动某服务: systemctl start httpd.service 停止某服务: systemctl stop httpd.service 重启某服务: systemctl restart httpd.service 实例 1.启动nfs服务 1systemctl start nfs-server.service 2.设置开机自启动 1systemctl enable nfs-server.service 3.停止开机启动 1systemctl disable nfs-server.service 4.查看服务当前状态 1systemctl status nfs-server.service 5.重新启动某服务 1systemctl restart nfs-server.service 6.查看所有已启动的服务 1systemctl list -units --type=service 开启防火墙22端口 1iptables -I INPUT -p tcp --dport 22 -j accept 如果仍然有问题，就可能是SELinux导致的 关闭SElinux： 修改/etc/selinux/config文件中的SELINUX=””为disabled，然后重启。 彻底关闭防火墙： 123sudo systemctl status firewalld.servicesudo systemctl stop firewalld.servicesudo systemctl disable firewalld.service"},{"title":"Linux 命令 「lsof」","date":"2018-06-08T01:28:45.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-08-Linux-cmd-lsof.html","permalink":"http://blog.caoxl.com/backup/2018-06-08-Linux-cmd-lsof.html","excerpt":"lsoflsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。","text":"lsoflsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。 命令参数 -a: 列出打开文件存在的进程 -c&lt;进程&gt;: 列出指定进程所打开的文件 -g: 列出GID进程详情 -d&lt;文件号&gt;: 列出占用该文件号的进程 +d&lt;目录&gt;: 列出目录下被打开的文件 +D&lt;目录&gt;: 递归列出目录下被打开的文件 -n&lt;目录&gt;: 列出使用NFS的文件 -i&lt;条件&gt;: 列出符合条件的进程. (4,6,协议,:端口,@ip) -p&lt;进程&gt;: 列出指定进程所打开的文件 -u: 列出UID号进程 -h: 显示帮助信息 -v: 显示版本信息 实例123456789101112131415[root@izj6c6djex81rijczh0t8yz ~]# lsof -iCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEntpd 886 ntp 16u IPv4 13635 0t0 UDP *:ntp ntpd 886 ntp 17u IPv6 13637 0t0 UDP *:ntp ntpd 886 ntp 18u IPv4 13642 0t0 UDP localhost:ntp ntpd 886 ntp 19u IPv4 13643 0t0 UDP izj6c6djex81rijczh0t8yz:ntp mysqld 1464 mysql 11u IPv4 14633 0t0 TCP *:mysql (LISTEN)nginx 1518 root 8u IPv4 14491 0t0 TCP *:http (LISTEN)nginx 1518 root 9u IPv4 14492 0t0 TCP *:https (LISTEN)nginx 1519 www 8u IPv4 14491 0t0 TCP *:http (LISTEN)nginx 1519 www 9u IPv4 14492 0t0 TCP *:https (LISTEN)sshd 1567 root 3u IPv4 15069 0t0 TCP *:ssh (LISTEN)redis-ser 5466 root 6u IPv4 869898 0t0 TCP localhost:6379 (LISTEN)sshd 9860 root 3u IPv4 908787 0t0 TCP izj6c6djex81rijczh0t8yz:ssh-&gt;61.140.75.173:19681 (ESTABLISHED)AliYunDun 28741 root 18u IPv4 904389 0t0 TCP izj6c6djex81rijczh0t8yz:53014-&gt;106.11.68.13:http (ESTABLISHED) 参数解释 COMMAND: 进程的名称 PID: 进程标识符 PPID: 父进程标识符 (需要指定 -R 参数) USER: 进程所有者 PGID: 进程所属组 FD: 文件描述符, 应用程序通过文件描述识别该文件 文件描述符列表 cwd: current work directory,即:应用程序的当前工作目录 txt: 该类型的文件是程序代码 lnn: 参考文献 er: FD信息误差(参见名称栏) jld: 监狱目录( FreeBSD一种可免费使用的UNIX操作系统) ltx: 共享库文本(代码和数据) mxx: 十六进制内存映射类型XX。 m86: DOS合并映射文件 mem: 内存映射文件 mmap: 内存映射设备 pd: 父目录 rtd: 根目录 tr: 内核跟踪文件(OpenBSD) v86: VP/ix 隐射文件 0: 表示标准输出 1: 表示标准输入 2: 表示标准错误 一般在标准输出、标准错误、标准输入后还跟着文件状态模式： u: 表示该文件被打开并处于读取/写入模式 r: 表示该文件被打开并处于只读模式 w: 表示该文件被打开并处于写入模式 空格: 表示该文件的状态模式为 unknown,且没有锁定 -: 表示该文件的状态模式为 unknown, 且被锁定 同时在文件状态模式后面，还跟着相关的锁： N: 对于未知类型的Solaris NFS锁 r: 文件的部分读锁 R: 整个文件的读锁 w: 文件的部分写锁 W: 整个文件的写锁 u: 对于任意长度的读写锁 U: 对于未知类型的锁 x: 对于SCO OpenServer XIX锁的一部分文件 X: 对于SCO OpenServer XIX锁的整个文件 空格: 没有锁 文件类型 DIR: 目录 CHR: 字符类型 BLK: 块设备类型 UNIX: UNIX域套接字 FIFO: 先进先出队列 IPv4: 网际协议(IP)套接字 DEVICE: 指定磁盘的名称 SIZE: 文件的大小 NODE: 索引节点 (文件在磁盘上的标识) NAME: 打开文件的确切名称"},{"title":"Linux 命令 「kill」","date":"2018-06-12T01:17:26.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-12-Linux-cmd-kill.html","permalink":"http://blog.caoxl.com/backup/2018-06-12-Linux-cmd-kill.html","excerpt":"kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或job指令查看。","text":"kill命令用来删除执行中的程序或工作。kill可将指定的信息送至程序。预设的信息为SIGTERM(15),可将指定程序终止。若仍无法终止该程序，可使用SIGKILL(9)信息尝试强制删除程序。程序或工作的编号可利用ps指令或job指令查看。 命令参数 -a: 当处理当前进程时, 不限制命令名和进程名的对应关系 -l&lt;信息编号&gt;: 若不加&lt;信息编号&gt;选项,则-l参数惠列出全部的信息名称 -p: 指定kill命令只打印相关进程的进程号,而不发送任何信号 -s&lt;信息名称或编号&gt;: 指定要送出的信息 -u: 指定用户 所有信号名称 kill -l 1234567891011121314[root@izj6c6djex81rijczh0t8yz ~]# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX 只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略，下面是常用的信号： 1234567HUP 1 终端断线INT 2 中断(同Ctrl + C)QUIT 3 退出(同Ctrl + \\)TERM 15 终止KILL 9 强制终止CONT 18 继续(与STOP相反, fg/bg命令)STOP 19 暂停(同Ctrl + Z) 使用先用ps查找进程，然后用kill杀掉： 12ps -ef | grep vimkill PID 注意: 使用信号 15 是安全的，而信号 9 则是处理异常进程的最后手段，请勿滥用。 pkillpkill命令可以按照进程名杀死进程。pkill和killall应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill来杀掉。 命令参数 -o: 仅向找到的最小(起始)进程号发送信号 -n: 仅向找到的最大(结束)进程号发送信号 -p: 指定父进程号发送信号 -g: 指定进程组 进程名称：指定要查找的进程名称，同时也支持类似grep指令中的匹配模式。 实例1234grep -l gaim2979 gaimpkill gaim 也就是说：kill对应的是PID，pkill对应的是command。 killallkillall命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程 命令参数 -e: 对长名称进行精确匹配 -I: 忽略大小写的不同 -p: 杀死进程所属的进程组 -i: 交互式杀死进程,杀死进程前需要进行确认 -l: 打印所有已知信号列表 -q: 如果没有进程被杀死,则不输出任何信息 -r: 使用正则表达式匹配要杀死的进程名称 -s: 用指定的进程号代替默认信号”SIGTERM” -u: 杀死指定用户的进程 -Z: 只杀死拥有scontext的进程 -v: 报告信息是否成功发送 --help: 显示帮助信息 实例 杀死所有同名进程 1killall vi"},{"title":"Linux 命令 「dnf」","date":"2018-06-13T03:26:19.000Z","updated":"2018-11-22T03:13:31.000Z","comments":true,"path":"backup/2018-06-13-Linux-cmd-dnf.html","permalink":"http://blog.caoxl.com/backup/2018-06-13-Linux-cmd-dnf.html","excerpt":"DNF D:掉你线 N:拿你钱 F:封你号, 你们就是那群穿着西装的死肥宅? 额, 拉回主题~~~ DNF是新一代的rpm软件包管理器。他首先出现在 Fedora 18 这个发行版中。而最近，它取代了yum，正式成为 Fedora 22 的包管理器。DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。DNF使用 RPM, libsolv 和 hawkey 库进行包管理操作。","text":"DNF D:掉你线 N:拿你钱 F:封你号, 你们就是那群穿着西装的死肥宅? 额, 拉回主题~~~ DNF是新一代的rpm软件包管理器。他首先出现在 Fedora 18 这个发行版中。而最近，它取代了yum，正式成为 Fedora 22 的包管理器。DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。DNF使用 RPM, libsolv 和 hawkey 库进行包管理操作。 安装 DNFDNF 并未默认安装在 RHEL 或 CentOS 7系统中，但是 Fedora 22 已经默认使用 DNF . 查看系统版本: cat /etc/redhat-release 为了安装 DNF ，您必须先安装并启用 epel-release 依赖。 1234yum install epel-release// 或yum install epel-release -y 使用 epel-release 依赖中的 YUM 命令来安装 DNF 包。在系统中执行以下命令： 1yum install dnf No package dnf available. ?1234wget http://springdale.math.ias.edu/data/puias/unsupported/7/x86_64/dnf-conf-0.6.4-2.sdl7.noarch.rpmwget http://springdale.math.ias.edu/data/puias/unsupported/7/x86_64//dnf-0.6.4-2.sdl7.noarch.rpmwget http://springdale.math.ias.edu/data/puias/unsupported/7/x86_64/python-dnf-0.6.4-2.sdl7.noarch.rpmyum install python-dnf-0.6.4-2.sdl7.noarch.rpm dnf-0.6.4-2.sdl7.noarch.rpm dnf-conf-0.6.4-2.sdl7.noarch.rpm 实例 查看DNF包管理器版本 1dnf --version/-v 查看系统中可用的DNF软件库 1dnf repolist 查看系统中可用和不可用的所有DNF软件库 1dnf repolist all 列出所有RPM包 1dnf list 列出所有安装了的RPM包 1dnf list installed 列出所有可供安装的RPM包 1dnf list avaiable 搜索软件库的RPM包 1dnf search nano // 软件的部分名称 查看某一文件的提供者 1dnf provides /bin/bash 查看软件包详情 1dnf info nano 安装软件包 1dnf install nano 升级软件包 1dnf update system 检查系统软件包的更新 1dnf check-update 升级所有系统软件包 1234dnf update或dnf upgrade 删除软件包 1234dnf remove nano或dnf erase nano 删除无用孤立的软件包 1dnf autoremove 删除缓存的无用软件包 1dnf clean all 获取有关某条命令的使用帮助 1dnf help clean 查看所有的dnf命令及其用途 1dnf help 查看dnf命令的执行历史 1dnf history 查看所有的软件包组 1dnf grouplist 安装一个软件包组 1dnf groupinstall \"Educational Software\" 升级一个软件包组中的软件包 1dnf groupupdate \"Educational Software\" 删除一个软件包组 1dnf groupremove \"Educational Software\" 从特定的软件包库安装特定的软件 1dnf –enablerepo=epel install phpmyadmin 更新软件包到最新的稳定发行版 1dnf distro-sync 重新安装特定软件包 1dnf reinstall nano 回滚某个特定软件的版本 12dnf downgrade acpid// 该命令用于降低特定软件包的版本 样例输出： 1234[root@izj6c6djex81rijczh0t8yz ~]# dnf downgrade acpidUsing metadata from Wed Jun 13 11:36:20 2018No match for available package: acpid-2.0.19-9.el7.x86_64Error: Nothing to do. 原作者注：在执行这条命令的时候， DNF 并没有按照我期望的那样降级指定的软件（“acpid”）。该问题已经上报。 总结DNF 包管理器作为 YUM 包管理器的升级替代品，它能自动完成更多的操作。但在我看来，正因如此，所以 DNF 包管理器不会太受那些经验老道的 Linux 系统管理者的欢迎。举例如下： 在 DNF 中没有 –skip-broken 命令，并且没有替代命令供选择。 在 DNF 中没有判断哪个包提供了指定依赖的 resolvedep 命令。 在 DNF 中没有用来列出某个软件依赖包的 deplist 命令。 当你在 DNF 中排除了某个软件库，那么该操作将会影响到你之后所有的操作，不像在 YUM 下那样，你的排除操作只会咋升级和安装软件时才起作用。"},{"title":"Linux 命令 「vi」","date":"2018-06-14T05:55:26.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-14-Linux-cmd-vi-vim.html","permalink":"http://blog.caoxl.com/backup/2018-06-14-Linux-cmd-vi-vim.html","excerpt":"vi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。","text":"vi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。Linux中的vi编辑器叫vim，它是vi的增强版（vi Improved），与vi编辑器完全兼容，而且实现了很多增强功能。 内置命令 Ctrl+u: 向文件首翻半屏 Ctrl+d: 向文件尾翻半屏 Ctrl+f: 向文件尾翻一屏 Ctrl+b: 向文件首翻一屏 ESC: 从编辑模式下切换到命令模式 ZZ: 命令模式下保存当前文件所做的修改后退出vi :行号: 光标跳转到指定货行的行首 :$: 从光标跳转到最后一行的行首 x或X: 删除一个字符,x删除光标后的,而X删除光标前的 D: 删除从当前光标到光标所在行尾的全部字符 dd: 删除光标行正行内容 ndd: 删除当前行及其后n-1行 nyy: 将当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字； p: 粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方 P: 粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方 /字符串: 文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示 ?name: 文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示 a，bs/F/T: 替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作 a: 在当前字符后添加文本 A: 在行末添加文本 i: 在当前字符前插入文本 I: 在行首插入文本 o: 在当前行后面插入一空行 O: 在当前行前面插入一空行 :wq: 存盘退出 :w: 存盘 :w!: 强制退出 :q: 退出vi操作 :q!: 强制退出vi操作 :e文件名: 打开并编辑指定名称的文件 :n: 如果同时打开多个文件，则继续编辑下一个文件 :f: 用于显示当前的文件名、光标所在行的行号以及显示比例 :set nu: 显示行号 :set nonu: 不显示行号 常用的就那么几个~~"},{"title":"Linux 命令 「telnet」","date":"2018-06-15T09:42:17.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-15-Linux-cmd-telnet.html","permalink":"http://blog.caoxl.com/backup/2018-06-15-Linux-cmd-telnet.html","excerpt":"telnet命令用于登录远程主机，对远程主机进行管理","text":"telnet命令用于登录远程主机，对远程主机进行管理 telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了 语法1telnet (选项)(参数) 安装1yum install telnet 选项 -8: 允许使用8位字符资料,包括输入与输出 -a: 尝试自动登入远端系统 -b&lt;主机别名&gt;: 使用别名指定远端主机名称 -c: 不读取用户专属目录里面的.telnetrc文件 -d: 启动排错模式 -e&lt;脱离字符&gt;: 设置脱离字符 -E: 滤除脱离字符 -f: 此参数的效果和指定”-F”参数相同 -K: 不自动登入远端主机； -l: 指定要登入远端主机的用户名称 -L: 允许输出8位字符资料 -n: 指定文件记录相关信息 -r: 使用类似rlogin指令的用户界面 -S&lt;服务类型&gt;: 设置telnet连接所需的ip TOS信息 -x: 假设主机有支出数据加密的功能, 就使用它 -X&lt;认证形态&gt;: 关闭指定的认证形态。 参数 远程主机: 指定要登录进行管理的远程主机 端口: 指定TELNET协议使用的端口号 实例1telnet 127.0.0.1 9501"},{"title":"Linux 命令 「curl」","date":"2018-06-11T02:10:58.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-11-Linux-cmd-curl.html","permalink":"http://blog.caoxl.com/backup/2018-06-11-Linux-cmd-curl.html","excerpt":"curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。","text":"curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。 常见参数 -A/--user-agent &lt;string&gt; 设置用户代理发送给服务器 -b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置 -c/--cookie-jar &lt;file&gt; 操作结束后吧cookie写入到这个文件中 -C/--continue-at &lt;offset&gt; 断点续转 -D/--dump-header &lt;file&gt; 把header信息写入该文件中 -e/--referer 来源地址 -f/--fail 连接失败时不显示http错误 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中,保留远程文件的文件名 -r/--range &lt;range&gt; 检索来自HTTP/1.1或FTP服务器字节范围 -s/--silent 静音模式,不输出任何东西 -T/--upload-file &lt;file&gt; 上传文件 -u/--user &lt;user[:password]&gt; 设置服务器的用户和密码 -w/--write-out [format] 什么输出完成后 -x/--proxy &lt;host [:port]&gt; 在给定的端口上使用HTTP代理 -#/--progress-bar 进度条显示当前的传送状态 常见用例基本用法1curl http://www.caoxl.com 自定义header1curl -H \"Referer:www.caoxl.com -H \"User-agent: Custom-User-Agent\" http://caxl.com 发送POST/GET 请求 POST 1curl -d \"username=caoxl&amp;passwd=123456\" -X POST http://caoxl.com/login 在使用 -d 的情况下，如果省略 -X，则默认为 POST 方式： 1curl -d \"username=caoxl&amp;passwd=123456\" http://caoxl.com/login GET 1234curl -d \"somedata\" -X GET http://caoxl.com/login// 或 -Gcurl -d \"somedata\" -G http://caoxl.com/api 显示HTTP头1234curl -I http://www.caoxl.com// 同时显示HTTP头和文件内容,使用 `-i`选项curl -i http://www.caoxl.com 保存访问的网页 使用linux的重定向功能保存 1curl http://caoxl.com &gt;&gt; caoxl.html 可以使用curl的内置option:-o(小写)保存网页 1curl -o caoxl2.html http://caoxl.com 可以使用curl的内置option:-O(大写)保存网页中的文件 要注意这里后面的url要具体到某个文件，不然抓不下来 1curl -O http://caoxl.com/index.html 测试网页返回值123curl -o /dev/null -s -w %&#123;http_code&#125; www.caoxl.com// 返回HTTP状态码 在脚本中，这是很常见的测试网站是否正常的用法 指定proxy服务器以及其端口很多时候上网需要用到代理服务器(比如是使用代理服务器上网或者因为使用curl别人网站而被别人屏蔽IP地址的时候)，幸运的是curl通过使用内置option：-x来支持设置代理 1curl -x 192.169.100.100:1080 http://caoxl.com 跟随链接重定向(HTTPS)1curl -L http://caoxl.com cookie有些网站是使用cookie来记录session信息。对于chrome这样的浏览器，可以轻易处理cookie信息，但在curl中只要增加相关参数也是可以很容易的处理cookie 保存http的response里面的cookie信息。内置option:-c（小写） 12curl -c cookiec.txt http://caoxl.com// 执行后cookie信息就被存到了cookiec.txt里面了, 无cookie则不会生成文件 保存http的response里面的header信息。内置option: -D 1curl -D cookieD.txt http://caoxl.com 使用cookie 很多网站都是通过监视你的cookie信息来判断你是否按规矩访问他们的网站的，因此我们需要使用保存的cookie信息。内置option: -b 1curl -b cookieb.txt http://caoxl.com 模仿浏览器有些网站需要使用特定的浏览器去访问他们，有些还需要使用某些特定的版本。curl内置option:-A可以让我们指定浏览器去访问网站 1curl -A \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.0)\" http://caoxl.com 这样服务器端就会认为是使用IE8.0去访问的 伪造referer（盗链）很多服务器会检查http访问的referer从而来控制访问。比如：你是先访问首页，然后再访问首页中的邮箱页面，这里访问邮箱的referer地址就是访问首页成功后的页面地址，如果服务器发现对邮箱页面访问的referer地址不是首页的地址，就断定那是个盗连了curl中内置option：-e可以让我们设定referer 1curl -e \"www.caoxl.com\" http://blog.caoxl.com 这样就会让服务器以为你是从www.caoxl.com点击某个链接过来的 下载文件 利用curl下载文件。 使用内置option：-o(小写) 1curl -o MasterSlave.jpg http://www.caoxl.com 使用内置option：-O(大写) 12curl -O http://www.caoxl.com/MasterSlave.jpg// 这样就会以服务器上的名称保存文件到本地 循环下载 有时候下载图片可以能是前面的部分名称是一样的，就最后的尾椎名不一样 1curl -O http://caoxl.com/MasterSlave[1-5].jpg 这样就会把MasterSlave1,MasterSlave2,MasterSlave3,MasterSlave4,MasterSlave5全部保存 下载重命名 1curl -O http://www.caoxl.com/&#123;newname,newname2&#125;/MasterSlave[1-5].jpg 这样在newname/MasterSlave.jpg的文件下载下来就会变成newname_MasterSlave1.jpg,其他文件依此类推，从而有效的避免了文件被覆盖 1curl -o #1_#2.jpg http://caoxl.com/&#123;newname,newname2&#125;/MasterSlave[1-5].jpg 分块下载 有时候下载的东西会比较大，这个时候我们可以分段下载。使用内置option：-r 1234curl -r 0-100 -o part1.jpg http://www.caoxl.com/MasterSlave.jpgcurl -r 1-200 -o part2.jpg http://www.caoxl.com/MasterSlave.jpgcurl -r 200- -o part3.jpg http://www.caoxl.com/MasterSlave.jpgcat part* &gt; NasterSlave.jpg 通过ftp下载文件 curl可以通过ftp下载文件, curl提供两种从ftp中下载的语法 1234curl -O -u 用户名:密码 ftp://www.caoxl.com/test.jpg// 或curl -O ftp://用户名:密码@www.caoxl.com/test.jpg 显示下载进度条 1curl -# -O http://www.caoxl.com/test.jpg 不会显示下载的进度信息 1curl -s -O http://www.caoxl.com/test.jpg 同时下载多个文件 1234curl -O http://www.caoxl/test1.jpg -O http://www.caoxl.com/test2.jpg// 或curl -o test.html http://caoxl.com/page/1/ -o http://caoxl.com/page/2/ 断点续传在windows中，我们可以使用迅雷这样的软件进行断点续传。curl可以通过内置option:-C同样可以达到相同的效果如果在下载test.jpg的过程中突然掉线了，可以使用以下的方式续传 1curl -C -O http://www.caoxl.com/test.jpg 上传文件curl不仅仅可以下载文件，还可以上传文件。通过内置option:-T来实现 1curl -T test.jpg -u 用户名:密码 ftp://www.caoxl.com/ 这样就向ftp服务器上传了文件test.jpg 显示抓取错误1curl -f http://caoxl.com/error 其他参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192-a/--append 上传文件时，附加到目标文件--anyauth 可以使用“任何”身份验证方法--basic 使用HTTP基本验证-B/--use-ascii 使用ASCII文本传输-d/--data &lt;data&gt; HTTP POST方式传送数据--data-ascii &lt;data&gt; 以ascii的方式post数据--data-binary &lt;data&gt; 以二进制的方式post数据--negotiate 使用HTTP身份验证--digest 使用数字身份验证--disable-eprt 禁止使用EPRT或LPRT--disable-epsv 禁止使用EPSV--egd-file &lt;file&gt; 为随机数据(SSL)设置EGD socket路径--tcp-nodelay 使用TCP_NODELAY选项-E/--cert &lt;cert[:passwd]&gt; 客户端证书文件和密码 (SSL)--cert-type &lt;type&gt; 证书文件类型 (DER/PEM/ENG) (SSL)--key &lt;key&gt; 私钥文件名 (SSL)--key-type &lt;type&gt; 私钥文件类型 (DER/PEM/ENG) (SSL)--pass &lt;pass&gt; 私钥密码 (SSL)--engine &lt;eng&gt; 加密引擎使用 (SSL). \"--engine list\" for list--cacert &lt;file&gt; CA证书 (SSL)--capath &lt;directory&gt; CA目 (made using c_rehash) to verify peer against (SSL)--ciphers &lt;list&gt; SSL密码--compressed 要求返回是压缩的形势 (using deflate or gzip)--connect-timeout &lt;seconds&gt; 设置最大请求时间--create-dirs 建立本地目录的目录层次结构--crlf 上传是把LF转变成CRLF--ftp-create-dirs 如果远程目录不存在，创建远程目录--ftp-method [multicwd/nocwd/singlecwd] 控制CWD的使用--ftp-pasv 使用 PASV/EPSV 代替端口--ftp-skip-pasv-ip 使用PASV的时候,忽略该IP地址--ftp-ssl 尝试用 SSL/TLS 来进行ftp数据传输--ftp-ssl-reqd 要求用 SSL/TLS 来进行ftp数据传输-F/--form &lt;name=content&gt; 模拟http表单提交数据-form-string &lt;name=string&gt; 模拟http表单提交数据-g/--globoff 禁用网址序列和范围使用&#123;&#125;和[]-G/--get 以get的方式来发送数据-h/--help 帮助-H/--header &lt;line&gt; 自定义头信息传递给服务器--ignore-content-length 忽略的HTTP头信息的长度-i/--include 输出时包括protocol头信息-I/--head 只显示文档信息-j/--junk-session-cookies 读取文件时忽略session cookie--interface &lt;interface&gt; 使用指定网络接口/地址--krb4 &lt;level&gt; 使用指定安全级别的krb4-k/--insecure 允许不使用证书到SSL站点-K/--config 指定的配置文件读取-l/--list-only 列出ftp目录下的文件名称--limit-rate &lt;rate&gt; 设置传输速度--local-port&lt;NUM&gt; 强制使用本地端口号-m/--max-time &lt;seconds&gt; 设置最大传输时间--max-redirs &lt;num&gt; 设置最大读取的目录数--max-filesize &lt;bytes&gt; 设置最大下载的文件总量-M/--manual 显示全手动-n/--netrc 从netrc文件中读取用户名和密码--netrc-optional 使用 .netrc 或者 URL来覆盖-n--ntlm 使用 HTTP NTLM 身份验证-N/--no-buffer 禁用缓冲输出-p/--proxytunnel 使用HTTP代理--proxy-anyauth 选择任一代理身份验证方法--proxy-basic 在代理上使用基本身份验证--proxy-digest 在代理上使用数字身份验证--proxy-ntlm 在代理上使用ntlm身份验证-P/--ftp-port &lt;address&gt; 使用端口地址，而不是使用PASV-Q/--quote &lt;cmd&gt; 文件传输前，发送命令到服务器--range-file 读取（SSL）的随机文件-R/--remote-time 在本地生成文件时，保留远程文件时间--retry &lt;num&gt; 传输出现问题时，重试的次数--retry-delay &lt;seconds&gt; 传输出现问题时，设置重试间隔时间--retry-max-time &lt;seconds&gt; 传输出现问题时，设置最大重试时间-S/--show-error 显示错误--socks4 &lt;host[:port]&gt; 用socks4代理给定主机和端口--socks5 &lt;host[:port]&gt; 用socks5代理给定主机和端口-t/--telnet-option &lt;OPT=val&gt; Telnet选项设置--trace &lt;file&gt; 对指定文件进行debug--trace-ascii &lt;file&gt; Like --跟踪但没有hex输出--trace-time 跟踪/详细输出时，添加时间戳--url &lt;URL&gt; Spet URL to work with-U/--proxy-user &lt;user[:password]&gt; 设置代理用户名和密码-V/--version 显示版本信息-X/--request &lt;command&gt; 指定什么命令-y/--speed-time 放弃限速所要的时间。默认为30-Y/--speed-limit 停止传输速度的限制，速度时间'秒-z/--time-cond 传送时间设置-0/--http1.0 使用HTTP 1.0-1/--tlsv1 使用TLSv1（SSL）-2/--sslv2 使用SSLv2的（SSL）-3/--sslv3 使用的SSLv3（SSL）--3p-quote like -Q for the source URL for 3rd party transfer--3p-url 使用url，进行第三方传送--3p-user 使用用户名和密码，进行第三方传送-4/--ipv4 使用IP4-6/--ipv6 使用IP6 参考 Linux curl命令详解"},{"title":"Linux 命令 「iotop」","date":"2018-06-25T01:47:31.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-25-Linux-cmd-iotop.html","permalink":"http://blog.caoxl.com/backup/2018-06-25-Linux-cmd-iotop.html","excerpt":"iotop命令是一个用来监视磁盘I/O使用状况的top类工具。iotop具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。","text":"iotop命令是一个用来监视磁盘I/O使用状况的top类工具。iotop具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。 安装Ubuntu1apt-get install iotop Centos1yum install iotop 编译安装1234wget http://guichaz.free.fr/iotop/files/iotop-0.4.4.tar.gz tar zxf iotop-0.4.4.tar.gz python setup.py build python setup.py install 命令/参数 -o: 只显示有io操作的进程 -b: 批量显示,无交互,主要用作记录到文件 -n NUM: 显示NUM次,主要用于非交互模式 -d SEC: 间隔SEC秒显示一次 -p PID: 监控的进程pid -u USER: 监控的进程用户 iotop常用快捷键: 左右箭头：改变排序方式，默认是按IO排序。 r：改变排序顺序。 o：只显示有IO输出的进程。 p：进程/线程的显示方式的切换。 a：显示累积使用量。 q：退出。 实例123456789101112131415161718192021Total DISK READ : 0.00 B/s | Total DISK WRITE : 0.00 B/sActual DISK READ: 0.00 B/s | Actual DISK WRITE: 0.00 B/s TID PRIO USER DISK READ DISK WRITE SWAPIN IO&gt; COMMAND 1 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % systemd --system --deserialize 21 2 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [kthreadd] 3 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [ksoftirqd/0]10826 be/4 mysql 0.00 B/s 0.00 B/s 0.00 % 0.00 % mysqld --basedir=/usr/lo~mp/mysql.sock --port=3306 5 be/0 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [kworker/0:0H] 7 rt/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [migration/0] 8 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [rcu_bh] 9 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [rcu_sched] 10 rt/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [watchdog/0] 12 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [kdevtmpfs] 13 be/0 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [netns] 14 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [khungtaskd] 15 be/0 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [writeback] 16 be/0 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [kintegrityd] 17 be/0 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [bioset] 18 be/0 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [kblockd] 19 be/0 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [md] 25 be/4 root 0.00 B/s 0.00 B/s 0.00 % 0.00 % [kswapd0]"},{"title":"Linux 命令 「netcat」","date":"2018-06-25T01:14:21.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-25-Linux-cmd-netcat.html","permalink":"http://blog.caoxl.com/backup/2018-06-25-Linux-cmd-netcat.html","excerpt":"nc命令是netcat命令的简称，都是用来设置路由器。","text":"nc命令是netcat命令的简称，都是用来设置路由器。 语法1nc/netcat (选项)(参数) 选项 -g&lt;网关&gt;: 设置路由器跃程通信网关, 最多设置8个 -G&lt;指向器数目&gt;: 设置来源路由指向器, 其数值为4的倍数 -h: 在线帮助 -i&lt;延迟秒速&gt;: 设置时间间隔,以便传送信息以及扫描通信端口 -l: 使用监听模式,监控传入的资料 -n: 直接使用ip地址,而不通过域名服务器 -o&lt;输出文件&gt;: 指定文件名称,把往来传输的数据以16进制字妈倾倒成该文件保存 -p&lt;通信端口&gt;: 设置本地主机使用的通信端口 -r: 指定源端口和目的端口都进行随机的选择 -s&lt;来源位址&gt;: 设置本地主机送出数据包的IP地址 -u: 使用UDP传输协议 -v: 显示指令执行过程 -w&lt;超时秒数&gt;: 设置等待连线的时间 -z: 使用0输入/输出模式, 只在扫描通信端口时使用 参数 主机: 指定主机的IP地址主机名称 端口号: 可以是单个整数或者是一个范围 实例 远程拷贝文件 从server1拷贝文件到server2上。需要先在server2上，用nc激活监听。 server2上运行： 1nc -lp 1234 &gt; install.log server1上运行： 123ll install.lognc -w 1 192.168.228.222 1234 &lt; install.log 克隆硬盘或分区 1nc -l -p 1234 | dd of=/dev/sda server1上执行传输，即可完成从server1克隆sda硬盘到server2的任务： 1dd if=/dev/sda | nc 192.168.228.222 1234 端口扫描 1nc -v -w 1 192.168.228.222 -z 1-1000 保存Web页面 12while true: do nc -l -p 80 -q 1 &lt; somepage.html 聊天 1nc -lp 1234"},{"title":"Linux 命令 「chgrp」","date":"2018-06-26T09:56:30.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-26-Linux-cmd-chgrp.html","permalink":"http://blog.caoxl.com/backup/2018-06-26-Linux-cmd-chgrp.html","excerpt":"chgrp命令用来改变文件或目录所属的用户组。","text":"chgrp命令用来改变文件或目录所属的用户组。 语法1chgrp (选项)(参数) 选项 -c/--changes: 效果类似“-v”参数，但仅汇报更改的部分 -f/--quiet/--silent: 不显示错误信息 -h/--no-dereference: 只对符号连接的文件作修改，而不是该其他任何相关文件 -R/--recursive: 递归处理,将指令目录下了的所有文件以及子目录一并处理 -v/--verbose: 显示指令执行过程 -reference=&lt;参考文件或目录&gt;: 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同 参数 组: 指定新工作名称 文件: 指定要改变所属组的文件列表,多个文件或目录直接使用空格隔开 实例将/usr/test及其子目录下的所有文件的用户组改为caoxl 1chgrp -R caoxl /usr/test"},{"title":"Linux 命令 「dump」","date":"2018-06-27T02:24:43.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-27-Linux-cmd-dump.html","permalink":"http://blog.caoxl.com/backup/2018-06-27-Linux-cmd-dump.html","excerpt":"dump命令用于备份ext2或者ext3文件系统。可将目录或整个文件系统备份至指定的设备，或备份成一个大文件。","text":"dump命令用于备份ext2或者ext3文件系统。可将目录或整个文件系统备份至指定的设备，或备份成一个大文件。 语法选项 -0123456789: 备份的层级 -b&lt;区块大小&gt;: 指定区块的大小,单位为KB -B&lt;区块数目&gt;: 指定备份卷册的区块数目 -c: 修改备份磁带预设的密度和容量 -d&lt;密度&gt;: 设置磁带的密度,单位为BPI -f&lt;设备名称&gt;: 指定备份设备 -h&lt;层级&gt;: 当备份层级等于或大于指定的层级时,将不备份用户表示为nodump的文件 -n: 当备份工作需要管理员介入时,向所有operator群组的使用者发出通知 -s&lt;磁带长度&gt;: 备份磁带的长度,单位为英尺 -T&lt;日期&gt;: 指定备份的时间和日期 -u: 备份完毕后,在/etc/dumpdates中记录备份的文件系统,层级,日期与时间等 -w: 与-W类似, 单仅需要备份的文件 -W: 显示需要备份的文件及其最后一次备份的层级,时间,日期 参数 备份源: 指定要备份的文件、目录或者文件系统 实例将/home目录所有内容备份到/tmp/homeback.bak文件中，备份层级为0并在/etc/dumpdates中记录相关信息： 1dump -0u -f /tmp/homeback.bak /home 将/home目录所有内容备份到/tmp/homeback.bak文件中，备份层级为1（只备份上次使用层次0备份后发生过改变的数据）并在/etc/dumpdates中记录相关信息： 1dump -1u -f /tmp/homeback.bak /home 通过dump命令的备份层级，可实现完整+增量备份、完整+差异备份，在配合crontab可以实现无人值守备份。"},{"title":"Linux 命令 「chmod」","date":"2018-06-26T09:08:12.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-26-Linux-cmd-chmod.html","permalink":"http://blog.caoxl.com/backup/2018-06-26-Linux-cmd-chmod.html","excerpt":"chmod命令用来变更文件或目录的权限。","text":"chmod命令用来变更文件或目录的权限。 在UNIX系统家族里，文件或目录权限的控制分别以读取、写入、执行3种一般权限来区分，另有3种特殊权限可供运用。用户可以使用chmod指令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。 权限范围 u User, 即文件或目录的拥有者 g Group, 即文件或目录的所属群组 o Other, 除了文件或目录拥有者或所属群组之外,其他用户都属于这个范围 a All, 即全部的用户, 包含拥有者,所属群组以及其他用户 r 读取权限, 数字代号为4 w 写入权限, 数字代号为2 x 执行或切换权限, 数字代号为1 - 不具任何权限, 数字代号为0 s 特殊功能说明: 变更文件或目录的权限 命令参数语法 chmod (选项)(参数) 选项 -c/--changes: 效果类似-v参数,但仅汇报更改部分 -f/--quiet/--silent: 不显示错误信息 -R/--recursive: 递归处理,将指令目录下的所有文件以及子目录一并处理 -v/--verbose: 显示指令执行过程 &lt;权限范围&gt;+&lt;权限设置&gt;: 开启权限范围的文件或目录的该选项权限设置 &lt;权限范围&gt;-&lt;权限设置&gt;: 关闭权限范围的文件或目录的该选项权限设置 &lt;权限范围&gt;=&lt;权限设置&gt;: 指定权限范围的文件或目录的该选项权限设置 参数 权限模式: 指定文件的权限模式 文件: 要改变权限的文件 实例123// 第一个字符为 \"d\" 代表目录drwxr-xr-x 2 root root 4096 Jun 26 17:30 Test-rw-r--r-- 1 root root 18 Jun 13 10:47 test.php r = 读取属性 // 值=4 w = 写入属性 // 值=2 x = 执行属性 // 值=1 1234chmod u+x,g+w file1 //为文件file1设置自己可以执行,组员可以写入的权限chmod u=rwx,g=rw,o=r file1 // 设置用户有全部权限,组员没有执行权限,其他只有读权限chmod 764 file1 // 7=4+2+1=rwx 6=4+2+0=rw- 4=4+0+0=r--chmod a+x file1 //对文件file1的u,g,o,都设置可执行属性 文件的属主和属组设置 1chown user:group file1 //把文件file1给user,添加到group组"},{"title":"Linux 命令 「chown」","date":"2018-06-26T09:45:46.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-26-Linux-cmd-chown.html","permalink":"http://blog.caoxl.com/backup/2018-06-26-Linux-cmd-chown.html","excerpt":"chown命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组","text":"chown命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组 用户可以是用户或者是用户D，用户组可以是组名或组id。文件名可以使由空格分开的文件列表，在文件名中可以包含通配符。 只有文件主和超级用户才可以使用该命令 语法1chown (选项) (参数) 命令选项 -c/--changes: 效果类似-v参数,但仅汇报更改部分 -f/--quiet/--silent: 不显示错误信息 -R/--recursive: 递归处理,将指令目录下的所有文件以及子目录一并处理 -v/--verbose: 显示指令执行过程 --dereference: 效果和-h参数相同 --help: 在线帮助 --reference=&lt;参考文件或目录&gt;: 把指定文件或目录的拥有者与所属群组全部设成和参考文件或目录的拥有者与所属群组相同； --version: 显示版本信息 参数 用户:组: 指定所有者和所属工作组,当省略”:”,仅改变文件所有者 文件: 指定要改变所有者和工作组的文件列表, 支持多个文件和目标,支持shell通配符 实例将目录/usr/test及其下面的所有文件、子目录的文件主改成 caoxl: 1chown -R caoxl /usr/test"},{"title":"Linux 命令 「halt」","date":"2018-06-28T06:25:30.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-28-Linux-cmd-halt.html","permalink":"http://blog.caoxl.com/backup/2018-06-28-Linux-cmd-halt.html","excerpt":"halt命令用来关闭正在运行的Linux操作系统。halt命令会先检测系统的runlevel，若runlevel为0或6，则关闭系统，否则即调用shutdown来关闭系统。","text":"halt命令用来关闭正在运行的Linux操作系统。halt命令会先检测系统的runlevel，若runlevel为0或6，则关闭系统，否则即调用shutdown来关闭系统。 语法1halt (选项) 选项 -d: 不要在wtmp中记录 -f: 不论目前的runlevel为何, 不调用shudown即强制关闭系统 -i: 在halt之前,关闭全部的网络界面 -n: halt前,不用先执行sync -p: halt之后,执行poweroff -w: 仅在wtmp中记录,而不实际结束系统 实例12halt -p // 关闭系统后关闭电源halt -d // 关闭系统,但不留下记录"},{"title":"Linux 命令 「restore」","date":"2018-06-27T02:42:15.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-27-Linux-cmd-restore.html","permalink":"http://blog.caoxl.com/backup/2018-06-27-Linux-cmd-restore.html","excerpt":"restore命令是dump命令的逆过程，用于还原dump命令生成的备份文件","text":"restore命令是dump命令的逆过程，用于还原dump命令生成的备份文件 命令选项 -b&lt;区块大小&gt;: 设置区块大小,单位为Byte -c: 不检查dump操作的备份格式,仅准许读取使用旧格式的备份文件 -C: 使用对比模式,将备份的文件与现行的文件相互对比 -D&lt;文件系统&gt;: 允许用户指定文件系统的名称 -f&lt;备份文件&gt;: 从指定的文件中读取备份数据,进行还原操作 -h: 仅解除目录而不包括与该目录相关的所有文件 -i: 使用互动模式, 在进行还原操作时,restore指令将依序询问用户 -m: 解开符合指定的inode编号的文件或目录而非用文件名称指定 -r: 进行还原操作 -R: 全面还原文件系统时, 检查应从何处开始进行 -s&lt;文件编号&gt;: 当备份数据超过一卷磁带时,用户可以指定备份文件的编号 -t: 指定文件名称, 若该文件已存在备份文件中, 则列出他们的名称 -v: 显示指令执行过程 -x: 设置文件名称,且从指定的存储媒体里读入它们，若该文件已存在在备份文件中，则将其还原到文件系统内； -y: 不询问任何问题, 一律以同意回答并继续执行指令 实例 用restore命令来恢复备份： 12345// 备份dump -9 -u -f /dev/file1 /home/back/// 还原restore rf /dev/file1 /home/back/ 用restore命令来查看备份文件里的文件列表： 1restore ft /dev/file1"},{"title":"Linux 命令 「poweroff」","date":"2018-06-28T07:12:58.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-28-Linux-cmd-poweroff.html","permalink":"http://blog.caoxl.com/backup/2018-06-28-Linux-cmd-poweroff.html","excerpt":"poweroff命令用来关闭计算机操作系统并且切断系统电源。","text":"poweroff命令用来关闭计算机操作系统并且切断系统电源。 语法1poweroff (选项) 选项 -n: 关闭操作系统时不执行sync操作 -w: 不真正关闭操作系统,仅在日志文件/var/log/wtmp中 -d: 关闭操作系统时, 不将操作写入日志/var/log/wtmp中添加相应的记录 -f: 强制关闭操作系统 -i: 关闭操作系统之前关闭所有的网络接口 -h: 关闭操作系统之前将系统中所有的硬件设置为备用模式 实例如果确认系统中已经没有用户存在且所有数据都已保存，需要立即关闭系统，可以使用poweroff命令。 1poweroff"},{"title":"Linux 命令 「reboot」","date":"2018-06-28T06:34:33.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-28-Linux-cmd-reboot.html","permalink":"http://blog.caoxl.com/backup/2018-06-28-Linux-cmd-reboot.html","excerpt":"reboot命令用来重新启动正在运行的Linux操作系统。","text":"reboot命令用来重新启动正在运行的Linux操作系统。 语法1reboot (选项) 选项 -d: 重新开机时不把数据写入记录文件/var/tmp/wtmp/.本参数具有-n`参数效果 -f: 强制重新开机,不调用shutdown指令的功能 -i: 在重开机之前,先关闭所有网络界面 -n: 重开机之前不检查师傅有未结束的程序 -w: 仅做测试,并不真正的将系统重新开机,只会把重开机的数据写入/var/log目录下的wtmp记录文件。 实例12reboot // 重开机reboot -w // 做个重开机的模拟"},{"title":"Linux 命令 「grep」","date":"2018-06-28T02:56:19.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-28-Linux-cmd-grep.html","permalink":"http://blog.caoxl.com/backup/2018-06-28-Linux-cmd-grep.html","excerpt":"grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。","text":"grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 命令参数 -a: 不要忽略二进制数据 -A&lt;显示列数&gt;: 除了显示符合范本样式的那一行之外,并显示该行之后的内容 -b: 除了显示符合范本样式的那一行之外,并显示该行之前的内容 -c: 计算符合范本样式的列数 -C&lt;显示列数&gt;或-&lt;显示列数&gt;: 除了显示符合范本样式的那一列之外,并显示该列之前后的内容 -d&lt;进行动作&gt;: 当指定要查找的是目录而非文件时,必须使用这项参数,否则grep命令将回报信息并停止动作 -e&lt;范本样式&gt;: 指定字符串作为查找文件内容的范本样式 -E: 将范本样式为延伸的普通表示法来使用,意味着使用能使用扩展正则表达式 -f&lt;范本文本&gt;: 指定范本文件, 其内容有一个或多个范本样式.让grep查找符合范本条件的文件内容，格式为每一列的范本样式。 -F: 将范本样式视为固定字符串的列表 -G: 将范本样式视为普通的表示法来使用。 -h: 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。 -H: 在显示符合范本样式的那一列之前，标示该列的文件名称。 -i: 忽略字符大小写的差别 -I: 列出文件内容符合指定的范本样式的文件名称 -L: 列出文件内容不符合指定的范本样式的名称 -n: 在显示符合范本样式的那一列之前，标示出该列的编号 -q: 不显示任何信息 -R/-r:此参数的效果的指定”-d recurse”参数相同 -s: 不显示错误信息 -v: 反转查找 -w: 只显示全字符合的列 -x: 只显示全列符合的列 -y: 此参数效果跟-i相同 -o: 只输出文件中匹配到的部分 常见用法 在文件中搜索一个单词，命令会返回一个包含“match_pattern”的文本行： 123456grep match_pattern file_name // match_pattern是要查询的内容grep \"match_pattern\" file_name// 例:[root@izj6c6djex81rijczh0t8yz test]# grep echo test.phpecho 1024; 在多个文件中查找 1grep \"match_pattern\" file_1 file_2 file_3 ... 输出除这个之外的所有行;使用-V选项 1grep -v \"match_pattern\" file_name 标记匹配颜色 --color=auto选项 1grep \"match_pattern\" filename --color=auto 使用正则表达式 -E选项 123grep -E \"[1-9]+\"或egrep \"[1-9]+\" 只输出文件中匹配到的部分-o选项 12345echo this is a test line. | grep -o -E \"[a-z]+\\.\"line.echo this is a test line. | egrep -o \"[a-z]+\\.\"line. 统计文件或者文本中包含匹配字符串的行数 -c 选项 1grep -c \"text\" file_name 输出包含匹配字符串的行数 -n 选项 123456grep \"text\" -n file_name# 或cat file_name | grep \"text\" -n# 多个文件grep \"text\" -n file_1 file_2 搜索多个文件并查找匹配文本在哪些文件中 1grep -l \"text\" file1 file2 file3.. 递归搜索文件 在多级目录中对文本进行递归搜索 12grep \"text\" . -r -n# . 表示当前目录 忽略匹配样式中的字符大小写 1echo \"hello world\" | grep -i \"HELLO\" 选项 -e 自动多个匹配样式 1234echo this is a text line | grep -e \"is\" -e \"line\" -o# 也可以用-f选项匹配多个样式echo aaa bbb ccc ddd eee | grep -f catfile -o"},{"title":"Linux 命令 「shutdown」","date":"2018-06-28T06:42:31.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-28-Linux-cmd-shutdown.html","permalink":"http://blog.caoxl.com/backup/2018-06-28-Linux-cmd-shutdown.html","excerpt":"shutdown命令用来系统关机命令。shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。","text":"shutdown命令用来系统关机命令。shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。 语法1shutdown (选项)(参数) 选项 -c: 当执行一个定时指令时,只要按+键就可以中断关机的命令 -f: 重新启动不执行fsck -F: 重新启动时执行fsck -h: 将系统关机 -k: 只是送出信息给所有用户,但不会实际关机 -n: 不调用init程序进行关机,而由shutdown自己进行 -r: shutdown之后重新启动 -t&lt;秒数&gt;: 送出警告信息和删除信息之间要延迟多少秒 参数 [时间]: 设置多久时间后执行shutdown指令 [警告信息]: 要传递给所有登入用户的信息 实例 指定现在立即关机 1shutdown -h now 指定5分钟后关机, 同时发出警告信息给登入用户 1shutdown +5 \"System will shutdown after 5 minutes\""},{"title":"Linux 命令 「fsck」","date":"2018-06-29T01:51:00.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-29-Linux-cmd-fsck.html","permalink":"http://blog.caoxl.com/backup/2018-06-29-Linux-cmd-fsck.html","excerpt":"fsck命令被用于检查并且试图修复文件系统中的错误。当文件系统发生错误四化，可用fsck指令尝试加以修复。","text":"fsck命令被用于检查并且试图修复文件系统中的错误。当文件系统发生错误四化，可用fsck指令尝试加以修复。 命令选项 -a: 自动修复文件系统, 不询问任何问题 -A: 依照/etc/fstab/匹配文件的内容,检查文件内所列的全部文件系统 -N: 不执行指令,仅列出实际执行惠进行的动作 -P: 当搭配-A参数使用时,则惠同时检查所有的文件系统 -r: 采用互动模式,在执行修复时询问问题,让用户得以确认并决定处理方式 -R: 当搭配-A参数使用时,则惠略过/目录的文件系统不予检查 -s: 依序执行检查作业,而非同时执行 -t&lt;文件系统类型&gt;: 指定要检查的文件系统类型 -T: 执行fsck指令时,不显示标题信息 -V: 显示指令执行过程 命令参数 文件系统: 指定要查看信息的文件系统 实例 linux的文件系统损坏会导致linux不正常关机，出错的时候如果系统告诉你是哪一块硬盘的分区有问题，比如是/dev/hda2，接着用如下的命令去对付它： 1fsck -y /dev/hda2 结束后使用reboot命令重启系统这样就好了！ 如果不知道时哪个地方出了问题，可以直接： 1fsck 在随后的多个确认对话框中输入:y 结束后同样使用reboot命令重启系统这样就好了！"},{"title":"Linux 命令 「uname」","date":"2018-06-28T06:07:19.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-28-Linux-cmd-uname.html","permalink":"http://blog.caoxl.com/backup/2018-06-28-Linux-cmd-uname.html","excerpt":"uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。","text":"uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 命令参数 -a/--all: 显示全部的信息 -m/--machine: 显示电脑类型 -n/-nodename: 显示在网络上的主机名称 -r/--release: 显示操作系统的发行编号 -s/--sysname: 显示操作系统名称 -v: 显示操作系统的版本 -p/--processor: 输出处理器类型或”unknown” -i/--operating-system: 输出操作系统名称 --help: 显示帮助 --version: 显示版本信息 实例 uname 12[root@izj6c6djex81rijczh0t8yz test]# unameLinux uname -a 12[root@izj6c6djex81rijczh0t8yz test]# uname -aLinux izj6c6djex81rijczh0t8yz 3.10.0-862.3.2.el7.x86_64 #1 SMP Mon May 21 23:36:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux uname -m 12[root@izj6c6djex81rijczh0t8yz test]# uname -mx86_64 uname -n 12[root@izj6c6djex81rijczh0t8yz test]# uname -nizj6c6djex81rijczh0t8yz uname -r 12[root@izj6c6djex81rijczh0t8yz test]# uname -r3.10.0-862.3.2.el7.x86_64 uname -s 12[root@izj6c6djex81rijczh0t8yz test]# uname -sLinux uname -v 12[root@izj6c6djex81rijczh0t8yz test]# uname -v#1 SMP Mon May 21 23:36:36 UTC 2018 uname -p 12[root@izj6c6djex81rijczh0t8yz test]# uname -px86_64 uname -i 12[root@izj6c6djex81rijczh0t8yz test]# uname -ix86_64 uname -o 12[root@izj6c6djex81rijczh0t8yz test]# uname -oGNU/Linux uname --version 12345678[root@izj6c6djex81rijczh0t8yz test]# uname --versionuname (GNU coreutils) 8.22Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Written by David MacKenzie."},{"title":"Linux 命令 「gcc」","date":"2018-07-02T01:14:35.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-02-Linux-cmd-gcc.html","permalink":"http://blog.caoxl.com/backup/2018-07-02-Linux-cmd-gcc.html","excerpt":"gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点","text":"gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点 选项 -o: 指定生成的输出文件 -E: 仅执行编译预处理 -S: 将C代码转换为汇编代码 -wall: 显示警告信息 -c: 仅执行编译操作, 不进行连接操作 参数 C源文件: 指定C语言源代码文件 实例常用编译命令选项假设源程序文件名为test.c 无选项编译链接 1gcc test.c 将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。 选项 -o 1gcc test.c -o test 将test.c预处理、汇编、编译并链接形成可执行文件test。-o选项用来指定输出文件的文件名。 选项 -E 1gcc -E test.c -o test.i 将test.c预处理输出test.i文件。 选项 -S 1gcc -S test.i 将预处理输出文件test.i汇编成test.s文件。 选项 -c 1gcc -c test.s 将汇编输出文件test.s编译输出test.o文件。 无选项链接 1gcc test.o -o test 将编译输出文件test.o链接成最终可执行文件test。 选项 -O 1gcc -O1 test.c -o test 使用编译优化级别1编译程序。级别为1~3，级别越大优化效果越好，但编译时间越长 多源文件的编译方法 如果有多个源文件，基本上有两种编译方法： 假设有两个源文件为test.c和testfun.c 多个文件一起编译 1gcc testfun.c test.c -o test 分别编译各个源文件，之后对编译后输出的目标文件链接。 123gcc -c testfun.c #将testfun.c 编译成testfun.ogcc -c test.c #将test.c编译成test.ogcc -o testfun.c test.o -o test #将testfun.o和test.o 链接成test 以上两种方法相比较，第一中方法编译时需要所有文件重新编译，而第二种方法可以只重新编译修改的文件，未修改的文件不用重新编译。"},{"title":"Linux 命令 「wget」","date":"2018-06-29T07:22:16.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-06-29-Linux-cmd-wget.html","permalink":"http://blog.caoxl.com/backup/2018-06-29-Linux-cmd-wget.html","excerpt":"wget命令用来从指定的URL下载文件。","text":"wget命令用来从指定的URL下载文件。 wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 命令选项 -a&lt;日志文件&gt;: 在指定的日志文件中记录资料的执行过程 -A&lt;后缀名&gt;: 指定要下载文件的后缀名, 多个后缀名之间使用逗号进行分隔 -b: 进行后台的方式运行wget -B&lt;连接地址&gt;: 设置参考的连接地址的基地地址 -c: 继续执行上次终端的任务 -C&lt;标志&gt;: 设置服务器数据块功能标志on为激活,off为关闭,默认值为on -d: 调试模式运行指令 -D&lt;域名列表&gt;: 设置顺着的域名列表, 域名之间用”,”分隔 -e&lt;指令&gt;: 作为文件”/wgetrc”中的一部分执行指定的指令 -h: 显示指令帮助信息 -i&lt;文件&gt;: 从指定文件获取要下载的URL地址 -l&lt;目录列表&gt;: 设置顺着的目录列表,多个目录用”,”分隔 -L: 仅顺着关联的连接 -r: 递归下载方式 -nc: 文件存在时,下载文件不覆盖原有文件 -nv: 下载时只显示更新和出错信息,不显示指令的详细执行过程 -q: 不显示指令执行过程 -nh: 不查询主机名称 -v: 显示详细执行过程 -V: 显示版本信息 --passive-ftp: 使用被动模式PASV连接FTP服务器 --follow-ftp: 从HTML文件中下载FTP连接文件 命令参数 URL: 下载指定的URL地址 实例 使用wget下载单个文件 1wget http://linuxde.net/testfile.zip 下载并以不同的文件名保存 1wget -O wordpress.zip http://www.linuxde.net/download/aspx?id=1080 wget默认会以最后一个符合/的后面的字符来命令，对于动态链接的下载通常文件名会不正确。 wget限速下载 1wget --limit-rate=300k http://www.linuxde.net/testfile.zip 当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了 使用wget断点续传 1wget -c http://www.linuxde.net/testfile.zip 使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。 使用wget后台下载 1wget -b http://www.linuxde.net/testfile.zip 对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载，你可以使用以下命令来察看下载进度： 1tail -f wget-log 伪装代理名称下载 1wget --user-agent=\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\" http://www.linuxde.net/testfile.zip 有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过--user-agent参数伪装。 测试下载链接 当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加--spider参数进行检查。 1wget --spider URL 增加重试次数 1wget --tries=40 URL 如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用--tries增加重试次数。 下载多个文件 1wget -i filelist.txt 首先，保存一份下载链接文件： 12345cat &gt; filelist.txturl1url2url3url4 接着使用这个文件和参数-i下载。 镜像网站 1wget --mirror -p --convert-links -P ./LOCAL URL 接着使用这个文件和参数-i下载。 --mirror: 开户镜像下载 -p: 下载所有为了html页面显示正常的文件 --convert-links: 下载后,转换成本地的链接 -P ./LOCAL: 保存所有文件和目录到本地指定目录 过滤指定格式下载 1wget --reject=gif ur 下载一个网站，但你不希望下载图片，可以使用这条命令。 把下载信息存入日志文件 1wget -o download.log URL 不希望下载信息直接显示在终端而是在一个日志文件，可以使用。 限制总下载文件大小 1wget -Q5m -i filelist.txt 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。 下载指定格式文件 1wget -r -A.pdf url 可以在以下情况使用该功能： 下载一个网站的所有图片。 下载一个网站的所有视频。 下载一个网站的所有PDF文件。 FTP下载 12wget ftp-urlwget --ftp-user=USERNAME --ftp-password=PASSWORD url 可以使用wget来完成ftp链接的下载。 使用wget匿名ftp下载 1wget ftp-url 使用wget用户名和密码认证的ftp下载 1wget --ftp-user=USERNAME --ftp-password=PASSWORD url"},{"title":"Linux 命令 「whereis」","date":"2018-07-02T02:07:59.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-02-Linux-cmd-whereis.html","permalink":"http://blog.caoxl.com/backup/2018-07-02-Linux-cmd-whereis.html","excerpt":"whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。","text":"whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。 whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 和find相比，whereis查找的速度非常快，这是因为linux系统会将系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 命令选项 -b: 只查找二进制文件 -B&lt;目录&gt;: 只在设置的目录下查找二进制文件 -f: 不显示文件名前的路径名称 -m: 只查找说明文件 -M&lt;目录&gt;: 只在设置的目录下查找说明文件 -s: 只查找原始代码文件 -S&lt;目录&gt;: 只在设置的目录下查找原始代码文件 -u: 查找不包含指定类型的文件 命令参数 指令名: 要查找的二进制程序,源文件和man手册页的指令名 实例 将相关的文件都查找出来 123456[root@izj6c6djex81rijczh0t8yz ~]# whereis tomcattomcat:[root@izj6c6djex81rijczh0t8yz ~]# whereis svnsvn:[root@izj6c6djex81rijczh0t8yz ~]# whereis gitgit: /usr/bin/git /usr/share/man/man1/git.1.gz 说明：tomcat、svn没安装，找不出来，git安装找出了很多相关文件 只将二进制文件查找出来 1234567891011# 只查找二进制文件[root@izj6c6djex81rijczh0t8yz ~]# whereis -b gitgit: /usr/bin/git# 只查找说明文件[root@izj6c6djex81rijczh0t8yz ~]# whereis -m gitgit: /usr/share/man/man1/git.1.gz# 只查找`source`源文件[root@izj6c6djex81rijczh0t8yz ~]# whereis -s gitgit:"},{"title":"Linux 命令 「nslookup」","date":"2018-07-04T06:10:41.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-04-Linux-cmd-nslookup.html","permalink":"http://blog.caoxl.com/backup/2018-07-04-Linux-cmd-nslookup.html","excerpt":"nslookup命令是常用域名查询工具，就是查DNS信息用的命令。","text":"nslookup命令是常用域名查询工具，就是查DNS信息用的命令。 nslookup有两种工作模式，即“交互模式”和“非交互模式”。 在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。 命令选项 -sil: 不显示任何警告信息 命令参数 域名: 指定要查询域名 实例12345678[root@izj6c6djex81rijczh0t8yz ~]# nslookup&gt; www.caoxl.com Server: 100.100.2.136Address: 100.100.2.136#53Non-authoritative answer:Name: www.caoxl.comAddress: 47.91.221.85"},{"title":"Linux 命令 「ssh」","date":"2018-07-03T01:55:58.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-03-Linux-cmd-ssh.html","permalink":"http://blog.caoxl.com/backup/2018-07-03-Linux-cmd-ssh.html","excerpt":"ssh命令是openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器。","text":"ssh命令是openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器。 语法1ssh (选项)(参数) 选项 -1: 强制使用ssh协议版本1; -2: 强制使用ssh协议版本2; -4: 强制使用IPv4地址; -6: 强制使用IPv6地址; -A: 开启认证代理连接转发功能; -a: 关闭认证代理连接转发功能; -b: 使用本机指定地址作为对应连接的源ip地址; -C: 请求压缩所有数据; -F: 指定ss指令的配置文件; -f: 后台执行ssh指令; -g: 允许远程主机连接主机的转发端口; -i: 指定身份文件; -l: 指定连接远程服务器登录用户名; -N: 不执行远程指令; -o: 指定配置选项; -p: 指定远程服务器上的端口; -q: 静默模式; -X: 关闭X11转发功能; -y: 开启信任X11转发功能; 参数 远程主机: 指定要连接的远程ssh服务器 指令: 要在远程ssh服务器上执行的指令 实例 ssh登录远程服务器 1234ssh user@host -p port例:ssh caoxl@127.0.0.1 -p 22"},{"title":"Linux 命令 「ssh-keygen」","date":"2018-07-04T06:46:33.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-04-Linux-cmd-ssh-keygen.html","permalink":"http://blog.caoxl.com/backup/2018-07-04-Linux-cmd-ssh-keygen.html","excerpt":"ssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥。","text":"ssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥。 语法1ssh-keygen (选项) 选项 -b: 指定密钥长度 -e: 读取openssh的私钥或者公钥文件 -C: 添加注释 -f: 指定用来保存密钥的文件名 -i: 读取未加密的ssh-v2兼容的私钥/公钥文件.然后再标准输出设备上显示openssh兼容的私钥/公钥 -l: 显示公钥文件的指纹数据 -N: 提供一个新密语 -P: 提供(旧)密语 -q: 静默模式 -t: 指定要创建的密钥类型"},{"title":"Linux 命令 「awk」","date":"2018-07-05T01:42:30.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-05-Linux-cmd-awk.html","permalink":"http://blog.caoxl.com/backup/2018-07-05-Linux-cmd-awk.html","excerpt":"awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。","text":"awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。 语法12awk [options] 'script' var=value file(s)awk [options] -f scriptfile var=value file(s) 命令选项 -F fs: fs指定输入分隔符,fs可以是字符串或正则表达式,如-F -v var=value: 赋值一个用户定义变量, 将外部变量传递给awk -f scripfile: 从脚本文件中读取awk命令 -m [fr] val: 对val值设置内在限制, -mf选项限制分配给val的最大快数目 -mr选项限制记录的最大数目 这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用 awk模式和操作模式 /正则表达式/: 使用通配符的扩展集 关系表达式: 使用运算符进行操作, 可以是字符串或数字的比较测试 模式匹配表达式: 用运算符~(匹配) 和 ~!(不匹配) BEGIN语句块、pattern语句块、END语句块 操作操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是： 变量或数组赋值 输出命令 内置函数 控制流语句 awk脚本基本结构1awk 'BEGIN&#123; print \"start\" &#125; pattern&#123; commands &#125; END&#123; print \"end\" &#125;' file 一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中，例如： 12awk 'BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;' filenameawk \"BEGIN&#123; i=0 &#125; &#123; i++ &#125; END&#123; print i &#125;\" filename awk的工作原理1awk 'BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;' 第一步: 执行BEGIN{ commands }语句块中的语句 第二步: 从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。 第三步: 当读至输入流末尾时, 执行END{ commands } 语句块 BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。 pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。 END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。"},{"title":"Linux 命令 「init」","date":"2018-07-06T05:56:23.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-06-Linux-cmd-init.html","permalink":"http://blog.caoxl.com/backup/2018-07-06-Linux-cmd-init.html","excerpt":"init命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令是Linux操作系统中不可缺少的程序之一，init进程是Linux内核引导运行的，是系统中的第一个进程。","text":"init命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令是Linux操作系统中不可缺少的程序之一，init进程是Linux内核引导运行的，是系统中的第一个进程。 语法1init (选项)(参数) 选项 -b: 不执行相关脚本而直接进入单用户模式 -s: 切换到单用户模式 参数 运行等级: 指定Linux系统要切换到的运行等级 实例 查看系统进程命令: ps -ef | head 查看init的配置文件: more /etc/inittab 查看系统当前运行的级别: runlevel 运行级别到底什么是运行级呢？简单的说，运行级就是操作系统当前正在运行的功能级别。这个级别从0到6, 具有不同的功能。你也可以在/etc/rc.d看到对应的文件夹。 1234567#0 停机 (千万不能把initdefault 设置为0)#1 单用户模式#2 多用户, 没有NFS(和级别3相似, 会停止部分服务)#3 完全的多用户模式(有NFS), 登陆后进入控制台命令行模式#4 没有用到#5 x11(Xwindow)#6 重新启动(千万不要把initdefault 设置为6) NFS 网络文件系统(Network File System) 是由Sun公司1984年发布的分布式文件系统协议。它允许客户端上的用户像访问本地文件一样地访问网络上的文件。"},{"title":"Linux 命令 「sed」","date":"2018-07-05T02:20:17.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-05-Linux-cmd-sed.html","permalink":"http://blog.caoxl.com/backup/2018-07-05-Linux-cmd-sed.html","excerpt":"sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。","text":"sed是一种流编辑器，它是文本处理中非常中的工具，能够完美的配合正则表达式使用，功能不同凡响。sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 命令格式12sed [options] 'command' file(s)sed [options] -f scriptfile file(s) 选项 -e&lt;script&gt;/--expression=&lt;script&gt;: 以选项中指定的script来处理输入的文本文件 -f&lt;script&gt;/--file=&lt;script文件&gt;: 以选项中指定的script文件来处理输入的文本文件 -h/--help: 显示帮助 -n/--quiet/--silent: 仅显示script处理后的结果 -V/--version: 显示版本信息 参数 文件: 指定待处理的文本文件列表 sed命令 a\\: 在当前行下面插入文本 i\\: 在当前行上面插入文本 c\\: 把选定的行改为新的文本 d: 删除, 删除选项的行 D: 删除模板块的第一行 s: 替换指定字符 h: 拷贝模板块的内容到内存中的缓存区 H: 追加模板块的内容到内存中的缓存区 g: 获得内存缓冲区的内容,并替代当前模板块中的文本 G: 获得内存缓冲区的内容,并追加到当前模板块文本的后面 I: 列表不能打印字符的清单 n: 读取下一个输入行, 用下一个命令处理新的行而不是用第一个命令 N: 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。 p: 打印模板块的行 P: 打印模板块的第一行 q: 退出sed b lable 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。 r file 从file中读行。 t label if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 T label错误分支, 从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。 w file: 写并追加模板块到file末尾 W file: 写并追加模板块到第一行到file末尾 !: 表示后面的命令对所有没有被选定的行发生作用 =: 打印当前行号码 #: 把注释扩展到下一个换行符以前 sed替换标记 g: 表示行内全面替换 p: 表示打印行 w: 表示把行写入一个文件 x: 表示互换模板块中的文本和缓冲区中的文本 y: 表示把一个字符翻译为另外的字符(但是不用于正则表达式) \\1: 子串匹配标记 &amp;: 已匹配字符串标记 sed元字符集 ^ 匹配行开始，如：/^sed/匹配所有以sed开头的行。 $ 匹配行结束，如：/sed$/匹配所有以sed结尾的行 . 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。 * 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。 []匹配一个指定范围内的字符，如/[ss]ed/匹配sed和Sed。 [^] 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/ 匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。 \\(..\\) 匹配子串，保存匹配的字符，如s/\\(love\\)able/\\1rs，loveable被替换成lovers。 &amp; 保存搜索字符用来替换其他字符，如s/love/**&amp;**/，love这成 love。 \\&lt; 匹配单词的开始，如:/\\&lt;love/匹配包含以love开头的单词的行。 \\&gt; 匹配单词的结束，如:/love\\&gt;/匹配包含以love结尾的单词的行。 x\\{m\\} 重复字符x，m次，如：/0{5}/匹配包含5个0的行。 x\\{m,\\} 重复字符x，至少m次，如：/0{5,}/匹配至少有5个0的行。 x\\{m,n\\} 重复字符x，至少m次，不多于n次，如：/0{5,10}/匹配5~10个0的行。 sed用法实例 替换操作: s命令 1sed 's/1024/2048/' file -n选项和p命令一起使用表示只打印那些发生替换的行： 1sed -n 's/1024/2028/p' file 直接编辑文件选项-i，会匹配file文件中每一行的第一个book替换为books: 1sed -i 's/1024/2028/g' file 全面替换标记g 使用后缀 /g 标记会替换每一行中的所有匹配: 1sed 's/1024/2028/g' file 当需要从第N处匹配开始替换时，可以使用 /Ng: 1echo sksksksksk | sed 's/sk/SK/2g' 定界符 以上命令中字符 / 在sed中作为定界符使用，也可以使用任意的定界符 12sed 's:test:TEXT:g'sed 's|test|TEST|g' 定界符出现在样式内部时，需要进行转义： 1sed 's/\\/bin/\\/usr\\/local\\/bin/g' 删除操作: d命令 12345678910# 删除空白行sed '/^$/d' file# 删除文件的第2行sed '2d' file# 删除文件的第`2`行到末尾所有行sed '2,$d' file# 删除文件最后一行sed '$d' file# 删除文件中所有开头是test的行sed '/^test/'d file"},{"title":"Linux 命令 「ps」","date":"2018-07-06T06:08:39.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-06-Linux-cmd-ps.html","permalink":"http://blog.caoxl.com/backup/2018-07-06-Linux-cmd-ps.html","excerpt":"ps命令用于报告当前系统的进程状态","text":"ps命令用于报告当前系统的进程状态 可以搭配kill指令随时中断、删除不必要的程序.ps命令是最基本同时也是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态,进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。 语法1ps (选项) 选项 -a: 显示所有进程 a: 显示同一终端下的所有程序 -A: 显示所有程序 -c: 显示CLS和PRI栏位 c: 显示进程的真实名称 -C&lt;指令名称&gt;: 指定执行指令的名称, 并列出该指令的程序的状况 -d: 显示所有程序, 但不包括阶段作业领导者的程序 -e: 此选项的效果和指定A选项相同 e: 列出程序时, 显示每个程序所使用的环境变量 f: 显示程序间的关系 -H: 显示树状结构 r: 显示当前终端的所有程序 T: 显示当前终端的所有程序 u: 指定用户的所有进程 -au: 显示较详细的资讯 -aux: 显示所有包含其他使用者的进程 --lines&lt;行数&gt;: 每页显示的行数 --width&lt;字符数&gt;: 每页显示的字符数 --help: 显示帮助信息 --version: 显示版本显示 由于ps命令能够支持的系统类型相当的多，所以选项多的离谱！ 详情:ps 常见命令 显示所有进程的信息 - ps -A 12345678[root@izj6c6djex81rijczh0t8yz ~]# ps -APID TTY TIME CMD 1 ? 00:00:07 systemd 2 ? 00:00:00 kthreadd 3 ? 00:00:03 ksoftirqd/0 5 ? 00:00:00 kworker/0:0H 7 ? 00:00:00 migration/0... 显示指定用户信息 - ps -u root 1234567891011[root@izj6c6djex81rijczh0t8yz ~]# ps -u root PID TTY TIME CMD 1 ? 00:00:07 systemd 2 ? 00:00:00 kthreadd 3 ? 00:00:03 ksoftirqd/0 5 ? 00:00:00 kworker/0:0H 7 ? 00:00:00 migration/0...[root@izj6c6djex81rijczh0t8yz ~]# ps -u git PID TTY TIME CMD 显示所有进程信息, 连同命令行 - ps -ef 12345678[root@izj6c6djex81rijczh0t8yz ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Jun25 ? 00:00:07 /usr/lib/systemd/systemd --switched-root --system --deserializroot 2 0 0 Jun25 ? 00:00:00 [kthreadd]root 3 2 0 Jun25 ? 00:00:03 [ksoftirqd/0]root 5 2 0 Jun25 ? 00:00:00 [kworker/0:0H]root 7 2 0 Jun25 ? 00:00:00 [migration/0]... ps 与 grep 常用组合用户, 查找特地进程 - ps -ef | grep ssh 1234[root@izj6c6djex81rijczh0t8yz ~]# ps -ef | grep sshroot 449 32147 0 14:47 pts/0 00:00:00 grep --color=auto sshroot 1443 1 0 Jun25 ? 00:00:04 /usr/sbin/sshd -Droot 32145 1443 0 09:49 ? 00:00:00 sshd: root@pts/0 将目前属于你自己这次登入的PID与相关信息列示出来 - ps -l 1234[root@izj6c6djex81rijczh0t8yz ~]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD0 R 0 450 32147 0 80 0 - 38292 - pts/0 00:00:00 ps4 S 0 32147 32145 0 80 0 - 28892 do_wai pts/0 00:00:00 bash 说明: F: 代表正呈现的flag, 4 代表使用者为 super user S: 代表这个程序的状态(STAT) UID: 程序拥有者 PID: 程序的ID PPID: 上级父程序的ID C: CPU使用的资源百分比 PRI: Priority(优先执行序)的简写 NI: Nice值 ADDR: kernel function指出该程序在内存的哪个部分。如果是个 running的程序，一般就是 “-“ SZ: 已使用的内存大小 WCHEAN: 是否正在运行, -表示正在运行 TTY: 登入者的终端机位置 TIME: 已使用的CPU时间 CMD: 所下达的指令名称 在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，所以， 当我使用 ps -l 的时候，只有2个 PID 列出目前所有的正在内存当中的程序 - ps aux 1234567[root@izj6c6djex81rijczh0t8yz ~]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.3 43404 3140 ? Ss Jun25 0:07 /usr/lib/systemd/systemd --switched-root --syroot 2 0.0 0.0 0 0 ? S Jun25 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S Jun25 0:03 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S&lt; Jun25 0:00 [kworker/0:0H]root 7 0.0 0.0 0 0 ? S Jun25 0:00 [migration/0] 说明: USER: 该 process 属于哪个使用者账号的 PID: 该 process 的ID %CPU: 该 process 使用掉的 CPU 资源百分比 %MEM: 该 process 所占用的物理内存百分比 VSZ: 该 process 使用掉的虚拟内存量 (Kbytes) RSS: 该 process 占用的固定的内存量 (Kbytes) TTY: 该 process 是在哪个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序 STAT: 该程序目前的状态，主要的状态有 R: 该程序目前正在运作，或者是可被运作 S: 该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒 T: 该程序目前正在侦测或者是停止了 Z: 该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (僵尸) 程序的状态 START: 该 process 被触发启动的时间 TIME: 该 process 实际使用 CPU 运作的时间 COMMAND: 该程序的实际指令 列出类似程序树的程序显示 - ps -axjf 12345678[root@izj6c6djex81rijczh0t8yz ~]# ps -axjf PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 0 2 0 0 ? -1 S 0 0:00 [kthreadd] 2 3 0 0 ? -1 S 0 0:03 \\_ [ksoftirqd/0] 2 5 0 0 ? -1 S&lt; 0 0:00 \\_ [kworker/0:0H] 2 7 0 0 ? -1 S 0 0:00 \\_ [migration/0] 2 8 0 0 ? -1 S 0 0:00 \\_ [rcu_bh] 2 9 0 0 ? -1 R 0 0:31 \\_ [rcu_sched] 找出与cron与syslog这个两个服务有关的PID号码 - ps aux | egrep &#39;(cron|syslog)&#39; 1234[root@izj6c6djex81rijczh0t8yz ~]# ps aux | egrep '(cron|syslog)'root 471 0.0 0.1 126316 1644 ? Ss Jun25 0:01 /usr/sbin/crond -nroot 546 0.0 0.0 112708 1000 pts/0 R+ 15:24 0:00 grep -E --color=auto (cron|syslog)root 706 0.0 1.8 548532 18440 ? Ssl Jun25 0:53 /usr/sbin/rsyslogd -n"},{"title":"Linux 命令 「chage」","date":"2018-07-09T01:22:20.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-09-Linux-cmd-chage.html","permalink":"http://blog.caoxl.com/backup/2018-07-09-Linux-cmd-chage.html","excerpt":"chage命令是用来修改帐号和密码的有效期限。","text":"chage命令是用来修改帐号和密码的有效期限。 语法1chage [选项] 用户名 选项 -m: 密码可更改的最小天数, 为零时代表任何时候都可以更改密码 -M: 密码可保持有效的最大天数 -W: 用户密码到期前, 提前收到警告信息的天数 -E: 账号到期的日期, 过了这天, 此账号将不可用 -d: 上一次更改的日期 -i: 停滞时期, 如果一个密码已过期这些天,那么此账号将不可用 -l: 列出当前的设置. 由非特权用户确定他们的密码或账号何时过期 实例 可以编辑 /etc/login.defs 来设定几个参数，以后设置口令默认就按照参数设定为准: 1234PASS_MAX_DAYS 99999PASS_MIN_DAYS 0PASS_MIN_LEN 5PASS_WARN_AGE 7 在/etc/default/useradd可以找到如下2个参数进行设置: 123456789[root@izj6c6djex81rijczh0t8yz default]# cat useradd # useradd defaults fileGROUP=100HOME=/homeINACTIVE=-1EXPIRE=SHELL=/bin/bashSKEL=/etc/skelCREATE_MAIL_SPOOL=yes 通过修改配置文件，能对之后新建用户起作用，而目前系统已经存在的用户，则直接用chage来配置。 我的服务器root帐户密码策略信息如下: 12345678[root@izj6c6djex81rijczh0t8yz default]# chage -l rootLast password change : Jan 02, 2018 # 最近一次密码修改时间Password expires : never # 密码过期时间Password inactive : never # 密码失效时间Account expires : never # 账户过期时间Minimum number of days between password change : 0 # 两次改变密码之间相距的最小天数Maximum number of days between password change : 99999 # 两次改变密码之间相距的最大天数Number of days of warning before password expires : 7 # 在密码过期之前警告的天数 我可以通过如下命令修改我的密码过期时间: 12345678[root@izj6c6djex81rijczh0t8yz default]# chage -l rootLast password change : Jan 02, 2018Password expires : Sep 27, 2020Password inactive : neverAccount expires : neverMinimum number of days between password change : 0Maximum number of days between password change : 999Number of days of warning before password expires : 7 然后通过如下命令设置密码失效时间: 123456789[root@izj6c6djex81rijczh0t8yz default]# chage -I 999 root[root@izj6c6djex81rijczh0t8yz default]# chage -l rootLast password change : Jan 02, 2018Password expires : Sep 27, 2020Password inactive : Jun 23, 2023Account expires : neverMinimum number of days between password change : 0Maximum number of days between password change : 999Number of days of warning before password expires : 7"},{"title":"Linux 命令 「passwd」","date":"2018-07-09T01:53:25.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-09-Linux-cmd-passwd.html","permalink":"http://blog.caoxl.com/backup/2018-07-09-Linux-cmd-passwd.html","excerpt":"passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。","text":"passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。 语法1passwd (选项) (参数) 选项 -d: 删除密码, 仅有系统管理者才能使用 -f: 强制执行 -k: 设置只有在密码过期失效后, 方能更新 -l: 锁住密码 -s: 列出密码的相关信息,仅有系统管理者才能使用 -u: 解开已上锁的账号 参数 用户名: 需要设置密码的用户名 扩展与用户、组账户信息相关的文件: 存放用户信息: 12/etc/passwd/etc/shadow 存放组信息 12/etc/group/etc/gshadow 用户信息文件分析 (每项用 : 隔开) 12345678例如: git:x:1002:1002::/home/git:/usr/bin/git-shellgit // 用户名x // 口令、密码1002 // 用户id (0代表root、普通新建用户从500开始)1002 // 所在组: // 描述/home/git/ // 用户主目录/usr/bin/git-shell // 用户缺省Shell 实例 如果是普通用户执行passwd只能修改自己的密码。如果新建用户后，要为新用户创建密码，则用passwd用户名，注意要以root用户的权限来创建。 12345[root@localhost ~]# passwd linuxde //更改或创建linuxde用户的密码；Changing password for user linuxde.New UNIX password: //请输入新密码；Retype new UNIX password: //再输入一次；passwd: all authentication tokens updated successfully. //成功； 普通用户如果想更改自己的密码，直接运行passwd即可，比如当前操作的用户是linuxde。 123456[linuxde@localhost ~]$ passwdChanging password for user linuxde. //更改linuxde用户的密码；(current) UNIX password: //请输入当前密码；New UNIX password: //请输入新密码；Retype new UNIX password: //确认新密码；passwd: all authentication tokens updated successfully. //更改成功； 让某个用户不能修改密码，可以用-l选项来锁定: 12345678910[root@localhost ~]# passwd -l linuxde //锁定用户linuxde不能更改密码Locking password for user linuxde.passwd: Success //锁定成功[linuxde@localhost ~]# su linuxde //通过su切换到linuxde用户[linuxde@localhost ~]$ passwd //linuxde来更改密码Changing password for user linuxde.Changing password for linuxde(current) UNIX password: //输入linuxde的当前密码passwd: Authentication token manipulation error //失败，不能更改密码 再来一例: 123456[root@localhost ~]# passwd -d linuxde //清除linuxde用户密码Removing password for user linuxde.passwd: Success //清除成功[root@localhost ~]# passwd -S linuxde //查询linuxde用户密码状态Empty password. //空密码，也就是没有密码 注意：当我们清除一个用户的密码时，登录时就无需密码，这一点要加以注意。 123[root@izj6c6djex81rijczh0t8yz ~]# su caoxl # 无需密码[caoxl@izj6c6djex81rijczh0t8yz root]$ su lc # 需要密码Password:"},{"title":"Linux 命令 「df」","date":"2018-07-10T09:25:02.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-10-Linux-cmd-df.html","permalink":"http://blog.caoxl.com/backup/2018-07-10-Linux-cmd-df.html","excerpt":"df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。","text":"df命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。 可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。 语法1df (选项) (参数) 选项 -a/--a: 包含全部的文件系统 --block-size=&lt;区块大小&gt;: 以指定的区块大小来显示区块数目 -h/--human-readable: 以可读性较高的方式来显示信息 -H/--si: 与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes -i/--inodes: 显示inode的信息 -k/--kilobytes: 指定区块大小为1024字节 -l/--local: 仅显示本地端的文件系统 -m/--megabytes: 指定区块大小为1048576字节 --no-sync: 在取得磁盘使用信息前，不要执行sync指令，此为预设值 -t&lt;文件系统类型&gt;/--type=&lt;文件系统类型&gt;: 仅显示指定文件系统类型的磁盘信息 -x&lt;文件系统类型&gt;/--exclude-type=&lt;文件系统类型&gt;: 不要显示指定文件系统类型的磁盘信息 -T/--print-type: 显示文件系统的类型 --help: 显示帮助 --version: 显示版本信息 参数 文件: 指定文件系统上的文件 实例 查看系统磁盘设备，默认是KB为单位: 123456789[root@izj6c6djex81rijczh0t8yz ~]# df# 文件系统 1K-块 已用 可用 已用% 挂载点Filesystem 1K-blocks Used Available Use% Mounted on/dev/vda1 41151808 6917616 32120760 18% /devtmpfs 497116 0 497116 0% /devtmpfs 507716 0 507716 0% /dev/shmtmpfs 507716 472 507244 1% /runtmpfs 507716 0 507716 0% /sys/fs/cgrouptmpfs 101544 0 101544 0% /run/user/0 使用-h选项以KB以上的单位来显示，可读性高 12345678[root@izj6c6djex81rijczh0t8yz ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 6.6G 31G 18% /devtmpfs 486M 0 486M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 472K 496M 1% /runtmpfs 496M 0 496M 0% /sys/fs/cgrouptmpfs 100M 0 100M 0% /run/user/0 查看全部文件系统: 12345678910111213141516171819202122232425262728293031[root@izj6c6djex81rijczh0t8yz ~]# df -aFilesystem 1K-blocks Used Available Use% Mounted onrootfs - - - - /sysfs 0 0 0 - /sysproc 0 0 0 - /procdevtmpfs 497116 0 497116 0% /devsecurityfs 0 0 0 - /sys/kernel/securitytmpfs 507716 0 507716 0% /dev/shmdevpts 0 0 0 - /dev/ptstmpfs 507716 472 507244 1% /runtmpfs 507716 0 507716 0% /sys/fs/cgroupcgroup 0 0 0 - /sys/fs/cgroup/systemdpstore 0 0 0 - /sys/fs/pstorecgroup 0 0 0 - /sys/fs/cgroup/cpusetcgroup 0 0 0 - /sys/fs/cgroup/net_cls,net_priocgroup 0 0 0 - /sys/fs/cgroup/hugetlbcgroup 0 0 0 - /sys/fs/cgroup/memorycgroup 0 0 0 - /sys/fs/cgroup/blkiocgroup 0 0 0 - /sys/fs/cgroup/freezercgroup 0 0 0 - /sys/fs/cgroup/devicescgroup 0 0 0 - /sys/fs/cgroup/perf_eventcgroup 0 0 0 - /sys/fs/cgroup/cpu,cpuacctcgroup 0 0 0 - /sys/fs/cgroup/pidsconfigfs 0 0 0 - /sys/kernel/config/dev/vda1 41151808 6917748 32120628 18% /systemd-1 - - - - /proc/sys/fs/binfmt_mischugetlbfs 0 0 0 - /dev/hugepagesdebugfs 0 0 0 - /sys/kernel/debugmqueue 0 0 0 - /dev/mqueuetmpfs 101544 0 101544 0% /run/user/0binfmt_misc 0 0 0 - /proc/sys/fs/binfmt_misc"},{"title":"Linux 命令 「ispell」","date":"2018-07-13T06:47:32.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-13-Linux-cmd-ispell.html","permalink":"http://blog.caoxl.com/backup/2018-07-13-Linux-cmd-ispell.html","excerpt":"ispell命令用于检查文件中出现的拼写错误。","text":"ispell命令用于检查文件中出现的拼写错误。 ispell预设会使用/usr/lib/ispell/english.hash字典文件来检查文本文件 语法1ispell (参数) 参数 文件: 指定要进行拼写检查的文件"},{"title":"Linux 命令 「nmap」","date":"2018-07-11T02:47:41.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-11-Linux-cmd-nmap.html","permalink":"http://blog.caoxl.com/backup/2018-07-11-Linux-cmd-nmap.html","excerpt":"nmap命令是一款开放源代码的网络探测和安全审核工具，它的设计目标是快速地扫描大型网络。","text":"nmap命令是一款开放源代码的网络探测和安全审核工具，它的设计目标是快速地扫描大型网络。 安装nmap1yum install nmap 语法1nmap (选项) (参数) 选项 -O: 激活操作探测 -P0: 值进行扫描, 不ping主机 -PT: 是同TCP的ping -sV: 探测服务版本信息 -sP: ping扫描, 仅发现目标主机是否存活 -ps: 发送同步(SYN)报文 -PU: 发送udp ping -PE: 强制执行直接的TCMPping -PB: 默认模式, 可以使用ICMPping和TCPping -6: 使用IPv6地址 -v: 得到更多选项信息 -d: 增加调试信息的输出 -oN: 以人民可阅读的格式输出 -oX: 以xml格式向指定文件输出信息 -oM: 以机器可阅读的格式输出 -A: 使用所有高级扫描选项 --resume: 继续上次执行完的扫描 -P: 指定要扫描的端口，可以是一个单独的端口，用逗号隔开多个端口，使用“-”表示端口范围 -e: 在多网络接口Linux系统中, 指定扫描使用的网络接口 -g: 将指定的端口作为源端口进行扫描 --ttl: 指定发送的扫描报文进行扫描 --packet-trace: 显示扫描过程中收发报文统计 --scanflags: 设置在扫描报文中的TCP标志 参数 ip地址: 指定待扫描报文中的TCP地址 实例 使用nmap扫描www.caoxl.com的开放端口 使用主机名扫描12345678910111213[root@izj6c6djex81rijczh0t8yz ~]# nmap www.caoxl.comStarting Nmap 6.40 ( http://nmap.org ) at 2018-07-11 10:47 CSTNmap scan report for www.caoxl.com (47.91.221.85)Host is up (0.00030s latency).Not shown: 996 filtered portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open https3389/tcp closed ms-wbt-serverNmap done: 1 IP address (1 host up) scanned in 4.69 seconds 使用IP地址扫描123456789101112131415161718192021222324[root@izj6c6djex81rijczh0t8yz ~]# nmap 106.15.38.11Starting Nmap 6.40 ( http://nmap.org ) at 2018-07-11 11:10 CSTNmap scan report for 106.15.38.11Host is up (0.035s latency).Not shown: 985 closed portsPORT STATE SERVICE22/tcp open ssh25/tcp filtered smtp42/tcp filtered nameserver80/tcp open http135/tcp filtered msrpc139/tcp filtered netbios-ssn443/tcp open https445/tcp filtered microsoft-ds593/tcp filtered http-rpc-epmap1025/tcp filtered NFS-or-IIS1068/tcp filtered instl_bootc1434/tcp filtered ms-sql-m3128/tcp filtered squid-http3306/tcp open mysql4444/tcp filtered krb524Nmap done: 1 IP address (1 host up) scanned in 1.77 seconds 扫描使用“-v”选项使用“ –v “选项后给出了远程机器更详细的信息 1234567891011121314151617181920212223242526[root@izj6c6djex81rijczh0t8yz ~]# nmap -v caoxl.comStarting Nmap 6.40 ( http://nmap.org ) at 2018-07-11 11:10 CSTInitiating Ping Scan at 11:10Scanning caoxl.com (47.91.221.85) [4 ports]Completed Ping Scan at 11:10, 0.00s elapsed (1 total hosts)Initiating Parallel DNS resolution of 1 host. at 11:10Completed Parallel DNS resolution of 1 host. at 11:10, 0.03s elapsedInitiating SYN Stealth Scan at 11:10Scanning caoxl.com (47.91.221.85) [1000 ports]Discovered open port 80/tcp on 47.91.221.85Discovered open port 22/tcp on 47.91.221.85Discovered open port 443/tcp on 47.91.221.85Completed SYN Stealth Scan at 11:11, 4.22s elapsed (1000 total ports)Nmap scan report for caoxl.com (47.91.221.85)Host is up (0.00026s latency).Not shown: 996 filtered portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open https3389/tcp closed ms-wbt-serverRead data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 4.30 seconds Raw packets sent: 2002 (88.064KB) | Rcvd: 20 (816B) 扫描整个子网123456789101112131415161718192021222324252627282930313233343536373839404142[root@izj6c6djex81rijczh0t8yz ~]# nmap 47.91.221.*Starting Nmap 6.40 ( http://nmap.org ) at 2018-07-11 11:12 CSTNmap scan report for 47.91.221.0Host is up (0.00034s latency).Not shown: 999 filtered portsPORT STATE SERVICE80/tcp closed httpNmap scan report for 47.91.221.1Host is up (0.00087s latency).Not shown: 996 filtered portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open https3389/tcp closed ms-wbt-serverNmap scan report for 47.91.221.2Host is up (0.00084s latency).Not shown: 982 closed portsPORT STATE SERVICE25/tcp filtered smtp135/tcp open msrpc139/tcp open netbios-ssn445/tcp open microsoft-ds666/tcp open doom6666/tcp open irc8000/tcp open http-alt8001/tcp open vcom-tunnel8002/tcp open teradataordbms8007/tcp open ajp128008/tcp open http8009/tcp open ajp138100/tcp open xprint-server9000/tcp open cslistener9001/tcp open tor-orport9002/tcp open dynamid9003/tcp open unknown9009/tcp open pichat... 参考 给Linux系统/网络管理员准备的Nmap命令的29个实用范例"},{"title":"Linux 命令 「apt-get」","date":"2018-07-12T08:06:42.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-12-Linux-cmd-apt-get.html","permalink":"http://blog.caoxl.com/backup/2018-07-12-Linux-cmd-apt-get.html","excerpt":"apt-get命令是Debian Linux发行版中的APT软件包管理工具, 类似于CentOS下的yum.","text":"apt-get命令是Debian Linux发行版中的APT软件包管理工具, 类似于CentOS下的yum. 语法1apt-get (选项) (参数) 选项 -c: 指定配置文件 参数 管理指令: 对APT软件包的管理操作 软件包: 指定要操纵的软件包 实例 安装一个新软件包 1apt-get install package_name 卸载一个已安装的软件包(保留配置文件) 1apt-get remove package_name 卸载一个已安装的软件包(删除配置文件) 1apt-get -purage remove package_name 删除已经删掉的软件 1apt-get autoclean apt 删除已安装的软件的备份 1apt-get clean 更新所有已安装的软件包 1apt-get upgrade 将系统升级到新版本 1apt-get dist-upgrade"},{"title":"Linux 命令 「vmstat」","date":"2018-07-16T02:19:07.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-16-Linux-cmd-vmstat.html","permalink":"http://blog.caoxl.com/backup/2018-07-16-Linux-cmd-vmstat.html","excerpt":"vmstat命令的含义为显示虚拟内存状态 (“Viryual Memor Statics”), 但是它可以报告关于进程、内存、I/O等系统整体运行状态","text":"vmstat命令的含义为显示虚拟内存状态 (“Viryual Memor Statics”), 但是它可以报告关于进程、内存、I/O等系统整体运行状态 语法1vmstat (选项) (参数) 选项 -a: 显示活动内页 -f: 显示启动后创建的进程总数 -m: 显示slab信息 -n: 头信息仅显示一次 -s: 以表格方式显示事件计数器和内存状态 -d: 报告磁盘状态 -p: 显示指定的硬盘分区状态 -S: 输出信息的单位 参数 事件间隔: 状态信息刷新的时间间隔 次数: 显示报告的次数 实例1234[root@caoxianliang ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 3 0 0 103704 99284 671468 0 0 2 6 87 158 0 0 100 0 0 字段说明: Procs (进程) r: 运行队列中进程数量, 这个值也可以判断是否需要增加CPU (长期大于1) b: 等待IO的进程数量 Memory (内存) swpd: 使用虚拟内存大小, 如果swpd的值不为0, 但是SI,SO的值长期为0, 这种情况不糊影响系统性能 free: 空闲物理内存大小 buff: 用作缓冲的内存大小 cache: 用作缓冲的内存大小, 如果cache的值大的时候, 说明cache处的文件数多, 如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。 Swap si: 每秒从交换区写到内存大小, 由磁盘调入内存 so: 每秒写入交换区的内存大小, 由内存调入磁盘 注意: 内存够用的时候，这2个值都是0*, 如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so, 如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的** IO (现在的Linux版本块的大小为1kb) bi: 每秒读取的块数 bo: 每秒写入的块数 注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。 System (系统) in: 每秒中断数, 包括时钟中断 cs: 每秒上下文切换数 注意: 上面2个值越大, 会看到由内核消耗的CPU时间会越大. CPU (以百分比表示) us: 用户进程执行时间百分比(user time) us的值比较高时, 说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速; sy: 内核系统进程执行时间百分比 (system time) sy的值高时, 说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因; wa: IO等待时间百分比 wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。 id: 空闲时间百分比"},{"title":"Linux 命令 「iostat」","date":"2018-07-23T06:39:13.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-23-Linux-cmd-iostat.html","permalink":"http://blog.caoxl.com/backup/2018-07-23-Linux-cmd-iostat.html","excerpt":"iostat命令被用于监视系统输入输出设备和CPU的使用情况。","text":"iostat命令被用于监视系统输入输出设备和CPU的使用情况。 它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析 语法1iostat (选项) (参数) 选项 -c: 仅显示CPU使用情况 -d: 仅显示设备利用率 -k: 显示状态以千字节每秒为单位, 而不使用块每秒 -m: 显示状态以兆字节每秒为单位, -p: 仅显示块设备和所有被使用的其他分区的状态 -t: 显示每个报告产生的时间 -V: 显示版号并退出 -x: 显示扩展状态 参数 间隔时间: 每次报告的间隔时间 (秒) 次数: 显示报告的次数 实例用 iostat -x /dev/sda1 来观看磁盘 I/O 的详细情况:1234567[root@caoxianliang ~]# iostat -x /dev/sda1Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.20 0.01 0.11 0.02 0.00 99.65Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util 详细说明: 第二行是系统信息和监测时间, 第三行和第四行显示CPU使用情况（具体内容和mpstat命令相同）。这里主要关注后面I/O输出的信息，如下所示: 参数说明: cpu属性值说明 %user - CPU处在用户模式下的时间百分比 %nice - CPU处在带NICE值的用户模式下的时间百分比 %system - CPU处在系统模式下的时间百分比 %iowait - CPU等待输入输出完成时间的百分比 %steal - 管理程序维护另一个虚拟处理器时, 虚拟CPU的无意识等待时间百分比 %idle - CPU空闲时间百分比 disk属性值说明 Device - 检测设备名称 rrqm/s - 每秒需要读取需求的数量 wrqm/s - 每秒需要写入需求的数量 r/s - 每秒实际读取需求的数量 w/s - 每秒实际写入需求的数量 rsec/s - 每秒读取区段的数量 wsec/s - 每秒写入区段的数量 rkB/s - 每秒实际读取的大小, 单位为KB wkB/s - 每秒实际写入的大小, 单位为KB avgqu-sz - 需求的平均大小区段 avgqu-sz - 需求的评价队列长度 await - 等待I/O平均的时间 svctm - I/O需求完成的平均时间 %util - 被I/O需求消耗的CPU百分比 定时显示所有信息1234567891011121314151617181920[root@caoxianliang ~]# iostat 2 3Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.20 0.01 0.11 0.02 0.00 99.65Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.85 1.55 5.30 1327517 4544968avg-cpu: %user %nice %system %iowait %steal %idle 0.00 0.00 0.00 0.00 0.00 100.00Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.00 0.00 0.00 0 0avg-cpu: %user %nice %system %iowait %steal %idle 0.00 0.00 0.00 0.00 0.00 100.00Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.00 0.00 0.00 0 0 每隔 2秒刷新显示，且显示3次 显示指定磁盘信息 iostat -d sda1 1234[root@caoxianliang ~]# iostat -d sda1Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtn 显示tty和cpu信息123456789[root@caoxianliang ~]# iostat -tLinux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)07/23/2018 03:48:46 PMavg-cpu: %user %nice %system %iowait %steal %idle 0.20 0.01 0.11 0.02 0.00 99.65Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.85 1.55 5.30 1327517 4544988 以M为单位显示所有信息12345678[root@caoxianliang ~]# iostat -mLinux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.20 0.01 0.11 0.02 0.00 99.66Device: tps MB_read/s MB_wrtn/s MB_read MB_wrtnvda 0.85 0.00 0.01 1296 4438 查看TPS和吞吐量信息12345[root@caoxianliang ~]# iostat -d -k 1 1Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.85 1.55 5.30 1327517 4544988 查看设备使用率(%util)、响应时间(await)12345[root@caoxianliang ~]# iostat -d -x -k 1 1Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.34 0.09 0.76 1.55 5.30 16.10 0.00 5.52 7.06 5.34 0.33 0.03 查看CPU状态1234567891011[root@caoxianliang ~]# iostat -c 1 3Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.20 0.01 0.11 0.02 0.00 99.66avg-cpu: %user %nice %system %iowait %steal %idle 0.00 0.00 0.00 0.00 0.00 100.00avg-cpu: %user %nice %system %iowait %steal %idle 0.00 0.00 0.00 0.00 0.00 100.00"},{"title":"Linux 命令 「sar」","date":"2018-07-23T04:00:09.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-23-Linux-cmd-sar.html","permalink":"http://blog.caoxl.com/backup/2018-07-23-Linux-cmd-sar.html","excerpt":"sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备","text":"sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备 sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据。取样数据和分析的结果都可以存入文件，使用它时消耗的系统资源很小 语法1sar (选项) (参数) 选项 -A: 显示所有的报告信息 -b: 显示I/O速率 -B: 显示进程创建活动 -c: 显示进程创建活动 -d: 显示每个块设备的状态 -e: 设置显示报告的结束时间 -f: 从指定文件提取报告 -i: 设状态信息刷新的间隔时间 -P: 报告每个CPU的状态 -R: 显示内存状态 -u: 显示CPU利用率 -v: 显示索引节点, 文件和其他内核表的状态 -w: 显示交换分区状态 -x: 显示给定进程的状态 参数 间隔时间: 每次报告的间隔时间 (秒) 次数: 显示报告的次数 实例察看内存和交换空间的使用率1234567[root@caoxianliang ~]# sar -rLinux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)12:00:01 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty12:10:01 AM 128632 886804 87.33 88516 552564 536796 52.86 461080 312884 20812:20:01 AM 128720 886716 87.32 88544 552572 536796 52.86 461088 312912 20812:30:01 AM 128704 886732 87.33 88584 552588 536796 52.86 461132 312920 292 观察系统部件10分钟, 并对数据进行排序123456[root@caoxianliang ~]# sar -o temp 60 10Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)02:24:19 PM CPU %user %nice %system %iowait %steal %idle02:24:34 PM all 0.13 0.00 0.13 0.00 0.00 99.73Average: all 0.13 0.00 0.13 0.00 0.00 99.73"},{"title":"Linux 命令 「find」","date":"2018-07-25T09:04:10.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-25-Linux-cmd-find.html","permalink":"http://blog.caoxl.com/backup/2018-07-25-Linux-cmd-find.html","excerpt":"find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多","text":"find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多 语法1find [PATH] [option] [action] 参数与时间有关的参数 mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件 mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名 mtime -n : 列出在n天之内（含n天本身）被更改过的文件名 newer file : 列出比file还要新的文件名 例如: 1find /root -mtime 0 # 在/root目录下查找今天之内有改动的文件 与用户或用户组名有关的参数 user name : 列出文件所有者为name的文件 group name : 列出文件所属用户组为name的文件 uid n : 列出文件所有者为用户ID为n的文件 gid n : 列出文件所属用户组为用户组ID为n的文件 例如: 1find /home/caoxl -user caoxl # 在目录/home/caoxl 中找出所有者为caoxl的文件 与文件权限及名称有关的参数 name filename ：找出文件名为filename的文件 size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件 tpye TYPE ：查找文件的类型为TYPE的文件 TYPE的值主要有：一般文件（f)、设备文件（b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）； perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755； perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示 perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示 例如: 123find / -name passwd # 查找文件名为passwd的文件find . -perm 0755 # 查找当前目录中文件权限为0755的文件find . -size +12k # 查找当前目录中大于12KB的文件, 注意c表示type"},{"title":"Linux 命令 「pstree」","date":"2018-07-24T06:57:39.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-24-Linux-cmd-pstree.html","permalink":"http://blog.caoxl.com/backup/2018-07-24-Linux-cmd-pstree.html","excerpt":"pstree命令以树状图的方式展现进程之间的派生关系，显示效果比较直观。","text":"pstree命令以树状图的方式展现进程之间的派生关系，显示效果比较直观。 语法1pstree (选项) 选项 -a: 显示每个程序的完整指令, 包含路径, 参数或是常驻服务的标示 -c: 不使用精简标示法 -G: 使用VT100终端机的列绘图字符 -h: 列出树状图时, 特别标明现在执行的程序 -H&lt;程序识别码&gt;: 此参数的效果和指定”-h”参数类似,但特别标明指定的程序 -l: 采用长列格式显示树状图 -n: 用程序识别码排序, 预设是以程序名称来排序 -p: 显示程序识别码 -u: 显示用户名称 -U: 使用UTF-8列绘图字符 -V: 显示版本信息 实例 pstree 12345678910111213141516171819202122[root@caoxianliang test]# pstreesystemd─┬─AliYunDun───15*[&#123;AliYunDun&#125;] ├─AliYunDunUpdate───3*[&#123;AliYunDunUpdate&#125;] ├─agetty ├─aliyun-service───6*[&#123;aliyun-service&#125;] ├─atd ├─auditd───&#123;auditd&#125; ├─crond ├─dbus-daemon ├─mysqld_safe───mysqld───15*[&#123;mysqld&#125;] ├─nginx───nginx ├─ntpd ├─php-fpm───2*[php-fpm] ├─polkitd───5*[&#123;polkitd&#125;] ├─python ├─rsyslogd───2*[&#123;rsyslogd&#125;] ├─screen───bash ├─sshd───sshd───bash───pstree ├─systemd-journal ├─systemd-logind ├─systemd-udevd └─tuned───4*[&#123;tuned&#125;] 显示当前所有进程的进程号和进程id 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[root@caoxianliang test]# pstree -psystemd(1)─┬─AliYunDun(17050)─┬─&#123;AliYunDun&#125;(17051) │ ├─&#123;AliYunDun&#125;(17052) │ ├─&#123;AliYunDun&#125;(17054) │ ├─&#123;AliYunDun&#125;(17055) │ ├─&#123;AliYunDun&#125;(17056) │ ├─&#123;AliYunDun&#125;(17057) │ ├─&#123;AliYunDun&#125;(17058) │ ├─&#123;AliYunDun&#125;(17059) │ ├─&#123;AliYunDun&#125;(17060) │ ├─&#123;AliYunDun&#125;(17061) │ ├─&#123;AliYunDun&#125;(17062) │ ├─&#123;AliYunDun&#125;(17063) │ ├─&#123;AliYunDun&#125;(17064) │ ├─&#123;AliYunDun&#125;(17072) │ └─&#123;AliYunDun&#125;(28696) ├─AliYunDunUpdate(787)─┬─&#123;AliYunDunUpdate&#125;(789) │ ├─&#123;AliYunDunUpdate&#125;(790) │ └─&#123;AliYunDunUpdate&#125;(797) ├─agetty(487) ├─aliyun-service(1475)─┬─&#123;aliyun-service&#125;(1478) │ ├─&#123;aliyun-service&#125;(1479) │ ├─&#123;aliyun-service&#125;(1480) │ ├─&#123;aliyun-service&#125;(1481) │ ├─&#123;aliyun-service&#125;(1482) │ └─&#123;aliyun-service&#125;(1483) ├─atd(480) ├─auditd(433)───&#123;auditd&#125;(434) ├─crond(481) ├─dbus-daemon(458) ├─mysqld_safe(12935)───mysqld(13453)─┬─&#123;mysqld&#125;(13455) │ ├─&#123;mysqld&#125;(13456) │ ├─&#123;mysqld&#125;(13457) │ ├─&#123;mysqld&#125;(13458) │ ├─&#123;mysqld&#125;(13459) │ ├─&#123;mysqld&#125;(13460) │ ├─&#123;mysqld&#125;(13461) │ ├─&#123;mysqld&#125;(13462) │ ├─&#123;mysqld&#125;(13463) │ ├─&#123;mysqld&#125;(13464) │ ├─&#123;mysqld&#125;(13466) │ ├─&#123;mysqld&#125;(13467) │ ├─&#123;mysqld&#125;(13468) │ ├─&#123;mysqld&#125;(13469) │ └─&#123;mysqld&#125;(13472) ├─nginx(17121)───nginx(17122) ├─ntpd(461) ├─php-fpm(1352)─┬─php-fpm(1353) │ └─php-fpm(1354) ├─polkitd(456)─┬─&#123;polkitd&#125;(464) │ ├─&#123;polkitd&#125;(465) │ ├─&#123;polkitd&#125;(473) │ ├─&#123;polkitd&#125;(475) │ └─&#123;polkitd&#125;(478) ├─python(1175) ├─rsyslogd(712)─┬─&#123;rsyslogd&#125;(750) │ └─&#123;rsyslogd&#125;(1383) ├─screen(1697)───bash(1698) ├─sshd(1444)───sshd(1685)───bash(1688)───pstree(2250) ├─systemd-journal(319) ├─systemd-logind(470) ├─systemd-udevd(342) └─tuned(704)─┬─&#123;tuned&#125;(1395) ├─&#123;tuned&#125;(1396) ├─&#123;tuned&#125;(1397) └─&#123;tuned&#125;(1410) 显示所有进程的所有详细信息，遇到相同的进程名可以压缩显示。 123456789101112131415161718192021222324252627282930313233343536373839[root@caoxianliang test]# pstree -asystemd --switched-root --system --deserialize 22 ├─AliYunDun │ └─15*[&#123;AliYunDun&#125;] ├─AliYunDunUpdate │ └─3*[&#123;AliYunDunUpdate&#125;] ├─agetty --noclear tty1 linux ├─aliyun-service │ └─6*[&#123;aliyun-service&#125;] ├─atd -f ├─auditd │ └─&#123;auditd&#125; ├─crond -n ├─dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation ├─mysqld_safe /usr/local/mysql/bin/mysqld_safe --datadir=/usr/local/mysql/var ... │ └─mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var--plugin-dir=/usr/local/mysql/lib/plugi │ └─15*[&#123;mysqld&#125;] ├─nginx │ └─nginx ├─ntpd -u ntp:ntp -g ├─php-fpm │ ├─php-fpm ... │ └─php-fpm ... ├─polkitd --no-debug │ └─5*[&#123;polkitd&#125;] ├─python /usr/local/shadowsocks/server.py -c /etc/shadowsocks.json -d start ├─rsyslogd -n │ └─2*[&#123;rsyslogd&#125;] ├─screen │ └─bash ├─sshd -D │ └─sshd │ └─bash │ └─pstree -a ├─systemd-journal ├─systemd-logind ├─systemd-udevd └─tuned -Es /usr/sbin/tuned -l -P └─4*[&#123;tuned&#125;]"},{"title":"Linux 命令 「time」","date":"2018-07-25T09:30:16.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-25-Linux-cmd-time.html","permalink":"http://blog.caoxl.com/backup/2018-07-25-Linux-cmd-time.html","excerpt":"time命令用于测算一个命令（即程序）的执行时间","text":"time命令用于测算一个命令（即程序）的执行时间 语法1time command 实例1234567[root@caoxianliang /]# time lsbin data etc lib lnmp1.4 media opt root sbin sys usrboot dev home lib64 lost+found mnt proc run srv tmp varreal 0m0.002suser 0m0.000ssys 0m0.002s 说明: real: 实际实际, 从command命令行开始执行到运行终止的消逝时间 user: 用户CPU时间, 命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和 sys: 系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和 用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。"},{"title":"Linux 命令 「ss」","date":"2018-07-24T07:23:36.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-24-Linux-cmd-ss.html","permalink":"http://blog.caoxl.com/backup/2018-07-24-Linux-cmd-ss.html","excerpt":"ss命令用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。","text":"ss命令用来显示处于活动状态的套接字信息。ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。 天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag, ss也可以正常运行，只是效率会变得稍慢。 TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字(socket)或插口。 语法1ss (选项) 选项 -h: 显示帮助信息 -V: 显示指令版本信息 -n: 不解析服务名称, 以数字方式显示 -a: 显示所有的套接字 -l: 显示处于监听状态的套接字 -o: 显示计时器信息 -m: 显示套接字的内存使用情况 -p: 显示使用套接字的进程信息 -i: 显示内部的TCP信息 -4: 只显示ipv4的套接字 -6: 只显示ipv6的套接字 -t: 只显示tcp套接字 -u: 只显示udp套接字 -d: 只显示DCCP套接字 -w: 仅显示RAW套接字 -x: 仅显示UNIX域套接字 实例显示ICP连接12345678910[root@caoxianliang ~]# ss -t -aState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 *:https *:* LISTEN 0 128 127.0.0.1:cslistener *:* LISTEN 0 50 *:mysql *:* LISTEN 0 128 *:http *:* LISTEN 0 128 *:ssh *:* ESTAB 0 0 172.31.45.94:43842 106.11.248.51:http ESTAB 0 232 172.31.45.94:ssh 59.41.94.230:44067 LISTEN 0 128 :::smc-https :::* 显示Sockets摘要1234567891011[root@caoxianliang ~]# ss -sTotal: 107 (kernel 192)TCP: 9 (estab 2, closed 1, orphaned 0, synrecv 0, timewait 0/0), ports 0Transport Total IP IPv6* 192 - - RAW 0 0 0 UDP 6 4 2 TCP 8 7 1 INET 14 11 3 FRAG 0 0 0 列出所有打开的网络连接端口123456789101112[root@caoxianliang ~]# ss -lNetid State Recv-Q Send-Q Local Address:Port Peer Address:Port nl UNCONN 0 0 rtnl:ntpd/461 * nl UNCONN 0 0 rtnl:kernel * nl UNCONN 0 0 rtnl:ntpd/461 * nl UNCONN 4352 0 tcpdiag:ss/4090 * nl UNCONN 768 0 tcpdiag:kernel * nl UNCONN 0 0 xfrm:kernel * nl UNCONN 0 0 selinux:kernel * nl UNCONN 0 0 audit:auditd/433 * nl UNCONN 0 0 audit:kernel * ... 查看进程使用的Sockets12345678910[root@caoxianliang ~]# ss -plNetid State Recv-Q Send-Q Local Address:Port Peer Address:Port nl UNCONN 0 0 rtnl:ntpd/461 * nl UNCONN 0 0 rtnl:kernel * nl UNCONN 0 0 rtnl:ntpd/461 * nl UNCONN 4352 0 tcpdiag:ss/4149 * nl UNCONN 768 0 tcpdiag:kernel * nl UNCONN 0 0 xfrm:kernel * nl UNCONN 0 0 selinux:kernel * nl UNCONN 0 0 audit:auditd/433 * 找到打开套接字/端口应用程序12[root@caoxianliang ~]# ss -pl | grep 80u_str LISTEN 0 50 /tmp/mysql.sock 901802 * 0 users:((\"mysqld\",pid=13453,fd=14)) 显示所有的UDP Sockets12345678[root@caoxianliang ~]# ss -u -aState Recv-Q Send-Q Local Address:Port Peer Address:Port UNCONN 0 0 *:37916 *:* UNCONN 0 0 172.31.45.94:ntp *:* UNCONN 0 0 127.0.0.1:ntp *:* UNCONN 0 0 *:ntp *:* UNCONN 0 0 :::ntp :::* UNCONN 0 0 :::smc-https :::*"},{"title":"Linux 命令 「traceroute」","date":"2018-07-26T01:15:12.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-26-Linux-cmd-traceroute.html","permalink":"http://blog.caoxl.com/backup/2018-07-26-Linux-cmd-traceroute.html","excerpt":"traceroute命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是60字节。","text":"traceroute命令用于追踪数据包在网络上的传输时的全部路径，它默认发送的数据包大小是60字节。 通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其ip地址。 语法1traceroute (选项) (参数) 选项 -d: 使用Socket层级的排错功能 -f&lt;存货数值&gt;: 设置第一个检测数据包的存活数值TTL的大小 -F: 设置勿离断位 -g&lt;网关&gt;: 设置来源路由网关, 最多可设置8个 -i&lt;网络界面&gt;: 使用指定的网络界面送出数据包 -I: 使用ICMP回应取代UDP资料信息 -m&lt;存活数值&gt;: 设置检测数据包的最大存活数值TTL的大小 -n: 直接使用IP地址而非主机名称 -p&lt;通信端口&gt;: 设置UDP传输协议的通信端口 -r: 忽略普通的Routing Table, 直接将数据包送到远端主机上 -s&lt;来源地址&gt;: 设置本地主机送出数据包的IP地址 -t&lt;服务类型&gt;: 设置检测数据包的TOS数值 -v: 详细显示指令的执行过程 -w&lt;超时秒数&gt;: 设置等待远端主机回报的时间 -x: 开启或关闭数据包的正确性检验 参数 主机: 指定目的主机IP地址或主机名 实例 www.caoxl.com 1234567891011121314151617181920212223242526272829303132[root@caoxianliang ~]# traceroute www.caoxl.comtraceroute to www.caoxl.com (47.91.221.85), 30 hops max, 60 byte packets 1 * * * 2 * * * 3 * * * 4 * * * 5 * * * 6 * * * 7 * * * 8 * * * 9 * * *10 * * *11 * * *12 * * *13 * * *14 * * *15 * * *16 * * *17 * * *18 * * *19 * * *20 * * *21 * * *22 * * *23 * * *24 * * *25 * * *26 * * *27 * * *28 * * *29 * * *30 * * * www.baidu.com 1234567891011121314151617181920212223242526272829303132[root@caoxianliang ~]# traceroute www.baidu.comtraceroute to www.baidu.com (103.235.46.39), 30 hops max, 60 byte packets 1 * * * 2 11.211.16.5 (11.211.16.5) 6.214 ms 11.211.20.1 (11.211.20.1) 9.277 ms 9.461 ms 3 11.211.20.122 (11.211.20.122) 1.062 ms 11.211.20.118 (11.211.20.118) 1.140 ms 11.211.20.154 (11.211.20.154) 1.073 ms 4 116.251.72.162 (116.251.72.162) 1.486 ms 116.251.118.198 (116.251.118.198) 1.475 ms 116.251.74.154 (116.251.74.154) 1.492 ms 5 p55967.hkg.equinix.com (119.27.63.97) 1.377 ms 116.251.65.85 (116.251.65.85) 2.208 ms p55967.hkg.equinix.com (119.27.63.97) 1.263 ms 6 103.235.45.0 (103.235.45.0) 3.442 ms p55967.hkg.equinix.com (119.27.63.97) 1.669 ms s55967.hkg.equinix.com (119.27.63.98) 1.970 ms 7 * 103.235.45.0 (103.235.45.0) 2.189 ms * 8 * * * 9 * * *10 * * *11 * * *12 * * *13 * * *14 * * *15 * * *16 * * *17 * * *18 * * *19 * * *20 * * *21 * * *22 * * *23 * * *24 * * *25 * * *26 * * *27 * * *28 * * *29 * * *30 * * * 记录按序列号从1开始，每个纪录就是一跳 ，每跳表示一个网关，我们看到每行有三个时间，单位是ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间； 如果用traceroute -q 4 www.58.com, 表示向每个网关发送4个数据包。 有时我们traceroute一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。 有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n参数来避免DNS解析，以IP格式输出数据。"},{"title":"Linux 命令 「gzip」","date":"2018-07-27T02:26:24.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-27-Linux-cmd-gzip.html","permalink":"http://blog.caoxl.com/backup/2018-07-27-Linux-cmd-gzip.html","excerpt":"gzip命令用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。","text":"gzip命令用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。 据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。 语法1gzip (选项) (参数) 选项 -a/--ascii: 使用ASCII文件模式 -d/--decompress/--uncompress: 解开压缩文件 -f/--force: 强行压缩文件,不理会文件名称或硬连接是否存在以及该文件是否为符号连接 -h/--help: 在线帮助 -l/--list: 列出压缩文件的相关信息 -L/--license: 显示版本与版权信息 -n/--no-name: 压缩文件时, 不保存原来的文件名称及时间戳 -N/--name: 压缩文件时, 保存原来的文件名称及时间戳 -q/--quiet: 不显示警告信息 -r/--recursive: 递归处理, 将指定目录下的所有文件及子目录一并处理 -S: 更改压缩字尾字符串 -t/--test: 测试压缩文件是否正确无误 -v/--verbose: 显示指令执行过程 -V/--version: 显示版本信息 &lt;压缩效率&gt;：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高 --best: 此参数的效果和指定”-9”参数相同 --fast: 此参数的效果和指定”-1”参数相同 参数 文件列表: 指定要压缩的文件列表 实例 把test目录下的每个文件压缩成.gz文件 1gzip * 把上例中每个压缩的文件解压，并列出详细的信息 1gzip -dv * 详细显示例1中每个压缩的文件的信息，并不解压 1gzip -l * 压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz 1gzip -r log.tar 递归的压缩目录 1gzip -rv test 递归地解压目录 1gzip -dr test"},{"title":"Linux 命令 「tar」","date":"2018-07-27T01:30:19.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-27-Linux-cmd-tar.html","permalink":"http://blog.caoxl.com/backup/2018-07-27-Linux-cmd-tar.html","excerpt":"利用tar命令，可以把一大堆的文件和目录全部打包成一个文件 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。","text":"利用tar命令，可以把一大堆的文件和目录全部打包成一个文件 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 语法1tar (选项) (参数) 选项 -A/--catenate: 新增文件到已存在的备份文件 -B: 设置区块大小 -c/--create: 建立新的备份文件 -C&lt;目录&gt;: 这个选项用在解压缩 若要在特定目录解压缩, 可以使用这个选项 -d: 记录文件的差别 -x/--extract/--get: 从备份文件中还原文件 -t/--list: 列出备份文件的内容 -z/--gzip/--ungzip: 通过gzip指令处理备份文件 -Z/--compress/--uncompress: 通过compress指令处理备份文件 -f&lt;备份文件&gt;/--file=&lt;备份文件&gt;: 指定备份文件 -v/--verbose: 显示指令执行过程 -u: 添加改变了和现有的文件到已经存在的压缩文件 -j: 支持bzip2解压文件 -v: 显示操作过程 -l: 文件系统边界设置 -k: 保留原有文件不覆盖 -m: 保留文件不被覆盖 -w: 确认压缩文件的正确性 -p/--same-permissions: 用原来的文件权限还原文件 -p/--absolute-names: 文件名使用绝对名称, 不移除文件名称钱的”/“号 -N&lt;日期格式&gt; / --newer=&lt;日期时间&gt;: 只将较指定日期更新的文件保存到备份文件里 --exclude=&lt;范本样式&gt;: 排除符合范本样式的文件 参数 文件或目录: 指定要打包的文件或目录列表 实例将文件全部打包成tar包 仅打包, 不压缩 1tar -cvf log.tar log.log 打包后, 以 gzip 压缩 1tar -zcvf log.tar.gz log.log 打包后, 以 bzip2 压缩 1tar -jcvf log.tar.ba2 log.log 查阅上诉tar包内有哪些文件1tar -ztcf log.tar.gz 将tar包解压缩1tar -zxvf /test/log.tar.gz 只将tar内的部分文件解压出来1tar -zxvf /test/log.tar.gz log.log 文件备份下来, 并且保存其权限1tar -zcvpf log.tar.gz log2017.log log2018.log 在文件夹中, 比某个日期新的文件才备份1tar -N \"2018/06/17\" -zcvf log18.tar.gz test 备份文件夹内容是排除部分文件1tar --exclude scf/service -zcvf scf.tar.fz scf/* 最简单的使用 tar 压缩 1tar -jcv -f filename/tar/bz2 要被压缩的文件或目录名称 解压缩 1tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 查询 1tar -jtv -f filename.tar.bz2"},{"title":"Linux 命令 「type」","date":"2018-08-08T08:43:20.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-08-08-Linux-cmd-type.html","permalink":"http://blog.caoxl.com/backup/2018-08-08-Linux-cmd-type.html","excerpt":"type命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。","text":"type命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。 命令类型 alias: 别名 keyword: 关键字, Shell保留字 function: 函数, Shell函数 builtin: 内建命令, Shell内建命令 file: 文件, 磁盘文件, 外部命令 unfound: 没有找到 语法1type (选项) (参数) 选项 -t: 删除”file”、”alias”或者”builtin”, 分别表示给定的指令为”外部指令”、”命令别名”或者”内部指令” -p: 如果给出的指令为外部指令, 则显示其绝对路径 -a: 在环境变量”PATH”指定的路径中, 显示给定指令的信息, 包括命令别名 参数 指令: 要显示类型的指令 实例 type 12345678910111213141516171819202122232425[root@caoxl ~]# type lsls is aliased to `ls --color=auto'[root@caoxl ~]# type cdcd is a shell builtin[root@caoxl ~]# type datedate is /usr/bin/date[root@caoxl ~]# type mysqlmysql is /usr/bin/mysql[root@caoxl ~]# type ifif is a shell keyword[root@caoxl ~]# type whichwhich is aliased to `alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'[root@caoxl ~]# type -a cdcd is a shell builtincd is /usr/bin/cd[root@caoxl ~]# type -a grepgrep is aliased to `grep --color=auto'grep is /usr/bin/grep type -t 123456[root@caoxl ~]# type -t lsalias[root@caoxl ~]# type -t ifkeyword[root@caoxl ~]# type -t typebuiltin"},{"title":"Linux 命令 「zip」","date":"2018-07-27T02:48:07.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-07-27-Linux-cmd-zip.html","permalink":"http://blog.caoxl.com/backup/2018-07-27-Linux-cmd-zip.html","excerpt":"zip命令可以用来解压缩文件，或者对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。","text":"zip命令可以用来解压缩文件，或者对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。 语法1zip (选项) (参数) 选项 -A: 调整可执行的自动解压缩文件 -b&lt;工作目录&gt;: 指定暂时存放文件的目录 -c: 替每个被压缩的文件加上注释 -d: 从压缩文件内删除指定的文件 -D: 压缩文件内不建立目录名称 -f: 此参数的效果和指定”-u”参数类似 -F: 尝试修复已损坏的压缩文件 -g: 将文件压缩后附件在已有的压缩文件之后, 而非另行建立新的压缩文件 -h: 在线帮助 -i&lt;范本样式&gt;: 只压缩符合条件的文件 -j: 只保存文件名称及其内容, 而不存放任何目录名称 -J: 删除压缩文件前面不必要的数据 -k: 使用MS-DOS兼容格式的文件名称 -l: 压缩文件时, 把LF字符置换成LF+CR字符 -ll: 压缩文件时, 把LF+cp字符置换成LF字符 -L: 显示版权信息 -m: 将文件压缩并加入压缩文件后, 删除原始文件, 即把文件移到压缩文件中 -n&lt;字尾字符串&gt;: 不压缩具有特定字尾字符串的文件 -o: 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同 -q: 不显示指令执行过程 -r: 递归处理，将指定目录下的所有文件和子目录一并处理 -S:包含系统和隐藏文件 -t&lt;日期时间&gt;: 把压缩文件的日期设成指定的日期 -T: 检查备份文件内的每个文件是否正确无误 -u: 更换较新的文件到压缩文件内 -v: 显示指令执行过程或显示版本信息 -V: 保存VMS操作系统的文件属性 -w: 在文件名称里假如版本编号，本参数仅在VMS操作系统下有效 -x&lt;范本样式&gt;: 压缩时排除符合条件的文件 -X: 不保存额外的文件属性 -y: 直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效 -z: 替压缩文件加上注释 -$: 保存第一个被压缩文件所在磁盘的卷册名称 -&lt;压缩效率&gt;: 压缩效率是一个介于1~9的数值。 参数 zip压缩包: 指定要创建的zip压缩包 文件列表: 指定要压缩的文件列表 实例 将/home/html/这个目录下所有文件和文件夹打包为当前目录下的html.zip 1zip -q -r html.zip /home/html 比如现在我的html目录下，我操作的zip压缩命令是 1zip -q -r html.zip *"},{"title":"Linux 命令 「ifconfig/ifup/ifdown」","date":"2018-08-03T01:49:41.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-08-03-Linux-cmd-ifconfig-ifup-ifdown.html","permalink":"http://blog.caoxl.com/backup/2018-08-03-Linux-cmd-ifconfig-ifup-ifdown.html","excerpt":"ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数","text":"ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数 ifconfig语法1ifconfig (参数) 常见参数 add&lt;地址&gt;: 设置网络设备IPv6的IP地址 del&lt;地址&gt;: 删除网络设备IPv6的IP地址 down: 关闭指定的网络设备 io_addr&lt;I/O地址&gt;: 设置网络设备的I/O地址 up: 启动指定的网络设备 IP地址: 指定网络设备的IP地址 网络设备: 指定网络设备的名称 实例显示网络设备信息(激活状态的):12345678910111213141516[root@caoxl ~]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.45.94 netmask 255.255.240.0 broadcast 172.31.47.255 ether 00:16:3e:01:a4:4f txqueuelen 1000 (Ethernet) RX packets 4367 bytes 1362027 (1.2 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 4090 bytes 1498312 (1.4 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 36 bytes 4896 (4.7 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 36 bytes 4896 (4.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 说明: eth0表示第一块网卡，其中ether表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址） 是00:16:3e:01:a4:4f inet用来表示网卡的IP地址，此网卡的IP地址是172.31.45.94，广播地址broadcast:172.31.47.255，掩码地址netmask:255.255.240.0。 lo是表示主机的回环地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 httpd服务器的指定到回环地址，在浏览器输入127.0.0.1就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。 第一行: UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节 第二行: 网卡的IP地址、掩码地址 第三行: 第四、五行: 接收数据包情况统计 第六、七行: 发送数据包情况统计 启动关闭指定网卡:12ifconfig eth0 up // 启动网卡eth0ifconfig eth0 down // 关闭网卡eth0 ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。 为网卡配置和删除IPv6地址:12ifconfig eth0 add 33ffe:3240:800:1005::2/64 # 为网卡eth0配置IPv6地址ifconfig eth0 del 33ffe:3240:800:1005::2/64 # 为网卡eth0配置IPv6地址 用ifconfig修改MAC地址:1ifconfig eth0 hw ether 00:AA:BB:CC:dd:EE 配置IP地址:123ifconfig eth0 192.168.2.10ifconfig eth0 192.168.2.10 netmask 255.255.255.0ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255 启用和关闭arp协议:12ifconfig eth0 arp # 开启网卡eth0的arp协议ifconfig eth0 -arp # 关闭网卡eth0的arp协议 设置最大传输单元:1ifcongig eth mtu 1500 # 设置能通过的最大数据包大小为 1500 bytes ifup ifup命令用于激活指定的网络接口。 语法1ifup (参数) 参数 网络接口: 要激活的网络接口 实例1ifup eth0 # 激活eth0 ifdown ifdown命令用于禁用指定的网络接口。 语法1ifdown (参数) 参数 网络接口: 要禁用的网络接口 实例1ifdown eth0 # 禁用eth0"},{"title":"Linux 命令 「echo」","date":"2018-08-07T01:13:47.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-08-07-Linux-cmd-echo.html","permalink":"http://blog.caoxl.com/backup/2018-08-07-Linux-cmd-echo.html","excerpt":"echo命令用于在shell中打印shell变量的值，或者直接输出指定的字符串。","text":"echo命令用于在shell中打印shell变量的值，或者直接输出指定的字符串。 越简单的东西, 越容易被忽视. 语法1echo (选项) (参数) 选项1-e: 激活转义字符 使用 -e选项时, 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出: \\a: 发出警告声 \\b: 删除前一个字符 \\c: 最后不加上换行符号 \\f: 换行但光标仍旧停留在原来的位置 \\n: 换行且光标移至行首 \\r: 光标移至行首, 但不换行 \\t: 插入tab \\v: 与\\f相同 \\\\: 插入\\字符 \\nnn: 插入nnn(八进制)所代表的ASCII字符 参数 变量: 指定要打印的变量 实例用echo命令打印带有色彩的文字文字色:12[root@caoxl ~]# echo -e &quot;\\e[1;31mThis is red text\\e[0m&quot;This is red text \\e[1;31m: 将颜色设置为红色 \\e[0m: 将颜色重新置回 颜色码：重置=0，黑色=30，红色=31，绿色=32，黄色=33，蓝色=34，洋红=35，青色=36，白色=37 例如: 12345678echo -e \"\\033[30m 黑色字 \\033[0m\"echo -e \"\\033[31m 红色字 \\033[0m\"echo -e \"\\033[32m 绿色字 \\033[0m\"echo -e \"\\033[33m 黄色字 \\033[0m\"echo -e \"\\033[34m 蓝色字 \\033[0m\"echo -e \"\\033[35m 紫色字 \\033[0m\"echo -e \"\\033[36m 天蓝字 \\033[0m\"echo -e \"\\033[37m 白色字 \\033[0m\" 背景色:12[root@caoxl ~]# echo -e \"\\e[1;42mGreed Background\\e[0m\"Greed Background 颜色码：重置=0，黑色=40，红色=41，绿色=42，黄色=43，蓝色=44，洋红=45，青色=46，白色=47 例如: 12345678echo -e \"\\033[40;37m 黑底白字 \\033[0m\"echo -e \"\\033[41;37m 红底白字 \\033[0m\"echo -e \"\\033[42;37m 绿底白字 \\033[0m\"echo -e \"\\033[43;37m 黄底白字 \\033[0m\"echo -e \"\\033[44;37m 蓝底白字 \\033[0m\"echo -e \"\\033[45;37m 紫底白字 \\033[0m\"echo -e \"\\033[46;37m 天蓝底白字 \\033[0m\"echo -e \"\\033[47;30m 白底黑字 \\033[0m\" 文字闪动:12[root@caoxl ~]# echo -e \"\\033[37;31;5mMySQL Server Stop...\\033[39;49;0m\"MySQL Server Stop... 红色数字处还有其他数字参数：0 关闭所有属性、1 设置高亮度（加粗）、4 下划线、5 闪烁、7 反显、8 消隐 控制选项说明: 12345678910111213141516171819\\33[0m 关闭所有属性 \\33[1m 设置高亮度 \\33[4m 下划线 \\33[5m 闪烁 \\33[7m 反显 \\33[8m 消隐 \\33[30m -- \\33[37m 设置前景色 \\33[40m -- \\33[47m 设置背景色 \\33[nA 光标上移n行 \\33[nB 光标下移n行 \\33[nC 光标右移n行 \\33[nD 光标左移n行 \\33[y;xH设置光标位置 \\33[2J 清屏 \\33[K 清除从光标到行尾的内容 \\33[s 保存光标位置 \\33[u 恢复光标位置 \\33[?25l 隐藏光标 \\33[?25h 显示光标 使用\\a选项 -e后面跟上\\a选项会听到声音警告。 12[root@caoxl ~]# echo -e \"Tecmint is a community of \\aLinux Nerds\" Tecmint is a community of Linux Nerds"},{"title":"Linux 命令 「sftp」","date":"2018-08-13T09:24:19.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-08-13-Linux-cmd-sftp.html","permalink":"http://blog.caoxl.com/backup/2018-08-13-Linux-cmd-sftp.html","excerpt":"sftp命令是一款交互式的文件传输程序，命令的运行和使用方式与ftp命令相似，但是，sftp命令对传输的所有信息使用ssh加密，它还支持公钥认证和压缩等功能。","text":"sftp命令是一款交互式的文件传输程序，命令的运行和使用方式与ftp命令相似，但是，sftp命令对传输的所有信息使用ssh加密，它还支持公钥认证和压缩等功能。 语法1sftp (选项) (参数) 选项 -B: 指定传输文件时缓冲区的大小 -l: 使用ssh协议版本1 -b: 指定批处理文件 -C: 使用压缩 -o: 指定ssh选项 -F: 指定ssh配置文件 -R: 指定一次可以容忍多少请求数 -v: 升高日志等级 参数 目标主机: 指定sftp服务器ip地址或者主机名"},{"title":"Linux 命令 「axel」","date":"2018-08-10T07:40:14.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-08-10-Linux-cmd-axel.html","permalink":"http://blog.caoxl.com/backup/2018-08-10-Linux-cmd-axel.html","excerpt":"axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件","text":"axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件 安装 CentOS 1yum install axel Debian/Ubuntu 1apt-get install axel 语法1axel 选项 url1 [url2] [url...] 选项 --max-speed=x/-s x 最高速度x --num-connections=x/-n x 连接数x --output=f/-o f 下载为本地文件f --search[=x],-S [x] 搜索镜像 --header=x/-H x 添加头文件字符串x --user-agent=x/-U x 设置用户代理 --no-proxy/-N 不使用代理服务器 --quiet/-q 静默模式 --verbose/-v 更多状态信息 --alternate/-a 交替进度指示器 --help/-h 帮助 --version/-V 版本信息 实例 如下载LNMP安装包指定10个线程，存到/tmp/: 1axel -n 10 -o /tmp/ http://www.linuxde.net/lnmp.tar.gz 如果下载过程中下载中断可以再执行下载命令即可恢复上次的下载进度。"},{"title":"Linux 命令 「scp」","date":"2018-08-13T09:08:14.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-08-13-Linux-cmd-scp.html","permalink":"http://blog.caoxl.com/backup/2018-08-13-Linux-cmd-scp.html","excerpt":"scp命令用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。","text":"scp命令用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 语法1scp (选项) (参数) 选项 -1: 使用ssh协议版本1; -2: 使用ssh协议版本2; -4: 使用ipv4; -6: 使用ipv6; -B: 以批处理模式运行; -C: 使用压缩; -F: 指定ssh配置文件; -l: 指定宽带限制; -o: 指定使用的ssh选项 -P: 指定远程主机的端口号 -p: 保留文件的最后修改时间, 最后访问时间和权限模式 -q: 不显示复制进度 -r: 以递归方式复制 参数 源文件: 指定要复制的源文件 目标文件: 目标文件, 格式为user@host:filename（文件名为目标文件的名称） 实例从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。 从远程复制文件到本地目录1scp root@10.10.10.10:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/ 从10.10.10.10机器上的/opt/soft/的目录中下载nginx-0.5.38.tar.gz 文件到本地/opt/soft/目录中。 从远程复制到本地1scp -r root@10.10.10.10:/opt/soft/mongodb /opt/soft/ 从10.10.10.10机器上的/opt/soft/中下载mongodb目录到本地的/opt/soft/目录来。 上传本地文件到远程机器指定目录1scp /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/scptest 复制本地/opt/soft/目录下的文件nginx-0.5.38.tar.gz到远程机器10.10.10.10的opt/soft/scptest目录。 上传本地目录到远程机器指定目录1scp -r /opt/soft/mongodb root@10.10.10.10:/opt/soft/scptest 上传本地目录/opt/soft/mongodb到远程机器10.10.10.10上/opt/soft/scptest的目录中去"},{"title":"Linux cmd 「ln」","date":"2018-11-15T06:40:07.000Z","updated":"2018-11-15T06:54:27.000Z","comments":true,"path":"backup/2018-11-15-Linux-cmd-ln.html","permalink":"http://blog.caoxl.com/backup/2018-11-15-Linux-cmd-ln.html","excerpt":"ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用”-s”选项。","text":"ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用”-s”选项。 简介Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 软链接 软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 软链接可以 跨文件系统 ，硬链接不可以 软链接可以对一个不存在的文件名进行链接 软链接可以对目录进行链接 硬链接 硬链接，以文件副本的形式存在。但不占用实际空间。 不允许给目录创建硬链接 硬链接只有在同一个文件系统中才能创建 语法1ln(选项)(参数) 常用选项 -b: 删除，覆盖以前建立的链接 -d: 允许超级用户制作目录的硬链接 -f: 强制执行 -i: 交互模式，文件存在则提示用户是否覆盖 -n: 把符号链接视为一般目录 -s: 软链接(符号链接) -v: 显示详细的处理过程 参数 源文件：指定连接的源文件。如果使用-s选项创建符号连接，则“源文件”可以是文件或者目录。创建硬连接时，则“源文件”参数只能是文件； 目标文件：指定源文件的目标连接文件。 实例 同一个服务器下多个PHP共存 123456789ln -s /usr/local/php/php72/bin/php /usr/local/bin/phpln -s /usr/local/php/php56/bin/php /usr/local/bin/php56cd /usr/local/bin[root@caoxl bin]# lltotal 1.8Mlrwxrwxrwx 1 root root 28 Nov 15 11:45 php -&gt; /usr/local/php/php72/bin/phplrwxrwxrwx 1 root root 28 Nov 15 11:29 php56 -&gt; /usr/local/php/php56/bin/php"},{"title":"Linux 命令 「dmidecode」","date":"2018-08-17T01:11:46.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"backup/2018-08-17-Linux-cmd-dmidecode.html","permalink":"http://blog.caoxl.com/backup/2018-08-17-Linux-cmd-dmidecode.html","excerpt":"dmidecode命令可以让你在Linux系统下获取有关硬件方面的信息。dmidecode的作用是将DMI数据库中的信息解码，以可读的文本方式显示。由于DMI信息可以人为修改，因此里面的信息不一定是系统准确的信息。dmidecode遵循SMBIOS/DMI标准，其输出的信息包括BIOS、系统、主板、处理器、内存、缓存等等。","text":"dmidecode命令可以让你在Linux系统下获取有关硬件方面的信息。dmidecode的作用是将DMI数据库中的信息解码，以可读的文本方式显示。由于DMI信息可以人为修改，因此里面的信息不一定是系统准确的信息。dmidecode遵循SMBIOS/DMI标准，其输出的信息包括BIOS、系统、主板、处理器、内存、缓存等等。 语法1dmidecode [选项] 选项 -d: (default:/dev/mem)从设备文件读取信息, 输出内容与不加参数的标准输出相同 -h: 显示帮助信息 -s: 只显示指定DMI字符串的信息 (string) -t: 只显示指定条目的信息 (type) -u: 显示未解码的原始条目内容 --dump-bin file: 将DMI数据转储到一个二进制文件中 --from-dump FILE: 从一个二进制文件读取DMI数据 -V: 显示版本信息 dmidecode参数string及type列表：（1）Valid string keywords are： bios-vendor (BIOS供应商) bios-version (BIOS版本) bios-release-date (BIOS发行时间) system-manufacturer (系统制造商) system-product-name (系统产品名称) system-version (系统版本) system-serial-number (系统序列号) system-uuid (系统UUID) baseboard-manufacturer (主板motherboard制造商) baseboard-product-name (主板motherboard产品名称) baseboard-version (主板motherboard版本) baseboard-serial-number (主板motherboard序列号) baseboard-asset-tag (主板motherboard资产标签) chassis-manufacturer (机箱制造商) chassis-type (机箱类型) chassis-version (机箱版本) chassis-serial-number (机箱序列号) chassis-asset-tag (机箱资产标签) processor-family (处理器家族) processor-manufacturer (处理器的制造商) processor-version (处理器版本) processor-frequency (处理器的频率) （2）Valid type keywords are： bios (BIOS) system (系统) baseboard (主板) chassis (机箱) processor (处理器) memory (内存) Cache (缓存) connector (连接器) slot (插槽) （3）type全部编码列表： BIOS (BIOS) System (系统) Base Board (主板) Chassis (机箱) Processor (处理器) Memory Controller (内存控制器) Memory Module (内存模块) Cache (高速缓存) Port Connector (端口连接器) System Slots (系统插槽) On Board Devices (在线设备) OEM Strings (OEM字符串) System Configuration Options (系统配置选项) BIOS Language (BIOS 语言) Group Associations (集团协会) System Event Log (系统事件日志) Physical Memory Array (物理内存阵列) Memory Device (记忆装置) 32-bit Memory Error (32位内存错误) Memory Array Mapped Address (内存阵列映射地址) Memory Device Mapped Address (内存设备映射地址) Built-in Pointing Device (内置指针设备) Portable Battery (便携式电池) System Reset (系统重置) Hardware Security (硬件安全) System Power Controls (系统电源控制) Voltage Probe (电压探头) Cooling Device (冷却装置) Temperature Probe (温度探头) Electrical Current Probe (电流探头) Out-of-band Remote Access (带外远程访问) Boot Integrity Services (启动完整性服务) System Boot (系统启动) 64-bit Memory Error (64位内存错误) Management Device (管理设备) Management Device Component (管理设备组件) Management Device Threshold Data (管理设备阈值数据) Memory Channel (记忆频道) IPMI Device (IPMI设备) Power Supply (电源) Additional Information (附加信息) Onboard Device (板载设备) 实例 查看服务器型号: 12[root@caoxl ~]# dmidecode | grep 'Product Name' Product Name: Alibaba Cloud ECS 查主板的序列号: 12345[root@caoxl ~]# dmidecode |grep 'Serial Number' Serial Number: ff1e4090-65f1-4fba-882d-ab08dc1e9119 Serial Number: Not Specified Serial Number: Not Specified Serial Number: Not Specified 查看系统序列号: 12[root@caoxl ~]# dmidecode -s system-serial-numberff1e4090-65f1-4fba-882d-ab08dc1e9119 查看内存信息: 12345678910111213141516171819202122232425262728293031323334353637[root@caoxl ~]# dmidecode -t memory# dmidecode 3.0Getting SMBIOS data from sysfs.SMBIOS 2.8 present.Handle 0x1000, DMI type 16, 23 bytesPhysical Memory Array Location: Other Use: System Memory Error Correction Type: Multi-bit ECC Maximum Capacity: 1 GB Error Information Handle: Not Provided Number Of Devices: 1Handle 0x1100, DMI type 17, 40 bytesMemory Device Array Handle: 0x1000 Error Information Handle: Not Provided Total Width: Unknown Data Width: Unknown Size: 1024 MB Form Factor: DIMM Set: None Locator: DIMM 0 Bank Locator: Not Specified Type: RAM Type Detail: Other Speed: Unknown Manufacturer: Alibaba Cloud Serial Number: Not Specified Asset Tag: Not Specified Part Number: Not Specified Rank: Unknown Configured Clock Speed: Unknown Minimum Voltage: Unknown Maximum Voltage: Unknown Configured Voltage: Unknown 查看OEM信息: 1234[root@caoxl ~]# dmidecode -t 11# dmidecode 3.0Getting SMBIOS data from sysfs.SMBIOS 2.8 present. 不带选项执行dmidecode命令通常会输出所有的硬件信息。dmidecode命令有个很有用的选项-t，可以按指定类型输出相关信息，假如要获得处理器方面的信息，则可以执行： 1234567891011121314151617181920212223242526272829[root@caoxl ~]# dmidecode -t processor# dmidecode 3.0Getting SMBIOS data from sysfs.SMBIOS 2.8 present.Handle 0x0400, DMI type 4, 42 bytesProcessor Information Socket Designation: CPU 0 Type: Central Processor Family: Other Manufacturer: Alibaba Cloud ID: F1 06 04 00 FF FB 8B 0F Version: pc-i440fx-2.1 Voltage: Unknown External Clock: Unknown Max Speed: Unknown Current Speed: Unknown Status: Populated, Enabled Upgrade: Other L1 Cache Handle: Not Provided L2 Cache Handle: Not Provided L3 Cache Handle: Not Provided Serial Number: Not Specified Asset Tag: Not Specified Part Number: Not Specified Core Count: 1 Core Enabled: 1 Thread Count: 1 Characteristics: None"},{"title":"Linux 命令 「ab」","date":"2018-06-06T06:08:40.000Z","updated":"2018-11-22T02:55:46.000Z","comments":true,"path":"backup/2018-06-05-Linux-cmd-ab.html","permalink":"http://blog.caoxl.com/backup/2018-06-05-Linux-cmd-ab.html","excerpt":"abab命令是Apache的Web服务器的性能测试工具，它可以测试安装Web服务器每秒种处理的HTTP请求。","text":"abab命令是Apache的Web服务器的性能测试工具，它可以测试安装Web服务器每秒种处理的HTTP请求。 安装 CentOS 1yum -y install httpd-tools Ubuntu 1apt-get install apache2-utils 查看版本/命令 ab -V 查看版本 ab -help 查看命令 命令参数 -A: 指定连接服务器的基本的认证凭据 -c: 指定一次向服务器发出请求数 -C: 添加cookie -g: 将测试结果输出为:gnuolot文件 -h: 显示帮助信息 -H: 为请求追加一个额外的头 -i: 使用head请求方式 -k: 激活HTTP中的keepAlive特性 -n: 指定测试会话使用的请求数 -p: 指定包含数据的文件 -q: 不显示进度百分比 -T: 使用POST数据时,设置内容类型头 -v: 设置详细模式等级 -w: 以HTML表格方式打印结果 -x: 以表格方式输出时,设置表格的属性 -X: 使用指定的代理服务器发送请求 -y: 以表格方式输出时,设置表格属性 使用1ab -n 1000 -c 10 http://www.caoxl.com/ 注意URL后面的/是必须的, 不然会报invalid URL -n访问1000次, -c并发10个 ab压力测试返回报文内容详解: 123456789101112131415161718192021222324252627282930313233343536Server Software: nginx #服务器软件Server Hostname: www.caoxl.com #域名Server Port: 80 #请求端口号Document Path: / #文件路径Document Length: 3648 bytes #页面字节数Concurrency Level: 10 #请求的并发数Time taken for tests: 30.317 seconds #总访问时间Complete requests: 1000 #请求成功数量Failed requests: 0 #请求失败数量Write errors: 0Total transferred: 3898000 bytes #请求总数据大小(包括header头信息)HTML transferred: 3648000 bytes #html页面实际总字节数Requests per second: 32.98 [#/sec] (mean)#每秒多少请求,(服务器的吞吐量)Time per request: 303.173 [ms] (mean) #用户平均请求等待时间Time per request: 30.317 [ms] (mean, across all concurrent requests) # 服务器平均处理时间，也就是服务器吞吐量的倒数Transfer rate: 125.56 [Kbytes/sec] received #每秒获取的数据长度Connection Times (ms) min mean[+/-sd] median maxConnect: 31 38 55.2 35 1058Processing: 32 258 379.0 145 3986Waiting: 31 157 297.3 37 3730Total: 63 296 384.2 179 4021Percentage of the requests served within a certain time (ms) 50% 179 #50%用户请求在179ms内返回 66% 334 #66%用户请求在334ms内返回 75% 435 #75%用户请求在435ms内返回 80% 447 #80%用户请求在447ms内返回 90% 678 #90%用户请求在678ms内返回 95% 929 #95%用户请求在929ms内返回 98% 1176 #98%用户请求在1176ms内返回 99% 1860 #99%用户请求在1860ms内返回 100% 4021 (longest request)"},{"title":"Linux cmd chkconfig","date":"2018-11-16T03:44:24.000Z","updated":"2018-11-16T06:25:03.000Z","comments":true,"path":"backup/2018-11-16-Linux-cmd-chkconfig.html","permalink":"http://blog.caoxl.com/backup/2018-11-16-Linux-cmd-chkconfig.html","excerpt":"chkconfig命令检查、设置系统的各种服务。这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。谨记chkconfig不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。","text":"chkconfig命令检查、设置系统的各种服务。这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。谨记chkconfig不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。 语法1chkconfig (选项) 选项 --add：增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据； --del：删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据； --level&lt;等级代号&gt;：指定读系统服务要在哪一个执行等级中开启或关毕。 等级代号列表： 等级0表示：表示关机 等级1表示：单用户模式 等级2表示：无网络连接的多用户命令行模式 等级3表示：有网络连接的多用户命令行模式 等级4表示：不可用 等级5表示：带图形界面的多用户模式 等级6表示：重新启动 实例1234567chkconfig --list #列出所有的系统服务。chkconfig --add httpd #增加httpd服务。chkconfig --del httpd #删除httpd服务。chkconfig --level httpd 2345 on #设置httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态。chkconfig --list mysqld #列出mysqld服务设置情况。chkconfig --level 35 mysqld on #设定mysqld在等级3和5为开机运行服务，--level 35表示操作只在等级3和5执行，on表示启动，off表示关闭。chkconfig mysqld on #设定mysqld在各等级为on，“各等级”包括2、3、4、5等级。 如何增加一个服务? 服务脚本必须存放在 /etc/ini.d/ 目录下； chkconfig --add servicename在chkconfig工具服务列表中增加此服务，此时服务会被在/etc/rc.d/rcN.d中赋予K/S入口了； chkconfig --level 35 mysqld on修改服务的默认启动等级。"},{"title":"Categories","date":"2018-01-08T10:01:18.000Z","updated":"2018-08-28T03:28:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://blog.caoxl.com/categories/index.html","excerpt":"","text":""},{"title":"PHP 函数「file_get_contents」","date":"2018-07-06T07:41:38.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-07-06-PHP-Func-file-get-contents.html","permalink":"http://blog.caoxl.com/disuse/2018-07-06-PHP-Func-file-get-contents.html","excerpt":"file_get_content - 将整个文件读入一个字符串","text":"file_get_content - 将整个文件读入一个字符串 file_get_contents() 函数是用来将文件的内容读入到一个字符串中的首选方法。如果操作系统支持还会使用内存映射技术来增强性能。 语法1file_get_contents(path, include_path, context, start, max_length) 参数 path: 必需. 规定要读取的文件 include_path: 可选. 如果也想在 include_path 中搜寻文件的话，可以将该参数设为 &quot;1&quot;。 context: 可选. 规定文件句柄的环境.context 是一套可以修改流的行为的选项。若使用 null，则忽略。 start: 可选. 规定在文件中读取的位置, 该参数是 PHP 5.1 新加的。 max_length: 可选. 规定读取的字节数. 该参数是 PHP 5.1 新加的。 实例 获取并输出网站主页的来源 12345&lt;?php$homepage = file_get_contents('http://www.example.com/');echo $homepage; 在include_path中搜索 1234567&lt;?php// &lt;= PHP 5$file = file_get_contents('./people.txt', true);// &gt; PHP 5$file = file_get_contents('./people.txt', FILE_USE_INCLUDE_PATH); 读取文件的一部分 12345&lt;?php// 从第二十一个字符开始读取14个字符$section = file_get_contents('./people.txt', NULL, NULL, 20, 14);var_dump($section); 使用流上下文 123456789101112131415&lt;?php// 创建流$opts = array( 'http'=&gt;array( 'method'=&gt;\"GET\", 'header'=&gt;\"Accept-language: en\\r\\n\" . \"Cookie: foo=bar\\r\\n\" ));$context = stream_context_create($opts);// Open the file using the HTTP headers set above$file = file_get_contents('http://www.example.com/', false, $context);"},{"title":"二次开发之江湖外卖-转","date":"2018-01-05T07:15:15.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-01-05-JHWM-Second-Dev-Log-Reprint.html","permalink":"http://blog.caoxl.com/disuse/2018-01-05-JHWM-Second-Dev-Log-Reprint.html","excerpt":"惠吃猫-二次开发-江湖外卖 二次开发一个买来的项目,源码相当垃圾,没有文档","text":"惠吃猫-二次开发-江湖外卖 二次开发一个买来的项目,源码相当垃圾,没有文档 安装&amp;开发配置 需要的扩展 ZendGuardLoader Redis 设置数据库连接：system/config.php 自定义绑定域名：/admin(后台) =&gt; 设置 =&gt; 网站设置 =&gt; 基本设置 =&gt; 网站网址 通过 SSH tunnel(隧道) 连接阿里云 RDS(关系数据系统)首先要要可以连接到一台阿里云主机 然后先设置 SSH 连接（连ECS） ssh root@ECS公网IP 最后设置数据库连接（连 RDS） PHPStorm 本地上传远程 先打开项目再配置远程 配置远程 本地使用 PHPStorm 打开 git 仓库后，选中项目名称，右键 “upload to xxx” 即可（此操作最好只在最开始操作一次，因为遍历所有文件会比较慢） 可以设置一直 “upload to xxx” 先配置远程再打开项目 系统 __CORE_DIR：system 目录在文件系统中的绝对路径。如：/data/wwwroot/jhwm.dev/system/ __TIME：时间戳 EOOTURL：网站根URL。如：http://jhwm.dev/。 $pager 结构 12345678910&#123; \"page\":1, \"limit\":50, \"count\":11, \"pagebar\":null, \"res\":\"\\ static\", \"img\":\"http://jhwm.dev/attachs\", \"dateline\":1495853330, \"url\":\"http://admin\"&#125; 可以在后台：设置=》网站设置=》附件设置中修改”附件URL地址”。 伪静态开启：设置 =&gt; 基本设置 =&gt; 开启伪静态。 自定义配置如果需要在后台新增一个选项，需要先往数据库 system_module 中插入一条记录。比如： 12insert into jh_system_module values(null, 'module', 3, 'system/conf', 'index', '系统配置', 1, 269, 50, current_timestamp);insert into jh_system_module values(null, 'module', 3, 'system/conf', 'update', '系统配置', 0, 269, 50, current_timestamp); 其中 visible 字段表示时候显示到后台页面。 注意，只要是要通过 HTTP 请求系统配置的，都需要插入记录先，但是在相应的配置控制器中，则不需要为没个方法都插入一条记录。 接口统一请求：/api.php，POST 发送数据类型为 json。示例： 1http://jhwm.dev/api.php?API=shop/items&amp;data=&#123;%22lat%22:%2237.7914833290724%22,%22lng%22:%22-122.4000111082433%22,%22page%22:1&#125; 其中，该 URL 最终访问到的控制器和方法是：system/api/controllers/shop.ctl.php@items()。 如何写一个接口 1234// 数据库查询、数据格式组装（如果需要）// 返回$this-&gt;msgbox-&gt;add('success');$this-&gt;msgbox-&gt;set_data('data', []); 接口开发 iOS／Android 如何从 H5 跳回 APP？有时候，需要从 APP 内跳入 H5 页面进行一些操作，比如支付。支付结束不希望继续留在 Web 页面而是返回 APP，这样的体验会好很多。 可以在返回的页面带上一个特殊的字符串参数，比如 _app_listen_on_HASHSTRING。然后 APP 内可以从对 URL 请求中监听到这个特殊的字符串，然后自行返回到 APP 内部。 数据库 打印 SQL（只有通过日志的形式；只能打印全部的） 12print_r($this-&gt;system-&gt;db-&gt;SQLLOG());K::M(\"system/logs\")-&gt;log(\"sqllog\",$this-&gt;system-&gt;db-&gt;SQLLOG()); iOS 调用 payment/moneydeduction 接口时候 把拿到的参数调用支付宝APP 提示 “创建交易异常，请重新创建后再付款”（web 支付可以） wap端和app用的不是同一种加密方式 app的支付 一般和公私钥的配置有关系（mapi网关密钥支付） 公私钥 配置正确 模型 表单命名和数据库表字段命名要一致，并在 protected $_cols 里面把可以新增和修改的字段添加进去。示例：system/models/shop/shop.mdl.php K::M(‘/‘) 可以创建任何位于 system/models 目录下的模型。 自定义数据库连接再使用的过程中，发现很多对数据库的操作都没有，也无文档可查，一“怒”之下自己封装了一个简单的 PDO 操作类，供自己使用： 123456789101112131415161718192021222324252627282930313233343536&lt;?php// system/models/system/dbext.mdl.phpif(!defined('__CORE_DIR'))&#123; exit(\"Access Denied\");&#125;class Mdl_System_Dbext extends Model&#123; public $pdo = null; public $tbPre = ''; public function __construct() &#123; unset($this-&gt;system-&gt;db); if (!$this-&gt;pdo || !is_object($this-&gt;pdo)) &#123; $this-&gt;pdo = $this-&gt;getDbInstance(); &#125; &#125; public function getDbInstance() &#123; if (!$this-&gt;pdo || !is_object($this-&gt;pdo)) &#123; $dbCfg = parse_url(__CFG::MYSQL); $path = array_filter(explode('/', $dbCfg['path'])); $dbName = isset($path[1]) ? ';dbname='.$path[1] : ''; $chSet = isset($path[3]) ? $path[3] : 'UTF8'; $chSet = ';charset='.$chSet; if (isset($path[2])) &#123; $this-&gt;tbPre = $path[2]; &#125; $dsn = $dbCfg['scheme'].':host='.$dbCfg['host'].$chSet.$dbName; $user = $dbCfg['user']; $passwd = $dbCfg['pass']; return new PDO($dsn, $user, $passwd); &#125; else &#123; return $this-&gt;pdo; &#125; &#125;&#125; 系统成员用户 在接口中是 $this-&gt;member 在 web 中是 $this-&gt;user。商户 登录后可以通过 $this-&gt;shop 获取信息。API 为什么请求 /api.php?API=biz/info&amp;TOKEN=XXXX 带上 TOKEN 了还是要求登录？源码：system/api/controller.php@check_login() 中可以看出，必须还要带上 CLIENT_API=BIZ 才可以。配送端同理。商户后台 system/home/controllers/biz/ctlmaps.php 这里事先配置好菜单及其子项才可以 常用调用 创建一个连接 123K::M('helper/link')-&gt;mklink('trade/payment:return', array('alipay'), null, 'www');// http://jhwm.dev/index.php?trade/payment/return-alipay.html// app 和 www 的区别只是有没有 http://jhwm.dev 注意事项（坑） web 登录一个账户后，如果再使用 api 登录，则会清除登录信息。 后台的配置信息时报存在数据库的。 FAQ启用阿里云全站 CDN 后，访问 /admin 会出现无限 302？检查是否在 CDN 设置中开启了「过滤参数」 选项（性能优化分类下）。 回源时会去除 URL 中？之后的参数，有效提高文件缓存命中率，提升分发效率。 而江湖外卖对请求的处理是根据请求参数来选择控制器和方法的。以登录后台为例，江湖外卖的源代码又如下判断： 1234567891011121314151617181920212223242526272829// system/admin/index.phpprotected function _init()&#123; $guest_allow = array(\"index:login\", \"index:verify\", \"index:loginout\"); if ($OATOKEN = trim($_POST[\"OATOKEN\"])) &#123; if ($a = $this-&gt;load_model(\"secure/crypt\")-&gt;hexarr($OATOKEN)) &#123; if ($a[\"ATOKEN\"] &amp;&amp; $a[\"AGENT\"]) &#123; $_SERVER[\"HTTP_USER_AGENT\"] = $a[\"AGENT\"]; $_COOKIE[__CFG::C_PREFIX . \"ATOKEN\"] = $a[\"ATOKEN\"]; &#125; &#125; &#125; define(\"CITY_ID\", $this-&gt;admin-&gt;admin[\"city_id\"]); parent::_init(); require __APP_DIR . \"controller.php\"; $act = $this-&gt;request[\"ctl\"] . \":\" . $this-&gt;request[\"act\"]; $this-&gt;admin = K::M(\"admin/auth\"); // ---- 问题代码所在 开始 ---- if (!$this-&gt;admin-&gt;token()) &#123; if (!in_array($act, $guest_allow)) &#123; header(\"Location:?index-login\"); exit(); &#125; &#125; // ---- 问题代码所在 结束 ---- $this-&gt;admin_id = $this-&gt;admin-&gt;admin_id; $this-&gt;admin_name = $this-&gt;admin-&gt;admin_name;&#125; 可见，如果开起来过滤参数，那么 CDN 对动态请求回源时会经过如下流程： 用户访问 /admin 阿里云全站 CDN 识别是动态请求，在过滤掉请求参数后回源 源站（江湖外卖）检查出未登录，将重定向到登录界面：/admin?index-login CDN 接收到重定向请求，会把 /admin?index-login 中的参数过滤变成 /admin，然后重新回源请求 源站（江湖外卖）检查出未登录，将重定向到登录界面：/admin?index-login CDN 接收到重定向请求，会把 /admin?index-login 中的参数过滤变成 /admin，然后重新回源请求 … 因此，对于江湖外卖这套系统，在启用 CDN 的时候，不要启用参数过滤。 实际上，很多系统在开启 CDN 时候如果启用了性能优化都会出现一些问题，因为 CDN 提供的性能优化对很多系统是不适用的。 启用阿里云 CDN 后，后台进入商家管理信息读取异常？具体表现是：从管理总后台商家列表点击进入商家管理后台时，随机切换左侧标签页，显示的商家名称都不一样。 问题的原因是，江湖外卖在对动态请求的响应头中，并没有设置 no-cache，导致 CDN 缓存了 cookie，而 cookie 是要被用于源站。 请务必将 Cache-Control 设置为no-cache, private或者max-age=0。（动态文件一般类似是带有cookie id 的登陆页面，交易页面，或者是需要与数据库进行交互生成的页面）, 这样CDN就不会做缓存，直接回源站； 如果加速域名下面的文件类型多为动态文件，强烈建议采用独立域名，不用CDN加速 附录 POST JSON data with CURL 123curl -X POST http://localhost/api/login \\-H \"Content-Type: application/json\"-d '&#123;\"username\":\"xyz\",\"password\":\"xyz\"&#125;' 参考 缓存相关-阿里云CDN帮助文档"},{"title":"PHP 函数「array_merge」","date":"2018-07-09T02:58:58.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-07-09-PHP-Func-array-merge.html","permalink":"http://blog.caoxl.com/disuse/2018-07-09-PHP-Func-array-merge.html","excerpt":"array_merge - 合并成一个或多个数组","text":"array_merge - 合并成一个或多个数组 语法1array_merge(array1, array2, array3...) 参数 array1 必需, 规定数组 array2 可选, 规定数组 array3 可选, 规定数组 实例12345678&lt;?php$array1 = array(\"color\" =&gt; \"red\", 2, 4);$array2 = array(\"a\", \"b\", \"color\" =&gt; \"green\", \"shape\" =&gt; \"trapezoid\", 4);$result = array_merge($array1, $array2);print_r($result); 12345678910Array( [color] =&gt; green [0] =&gt; 2 [1] =&gt; 4 [2] =&gt; a [3] =&gt; b [shape] =&gt; trapezoid [4] =&gt; 4) 纯数字键名 123456&lt;?php$array1 = array();$array2 = array(1 =&gt; \"data\");$result = array_merge($array1, $array2); 别忘了数字键名将会被重新编号！ 1234Array( [0] =&gt; data) 如果你想完全保留原有数组并只想新的数组附加到后面，用 + 运算符: 12345678&lt;?php$array1 = array(0 =&gt; 'zero_a', 2 =&gt; 'two_a', 3 =&gt; 'three_a');$array2 = array(1 =&gt; 'one_b', 3 =&gt; 'three_b', 4 =&gt; 'four_b');$result = $array1 + $array2;var_dump($result);"},{"title":"PHP 函数「strcasecmp」","date":"2018-07-10T09:43:41.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-07-10-PHP-Func-strcasecmp.html","permalink":"http://blog.caoxl.com/disuse/2018-07-10-PHP-Func-strcasecmp.html","excerpt":"strcasecmp - 二进制安全比较字符串","text":"strcasecmp - 二进制安全比较字符串 语法1strcasecmp (string1, string2) 参数 string1: 必需。规定要比较的第一个字符串。 string2: 必需。规定要比较的第二个字符串。 实例比较两个字符串 (不区分大小写，HELLO 和 hELLo 输出相同): 12345678&lt;?php$var1 = \"Hello\";$var2 = \"hello\";if (strcasecmp($var1, $var2) == 0) &#123; echo '在不区分大小写的字符串比较中，$var1等于$var2';&#125;;"},{"title":"PHP 函数「touch」","date":"2018-07-11T03:39:01.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-07-11-PHP-Func-touch.html","permalink":"http://blog.caoxl.com/disuse/2018-07-11-PHP-Func-touch.html","excerpt":"touch - 设定文件的访问和修改时间","text":"touch - 设定文件的访问和修改时间 语法1touch(filename, time, atime) 参数 filename - 必需, 规定要接触的文件 time - 可选, 设置时间,默认是当前系统时间 atime - 可选, 设置访问时间, 默认是当前系统时间 说明 尝试将由 filename 给出的文件的访问和修改时间设定为指定的时间。如果没有设置可选参数 time，则使用当前系统时间。如果给出了第三个参数 atime，则指定文件的访问时间会被设为 atime 。 如果成功则返回 true，失败则返回 false。 注释: 如果文件不存在, 则会被创建 实例123&lt;?phptouch('text.txt');"},{"title":"","date":"2020-07-14T07:25:10.897Z","updated":"2019-08-22T07:33:58.000Z","comments":true,"path":"disuse/2018-07-24-PHP-Func-array-combine.html","permalink":"http://blog.caoxl.com/disuse/2018-07-24-PHP-Func-array-combine.html","excerpt":"通过合并两个数组来创建一个新数组，其中的一个数组元素为键名，另一个数组元素为键值","text":"通过合并两个数组来创建一个新数组，其中的一个数组元素为键名，另一个数组元素为键值 语法1array_combine($keys, $values); 参数 keys - 必需, 键名数组 values - 必需, 键值数组 实例123456$name = array('caoxl', 'xian', 'liang');$age = array('18', '20', '23');$arr = array_combine($name, $age);var_dump($arr);"},{"title":"","date":"2020-07-14T07:25:10.899Z","updated":"2019-08-22T07:33:58.000Z","comments":true,"path":"disuse/2019-03-04-Solve-Wool-Party.html","permalink":"http://blog.caoxl.com/disuse/2019-03-04-Solve-Wool-Party.html","excerpt":"只要公司有注册送积分,邀请送金豆等等类似可以被羊毛党薅羊毛的功能,就有被薅羊毛的风险.这里从实际操作的几个方面处理","text":"只要公司有注册送积分,邀请送金豆等等类似可以被羊毛党薅羊毛的功能,就有被薅羊毛的风险.这里从实际操作的几个方面处理 前端 前端混淆JS代码,隐藏和后端对接的任何信息(如果接口信息已经暴露, 需要立即更换接口) 服务端 接口做访问次数限制 接口做IP访问限制 接口做设备访问限制 接口做用户真实性访问限制 和前端对接验证码(这里不要用纯前端验证码, 因为一样有风险) 服务器 做相关路由的IP访问限制,比如: 12345678910location /account/login/ &#123; # apply rate limiting limit_req zone=login burst=5; # boilerplate copied from location / proxy_pass http://myapp; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host;&#125; 最后 根据判断封禁违规账号. 回收羊毛"},{"title":"PHP 函数「文件系统操作」","date":"2018-07-12T03:15:28.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-07-12-PHP-Func-File-System-Opt.html","permalink":"http://blog.caoxl.com/disuse/2018-07-12-PHP-Func-File-System-Opt.html","excerpt":"PHP文件系统操作常用函数整理","text":"PHP文件系统操作常用函数整理 php.net 太多不想写,自己看吧: 文件系统函数 文件操作路径相关 basename - 返回路径中的文件名部分 文件复制 copy - 拷贝文件 文件指针 fclose - 关闭一个已打开的文件指针 feof - 测试文件指针是否到了文件结束的位置 fopen - 打开文件或URL fseek - 在文件指针中定位 ftell - 返回文件指针读/写的位置 rewind - 倒回文件指针的位置 文件写入 fflush - 将缓冲内容输出到文件 file_put_contents - 将一根字符串写入文件 fputs - fwrite的别名 fwrite - 写入文件 (可安全用于二进制文件) 文件读取 fgetc - 从文件指针中读取字符 fgets - 从文件指针中读取一行 file_get_contents - 将整个文件读入一个字符串 file - 将整个文件读入一个数组 fpassthru - 输出文件指针处的所有剩余数据 fread - 读取文件 (可安全用二进制文件) ftruncate - 将文件截断到给定的长度 readfile - 输出文件 文件属性 file_exits - 检查文件或目录是否存在 fileatime - 取得文件的上次访问时间 filemtime - 取得文件修改时间 filesize - 取得文件大小 filetype - 取得文件类型 fstat - 通过已打开的文件指针取得文件信息 is_exeutable - 判断给定文件名是否可执行 is_file - 判断给定文件名是否为一个正常的文件 is_readable - 判断给定文件名是否可读 is_uploaded_file - 判断文件是否是通过HTTP POST上传的 is_writable - 判断给定的文件名是否可写 is_writeable - is_writable的别名 pathinfo - 返回文件路径的信息 realpath - 返回规范化的绝对路径名 rename - 重命名一个文件或目录 stat - 给出文件的信息 新建文件 tempnam - 建立一个具有唯一文件名的文件 tmpfile - 建立一个临时文件 touch - 设定文件的访问和修改时间 删除文件 unlink - 删除文件 SPLSplFileInfo1234567891011121314151617181920212223242526&lt;?php$fileName = 'file.php';$fileInfo = new SplFileInfo($fileName);echo '文件' . $fileName . '的信息如下:' . '&lt;/br&gt;';echo '文件名:' . $fileInfo-&gt;getFilename() . '&lt;/br&gt;';echo '扩展名:' . $fileInfo-&gt;getExtension() . '&lt;/br&gt;';echo '文件basename' . $fileInfo-&gt;getBasename() . '&lt;/br&gt;';echo '最后访问时间:' . date('Y-m-d H:i', $fileInfo-&gt;getATime()) . '&lt;/br&gt;';echo '最后inode时间:' . date('Y-m-d H:i', $fileInfo-&gt;getCTime()) . '&lt;/br&gt;';echo '最后修改时间:' . date('Y-m-d H:i', $fileInfo-&gt;getMTime()) . '&lt;/br&gt;';echo '文件组:' . $fileInfo-&gt;getGroup() . '&lt;/br&gt;';echo '文件inode:' . $fileInfo-&gt;getInode() . '&lt;/br&gt;';echo '文件拥有者:' . $fileInfo-&gt;getOwner() . '&lt;/br&gt;';echo '文件所在目录:' . $fileInfo-&gt;getPath() . '&lt;/br&gt;';echo '文件所在完整路径:' . $fileInfo-&gt;getPathname() . '&lt;/br&gt;';echo '文件绝对路径:' . $fileInfo-&gt;getRealPath() . '&lt;/br&gt;';echo '文件权限:' . $fileInfo-&gt;getPerms() . '&lt;/br&gt;';echo '文件大小:' . $fileInfo-&gt;getSize() . '&lt;/br&gt;';echo '文件类型:' . $fileInfo-&gt;getType() . '&lt;/br&gt;';echo '是否是目录:' . ($fileInfo-&gt;isDir() ? '是' : '否') . '&lt;/br&gt;';echo '是否是链接:' . ($fileInfo-&gt;isFile() ? '是' : '否') . '&lt;/br&gt;';echo '是否可执行:' . ($fileInfo-&gt;isWritable() ? '是' : '否') . '&lt;/br&gt;';echo '是否可写:' . ($fileInfo-&gt;isWritable() ? '是' : '否') . '&lt;/br&gt;';echo '是否可读:' . ($fileInfo-&gt;isReadable() ? '是' : '否') . '&lt;/br&gt;'; 在我的windows电脑下: 123456789101112131415161718192021文件file.php的信息如下:文件名:file.php扩展名:php文件basenamefile.php最后访问时间:2018-07-12 03:11最后inode时间:2018-05-30 10:04最后修改时间:2018-07-12 03:11文件组:0文件inode:0文件拥有者:0文件所在目录:文件所在完整路径:file.php文件绝对路径:C:\\WWW\\Test\\file.php文件权限:33206文件大小:140文件类型:file是否是目录:否是否是链接:是是否可执行:是是否可写:是是否可读:是 在我的Mac下 1还没有测试~~~ SplFileObject读取文件 方法1 12345678try &#123; $fileObject = new SplFileObject($fileName); foreach ($fileObject as $line) &#123; echo $line . '&lt;br/&gt;'; &#125;&#125; catch (Exception $e) &#123; echo $e-&gt;getMessage();&#125; 方法2 123456789try &#123; $fileObject = new SplFileObject($fileName); while ($fileObject-&gt;valid()) &#123; echo $fileObject-&gt;current() . '&lt;br/&gt;'; $fileObject-&gt;next(); &#125;&#125; catch (Exception $e) &#123; echo $e-&gt;getMessage();&#125; 写入文件123456try &#123; $fileObject = new SplFileObject($fileName, 'ab+'); $fileObject-&gt;fwrite('// 写点东西');&#125; catch (Exception $e) &#123; echo $e-&gt;getMessage();&#125; 实例 创建一个名为test的目录，在目录中创建一个test.txt的文件并且项文件中写入”Hello World!” 方法1: 123456789101112131415&lt;?php$rootDir = '.';$newDir = $rootDir . '/test';$filePath = $newDir . '/test.txt';$makeDirResult = mkdir($newDir);if ($makeDirResult) &#123; $fileHandler = @fopen($filePath, 'wb+'); fwrite($fileHandler, 'Hello World!'); fclose($fileHandler); echo \"创建目录成功~\";&#125; else &#123; echo \"创建目录失败~\";&#125; 方法2: 1234567891011&lt;?php$rootDir = '.';$newDir = $rootDir . '/test';$filePath = $newDir . '/test.txt';$makeDirResult = mkdir($newDir);if ($makeDirResult) &#123; file_put_contents($filePath, 'Hello World', FILE_APPEND); echo \"写入成功~\";&#125; 返回文件从X行到Y行的内容 方法1 123456789101112131415161718192021&lt;?phpfunction getContentFromFile($file, $startLine, $endLine) &#123; $content = ''; if (file_exists($file)) &#123; $fileHandler = @fopen($file, 'rb'); $i = 1; while (!feof ($fileHandler)) &#123; if ($i &gt; $startLine &amp;&amp; $i &lt;= $endLine) &#123; $content .= fgets($fileHandler); &#125; else &#123; fgets($fileHandler); &#125; $i++; &#125; fclose($fileHandler); &#125; return $content;&#125;echo getContentFromFile('./spl.php', 1, 10); 方法2 1234567891011121314151617&lt;?phpfunction getContentFromFile($file, $startLine, $endLine) &#123; $content = ''; $fileObject = new SplFileObject($file); $fileObject-&gt;seek($startLine); $count = $endLine - $startLine; for ($i = 0; $i &lt;= $count; $i++) &#123; $content .= $fileObject-&gt;current(); $fileObject-&gt;next(); &#125; return $content;&#125;echo getContentFromFile('spl.php', 1, 20); 目录相关路径相关 dirname - 返回路径中的目录部分 目录属性 is_dir - 判断给定文件名是否是一个目录 新建目录 mkdir - 新建目录 删除目录 rmdir - 删除目录 打开目录 opendir - 打开目录句柄 readdir - 从目录句柄中读取条目 关闭目录 closedir - 关闭目录句柄 扫描目录 scandir - 列出指定路径中的文件和目录 参考 PHP文件系统操作常用函数整理"},{"title":"PHP 函数「输出控制」","date":"2018-07-12T02:15:11.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-07-12-PHP-Func-Output-Control.html","permalink":"http://blog.caoxl.com/disuse/2018-07-12-PHP-Func-Output-Control.html","excerpt":"PHP 输出控制函数","text":"PHP 输出控制函数 php.net flush - 刷新输出缓冲 ob_clean - 清空输出缓冲区 ob_end_clean - 清空缓冲区并关闭输出缓冲 ob_end_flush - 冲刷出输出缓冲区内容并关闭缓冲 ob_flush - 冲刷出输出缓冲区中的内容 ob_get_clean - 得到当前缓冲区的内容并删除当前输出缓存 ob_get_content - 返回输出缓冲区的内容 ob_get_flush - 刷出缓冲区内容, 以字符串形式返回内容, 并关闭输出缓冲区 ob_get_length - 返回输出缓冲区内容的长度 ob_get_level - 返回输出缓冲机制的嵌套级别 ob_get_status - 得到所有输出缓冲区的状态 ob_gzhangdler - 在ob_start中使用的用来压缩输出缓冲区中内容的回调函数 ob_implicit_flush - 打开/关闭绝对刷送 ob_list_handlers - 列出所有使用中的输出处理程序 ob_start - 打开输出控制缓冲 output_add_rewrite_var - 添加URL重写器的值 output_reset_rewrite_vars - 重设URL重写器的值 常用的输出控制函数说明ob_start 此函数将打开输出缓冲。当输出缓冲激活后，脚本将不会输出内容（除http标头外），相反需要输出的内容被存储在内部缓冲区中。 内部缓冲区的内容可以用 ob_get_contents() 函数复制到一个字符串变量中.想要输出存储在内部缓冲区中的内容, 可以使用 ob_end_flush() 函数。另外， 使用 ob_end_clean() 函数会静默丢弃掉缓冲区的内容。 输出缓冲区是可堆叠的，这即意谓着，当有一个 ob_start() 是活跃的时， 你可以调用另一个 ob_start() 。只要确保正确调用了 ob_end_flush() 恰当的次数即可。 如果有多重输出回调函数是活跃的，输出内容会一直按嵌套的顺序依次通过它们而被过滤。 flush 刷新PHP程序的缓冲，该函数将当前为止程序的所有输出发送到用户的浏览器。 flush() 函数不会对服务器或客户端浏览器的缓存模式产生影响。因此，必须同时使用 ob_flush() 和 flush() 函数来刷新输出缓冲。 ob_flush 冲刷出输出缓冲区中的内容 输出缓冲区中的内容，如果想进一步处理缓冲区中的内容，必须在ob_flush()之前调用ob_get_contents() ，因为在调用ob_flush()之后缓冲区内容将被丢弃，而缓冲区不会被销毁。 ob_end_flush 输出缓冲区内容，并关闭输出缓冲区。 ob_get_flush 输出缓冲区内容(以字符串形式返回)，并关闭输出缓冲区，与ob_end_flush()不同的是本函数还会以字符串形式返回缓冲区内容。 ob_clean 清空输出缓冲区, 此函数用来丢弃输出缓冲区的内容 此函数不会像 ob_end_clean() 函数那样销毁输出缓冲区。 输出缓冲必须已被 ob_start() 以 PHP_OUTPUT_HANDLER_CLEANABLE 标记启动。否则 ob_clean() 不会有效果。 ob_end_clean 清空输出缓冲区并关闭输出缓冲区; 此函数丢弃最顶层输出缓冲区的内容并关闭这个缓冲区 ob_get_clean 得到当前缓冲区的内容并删除当前输出缓存 返回输出缓冲区的内容，并结束输出缓冲区。如果输出缓冲区不是活跃的，即返回 FALSE 。 ob_get_conent 获取缓冲区的内容 ob_get_length 获取缓冲区内容的长度 ob_get_level 获取缓冲机制的嵌套级别 ob_get_status 得到所有输出缓冲区的状态 实例使用控制输出函数生成静态页面1234567891011121314151617181920&lt;?php ob_start(); echo \"&lt;html&gt;&lt;head&gt;&lt;title&gt;PHP静态化设计&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello OB&lt;/body&gt;&lt;/html&gt;\"; $out = ob_get_contents(); ob_end_clean(); $fp = fopen(\"static.html\", \"w\"); if (!$fp) &#123; echo \"System Error.\";exit(); &#125; else &#123; fwrite($fp, $out); fclose($fp); echo \"Success\"; &#125;"},{"title":"","date":"2020-07-14T07:25:10.898Z","updated":"2019-08-22T07:33:58.000Z","comments":true,"path":"disuse/2018-11-27-PHP-Func-String-Opt.html","permalink":"http://blog.caoxl.com/disuse/2018-11-27-PHP-Func-String-Opt.html","excerpt":"如果说PHP是一本武功秘籍, 那么字符串函数,就是里面的基本招式直接查看手册吧:http://php.net/manual/zh/ref.strings.php这里是我自己写给自己看的.","text":"如果说PHP是一本武功秘籍, 那么字符串函数,就是里面的基本招式直接查看手册吧:http://php.net/manual/zh/ref.strings.php这里是我自己写给自己看的. 字符串替换 str_replace 1echo str_replace(\"Java\", 'PHP', 'Java is the best language in the world'); 字符串截取 substr 123456$str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";echo substr($str, 5); // 从第5个字符开始取至最后echo substr($str, 9, 4); // 从第9个字符开始取4个字符echo substr($str, -5); // 取倒数5个字符echo substr($str, -8, 4); // 从倒数第8个字符开始向后取4个字符echo substr($str, -8, -2); // 从倒数第8个字符开始取到倒数第2个字符为止 字符串查找 stripos 1234567// 查找字符串首次出现的位置,不区分大小写$findme = 'a';$mystring1 = 'xyz';$mystring2 = 'ABC';$pos1 = stripos($mystring1, $findme);$pos2 = stripos($mystring2, $findme); strpos 1234// 查找字符串首次出现的位置$findme = 'a';$mystring = 'abc';$pos = strpos($mystring, $findme); strrchr 123456789101112// 查找指定字符在字符串中的最后一次出现// 获取 $PATH 中不含磁盘符号的目录$dir = substr(strrchr($PATH, \":\"), 1);// 获取最后一行内容$text = \"Line 1\\nLine 2\\nLine 3\";$last = substr(strrchr($text, 10), 1 );$path = '/www/public/index.html';$filename = substr(strrchr($path, \"/\"), 1);echo $filename;// \"index.html\" strstr 1234567// 查找字符串的首次出现,该函数区分大小写$email = 'name@example.com';$domain = strstr($email, '@');echo $domain; // 打印 @example.com$user = strstr($email, '@', true); // 从 PHP 5.3.0 起echo $user; // 打印 name 字符串格式化 sprintf 1234// 返回格式化的字符串$number = 9999;sprintf(\"%.1f\", substr(sprintf(\"%.3f\", $number/1000), 0, -2)) . 'k';sprintf(\"%.1f\", substr(sprintf(\"%.4f\", $number/10000), 0, -3)) . 'w'; vprintf 12// 输出格式化字符串vprintf(\"%04d-%02d-%02d\", explode('-', '1988-8-1')); // 1988-08-01 vsprintf 12` // 返回格式化字符串 print vsprintf(\"%04d-%02d-%02d\", explode('-', '1988-8-1')); // 1988-08-01 字符串填充 str_pad 123echo str_pad(\"input\", 10, \"pp\", STR_PAD_BOTH ); // ppinputpppecho str_pad(\"input\", 6, \"p\", STR_PAD_BOTH ); // inputpecho str_pad(\"input\", 8, \"p\", STR_PAD_BOTH ); //pinputpp 字符串分割 explode 12$string = \"hello,world\";var_dump(explode( ',', $string)); 字符串拼接 implode 12$array = array('lastname', 'email', 'phone');$comma_separated = implode(\",\", $array); 字符串转数组 str_split 1234567$str = \"Hello Friend\";$arr1 = str_split($str);$arr2 = str_split($str, 3);print_r($arr1);print_r($arr2); 字符串重复 str_repeat 1echo str_repeat(\"php\", 10); 字符串打乱 str_shuffle 12$str = 'abcdef';$shuffled = str_shuffle($str); 字符串反转 strrev 1echo strrev(\"Hello world!\"); // 输出 \"!dlrow olleH\" 字符串大小写转化 strtolower 123$str = \"Mary Had A Little Lamb and She LOVED It So\";$str = strtolower($str);echo $str; // 打印 mary had a little lamb and she loved it so strtoupper 123$str = \"Mary Had A Little Lamb and She LOVED It So\";$str = strtoupper($str);echo $str; // 打印 MARY HAD A LITTLE LAMB AND SHE LOVED IT SO"},{"title":"PHP 函数「array_chunk」","date":"2018-07-09T02:59:07.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-07-09-PHP-Func-array-chunk.html","permalink":"http://blog.caoxl.com/disuse/2018-07-09-PHP-Func-array-chunk.html","excerpt":"array_chunk - 将一个数组分割成多个数组","text":"array_chunk - 将一个数组分割成多个数组 定义和用法其中每个数组的单元数目由 size 参数决定。最后一个数组的单元数目可能会少几个。 可选参数 preserve_key 是一个布尔值，它指定新数组的元素是否有和原数组相同的键（用于关联数组），还是从 0 开始的新数字键（用于索引数组）。默认是分配新的键。 语法1array_chunk(array, size, preserve_key); 参数 array: 必需. 规定要使用的数组 size: 必需. 整数值,规定每个新数组包含多少个元素 preserve_key: 可选. true: 保留原始数组中的键名 false: 默认. 每个结果数组使用从0开始的新数组索引 实例123456&lt;?php$input_array = array('a', 'b', 'c', 'd', 'e');print_r(array_chunk($input_array, 2));print_r(array_chunk($input_array, 2, true));"},{"title":"","date":"2020-07-14T07:25:10.901Z","updated":"2019-08-22T07:33:34.000Z","comments":true,"path":"disuse/2019-03-19-PHP-Func-BC-Math.html","permalink":"http://blog.caoxl.com/disuse/2019-03-19-PHP-Func-BC-Math.html","excerpt":"关于 PHP 浮点数运算，特别是金融行业、电子商务订单管理、数据报表等相关业务，利用浮点数进行加减乘除时，稍不留神运算结果就会出现偏差，轻则损失几十万，重则会有信誉损失，甚至吃上官司，我们一定要引起高度重视！","text":"关于 PHP 浮点数运算，特别是金融行业、电子商务订单管理、数据报表等相关业务，利用浮点数进行加减乘除时，稍不留神运算结果就会出现偏差，轻则损失几十万，重则会有信誉损失，甚至吃上官司，我们一定要引起高度重视！ 浮点数运算的“锅”12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php# 加$a = 0.1;$b = 0.7;$c = intval(($a + $b) * 10);echo $c.\"&lt;br&gt;\";//输出：7# 减$a = 100;$b = 99.98;$c = $a - $b;echo $c.\"&lt;br&gt;\";//输出：0.019999999999996# 乘$a = 0.58;$b = 100;$c = intval($a * $b);echo $c.\"&lt;br&gt;\";//输出：57# 除$a = 0.7;$b = 0.1;$c = intval($a / $b);echo $c.\"&lt;br&gt;\";//输出：6 上面的结果，显然不是我们想要的! PHP 官方手册解释如下： 浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用 任意精度数学函数 或者 gmp函数。 BC 数学函数(任意精度数学函数) BCMath：BC 是 Binary Calculator 的缩写。官方手册：http://php.net/manual/zh/book.bc.php 大家在使用前，请先确认是否已安装 bcmath。 bcadd - 2个任意精度数字的加法计算 此可选参数用于设置结果中小数点后的小数位数。也可通过使用 bcscale() 来设置全局默认的小数位数，用于所有函数。 1234567&lt;?php$a = '1.234';$b = '5';echo bcadd($a, $b); // 6echo bcadd($a, $b, 4); // 6.2340 bcsub - 2个任意精度数字的减法 此可选参数用于设置结果中小数点后的小数位数。也可通过使用 bcscale() 来设置全局默认的小数位数，用于所有函数。 1234567&lt;?php$a = '1.234';$b = '5';echo bcsub($a, $b); // -3echo bcsub($a, $b, 4); // -3.7660 bcmul - 2个任意精度数字乘法计算 此可选参数用于设置结果中小数点后的小数位数。也可通过使用 bcscale() 来设置全局默认的小数位数，用于所有函数。 1234&lt;?phpecho bcmul('1.34747474747', '35', 3); // 47.161echo bcmul('2', '4'); // 8 bcdiv - 2个任意精度的数字除法计算 此可选参数用于设置结果中小数点后的小数位数。也可通过使用 bcscale() 来设置全局默认的小数位数，用于所有函数。 123&lt;?phpecho bcdiv('105', '6.55957', 3); // 16.007 bccomp - 比较两个任意精度的数字 如果两个数相等返回0, 左边的数left_operand比较右边的数right_operand大返回1, 否则返回-1. 12345&lt;?phpecho bccomp('1', '2') . \"\\n\"; // -1echo bccomp('1.00001', '1', 3); // 0echo bccomp('1.00001', '1', 5); // 1 bcmod - 对一个任意精度数字取模 返回字符串类型取模后结果，如果系数为0则返回null 1234&lt;?phpecho bcmod('4', '2'); // 0echo bcmod('2', '4'); // 2 bcpow - 任意精度数字的乘方 此可选参数用于设置结果中小数点后的小数位数。也可通过使用 bcscale() 来设置全局默认的小数位数，用于所有函数。 123&lt;?phpecho bcpow('4.2', '3', 2); // 74.08 bcscale - 设置所有bc数学函数的默认小数点保留位数 成功时返回 TRUE， 或者在失败时返回 FALSE。 12345678&lt;?php// default scale : 3bcscale(3);echo bcdiv('105', '6.55957'); // 16.007// this is the same without bcscale()echo bcdiv('105', '6.55957', 3); // 16.007 bcsqrt - 任意精度数字的二次方根 返回二次方根的结果为字符串类型，如果操作数是负数则返回null. 123&lt;?phpecho bcsqrt('2', 3); // 1.414 使用BcMath避免锅1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php# 加$a = 0.1;$b = 0.7;$c = intval(bcadd($a, $b, 1) * 10);echo $c.\"&lt;br&gt;\";//输出：8# 减$a = 100;$b = 99.98;$c = bcsub($a, $b, 2);echo $c.\"&lt;br&gt;\";//输出：0.02# 乘$a = 0.58;$b = 100;$c = intval(bcmul($a, $b));echo $c.\"&lt;br&gt;\";//输出：58# 除$a = 0.7;$b = 0.1;$c = intval(bcdiv($a, $b));echo $c.\"&lt;br&gt;\";//输出：7"},{"title":"","date":"2020-07-14T07:25:10.903Z","updated":"2019-08-22T07:33:34.000Z","comments":true,"path":"funny/2018-07-11-God-Lie-Wolves-Kill-2.html","permalink":"http://blog.caoxl.com/funny/2018-07-11-God-Lie-Wolves-Kill-2.html","excerpt":"没有看过的请前往入门篇: 狼人杀 「入门指南」","text":"没有看过的请前往入门篇: 狼人杀 「入门指南」 狼人杀是一个智商游戏, 是一个团体游戏, 更准确的说是一个发言游戏 12人/石像鬼、守墓人玩法 4神: 预言家(在晚上具有查看身份的能力) 女巫(有毒药和解药，可以救人毒人) 猎人(猎人离开的时候可以带走一个人) 守墓人(得知上一个白天被放逐的玩家是好人或是狼人) 4狼: 石像鬼(狼人阵营; 不进狼窝,没完可以查验一名玩家的具体身份,当所有普狼出局后石像鬼带刀) 石像鬼被预言家查验为狼人 石像鬼不可以自爆 石像鬼可以被狼刀死 三只普通的狼 4民: 4个普通人 夜晚睁眼顺序 守墓人–石像鬼–狼人–女巫–预言家–猎人"},{"title":"网站开发随笔","date":"2018-03-28T06:55:11.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-03-28-Development-Notes.html","permalink":"http://blog.caoxl.com/disuse/2018-03-28-Development-Notes.html","excerpt":"这里纯粹记录一些自己想到的一些东西。","text":"这里纯粹记录一些自己想到的一些东西。 安装/部署安装开发环境PHP+MYSQLwindows下 下载一个PHPStudy（带有phpMyAdmin） 下载一个Navicat Nginx/Apache框架LaravelLumenThinkPHPLaravel-admin服务器配置/部署LinuxWindows server开发/测试Git/Composer/Svn/vim/shellAB/Unit各框架必备登录注册验证码、短信验证码、邮箱验证OAuth/Passport/JWT文件、图片上传/文件下载七牛云图片存储支付功能支付宝、微信网页支付短信通知、消息推送定时任务各框架优化必备CDNRedis、Memcache队列、缓存团队开发、任务管理、代码托管、开发文档Github/Gitlab/Coding禅道、Showdoc、Markdown开发常用软件PHPstorm/SublimeNavicat/phpMyAdminXshell/ZshDocker/Vargant/PHPstuady/Wamp/XamppGit/Vim/Nodejs/shell常用第三方支付宝支付微信支付第三方登录阿里云云通信极光推送七牛云快递100、阿里云云市场（物流查询）聚合数据扩展小程序微信公众号开发前端框架Node.jsPython等别的语言"},{"title":"PHP 函数「file_put_contents」","date":"2018-07-06T07:41:45.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"disuse/2018-07-06-PHP-Func-file-put-contents.html","permalink":"http://blog.caoxl.com/disuse/2018-07-06-PHP-Func-file-put-contents.html","excerpt":"file_put_contents — 将一个字符串写入文件","text":"file_put_contents — 将一个字符串写入文件 和依次调用 fopen(), fwrite() 以及 fclose() 功能一样。 语法1file_put_contents(file, data, mode, context) 参数 file: 必需. 规定要写入数据的文件, 文件文件不存在, 则创建一个新文件 data: 可选. 规定要写入文件的数据. 可以是字符串、数组或数据流 mode: 可选. 规定如何打开/写入文件. 可能的值 FILE_USE_INCLUDE_PATH: 在 include 目录里搜索 filename FILE_APPEND: 如果文件 filename 已经存在，追加数据而不是覆盖。 LOCK_EX: 在写入时获得一个独占锁。 context: 可选. 规定文件句柄的环境. context 是一套可以修改流的行为的选项。若使用 null，则忽略。 实例 简单的用法示例 123456789&lt;?php$file = 'people.txt';$current = file_get_contents($file);$current .= \"John Smith\\n\";file_put_contents($file, $current); 使用标志 1234567&lt;?php$file = 'people.txt';$person = \"John Smith\\n\";file_put_contents($file, $person, FILE_APPEND | LOCK_EX);"},{"title":"","date":"2020-07-14T07:25:10.907Z","updated":"2019-08-22T07:33:34.000Z","comments":true,"path":"funny/2018-08-22-How-Netcap-Find-You.html","permalink":"http://blog.caoxl.com/funny/2018-08-22-How-Netcap-Find-You.html","excerpt":"一直知道网络没有隐私可言，今天在网上看到这篇分析，再次验证了：网络踪迹是很容易被发现的。本文非原创。","text":"一直知道网络没有隐私可言，今天在网上看到这篇分析，再次验证了：网络踪迹是很容易被发现的。本文非原创。 我们上网的方式大致分为下列几种： 不用代理 网络用户 → ISP → 服务器托管商 → 服务器网络警察 → 服务器 IP → 网络用户 IP → 网络用户 ISP → 档案暴露概率：100% 只用 1 层私人 VPN 网络用户 → ISP → VPN → 服务器托管商 → 服务器网络警察 → 服务器 IP → VPN 的 IP → 路由日志 → 链接者 IP → 链接者 ISP → 办网档案暴露概率： 100% 用 1 层共用 VPN 网络用户 → ISP → VPN → 服务器托管商 → 服务器网络警察 → 服务器 IP → VPN 的 IP → 入侵 VPN 服务器 → 日志 → 链接者 IP → 链接者 ISP → 办网档案暴露概率：80% 用 2 层私人 VPN 网络用户 → ISP → VPN 1 → VPN 2 → 服务器托管商 → 服务器网络警察 → 服务器 IP → VPN 2 的 IP → 入侵 VPN 2 服务器 → 日志查 VPN 1 → 路由日志 → 链接者 IP → 链接者 ISP → 办网档案暴露概率：40% 用 2 层共用 VPN 网络用户 → ISP → VPN 1 → VPN 2 → 服务器托管商 → 服务器网络警察 → 服务器 IP → VPN 2的 IP → 入侵 VPN 2服务器 → 日志查 VPN 1 → 日志 → 链接者 IP → 链接者 ISP → 办网档案暴露概率：25% 用 N 层私人（共用） VPN 后删掉 VPN ，如果网络用户有 QQ 网络用户 → ISP → VPN 1 → VPN 2 → VPN 3 → VPN *n服务器托管商 → 服务器网络警察 → 服务器 IP → 访问网站 → 网络用户常用用户名 → 谷歌（百度）一下 → 查到QQ → 找企鹅公司查近期登录 IP暴露概率： 100% 用N层私人（共用） VPN 后删掉 VPN ，如果网络用户无QQ 网络用户 → ISP → VPN 1 → VPN 2 → VPN 3 → VPN *n服务器托管商 → 服务器网络警察 → 服务器 IP → 访问网站 → 网络用户常用用户名 → 谷歌（百度）一下 → 查到其他论坛注册的ID → 找管理员查注册（登录） IP暴露概率： 100% 用 N 层私人（共用） VPN 后删掉 VPN ，如果网络用户在网上没有任何信息 网络用户 → ISP → VPN 1 → VPN 2 → VPN 3 → VPN *n服务器托管商 → 服务器网络警察 → 服务器 IP → 访问网站 → 无常用用户名 → 根据发帖内容（如北京市海淀区XX小区） → 监控整个小区宽带 → 分析 → 找到 IP暴露概率：80%（如果不是严重的问题，如判国之类的应该不会用这种蛋疼方法） 用 N 层私人（共用） VPN 后删掉 VPN ，如果网络用户在网上没有任何信息，但电脑上有自动链接网络的软件，如QQ，金山快盘等。。 网络用户 → ISP → VPN 1 → VPN 2 → VPN 3 → VPN *n服务器托管商 → 服务器网络警察 → 服务器 IP → 访问网站 → 无常用用户名 → 各大公司查 IP → 查到常用用户名 → 查历史登录记录 → 查 IP → 游戏结束暴露概率： 100% 到 KFC 之类的地方上公共网。 网络用户 → KFC → 服务器托管商 → 服务器网络警察 → 服务器 IP → 访问网站 → 看发帖日期时间 → 到KFC → 调监控 → 游戏结束暴露概率： 100% 到 KFC 之类的地方上公共网，假设本次没被监控拍到 网络用户 → KFC → 服务器托管商 → 服务器网络警察 → 服务器 IP → 访问网站 → 看发帖日期时间 → 到KFC → 查MAC地址 → 到附近其他公共网络查此MAC → (如果DHCP会查计算机名) → 附近监控 → 游戏结束暴露概率： 100%"},{"title":"","date":"2020-07-14T07:25:10.905Z","updated":"2019-08-22T07:33:34.000Z","comments":true,"path":"funny/2018-07-17-Rose-For-Love-You.html","permalink":"http://blog.caoxl.com/funny/2018-07-17-Rose-For-Love-You.html","excerpt":"送你一朵玫瑰花, 亲爱的女儿 希希, 满月啦~~","text":"送你一朵玫瑰花, 亲爱的女儿 希希, 满月啦~~ 手机版: 送你一朵玫瑰花 电脑版: 送你一朵玫瑰花"},{"title":"","date":"2020-07-14T07:25:10.902Z","updated":"2019-08-22T07:33:34.000Z","comments":true,"path":"funny/2018-03-09-How-to-play-Wolves-Kill.html","permalink":"http://blog.caoxl.com/funny/2018-03-09-How-to-play-Wolves-Kill.html","excerpt":"别问我为什么技术博客会有狼人杀, 程序员也是需要生活的!而且想做一个学习指南帮助想玩这个游戏的大致了解下先。","text":"别问我为什么技术博客会有狼人杀, 程序员也是需要生活的!而且想做一个学习指南帮助想玩这个游戏的大致了解下先。 游戏设定人数不同，玩法不一样。这里先介绍一种12人的玩法。 分三大类：神，人，狼。 12人狼美人/梦魇玩法 4神: 预言家(在晚上具有查看身份的能力) 女巫(有毒药和解药，可以救人毒人) 猎人(猎人离开的时候可以带走一个人) 守卫(在晚上可以选择守卫一个人) 每晚预言家可以窥视一个玩家的真实身份，是村庄里的灵魂人物。预言家要思考如何帮助村民的同时又不被狼人发现自己的身份。女巫拥有两瓶药，解药可以救活一名当晚被狼人杀害的玩家，毒药可以毒杀一名玩家，女巫在每天晚上最多使用一瓶药，女巫不可自救。当猎人被狼人杀害或被村民处决时，他可以射杀任意一个玩家。但当猎人由于意外死亡（如女巫的毒药或者被殉情而死）他不可在死前射出子弹。每晚守卫暗中指定一个玩家，该玩家当晚会受到保护，不会被狼人杀害，守卫不能连续两晚守卫同一个人，守卫可以守卫自己。（注：部分局规定若女巫的救人与守卫守护的人为同一人，则判定该位玩家因同守同救而死亡） 4狼: 狼美人(可以魅惑一个人，狼美人离开可以带着被魅惑的) 或者 梦魇(可以发动技能，限制一个神的能力) 三只普通的狼 每天晚上会残忍地杀害一个村民，到了白天，狼人要假扮村民隐藏自己的身份，故意误导或陷害其他村民。 4民: 4个普通人 本身没有任何能力，一觉睡到天亮却要考虑很多事情。平民会接收到真假混杂的信息，需要从中分辨和判断出正确的信息。 12人盗贼/丘比特玩法 4神： 预言家(在晚上具有查看身份的能力) 女巫(有毒药和解药，可以救人毒人) 猎人(猎人离开的时候可以带走一个人) 守卫(在晚上可以选择守卫一个人) 3狼 2只普狼 一只盗贼狼 5民 盗贼 (首页睁眼，选择底牌，优先选狼) 盗贼可以选择埋掉一张牌(一张神牌) 丘比特 链接两人： 两人为狼人，则为狼人 两人为好人，则为好人 一人一狼则为第三方 12人种狼/隐狼玩法 4神： 预言家（在晚上具有查看身份的能力） 女巫 (有毒药和解药，可以救人毒人) 猎人 (猎人离开的时候可以带走一个人) 白痴 (白痴神，没有能力的神) 4狼： 种狼 隐狼 2只普狼 种狼具有感染能力，被感染的隔夜变狼 4民： 输赢判定狼杀全部神或者全部民则狼人胜利。狼人全部被杀则好人胜利。 游戏玩法游戏中需要有一个上帝视角的人(法官)，负责游戏流程。 游戏开始每个人拿到自己的牌确认自己的身份。 带警长的，全部人竞选警长，由警长觉得从谁开始发言，警长走了可以选择一人拿警徽继续当警长。 1、 法官宣布“天黑请闭眼”，此时所有玩家都闭眼，进入天黑（夜晚）阶段。狼人请睁眼，狼人请杀人(几个狼人一致决定杀谁)，杀人结束狼人请闭眼。 2、 法官宣布“守卫睁眼”，问守卫本轮会守护哪个人。（守卫不知道他保护的人的身份，或是否是被杀死的。） 3、 法官宣布“预言家请睁眼”，预言家睁眼指定一名玩家，法官把该玩家的身份牌给预言家看，看完后身份牌放回原处，牌面向下。随后法官宣布“预言家请闭眼”。 4、 法官宣布“女巫睁眼”，法官用手势告诉女巫刚才狼人杀死的是谁。女巫可以使用药剂，也可以不使用。如果女巫要使用药剂，则拇指向上表示用解药，救刚才被狼人杀死的人；拇指向下表示使用毒药，并且用手势告诉法官，要在哪位玩家身上使用毒药。被使用了毒药的玩家，天亮时死去。随后法官宣布“女巫闭眼”。 5、 法官宣布“天亮了，所有人睁眼”。此时进入白天阶段。玩家睁眼后，法官宣布昨晚死去的人是谁（也可能没有人死去）。 如果猎人被杀，则猎人立即进行报复，指定一名玩家，该玩家立即死去。死去的玩家，需要发动技能的则翻开身份牌，没有技能可发动的不得翻开身份牌，之后出局，退出游戏，此后不得与其他玩家有任何交流。 6、 场上活着的玩家按顺序依次进行讨论，决定白天要处死谁。（变体规则：刚才天黑时被杀的玩家左手边的玩家开始，按照顺时针方向，轮流发言，玩家之间不得对话，一名玩家发言时，其余玩家不得说话。） 7、 讨论结束，开始投票。所有玩家都伸出手，法官一声令下，玩家同时把手指向自己心目中要处死的目标，被指得最多的玩家（警长的1票算作1.5票）被投票出局。出局玩家翻开自己的身份牌，退出游戏，此后不得与其他玩家有任何交流。如果投票出现平局，则没有人出局。（变体规则：平局时，得票数相同的玩家要再次发言，轮流发言一次，随后便再次投票，直至有人出局。） 8、 法官宣布“天黑请闭眼”，所有人闭上眼睛。接着游戏跳回到前面的第1步，并按照这个顺序循环往复进行，直到游戏结束。 游戏术语关系/位置 金水 (指被预言家公布身份为民及民以上。) 双金水 (指某个玩家同时被两个跳预言家的玩家给出金水身份。) 银水 (指狼人杀中女巫救起来的对象。) 警上 (指参与警长竞选的玩家。) 警下 (指没有上警的玩家。) 外置位 (指预言家警徽流之外的玩家。) 前置位 (前置位：指在白天前几个发言的人，12人局往往指前2-3个人；) 后置位 (后置位：指在白天最后几个发言的人。) 警徽流 (指预言家没有遗言的时候可以通过给警徽传递他的验人信息。) 强神 (指代有功能牌的神。一般指女巫、猎人。) 弱神 (一般指白痴神。) 自证强神 (指可以证明自己身份的神牌。比如枪走了之后翻牌带人，女巫晚上说要毒谁，结果果真毒了都是一个自证的过程。) 民及民以上 (身份为民或者神，又泛指身份偏高。) 民及民以下 (指玩家的身份为民及民以下；表示该玩家的身份为村民或者狼人。这种情况下多表明该玩家身份偏低，极大可能为狼人。) 深水狼 (隐藏的很深、活到最后。一般指被狼队保护的狼人，称为“深水狼”。) 倒钩狼 (站队真预言家，卖掉自己的狼队友，从而做好自己身份的狼。) 金刚狼 (指狼人强沾边好人阵营，通过一些语言和动作来获得好人的信任，也就是指就是好人一辈子找不着推不动的那种狼。) 水包 (表示别人是被怀疑的对象，丢个水包给他，看他怎么聊。丢水包的目的可以是真的对对象有所怀疑，也可以是试探性地给该玩家施加压力，试图根据其在压力下的发言判断身份。) 操作/动作 查杀 (指被预言家验过的狼人。) 双查杀/铁狼 (指真假预言家都给同一个玩家发查杀，则称双查杀(双查杀为铁狼)。) 夹杀 (指两个狼中间的人，一般被谣传为身份面大。) 刀 (指狼人在夜晚杀死好人。) 空刀 (指一般指狼人在夜晚没有刀人。) 自爆 (指白天遗言、投票以外的任意时间，一名狼人明示自己身份并出局使这一个白天不再有投票且立即结束（中断发言）的行为。) 跳 (指玩家说明自己是某种身份。) 对跳 (指两个人或以上都跳一个身份（村民和狼人除外），且警上都不退水，一般其中有一个是狼人) 推 (指票一个人出局，晚上狼队商量的时候比个号数然后做出推的手势，意思就是你抿出来他是个不挂身份的牌，且可以推出局。) 退水 (指上了警又选择不争抢警徽。) 摸 (指预言家验明某个人的身份。) 踩 (指玩家猜测某人是狼，从而影响该玩家的心态从而暴露身份。) 认刀认推不认毒 (在桌游狼人杀中白痴神和枪神（猎人）可以说的话，指可以刀他、推他但是不能够毒他。) 悍跳 (一般指狼人跳明预言家的身份。) 反水 (指玩家不接别人给你发的金水。) 反水立金 (玩家A跳预言家发给B一个金水，B在A之后发言也跳一个预言家。) 点到 (某个玩家身份是狼，但是全部人都要出他，这时候这个玩家可以发言说某某人是狼来暗示自己队友晚上刀这个人。) 抿 (指通过发言，行为，状态等判断出你的底牌。) 盘 (指玩家和你慢慢梳理逻辑。) 竞选警长部分 上警：指第一天白天举手参与竞选警长竞争警徽的行为。 警上：指参与了警长竞选的玩家。 警下：指没有参加竞选警长的玩家。 警徽流：即警徽的流向，指预言家为了防止夜间被杀或者第二天狼自爆无法发言，提前说明晚上的验人顺序，标准局警徽流一般留两夜。 撕警徽：通过投票将警长放逐出局的行为。 吞警徽：在警上竞选警长发言阶段有狼自爆，则本局游戏没有警徽。 退水：竞选警长的玩家在警上发言完毕之后决定退出竞选的行为称之为退水。 金水：预言家验的好人玩家被称为“金水”。 查杀：预言家验的狼人玩家称为查杀。 反水：一般指预言家给你金水但是你不认这个预言家，不接金水而且反对他的行为，称为“反水”。 反水立警：警上A玩家跳预言家给B玩家发金水，B玩家选择跳预言家竞选警长，则称B玩家行为为“反水立警”（一般玩家反水立警不退为真预言家，被反水则多为狼人）。 真金水：确定的真预言家验出的好人。 双金水：真假预言家都给同一个玩家发金水，则称双金水（双金水为铁好人）。 双查杀：真假预言家都给同一个玩家发查杀，则称双查杀（双查杀为铁狼）。 银水：女巫夜晚用解药救过的人称为银水（好人身份的佐证，力度低于金水）。 对跳：有两个或者两个以上的玩家跳同一个身份牌，则称之为对跳。 悍跳：指狼人比较强悍的冒认某种身份牌，比如狼人认预言家则称为，悍跳预言家。 场外：指与游戏无关的一些因素，如夜晚的动静等。 自爆：承认自己是狼，然后让法官终止发言立即进入夜晚，并且有指刀权利。 屠城：狼人或者好人某一边全部出局，游戏结束。 屠边：狼人、村民、神民某一边全部出局，游戏结束。 倒牌：死亡或者被放逐，出局。 遗言：死后的发言。 前置位：相对而言，同一轮里比较早发言的玩家。 后置位：相对而言，同一轮里比较晚发言的玩家。 末置位/归票位：同一轮里最后一位发言的玩家。 PK：在投票环节出现两个平票玩家，则该二位玩家进行多一轮发言，其余玩家进行投票，并只能在其中选择，此二位玩家行为称之为PK。 失联/黑麦/段麦：指网杀中参与游戏的玩家不在局或者发言听不到的情况。（网杀） 天黑闭眼部分 首刀：第一夜里狼人的刀法。 首验：第一夜里预言家的验人。 首刀保护：第一局游戏被首刀的玩家，第二局游戏不能被再次首刀。 首验保护：第一局游戏被首验的玩家，第二局游戏不能被再次首验。 自刀：狼人夜里选择刀自己。 空刀：狼人夜里选择不刀人。 续刀：前一夜里没有杀死某位玩家，第二天夜里继续选择刀该玩家。 指刀/点刀：指挥队友刀某位玩家，白天自爆的狼人在当天夜里具有指定杀某位玩家的权利。 刀法：狼人晚上刀人的一个行为逻辑。 交刀：狼人见大势已去选择认输，放弃比赛。 平安夜：当天夜里无人死亡。 空守：守卫选择不守任何人。 同守同救：狼人刀中守卫守护的玩家，同时女巫使用解药救该名玩家。（同守同救死亡） 盲毒：在所有玩家没有发言过的情况下，女巫对一个身份未知的玩家使用毒药。 骗药：使用方法套路让女巫用错解药的行为（一般为狼人自刀，骗取女巫解药） 撒毒：女巫夜里使用毒药的行为。 可乐：女巫的毒药。 白天发言部分 验尸官：预言家验的玩家刚好被刀死。 票型：投票的情况。 票死/投死：指白天公投环节吃到最多票的玩家被放逐出局。 绑票/冲票：公投环节有计划的一起举票同一个人的行为。 分票：指好人势力没有统一举票同一名玩家，而分投多名玩家。 归票：具有归票权的玩家号召一起举票同一名玩家的行为（警长具有归票权）。 号票：号召大家一起投票某位玩家。 拉票：争取其他玩家的票。 跳/认：指声称自己是某一种身份牌，如跳预言家/认预言家。 踩：指出某个玩家发言不好的地方，做低其身份。 污/脏：诬陷某个玩家，做低该玩家的身份。 抗推：多指好人在白天被公投出局，相当于为狼人扛了白天的一推。 深推：预言家死亡，而局势、身份尚未明朗，只能依靠猜测来进行投票推人。 挡刀：多指村民假装有身份或者跳出神的身份吸引狼人刀自己，从而保护神民。 捞：指为发言不好的玩家开脱，避免其被抗推的发言行为。也指女巫夜间救人的行为。 穿衣服：身份，比如一个民跳女巫的身份，则称穿女巫的衣服。 脱衣服：不认神的身份。 自证身份：可以用技能证实自己的身份。 划水：不怎么发言或者发言没有信息没有意义。 狼坑：狼人的位置、号码。 聊爆/爆狼发言：指玩家在发言中，不经意的暴露自己的狼人身份。 裸打：亮明自己的身份来玩。 四狼裸坐：指狼直接不刻意隐藏身份，不做深水狼倒钩狼，集体站边、冲票等。 对话：发言的时候刻意说给某个玩家听（当然被对话玩家不能回答）。 贴脸：指通过非逻辑的方式使自己在游戏过程中获益的发言，如“我发誓XXX”，“我是SS我XXX”等。这类发言影响游戏平衡，对其他玩家不公平（一般禁止贴脸）。 带走：有身份的牌发动技能使其他玩家出局，如女巫毒药，白狼王自爆，猎人开枪等。 开枪：（猎人也称枪牌）指猎人死的时候发动技能开枪带走一名玩家。 颜杀：未发言或者发言没有信息点的情况下，通过表情反应直接判断玩家身份。 身份代称部分 身份作好/做差：指一名玩家的身份是偏好人或者偏狼人。 高/低：身份好的则称身份高，身份差的则称为身份低。通常讲身份高低为神民&gt;村民&gt;狼人。一般双金水铁好人则称场上“身份最高”。 愚民：看不清局势，乱投票的村民。 乱民/暴民：通过发言或者某些行为来搅乱局势的村民。 民及民以上：身份为民或者神。 民及民以下：身份为民或者狼。 铁好人：指某位玩家必定是好人。 铁狼：指某位玩家必定是狼。 隐狼：一般指隐藏着的狼，游戏前半段都没暴露，类似深水狼。 深水狼：一般指狼人玩家假装好人，隐藏的很深，没把自己做出焦点牌，很难发现。 山洞狼：躲在山洞的狼，类似于深水狼，比深水狼稍有存在感，发言较多。 金刚狼：一般指焦点牌的狼人玩家通过某些因素或者套路，获得好人的信任，坐实铁好人身份。 倒钩狼：站队真预言家，卖掉自己的狼队友，从而做好自己的身份。 抿身份：试探并猜测出某个身份。比如抿神。 炸身份：通过某些特定的假设行为，来试探某名玩家的身份，如其他身份警上跳预言家发后置位查 杀，试探其反应。 第三方：指除了好人阵营和狼人阵营之外的其它正营，一般存在与人狼恋、吹笛者等等。 殉情：指丘比特局中，情侣的一方死亡，另外一方也跟着出局。 链子：指有丘比特的局中被连成情侣的两名玩家，比如：5号8号为链子。 榜样：野孩子的局，该玩家会认定一名榜样，榜样一死，野孩子变为带刀狼。 其他 身份牌 (指除了平民之外的牌。) 平安夜 (指当天夜里没有玩家死亡，有可能是女巫救人或者守卫守对人或者狼人没有刀人。) 绑票 (指出现狼人票数比好人多的情况（可以是人数，也可以是狼警长），这种情况下一般狼人获胜。) 冲票 (公投环节有计划的一起举票同一个人的行为。) 指刀 (狼人在晚上指杀一名角色。通常指狼人在白天自爆后有权利不退场，留下来在进入天黑之后与其余的狼同伴一起讨论当晚需杀死哪一名玩家。) 穿衣服 (指说明自己是某种身份，不一定要说明自己的真实身份。) 挂身份 (指不是普通村民牌，可以挂着神的身份来玩。) 脱衣服 （说完自己是某神，后面轮次又说“我不是那个神”） 挂相 (指面部表情，微表情，面杀时候可以用到。) 聊爆 (指玩家发言没有章法，发言里面透出一股子狼味儿。) 压手 (指弃票) 生推局 （指预言家死于第一夜，第二天开始场上没有预言家，仅凭发言推人的） 表水 （指真诚的说出自己的底牌） 号票 （号召大家冲票某玩家出局(一般会跳身份号票)） 打煽动 （狼人站出来盘反逻辑，强势带节奏出好人(申屠大神的狼打法)） 参考 新月狼人杀虎牙直播"},{"title":"Tags","date":"2018-01-08T10:01:18.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"tags/index.html","permalink":"http://blog.caoxl.com/tags/index.html","excerpt":"","text":""},{"title":"Linux 命令 复习日记","date":"2019-01-24T02:35:34.000Z","updated":"2019-01-25T09:52:36.000Z","comments":true,"path":"backup/2019-01-24-Linux-cmd-Notes.html","permalink":"http://blog.caoxl.com/backup/2019-01-24-Linux-cmd-Notes.html","excerpt":"Linux命令大全","text":"Linux命令大全 系统管理常用工具命令touch 修改文件的创建日期或以当前系統日期创建一個空文件 123[root@caoxl ~]# touch php.txt[root@caoxl ~]# lsphp.txt which 显示应用程序文件的位置 12[root@caoxl ~]# which touch/usr/bin/touch whereis 显示指定命令或文件的帮助信息 12[root@caoxl ~]# whereis touchtouch: /usr/bin/touch /usr/share/man/man1/touch.1.gz grep 从一个文件中找出匹配关键字的行,并送到标准输出 12345[root@caoxl ~]# rpm -qa | grep vimvim-filesystem-7.4.160-4.el7.x86_64vim-minimal-7.4.160-4.el7.x86_64vim-common-7.4.160-4.el7.x86_64vim-enhanced-7.4.160-4.el7.x86_64 gzip 文件压缩/解压缩,不支持对目录进行压缩,如果对目录压缩,要先打包再压缩 1234567891011[root@caoxl cmd]# touch a.txt[root@caoxl cmd]# lsa.txt[root@caoxl cmd]# gzip a.txt[root@caoxl cmd]# lsa.txt.gz [root@caoxl cmd]# gzip -d a.txt.gz [root@caoxl cmd]# lsa.txt speedtest-cli 一个使用python编写的命令行脚本，通过调用speedtest.net测试上下行的接口来完成速度测试 123456789101112131415// 安装pip install speedtest-cli// 外网速度测试[root@caoxl cmd]# speedtest-cli --server=3633 --shareRetrieving speedtest.net configuration...Testing from Aliyun Computing Co. (47.107.169.233)...Retrieving speedtest.net server list...Retrieving information for the selected server...Hosted by China Telecom (Shanghai) [826.34 km]: 125.72 msTesting download speed................................................................................Download: 75.90 Mbit/sTesting upload speed................................................................................................Upload: 1.43 Mbit/sShare results: http://www.speedtest.net/result/7982809492.png xargs xargs用作替换工具，读取输入数据重新格式化后输出。 12345678910111213141516171819202122[root@caoxl cmd]# cat a.txta b c d e f gh i j k l m no p qr s tu v w x y z// 多行输入单行输出：[root@caoxl cmd]# cat a.txt | xargsa b c d e f g h i j k l m n o p q r s t u v w x y z// -n选项多行输出：[root@caoxl cmd]# cat a.txt | xargs -n3a b cd e fg h ij k lm n op q rs t uv w xy z whatis 用于查询一个命令执行什么功能，并将查询结果打印到终端上 1234[root@caoxl cmd]# whatis lsls (1) - list directory contents[root@caoxl cmd]# whatis manman (1) - an interface to the on-line reference manuals wall wall命令用于向系统当前所有打开的终端上输出信息。 12345[root@caoxl cmd]# wall this is a test line[root@caoxl cmd]# Broadcast message from root@caoxl (pts/3) (Thu Jan 24 14:33:30 2019):this is a test line cat cal命令用于显示当前日历，或者指定日期的日历。 123456789101112131415161718192021222324[root@caoxl cmd]# cal -3 December 2018 January 2019 February 2019 Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 1 2 3 4 5 1 2 2 3 4 5 6 7 8 6 7 8 9 10 11 12 3 4 5 6 7 8 9 9 10 11 12 13 14 15 13 14 15 16 17 18 19 10 11 12 13 14 15 1616 17 18 19 20 21 22 20 21 22 23 24 25 26 17 18 19 20 21 22 2323 24 25 26 27 28 29 27 28 29 30 31 24 25 26 27 28 30 31 [root@caoxl cmd]# cal -hUsage: cal [options] [[[day] month] year]Options: -1, --one show only current month (default) -3, --three show previous, current and next month -s, --sunday Sunday as first day of week -m, --monday Monday as first day of week -j, --julian output Julian dates -y, --year show whole current year -V, --version display version information and exit -h, --help display this help text and exit Shell内建命令vmstat vmstat是一款監控Linux系統性能數據的簡易工具，這讓它更合適使用在shell腳本中 1234[root@caoxl cmd]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 360768 275788 2876224 0 0 0 1 0 2 0 0 100 0 0 fg, bg 我們使用bg命令可以将任务放在后台执行，而用fg可以调到前台來使用 history 用于显示指定数目的指令命令，读取历史命令文件中的目录到历史命令缓冲区和将历史命令缓冲区中的目录写入命令文件。 1234567891011[root@caoxl cmd]# history 10 1049 cal -12 1050 cal -y 1051 cal -h 1052 pstree 1053 vmstat 1054 vmstat -s 1055 sudo apt-get install xeyes 1056 yum install xeyes 1057 xeyes 1058 history 10 alias alias命令用来设置指令的别名。 1234[root@caoxl cmd]# alias lll='ls -lsh'[root@caoxl cmd]# llltotal 4.0K4.0K -rw-r--r-- 1 root root 52 Jan 24 14:24 a.txt 系统安全lastb lastb命令用于显示用户错误的登录列表，此指令可以发现系统的登录异常。 1234567891011[root@caoxl cmd]# lastb | headadmin ssh:notty 113.172.107.59 Thu Jan 24 04:12 - 04:12 (00:00) admin ssh:notty 113.172.107.59 Thu Jan 24 04:12 - 04:12 (00:00) root ssh:notty 118.175.228.80 Thu Jan 24 04:12 - 04:12 (00:00) admin ssh:notty 123.21.165.34 Wed Jan 23 18:35 - 18:35 (00:00) admin ssh:notty 123.21.165.34 Wed Jan 23 18:35 - 18:35 (00:00) root ssh:notty 95.99.143.233 Wed Jan 23 01:53 - 01:53 (00:00) admin ssh:notty 43.254.241.164 Tue Jan 22 16:38 - 16:38 (00:00) admin ssh:notty 43.254.241.164 Tue Jan 22 16:38 - 16:38 (00:00) admin ssh:notty 41.238.244.8 Tue Jan 22 03:38 - 03:38 (00:00) admin ssh:notty 41.238.244.8 Tue Jan 22 03:38 - 03:38 (00:00) lastlog lastlog命令用于显示系统中所有用户最近一次登录信息。 1234567891011[root@caoxl cmd]# lastlog | headUsername Port From Latestroot pts/3 14.18.29.122 Thu Jan 24 14:01:04 +0800 2019bin **Never logged in**daemon **Never logged in**adm **Never logged in**lp **Never logged in**sync **Never logged in**shutdown **Never logged in**halt **Never logged in**mail **Never logged in** last last命令用于显示用户最近登录信息。单独执行last命令，它会读取/var/log/wtmp的文件，并把该给文件的内容记录的登入系统的用户名单全部显示出来。 1234567891011[root@caoxl cmd]# last -10root pts/3 14.18.29.122 Thu Jan 24 14:01 still logged in root pts/3 14.18.29.122 Mon Jan 14 14:21 - 18:38 (04:17) root pts/3 14.18.29.122 Mon Jan 14 11:31 - 13:55 (02:23) root pts/3 14.18.29.101 Tue Dec 25 15:39 - 15:41 (00:01) root pts/3 14.18.29.122 Tue Dec 18 10:28 - 20:01 (09:33) root pts/3 14.18.29.122 Mon Dec 17 16:56 - 18:36 (01:40) root pts/4 14.18.29.122 Thu Dec 13 18:32 - 18:36 (00:03) root pts/3 14.18.29.111 Thu Dec 13 16:55 - 19:47 (02:52) root pts/3 14.18.29.104 Wed Dec 12 17:42 - 18:37 (00:54) root pts/3 14.18.29.104 Wed Dec 12 09:35 - 09:46 (00:10) 进程和作业管理systemctl systemctl 命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。 12345[root@caoxl cmd]# systemctl status nginx.service● nginx.service - LSB: starts the nginx web server Loaded: loaded (/etc/rc.d/init.d/nginx; bad; vendor preset: disabled) Active: inactive (dead) Docs: man:systemd-sysv-generator(8) watch watch命令以周期性的方式执行给定的指令，指令输出以全屏方式显示。 -n：指定指令执行的间隔时间（秒）； -d：高亮显示指令输出信息不同之处； -t：不显示标题。 1[root@caoxl cmd]# watch uptime skill skill命令用于向选定的进程发送信号，冻结进程 123456789101112131415// 使用skill命令\"冻结\"它，而不是停止它skill -STOP pid// 唤醒该进程skill -CONT pid// 如果您要停止 \"oracle\" 用户的所有进程，只需要一个命令即可实现：skill -STOP oracle// 可以使用用户、PID、命令或终端 id 作为参数。以下命令可停止所有 rman 命令。skill -STOP rman// snice命令的功能与skill类似。但它用于降低进程的优先级，而不是停止进程// 将 \"oracle\" 进程的优先级降低四个点。注意，该值越高，优先级越低。snice +4 -u oracle service service命令是Redhat Linux兼容的发行版中用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。 12[root@caoxl cmd]# service nginx statusnginx (pid 25817 25816 25815 25814 25813) is running... ps ps命令用于报告当前系统的进程状态 123456789101112// 查看系统进程命令[root@caoxl cmd]# ps -ef | headUID PID PPID C STIME TTY TIME CMDroot 1 0 0 2018 ? 00:00:37 /usr/lib/systemd/systemd --system --deserialize 21root 2 0 0 2018 ? 00:00:00 [kthreadd]root 3 2 0 2018 ? 00:00:00 [ksoftirqd/0]root 5 2 0 2018 ? 00:00:00 [kworker/0:0H]root 7 2 0 2018 ? 00:00:00 [migration/0]root 8 2 0 2018 ? 00:00:00 [rcu_bh]root 9 2 0 2018 ? 00:15:34 [rcu_sched]root 10 2 0 2018 ? 00:00:23 [watchdog/0]root 11 2 0 2018 ? 00:00:17 [watchdog/1] killall killall命令使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程 1[root@caoxl cmd]# killall vim pkill pkill命令可以按照进程名杀死进程。pkill和killall应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill来杀掉。 123[root@caoxl cmd]# pgrep -l vi14328 aliyun-service[root@caoxl cmd]# pkill aliyun-service batch batch命令用于在指定时间，当系统不繁忙时执行任务，用法与at相似。 -f：指定包含具体指令的任务文件； -q：指定新任务的队列名称； -m：任务执行完后向用户发送E-mail。 1234[root@caoxl cmd]# batchat&gt; echo 1024 at&gt; &lt;EOT&gt;at&gt; job 1 at Sun Apr 28 08:49:00 2019 at at命令用于在指定时间执行命令。 1[root@caoxl cmd]# at now + 10 minutes atq atq命令显示系统中待执行的任务列表，也就是列出当前用户的at任务列表。 12[root@caoxl cmd]# atq3 Thu Jan 24 16:28:00 2019 a root pidof pidof命令用于查找指定名称的进程的进程号id号。 12[root@caoxl cmd]# pidof nginx25817 25816 25815 25814 25813 用户和工作组管理change chage命令是用来修改帐号和密码的有效期限。 12345678[root@caoxl cmd]# chage -l rootLast password change : Nov 14, 2018Password expires : neverPassword inactive : neverAccount expires : neverMinimum number of days between password change : 0Maximum number of days between password change : 99999Number of days of warning before password expires : 7 nologin nologin命令可以实现礼貌地拒绝用户登录系统，同时给出信息。如果尝试以这类用户登录，就在log里添加记录，然后在终端输出This account is currently not available信息，就是这样。 12345678// 禁止个别用户登录，比如禁止caoxl用户登录。[root@caoxl cmd]# passwd -l caoxl// 解锁[root@caoxl cmd]# passwd -u caoxl// 禁止所有用户登录。[root@caoxl cmd]# touch /etc/nologin finger finger命令用于查找并显示用户信息。包括本地与远端主机的用户皆可，帐号名称没有大小写的差别。单独执行finger指令，它会显示本地主机现在所有的用户的登陆信息，包括帐号名称，真实姓名，登入终端机，闲置时间，登入时间以及地址和电话。 123[root@caoxl cmd]# fingerLogin Name Tty Idle Login Time Office Office Phone Hostroot root pts/3 Jan 24 16:19 (14.18.29.122) useradd useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 12// 建立一个新用户账户，并设置ID：[root@caoxl cmd]# useradd caoxl -u 999 userdel userdel命令用于删除给定的用户，以及与用户相关的文件。若不加选项，则仅删除用户帐号，而不删除相关文件。 12345678910[root@caoxl cmd]# useradd caoxl -u 9999[root@caoxl cmd]# finger caoxlLogin: caoxl Name: Directory: /home/caoxl Shell: /bin/bashNever logged in.No mail.No Plan.[root@caoxl cmd]# userdel caoxl[root@caoxl cmd]# finger caoxlfinger: caoxl: no such user. 文件系统管理swapoff swapoff命令用于关闭指定的交换空间（包括交换文件和交换分区）。swapoff实际上为swapon的符号连接，可用来关闭系统的交换区 1[root@caoxl cmd]# swapoff /dev/sda2 swapon swapon命令用于激活Linux系统中交换空间，Linux系统的内存管理必须使用交换区来建立虚拟内存。 1[root@caoxl cmd]# swapon -v /dev/hdb4 系统关机和重启halt halt命令用来关闭正在运行的Linux操作系统。halt命令会先检测系统的runlevel，若runlevel为0或6，则关闭系统，否则即调用shutdown来关闭系统。 12[root@caoxl cmd]# halt -p // 关闭系统后关闭电源[root@caoxl cmd]# halt -d // 关闭系统,但不留下记录 reboot reboot命令用来重新启动正在运行的Linux操作系统。 12[root@caoxl cmd]# reboot // 重开机[root@caoxl cmd]# reboot -w // 做个重开机的模拟 (只有记录) shutdown shutdown命令用来系统关机命令。shutdown指令可以关闭所有程序，并依用户的需要，进行重新开机或关机的动作。 1[root@caoxl cmd]# shutdown -h now poweroff poweroff命令用来关闭计算机操作系统并且切断系统电源。 1[root@caoxl cmd]# poweroff 网络管理网络应用axel axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度。比如在国内VPS或服务器上下载lnmp一键安装包用Axel就比wget快。 12如下载lnmp安装包指定10个线程，存到/tmp/：[root@caoxl cmd]# axel -n 10 -o /download/ http://www.linuxde.net/lnmp.tar.gz jwhois whois 客户端服务 123456[root@caoxl cmd]# jwhois caoxl.com[Querying whois.verisign-grs.com][Redirected to grs-whois.hichina.com][Querying grs-whois.hichina.com][grs-whois.hichina.com]The queried object does not exist: caoxl.com curl curl命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。做网页处理流程和数据检索自动化，curl可以祝一臂之力。 1[root@caoxl cmd]# curl URL --silent wget wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。 1[root@caoxl cmd]# wget http://www.linuxde.net/testfile.zip telnet telnet命令用于登录远程主机，对远程主机进行管理 12[root@caoxl cmd]# telnet 192.168.1.200Trying 192.168.1.200... lynx lynx命令是纯文本模式的网页浏览器，不支持图形、音视频等多媒体信息。 1[root@caoxl cmd]# lynx caoxl.com 高级网络ss ss命令用来显示处于活动状态的套接字信息。 12345678910111213141516171819202122232425262728// 显示ICP连接[root@caoxl cmd]# ss -t -aState Recv-Q Send-Q Local Address:Port Peer Address:Port LISTEN 0 128 127.0.0.1:6379 *:* LISTEN 0 128 *:http *:* LISTEN 0 128 127.0.0.1:targus-getdata *:* LISTEN 0 128 127.0.0.1:sd *:* LISTEN 0 128 *:ssh *:* LISTEN 0 128 127.0.0.1:9503 *:* LISTEN 0 128 *:8099 *:* LISTEN 0 128 127.0.0.1:cslistener *:* LISTEN 0 128 127.0.0.1:etlservicemgr *:* ESTAB 0 52 172.18.52.244:ssh 14.18.29.122:23783 LISTEN 0 128 :::smc-https :::* LISTEN 0 80 :::mysql :::*// 显示Sockets摘要[root@caoxl cmd]# ss -sTotal: 141 (kernel 226)TCP: 13 (estab 1, closed 1, orphaned 0, synrecv 0, timewait 0/0), ports 0Transport Total IP IPv6* 226 - - RAW 0 0 0 UDP 9 6 3 TCP 12 10 2 INET 21 16 5 FRAG 0 0 0 ip ip命令用来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。 12345// 显示核心路由表[root@caoxl cmd]# ip route listdefault via 172.18.63.253 dev eth0 169.254.0.0/16 dev eth0 scope link metric 1002 172.18.48.0/20 dev eth0 proto kernel scope link src 172.18.52.244 iptables iptables命令是Linux上常用的防火墙软件，是netfilter项目的一部分。可以直接配置，也可以通过许多前端和图形界面配置。 12345// 屏蔽IP[root@caoxl cmd]# iptables -I INPUT -s 123.45.6.7 -j DROP #屏蔽单个IP的命令[root@caoxl cmd]# iptables -I INPUT -s 123.0.0.0/8 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令[root@caoxl cmd]# iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令[root@caoxl cmd]# iptables -I INPUT -s 123.45.6.0/24 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令是 网络测试host host命令是常用的分析域名查询工具，可以用来测试域名系统工作是否正常。 123456[root@caoxl cmd]# host caoxl.comcaoxl.com has address 47.107.169.233[root@caoxl cmd]# host lilis.xinlilis.xin has address 47.254.25.179lilis.xin mail is handled by 5 mxn.mxhichina.com.lilis.xin mail is handled by 10 mxw.mxhichina.com. dig dig命令是常用的域名查询工具，可以用来测试域名系统工作是否正常。 1234567891011121314151617181920[root@caoxl cmd]# dig caoxl.com; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-61.el7_5.1 &lt;&lt;&gt;&gt; caoxl.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 16488;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;caoxl.com. IN A;; ANSWER SECTION:caoxl.com. 600 IN A 47.107.169.233;; Query time: 0 msec;; SERVER: 100.100.2.138#53(100.100.2.138);; WHEN: Thu Jan 24 17:51:40 CST 2019;; MSG SIZE rcvd: 54 nslookup nslookup命令是常用域名查询工具，就是查DNS信息用的命令 1234567[root@caoxl cmd]# nslookup caoxl.comServer: 100.100.2.138Address: 100.100.2.138#53Non-authoritative answer:Name: caoxl.comAddress: 47.107.169.233 netstat netstat命令用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 123456789101112// 列出端口[root@caoxl cmd]# netstat -a | headActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 localhost:6379 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:http 0.0.0.0:* LISTEN tcp 0 0 localhos:targus-getdata 0.0.0.0:* LISTEN tcp 0 0 localhost:sd 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:ssh 0.0.0.0:* LISTEN tcp 0 0 localhost:9503 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8099 0.0.0.0:* LISTEN tcp 0 0 localhost:cslistener 0.0.0.0:* LISTEN iperf iperf命令是一个网络性能测试工具。iperf可以测试TCP和UDP带宽质量。 1234567891011121314// UDP模式[root@caoxl cmd]# iperf -u -s------------------------------------------------------------Server listening on UDP port 5001Receiving 1470 byte datagramsUDP buffer size: 208 KByte (default)------------------------------------------------------------// TCP模式[root@caoxl cmd]# iperf -s------------------------------------------------------------Server listening on TCP port 5001TCP window size: 85.3 KByte (default)------------------------------------------------------------ 网络安全ssh ssh命令是openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器。 1[root@caoxl cmd]# [root@caoxl ~]# ssh 用户名@IP地址 -p 端口号 ssh-add ssh-add命令是把专用密钥添加到ssh-agent的高速缓存中。该命令位置在/usr/bin/ssh-add。 12345678// 把专用密钥添加到 ssh-agent 的高速缓存中：[root@caoxl cmd]# ssh-add ~/.ssh/id_dsa// 从ssh-agent中删除密钥：[root@caoxl cmd]# ssh-add -d ~/.ssh/id_xxx.pub// 查看ssh-agent中的密钥：[root@caoxl cmd]# ssh-add -l ssh-agent ssh-agent命令是一种控制用来保存公钥身份验证所使用的私钥的程序。其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。 1234[root@caoxl cmd]# ssh-agentSSH_AUTH_SOCK=/tmp/ssh-yGosWaXjw9zF/agent.6332; export SSH_AUTH_SOCK;SSH_AGENT_PID=6333; export SSH_AGENT_PID;echo Agent pid 6333; ssh-keygen ssh-keygen命令用于为“ssh”生成、管理和转换认证密钥，它支持RSA和DSA两种认证密钥。 1[root@caoxl cmd]# ssh-keygen -t rsa // -t 指定要创建的密钥类型。 ssh-keyscan ssh-keyscan命令是一个收集大量主机公钥的使用工具。 1234567[root@caoxl cmd]# ssh-keyscan caoxl.com# caoxl.com:22 SSH-2.0-OpenSSH_7.4caoxl.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4W8UJjHbh34Z+YJ2cYNlIWEplSBvxNKgyMZssNgsCT19R4hYjXkkpQs3RhJZdNVtrbTw+MUPU2o3TGGkomxsSiKN7Ix0LZ9iNX5WRZC2LO+zboRs8Gg011ghg0aroNAA21Z24pN9LGqdEzgX84JFUL6p9QYox4awxUf630lMWO5ZhQHaHDiGWUAQ5tifCUCNsaiHnYndRw6AtBcfgg8XN90su06lUkP9zuF1WtRg5deOJUkFTBe6/NrmrpnlOs9jUX/3koSsbL708JPNLPX7ZE/eJGDRgTnNjC940fHCdZ00nIb76OZQcTeL9D/w/r15zY20X43G8j2o8fYe8nY+p# caoxl.com:22 SSH-2.0-OpenSSH_7.4caoxl.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGH2C+GRx3NryANP29qAbQXqVto0rxK8sAv1tGDVA4xonD9z6QOdWuShPPXy43sVEASfYmC9mHgDl6aJE2rET1E=# caoxl.com:22 SSH-2.0-OpenSSH_7.4caoxl.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIKfklk7UefK8pS+SLRi+wHquflsM1iEwmo297kx2EDvP nmap nmap命令是一款开放源代码的网络探测和安全审核工具，它的设计目标是快速地扫描大型网络。 1234567891011121314[root@caoxl cmd]# nmap caoxl.comStarting Nmap 6.40 ( http://nmap.org ) at 2019-01-24 18:14 CSTNmap scan report for caoxl.com (47.107.169.233)Host is up (0.00026s latency).Not shown: 995 filtered portsPORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp closed https3389/tcp closed ms-wbt-server6789/tcp open ibm-db2-adminNmap done: 1 IP address (1 host up) scanned in 4.92 seconds iptstate iptstate命令以top指令类似的风格时显示Linux内核中iptables的工作状态。 123[root@caoxl cmd]# iptstateCaught signal 2, cleaning up. sftp sftp命令是一款交互式的文件传输程序，命令的运行和使用方式与ftp命令相似，但是，sftp命令对传输的所有信息使用ssh加密，它还支持公钥认证和压缩等功能。 1[root@caoxl cmd]# sftp username@localhost 网络配置ifconfig ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。 12345[root@caoxl cmd]# ifconfig// 启动关闭指定网卡：[root@caoxl cmd]# ifconfig eth0 up[root@caoxl cmd]# ifconfig eth0 down hostname hostname命令用于显示和设置系统的主机名称。环境变量HOSTNAME也保存了当前的主机名。在使用hostname命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，需要同时修改/etc/hosts和/etc/sysconfig/network的相关内容。 12345[root@caoxl cmd]# hostnamecaoxl[root@caoxl cmd]# hostname Caoxllc[root@caoxl cmd]# hostnameCaoxllc route route命令用来显示并设置Linux内核中的网络路由表，route命令设置的路由主要是静态路由。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。 1234567// 显示当前路由：[root@caoxl cmd]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Ifacedefault gateway 0.0.0.0 UG 0 0 0 eth0link-local 0.0.0.0 255.255.0.0 U 1002 0 0 eth0172.18.48.0 0.0.0.0 255.255.240.0 U 0 0 0 eth0 网络服务器ab ab命令是Apache的Web服务器的性能测试工具，它可以测试安装Web服务器每秒种处理的HTTP请求。 1[root@caoxl cmd]# ab -n 1000 -c 10 http://www.caoxl.com/ mysql mysql命令是MySQL数据库服务器的客户端工具，它工作在命令行终端中，完成对远程MySQL数据库服务器的操作。 -h：MySQL服务器的ip地址或主机名； -u：连接MySQL服务器的用户名； -e：执行mysql内部命令； -p：连接MySQL服务器的密码。 12345678910[root@caoxl cmd]# mysql -u root -pEnter password: Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 175Server version: 10.2.16-MariaDB-log Source distributionCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysqldump mysqldump命令是mysql数据库中备份工具，用于将MySQL服务器中的数据库以标准的sql语言的方式导出，并保存到文件中。 123456789// 导出整个数据库mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名(.sql文件)// 导出一个表mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名// 导出一个数据库结构mysqldump -u 用户名 -p -d --add-drop-table 数据库名 &gt; 导出的文件名// -d没有数据，--add-drop-table每个create语句之前增加一个drop table mysqllimport mysqlimport命令为mysql数据库服务器提供了一种命令行方式导入数据工具，它从特定格式的文本文件中读取数据插入MySQL数据库表中。 -D：导入数据前清空表； -f：出现错误时继续处理剩余的操作； -h：MySQL服务器的ip地址或主机名； -u：连接MySQL服务器的用户名； -p：连接MySQL服务器的密码。 mysqladmin mysqladmin命令是mysql服务器管理任务的客户端工具，它可以检查mysql服务器的配置和当前工作状态，创建和删除数据库，创建用户和修改用户密码等操作。 mysqladmin支持下列命令： create databasename：创建一个新数据库； drop databasename：删除一个数据库及其所有表； extended-status：给出服务器的一个扩展状态消息； flush-hosts：清空所有缓存的主机； flush-logs：清空所有日志； flush-tables：清空所有表； flush-privileges：再次装载授权表(同reload)； kill id,id,...：杀死mysql线程； password 新口令：将老密码改为新密码； ping：检查mysqld是否活着； processlist：显示服务其中活跃线程列表； reload：重载授权表； refresh：清空所有表并关闭和打开日志文件； shutdown：关掉服务器； status：给出服务器的简短状态消息； variables：打印出可用变量； version：得到服务器的版本信息。 mysqlshow mysqlshow命令用于显示mysql服务器中数据库、表和列表信息。 -h：MySQL服务器的ip地址或主机名； -u：连接MySQL服务器的用户名； -p：连接MySQL服务器的密码； --count：显示每个数据表中数据的行数； -k：显示数据表的索引； -t：显示数据表的类型； -i：显示数据表的额外信息。 软件|打印|开发|工具软件包管理dnf DNF是新一代的rpm软件包管理器。他首先出现在 Fedora 18 这个发行版中。而最近，它取代了yum，正式成为 Fedora 22 的包管理器。 1234567891011// 查看系统中可用的 DNF 软件库[root@caoxl ~]# dnf repolistUsing metadata from Fri Jan 25 10:11:54 2019repo id repo name statusbase CentOS-7 10,019epel Extra Packages for Enterprise Linux 7 - x86_64 12,875extras CentOS-7 321updates CentOS-7 647// 查看系统中可用和不可用的所有的 DNF 软件库[root@caoxl ~]# dnf repolist all yum yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 install：安装rpm软件包； update：更新rpm软件包； check-update：检查是否有可用的更新rpm软件包； remove：删除指定的rpm软件包； list：显示软件包的信息； search：检查软件包的信息； info：显示指定的rpm软件包的描述信息和概要信息； clean：清理yum过期的缓存； shell：进入yum的shell提示符； resolvedep：显示rpm软件包的依赖关系； localinstall：安装本地的rpm软件包； localupdate：显示本地rpm软件包进行更新； deplist：显示rpm软件包的所有依赖关系。 rpm rpm命令是RPM软件包的管理工具。 如何安装rpm软件包 1[root@caoxl ~]# rpm -ivh your-package.rpm 如何卸载rpm软件包 使用命令rpm -e包名，包名可以包含版本号等信息，但是不可以有后缀.rpm，比如卸载软件包proftpd-1.2.8-1，可以使用下列格式： 1234[root@caoxl ~]# rpm -e proftpd-1.2.8-1[root@caoxl ~]# rpm -e proftpd-1.2.8[root@caoxl ~]# rpm -e proftpd-[root@caoxl ~]# rpm -e proftpd 如何查看与rpm包相关的文件和其他信息 1[root@caoxl ~]# rpm -qa | grep your-package apt-get apt-get命令是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。 安装一个新软件包： 1apt-get install packagename 卸载一个已安装的软件包（保留配置文件）： 1apt-get remove packagename 卸载一个已安装的软件包（删除配置文件）： 1apt-get –purge remove packagename 编程开发pstack pstack命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。 123456[root@caoxl ~]# pstack 1#0 0x00007f029aadb163 in __epoll_wait_nocancel () from /lib64/libc.so.6#1 0x0000560663e5a1f9 in sd_event_wait ()#2 0x0000560663e5ad0d in sd_event_run ()#3 0x0000560663dbbec3 in manager_loop ()#4 0x0000560663db046b in main () gdb gdb命令包含在GNU的gcc开发套件中，是功能强大的程序调试器 -cd：设置工作目录； -q：安静模式，不打印介绍信息和版本信息； -d：添加文件查找路径； -x：从指定文件中执行GDB指令； -s：设置读取的符号表文件。 gcc gcc命令使用GNU推出的基于C/C++的编译器，是开放源代码领域应用最广泛的编译器，具有功能强大，编译代码支持性能优化等特点 -o：指定生成的输出文件； -E：仅执行编译预处理； -S：将C代码转换为汇编代码； -wall：显示警告信息； -c：仅执行编译操作，不进行连接操作。 12// 多个文件一起编译[root@caoxl ~]# gcc testfun.c test.c -o test make make命令是GNU的工程化编译工具，用于编译众多相互关联的源代码问价，以实现工程化的管理，提高开发效率。 1[root@caoxl ~]# make &amp;&amp; make install mktemp mktemp命令被用来创建临时文件供shell脚本使用。 -q：执行时若发生错误，不会显示任何信息； -u：暂存文件会在mktemp结束前先行删除； -d：创建一个目录而非文件。 perl perl命令是perl语言解释器，负责解释执行perl语言程序。 -w：输出有用的警告信息； -U：允许不安全的操作； -c：仅检查文件的语法； -d：在调试下运行脚本程序。 ldd ldd命令用于打印程序或者库文件所依赖的共享库列表。首先ldd不是一个可执行程序，而只是一个shell脚本 123456[root@caoxl ~]# ldd --versionldd (GNU libc) 2.17Copyright (C) 2012 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Written by Roland McGrath and Ulrich Drepper. 打印cupsenable cupsenable命令用于启动指定的打印机。 -E：当连接到服务器时强制使用加密； -U：指定连接服务器时使用的用户名； -u：指定打印任务所属的用户； -h：指定连接的服务器名和端口号； cupsdisable cupsdisable命令用于停止指定的打印机。 -E：当连接到服务器时强制使用加密； -U：指定连接服务器时使用的用户名； -u：指定打印任务所属的用户； -c：取消指定打印机的所有打印任务； -h：指定连接的服务器名和端口号； -r：停止打印机的原因。 cancel cancel命令用于取消已存在的打印任务。 -a：取消所有打印任务； -E：当连接到服务器时强制使用加密； -U：指定连接服务器时使用的用户名； -u：指定打印任务所属的用户； -h：指定连接的服务器名和端口号。 文件目录管理文件传输ftp ftp命令用来设置文件系统相关功能。ftp服务器在网上较为常见，Linux ftp命令的功能是用命令的方式来控制在本地机和远程机之间传送文件 -d：详细显示指令执行过程，便于排错或分析程序执行的情况； -i：关闭互动模式，不询问任何问题； -g：关闭本地主机文件名称支持特殊字符的扩充特性； -n：不使用自动登录； -v：显示指令执行过程。 scp scp命令用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的 1234567891011// 从远处复制文件到本地目录scp root@10.10.10.10:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/// 从远处复制到本地scp -r root@10.10.10.10:/opt/soft/mongodb /opt/soft/// 上传本地文件到远程机器指定目录scp /opt/soft/nginx-0.5.38.tar.gz root@10.10.10.10:/opt/soft/scptest// 上传本地目录到远程机器指定目录scp -r /opt/soft/mongodb root@10.10.10.10:/opt/soft/scptest 文件处理touch touch命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。 1[root@caoxl cmd]# touch b.txt rename rename命令用字符串替换的方式批量改变文件名。 123[root@caoxl cmd]# rename b.txt a.txt b.txt[root@caoxl cmd]# lsa.txt dirname dirname命令去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个/及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个/后无字符，dirname 命令使用倒数第二个/，并忽略其后的所有字符。dirname 和 basename 通常在 shell 内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。 12[root@caoxl ~]# dirname ~/cmd/a.txt/root/cmd ln ln命令用来为文件创件连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用”-s”选项。 注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。 参数 源文件：指定连接的源文件。如果使用-s选项创建符号连接，则“源文件”可以是文件或者目录。创建硬连接时，则“源文件”参数只能是文件； 目标文件：指定源文件的目标连接文件。 1234567891011[root@caoxl init.d]# lltotal 60K-rw-r--r-- 1 root root 18K Jan 3 2018 functions-rwxr-xr-x 1 root root 12K Nov 15 10:21 mysqld-rwxr-xr-x 1 root root 4.3K Jan 3 2018 netconsole-rwxr-xr-x 1 root root 7.2K Jan 3 2018 network-rwxr-xr-x 1 root root 2.7K Jan 2 2018 nginxlrwxrwxrwx 1 root root 35 Nov 14 17:58 php-fpm-56 -&gt; /usr/local/php/php56/bin/php-fpm-56lrwxrwxrwx 1 root root 35 Nov 14 17:25 php-fpm-72 -&gt; /usr/local/php/php72/bin/php-fpm-72-rw-r--r-- 1 root root 1.2K Sep 27 03:11 README-rwxr-xr-x 1 root root 1.9K Nov 30 17:36 shadowsocks cat cat命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容，类似于下的type命令。 12[root@caoxl cmd]# cat a.txt cat命令连接文件并打印到标准输出设备上，cat经常用来显示文件的内容，类似于下的type命令。 文件查找和比较diff diff命令在最简单的情况下，比较给定的两个文件的不同。 12345[root@caoxl cmd]# diff a.txt b.txt1c1&lt; from a.txt---&gt; from b.txt cmp cmp命令用来比较两个文件是否有差异。当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有差异，预设会标示出第一个不通之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为“-”，则cmp指令会从标准输入设备读取数据。 12[root@caoxl cmd]# cmp a.txt b.txta.txt b.txt differ: byte 6, line 1 find find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 12345678910// 列出当前目录及子目录下所有文件和文件夹[root@caoxl cmd]# find .../a.txt./b.txt// 在~/cmd目录下查找以.txt结尾的文件名[root@caoxl cmd]# find ~/cmd -name \"*.txt\"/root/cmd/a.txt/root/cmd/b.txt 文件内容查看tail tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。 1234567891011[root@caoxl cmd]# tail test.php public function bar(string $ClassName) &#123; $this-&gt;arr[$ClassName] = new $ClassName(); return $this-&gt;arr[$ClassName]; &#125;&#125;$test = new Test();var_dump($test-&gt;bar('foo')-&gt;_foo()); head head命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。 12345678910[root@caoxl cmd]# head test.php &lt;?phpclass Foo&#123; public function _foo() &#123; echo 1024; &#125;&#125; less less命令的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。用less命令显示文件时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。 more more命令是一个基于vi编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作 按Space键：显示文本的下一屏内容。 按Enter键：只显示文本的下一行内容。 按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。 按H键：显示帮助屏，该屏上有相关的帮助信息。 按B键：显示上一屏内容。 按Q键：退出more命令。 目录基本操作tree tree命令以树状图列出目录的内容。 1234567[root@caoxl cmd]# tree.├── a.txt├── b.txt└── test.php0 directories, 3 files dirs dirs命令显示当前目录栈中的所有记录（不带参数的dirs命令显示当前目录栈中的记录）。dirs始终显示当前目录, 再是堆栈中的内容；即使目录堆栈为空, dirs命令仍然只显示当前目录。 12[root@caoxl cmd]# dirs~/cmd mkdir mkdir命令用来创建目录。 123[root@caoxl cmd]# mkdir test[root@caoxl cmd]# lsa.txt b.txt test test.php rmdir rmdir命令用来删除空目录。 12345[root@caoxl cmd]# lsa.txt b.txt test test.php[root@caoxl cmd]# rmdir test[root@caoxl cmd]# lsa.txt b.txt test.php pwd pwd命令以绝对路径的方式显示用户当前工作目录 12[root@caoxl cmd]# pwd/root/cmd 文件权限属性设置stat stat命令用于显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细。 123456789[root@caoxl cmd]# stat test.php File: ‘test.php’ Size: 0 Blocks: 0 IO Block: 4096 regular empty fileDevice: fd01h/64769d Inode: 663577 Links: 1Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2019-01-25 14:56:12.189122530 +0800Modify: 2019-01-25 14:56:12.189122530 +0800Change: 2019-01-25 14:56:12.189122530 +0800 Birth: - chmod chmod命令用来变更文件或目录的权限。 123456789[root@caoxl cmd]# lltotal 0-rw-r--r-- 1 root root 0 Jan 25 14:56 test.php// -rw-(u 属用户) r-- (g 属组) r-- (o其他人)[root@caoxl cmd]# chmod 777 test.php [root@caoxl cmd]# lltotal 0-rwxrwxrwx 1 root root 0 Jan 25 14:56 test.php 说明 r=读取属性 //值＝4 w=写入属性 //值＝2 x=执行属性 //值＝1 chown chown命令改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者或者改变文件所属的组 123456789[root@caoxl cmd]# chown git test.php [root@caoxl cmd]# lltotal 0-rwxrwxrwx 1 git root 0 Jan 25 14:56 test.php[root@caoxl cmd]# chown root:root test.php [root@caoxl cmd]# lltotal 0-rwxrwxrwx 1 root root 0 Jan 25 14:56 test.php chgrp chgrp命令用来改变文件或目录所属的用户组 1234[root@caoxl cmd]# chgrp www test.php [root@caoxl cmd]# lltotal 0-rwxrwxrwx 1 git www 0 Jan 25 14:56 test.php chattr chattr命令用来改变文件属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： a：让文件或目录仅供附加用途； b：不更新文件或目录的最后存取时间； c：将文件或目录压缩后存放； d：将文件或目录排除在倾倒操作之外； i：不得任意更动文件或目录； s：保密性删除文件或目录； S：即时更新文件或目录； u：预防意外删除。 12345678910111213141516171819// 不得任意更动文件或目录[root@caoxl cmd]# chattr +i ./test.php [root@caoxl cmd]# lstest.php[root@caoxl cmd]# lltotal 0-rwxrwxrwx 1 root root 0 Jan 25 14:56 test.php[root@caoxl cmd]# vim test.php [root@caoxl cmd]# lltotal 0-rwxrwxrwx 1 root root 0 Jan 25 14:56 test.php[root@caoxl cmd]# cat test.php [root@caoxl cmd]# chattr -i ./test.php [root@caoxl cmd]# lstest.php[root@caoxl cmd]# vi test.php [root@caoxl cmd]# cat test.php test file file命令用来探测给定文件的类型。file命令对文件的检查分为文件系统、魔法幻数检查和语言检查3个过程。 12[root@caoxl cmd]# file test.php test.php: ASCII text 文件过滤分割与合并egrep egrep命令用于在文件内查找指定的字符串 12[root@caoxl cmd]# egrep e *test grep grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 12[root@caoxl cmd]# ps -ef | grep viroot 10555 10097 0 15:24 pts/0 00:00:00 grep --color=auto vi sort sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入。 1234567891011121314[root@caoxl cmd]# cat sort.txt aaa:10:1.1ccc:30:3.3ddd:40:4.4bbb:20:2.2eee:50:5.5eee:50:5.5[root@caoxl cmd]# sort sort.txt aaa:10:1.1bbb:20:2.2ccc:30:3.3ddd:40:4.4eee:50:5.5eee:50:5.5 tr tr命令可以对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符，经常用来编写优美的单行命令，作用很强大。 12[root@caoxl cmd]# echo \"HELLO WORLD\" | tr 'A-Z' 'a-z'hello world 文件压缩与解压zip zip命令可以用来解压缩文件，或者对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。 语法 zip(选项)(参数) 参数 zip压缩包：指定要创建的zip压缩包； 文件列表：指定要压缩的文件列表。 123[root@caoxl cmd]# zip -qr zip.zip zip.txt[root@caoxl cmd]# lssort.txt test.php zip.txt zip.zip unzip unzip命令用于解压缩由zip命令压缩的“.zip”压缩包。 123456789101112131415[root@caoxl cmd]# unzip zip.zip Archive: zip.zipreplace zip.txt? [y]es, [n]o, [A]ll, [N]one, [r]ename: y extracting: zip.txt [root@caoxl cmd]# lssort.txt test.php zip.txt zip.zip// 查看压缩文件目录，但不解压。[root@caoxl cmd]# unzip -v zip.zip Archive: zip.zip Length Method Size Cmpr Date Time CRC-32 Name-------- ------ ------- ---- ---------- ----- -------- ---- 0 Stored 0 0% 01-25-2019 15:34 00000000 zip.txt-------- ------- --- ------- 0 0 0% 1 file tar tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件 1234567891011121314151617181920212223242526272829# 将文件全部打包成tar包// 仅打包, 不压缩[root@caoxl cmd]# lssort.txt test.php zip.txt zip.zip[root@caoxl cmd]# touch tar.txt[root@caoxl cmd]# tar -cvf tar.tar tar.txttar.txt[root@caoxl cmd]# lssort.txt tar.tar tar.txt test.php zip.txt zip.zip// 打包后, 以 gzip 压缩 [root@caoxl cmd]# tar -zcvf tar.tar.gz tar.txttar.txt[root@caoxl cmd]# lssort.txt tar.tar tar.tar.gz tar.txt test.php zip.txt zip.zip// 打包后, 以bzip2压缩[root@caoxl cmd]# tar -jcvf tar.tar.bz2 tar.txttar.txttar (child): bzip2: Cannot exec: No such file or directorytar (child): Error is not recoverable: exiting nowtar: Child returned status 2tar: Error is not recoverable: exiting now[root@caoxl cmd]# lssort.txt tar.bz2 tar.tar tar.tar.bz2 tar.tar.gz tar.txt test.php zip.txt zip.zip// 将tar包解压缩：[root@caoxl cmd]# tar -zxvf tar.tar.gztar.txt gzip gzip命令用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。 12345678910111213141516171819[root@caoxl cmd]# gzip gzip.txt [root@caoxl cmd]# lsgzip.txt.gz tar.bz2 tar.tar.bz2 tar.txt zip.txtsort.txt tar.tar tar.tar.gz test.php zip.zip// 递归的压缩目录[root@caoxl cmd]# mkdir gzip[root@caoxl cmd]# lsgzip sort.txt tar.tar tar.tar.gz test.php zip.zipgzip.txt.gz tar.bz2 tar.tar.bz2 tar.txt zip.txt[root@caoxl cmd]# cd gzip[root@caoxl gzip]# ls[root@caoxl gzip]# touch gzip.txt[root@caoxl gzip]# ..[root@caoxl cmd]# lsgzip sort.txt tar.tar tar.tar.gz test.php zip.zipgzip.txt.gz tar.bz2 tar.tar.bz2 tar.txt zip.txt[root@caoxl cmd]# gzip -rv gzipgzip/gzip.txt: 0.0% -- replaced with gzip/gzip.txt.gz gunzip gunzip命令用来解压缩文件。gunzip是个使用广泛的解压缩程序，它用于解开被gzip压缩过的文件，这些压缩文件预设最后的扩展名为.gz。事实上gunzip就是gzip的硬连接，因此不论是压缩或解压缩，都可通过gzip指令单独完成。 123456789101112[root@caoxl gzip]# lsgzip.txt.gz[root@caoxl gzip]# gzip -d gzip.txt.gz [root@caoxl gzip]# lsgzip.txt[root@caoxl gzip]# gzip gzip.txt [root@caoxl gzip]# lsgzip.txt.gz[root@caoxl gzip]# gunzip gzip.txt.gz [root@caoxl gzip]# lsgzip.txt zipinfo zipinfo命令用来列出压缩文件信息。执行zipinfo指令可得知zip压缩文件的详细信息。 123456789[root@caoxl cmd]# zipinfo tar.tar.gzArchive: tar.tar.gz[tar.tar.gz] End-of-central-directory signature not found. Either this file is not a zipfile, or it constitutes one disk of a multi-part archive. In the latter case the central directory and zipfile comment will be found on the last disk(s) of this archive.zipinfo: cannot find zipfile directory in one of tar.tar.gz or tar.tar.gz.zip, and cannot find tar.tar.gz.ZIP, period. bzip bzip2命令用于创建和管理（包括解压缩）“.bz2”格式的压缩包。 123456789101112[root@caoxl bzip2]# lsbzip2.txt// 压缩[root@caoxl bzip2]# bzip2 bzip2.txt [root@caoxl bzip2]# lsbzip2.txt.bz2// 解压[root@caoxl bzip2]# bzip2 -d bzip2.txt.bz2 [root@caoxl bzip2]# lsbzip2.txt 文件备份和恢复dump dump命令用于备份ext2或者ext3文件系统。可将目录或整个文件系统备份至指定的设备，或备份成一个大文件。 123[root@caoxl backup]# dump -0u -f /root/cmd/backup/backup.bak /home DUMP: You can't update the dumpdates file when dumping a subdirectory DUMP: The ENTIRE dump is aborted. restore restore命令是dump命令的逆过程，用于还原dump命令生成的备份文件。倾倒操作可用来备份文件，而还原操作则是写回这些已备份的文件。 1234dump -9 -u -f /dev/hda3 /home/frank/// 用restore命令来恢复备份：restore rf /dev/hda3 /home/frank 硬件|监测|内核|Shell性能监测与优化nethogs NetHogs是一个开源的命令行工具（类似于Linux的top命令），用来按进程或程序实时统计网络带宽使用率。 123[root@caoxl cmd]# nethogsEthernet link detected Waiting for first packet to arrive (see sourceforge.net bug 1019381) ifstat 统计网络接口流量状态ifstat命令就像iostat/vmstat描述其它的系统状况一样，是一个统计网络接口活动状态的工具。ifstat工具系统中并不默认安装，需要自己下载源码包，重新编译安装，使用过程相对比较简单。 12345678[root@caoxl cmd]# ifstat #kernelInterface RX Pkts/Rate TX Pkts/Rate RX Data/Rate TX Data/Rate RX Errs/Drop TX Errs/Drop RX Over/Rate TX Coll/Rate lo 276 0 276 0 45600 0 45600 0 0 0 0 0 0 0 0 0 eth0 35250 0 11833 0 40777K 0 1116K 0 0 0 0 0 0 0 0 0 dstat 通用的系统资源统计工具dstat命令是一个用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具，是一个全能系统信息统计工具 12345678910111213[root@caoxl cmd]# dstatYou did not select any stats, using -cdngy by default.----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--usr sys idl wai hiq siq| read writ| recv send| in out | int csw 0 0 100 0 0 0| 18k 9796B| 0 0 | 0 0 | 23 22 0 0 100 0 0 0| 0 0 | 60B 106B| 0 0 | 30 23 0 0 100 0 0 0| 0 0 | 60B 890B| 0 0 | 23 22 0 0 100 0 0 0| 0 0 | 60B 362B| 0 0 | 24 24 0 0 100 0 0 0| 0 60k| 60B 362B| 0 0 | 29 29 1 0 100 0 0 0| 0 0 | 60B 362B| 0 0 | 19 16 0 0 100 0 0 0| 0 0 | 60B 362B| 0 0 | 28 23 0 0 100 0 0 0| 0 0 | 60B 362B| 0 0 | 23 22 0 0 100 0 0 0| 0 0 | 60B 362B| 0 0 | 17 16 iotop 用来监视磁盘I/O使用状况的工具iotop命令是一个用来监视磁盘I/O使用状况的top类工具。iotop具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。 -o：只显示有io操作的进程 -b：批量显示，无交互，主要用作记录到文件。 -n NUM：显示NUM次，主要用于非交互式模式。 -d SEC：间隔SEC秒显示一次。 -p PID：监控的进程pid。 -u USER：监控的进程用户。 lsof lsof命令用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof命令需要访问核心内存和各种文件，所以需要root用户执行。 12345678910111213[root@caoxl cmd]# lsof | grep caoxlntpd 506 ntp 20u IPv4 16443 0t0 UDP caoxl:ntp nginx 966 root 6w REG 253,1 1143189 925606 /etc/nginx/logs/caoxl.error.lognginx 966 root 7w REG 253,1 1842057 925607 /etc/nginx/logs/caoxl.access.lognginx 968 www 6w REG 253,1 1143189 925606 /etc/nginx/logs/caoxl.error.lognginx 968 www 7w REG 253,1 1842057 925607 /etc/nginx/logs/caoxl.access.lognginx 970 www 6w REG 253,1 1143189 925606 /etc/nginx/logs/caoxl.error.lognginx 970 www 7w REG 253,1 1842057 925607 /etc/nginx/logs/caoxl.access.lognginx 971 www 6w REG 253,1 1143189 925606 /etc/nginx/logs/caoxl.error.lognginx 971 www 7w REG 253,1 1842057 925607 /etc/nginx/logs/caoxl.access.lognginx 972 www 6w REG 253,1 1143189 925606 /etc/nginx/logs/caoxl.error.lognginx 972 www 7w REG 253,1 1842057 925607 /etc/nginx/logs/caoxl.access.logsshd 10095 root 3u IPv4 27760 0t0 TCP caoxl:ssh-&gt;14.18.29.122:26561 (ESTABLISHED) vmstat vmstat命令的含义为显示虚拟内存状态（“Virtual Memory Statistics”），但是它可以报告关于进程、内存、I/O等系统整体运行状态。 1234[root@caoxl backup]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 3205700 36972 529176 0 0 7 4 11 10 0 0 100 0 0 time time命令用于统计给定命令所花费的总时间。 12345[root@caoxl cmd]# time lsreal 0m0.002suser 0m0.000ssys 0m0.002s iostat iostat命令被用于监视系统输入输出设备和CPU的使用情况。 12345678[root@caoxl cmd]# iostatLinux 3.10.0-862.14.4.el7.x86_64 (caoxl) 01/25/2019 _x86_64_ (2 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.06 0.02 0.04 0.03 0.00 99.84Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtnvda 0.94 14.41 8.18 390997 221968 mpstat mpstat命令指令主要用于多CPU环境下，它显示各个可用CPU的状态。这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。 12345[root@caoxl cmd]# mpstatLinux 3.10.0-862.14.4.el7.x86_64 (caoxl) 01/25/2019 _x86_64_ (2 CPU)05:33:32 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle05:33:32 PM all 0.06 0.02 0.04 0.03 0.00 0.00 0.00 0.00 0.00 99.84 free free命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。 1234[root@caoxl backup]# free -m total used free shared buff/cache availableMem: 3789 106 3130 9 553 3448Swap: 0 0 0 total：内存总数； used：已经使用的内存数； free：空闲的内存数； shared：当前已经废弃不用； buffers Buffer：缓存内存数； cached Page：缓存内存数。 top top命令可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过top命令所提供的互动式界面，用热键可以管理。 uptime uptime命令能够打印系统总共运行了多长时间和系统的平均负载。uptime命令可以显示的信息显示依次为：现在时间、系统已经运行了多长时间、目前有多少登陆用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。 12345678910[root@caoxl cmd]# uptime -Vuptime from procps-ng 3.3.10[root@caoxl backup]# uptime 17:43:53 up 7:42, 1 user, load average: 0.00, 0.01, 0.05 // 显示内容说明 17:43:53 // 系统当前时间 up 7:42 // 主机已运行时间,时间越大,说明你的机器越稳定。 1 user // 用户连接数，是总连接数而不是用户数 load average: 0.00, 0.01, 0.05 // 系统平均负载，统计最近1, 5, 15分钟的系统平均负载 sar sar命令是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。 123456789101112// 察看内存和交换空间的使用率：[root@caoxl cmd]# sar -r | headLinux 3.10.0-693.2.2.el7.x86_64 (Caoxllc) 01/25/2019 _x86_64_ (2 CPU)12:00:01 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty12:10:01 AM 343508 3538184 91.15 275904 2555528 1804876 46.50 1695976 1453476 24812:20:01 AM 343260 3538432 91.16 275904 2555532 1804876 46.50 1696072 1453472 24812:30:01 AM 343948 3537744 91.14 275904 2555540 1804876 46.50 1695916 1453472 24812:40:01 AM 343408 3538284 91.15 275904 2555548 1804876 46.50 1695992 1453468 24812:50:01 AM 343360 3538332 91.15 275904 2555552 1804876 46.50 1696136 1453464 24801:00:01 AM 343252 3538440 91.16 275904 2555556 1804876 46.50 1696100 1453468 24801:10:01 AM 343400 3538292 91.15 275904 2555560 1804876 46.50 1696124 1453460 248 内核与模块管理uname uname显示Linux系统信息, uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。 12345678[root@caoxl cmd]# unameLinux[root@caoxl cmd]# uname -aLinux caoxl 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux[root@caoxl cmd]# uname -mx86_64[root@caoxl cmd]# uname -ncaoxl lsb_release LSB是Linux Standard Base的缩写，lsb_release命令用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。 12[root@caoxl cmd]# lsb_releaseLSB Version: :core-4.1-amd64:core-4.1-noarch 磁盘管理du du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。 123456789101112131415[root@caoxl cmd]# du4 ./backup4 ./gzip4 ./bzip248 .// 显示磁盘的相关信息[root@caoxl cmd]# dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/vda1 41151808 10696136 28342240 28% /devtmpfs 1929864 0 1929864 0% /devtmpfs 1940464 0 1940464 0% /dev/shmtmpfs 1940464 448 1940016 1% /runtmpfs 1940464 0 1940464 0% /sys/fs/cgrouptmpfs 388096 0 388096 0% /run/user/0"}],"posts":[{"title":"他写出了 Vue，却做不对这十道 Vue 笔试题","slug":"Vue-The-Test","date":"2020-09-10T07:17:23.000Z","updated":"2020-09-10T07:43:56.026Z","comments":true,"path":"2020/09/10/Vue-The-Test/","link":"","permalink":"http://blog.caoxl.com/2020/09/10/Vue-The-Test/","excerpt":"原文地址: 他写出了 Vue，却做不对这十道 Vue 笔试题","text":"原文地址: 他写出了 Vue，却做不对这十道 Vue 笔试题 这里搬运过来只是方便自己学习. 上题: Vue 实例的 data 属性，可以在哪些生命周期中获取到？A. beforeCreateB. createdC. beforeMountD. mounted 下列对 Vue 原理的叙述，哪些是正确的？A. Vue 中的数组变更通知，通过拦截数组操作方法而实现B. 编译器目标是创建渲染函数，渲染函数执行后将得到 VNode 树C. 组件内 data 发生变化时会通知其对应 watcher，执行异步更新D. patching 算法首先进行同层级比较，可能执行的操作是节点的增加、删除和更新 对于 Vue 中响应式数据原理的说法，下列哪项是不正确的？A. 采用数据劫持方式，即 Object.defineProperty() 劫持 data 中各属性，实现响应式数据B. 视图中的变化会通过 watcher 更新 data 中的数据C. 若 data 中某属性多次发生变化，watcher 仅会进入更新队列一次D. 通过编译过程进行依赖收集 下列说法不正确的是哪项？A. key 的作用主要是为了高效地更新虚拟 DOMB. 若指定了组件的 template 选项，render 函数不会执行C. 使用 vm.$nextTick 可以确保获得 DOM 异步更新的结果D. 若没有 el 选项，vm.$mount(dom) 可将 Vue 实例挂载于指定元素上 下列关于 Vuex 的描述，不正确的是哪项？A. Vuex 通过 Vue 实现响应式状态，因此只能用于 VueB. Vuex 是一个状态管理模式C. Vuex 主要用于多视图间状态全局共享与管理D. 在 Vuex 中改变状态，可以通过 mutations 和 actions 关于 Vue 组件间的参数传递，下列哪项是不正确的？A. 若子组件给父组件传值，可使用 $emit 方法B. 祖孙组件之间可以使用 provide 和 inject 方式跨层级相互传值C. 若子组件使用 $emit(&#39;say&#39;) 派发事件，父组件可使用 @say 监听D. 若父组件给子组件传值，子组件可通过 props 接受数据 下列关于 vue-router 的描述，不正确的是哪项？A. vue-router 的常用模式有 hash 和 history 两种B. 可通过 addRoutes 方法动态添加路由C. 可通过 beforeEnter 对单个组件进行路由守卫D. vue-router 借助 Vue 实现响应式的路由，因此只能用于 Vue 下列说法不正确的是哪项？A. 可通过 this.$parent 查找当前组件的父组件B. 可使用 this.$refs 查找命名子组件C. 可使用 this.$children 按顺序查找当前组件的直接子组件D. 可使用 $root 查找根组件，并可配合 children 遍历全部组件 下列关于 v-model 的说法，哪项是不正确的？A. v-model 能实现双向绑定B. v-model 本质上是语法糖，它负责监听用户的输入事件以更新数据C. v-model 是内置指令，不能用在自定义组件上D. 对 input 使用 v-model，实际上是指定其 :value 和 :input 关于 Vue 的生命周期，下列哪项是不正确的？A. DOM 渲染在 mounted 中就已经完成了B. Vue 实例从创建到销毁的过程，就是生命周期C. created 表示完成数据观测、属性和方法的运算和初始化事件，此时 $el 属性还未显示出来D. 页面首次加载过程中，会依次触发 beforeCreate，created，beforeMount，mounted，beforeUpdate，updated 参考答案 123456789101. BCD2. ABCD3. BD4. B5. C6. B7. C8. C9. C10. D 逐条判定为什么 Dan Abramov 配不上阿里 P7","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.caoxl.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.caoxl.com/tags/Vue/"}]},{"title":"Vue CLI 3.x 与 2.x的区别","slug":"Vue-2x-3x-Diff","date":"2020-09-09T04:03:30.000Z","updated":"2020-09-09T07:56:32.250Z","comments":true,"path":"2020/09/09/Vue-2x-3x-Diff/","link":"","permalink":"http://blog.caoxl.com/2020/09/09/Vue-2x-3x-Diff/","excerpt":"Vue CLI 3.x 与 2.x的区别","text":"Vue CLI 3.x 与 2.x的区别 主要区别 安装与项目构建 项目目录变化 项目配置变化 安装&amp;项目构建CLI安装123456# cli 2.x npm install -g vue-cli# cli 3.x # 3.x 安装时，如果之前安装了2.x需要卸载2.x再安装npm install -g @vue/cli 项目构建cli2.x123vue init &lt;template-name&gt; &lt;project-name&gt;npm i npm run dev cli3.x 安装新增TypeScript配置选项 新增图形化安装方法 保留了2.x之前的安装方法 123456789vue create hello-worldnpm inpm run serve# 使用vue ui创建新项目(3.x新增)vue ui# 使用旧版（2.X）创建npm install -g @vue/cli-init# 'vue init'的运行效果与‘vue-cli@2.x’相同vue init webpack projectname 3.x后目录结构变化[替换2.x功能的新特性]config目录删除，使用模式的.env文件代替[模式]cli3新增模式概念，每个模式在项目中都有对应的配置文件，项目启动时，对应的文件就会加载，与环境变量不同，一个模式可以包括多个环境变量 Vue CLI 项目默认有三个模式： development 模式用于 vue-cli-service serve production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e test 模式用于 vue-cli-service test:unit 模式需要在启动项目时使用–mode指定 1NODE_ENV=development npm run serve --mode mymode # 模式包含多个环境变量 每个模式有多个环境变量，cli3.x为模式与环境变量指定了一个.env配置文件 123.env # 所有环境.env.mode # mode模式加载的配置文件[优先级高于.env].env.mode.development # mode模式下，development环境所加载的配置文件[优先级最高] .env文件详细信息 这些文件是用来代替config目录的 以VUE_APP_开头的变量可以再代码中通过process.env访问，其他的变量不可访问 process.env始终含有两个特殊变量NODE_ENV和BASE_URL 删除static目录[新增public目录]删除了static目录，它的静态资源转移到public目录中，通过/xx.xx可以直接访问 public详细信息 index.html入口文件从根目录转到public目录下，它拥有3个特殊插值 &lt;%= VALUE %&gt; 用来做不转义插值； &lt;%- VALUE %&gt; 用来做 HTML 转义插值； &lt;% expression %&gt; 用来描述 JavaScript 流程控制 静态资源被转移到public目录存放 cli3项目的静态资源有两种处理方式 在JavaScript或template/css(vue)中通过相对路径导入。这类资源会被webpack处理（不在public目录） 放在public目录或者使用绝对路径被导入的静态资源。这类资源会被直接拷贝，不会经过webpack处理 cli3.x项目配置的不同（build目录删除）2.x版本的项目配置是在config和build中完成，但是，到了3.x版本，这两个目录都被删除，如果需要自定义配置，需要自己新建vue.config.js文件 publicPath 部署应用包时的基本URL，即webpack的output.publicPath 但，vue项目中其他地方会用到publicPath，所以不要修改webpack的output.publicPath outputDir build构建的文件存放的目录 即output.path，但只能修改outputDir，不能修改output.path assetsDir 编译后，在outputDir目录中存放静态资源的目录 lintOnSave 配置eslint后，是否每次保存lint代码，默认启动 runtimeCompiler 是否使用包含运行时编译器的 Vue 构建版本，默认不启动 configureWebpack &amp; chainWebpack 这两个选项是用来配置webpack内容的，前者是合并对象，后者是链式调用 [cli3.6]webpack的build代码压缩默认不开启，需要设置环境变量为production才会开启 devServer 支持所有webpack-dev-server选项 配置项目端口、域名 host、port、https 配置项目跨域代理 proxy 123456module.exports = &#123; port: 8100, devServer: &#123; proxy: 'http://localhost:4000' &#125;&#125; 新增功能特性快速原型开发在cli3.x中可以使用vue serve 和vue build命令对单个*.vue 文件进行快速原型开发 安装全局依赖1npm install -g @vue/cli-service-global vue serve 运行文件1234567vue serve myComponent.vue Usage: serve [options] [entry]在开发环境模式下零配置为 .js 或 .vue 文件启动一个服务器Options: -o, --open 打开浏览器 -c, --copy 将本地 URL 复制到剪切板 -h, --help 输出用法信息 vue build 编译文件12345678vue build myComponent.vue Usage: build [options] [entry]在生产环境模式下零配置构建一个 .js 或 .vue 文件Options: -t, --target &lt;target&gt; 构建目标 (app | lib | wc | wc-async, 默认值：app) -n, --name &lt;name&gt; 库的名字或 Web Components 组件的名字 (默认值：入口文件名) -d, --dest &lt;dir&gt; 输出目录 (默认值：dist) -h, --help 输出用法信息 图形化界面vue cli3 新增一个UI图形化管理页面，可以通过它新建项目、管理原有项目的插件 创建新项目1vue ui # 启动图形化界面 管理原有项目（包括2.X项目） 插件管理（更新，查看）（3.x） 依赖（module）管理（删除、安装、更新、查看）（2.x、3.x） 项目配置修改 （3.x） 项目任务（项目script命令启动、停止操作）（2.x、3.x） cli插件什么是插件 vue cli3.x使用了一套基于插件的架构，cli的相关依赖都是以@vue/cli-plugin-开头的 插件可以修改内部的 webpack 配置，也可以向 vue-cli-service 注入命令 在项目创建的过程中列出的特性，绝大部分都是通过插件来实现的 vue add 插件的安装cli3.x项目提供了vue add命令来安装插件 1vue add @vue/cli-plugin-eslint 特殊的vue-router和vuex它们没有对应的插件，但是依旧可以使用vue add在项目中添加它们 12vue add routervue add vuex 配置文件样例12345678910111213141516171819202122232425262728293031323334353637383940414243444546const path = require('path')function resolve (dir) &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; publicPath: '/', assetsDir: 'static', productionSourceMap: false, configureWebpack: config =&gt; &#123; if (process.env.VUE_APP_NODE_ENV === 'production') &#123; // 为生产环境修改配置... &#125; else &#123; // 为开发环境修改配置... &#125; &#125;, // 解析别名处理 chainWebpack: config =&gt; &#123; config.resolve.alias .set('@img', resolve('src/assets/img')) .set('@c', resolve('src/components')) .set('@m', resolve('src/mixins')) .set('@v', resolve('src/views')) .set('@s', resolve('src/store')) &#125;, // 配置高于chainWebpack中关于 css loader 的配置 css: &#123; // 是否开启支持 foo.module.css 样式 modules: false, // 是否使用 css 分离插件 ExtractTextPlugin，采用独立样式文件载入，不采用 &lt;style&gt; 方式内联至 html 文件中 extract: true, // 是否构建样式地图，false 将提高构建速度 sourceMap: false, // css预设器配置项 loaderOptions: &#123; css: &#123; // options here will be passed to css-loader &#125;, postcss: &#123; // options here will be passed to postcss-loader &#125; &#125; &#125;, devServer: &#123; port: 8010 &#125;&#125; 参考 Vue CLI 3.x 与 2.x的区别 Vue 3教程（适用于Vue 2用户） 使用Vue3.0，我收获了哪些知识点","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.caoxl.com/categories/Vue/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.caoxl.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://blog.caoxl.com/tags/Vue/"}]},{"title":"SQL诊断与优化","slug":"MySQL-Explain-Notes","date":"2020-07-28T02:16:35.000Z","updated":"2020-07-28T03:26:01.164Z","comments":true,"path":"2020/07/28/MySQL-Explain-Notes/","link":"","permalink":"http://blog.caoxl.com/2020/07/28/MySQL-Explain-Notes/","excerpt":"","text":"Explain 诊断Explain各参数的含义如下： 列名 说明 id 执行编号，标识select所属的行。如果在语句中没有子查询或关联查询，只有唯一的select，每行都将显示1.否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置 select_type 显示本行是简单或复杂select，如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUIT table 访问引用哪个表（引用某个查询，如“derived3” type 数据访问/读取操作类型（All、index、range、ref、eq_ref、const/system、NULL） possible_key 揭示哪一些索引可能有利于高效的查找 key 显示mysql实际决定采用哪个索引来优化查询 key_len 显示mysql在索引里使用的字节数 ref 显示了之前的表在key列记录的索引中查找值所用的列或常量 rows 为了找到所需要的行而需要读取的行数，估算值 Extra 额外信息，如using index、filesort等 select_type 常见类型及其含义 SIMPLE: 不包含子查询或者 UNION 操作的查询 PRIMARY: 查询中如果包含任何子查询，那么最外层的查询则被标记为 PRIMARY SUBQUERY: 子查询中第一个 SELECT DEPENDENT SUBQUERY: 子查询中的第一个 SELECT，取决于外部查询 UNION: UNION 操作的第二个或者之后的查询 DEPENDENT UNION: UNION 操作的第二个或者之后的查询,取决于外部查询 UNION RESULT: UNION 产生的结果集 DERIVED: 出现在 FROM 字句中的子查询 type常见类型及其含义 system: 这是 const 类型的一个特例，只会出现在待查询的表只有一行数据的情况下 consts: 常出现在主键或唯一索引与常量值进行比较的场景下，此时查询性能是最优的 eq_ref: 当连接使用的是完整的索引并且是 PRIMARY KEY 或 UNIQUE NOT NULL INDEX 时使用它 ref：当连接使用的是前缀索引或连接条件不是 PRIMARY KEY 或 UNIQUE INDEX 时则使用它 ref_or_null: 类似于 ref 类型的查询，但是附加了对 NULL 值列的查询 index_merge: 该联接类型表示使用了索引进行合并优化 range: 使用索引进行范围扫描，常见于 between、&gt; 、&lt; 这样的查询条件 index: 索引连接类型与 ALL 相同，只是扫描的是索引树，通常出现在索引是该查询的覆盖索引的情况 ALL: 全表扫描，效率最差的查找方式 阿里编码规范要求：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好 key列实际在查询中是否使用到索引的标志字段 Extra列Extra 列主要用于显示额外的信息，常见信息及其含义如下: Using where: MySQL 服务器会在存储引擎检索行后再进行过滤 Using filesort: 通常出现在 GROUP BY 或 ORDER BY语句中，且排序或分组没有基于索引，此时需要使用文件在内存中进行排序，因为使用索引排序的性能好于使用文件排序，所以出现这种情况可以考虑通过添加索引进行优化 Using index: 使用了覆盖索引进行查询，此时不需要访问表，从索引中就可以获取到所需的全部数据 Using index condition: 查找使用了索引，但是需要回表查询数据 Using temporary: 表示需要使用临时表来处理查询，常出现在 GROUP BY 或 ORDER BY 语句中 SQL 优化超大分页场景解决方案如表中数据需要进行深度分页，如何提高效率？在阿里出品的Java编程规范中写道： 利用延迟关联或者子查询优化超多分页场景 说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写 12345# 反例（耗时129.570s）select * from task_result LIMIT 20000000, 10;# 正例（耗时5.114s）SELECT a.* FROM task_result a, (select id from task_result LIMIT 20000000, 10) b where a.id = b.id; 说明task_result表为生产环境的一个表，总数据量为3400万，id为主键，偏移量达到2000万 批量插入1234567# 反例INSERT into person(name,age) values('A',24)INSERT into person(name,age) values('B',24)INSERT into person(name,age) values('C',24)# 正例INSERT into person(name,age) values('A',24),('B',24),('C',24); 说明比较常规，就不多做说明了 like语句的优化like语句一般业务要求都是 &#39;%关键字%&#39; 这种形式，但是依然要思考能否考虑使用右模糊的方式去替代产品的要求，其中阿里的编码规范提到: 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决 123456789101112# 反例（耗时78.843s）EXPLAIN select * from task_result where taskid LIKE '%tt600e6b601677b5cbfe516a013b8e46%' LIMIT 1;# 正例（耗时0.986s）select * from task_result where taskid LIKE 'tt600e6b601677b5cbfe516a013b8e46%' LIMIT 1########################################################################### 对正例的Explain1 SIMPLE task_result range adapt_id adapt_id 98 99 100.00 Using index condition# 对反例的Explain1 SIMPLE task_result ALL 33628554 11.11 Using where 说明task_result表为生产环境的一个表，总数据量为3400万，taskid是一个普通索引列，可见%%这种匹配方式完全无法使用索引，从而进行全表扫描导致效率极低，而正例通过索引查找数据只需要扫描99条数据即可 避免SQL中对where字段进行函数转换或表达式计算123456789101112# 反例select * from task_result where id + 1 = 15551;# 正例select * from task_result where id = 15550;########################################################################### 对正例的Explain1 SIMPLE task_result const PRIMARY PRIMARY 8 const 1 100.00 # 对反例的Explain1 SIMPLE task_result ALL 33631512 100.00 Using where 说明其实在知道了有SQL优化器之后，我个人感觉这种普通的表达式转换应该可以提前进行处理再进行查询，这样一来就可以用到索引了，但是问题又来了，如果mysql优化器可以提前计算出结果，那么写sql语句的人也一定可以提前计算出结果，所以矛盾点在这个地方，导致5.7版本以前的此种情况都无法使用索引吧，未来可能会对其进行优化 使用 ISNULL()来判断是否为 NULL 值说明：NULL 与任何值的直接比较都为 NULL 123# 1） NULL &lt;&gt; NULL 的返回结果是 NULL，而不是 false。 # 2） NULL = NULL 的返回结果是 NULL，而不是 true。 # 3） NULL &lt;&gt; 1 的返回结果是 NULL，而不是 true。 明明有索引为什么还走全表扫描 MYSQL查询优化器针对查询的数据行占总数据量过多时会转化成全表查询 count(*) 还是 count(id) 【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*) count(*) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行 字段类型不同导致索引失效 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效 12345678910111213# 正例EXPLAIN SELECT * FROM `user_coll` where pid = '1';type：refref：const rows:1 Extra:Using index condition# 反例EXPLAIN SELECT * FROM `user_coll` where pid = 1;type：indexref：NULL rows:3(总记录数)Extra:Using where; Using index 说明pid字段有相应索引，且格式为varchar Tips 自建数据表进行测试 12345678CREATE TABLE `student` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `name` varchar(255) NOT NULL, `class` varchar(255) DEFAULT NULL, `page` bigint(20) DEFAULT NULL, `status` tinyint(3) unsigned NOT NULL COMMENT &apos;状态：0 正常，1 冻结，2 删除&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 插入数据 123456789101112131415DELIMITER ;; CREATE PROCEDURE insertData() BEGIN declare i int; set i = 1 ; WHILE (i &lt; 1000000) DO INSERT INTO student(`name`,class,`page`,`status`) VALUES(CONCAT(&apos;class_&apos;, i), CONCAT(&apos;class_&apos;, i), i, (SELECT FLOOR(RAND() * 2))); set i = i + 1; END WHILE; commit; END;;CALL insertData();","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"Explain","slug":"Explain","permalink":"http://blog.caoxl.com/tags/Explain/"}]},{"title":"CentOS7下编译安装PHP8","slug":"Install-PHP8-In-CentOS7","date":"2020-06-28T08:31:14.000Z","updated":"2020-06-28T09:54:27.000Z","comments":true,"path":"2020/06/28/Install-PHP8-In-CentOS7/","link":"","permalink":"http://blog.caoxl.com/2020/06/28/Install-PHP8-In-CentOS7/","excerpt":"CentOS7下编译安装PHP8","text":"CentOS7下编译安装PHP8 下载&amp;解压缩12345wget https://downloads.php.net/~pollita/php-8.0.0alpha1.tar.gztar -zxvf php-8.0.0alpha1.tar.gzcd php-8.0.0alpha1/ 编译安装12345678910111213141516171819202122./configure --prefix=/usr/local/php/php8 \\--with-config-file-path=/usr/local/php/php8 \\--enable-mbstring \\--enable-ftp \\--enable-gd \\--enable-gd-jis-conv \\--enable-mysqlnd \\--enable-pdo \\--enable-sockets \\--enable-fpm \\--enable-xml \\--enable-soap \\--enable-pcntl \\--enable-cli \\--with-openssl \\--with-mysqli=mysqlnd \\--with-pdo-mysql=mysqlnd \\--with-pear \\--with-zlib \\--with-iconv \\--with-curl \\; 输出: 12345678910+--------------------------------------------------------------------+| License: || This software is subject to the PHP License, available in this || distribution in the file LICENSE. By continuing this installation || process, you are bound by the terms of this license agreement. || If you do not agree with the terms of this license, you must abort || the installation process at this point. |+--------------------------------------------------------------------+Thank you for using PHP. 编译错误, 谷歌一下. 1make &amp;&amp; make install 配置 复制配置文件： 1cp php.ini-production /usr/local/php/php8/php.ini 打开错误 12# vim /usr/local/php/php8/php.inidisplay_errors = On 复制fpm的启动脚本： 1cp ./sapi/fpm/init.d.php-fpm /usr/local/php/php8/bin/php-fpm-8 增加执行权限 1 设置软连接 1234# php-fpmln -s /usr/local/php/php8/bin/php-fpm-8 /etc/init.d/php-fpm-8# php.iniln -s /usr/local/php/php8/etc/php.ini /etc/php/php8.ini 修改php-fpm配置文件： 1234567cd /usr/local/php/php8/etccp php-fpm.conf/default php-fpm.confvim php-fpm.conf# 去掉 pid = run/php-fpm.pid 前面的分号# 修改启动用户：user=www-wwwgroup=www-www 编译错误No package &#39;oniguruma&#39; found yum安装rpm包 123yum install https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/o/oniguruma-5.9.5-3.el7.x86_64.rpmyum install https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/o/oniguruma-devel-5.9.5-3.el7.x86_64.rpm 备用下载 oniguruma：http://down.24kplus.com/linux/oniguruma/oniguruma-6.7.0-1.el7.x86_64.rpm oniguruma-devel：http://down.24kplus.com/linux/oniguruma/oniguruma-devel-6.7.0-1.el7.x86_64.rpm 参考 CentOS 7/8 安装 oniguruma 和 oniguruma-devel","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"PHP8","slug":"PHP8","permalink":"http://blog.caoxl.com/tags/PHP8/"}]},{"title":"深入MySQL锁","slug":"Deep-Going-MySQL-Lock","date":"2020-06-23T03:16:11.000Z","updated":"2020-06-23T07:26:48.000Z","comments":true,"path":"2020/06/23/Deep-Going-MySQL-Lock/","link":"","permalink":"http://blog.caoxl.com/2020/06/23/Deep-Going-MySQL-Lock/","excerpt":"高并发场景下锁机制是怎么保证数据的一致性的和事务隔离性的?","text":"高并发场景下锁机制是怎么保证数据的一致性的和事务隔离性的? 锁种类 按照锁的粒度划分：表锁、页锁、行锁； 按照使用的方式划分：共享锁和排它锁； 按照思想划分：乐观锁和悲观锁。 按锁的粒度划分 「表锁」是粒度最大的锁，开销小，加锁快，不会出现死锁，但是由于粒度太大，因此造成锁的冲突几率大，并发性能低。 Mysql中「MyISAM储存引擎就支持表锁」，MyISAM的表锁模式有两种：「表共享读锁」和「表独占写锁」。 当一个线程获取到MyISAM表的读锁的时候，会阻塞其他用户对该表的写操作，但是不会阻塞其它用户对该用户的读操作。 相反的，当一个线程获取到MyISAM表的写锁的时候，就会阻塞其它用户的读写操作对其它的线程具有排它性。 「页锁」的粒度是介于行锁和表锁之间的一种锁，因为页锁是在BDB中支持的一种锁机制，也很少被人提及和使用，所以这里制作概述，不做详解。 「行锁」是粒度最小的锁机制，行锁的加锁开销性能大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高。 行锁是InnoDB默认的支持的锁机制，MyISAM不支持行锁，这个也是InnoDB和MyISAM的区别之一。 按锁的使用方式划分 行锁在使用的方式上可以划分为：「共享读锁（S锁）「和」排它写锁（X锁）」。 当一个事务对Mysql中的一条数据行加上了S锁，当前事务不能修改该行数据只能执行度操作，其他事务只能对该行数据加S锁不能加X锁。 若是一个事务对一行数据加了X锁，该事物能够对该行数据执行读和写操作，其它事务不能对该行数据加任何的锁，既不能读也不能写。 按锁的思想划分「悲观锁和乐观锁是在很多框架都存在的一种思想，不要狭义地认为它们是某一种框架的锁机制」。 数据库管理系统中为了控制并发，保证在多个事务执行时的数据一致性以及事务的隔离性，使用悲观锁和乐观锁来解决并发场景下的问题。 Mysql中「悲观锁的实现是基于Mysql自身的锁机制实现，而乐观锁需要程序员自己去实现的锁机制」，最常见的乐观锁实现就锁机制是「使用版本号实现」。 MyISAMMyISAM中默认支持的表级锁有两种：「共享读锁」 和 「独占写锁」。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。 Mysql中平时读写操作都是隐式的进行加锁和解锁操作，Mysql已经自动帮我们实现加锁和解锁操作了，若是想要测试锁机制，我们就要显示的自己控制锁机制。 Mysql中可以通过以下sql来显示的在事务中显式的进行加锁和解锁操作： 12345678// 显式的添加表级读锁LOCK TABLE 表名 READ// 显示的添加表级写锁LOCK TABLE 表名 WRITE// 显式的解锁（当一个事务commit的时候也会自动解锁）unlock tables; 下面我们就来测试一下MyISAM中的表级锁机制，首先创建一个测试表employee ，这里要指定存储引擎为MyISAM，并插入两条测试数据： 12345678910-- 创建一个测试表CREATE TABLE IF NOT EXISTS employee ( id INT PRIMARY KEY auto_increment, name VARCHAR(40), money INT)ENGINE MyISAM;-- 插入两条测试数据INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 8888);INSERT INTO employee(name, money) VALUES(&apos;lc&apos;, 9999); 查看一下，表结果如下图所示： 12345678MariaDB [test]&gt; select * from employee;+----+-------+-------+| id | name | money |+----+-------+-------+| 1 | caoxl | 8888 || 2 | lc | 9999 |+----+-------+-------+2 rows in set (0.01 sec) MyISAM表级写锁 与此同时再开启一个session窗口，然后在第一个窗口执行下面的sql，在session1中给表添加写锁： 12MariaDB [test]&gt; LOCK TABLE employee WRITE;Query OK, 0 rows affected (0.06 sec) 可以在session2中进行查询或者插入、更新该表数据，可以发现都会处于等待状态，也就是session1锁住了整个表，导致session2只能等待： 1MariaDB [test]&gt; select * from employee; 在session1中进行查询、插入、更新数据，都可以执行成功： 1234567891011121314151617-- 插入MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;caolx&apos;, 1111);Query OK, 1 row affected (0.02 sec)-- 更新MariaDB [test]&gt; UPDATE employee set name=&apos;caoxllc&apos; where id=1; Query OK, 1 row affected (0.14 sec)Rows matched: 1 Changed: 1 Warnings: 0-- 查询MariaDB [test]&gt; SELECT * FROM employee;+----+---------+-------+| id | name | money |+----+---------+-------+| 1 | caoxllc | 8888 || 2 | lc | 9999 || 3 | caolx | 1111 |+----+---------+-------+3 rows in set (0.01 sec) 「总结：」 从上面的测试结果显示 「当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作」。 MyISAM表级共享读锁 接下来测试一下表级共享读锁，同样还是利用上面的测试数据，第一步还是在session1给表加读锁。 12MariaDB [test]&gt; LOCK TABLE employee read;Query OK, 0 rows affected (0.11 sec) 然后在session1中尝试进行插入、更新数据，发现都会报错，只能查询数据。 12345678910111213141516-- 查询MariaDB [test]&gt; select * from employee;+----+---------+-------+| id | name | money |+----+---------+-------+| 1 | caoxllc | 8888 || 2 | lc | 9999 || 3 | caolx | 1111 |+----+---------+-------+3 rows in set (7 min 12.28 sec)-- 插入MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;lxlc&apos;, 2222);ERROR 1099 (HY000): Table &apos;employee&apos; was locked with a READ lock and can&apos;t be updated-- 更新MariaDB [test]&gt; UPDATE employee set name=&apos;lxlc&apos; where id=1;ERROR 1099 (HY000): Table &apos;employee&apos; was locked with a READ lock and can&apos;t be updated 最后在session2中尝试进行插入、更新数据，程序都会进入等待状态，只能查询数据，直到session1解锁表session2才能插入、更新数据。 1MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;lxlc&apos;, 2222); 「总结：」 从上面的测试结果显示 「当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁」。 MyISAM表级锁竞争情况MyISAM存储引擎中，可以通过查询变量来查看并发场景锁的争夺情况，具体执行下面的sql语句： 12345678MariaDB [test]&gt; show status like &apos;table%&apos;;+-----------------------+-------+| Variable_name | Value |+-----------------------+-------+| Table_locks_immediate | 37 || Table_locks_waited | 2 |+-----------------------+-------+2 rows in set (0.27 sec) 主要是查看table_locks_waited和table_locks_immediate的值的大小分析锁的竞争情况。 Table_locks_immediate: 表示能够立即获得表级锁的锁请求次数； Table_locks_waited: 表示不能立即获取表级锁而需要等待的锁请求次数分析，「值越大竞争就越严重」。 并发插入通过上面的操作演示，详细的说明了表级共享锁和表级写锁的特点。但是在平时的执行sql的时候，这些 「解锁和释放锁都是Mysql底层隐式的执行的」。 上面的演示只是为了证明显式的执行事务的过程共享锁和表级写锁的加锁和解锁的特点，实际并不会这么做的。 在我们平时执行select语句的时候就会隐式的加读锁，执行增、删、改的操作时就会隐式的执行加写锁。MyISAM存储引擎中，虽然读写操作是串行化的，但是它也支持并发插入，这个需要设置内部变量concurrent_insert的值。 它的值有三个值0、1、2。可以通过以下的sql查看concurrent_insert的默认值为 「AUTO(或者1)」。 1234567MariaDB [test]&gt; show variables like &quot;%concurrent_insert&quot;;+-------------------+-------+| Variable_name | Value |+-------------------+-------+| concurrent_insert | AUTO |+-------------------+-------+1 row in set (0.25 sec) concurrent_insert的值为: NEVER (or 0)表示不支持比并发插入； AUTO(或者1）表示在MyISAM表中没有被删除的行，运行另一个线程从表尾插入数据； ALWAYS (or 2)表示不管是否有删除的行，都允许在表尾插入数据。 锁调度MyISAM存储引擎中，「假如同时一个读请求，一个写请求过来的话，它会优先处理写请求」，因为MyISAM存储引擎中认为写请求比读请求重要。 这样就会导致，「假如大量的读写请求过来，就会导致读请求长时间的等待，或者”线程饿死”，因此MyISAM不适合运用于大量读写操作的场景」，这样会导致长时间读取不到用户数据，用户体验感极差。 当然可以通过设置low-priority-updates参数，设置请求链接的优先级，使得Mysql优先处理读请求。 InnoDB InnoDB和MyISAM不同的是，InnoDB支持「行锁」和「事务」 InnoDB中除了有「表锁」和「行级锁」的概念，还有Gap Lock（间隙锁）、Next-key Lock锁，「间隙锁主要用于范围查询的时候，锁住查询的范围，并且间隙锁也是解决幻读的方案」。 InnoDB中的行级锁是 「对索引加的锁，在不通过索引查询数据的时候，InnoDB就会使用表锁」。 「但是通过索引查询的时候是否使用索引，还要看Mysql的执行计划」，Mysql的优化器会判断是一条sql执行的最佳策略。 若是Mysql觉得执行索引查询还不如全表扫描速度快，那么Mysql就会使用全表扫描来查询，这是即使sql语句中使用了索引，最后还是执行为全表扫描，加的是表锁。 InnoDB行锁和表锁InnoDB的行锁也是分为行级 「共享读锁（S锁）「和」排它写锁（X锁）」，原理特点和MyISAM的表级锁两种模式是一样的。 若想显式的给表加行级读锁和写锁，可以执行下面的sql语句： 12345// 给查询sql显示添加读锁select ... lock in share mode;// 给查询sql显示添加写锁select ... for update； 下面我们直接进入锁机制的测试阶段，还是创建一个测试表，并插入两条数据： 1234567891011// 先把原来的MyISAM表给删除了DROP TABLE IF EXISTS employee;CREATE TABLE IF NOT EXISTS employee ( id INT PRIMARY KEY auto_increment, name VARCHAR(40), money INT)ENGINE INNODB;// 插入测试数据INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 1000);INSERT INTO employee(name, money) VALUES(&apos;lc&apos;, 2000); 创建的表中可以看出对表中的字段只有id添加了主键索引，接着就是在session1窗口执行begin开启事务，并执行下面的sql语句： 12345678910111213select * from employee where name=&apos;caoxl&apos; for update;MariaDB [test]&gt; begin;Query OK, 0 rows affected (0.01 sec)-- 使用非索引字段查询，并显式的添加写锁MariaDB [test]&gt; select * from employee where name=&apos;caolx&apos; for update;+----+-------+-------+| id | name | money |+----+-------+-------+| 1 | caolx | 1000 || 2 | caolx | 2000 |+----+-------+-------+2 rows in set (0.00 sec) 然后在session2中执行update语句，上面查询的式id=1的数据行，下面update的是id=1的数据行，会发现程序也会进入等待状态： 1MariaDB [test]&gt; update employee set name=&apos;caoxl&apos; where id = 1; 可见若是 「使用非索引查询，直接就是使用的表级锁」，锁住了整个表。 若是session1使用的是id来查询，如下所示： 1234567MariaDB [test]&gt; select * from employee where id=&apos;1&apos; for update; +----+-------+-------+| id | name | money |+----+-------+-------+| 1 | caolx | 1000 |+----+-------+-------+1 row in set (0.14 sec) 那么session2是可以成功update其它数据行的，但是这里我建议使用数据量大的表进行测试，因为前面我说过了 「是否执行索引还得看Mysql的执行计划，对于一些小表的操作，可能就直接使用全表扫描」。 还有一种情况就是：假如我们给name字段也加上了普通索引，那么通过普通索引来查询数据，并且查询到多行数据，拿它是锁这多行数据还是锁整个表呢？ 下面我们来测试一下，首先给「name字段添加普通索引」，如下所示： 123MariaDB [test]&gt; alter table employee add index index_name(name);Query OK, 0 rows affected (0.22 sec)Records: 0 Duplicates: 0 Warnings: 0 并插入一条新的数据name值与id=2的值相同，并显式的加锁，如下所示： 123456789101112131415161718192021222324MariaDB [test]&gt; INSERT INTO employee(name, money) VALUES(&apos;caoxl&apos;, 3000);Query OK, 1 row affected (0.02 sec)MariaDB [test]&gt; select * from employee; +----+-------+-------+| id | name | money |+----+-------+-------+| 1 | caolx | 1000 || 2 | caoxl | 2000 || 3 | caoxl | 3000 |+----+-------+-------+3 rows in set (0.00 sec)MariaDB [test]&gt; begin;Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; select * from employee where name=&apos;caoxl&apos; for update;+----+-------+-------+| id | name | money |+----+-------+-------+| 2 | caoxl | 2000 || 3 | caoxl | 3000 |+----+-------+-------+2 rows in set (0.03 sec) 当update其它数据行name值不是caoxl的也会进入等待状态，并且通过explain来查看是否name=’caoxl’有执行索引，可以看到sql语句是有执行索引条件的。 1234567MariaDB [test]&gt; MariaDB [test]&gt; explain update employee set name=&apos;lc&apos; where id = 1;+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+| 1 | SIMPLE | employee | range | PRIMARY | PRIMARY | 4 | NULL | 1 | Using where |+------+-------------+----------+-------+---------------+---------+---------+------+------+-------------+1 row in set (0.00 sec) 结论 执行非索引条件查询执行的是表锁。 执行索引查询是否是加行锁，还得看Mysql的执行计划，可以通过explain关键字来查看。 用普通键索引的查询，遇到索引值相同的，也会对其他的操作数据行的产生影响。 InnoDB间隙锁当我们使用范围条件查询而不是等值条件查询的时候，InnoDB就会给符合条件的范围索引加锁，在条件范围内并不存的记录就叫做”间隙（GAP）” 大家大概都知道在事务的四大隔离级别中，不可重复读会产生幻读的现象，只能通过提高隔离级别到串行化来解决幻读现象。 但是Mysql中的不可重复是已经解决了幻读问题，它通过引入间隙锁的实现来解决幻读，通过给符合条件的间隙加锁，防止再次查询的时候出现新数据产生幻读的问题。 例如我们执行下面的sql语句，就会对id大于100的记录加锁，在id&gt;100的记录中肯定是有不存在的间隙： 1Select * from employee where id &gt; 100 for update; 接着来测试间隙锁，新增一个字段num，并将num添加为普通索引、修改之前的数据使得num之间的值存在间隙，操作如下sql所示： 12345alter table employee add num int not null default 0;update employee set num = 1 where id = 1;update employee set num = 1 where id = 2;update employee set num = 3 where id = 3;insert into employee values(4,&apos;kris&apos;,4000,5); 12345678910MariaDB [test]&gt; select * from employee; +----+-------+-------+-----+| id | name | money | num |+----+-------+-------+-----+| 1 | caolx | 1000 | 1 || 2 | caoxl | 2000 | 1 || 3 | caoxl | 3000 | 3 || 4 | kris | 4000 | 5 |+----+-------+-------+-----+4 rows in set (0.00 sec) 接着在session1的窗口开启事务，并执行下面操作： 1234567MariaDB [test]&gt; select * from employee where num=3 for update;+----+-------+-------+-----+| id | name | money | num |+----+-------+-------+-----+| 3 | caoxl | 3000 | 3 |+----+-------+-------+-----+1 row in set (0.05 sec) 同时打开窗口session2，并执行新增语句： 1234insert into employee values(5,&apos;ceshi&apos;,5000,2); // 程序出现等待insert into employee values(5,&apos;ceshi&apos;,5000,4); // 程序出现等待insert into employee values(5,&apos;ceshi&apos;,5000,6); // 新增成功insert into employee values(6,&apos;ceshi&apos;,5000,0); // 新增成功 死锁死锁在InnoDB中才会出现死锁，MyISAM是不会出现死锁，因为MyISAM支持的是表锁，一次性获取了所有得锁，其它的线程只能排队等候。 而InnoDB默认支持行锁，获取锁是分步的，并不是一次性获取所有得锁，因此在锁竞争的时候就会出现死锁的情况。 虽然InnoDB会出现死锁，但是并不影响InnoDB最受欢成为迎的存储引擎，MyISAM可以理解为串行化操作，读写有序，因此支持的并发性能低下。 死锁的解决方案首先要解决死锁问题，在程序的设计上，当发现程序有高并发的访问某一个表时，尽量对该表的执行操作串行化，或者锁升级，一次性获取所有的锁资源。 然后也可以设置参数innodb_lock_wait_timeout，超时时间，并且将参数innodb_deadlock_detect打开，当发现死锁的时候，自动回滚其中的某一个事务。 总结上面详细的介绍了MyISAM和InnoDB两种存储引擎的锁机制的实现，并进行了测试。 MyISAM的表锁分为两种模式：「共享读锁」 和 「排它写锁」。获取的读锁的线程对该数据行只能读，不能修改，其它线程也只能对该数据行加读锁。 获取到写锁的线程对该数据行既能读也能写，对其他线程对该数据行的读写具有排它性。 MyISAM中默认写优先于读操作，因此MyISAM一般不适合运用于大量读写操作的程序中。 InnoDB的行锁虽然会出现死锁的可能，但是InnoDB的支持的并发性能比MyISAM好，行锁的粒度最小，一定的方法和措施可以解决死锁的发生，极大的发挥InnoDB的性能。 InnoDB中引入了间隙锁的概念来决解出现幻读的问题，也引入事务的特性，通过事务的四种隔离级别，来降低锁冲突，提高并发性能。","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"MySQL锁","slug":"MySQL锁","permalink":"http://blog.caoxl.com/tags/MySQL锁/"},{"name":"共享锁","slug":"共享锁","permalink":"http://blog.caoxl.com/tags/共享锁/"},{"name":"排他锁","slug":"排他锁","permalink":"http://blog.caoxl.com/tags/排他锁/"},{"name":"行锁","slug":"行锁","permalink":"http://blog.caoxl.com/tags/行锁/"},{"name":"表锁","slug":"表锁","permalink":"http://blog.caoxl.com/tags/表锁/"}]},{"title":"MySQL 面试题 II","slug":"MySQL-Interview-Questions-II","date":"2020-06-18T06:19:56.000Z","updated":"2020-06-18T08:47:15.000Z","comments":true,"path":"2020/06/18/MySQL-Interview-Questions-II/","link":"","permalink":"http://blog.caoxl.com/2020/06/18/MySQL-Interview-Questions-II/","excerpt":"非关系型数据库和关系型数据库区别，优势比较","text":"非关系型数据库和关系型数据库区别，优势比较 非关系型数据库非关系型数据库（感觉翻译不是很准确）称为 NoSQL，也就是 Not Only SQL，不仅仅是 SQL。非关系型数据库不需要写一些复杂的 SQL 语句，其内部存储方式是以 key-value 的形式存在可以把它想象成电话本的形式，每个人名（key）对应电话（value）。常见的非关系型数据库主要有 Hbase、Redis、MongoDB 等。非关系型数据库不需要经过 SQL 的重重解析，所以性能很高；非关系型数据库的可扩展性比较强，数据之间没有耦合性，遇见需要新加字段的需求，就直接增加一个 key-value 键值对即可。 关系型数据库关系型数据库以表格的形式存在，以行和列的形式存取数据，关系型数据库这一系列的行和列被称为表，无数张表组成了数据库，常见的关系型数据库有 Oracle、DB2、Microsoft SQL Server、MySQL等。关系型数据库能够支持复杂的 SQL 查询，能够体现出数据之间、表之间的关联关系；关系型数据库也支持事务，便于提交或者回滚。 MySQL 事务四大特性一说到 MySQL 事务，你肯定能想起来四大特性：原子性、一致性、隔离性、持久性，下面再对这事务的四大特性做一个描述 原子性(Atomicity): 原子性指的就是 MySQL 中的包含事务的操作要么全部成功、要么全部失败回滚，因此事务的操作如果成功就必须要全部应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性(Consistency)：一致性指的是一个事务在执行前后其状态一致。比如 A 和 B 加起来的钱一共是 1000 元，那么不管 A 和 B 之间如何转账，转多少次，事务结束后两个用户的钱加起来还得是 1000，这就是事务的一致性。 持久性(Durability): 持久性指的是一旦事务提交，那么发生的改变就是永久性的，即使数据库遇到特殊情况比如故障的时候也不会产生干扰。 隔离性(Isolation)：隔离性需要重点说一下，当多个事务同时进行时，就有可能出现脏读(dirty read)、不可重复读(non-repeatable read)、幻读(phantom read) 的情况，为了解决这些并发问题，提出了隔离性的概念。 MySQL 常见存储引擎的区别MySQL 常见的存储引擎，可以使用 123456789101112131415mysql&gt; SHOW ENGINES;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| CSV | YES | CSV storage engine | NO | NO | NO || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MyISAM | YES | MyISAM storage engine | NO | NO | NO || InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || ARCHIVE | YES | Archive storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.07 sec) 可以看到，InnoDB 是 MySQL 默认支持的存储引擎，支持事务、行级锁定和外键。 MyISAM 存储引擎的特点在 5.1 版本之前，MyISAM 是 MySQL 的默认存储引擎，MyISAM 并发性比较差，使用的场景比较少，主要特点是 不支持事务操作，ACID 的特性也就不存在了，这一设计是为了性能和效率考虑的。 不支持外键操作，如果强行增加外键，MySQL 不会报错，只不过外键不起作用。 MyISAM 默认的锁粒度是表级锁，所以并发性能比较差，加锁比较快，锁冲突比较少，不太容易发生死锁的情况。 MyISAM 会在磁盘上存储三个文件，文件名和表名相同，扩展名分别是 .frm(存储表定义)、.MYD(MYData,存储数据)、MYI(MyIndex,存储索引)。这里需要特别注意的是 MyISAM 只缓存索引文件，并不缓存数据文件。 MyISAM 支持的索引类型有 全局索引(Full-Text)、B-Tree 索引、R-Tree 索引 Full-Text 索引：它的出现是为了解决针对文本的模糊查询效率较低的问题。 B-Tree 索引：所有的索引节点都按照平衡树的数据结构来存储，所有的索引数据节点都在叶节点 R-Tree索引：它的存储方式和 B-Tree 索引有一些区别，主要设计用于存储空间和多维数据的字段做索引,目前的 MySQL 版本仅支持 geometry 类型的字段作索引，相对于 BTREE，RTREE 的优势在于范围查找。 数据库所在主机如果宕机，MyISAM 的数据文件容易损坏，而且难以恢复。 增删改查性能方面：SELECT 性能较高，适用于查询较多的情况 InnoDB 存储引擎的特点自从 MySQL 5.1 之后，默认的存储引擎变成了 InnoDB 存储引擎，相对于 MyISAM，InnoDB 存储引擎有了较大的改变，它的主要特点是 支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是可重复读(repetable-read)、通过MVCC（并发版本控制）来实现的。能够解决脏读和不可重复读的问题。 InnoDB 支持外键操作。 InnoDB 默认的锁粒度行级锁，并发性能比较好，会发生死锁的情况。 和 MyISAM 一样的是，InnoDB 存储引擎也有 .frm文件存储表结构 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。 InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。 InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。 增删改查性能方面，如果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。 MyISAM 和 InnoDB 存储引擎的对比 锁粒度方面：由于锁粒度不同，InnoDB 比 MyISAM 支持更高的并发；InnoDB 的锁粒度为行锁、MyISAM 的锁粒度为表锁、行锁需要对每一行进行加锁，所以锁的开销更大，但是能解决脏读和不可重复读的问题，相对来说也更容易发生死锁 可恢复性上：由于 InnoDB 是有事务日志的，所以在产生由于数据库崩溃等条件后，可以根据日志文件进行恢复。而 MyISAM 则没有事务日志。 查询性能上：MyISAM 要优于 InnoDB，因为 InnoDB 在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而 MyISAM 可以直接定位到数据所在的内存地址，可以直接找到数据。 表结构文件上： MyISAM 的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而 InnoDB 的表数据文件为:.ibd和.frm(表结构定义)； MySQL 基础架构 大致上来说，MySQL 可以分为Server层和存储引擎层。 Server 层包括连接器、查询缓存、分析器、优化器、执行器，包括大多数 MySQL 中的核心功能，所有跨存储引擎的功能也在这一层实现，包括存储过程、触发器、视图等。 存储引擎层包括 MySQL 常见的存储引擎，包括 MyISAM、InnoDB 和 Memory 等，最常用的是 InnoDB，也是现在 MySQL 的默认存储引擎。存储引擎也可以在创建表的时候手动指定，比如下面 1CREATE TABLE t (i INT) ENGINE = &lt;Storage Engine&gt;; 连接器首先需要在 MySQL 客户端登陆才能使用，所以需要一个连接器来连接用户和 MySQL 数据库，我们一般是使用 1mysql -u 用户名 -p 密码 来进行 MySQL 登陆，和服务端建立连接。在完成 TCP 握手 后，连接器会根据你输入的用户名和密码验证你的登录身份。如果用户名或者密码错误，MySQL 就会提示 Access denied for user，来结束执行。如果登录成功后，MySQL 会根据权限表中的记录来判定你的权限。 查询缓存连接完成后，你就可以执行 SQL 语句了，这行逻辑就会来到第二步：查询缓存。 MySQL 在得到一个执行请求后，会首先去 查询缓存 中查找，是否执行过这条 SQL 语句，之前执行过的语句以及结果会以 key-value 对的形式，被直接放在内存中。key 是查询语句，value 是查询的结果。如果通过 key 能够查找到这条 SQL 语句，就直接返回 SQL 的执行结果。 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果就会被放入查询缓存中。可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，效率会很高。 但是查询缓存不建议使用 为什么呢？因为只要在 MySQL 中对某一张表执行了更新操作，那么所有的查询缓存就会失效，对于更新频繁的数据库来说，查询缓存的命中率很低。 分析器如果没有命中查询，就开始执行真正的 SQL 语句。 首先，MySQL 会根据你写的 SQL 语句进行解析，分析器会先做 词法分析，你写的 SQL 就是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串是什么，代表什么。 然后进行 语法分析，根据词法分析的结果， 语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。如果 SQL 语句不正确，就会提示 You have an error in your SQL syntax 优化器经过分析器的词法分析和语法分析后，你这条 SQL 就合法了，MySQL 就知道你要做什么了。但是在执行前，还需要进行优化器的处理，优化器会判断你使用了哪种索引，使用了何种连接，优化器的作用就是确定效率最高的执行方案。 执行器MySQL 通过分析器知道了你的 SQL 语句是否合法，你想要做什么操作，通过优化器知道了该怎么做效率最高，然后就进入了执行阶段，开始执行这条 SQL 语句 在执行阶段，MySQL 首先会判断你有没有执行这条语句的权限，没有权限的话，就会返回没有权限的错误。如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。对于有索引的表，执行的逻辑也差不多。 至此，MySQL 对于一条语句的执行过程也就完成了。 SQL 的执行顺序我们在编写一个查询语句的时候 1234567891011121314SELECT DISTINCT &lt; select_list &gt;FROM &lt; left_table &gt; &lt; join_type &gt;JOIN &lt; right_table &gt; ON &lt; join_condition &gt;WHERE &lt; where_condition &gt;GROUP BY &lt; group_by_list &gt;HAVING &lt; having_condition &gt;ORDER BY &lt; order_by_condition &gt;LIMIT &lt; limit_number &gt; FROM 连接首先，对 SELECT 语句执行查询时，对 FROM 关键字两边的表执行连接，会形成笛卡尔积，这时候会产生一个虚表VT1(virtual table) 首先先来解释一下什么是笛卡尔积 现在我们有两个集合 A = {0,1} , B = {2,3,4} 那么，集合 A B 得到的结果就是 A B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)}; B A = {(2,0)、{2,1}、{3,0}、{3,1}、{4,0}、(4,1)}; 上面 A B 和 B A 的结果就可以称为两个集合相乘的 笛卡尔积 我们可以得出结论，A 集合和 B 集合相乘，包含了集合 A 中的元素和集合 B 中元素之和，也就是 A 元素的个数 B 元素的个数 再来解释一下什么是虚表 在 MySQL 中，有三种类型的表 一种是永久表，永久表就是创建以后用来长期保存数据的表 一种是临时表，临时表也有两类，一种是和永久表一样，只保存临时数据，但是能够长久存在的；还有一种是临时创建的，SQL 语句执行完成就会删除。 一种是虚表，虚表其实就是视图，数据可能会来自多张表的执行结果。 ON 过滤然后对 FROM 连接的结果进行 ON 筛选，创建 VT2，把符合记录的条件存在 VT2 中。 JOIN 连接第三步，如果是 OUTER JOIN(left join、right join) ，那么这一步就将添加外部行，如果是 left join 就把 ON 过滤条件的左表添加进来，如果是 right join ，就把右表添加进来，从而生成新的虚拟表 VT3。 WHERE 过滤第四步，是执行 WHERE 过滤器，对上一步生产的虚拟表引用 WHERE 筛选，生成虚拟表 VT4。 WHERE 和 ON 的区别 如果有外部列，ON 针对过滤的是关联表，主表(保留表)会返回所有的列; 如果没有添加外部列，两者的效果是一样的; 应用 对主表的过滤应该使用 WHERE; 对于关联表，先条件查询后连接则用 ON，先连接后条件查询则用 WHERE; GROUP BY根据 group by 字句中的列，会对 VT4 中的记录进行分组操作，产生虚拟机表 VT5。如果应用了group by，那么后面的所有步骤都只能得到的 VT5 的列或者是聚合函数（count、sum、avg等）。 HAVING紧跟着 GROUP BY 字句后面的是 HAVING，使用 HAVING 过滤，会把符合条件的放在 VT6 SELECT第七步才会执行 SELECT 语句，将 VT6 中的结果按照 SELECT 进行刷选，生成 VT7 DISTINCT在第八步中，会对 TV7 生成的记录进行去重操作，生成 VT8。事实上如果应用了 group by 子句那么 distinct 是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。 ORDER BY应用 order by 子句。按照 order_by_condition 排序 VT8，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。 什么是临时表，何时删除临时表什么是临时表？MySQL 在执行 SQL 语句的过程中，通常会临时创建一些存储中间结果集的表，临时表只对当前连接可见，在连接关闭时，临时表会被删除并释放所有表空间。 临时表分为两种：一种是内存临时表，一种是磁盘临时表，什么区别呢？内存临时表使用的是 MEMORY 存储引擎，而临时表采用的是 MyISAM 存储引擎。 MEMORY 存储引擎：memory 是 MySQL 中一类特殊的存储引擎，它使用存储在内容中的内容来创建表，而且数据全部放在内存中。每个基于 MEMORY 存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为 frm 类型。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于 MEMORY 的表的生命周期很短，一般是一次性的。 MySQL 会在下面这几种情况产生临时表 使用 UNION 查询：UNION 有两种，一种是UNION ，一种是 UNION ALL ，它们都用于联合查询；区别是 使用 UNION 会去掉两个表中的重复数据，相当于对结果集做了一下去重(distinct)。使用 UNION ALL，则不会排重，返回所有的行。使用 UNION 查询会产生临时表。 使用 TEMPTABLE 算法或者是 UNION 查询中的视图。TEMPTABLE 算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要 MySQL 要先创建好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行相应的查询。 ORDER BY 和 GROUP BY 的子句不一样时也会产生临时表。 DISTINCT 查询并且加上 ORDER BY 时； SQL中用到 SQL_SMALL_RESULT 选项时；如果查询结果比较小的时候，可以加上 SQL_SMALL_RESULT 来优化，产生临时表 FROM 中的子查询； EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 Using Temporary 就表示会用到临时表。 MySQL 常见索引类型索引是存储在一张表中特定列上的数据结构，索引是在列上创建的。并且，索引是一种数据结构。 在 MySQL 中，主要有下面这几种索引 全局索引(FULLTEXT)：全局索引，目前只有 MyISAM 引擎支持全局索引，它的出现是为了解决针对文本的模糊查询效率较低的问题。 哈希索引(HASH)：哈希索引是 MySQL 中用到的唯一 key-value 键值对的数据结构，很适合作为索引。HASH 索引具有一次定位的好处，不需要像树那样逐个节点查找，但是这种查找适合应用于查找单个键的情况，对于范围查找，HASH 索引的性能就会很低。 B-Tree 索引：B 就是 Balance 的意思，BTree 是一种平衡树，它有很多变种，最常见的就是 B+ Tree，它被 MySQL 广泛使用。 R-Tree 索引：R-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种，相对于 B-Tree 来说，R-Tree 的优势在于范围查找。 varchar 和 char 的区别和使用场景MySQL 中没有 nvarchar 数据类型，所以直接比较的是 varchar 和 char 的区别 char ：表示的是定长的字符串，当你输入小于指定的数目，比如你指定的数目是 char(6)，当你输入小于 6 个字符的时候，char 会在你最后一个字符后面补空值。当你输入超过指定允许最大长度后，MySQL 会报错 varchar： varchar 指的是长度为 n 个字节的可变长度，并且是非Unicode的字符数据。n 的值是介于 1 - 8000 之间的数值。存储大小为实际大小。 使用 char 存储定长的数据非常方便、char 检索效率高，无论你存储的数据是否到了 10 个字节，都要去占用 10 字节的空间 使用 varchar 可以存储变长的数据，但存储效率没有 char 高。 什么是 内连接、外连接、交叉连接、笛卡尔积连接的方式主要有三种：外连接、内链接、交叉连接 外连接(OUTER JOIN)：外连接分为三种，分别是左外连接(LEFT OUTER JOIN 或 LEFT JOIN)、右外连接(RIGHT OUTER JOIN 或 RIGHT JOIN) 、全外连接(FULL OUTER JOIN 或 FULL JOIN) MySQL 暂不支持全外连接 内连接(INNER JOIN)：结合两个表中相同的字段，返回关联字段相符的记录。 笛卡尔积(Cartesian product)： 我在上面提到了笛卡尔积，为了方便，下面再列出来一下。 交叉连接的原文是Cross join ，就是笛卡尔积在 SQL 中的实现，SQL中使用关键字CROSS JOIN来表示交叉连接，在交叉连接中，随便增加一个表的字段，都会对结果造成很大的影响。 1SELECT * FROM t_Class a CROSS JOIN t_Student b WHERE a.classid=b.classid 或者不用 CROSS JOIN，直接用 FROM 也能表示交叉连接的效果 1SELECT * FROM t_Class a ,t_Student b WHERE a.classid=b.classid 如果表中字段比较多，不适宜用交叉连接，交叉连接的效率比较差。","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"面试题","slug":"面试题","permalink":"http://blog.caoxl.com/tags/面试题/"}]},{"title":"MySQL 面试题 I","slug":"MySQL-Interview-Questions-I","date":"2020-06-18T02:09:36.000Z","updated":"2020-06-18T06:13:59.000Z","comments":true,"path":"2020/06/18/MySQL-Interview-Questions-I/","link":"","permalink":"http://blog.caoxl.com/2020/06/18/MySQL-Interview-Questions-I/","excerpt":"原文地址:100道MySQL数据库经典面试题解析（收藏版）","text":"原文地址:100道MySQL数据库经典面试题解析（收藏版） MySQL 索引使用有哪些注意事项呢？可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则 索引哪些情况会失效 查询条件包含or，可能导致索引失效 如果字段类型是字符串，where时一定用引号括起来，否则索引失效 like通配符可能导致索引失效。 联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。 在索引列上使用mysql的内置函数，索引失效。 对索引列运算（如，+、-、*、/），索引失效。 索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。 索引字段上使用is null， is not null，可能导致索引失效。 左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。 mysql估计使用全表扫描要比使用索引快,则不使用索引。 索引不适合哪些场景 数据量少的不适合加索引 更新比较频繁的也不适合加索引 区分度低的字段不适合加索引（如性别） 索引的一些潜规则 覆盖索引 回表 索引数据结构（B+树） 最左前缀原则 索引下推 MySQL 遇到过死锁问题吗，你是如何解决的？ 查看死锁日志show engine innodb status; 找出死锁Sql 分析sql加锁情况 模拟死锁案发 分析死锁日志 分析死锁结果 日常工作中你是怎么优化SQL的？ 加索引 避免返回不必要的数据 适当分批量进行 优化sql结构 分库分表 读写分离 说说分库与分表的设计分库分表方案，分库分表中间件，分库分表可能遇到的问题 分库分表方案: 水平分库：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。 水平分表：以字段为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。 常用的分库分表中间件： sharding-jdbc（当当） Mycat TDDL（淘宝） Oceanus(58同城数据库中间件) vitess（谷歌开发的数据库中间件） Atlas(Qihoo 360) 分库分表可能遇到的问题 事务问题：需要用分布式事务啦 跨节点Join的问题：解决这一问题可以分两次查询实现 跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。 数据迁移，容量规划，扩容等问题 ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID 跨分片的排序分页问题（后台加大pagesize处理？） InnoDB与MyISAM的区别 InnoDB支持事务，MyISAM不支持事务 InnoDB支持外键，MyISAM不支持外键 InnoDB支持 MVCC(多版本并发控制)，MyISAM 不支持 select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。 InnoDB不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引） InnoDB支持表、行级锁，而MyISAM支持表级锁 InnoDB表必须有主键，而MyISAM可以没有主键 InnoDB表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。 InnoDB按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。 InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引 数据库索引的原理，为什么要用 B+树，为什么不用二叉树？可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？ 为什么不是一般二叉树？如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。 为什么不是平衡二叉树呢？我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。 那为什么不是B树而是B+树呢？ B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。 B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。 聚集索引与非聚集索引的区别 一个表中只能拥有一个聚集索引，而非聚集索引一个表可以存在多个。 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。 索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。 聚集索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序； limit 1000000 加载很慢的话，你是怎么解决的呢？ 方案一：如果id是连续的，可以这样，返回上次查询的最大记录(偏移量)，再往下limit 1select id，name from employee where id&gt;1000000 limit 10. 方案二：在业务允许的情况下限制页数： 建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。 方案三：order by + 索引（id为索引） 1select id，name from employee order by id limit 1000000，10 方案四：利用延迟关联或者子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联） 1SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id 如何选择合适的分布式主键方案呢？ 数据库自增长序列或字段。 UUID Redis生成ID Twitter的snowflake算法 利用zookeeper生成唯一ID MongoDB的ObjectId 事务的隔离级别有哪些？MySQL的默认隔离级别是什么？ 读未提交（Read Uncommitted） 读已提交（Read Committed） 可重复读（Repeatable Read） 串行化（Serializable） Mysql默认的事务隔离级别是可重复读(Repeatable Read) 什么是幻读，脏读，不可重复读呢？ 事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读 在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。 事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。 在高并发情况下，如何做到安全的修改同一行数据？要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行记录。一般有悲观锁和乐观锁两种方案~ 使用悲观锁悲观锁思想就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如，可以使用select…for update ~ 1select * from User where name = &apos;jay&apos; for update 以上这条sql语句会锁定了User表中所有符合检索条件（name=’jay’）的记录。本次事务提交之前，别的线程都无法修改这些记录。 使用乐观锁乐观锁思想就是，有线程过来，先放过去修改，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。 数据库的乐观锁和悲观锁。悲观锁悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。 乐观锁乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。 SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义。 show status 命令了解各种 sql 的执行频率 通过慢查询日志定位那些执行效率较低的 sql 语句 explain 分析低效 sql 的执行计划（这点非常重要，日常开发中用它分析Sql，会大大降低Sql导致的线上事故） select for update有什么含义，会锁表还是锁行还是其他。select for update 含义select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加锁呢，而且它是悲观锁哦。至于加了是行锁还是表锁，这就要看是不是用了索引/主键啦。 没用索引/主键的话就是表锁，否则就是是行锁。 select for update 加锁验证没用索引/主键的话，select for update加的就是表锁 MySQL事务得四大特性以及实现原理 原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。 一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。 隔离性： 多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。 持久性： 表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。 事务ACID特性的实现思想 原子性：是使用 undo log来实现的，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。 隔离性：通过锁以及MVCC,使事务相互隔离开。 一致性：通过回滚、恢复，以及并发情况下的隔离性，从而实现一致性。 如果某个表有近千万数据，CRUD比较慢，如何优化。分库分表某个表有近千万数据，可以考虑优化表结构，分表（水平分表，垂直分表），当然，你这样回答，需要准备好面试官问你的分库分表相关问题呀，如 分表方案（水平分表，垂直分表，切分规则hash等） 分库分表中间件（Mycat，sharding-jdbc等） 分库分表一些问题（事务问题？跨节点Join的问题） 解决方案（分布式事务等） 索引优化除了分库分表，优化表结构，当然还有所以索引优化等方案~ 如何写sql能够有效的使用到复合索引。复合索引，也叫组合索引，用户可以在多个列上建立索引,这种索引叫做复合索引。 当我们创建一个组合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。 1select * from table where k1=A AND k2=B AND k3=D 有关于复合索引，我们需要关注查询Sql条件的顺序，确保最左匹配原则有效，同时可以删除不必要的冗余索引。 MVCC熟悉吗，它的底层原理？MVCC,多版本并发控制,它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性能的一种机制。 MVCC需要关注这几个知识点： 事务版本号 表的隐藏列 undo log read view MYSQL的主从延迟，你怎么解决？主从复制分了五个步骤进行： 步骤一：主库的更新事件(update、insert、delete)被写到binlog 步骤二：从库发起连接，连接到主库。 步骤三：此时主库创建一个binlog dump thread，把binlog的内容发送到从库。 步骤四：从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log 步骤五：还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db 主从同步延迟的原因一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取binlog的线程仅有一个，当某个SQL在从服务器上执行的时间稍长 或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。 主从同步延迟的解决办法 主服务器要负责更新操作，对安全性的要求比从服务器要高，所以有些设置参数可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置等。 选择更好的硬件设备作为slave。 把一台从服务器当度作为备份使用， 而不提供查询， 那边他的负载下来了， 执行relay log 里面的SQL效率自然就高了。 增加从服务器喽，这个目的还是分散读的压力，从而降低服务器负载。 什么是数据库连接池?为什么需要数据库连接池呢?连接池基本原理： 数据库连接池原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。 应用程序和数据库建立连接的过程： 通过TCP协议的三次握手和数据库服务器建立连接 发送数据库用户账号密码，等待数据库验证用户身份 完成身份验证后，系统可以提交SQL语句到数据库执行 把连接关闭，TCP四次挥手告别。 数据库连接池好处： 资源重用 (连接复用) 更快的系统响应速度 新的资源分配手段 统一的连接管理，避免数据库连接泄漏 一条SQL语句在MySQL中如何执行的？查询语句 先检查该语句是否有权限 如果没有权限，直接返回错误信息 如果有权限，在 MySQL8.0 版本以前，会先查询缓存。 如果没有缓存，分析器进行词法分析，提取 sql 语句select等的关键元素。然后判断sql 语句是否有语法错误，比如关键词是否正确等等。 优化器进行确定执行方案 进行权限校验，如果没有权限就直接返回错误信息，如果有权限就会调用数据库引擎接口，返回执行结果。 InnoDB引擎中的索引策略，了解过吗？ 覆盖索引 最左前缀原则 索引下推 索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 数据库存储日期格式时，如何考虑时区转换问题？ datetime类型适合用来记录数据的原始的创建时间，修改记录中其他字段的值，datetime字段的值不会改变，除非手动修改它。 timestamp类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，timestamp字段的值都会被自动更新。 一条sql执行过长的时间，你如何优化，从哪些方面入手？ 查看是否涉及多表和子查询，优化Sql结构，如去除冗余字段，是否可拆表等 优化索引结构，看是否可以适当添加索引 数量大的表，可以考虑进行分离/分表（如交易流水表） 数据库主从分离，读写分离 explain分析sql语句，查看执行计划，优化sql 查看mysql执行日志，分析是否有其他方面的问题 MYSQL数据库服务器性能分析的方法命令有哪些? Show status, 一些值得监控的变量值： Bytes_received和Bytes_sent 和服务器之间来往的流量。 Com_*服务器正在执行的命令。 Created_*在查询执行期限间创建的临时表和文件。 Handler_*存储引擎操作。 Select_*不同类型的联接执行计划。 Sort_*几种排序信息。 Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况 Blob和text有什么区别？ Blob用于存储二进制数据，而Text用于存储大字符串。 Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。 text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。 Mysql中有哪几种锁，列举一下？如果按锁粒度划分，有以下3种： 表锁： 开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。 行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。 页锁： 开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般 Hash索引和B+树区别是什么？你在设计索引是怎么抉择的？ B+树可以进行范围查询，Hash索引不能。 B+树支持联合索引的最左侧原则，Hash索引不支持。 B+树支持order by排序，Hash索引不支持。 Hash索引在等值查询上比B+树效率更高。 B+树使用like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，Hash索引根本无法进行模糊查询。 mysql 的内连接、左连接、右连接有什么区别？ Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集 left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。 right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。 mysql有关权限的表有哪几个呢？MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。 user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。 db权限表：记录各个帐号在各个数据库上的操作权限。 table_priv权限表：记录数据表级的操作权限。 columns_priv权限表：记录数据列级的操作权限。 host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。 Mysql的binlog有几种录入格式？分别有什么区别？有三种格式哈，statement，row和mixed。 statement，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。 row，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。 mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。 InnoDB引擎的4大特性，了解过吗 插入缓冲（insert buffer) 二次写(double write) 自适应哈希索引(ahi) 预读(read ahead) 索引有哪些优缺点？优点 唯一索引可以保证数据库表中每一行的数据的唯一性 索引可以加快数据查询速度，减少查询时间 缺点 创建索引和维护索引要耗费时间 索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间 以表中的数据进行增、删、改的时候，索引也要动态的维护。 索引有哪几种类型？ 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。 全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并 创建索引有什么原则呢？ 最左前缀匹配原则 频繁作为查询条件的字段才去创建索引 频繁更新的字段不适合创建索引 索引列不能参与计算，不能有函数操作 优先考虑扩展索引，而不是新建索引，避免不必要的索引 在order by或者group by子句中，创建索引需要注意顺序 区分度低的数据列不适合做索引列(如性别） 定义有外键的数据列一定要建立索引。 对于定义为text、image数据类型的列不要建立索引。 删除不再使用或者很少使用的索引 创建索引的三种方式 在执行CREATE TABLE时创建索引 123456CREATE TABLE `employee` ( `id` int(11) NOT NULL, `name` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_name` (`name`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8; 使用ALTER TABLE命令添加索引 1ALTER TABLE table_name ADD INDEX index_name (column); 使用CREATE INDEX命令创建 1CREATE INDEX index_name ON table_name (column); 覆盖索引、回表等这些，了解过吗？ 覆盖索引： 查询列要被所建的索引覆盖，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。 回表：二级索引无法直接查询所有列的数据，所以通过二级索引查询到聚簇索引后，再查询到想要的数据，这种通过二级索引查询出来的过程，就叫做回表。 为什么要使用视图？什么是视图？为什么要使用视图？为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。 什么是视图？视图是一个虚拟的表，是一个表中的数据经过某种筛选后的显示方式，视图由一个预定义的查询select语句组成。 视图有哪些特点？哪些使用场景？视图特点： 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。 视图是由基本表(实表)产生的表(虚表)。 视图的建立和删除不影响基本表。 对视图内容的更新(添加，删除和修改)直接影响基本表。 当视图来自多个基本表时，不允许添加和删除数据。 视图用途简化sql查询，提高开发效率，兼容老的表结构。 视图的常见使用场景 重用SQL语句； 简化复杂的SQL操作。 使用表的组成部分而不是整个表； 保护数据 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 MySQL中都有哪些触发器？MySQL 数据库中有六种触发器： Before Insert After Insert Before Update After Update Before Delete After Delete SQL 约束有哪几种呢？ NOT NULL: 约束字段的内容一定不能为NULL。 UNIQUE: 约束字段唯一性，一个表允许有多个 Unique 约束。 PRIMARY KEY: 约束字段唯一，不可重复，一个表只允许存在一个。 FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。 CHECK: 用于控制字段的值范围。 UNION与UNION ALL的区别？ Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； Union All：对两个结果集进行并集操作，包括重复行，不进行排序； UNION的效率高于 UNION ALL SQL的生命周期？ 服务器与数据库建立连接 数据库进程拿到请求sql 解析并生成执行计划，执行 读取数据到内存，并进行逻辑处理 通过步骤一的连接，发送结果到客户端 关掉连接，释放资源 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等 你们数据库是否支持emoji表情存储，如果不支持，如何操作？更换字符集utf8–&gt;utf8mb4 一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。 如果A表TID是自增长,并且是连续的,B表的ID为索引 1select * from a,b where a.tid = b.id and a.tid&gt;500000 limit 200; 如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。 1select * from b , (select tid from a limit 50000,200) a where b.id = a .tid; 其他 后端程序员必备：索引失效的十大杂症 手把手教你分析Mysql死锁问题 没内鬼，来点干货！SQL优化和诊断","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"面试题","slug":"面试题","permalink":"http://blog.caoxl.com/tags/面试题/"}]},{"title":"三年 Git 使用心得 & 常见问题整理","slug":"Git-Use-Notes","date":"2020-06-15T07:45:01.000Z","updated":"2020-06-15T09:45:54.000Z","comments":true,"path":"2020/06/15/Git-Use-Notes/","link":"","permalink":"http://blog.caoxl.com/2020/06/15/Git-Use-Notes/","excerpt":"原文地址 三年 Git 使用心得 &amp; 常见问题整理","text":"原文地址 三年 Git 使用心得 &amp; 常见问题整理 Git 流程图 Workspace: 工作区 Index/Stage: 暂存区 Repository: 仓库区(或本地仓库) Remote: 远程仓库 配置 Git12345678910# 配置全局用户git config --global user.name \"用户名\"git config --global user.email \"git账号\"# 美化log的输出, 并配置别名alias gll=\"git log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'\";# 删除全局配置git config --global --unset alias.xxxgit config --global --unset user.xxx 查看 Git 信息1234567891011121314151617181920212223242526# 查看系统配置git config --list# 查看用户配置cat ~/.gitconfig# 查看当前项目的git配置cat .git/config# 查看暂存区的文件git ls-files# 查看本地git命令历史git reflog# 查看所有git命令git --help -a# 查看当前HEAD指向cat .git/HEAD# 查看提交历史git log --online --grep=\"关键字\" --author \"username\" --before 1 day/1 week/1 \"2020-06-15\" git reflog12345$ git reflogcbff89f (HEAD -&gt; master, origin/master) HEAD@&#123;0&#125;: commit: Laravel7 初始化8b1a09f HEAD@&#123;1&#125;: commit: Laravel7 初始化c6dcc6b HEAD@&#123;2&#125;: commit: test jenkinsf76c78d HEAD@&#123;3&#125;: commit (initial): Laravel7 初始化 显示的是一个 HEAD 指向发生改变的时间列表。在你切换分支、用 git commit 进行提交、以及用 git reset 撤销 commit 时，HEAD 指向会改变，但当你进行 git checkout -- &lt;filename&gt; 撤销或者 git stash 存储文件等操作时，HEAD 并不会改变，这些修改从来没有被提交过，因此 reflog 也无法帮助我们恢复它们。 git reflog 不会永远保持，Git 会定期清理那些 “用不到的” 对象，不要指望几个月前的提交还一直在那里。 git log 点线图 git 中一条分支就是一个指针，新建一条分支就是基于当前指针新建一个指针 切换至某个分支 ，就是将 HEAD 指向某条分支（指针） 切换至某个 commit ，就是将 HEAD 指向某个 commit 符号解释： 12345* 表示一个 commit| 表示分支前进/ 表示分叉\\ 表示合入|/ 表示新分支 Git 常用命令1234567891011121314151617181920212223242526272829303132333435363738# 查看工作区和暂存区的状态git status# 将工作区的文件提交到暂存区git add .# 提交到本地仓库git commit -m \"本次提交说明\"# add和commit的合并，便捷写法（未追踪的文件无法直接提交到暂存区/本地仓库）git commit -am \"本次提交说明\"# 将本地分支和远程分支进行关联git push -u origin branch_name# 将本地仓库的文件推送到远程分支git push# 拉取远程分支的代码git pull origin branch_name# 合并分支git merge branch_name# 查看本地分支git branch# 查看所有分支git branch -a# 切换分支git checkout branch_name# 临时将工作区文件的修改保存至堆栈中git stash# 将之前保存至堆栈中的文件取出来git stash pop Git 常用命令详解add将工作区的文件添加到暂存区 12345678910111213141516171819202122232425# 添加指定文件到暂存区(追踪新增的指定文件)git add [file1] [file2] ...# 添加指定目录到暂存区, 包括子目录git add [dir]# 添加当前目录的所有文件到暂存区(追踪所有新增的文件)git add .# 删除工作区/暂存区的文件git rm [file1] [file2] ...# 改名工作区/暂存区的文件git mv [file-origine] [file-renamed]# Git 2.0 以下版本# 只作用于文件的新增和修改git add .# 只作用于文件的修改和删除git add -u# 作用于文件的增删改git add -A# Git 2.0版本git add . // 等价于 git add -A git add . ：操作的对象是“当前目录”所有文件变更，”.” 表示当前目录。会监控工作区的状态树，使用它会把工作区的所有变化提交到暂存区，包括文件内容修改（modified）以及新文件（new），但不包括被删除的文件。 git add -u ：操作的对象是整个工作区已经跟踪的文件变更，无论当前位于哪个目录下。仅监控已经被 add 的文件（即 tracked file），它会将被修改的文件（包括文件删除）提交到暂存区。git add -u 不会提交新文件（untracked file）。（git add --update 的缩写） git add -A ：操作的对象是“整个工作区”所有文件的变更，无论当前位于哪个目录下。是上面两个功能的合集（git add --all 的缩写）。 status12# 查看工作区和暂存区的状态git status commit123456789101112131415161718# 将暂存区的文件提交到本地仓库并添加提交说明git commit -m \"本次提交的说明\"# add 和 commit 的合并，便捷写法git commit -am \"本次提交的说明\"# 跳过验证继续提交git commit --no-verifygit commit -n# 编辑器会弹出上一次提交的信息，可以在这里修改提交信息git commit --amend# 修复提交, 同时修改提交信息git commit --amend -m \"本次提交的说明\"# 加入 --no-edit 标记会修复提交但不修改提交信息, 编辑器不会弹出上一次提交的信息git commit --amend --no-edit push &amp; pull 分支推送顺序的写法是 &lt;来源地&gt;:&lt;目的地&gt; 1234567891011121314151617181920212223242526272829303132333435# 将本地仓库的文件推送到远程分支# 如果远程仓库没有这个分支，会新建一个同名的远程分支# 如果省略远程分支名，则表示两者同名git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;git push origin branch_name# 如果省略本地分支名，则表示删除指定的远程分支# 因为这等同于推送一个空的本地分支到远程分支。git push origin :branch_name# 等同于git push origin --delete branch_name# 建立当前分支和远程分支的追踪关系git push -u origin master# 如果当前分支与远程分支存在追踪关系则可以省略分支和 -u git push# 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机git push --all origin# 拉取所有远程分支到本地镜像仓库中git pull# 拉取并合并项目其他人员的一个分支git pull origin branch_name# 等同于 fetch + mergegit fetch origin branch_namegit merge origin/branch_name# 如果远程主机的版本比本地版本更新，推送时 Git 会报错，要求先在本地做 git pull 合并差异，# 然后再推送到远程主机。这时，如果你一定要推送，可以使用 –-force 选项 # (尽量避免使用)git push --force origin# 或git push -f orign branch1234567891011121314151617181920212223242526272829303132333435363738394041424344# 查看本地分支git branch | git branch -l# 查看远程分支git branch -r# 查看所有分支(本地分支+远程分支)git branch -a# 查看所有分支并带上最新的提交信息git branch -av# 查看本地分支对应的远程分支git branch -vv# 新建分支# 在别的分支下新建一个分支，新分支会复制当前分支的内容# 注意：如果当前分支有修改，但是没有提交到仓库，此时修改的内容是不会被复制到新分支的git branch branch_name# 切换分支(切换分支时，本地工作区，仓库都会相应切换到对应分支的内容)git checkout branch_name# 创建一个 caoxl 分支，并切换到该分支 （新建分支和切换分支的简写）git checkout -b caoxl# 可以看做是基于 master 分支创建一个 caoxl 分支，并切换到该分支git checkout -b caoxl master# 新建一条空分支（详情请看问题列表）git checkout --orphan empty_branch_namegit rm -rf .# 删除本地分支, 会阻止删除保护未合并更改的分支git branch -D branch_name# 删除远程分支# 推送一个空分支到远程分支，其实就相当于删除远程分支git push orign :远程分支名# 或者git push origin --delete 远程分支名# 修改当前分支名git branch -m branch_name merge 三种常用合并方法1234567# 默认 fast-forward ，HEAD 指针直接指向被合并的分支git merge# 禁止快进式合并git merge --no-ff git merge --squash fast-forward：会在当前分支的提交历史中添加进被合并分支的提交历史（得先理解什么时候会发生快速合并，并不是每次 merge 都会发生快速合并）； --no-ff：会生成一个新的提交，让当前分支的提交历史不会那么乱； --squash：不会生成新的提交，会将被合并分支多次提交的内容直接存到工作区和暂存区，由开发者手动去提交，这样当前分支最终只会多出一条提交记录，不会掺杂被合并分支的提交历史 stash 能够将所有未提交的修改保存至堆栈中，用于后续恢复当前工作区内容 如果文件没有提交到暂存区（使用 git add . 追踪新的文件），使用该命令会提示 No local changes to save ，无法将修改保存到堆栈中 使用场景： 当你接到一个修复紧急 bug 的任务时候，一般都是先创建一个新的 bug 分支来修复它，然后合并，最后删除。但是，如果当前你正在开发功能中，短时间还无法完成，无法直接提交到仓库，这时候可以先把当前工作区的内容 git stash 一下，然后去修复 bug，修复后，再 git stash pop，恢复之前的工作内容。 123456789# 将所有未提交的修改（提交到暂存区）保存至堆栈中git stash# 给本次存储加个备注, 以防时间久了忘了git stash save \"存储\"# 存储未追踪的文件git stash -u# 查看存储记录git stash list diff12345678910111213141516# 查看工作区和暂存区单个文件的对比git diff filename# 查看工作区和暂存区所有文件的对比git diff# 查看工作区和暂存区所有文件的对比，并显示出所有有差异的文件列表git diff --stat# 查看暂存区与上次提交到本地仓库的快照（即最新提交到本地仓库的快照）的对比git diff --cached/--staged# 查看工作区与上次提交到本地仓库的快照（即最新提交到本地仓库的快照）的对比git diff branch_name# 查看工作区与 HEAD 指向（默认当前分支最新的提交）的对比git diff HEAD# 查看两个commit的对比git diff commit1..commit2 remote12345678# 查看所有远程主机git remote# 查看关联的远程仓库的详细信息git remote -v# 删除远程仓库的\"关联\"git remote rm projectname# 设置远程仓库的\"关联\"git remote set-url origin &lt;newurl&gt; tag123456789101112131415161718192021222324252627# 默认在 HEAD 上创建一个标签 git tag v1.0# 指定一个 commit id 创建一个标签 git tag v0.9 f52c633# 创建带有说明的标签，用 -a 指定标签名，-m 指定说明文字git tag -a v0.1 -m \"version 0.1 released\" # 查看所有标签git tag# 查看单个标签具体信息git show &lt;tagname&gt; # 推送一个本地标签git push origin &lt;tagname&gt;# 推送全部未推送的本地标签git push origin --tags# 删除本地标签git tag -d v0.1# 因为创建的标签都只存储在本地，不会自动推送到远程。# 所以，打错的标签可以在本地安全删除。git tag -d v0.1# 删除一个远程标签（先删除本地 tag ，然后再删除远程 tag）git push origin :refs/tags/&lt;tagname&gt; revert1234567891011121314151617# 生成一个撤销最近的一次提交的新提交git revert HEAD # 生成一个撤销最近一次提交的上一次提交的新提交git revert HEAD^ # 生成一个撤销最近一次提交的上两次提交的新提交git revert HEAD^^ # 生成一个撤销最近一次提交的上n次提交的新提交git revert HEAD~num # 生成一个撤销指定提交版本的新提交git revert &lt;commit_id&gt;# 生成一个撤销指定提交版本的新提交，执行时不打开默认编辑器，直接使用 Git 自动生成的提交信息git revert &lt;commit_id&gt; --no-edit 新建一个 Git 项目的两种方式本地新建好 Git 项目，然后关联远程仓库12345678# 初始化一个Git仓库git init# 关联远程仓库git remote add &lt;name&gt; &lt;git-repo-url&gt;# 例如git remote add origin https://github.com/xxxxxx clone 远程仓库12345# 新建好远程仓库，然后 clone 到本地git clone &lt;git-repo-url&gt;# 将远程仓库下载到（当前 git bash 启动位置下面的）指定文件中，如果没有会自动生成git clone &lt;git-repo-url&gt; &lt;project-name&gt; Git 钩子pre-commit pre-commit 就是在代码提交之前做些东西，比如代码打包，代码检测，称之为钩子（hook） 在 commit 之前执行一个函数（callback）。这个函数成功执行完之后，再继续 commit，但是失败之后就阻止 commit 在 .git/hooks/下面有个 pre-commit.sample* ，这个里面就是默认的函数(脚本)样本 安装 pre-commit1npm install pre-commit --save-dev 配置脚本如果没有在 .git/hooks 目录下生成 pre-commit 文件的话，则要手工创建 node ./node_modules/pre-commit/install.js 123456789\"scripts\": &#123; \"build\": \"tsc\", \"eslint\": \"eslint src --ext .ts\", \"eslint:fix\": \"eslint src --ext .ts --fix\" &#125;, //在提交代码之前，先执行 scripts 中的 eslint 命令 \"pre-commit\": [ \"eslint\" ] 跳过 pre-commit 继续提交代码123# 跳过验证git commit --no-verifygit commit -n 常见问题将本地新建的项目上传到新建的远程仓库上之前没有进行过关联，即没有通过 clone 远程项目到本地再开始做项目，而是先本地新建了一个项目，然后想传到远程仓库上。 12345678# 将本地仓库和远程仓库关联起来git remote add origin 远程仓库地址# 将本地的 master 分支推送到 origin 主机，同时指定 origin 为默认主机git push -u origin master# 上面的命名执行后，下次再从本地库上传内容的时候只需下面这样就可以了git push 不小心把某些文件上传到远程 git 仓库/想要删除远程仓库中的文件12345# 删除暂存区和工作区的文件git rm filename# 只删除暂存区的文件, 不会删除工作区的文件git rm --cached filename 每次 git push 都要输入用户名、密码12345678910111213# 生成公钥ssh-keygen -t rsa -C \"xxxxx@xxxxx.com\"# 查看已生成的公钥cat ~/.ssh/id_rsa.pub# 复制已生成的公钥添加到 git 服务器# 测试ssh是否能够连接成功ssh -T git@github.com# 设置远程仓库git remote set-url origin git@xxx.com/xxx.git","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.caoxl.com/tags/Git/"}]},{"title":"使用 Gitlab+Jenkins 实现自动化构建","slug":"Gitlab-Jenkins-AutoBuild","date":"2020-06-03T01:20:01.000Z","updated":"2020-06-04T06:22:29.000Z","comments":true,"path":"2020/06/03/Gitlab-Jenkins-AutoBuild/","link":"","permalink":"http://blog.caoxl.com/2020/06/03/Gitlab-Jenkins-AutoBuild/","excerpt":"使用 Gitlab+Jenkins 实现自动化构建","text":"使用 Gitlab+Jenkins 实现自动化构建 准备工作Jenkins 密钥配置 设置jenkins的shell终端为/bin/bash 12[root@caoxl ~]# grep jenkins /etc/passwdjenkins:x:990:987:Jenkins Automation Server:/var/lib/jenkins:/bin/false 登录到jenkins用户生成密钥 1234[root@caoxl ~]# su - jenkinsLast login: Wed Jun 3 15:27:02 CST 2020 on pts/3[root@caoxl ~]# ssh-keygen -t rsa[root@caoxl ~]# cat ~/.ssh/id_rsa.pub 添加公钥到gitlab服务器，用来clone代码 添加完成之后从gitlab服务器clone下自己的工程，会在.ssh/known_hosts添加gitlab服务器记录 添加公钥到jenkins服务器root用户，用来执行部署脚本 1234567891011// 输入以下, 并且输入服务器密码即可[root@caoxl ~]# ssh-copy-id -i .ssh/id_rsa.pub root@47.107.169.233/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \".ssh/id_rsa.pub\"/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keysroot@47.107.169.233's password: Number of key(s) added: 1Now try logging into the machine, with: \"ssh 'root@47.107.169.233'\"and check to make sure that only the key(s) you wanted were added. 准备一个脚本script123[root@caoxl deploy]# cat /shell/deploy/jenkins_deploy.sh#!/bin/bashecho \"部署脚本被执行\" 注意：如果是生产配置，直接把这个脚本换成对应项目的上线脚本即可，jenkins配置无须修改。 正式脚本 /bin/sh /shell/deploy/jenkins_deploy.sh ${WORKSPACE} ${JOB_NAME} ${BUILD_NUMBER} 12345678cd /$&#123;WORKSPACE&#125;tar -zcvf /var/www/code_backup/$&#123;JOB_NAME&#125;_$&#123;BUILD_NUMBER&#125;.tar.gz $&#123;JOB_NAME&#125;tar -zcvf /var/www/code_backup/$&#123;JOB_NAME&#125;_$&#123;BUILD_NUMBER&#125;_bak.tar.gz /var/www/lumen6.caoxl.commv /var/www/code_backup/$&#123;JOB_NAME&#125;_$&#123;BUILD_NUMBER&#125;.tar.gz /var/www/cd /var/www/tar -zxvf $&#123;JOB_NAME&#125;_$&#123;BUILD_NUMBER&#125;.tar.gzrm $&#123;JOB_NAME&#125;_$&#123;BUILD_NUMBER&#125;.tar.gzchown -Rf www:www * Jenkins 触发式构建 用于开发环境部署，开发人员push代码或者合并代码到gitlab项目的master分支，jenkins就部署代码到对应服务器。 Jenkins 参数化构建 用于测试环境预上线环境部署，开发push代码或者合并代码到gitlab项目的master分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。 Jenkins 定时构建 用于APP自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就每天凌晨从gitlab拉取最新的APP代码打包。","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://blog.caoxl.com/tags/Jenkins/"},{"name":"Gitlab","slug":"Gitlab","permalink":"http://blog.caoxl.com/tags/Gitlab/"},{"name":"自动化构建","slug":"自动化构建","permalink":"http://blog.caoxl.com/tags/自动化构建/"}]},{"title":"CentOS7 安装部署 Jenkins","slug":"Install-Jenkins-In-CentOS7","date":"2020-06-02T03:40:05.000Z","updated":"2020-06-02T07:20:23.000Z","comments":true,"path":"2020/06/02/Install-Jenkins-In-CentOS7/","link":"","permalink":"http://blog.caoxl.com/2020/06/02/Install-Jenkins-In-CentOS7/","excerpt":"Jenkins是一个开源的支持自动化构建、部署等任务的平台。基本上可以说是持续集成（CI）、持续发布（CD）不可或缺的工具。Jenkins 官网","text":"Jenkins是一个开源的支持自动化构建、部署等任务的平台。基本上可以说是持续集成（CI）、持续发布（CD）不可或缺的工具。Jenkins 官网 准备工作本篇环境信息 工具/环境 版本 Linux Server CentOS7 Jenkins 2.222.4 JDK 1.8.0_212 Nginx 1.15.1 查看JAVA SDK版本 1234[root@caoxl ~]# java -versionopenjdk version \"1.8.0_212\"OpenJDK Runtime Environment (build 1.8.0_212-b04)OpenJDK 64-Bit Server VM (build 25.212-b04, mixed mode) 查看Nginx版本 1234[root@caoxl ~]# /usr/local/nginx/sbin/nginx -Vnginx version: nginx/1.15.1built by gcc 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) configure arguments: 查看Jenkins端口 12[root@caoxl ~]# cat /etc/sysconfig/jenkins | grep \"JENKINS_PORT\"JENKINS_PORT=\"8080\" 安装JenkinsYum安装 yum源导入 12345#添加Yum源sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo#导入密钥sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key 安装 1sudo yum install -y jenkins 开放端口Jenkins站点的默认监听端口是8080 12sudo firewall-cmd --add-port=8080/tcp --permanentsudo firewall-cmd --reload 配置Java可选路径因为Jenkins默认的java可选路径不包含我们部署的jdk路径，所以这里要配置一下，不然Jenkins服务会启动失败 123456789101112131415#修改jenkins启动脚本sudo vi /etc/init.d/jenkins#修改candidates增加java可选路径：/usr/java/jdk1.8.0_181/bin/javacandidates=\" /etc/alternatives/java /usr/lib/jvm/java-1.8.0/bin/java /usr/lib/jvm/jre-1.8.0/bin/java /usr/lib/jvm/java-1.7.0/bin/java /usr/lib/jvm/jre-1.7.0/bin/java /usr/lib/jvm/java-11.0/bin/java /usr/lib/jvm/jre-11.0/bin/java /usr/lib/jvm/java-11-openjdk-amd64 /usr/bin/java\" 启动Jenkins并设置Jenkins开机启动123456789#重载服务（由于前面修改了Jenkins启动脚本）sudo systemctl daemon-reload#启动Jenkins服务sudo systemctl start jenkins#将Jenkins服务设置为开机启动#由于Jenkins不是Native Service，所以需要用chkconfig命令而不是systemctl命令sudo /sbin/chkconfig jenkins on 浏览器输入 http://&lt;ip address&gt;:8080 访问Jenkins 修改Jenkins端口12345vim /etc/sysconfig/jenkinsJENKINS_PORT=\"8080\" // 修改成自己需要的端口即可// 重新启动jenkinssystemctl restart jenkins 配置Nginx反向代理Jenkins 新建配置文件 123456789101112131415161718#新增Jenkins专用Nginx配置文件sudo vi /etc/nginx/conf.d/jenkins.conf#输入以下内容并保存server &#123; listen 80;#监听80端口 server_name jenkins.caoxl.com;#监听的域名 access_log /var/log/nginx/jenkins.access.log main; error_log /var/log/nginx/jenkins.error.log error; location / &#123; #转发或处理 proxy_pass http://127.0.0.1:8080; &#125; error_page 500 502 503 504 /50x.html;#错误页 location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 重载Nginx配置 1sudo nginx -s reload 报-bash: nginx: command not found, 解决办法 123[root@caoxl sbin]# vi /etc/profileexport PATH=$PATH:/usr/local/nginx/sbin // Nginx可执行文件路径[root@caoxl sbin]# source /etc/profile 解决Jenkins插件下载慢的问题修改插件下载链接123456789vim /var/lib/jenkins/hudson.model.UpdateCenter.xml# 修改https://updates.jenkins.io/update-center.json# 为http://mirror.xmission.com/jenkins/updates/update-center.json# 重新启动jenkinssystemctl restart jenkins 修改default.jsoncd 到updates目录,找到default.json文件 1234567[root@caoxl updates]# pwd/var/lib/jenkins/updates[root@caoxl updates]# lltotal 2.2M-rw-r--r-- 1 jenkins jenkins 1.9M Jun 2 14:22 default.json-rw-r--r-- 1 jenkins jenkins 5.3K Jun 2 14:22 hudson.tasks.Maven.MavenInstaller-rw-r--r-- 1 jenkins jenkins 274K Jun 2 14:53 hudson.tools.JDKInstaller 使用vi编辑文件，如下，替换所有插件下载的url 1:1,$s/http:\\/\\/updates.jenkins-ci.org\\/download/https:\\/\\/mirrors.tuna.tsinghua.edu.cn\\/jenkins/g 替换连接测试url 1:1,$s/http:\\/\\/www.google.com/https:\\/\\/www.baidu.com/g 进入vi先输入:然后再粘贴上边的:后边的命令，注意不要写两个冒号! 参考 使用CentOS7安装配置Jenkins CentOS 7 下Jenkins安装部署教程","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"http://blog.caoxl.com/tags/Jenkins/"},{"name":"CentOS7","slug":"CentOS7","permalink":"http://blog.caoxl.com/tags/CentOS7/"}]},{"title":"CentOS7 安装部署 Gitlab","slug":"Install-Gitlab-In-Centos7","date":"2020-06-01T01:46:29.000Z","updated":"2020-06-02T06:28:54.000Z","comments":true,"path":"2020/06/01/Install-Gitlab-In-Centos7/","link":"","permalink":"http://blog.caoxl.com/2020/06/01/Install-Gitlab-In-Centos7/","excerpt":"GitLab一个开源的git仓库管理平台，方便团队协作开发、管理。","text":"GitLab一个开源的git仓库管理平台，方便团队协作开发、管理。 准备工作安装基础依赖123456# 安装基础依赖sudo yum install -y curl policycoreutils-python openssh-server# 启动ssh服务&amp;设置为开机启动sudo systemctl enable sshdsudo systemctl start sshd 安装PostfixPostfix是一个邮件服务器，GitLab发送邮件需要用到 123456#安装postfixsudo yum install -y postfix#启动postfix并设置为开机启动sudo systemctl enable postfixsudo systemctl start postfix 报 Job for postfix.service failed because the control process exited with error code. See &quot;systemctl status postfix.service&quot; and &quot;journalctl -xe&quot; for details.错误, 解决办法: 12345# 修改 /etc/postfix/main.cf 的设置inet_protocols = ipv4inet_interfaces = all# 重新启动postfix即可sudo systemctl restart postfix.service 开放ssh以及http服务（80端口）123456#开放ssh、http服务sudo firewall-cmd --add-service=ssh --permanentsudo firewall-cmd --add-service=http --permanent#重载防火墙规则sudo firewall-cmd --reload 报 FirewallD is not running, 解决办法: 1sudo systemctl start firewalld 部署过程本次我们部署的是社区版:gitlab-ce，如果要部署商业版可以把关键字替换为：gitlab-ee Yum安装GitLab 添加GitLab社区版Package 1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash 安装GitLab社区版 1sudo yum install -y gitlab-ce 安装成功后会看到gitlab-ce打印了以下图形 123456789101112131415161718192021222324 *. *. *** *** ***** ***** .****** ******* ******** ******** ,,,,,,,,,***********,,,,,,,,, ,,,,,,,,,,,*********,,,,,,,,,,, .,,,,,,,,,,,*******,,,,,,,,,,,, ,,,,,,,,,*****,,,,,,,,,. ,,,,,,,****,,,,,, .,,,***,,,, ,*,. _______ __ __ __ / ____(_) /_/ / ____ _/ /_ / / __/ / __/ / / __ `/ __ \\ / /_/ / / /_/ /___/ /_/ / /_/ / \\____/_/\\__/_____/\\__,_/_.___/ Thank you for installing GitLab! 配置GitLab站点UrlGitLab默认的配置文件路径是/etc/gitlab/gitlab.rb 默认的站点Url配置项是： 1external_url 'http://gitlab.example.com' 12345#修改配置文件sudo vi /etc/gitlab/gitlab.rb#配置首页地址external_url 'http://gitlab.caoxl.com' 防火墙开启端口 12[root@caoxl init.d]# firewall-cmd --add-port=9999/tcp --permanentsuccess 启动并访问Gitlab 启动Gitlab 1234567891011#重新配置并启动sudo gitlab-ctl reconfigure#完成后将会看到如下输出Running handlers:Running handlers completeChef Client finished, 3/709 resources updated in 15 secondsgitlab Reconfigured!#启动sudo gitlab-ctl restart 访问Gitlab 将设置的域名DNS解析到服务器IP，或者修改本地host将域名指向服务器IP。访问：http://gitlab.caoxl.com 这时候会提示为管理员账号设置密码。管理员账号默认username是root。设置完成之后即可使用root账号登录，登陆后会进入欢迎界面。 报ruby_block[authorize Grafana with GitLab] action run,解决办法 12# vim /etc/gitlab/gitlab.rbmonitoring['grafana']['enable'] = false 报 Whoops, GitLab is taking too much time to respond. (502)错误, 解决办法 原因是端口被其他服务占用了，需要更换配置文件里得到端口 ，并且执行gitlab-ctl reconfigure, gitlab-ctl restart 就可以解决 GitLab常用配置邮件配置配置邮箱可以让GitLab在发生相应事件的时候进行邮件通知比如：找回密码、添加邮箱等 12345678910111213141516171819#修改配置文件sudo vi /etc/gitlab/gitlab.rb#邮件配置gitlab_rails['smtp_enable'] = truegitlab_rails['smtp_address'] = 'smtp.163.com'gitlab_rails['smtp_port'] = 465gitlab_rails['smtp_user_name'] = 'yourmail@163.com'gitlab_rails['smtp_password'] = 'yourpasswd'gitlab_rails['smtp_domain'] = 'smtp.163.com'gitlab_rails['smtp_authentication'] = 'login'gitlab_rails['smtp_enable_starttls_auto'] = truegitlab_rails['smtp_tls'] = truegitlab_rails['gitlab_email_enabled'] = truegitlab_rails['gitlab_email_from'] = 'yourmail@163.com'gitlab_rails['gitlab_email_display_name'] = 'Gitlab'#保存后，重新配置并启动GitLabsudo gitlab-ctl reconfigure 禁用创建组权限GitLab默认所有的注册用户都可以创建组。但对于团队来说，通常只会给Leader相关权限。虽然可以在用户管理界面取消权限，但毕竟不方便。我们可以通过配置GitLab默认禁用创建组权限。 123456789#修改配置文件sudo vi /etc/gitlab/gitlab.rb#开启gitlab_rails['gitlab_default_can_create_group'] 选项，并将值设置为false### GitLab user privilegesgitlab_rails['gitlab_default_can_create_group'] = false#保存后，重新配置并启动GitLabsudo gitlab-ctl reconfigure gitlab-ctl常用命令介绍1sudo gitlab-ctl cmd 命令 说明 check-config 检查在gitlab中是否有任何配置。在指定版本中删除的rb deploy-page 安装部署页面 diff-config 将用户配置与包可用配置进行比较 remove-accounts 删除所有用户和组 upgrade 升级 once 如果GitLab服务停止了就启动服务，如果已启动就不做任何操作 restart 重启GitLab服务 start 如果GitLab服务停止了就启动服务，如果已启动就重启服务 stop 停止GitLab服务 status 查看GitLab服务状态 reconfigure reconfigure重新配置GitLab并启动 解决Gitlab的Nginx以及自带Nginx冲突问题 vim /etc/gitlab/gitlab.rb 做以下修改: 123456789101112// 禁用Gitlab的nginxnginx['enable'] = false// 设置自建Nginx的用户, 查看用户命令看说明web_server['external_users'] = ['www']// 修改监听方式和监听地址gitlab_workhorse['listen_network'] = \"tcp\"gitlab_workhorse['listen_addr'] = \"127.0.0.1:9999\"// 最后执行下面命令让配置生效：sudo gitlab-ctl reconfigure 说明 1cat /usr/local/nginx/conf/nginx.conf | grep user 配置Nginx, 新增gitlab.conf 官网提供配置 - gitlab-omnibus-nginx.conf 123456789101112131415161718192021222324252627282930313233343536373839upstream gitlab-workhorse &#123; server 127.0.0.1:9999; #根据实际情况修改, 与gitlab.rb中的gitlab_workhorse['listen_addr']一致&#125;## Normal HTTP hostserver &#123; listen 80; listen [::]:80 default_server; server_name gitlab.caoxl.com; ## 修改成自己的域名； server_tokens off; ## Don't show the nginx version number, a security best practice root /opt/gitlab/embedded/service/gitlab-rails/public; ## See app/controllers/application_controller.rb for headers set ## Individual nginx logs for this GitLab vhost access_log /var/log/nginx/gitlab_access.log; # 根据实际情况修改 error_log /var/log/nginx/gitlab_error.log; # 根据实际情况修改 location / &#123; client_max_body_size 0; gzip off; ## https://github.com/gitlabhq/gitlabhq/issues/694 ## Some requests take more than 30 seconds. proxy_read_timeout 300; proxy_connect_timeout 300; proxy_redirect off; proxy_http_version 1.1; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://gitlab-workhorse; &#125;&#125; 重启Nginx: sudo service nginx restart 解决Gitlab访问502问题1sudo chmod -R o+x /opt/gitlab/embedded/service//gitlab-rails/","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://blog.caoxl.com/tags/CentOS7/"},{"name":"Gitlab","slug":"Gitlab","permalink":"http://blog.caoxl.com/tags/Gitlab/"}]},{"title":"值得期待的PHP8新特性","slug":"Hello-PHP8","date":"2020-05-30T01:31:16.000Z","updated":"2020-05-30T03:14:05.000Z","comments":true,"path":"2020/05/30/Hello-PHP8/","link":"","permalink":"http://blog.caoxl.com/2020/05/30/Hello-PHP8/","excerpt":"罗列出 PHP8 中会发生的一些改变：新功能、性能改进和突破性变化。","text":"罗列出 PHP8 中会发生的一些改变：新功能、性能改进和突破性变化。 新特性联合类型(Union types)考虑到 PHP 的动态类型特性，联合类型在很多情况下都很有用。联合类型是两个或多个类型的集合，这些类型指示可以使用这两个类型中的任何一个。 1public function foo(Foo|Bar $input): int|float; 请注意，void 永远不能是联合类型的一部分，因为它表示 “根本没有返回值”。 此外，可以使用 |NULL 或使用现有的 ？。 123public function foo(Foo|null $foo): void;public function bar(?Bar $bar): void; JIT JIT-Just-In-Time 编译器承诺显著提高性能，尽管在 Web 应用可能没有较大的好处。 静态返回类型 (Static return types)虽然已经可以返回 self ，但在 PHP8 之前，静态不是有效的返回类型。考虑到 PHP 的动态类型特性，它对许多开发人员都很有用。 123456789&lt;?phpclass Foo&#123; public function test(): static &#123; return new static(); &#125;&#125; 弱映射基于在 PHP 7.4 中添加的 WeakRefs RFC 的基础上，在 PHP 8 中 添加了 WeakMap 实现。WeakMap 包含对对象的引用，这不会阻止这些对象被垃圾回收。 以 ORM 为例，它们经常实现包含对实体类的引用的缓存，以提高实体之间关系的性能。这些实体对象不能被垃圾回收，只要该缓存有对它们的引用，即使缓存是唯一引用它们的东西。 如果该缓存层改为使用弱引用和映射，则 PHP 将在其他对象不再引用这些对象时对它们进行垃圾回收。特别是在 ORM 的情况下，它可以在一个请求中管理数百个 (如果不是数千个) 实体；弱映射可以提供一种更好、更资源友好的方式来处理这些对象。 以下是 Weak maps 的用法，RFC 中的一个示例： 1234567891011&lt;?phpclass Foo&#123; private WeakMap $cache; public function getSomethingWithCaching(object $obj): object &#123; return $this-&gt;cache[$obj] ??= $this-&gt;computeSomethingExpensive($obj); &#125; &#125; 可以在对象上使用 ::class一个小而有用的新特性：现在可以对对象使用 ::class，而不必对它们使用 get_class()。它的工作方式与 get_class() 相同。 123$foo = new Foo();var_dump($foo::class); 创建 DateTime 对象的接口您已经可以使用 DateTime::createFromImmutable($immutableDateTime)，从 DateTimeImmutable 对象创建 DateTime 对象，但是反过来很棘手。 通过添加 DateTime::createFromInterface() 和 DatetimeImmutable::createFromInterface()，现在有了一种将 DateTime 和 DateTimeImmutable 对象相互转换的通用方法。 123DateTime::createFromInterface(DateTimeInterface $other);DateTimeImmutable::createFromInterface(DateTimeInterface $other); 新的 Stringable 接口Stringable 接口可用于键入提示任何字符串或实现__toString()。此外，每当类实现 __toString() 时，它都会自动在幕后实现接口，不需要手动实现它。 123456789101112class Foo&#123; public function __toString(): string &#123; return 'foo'; &#125;&#125;function bar(Stringable $stringable) &#123; /* … */ &#125;bar(new Foo());bar('abc'); 新的 str_contains() 函数 有些人可能会说这是早就应该实现的功能，但是我们最终不必再依赖 strpos() 来知道一个字符串是否包含另一个字符串。 以前: 1234567 if (strpos('string with lots of words', 'words') !== false) &#123; /* … */ &#125;``` - 现在:```php if (str_contains('string with lots of words', 'words')) &#123; /* … */ &#125; 新的 fdiv() 函数新的 fdiv() 函数的作用类似于 fmod() 和 intdiv() 函数，它们允许被 0 整除。您将得到 INF、-INF 或 NaN ，而不是错误，具体取决于大小写。 新的 get_debug_type() 函数get_debug_type() 返回一个变量的类型。听起来像是 gettype() 可以实现的功能。get_debug_type() 为数组、字符串、匿名类和对象返回更有用的输出。 例如，在类 \\foo\\Bar 上调用 gettype() 将返回 Object。使用 get_debug_type() 将返回类名。 改进 traits 里的抽象方法traits 可以指定必须由使用它们的类实现的抽象方法。但是有一个警告：在 PHP8 之前，这些方法实现的签名没有经过验证。在以下代码中有效： 12345678910111213trait Test &#123; abstract public function test(int $input): int;&#125;class UsesTrait&#123; use Test; public function test($input) &#123; return $input; &#125;&#125; 在使用 traits 并实现其抽象方法时，PHP8 将执行正确的方法签名验证。这意味着您需要改写以下内容： 123456789class UsesTrait&#123; use Test; public function test(int $input): int &#123; return $input; &#125;&#125; token_get_all() 的对象接口 RFC函数的作用是：返回值的是一个数组。此 RFC 使用 PhpToken::getall() 方法添加一个 PhpToken 类。此实现使用对象，而不是普通值。它消耗更少的内存，更容易阅读。 统一错误类型 RFCPHP 中的用户定义函数已经抛出 TypeErrors，但是内部函数没有抛出 TypeErrors，而是发出警告并返回 NULL。从 PHP8 开始，内部函数的行为已经保持一致。 默认错误报告级别现在是 E_ALL，而不是除 E_NOTICE 和 E_DEVERATED 之外的所有内容。这意味着可能会弹出许多以前被悄悄忽略的错误，尽管在 PHP8 之前可能已经存在 @运算符不再忽略致命错误此更改可能会揭示在 PHP8 之前隐藏的错误。请确保在生产服务器上设置 display_errors=off 串联优先级 RFC虽然在 PHP7.4 中已不推荐使用，但此更改现在生效。如果你这样写的话： 1echo \"sum: \" . $a + $b; PHP 以前会这样解释它： 1echo (\"sum: \" . $a) + $b; PHP 8 将会这样解释它： 1echo \"sum: \" . ($a + $b); 反射方法签名更改反射类的三个方法签名已更改： 123ReflectionClass::newInstance($args);ReflectionFunction::invoke($args);ReflectionMethod::invoke($object, $args); 现已成为： 123ReflectionClass::newInstance(...$args);ReflectionFunction::invoke(...$args);ReflectionMethod::invoke($object, ...$args); 升级指南指定，如果您扩展了这些类，并且仍然希望同时支持 PHP 7 和 PHP 8，则允许以下签名： 123ReflectionClass::newInstance($arg = null, ...$args);ReflectionFunction::invoke($arg = null, ...$args);ReflectionMethod::invoke($object, $arg = null, ...$args);","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP8","slug":"PHP8","permalink":"http://blog.caoxl.com/tags/PHP8/"}]},{"title":"PHP面试/笔试题杂记 VIII","slug":"Interview-Questions-Notes-VIII","date":"2020-05-21T03:35:49.000Z","updated":"2020-05-21T08:07:25.000Z","comments":true,"path":"2020/05/21/Interview-Questions-Notes-VIII/","link":"","permalink":"http://blog.caoxl.com/2020/05/21/Interview-Questions-Notes-VIII/","excerpt":"知识嘛就是常问常新.","text":"知识嘛就是常问常新. MySQLMySQL索引 (全文索引, 聚簇索引)FULLTEXT即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE INDEX创建FULLTEXT索引，要比先为一张表建立FULLTEXT然后再将数据写入的速度快很多。 HASH Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。 由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。 Hash 索引无法被用来避免数据的排序操作。 由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算； Hash 索引不能利用部分索引键查询。 对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。 Hash 索引在任何时候都不能避免表扫描。 前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。 Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。 BTREEBTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中 MySQL引擎 (MyISAM, InnoDB) MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快. InnoDB不支持FULLTEXT类型的索引. InnoDB中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可. 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。 DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。 LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用. MyISAM支持表锁，InnoDB支持行锁。 MySQL优化方式MySQL 优化常用方法 选取最适用的字段属性 使用连接（JOIN）来代替子查询(Sub-Queries) 使用联合(UNION)来代替手动创建的临时表 事务 锁定表 使用外键 使用索引 优化的查询语句 MySQL 性能优化方案 列出mysql服务器运行各种状态值 1show global status; 查询mysql服务器配置信息语句 1show variables; 慢查询12345678910111213141516mysql&gt; show variables like 'slow%';+---------------------+-------------------------------------------+| Variable_name | Value |+---------------------+-------------------------------------------+| slow_launch_time | 2 || slow_query_log | ON || slow_query_log_file | /home/mysql/data3056/mysql/slow_query.log |+---------------------+-------------------------------------------+mysql&gt; show global status like 'slow%';+---------------------+-------+| Variable_name | Value |+---------------------+-------+| Slow_launch_threads | 0 || Slow_queries | 52321 |+---------------------+-------+ 连接数123456mysql&gt; show variables like 'max_connections';+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 4532 |+-----------------+-------+ 查询一下服务器响应的最大连接数： 123456mysql&gt; show global status like 'max_used_connections';+----------------------+-------+| Variable_name | Value |+----------------------+-------+| Max_used_connections | 835 |+----------------------+-------+ 临时表12345678mysql&gt; show global status like 'created_tmp%';+-------------------------+-----------+| Variable_name | Value |+-------------------------+-----------+| Created_tmp_disk_tables | 44999364 || Created_tmp_files | 1763 || Created_tmp_tables | 120658849 |+-------------------------+-----------+ 查看一下mysql服务器对临时表的配置 1234567mysql&gt; show variables where variable_name in ('tmp_table_size', 'max_heap_table_size');+---------------------+----------+| Variable_name | Value |+---------------------+----------+| max_heap_table_size | 67108864 || tmp_table_size | 2097152 |+---------------------+----------+ open table 情况1234567mysql&gt; show global status like 'open%tables%';+---------------+-------+| Variable_name | Value |+---------------+-------+| Open_tables | 1998 || Opened_tables | 7704 |+---------------+-------+ open_tables 表示打开表的数量，opened_tables表示打开过的表数量，如果opened_tables数量过大，说明配置中 table_open_cache(5.1.3之前这个值叫做table_cache)值可能太小，我们查询一下服务器table_open_cache： 123456mysql&gt; show variables like 'table_open_cache';+------------------+-------+| Variable_name | Value |+------------------+-------+| table_open_cache | 2000 |+------------------+-------+ 进程使用情况123456789mysql&gt; show global status like 'thread%';+-------------------+-------+| Variable_name | Value |+-------------------+-------+| Threads_cached | 10 || Threads_connected | 736 || Threads_created | 85295 || Threads_running | 3 |+-------------------+-------+ threads_created表示创建过的线程数，如果发现threads_created值过大的话，表明 mysql服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值， 查询服务器 thread_cache_size配置： 123456mysql&gt; show variables like 'thread_cache_size';+-------------------+-------+| Variable_name | Value |+-------------------+-------+| thread_cache_size | 100 |+-------------------+-------+ 查询缓存(query cache)12345678910111213mysql&gt; show global status like 'qcache%';+-------------------------+-----------+| Variable_name | Value |+-------------------------+-----------+| Qcache_free_blocks | 1 || Qcache_free_memory | 3128864 || Qcache_hits | 0 || Qcache_inserts | 0 || Qcache_lowmem_prunes | 0 || Qcache_not_cached | 712727780 || Qcache_queries_in_cache | 0 || Qcache_total_blocks | 1 |+-------------------------+-----------+ Qcache_free_blocks: 缓存中相邻内存块的个数。数目大说明可能有碎片。flush query cache会对缓存中的碎片进行整理，从而得到一个空闲块。 Qcache_free_memory: 缓存中的空闲内存 Qcache_hits: 每次查询在缓存中命中时就增大 Qcache_inserts: 每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。 Qcache_lowmem_prunes: 缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存 很少。（上面的 free_blocks和free_memory可以告诉您属于哪种情况） Qcache_not_cached: 不适合进行缓存的查询的数量，通常是由于这些查询不是 select 语句或者用了now()之类的函数。 Qcache_queries_in_cache: 当前缓存的查询（和响应）的数量。 Qcache_total_blocks: 缓存中块的数量。 再查询一下服务器关于query_cache的配置： 12345678910mysql&gt; show variables like 'query_cache%';+------------------------------+---------+| Variable_name | Value |+------------------------------+---------+| query_cache_limit | 1048576 || query_cache_min_res_unit | 1024 || query_cache_size | 3145728 || query_cache_type | OFF || query_cache_wlock_invalidate | OFF |+------------------------------+---------+ query_cache_limit: query_cache_limit query_cache_min_res_unit: 缓存块的最小大小 query_cache_size: 查询缓存大小 query_cache_type: 缓存类型，决定缓存什么样的查询，示例中表示不缓存 select sql_no_cache 查询 query_cache_wlock_invalidate: 当有其他客户端正在对myisam表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。 排序使用情况123456789mysql&gt; show global status like 'sort%';+-------------------+----------+| Variable_name | Value |+-------------------+----------+| Sort_merge_passes | 3948 || Sort_range | 19442930 || Sort_rows | 87116099 || Sort_scan | 1748111 |+-------------------+----------+ 文件打开数(open_files)123456mysql&gt; show global status like 'open_files';+---------------+-------+| Variable_name | Value |+---------------+-------+| Open_files | 10 |+---------------+-------+ 123456mysql&gt; show variables like 'open_files_limit';+------------------+-------+| Variable_name | Value |+------------------+-------+| open_files_limit | 65535 |+------------------+-------+ 比较合适的设置：open_files / open_files_limit * 100% &lt;= 75% 表锁情况1234567mysql&gt; show global status like 'table_locks%';+-----------------------+----------+| Variable_name | Value |+-----------------------+----------+| Table_locks_immediate | 61629615 || Table_locks_waited | 77 |+-----------------------+----------+ Table_locks_immediate: 表示立即释放表锁数 Table_locks_waited: 表示需要等待的表锁数 如果 table_locks_immediate / table_locks_waited &gt; 5000，最好采用innodb引擎，因为innodb是行锁而myisam是表锁，对于高并发写入的应用innodb效果会好些 表扫描情况123456789101112mysql&gt; show global status like 'handler_read%';+-----------------------+--------------+| Variable_name | Value |+-----------------------+--------------+| Handler_read_first | 177188783 || Handler_read_key | 3542386589 || Handler_read_last | 52930 || Handler_read_next | 445982431928 || Handler_read_prev | 89234087 || Handler_read_rnd | 2283006748 || Handler_read_rnd_next | 175219902622 |+-----------------------+--------------+ 服务器完成的查询请求次数: 123456mysql&gt; show global status like 'com_select';+---------------+-----------+| Variable_name | Value |+---------------+-----------+| Com_select | 713039214 |+---------------+-----------+ 计算表扫描率: 表扫描率 ＝ handler_read_rnd_next / com_select MySQL 分库分表数据库主从从数据库(Slave)是主数据库的备份，当主数据库(Master)变化时从数据库要更新，这些数据库软件可以设计更新周期。这是提高信息安全的手段。主从数据库服务器不在一个地理位置上，当发生意外时数据库可以保存。 主从分工 其中Master负责写操作的负载，也就是说一切写的操作都在Master上进行，而读的操作则分摊到Slave上进行。 基本过程 Mysql的主从同步就是当master（主库）发生数据变化的时候，会实时同步到slave（从库）。 主从复制可以水平扩展数据库的负载能力，容错，高可用，数据备份。 不管是delete、update、insert，还是创建函数、存储过程，都是在master上，当master有操作的时候，slave会快速的接受到这些操作，从而做同步。 用途和条件 mysql主从复制用途 实时灾备，用于故障切换 读写分离，提供查询服务 备份，避免影响业务 主从部署必要条件： 主库开启binlog日志（设置log-bin参数） 主从server-id不同 从库服务器能连通主库 主从形式 一主一从 主主复制 一主多从—扩展系统读取的性能，因为读是在从库读取的; 多主一从—5.7开始支持 联级复制 主从同步的延迟等问题、原因及解决方案： mysql数据库从库同步的延迟问题 MySQL数据库主从同步延迟原理mysql主从同步原理：主库针对写操作，顺序写binlog，从库单线程去主库顺序读”写操作的binlog”，从库取到binlog在本地原样执行（随机写），来保证主从数据逻辑上一致。mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生binlog，binlog是顺序写，所以效率很高，slave的Slave_IO_Running线程到主库取日志，效率比较高，下一步，问题来了，slave的Slave_SQL_Running线程将主库的DDL和DML操作在slave实施。DML和DDL的IO操作是随即的，不是顺序的，成本高很多，还可能可slave上的其他查询产生lock争用，由于Slave_SQL_Running也是单线程的，所以一个DDL卡主了，需要执行10分钟，那么所有之后的DDL会等待这个DDL执行完才会继续执行，这就导致了延时。有朋友会问：“主库上那个相同的DDL也需要执行10分，为什么slave会延时？”，答案是master可以并发，Slave_SQL_Running线程却不可以。 MySql数据库从库同步的延迟解决方案 架构方面 业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。 单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。 服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。 不同业务的mysql物理上放在不同机器，分散压力。 使用比主库更好的硬件设备作为slave总结，mysql压力小，延迟自然会变小。 硬件方面 提高服务器性能 mysql主从同步加速 sync_binlog在slave端设置为0 –logs-slave-updates 从服务器从主服务器接收到的更新不记入它的二进制日志。 直接禁用slave端的binlog slave端，如果使用的存储引擎是innodb，innodb_flush_log_at_trx_commit =2 水平分表例：QQ的登录表。假设QQ的用户有100亿，如果只有一张表，每个用户登录的时候数据库都要从这100亿中查找，会很慢很慢。如果将这一张表分成100份，每张表有1亿条，就小了很多，比如qq0,qq1,qq1…qq99表。 用户登录的时候，可以将用户的id%100，那么会得到0-99的数，查询表的时候，将表名qq跟取模的数连接起来，就构建了表名。比如123456789用户，取模的89，那么就到qq89表查询，查询的时间将会大大缩短。 这就是水平分割。 垂直分表也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。 MySQL+如何做双机热备和负载均衡 MySQL 主从复制，双机热备 双机热备 所谓双机热备其实是一个复制的过程，复制过程中一个服务器充当主服务器，一个或多个服务器充当从服务。 这个复制的过程实质上是从服务器复制主服务器上MySQL的二进制日志（bin-log），并在从服务器上还原主服务器上的sql语句操作，这样只要两个数据库的初态是一样的，就能一直同步。 实现双机热备，原理其实就是做两个机器的互相主从，我们把上述步骤主从对调，然后做一遍就能实现了双机热备了 负载均衡 mysql读写分离 mysql复制时，产生了多个数据副本（备库），为减少服务器压力，从库用于处理读操作，主库可同时处理读写是mysql集群实现读写分离的常用策略。 由于备库的复制是异步的，无法实时同步，读写分离的主要难点也在于从库上的脏数据。通常如果使用备库进行读，一般对数据的实时性要求不能太高。对此，mysql提供了几种常见的读写分离方式，例如基于查询的读写分离、基于脏数据、基于会话等，有兴趣可继续研究。 mysql设置的读写分离，减少了主库的请求量，将大量读的操作发送给从库，实现负载均衡。 修改DNS 通过n个服务器IP指定到一个域名，根据请求的不同标识特征，将请求发送给不同的IP服务器进行处理。 引入中间件 mysql官方提供了一个mysql负载的中间件，mysql_proxy，也需要在服务器上进行安装，修改配置文件（mysql的服务器IP）,实质与nginx类似，也是一个代理服务器。 数据表类型有哪些 MyISAM、InnoDB、HEAP、BOB,ARCHIVE,CSV等 MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。 InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。 MySQL 把一个大表拆分多个表后,如何解决跨表查询效率问题MySQL 对于大表(千万级),要怎么优化呢? 优化SQL和索引 加缓存, Memcached, redis等 主从复制,读写分离 分库分表 分布式系统 优化 规范设计 配置规范 建表规范 命名规范 索引规范 应用规范 业务层优化 业务拆分 数据拆分 读多写少优化场景 采用缓存 读少写多优化场景 采用异步提交模式 使用队列技术 降低写入频率 架构层优化 管理优化 数据清理如何做 数据变更如何做 尽可能避免数据碎片 MySQL 的慢查询问题 其实通过慢查询日志来分析是一种比较简单的方式，如果不想看日志，可以借助工具来完成， 如mysqldumpslow, mysqlsla, myprofi, mysql-explain-slow-log, mysqllogfilter等，感觉自己来分析一个需要丰富的经验，一个浪费时间。 SQL语言分4大类请列举 ? DDL–CREATE,DROP,ALTER DDL 数据库定义语言 (Data Definition Language) DML–INSERT,UPDATE,DELETE 数据库操纵语言 (Data Manipulation Language) DQL–SELECT 数据库查询语言 (Data Query Language) DCL–GRANT,REVOKE,COMMIT,ROLLBACK 数据库控制语言 (Data Control Language) (mysql)请写出数据类型(int char varchar datetime text)的意思; int : 数值类型 char : 固定长度字符串类型 varchar : 可变长度字符串类型 datetime : 时期时间类型 text : 文本类型 varchar和char有什么区别: char 长度是固定的，不管你存储的数据是多少他都会是固定的长度。而varchar则是可变长度但他要在总长度上加1字符，这个用来存储位置。 char 固定长度，所以在处理速度上要比varchar快速很多，但是浪费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例。","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://blog.caoxl.com/tags/面试题/"},{"name":"笔试题","slug":"笔试题","permalink":"http://blog.caoxl.com/tags/笔试题/"}]},{"title":"Linux awk使用","slug":"Linux-cmd-awk","date":"2020-05-19T02:29:47.000Z","updated":"2020-05-19T03:11:01.000Z","comments":true,"path":"2020/05/19/Linux-cmd-awk/","link":"","permalink":"http://blog.caoxl.com/2020/05/19/Linux-cmd-awk/","excerpt":"awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。","text":"awk是一种编程语言，用于在linux/unix下对文本和数据进行处理。 awk命令格式和选项语法形式 awk [options] ‘script’ var=value file(s)awk [options] -f script_file var=value file(s) 常用命令选项 -F fs: fs指定输入分隔符, fs可以是字符串或正则表达式，如-F: -v var=value 赋值一个用户定义变量，将外部变量传递给awk -f script_file 从脚本文件中读取awk命令 基本用法 log.txt文本内容如下： 12342 this is a test3 Are you like awkThis's a test10 There are orange,apple,mongo 用法一:1awk '&#123;[pattern] action&#125;' &#123;filenames&#125; # 行匹配语句 awk ''只能用单引号 实例12345678910111213# 每行按空格或TAB分割，输出文本中的1、4项[root@caoxl ~]# awk '&#123;print $1,$4&#125;' log.txt2 a3 likeThis's 10 orange,apple,mongo# 格式化输出[root@caoxl ~]# awk '&#123;printf \"%-8s %-10s\\n\",$1,$4&#125;' log.txt2 a 3 like This's 10 orange,apple,mongo 用法二:1awk -F #-F相当于内置变了FS, 指定分割字符 实例12345678910111213141516171819# 使用\",\"分割[root@caoxl ~]# awk -F, '&#123;print $1,$2&#125;' log.txt2 this is a test 3 Are you like awk This's a test 10 There are orange apple# 或者使用内建变量[root@caoxl ~]# awk 'BEGIN&#123;FS=\",\"&#125;&#123;print $1,$2&#125;' log.txt2 this is a test 3 Are you like awk This's a test 10 There are orange apple# 使用多个分隔符.先使用空格分割，然后对分割结果再使用\",\"分割2 this3 AreThis's a10 There 用法三:1awk -v # 设置变量 实例1234567891011[root@caoxl ~]# awk -va=1 '&#123;print $1,$1+a&#125;' log.txt2 33 4This's 110 11[root@caoxl ~]# awk -va=1 -vb=s '&#123;print $1,$1+a,$1b&#125;' log.txt2 3 2s3 4 3sThis's 1 This'ss10 11 10s 用法四:1awk -f &#123;awk脚本&#125; &#123;文件名&#125; 实例 cal.awk 1234567891011121314151617181920212223#!/bin/awk -f#运行前BEGIN &#123; math = 0 english = 0 computer = 0 printf \"NAME NO. MATH ENGLISH COMPUTER TOTAL\\n\" printf \"---------------------------------------------\\n\"&#125;#运行中&#123; math+=$3 english+=$4 computer+=$5 printf \"%-6s %-6s %4d %8d %8d %8d\\n\", $1, $2, $3, $4, $5, $3+$4+$5&#125;#运行后END &#123; printf \"---------------------------------------------\\n\" printf \" TOTAL:%10d %8d %8d \\n\", math, english, computer printf \"AVERAGE:%10.2f %8.2f %8.2f\\n\", math/NR, english/NR, computer/NR&#125; score.txt 12345Marry 2143 78 84 77Jack 2321 66 78 45Tom 2122 48 77 71Mike 2537 87 97 95Bob 2415 40 57 62 运行 1234567891011[root@caoxl ~]# awk -f cal.awk score.txtNAME NO. MATH ENGLISH COMPUTER TOTAL---------------------------------------------Marry 2143 78 84 77 239Jack 2321 66 78 45 189Tom 2122 48 77 71 196Mike 2537 87 97 95 279Bob 2415 40 57 62 159--------------------------------------------- TOTAL: 319 393 350 AVERAGE: 63.80 78.60 70.00 其他用法: 从文件中找出长度大于30的行 12[root@caoxl ~]# awk 'length&gt;30' log.txt 10 There are orange,apple,mongo 打印九九乘法表 12345678910[root@caoxl ~]# seq 9 | sed 'H;g' | awk -v RS='' '&#123;for(i=1;i&lt;=NF;i++)printf(\"%dx%d=%d%s\", i, NR, i*NR, i==NR?\"\\n\":\"\\t\")&#125;'1x1=11x2=2 2x2=41x3=3 2x3=6 3x3=91x4=4 2x4=8 3x4=12 4x4=161x5=5 2x5=10 3x5=15 4x5=20 5x5=251x6=6 2x6=12 3x6=18 4x6=24 5x6=30 6x6=361x7=7 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=491x8=8 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=641x9=9 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"awk","slug":"awk","permalink":"http://blog.caoxl.com/tags/awk/"}]},{"title":"MySQL 基础知识 II","slug":"MySQL-Basic-Knowledge-II","date":"2020-04-23T07:58:29.000Z","updated":"2020-04-23T09:13:26.000Z","comments":true,"path":"2020/04/23/MySQL-Basic-Knowledge-II/","link":"","permalink":"http://blog.caoxl.com/2020/04/23/MySQL-Basic-Knowledge-II/","excerpt":"闲来无事, 复习复习MySQL原文地址: [记录] MySQL 学习笔记","text":"闲来无事, 复习复习MySQL原文地址: [记录] MySQL 学习笔记 连接与断开服务器123mysql -h 地址 -P 端口 -u 用户名 -p 密码SHOW PROCESSLIST; -- 显示哪些线程正在运行SHOW VARIABLES; -- 显示系统变量信息 数据库操作123456789101112131415161718-- 查看当前数据库 SELECT DATABASE();-- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version();-- 创建库 CREATE DATABASE [IF NOT EXISTS] 数据库名 数据库选项 数据库选项： CHARACTER SET charset_name COLLATE collation_name。-- 查看已有库 SHOW DATABASES [LIKE &apos;PATTERN&apos;]-- 查看当前库信息 SHOW CREATE DATABASE 数据库名-- 修改库的选项信息 ALTER DATABASE 库名 选项信息-- 删除库 DROP DATABASE[ IF EXISTS] 数据库名 同时删除该数据库相关的目录及其目录内容 表的操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788-- 创建表 CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [库名.]表名 (表的结构定义)[表选项] 每个字段必须有数据类型 最后一个字段后不能有逗号 TEMPORARY 临时表，会话结束时表自动消失 对于字段的定义： 字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &apos;string&apos;]-- 表选项 -- 字符集 CHARSET = charset_name 如果表没有设定，则使用数据库字符集 -- 存储引擎 ENGINE = engine_name 表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同 常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive 不同的引擎在保存表的结构和数据时采用不同的方式 MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引 InnoDB表文件含义：.frm表定义，表空间数据和日志文件 SHOW ENGINES -- 显示存储引擎的状态信息 SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息 -- 自增起始数 AUTO_INCREMENT = 行数 -- 数据文件目录 DATA DIRECTORY = &apos;目录&apos; -- 索引文件目录 INDEX DIRECTORY = &apos;目录&apos; -- 表注释 COMMENT = &apos;string&apos; -- 分区选项 PARTITION BY ... (详细见手册)-- 查看所有表 SHOW TABLES[ LIKE &apos;pattern&apos;] SHOW TABLES FROM 表名-- 查看表结构 SHOW CREATE TABLE 表名 （信息更详细） DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &apos;PATTERN&apos;] SHOW TABLE STATUS [FROM db_name] [LIKE &apos;pattern&apos;]-- 修改表 -- 修改表本身的选项 ALTER TABLE 表名 表的选项 eg: ALTER TABLE 表名 ENGINE=MYISAM; -- 对表进行重命名 RENAME TABLE 原表名 TO 新表名 RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库） -- RENAME可以交换两个表名 -- 修改表的字段机构（13.1.2. ALTER TABLE语法） ALTER TABLE 表名 操作名 -- 操作名 ADD[COLUMN] 字段定义 -- 增加字段 AFTER 字段名 -- 表示增加在该字段名后面 FIRST -- 表示增加在第一个 ADD PRIMARY KEY(字段名) -- 创建主键 ADD UNIQUE [索引名] (字段名) -- 创建唯一索引 ADD INDEX [索引名] (字段名) -- 创建普通索引 DROP[ COLUMN] 字段名 -- 删除字段 MODIFY[ COLUMN] 字段名 字段属性 -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上) CHANGE[ COLUMN] 原字段名 新字段名 字段属性 -- 支持对字段名修改 DROP PRIMARY KEY -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性) DROP INDEX 索引名 -- 删除索引 DROP FOREIGN KEY 外键 -- 删除外键-- 删除表 DROP TABLE[ IF EXISTS] 表名 ...-- 清空表数据 TRUNCATE [TABLE] 表名-- 复制表结构 CREATE TABLE 表名 LIKE 要复制的表名-- 复制表结构和数据 CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名-- 检查表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ...-- 优化表 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...-- 修复表 REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]-- 分析表 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 数据操作12345678910111213141516171819-- 增 INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。 -- 可同时插入多条数据记录！ REPLACE 与 INSERT 完全一样，可互换。 INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]-- 查 SELECT 字段列表 FROM 表名[其他子句] -- 可来自多个表的多个字段 -- 其他子句可以不使用 -- 字段列表可以用*代替，表示所有字段-- 删 DELETE FROM 表名[ 删除条件子句] 没有条件子句，则会删除全部-- 改 UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件] 字符集编码12345678910111213141516171819-- MySQL、数据库、表、字段均可设置编码-- 数据编码与客户端编码不需一致SHOW VARIABLES LIKE &apos;character_set_%&apos;; -- 查看所有字符集编码项 character_set_client 客户端向服务器发送数据时使用的编码 character_set_results 服务器端将结果返回给客户端所使用的编码 character_set_connection 连接层编码SET 变量名 = 变量值 SET character_set_client = gbk; SET character_set_results = gbk; SET character_set_connection = gbk;SET NAMES GBK; -- 相当于完成以上三个设置-- 校对集 校对集用以排序 SHOW CHARACTER SET [LIKE &apos;pattern&apos;]/SHOW CHARSET [LIKE &apos;pattern&apos;] 查看所有字符集 SHOW COLLATION [LIKE &apos;pattern&apos;] 查看所有校对集 CHARSET 字符集编码 设置字符集编码 COLLATE 校对集编码 设置校对集编码 数据类型 (列类型) 数值类型 123456789101112131415161718192021222324252627282930313233-- a. 整型 ---------- 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 bigint 8字节 int(M) M表示总位数 - 默认存在符号位，unsigned 属性修改 - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改 例：int(5) 插入一个数&apos;123&apos;，补填后为&apos;00123&apos; - 在满足要求的情况下，越小越好。 - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。-- b. 浮点型 ---------- 类型 字节 范围 float(单精度) 4字节 double(双精度) 8字节 浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。 不同于整型，前后均会补填0. 定义浮点型时，需指定总位数和小数位数。 float(M, D) double(M, D) M表示总位数，D表示小数位数。 M和D的大小会决定浮点数的范围。不同于整型的固定范围。 M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。 支持科学计数法表示。 浮点数表示近似值。-- c. 定点数 ---------- decimal -- 可变长度 decimal(M, D) M也表示总位数，D表示小数位数。 保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。 将浮点数转换为字符串来保存，每9位数字保存为4个字节。 字符串类型 12345678910111213141516171819202122232425-- a. char, varchar ---------- char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 M表示能存储的最大长度，此长度是字符数，非字节数。 不同的编码，所占用的空间不同。 char,最多255个字符，与编码无关。 varchar,最多65535字符，与编码有关。 一条有效记录最大不能超过65535个字节。 utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符 varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。 varchar 的最大有效长度由最大行大小和使用的字符集确定。 最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。 例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3-- b. blob, text ---------- blob 二进制字符串（字节字符串） tinyblob, blob, mediumblob, longblob text 非二进制字符串（字符字符串） tinytext, text, mediumtext, longtext text 在定义时，不需要定义长度，也不会计算总长度。 text 类型在定义时，不可给default值-- c. binary, varbinary ---------- 类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。 char, varchar, text 对应 binary, varbinary, blob. 日期时间类型 12345678910111213141516171819202122232425263. 日期时间类型 一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155datetime YYYY-MM-DD hh:mm:sstimestamp YY-MM-DD hh:mm:ss YYYYMMDDhhmmss YYMMDDhhmmss YYYYMMDDhhmmss YYMMDDhhmmssdate YYYY-MM-DD YY-MM-DD YYYYMMDD YYMMDD YYYYMMDD YYMMDDtime hh:mm:ss hhmmss hhmmssyear YYYY YY YYYY YY 枚举和集合 1234567891011121314-- 枚举(enum) ----------enum(val1, val2, val3...) 在已知的值中进行单选。最大数量为65535. 枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。 表现为字符串类型，存储却是整型。 NULL值的索引是NULL。 空字符串错误值的索引值是0。-- 集合(set) ----------set(val1, val2, val3...) create table tab ( gender set(&apos;男&apos;, &apos;女&apos;, &apos;无&apos;) ); insert into tab values (&apos;男, 女&apos;); 最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。 当创建表时，SET成员值的尾部空格将自动被删除。 列属性 (列约束)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253541. PRIMARY 主键 - 能唯一标识记录的字段，可以作为主键。 - 一个表只能有一个主键。 - 主键具有唯一性。 - 声明字段时，用 primary key 标识。 也可以在字段列表之后声明 例：create table tab ( id int, stu varchar(10), primary key (id)); - 主键字段的值不能为null。 - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。 例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));2. UNIQUE 唯一索引（唯一约束） 使得某字段的值也不能重复。3. NULL 约束 null不是数据类型，是列的一个属性。 表示当前列是否可以为null，表示什么都没有。 null, 允许为空。默认。 not null, 不允许为空。 insert into tab values (null, &apos;val&apos;); -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null4. DEFAULT 默认值属性 当前字段的默认值。 insert into tab values (default, &apos;val&apos;); -- 此时表示强制使用默认值。 create table tab ( add_time timestamp default current_timestamp ); -- 表示将当前时间的时间戳设为默认值。 current_date, current_time5. AUTO_INCREMENT 自动增长约束 自动增长必须为索引（主键或unique） 只能存在一个字段为自动增长。 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;6. COMMENT 注释 例：create table tab ( id int ) comment &apos;注释内容&apos;;7. FOREIGN KEY 外键约束 用于限制主表与从表数据完整性。 alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id); -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。 MySQL中，可以对InnoDB引擎使用外键约束： 语法： foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作] 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择： 1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。 2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。 3. restrict，拒绝父表删除和更新。 注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。 建表规范1234567891011121314-- Normal Format, NF - 每个表保存一个实体信息 - 每个具有一个ID字段作为主键 - ID主键 + 原子表-- 1NF, 第一范式 字段不能再分，就满足第一范式。-- 2NF, 第二范式 满足第一范式的前提下，不能出现部分依赖。 消除符合主键就可以避免部分依赖。增加单列关键字。-- 3NF, 第三范式 满足第二范式的前提下，不能出现传递依赖。 某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。 将一个实体信息的数据放在一个表内实现。 SELECT12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMITa. select_expr -- 可以用 * 表示所有字段。 select * from tb; -- 可以使用表达式（计算公式、函数调用、字段也是个表达式） select stu, 29+25, now() from tb; -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。 - 使用 as 关键字，也可省略 as. select stu+10 as add10 from tb;b. FROM 子句 用于标识查询来源。 -- 可以为表起别名。使用as关键字。 SELECT * FROM tb1 AS tt, tb2 AS bb; -- from子句后，可以同时出现多个表。 -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。 SELECT * FROM tb1, tb2; -- 向优化符提示如何选择索引 USE INDEX、IGNORE INDEX、FORCE INDEX SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3; SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;c. WHERE 子句 -- 从from获得的数据源中进行筛选。 -- 整型1表示真，0表示假。 -- 表达式由运算符和运算数组成。 -- 运算数：变量（字段）、值、函数返回值 -- 运算符： =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor is/is not 加上ture/false/unknown，检验某个值的真假 &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较d. GROUP BY 子句, 分组子句 GROUP BY 字段/别名 [排序方式] 分组后会进行排序。升序：ASC，降序：DESC 以下[合计函数]需配合 GROUP BY 使用： count 返回不同的非NULL值数目 count(*)、count(字段) sum 求和 max 求最大值 min 求最小值 avg 求平均值 group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。e. HAVING 子句，条件子句 与 where 功能、用法相同，执行时机不同。 where 在开始时执行检测数据，对原数据进行过滤。 having 对筛选出的结果再次进行过滤。 having 字段必须是查询出来的，where 字段必须是数据表存在的。 where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。 where 不可以使用合计函数。一般需用合计函数才会用 having SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。f. ORDER BY 子句，排序子句 order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]... 升序：ASC，降序：DESC 支持多个字段的排序。g. LIMIT 子句，限制结果数量子句 仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。 limit 起始位置, 获取条数 省略第一个参数，表示从索引0开始。limit 获取条数h. DISTINCT, ALL 选项 distinct 去除重复记录 默认为 all, 全部记录 UNION1234567将多个select查询的结果组合成一个结果集合。SELECT ... UNION [ALL|DISTINCT] SELECT ...默认 DISTINCT 方式，即所有返回的行都是唯一的建议，对每个SELECT查询加上小括号包裹。ORDER BY 排序时，需加上 LIMIT 进行结合。需要各select查询的字段数量一样。每个select查询的字段列表（数量、类型）应一致，因为结果中的字段名以第一条select语句为准。 子查询1234567891011121314151617181920212223242526272829- 子查询需用括号包裹。-- from型 from后要求是一个表，必须给子查询结果取个别名。 - 简化每个查询内的条件。 - from型需将结果生成一个临时表格，可用以原表的锁定的释放。 - 子查询返回一个表，表型子查询。 select * from (select * from tb where id &gt; 0) as subfrom where id&gt;1;-- where型 - 子查询返回一个值，标量子查询。 - 不需要给子查询取别名。 - where子查询内的表，不能直接用以更新。 select * from tb where money = (select max(money) from tb); -- 列子查询 如果子查询结果返回的是一列。 使用 in 或 not in 完成查询 exists 和 not exists 条件 如果子查询返回数据，则返回1或0。常用于判断条件。 select column1 from t1 where exists (select * from t2); -- 行子查询 查询条件是一个行。 select * from t1 where (id, gender) in (select id, gender from t2); 行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...) 行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。 -- 特殊运算符 != all() 相当于 not in = some() 相当于 in。any 是 some 的别名 != some() 不等同于 not in，不等于其中某一个。 all, some 可以配合其他运算符一起使用。 连接查询 (JOIN)123456789101112131415161718192021222324将多个表的字段进行连接，可以指定连接条件。-- 内连接(inner join) - 默认就是内连接，可省略inner。 - 只有数据存在时才能发送连接。即连接结果不能出现空行。 on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真） 也可用where表示连接条件。 还有 using, 但需字段名相同。 using(字段名) -- 交叉连接 cross join 即，没有条件的内连接。 select * from tb1 cross join tb2;-- 外连接(outer join) - 如果数据不存在，也会出现在连接结果中。 -- 左外连接 left join 如果数据不存在，左表记录会出现，而右表为null填充 -- 右外连接 right join 如果数据不存在，右表记录会出现，而左表为null填充-- 自然连接(natural join) 自动判断连接条件完成连接。 相当于省略了using，会自动查找相同字段名。 natural join natural left join natural right join INSERT12345678910111213141516171819select语句获得的数据可以用insert插入。可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。 或者使用set语法。 INSERT INTO tbl_name SET field=value,...；可以一次性使用多个值，采用(), (), ();的形式。 INSERT INTO tbl_name VALUES (), (), ();可以在列值指定时，使用表达式。 INSERT INTO tbl_name VALUES (field_value, 10+10, now());可以使用一个特殊值 DEFAULT，表示该列使用默认值。 INSERT INTO tbl_name VALUES (field_value, DEFAULT);可以通过一个查询的结果，作为需要插入的值。 INSERT INTO tbl_name SELECT ...;可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。 INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, ...; DELETE123456DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]按照条件删除。where指定删除的最多记录数。limit可以通过排序条件删除。order by + limit支持多表删除，使用类似连接语法。delete from 需要删除数据多表1，表2 using 表连接操作 条件。 TRUNCATE12345678TRUNCATE [TABLE] tbl_name清空数据删除重建表区别：1. truncate 是删除表再创建，delete 是逐条删除2. truncate 重置auto_increment的值。而delete不会3. truncate 不知道删除了几条，而delete知道。4. 当被用于带分区的表时，truncate 会保留分区 备份与还原 备份，将数据的结构与表内数据保存起来。 利用 mysqldump 指令完成。 12345678910111213141516171819-- 导出mysqldump [options] db_name [tables]mysqldump [options] ---database DB1 [DB2 DB3...]mysqldump [options] --all--database1. 导出一张表 mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)可以-w携带WHERE条件-- 导入1. 在登录mysql的情况下： source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 视图 什么是视图： 视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。 视图具有表结构文件，但不存在数据文件。 对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。 视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用 1234567891011121314151617181920212223242526272829-- 创建视图CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement - 视图名必须唯一，同时不能与表重名。 - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。 - 可以指定视图执行的算法，通过ALGORITHM指定。 - column_list如果存在，则数目必须等于SELECT语句检索的列数-- 查看结构 SHOW CREATE VIEW view_name-- 删除视图 - 删除视图后，数据依然存在。 - 可同时删除多个视图。 DROP VIEW [IF EXISTS] view_name ...-- 修改视图结构 - 一般不修改视图，因为不是所有的更新视图都会映射到表上。 ALTER VIEW view_name [(column_list)] AS select_statement-- 视图作用 1. 简化业务逻辑 2. 对客户端隐藏真实的表结构-- 视图算法(ALGORITHM) MERGE 合并 将视图的查询语句，与外部查询需要先合并再执行！ TEMPTABLE 临时表 将视图执行完毕后，形成临时表，再做外层查询！ UNDEFINED 未定义(默认)，指的是MySQL自主去选择相应的算法。 事务 (transaction) 事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 - 支持连续SQL的集体成功或集体撤销。 - 事务是数据库在数据晚自习方面的一个功能。 - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。 - InnoDB被称为事务安全型引擎。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 事务开启 START TRANSACTION; 或者 BEGIN; 开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。-- 事务提交 COMMIT;-- 事务回滚 ROLLBACK; 如果部分操作发生问题，映射到事务开启前。-- 事务的特性 1. 原子性（Atomicity） 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 2. 一致性（Consistency） 事务前后数据的完整性必须保持一致。 - 事务开始和结束时，外部数据一致 - 在整个事务过程中，操作是连续的 3. 隔离性（Isolation） 多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。 4. 持久性（Durability） 一个事务一旦被提交，它对数据库中的数据改变就是永久性的。-- 事务的实现 1. 要求是事务支持的表类型 2. 执行一组相关的操作前开启事务 3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。-- 事务的原理 利用InnoDB的自动提交(autocommit)特性完成。 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。-- 注意 1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。 2. 事务不能被嵌套-- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点-- InnoDB自动提交特性设置 SET autocommit = 0|1; 0表示关闭自动提交，1表示开启自动提交。 - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。 - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是， SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接) 而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务) 锁表123456表锁定只用于防止其它客户端进行不正当地读取和写入MyISAM 支持表锁，InnoDB 支持行锁-- 锁定 LOCK TABLES tbl_name [AS alias]-- 解锁 UNLOCK TABLES SQL编程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849--// 局部变量 ------------ 变量声明 declare var_name[,...] type [default value] 这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。-- 赋值 使用 set 和 select into 语句为变量赋值。 - 注意：在函数内是可以使用全局变量（用户自定义的变量）--// 全局变量 ------------ 定义、赋值set 语句可以定义并为变量赋值。set @var = value;也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。select @var:=20;select @v1:=id, @v2=name from t1 limit 1;select * from tbl_name where @var:=30;select into 可以将表中查询获得的数据赋给变量。 -| select max(height) into @max_height from tb;-- 自定义变量名为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。@var=10; - 变量被定义后，在整个会话周期都有效（登录到退出）--// 控制结构 ------------ if语句if search_condition then statement_list [elseif search_condition then statement_list]...[else statement_list]end if;-- case语句CASE value WHEN [compare-value] THEN result[WHEN [compare-value] THEN result ...][ELSE result]END-- while循环[begin_label:] while search_condition do statement_listend while [end_label];- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。 -- 退出循环 退出整个循环 leave 退出当前循环 iterate 通过退出的标签决定退出哪个循环 内置函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657-- 数值函数abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数-- 时间日期函数now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取日期部分time(&apos;yyyy-mm-dd hh:ii:ss&apos;); -- 获取时间部分date_format(&apos;yyyy-mm-dd hh:ii:ss&apos;, &apos;%d %y %a %d %m %b %j&apos;); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间-- 字符串函数length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小-- 流程函数case when [condition] then result [when [condition] then result ...] [else result] end 多分支if(expr1,expr2,expr3) 双分支。-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default(); 存储函数，自定义函数 12345678910111213141516171819-- 新建 CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型 函数体 - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。 - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。 - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。 - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。 - 多条语句应该使用 begin...end 语句块包含。 - 一定要有 return 返回值语句。-- 删除 DROP FUNCTION [IF EXISTS] function_name;-- 查看 SHOW FUNCTION STATUS LIKE &apos;PATTEN&apos; SHOW CREATE FUNCTION function_name;-- 修改 ALTER FUNCTION function_name 函数选项 存储过程，自定义功能 123456789101112131415161718192021222324252627282930-- 定义存储存储过程 是一段代码（过程），存储在数据库中的sql组成。一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。-- 创建CREATE PROCEDURE sp_name (参数列表) 过程体参数列表：不同于函数的参数列表，需要指明参数类型IN，表示输入型OUT，表示输出型INOUT，表示混合型注意，没有返回值。-- 存储过程存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。调用：CALL 过程名-- 注意- 没有返回值。- 只能单独调用，不可夹杂在其他语句中-- 参数IN|OUT|INOUT 参数名 数据类型IN 输入：在调用过程中，将数据输入到过程体内部的参数OUT 输出：在调用过程中，将过程体处理完的结果返回到客户端INOUT 输入输出：既可输入，也可输出-- 语法CREATE PROCEDURE 过程名 (参数列表)BEGIN 过程体END 用户和权限管理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586-- root密码重置1. 停止MySQL服务2. [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp; [Windows] mysqld --skip-grant-tables3. use mysql;4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;5. FLUSH PRIVILEGES;用户信息表：mysql.user-- 刷新权限FLUSH PRIVILEGES;-- 增加用户CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &apos;user_name&apos;@&apos;192.168.1.1&apos; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD-- 重命名用户RENAME USER old_user TO new_user-- 设置密码SET PASSWORD = PASSWORD(&apos;密码&apos;) -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD(&apos;密码&apos;) -- 为指定用户设置密码-- 删除用户DROP USER 用户名-- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &apos;password&apos;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 GRANT ALL PRIVILEGES ON `pms`.* TO &apos;pms&apos;@&apos;%&apos; IDENTIFIED BY &apos;pms0817&apos;;-- 查看权限SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限-- 权限层级-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv 当使用REVOKE时，您必须指定与被授权列相同的列。-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER; -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限 表维护123456789-- 分析和存储表的关键字分布ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...-- 检查一个或多个表是否有错误CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;-- 整理数据文件的碎片OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 杂项123456789101112131415161718191. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！2. 每个库目录存在一个保存当前数据库的选项文件db.opt。3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\&apos;5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\\G&quot;, &quot;\\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。6. SQL对大小写不敏感7. 清除已有语句：\\c","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"}]},{"title":"Swoole 再深入","slug":"Swoole-Learn-More","date":"2020-04-09T03:55:42.000Z","updated":"2020-04-10T06:41:13.000Z","comments":true,"path":"2020/04/09/Swoole-Learn-More/","link":"","permalink":"http://blog.caoxl.com/2020/04/09/Swoole-Learn-More/","excerpt":"问即是学","text":"问即是学 基础编程知识阻塞 和 非阻塞 的区别? 同步(Synchronous)IO 当一个程序发起调用的时候，在程序没有处理完成返回结果时，调用方会一直等待，等待结果的返回。 异步(Asynchronous)IO 当一个程序发起调用的时候，程序立即返回调用成功的消息，但不会马上返回结果，而是需要通过回调的方式把返回结果返回给调用方。 阻塞(Blocking)IO 阻塞就是在程序调用之后，结果返回之前，当前的进程/线程是被挂起的 非阻塞(non-Blocking)IO 非阻塞是指程序调用之后，结果返回之前，不会挂起该进程/线程的。 异步的优势 ? 高并发，同步阻塞IO模型的并发能力依赖于进程/线程数量 无IO等待，同步模型无法解决IOWait很高的场景 同步的优势 ? 编码简单，同步模式编写/调试程序更轻松 可控性好，同步模式的程序具有良好的过载保护机制 PHP的GC机制 ? GC机制: 垃圾回收机制 PHP5.3: 当变量容器的ref_count计数清0时，表示该变量容器就会被销毁，实现了内存回收PHP5.3版本之后引入根缓冲机制，即php启动时默认设置指定zval数量的根缓冲区（默认是10000），当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量（默认是10000）后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题 PHP面向对象编程: 对象引用机制和对象与内存之间的关系 ? 对象释放的时候调用了__destruct(),释放内存; 多进程编程fpm 和 swoole 的多进程模型及其区别 ? PHP-FPM php-fpm 就是通过 FastCGI 协议来处理 PHP 与第三方 WEB 服务器之间的通信比如 Nginx + php-fpm 的组合，这种方式运行的 fpm 是 Master/Worker 模式，启动一个 Master 进程监听来自 Nginx 的请求，再 fork 多个 Worker 进程处理请求。每个 Worker 进程只能处理一个请求，单一进程的生命周期大体如下： 初始化模块。 初始化请求。此处请求是请求 PHP 执行代码的意思，并非 HTTP 的请求。 执行 PHP 脚本。 结束请求。 关闭模块。 Swoole Swoole 采用的也是 Master/Worker 模式，不同的是 Master 进程有多个 Reactor 线程，Master 只是一个事件发生器，负责监听 Socket 句柄的事件变化。Worker 以多进程的方式运行，接收来自 Reactor 线程的请求，并执行回调函数（PHP 编写的）。启动 Master 进程的流程大致是： 初始化模块。 初始化请求。因为 swoole 需要通过 cli 的方式运行，所以初始化请求时，不会初始化 PHP 的全局变量，如 $_SERVER, $_POST, $_GET 等。 执行 PHP 脚本。包括词法、语法分析，变量、函数、类的初始化等，Master 进入监听状态，并不会结束进程。 对比不同: PHP-FPM Master 主进程 / Worker 多进程模式。 启动 Master，通过 FastCGI 协议监听来自 Nginx 传输的请求。 每个 Worker 进程只对应一个连接，用于执行完整的 PHP 代码。 PHP 代码执行完毕，占用的内存会全部销毁，下一次请求需要重新再进行初始化等各种繁琐的操作。 只用于 HTTP Server。 Swoole Master 主进程（由多个 Reactor 线程组成）/ Worker 多进程（或多线程）模式 启动 Master，初始化 PHP 代码，由 Reactor 监听 Socket 句柄的事件变化。 Reactor 主线程负责子多线程的均衡问题，Manager 进程管理 Worker 多进程，包括 TaskWorker 的进程。 每个 Worker 接受来自 Reactor 的请求，只需要执行回调函数部分的 PHP 代码。 只在 Master 启动时执行一遍 PHP 初始化代码，Master 进入监听状态，并不会结束进程。 不仅可以用于 HTTP Server，还可以建立 TCP 连接、WebSocket 连接。 进程间通信? 进程隔离? 进程信号量?进程间通信 管道 我们知道进程直接是相互独立的，那如果在进程之间通信就需要通过特殊介质，建立管道是其中一种方式。 管道分无名管道(pipe)和有名管道(FIFO)，无名管道只能用于父子进程或者兄弟进程这些具有亲缘关系的进程； 为了克服这个缺点，就有了有名管道，提供非亲缘关系直接进程间通信 信号 比如我们kill命令来杀死一个进程，就是内核生成一个信号，当系统捕获到是这个信号就会做出相应得操作。 信号可以作为进程间通信或修改行为的一种方式，明确地由一个进程发送给另一个进程。一个信号的产生叫生成，接收到一个信号叫捕获。 消息队列 共享内存 进程隔离 不同的进程中PHP变量不是共享，即使是全局变量，在A进程内修改了它的值，在B进程内是无效的 如果需要在不同的Worker进程内共享数据，可以用Redis、MySQL、文件、Swoole\\Table、APCu、shmget等工具实现 不同进程的文件句柄是隔离的，所以在A进程创建的Socket连接或打开的文件，在B进程内是无效，即使是将它的fd发送到B进程也是不可用的 基础的TCP/UDP认知TCP 和 UDP的区别 ? TCP(Transmission Control Protocol, 传输控制协议)TCP 三次握手 四次挥手 UDP(User Data Protocol, 用户数据报协议) 区别 基于连接与无连接; 对系统资源的要求 (TCP较多，UDP少); UDP程序结构较简单; 流模式与数据报模式; TCP保证数据正确性，UDP可能丢包; TCP保证数据顺序，UDP不保证 OSI七层模型中的上四层 ? 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 协程Swoole的协程工作模式 ? 内存栈 4.0版本使用了PHP+C的双栈模式。创建协程时会创建一个C栈，默认尺寸为2M，创建一个PHP栈，默认为8K。 C栈主要用于保存底层函数调用的局部变量数据，用于解决call_user_func、array_map等C函数调用在协程切换时未能还原的问题。4.0版本无论如何切换协程，底层总是能正确地切换回原先的C函数栈帧继续向下执行。 协程切换 C栈切换使用了boost.context 1.60汇编代码，用于保存寄存器，切换指令序列。主要是jump_fcontext这个ASM函数提供。PHP栈的切换是跟随C栈切同步进行的。底层会切换EG(vm_stack)使得PHP恢复到正确的PHP函数栈帧。4.0.2版本还增加了ob输出缓存区的切换，ob_start等操作也可以用于协程。 协程调度 4.0协程实现中，主协程即为Reactor协程，负责整个EventLoop的运行。主协程实现事件监听，在IO事件完成后唤醒其他工作协程。 协程挂起 在工作协程中执行一些IO操作时，底层会将IO事件注册到EventLoop，并让出执行权。 协程恢复 当主协程的Reactor接收到新的IO事件，底层会挂起主协程，并恢复IO事件对应的工作协程。该工作协程挂起或退出时，会再次回到主协程。 Swoole常见的”坑”为何全局变量无法共享呢 ? 这是在于出现了进程克隆，而每个进程之间的数据都是不一致的。 echo var_dump 无法输出到浏览器(http响应) ? 原因在于模式的变更，swoole的运行模式不再是fpm，而是cli，如果你需要把数据响应给浏览器，你只能 通过Http request回调中的response对象进行响应 http请求参数获取 ? 在同swoole的http服务的时候，很多人会发现$_GET、$_POST等常见全局变量无法使用。这是因为$_GET、$_POST等变量都是全局的，在swoole当中会出现问题，如果想获取请求参数，可以用swoole回调时提供的Request对象来进行获取 swoole不能使用die/exit ? phper都习惯用die/exit来调试代码，这是因为这个命令会直接退出当前进程，对于fpm来讲，每个请求都对应一个独立进程，退出了问题不大，但是在swoole当中，可能一个进程中会有多个请求同时在处理，如果你exit或者die来退出当前进程，会导致数据丢失。 swoole下为何需要断线重连 ? 在swoole常驻内存的情况下， 请求结束后，该连接并不会被清理，依旧保留在内存空间内，而该连接若是长时间没有使用，或者是因为网络波动，那么就会断开。下次请求进来的时候，你没有判断连接状态，就直接去执行sql语句，那么就意味着你操作了一个断线的数据库连接，因此肯定会报错。","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"}]},{"title":"Swoft V2 学习日志","slug":"Swoft-V2-Learning","date":"2020-04-09T02:43:20.000Z","updated":"2020-04-09T02:48:29.000Z","comments":true,"path":"2020/04/09/Swoft-V2-Learning/","link":"","permalink":"http://blog.caoxl.com/2020/04/09/Swoft-V2-Learning/","excerpt":"","text":"","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"},{"name":"Swoft","slug":"Swoft","permalink":"http://blog.caoxl.com/tags/Swoft/"}]},{"title":"PHP7.4 新特性","slug":"PHP-74-New-Features","date":"2020-04-08T09:39:35.000Z","updated":"2020-04-08T09:55:44.000Z","comments":true,"path":"2020/04/08/PHP-74-New-Features/","link":"","permalink":"http://blog.caoxl.com/2020/04/08/PHP-74-New-Features/","excerpt":"原文地址: PHP7.4 新特性","text":"原文地址: PHP7.4 新特性 属性添加限定类型12345678910111213&lt;?phpclass User&#123; public int $age; public string $name&#125;$user = new User();$user-&gt;age = 10;$user-&gt;name = \"张三\";// error 需要传递int$user-&gt;age = \"zhang\"; 箭头函数这个特性基本上参考 Js 的 ES6 的语法。可以让我们的代码写的更少。如果你的代码有 fn 这个函数。可能会冲突 123456789&lt;?php$factor = 10;$nums = array_map(fn($n) =&gt; $n * $factor, [1, 2, 3]); // [10,20,30]// 之前的写法$nums = array_map(function ($num) use ($factor) &#123; return $num * $factor;&#125;, [1, 2, 3]) 有限返回类型协变与参数类型逆变仅当使用自动加载时，才提供完全协变 / 逆变支持。在单个文件中，只能使用非循环类型引用，因为所有类在被引用之前都必须可用。 1234567891011&lt;?phpclass A &#123;&#125;class B extends A &#123;&#125;class Producer &#123; public function method(): A &#123;&#125;&#125;class ChildProducer extends Producer &#123; public function method(): B &#123;&#125;&#125; 数组解包使用展开运算符 ... 解包数组。这个特性，应该又是从 js 那吸收过来的。看例子 12345678&lt;?php$parts = ['apple', 'pear'];$fruits = ['banana', 'orange', ...$parts, 'watermelon'];// ['banana', 'orange', 'apple', 'pear', 'watermelon'];// 老的写法$fruits = array_merge(['banana', 'orange'], $parts, ['watermelon']); 空合并运算符赋值12345678&lt;?php$array['key'] ??= computeDefault();// 老的写法if (!isset($array['key'])) &#123; $array['key'] = computeDefault();&#125; 数值文字分隔符数字文字可以在数字之间包含下划线。 123456&lt;?php6.674_083e-11; // float299_792_458; // decimal0xCAFE_F00D; // hexadecimal0b0101_1111; // binary 允许从 __toString () 抛出异常 现在允许从 __toString() 引发异常，以往这会导致致命错误，字符串转换中现有的可恢复致命错误已转换为 Error 异常。 Filter 新增 FILTER_VALIDATE_FLOAT 123&lt;?phpfilter_var(1.00, FILTER_VALIDATE_FLOAT); strip_tags 支持数组123456&lt;?phpstrip_tags($str,['p','a','div']);// 老的写法strip_tags($str,\"&lt;p&gt;&lt;a&gt;&lt;div&gt;\"); 废弃的特性没有显式括号的嵌套三元运算符12345&lt;?php1 ? 2 : 3 ? 4 : 5; // deprecated(1 ? 2 : 3) ? 4 : 5; // ok1 ? 2 : (3 ? 4 : 5); // ok 花括号访问数组索引123456&lt;?php$arr = [\"a\"=&gt;\"111\"];$index = \"a\";$arr&#123;$index&#125;; // 废弃$arr[$index]; real 和 is_real 实数12345&lt;?php$num = \"\";$a = (real) $num; // 废弃$a = (float) $num; parent 关键词在没父类的类中使用在没有父类的类中使用 parent 会出现编译错误。 123456789&lt;?phpclass Test&#123; public function index() &#123; return parent::index(); //编译错误 &#125;&#125; money_format 函数money_format 被废弃，使用 numberFormater 替换","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP7.4","slug":"PHP7-4","permalink":"http://blog.caoxl.com/tags/PHP7-4/"}]},{"title":"RabbitMQ 再深入","slug":"RabbitMQ-Learn-More","date":"2020-04-08T06:19:22.000Z","updated":"2020-04-08T07:11:27.000Z","comments":true,"path":"2020/04/08/RabbitMQ-Learn-More/","link":"","permalink":"http://blog.caoxl.com/2020/04/08/RabbitMQ-Learn-More/","excerpt":"问即是学","text":"问即是学 什么是RabbitMQ ? RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的消息中间件 什么是消息中间件 ? 是关注于数据的发送和接收，利用高效可靠的异步消息传递机制集成分布式系统 RabbitMQ的使用场景 ? 服务间异步通信 顺序消费 定时任务 请求削峰 RabbitMQ基本概念 ? Broker: 简单来说就是消息队列服务器实体 Exchange: 消息交换机，它指定消息按什么规则，路由到哪个队列 Queue: 消息队列载体，每个消息都会被投入到一个或多个队列 Binding: 绑定，它的作用就是把exchange和queue按照路由规则绑定起来 Routing Key: 路由关键字，exchange根据这个关键字进行消息投递 VHost: vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等，但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段 Producer: 消息生产者，就是投递消息的程序 Consumer: 消息消费者，就是接受消息的程序 Channel: 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务 RabbitMQ的工作模式 ?Simple模式 (即最简单的收发模式) 消息产生消息，将消息放入队列 消息的消费者(consumer) 监听 消息队列,如果队列中有消息,就消费掉,消息被拿走后,自动从队列中删除(隐患 消息可能没有被消费者正确处理,已经从队列中消失了,造成消息的丢失，这里可以设置成手动的ack,但如果设置成手动ack，处理完后要及时发送ack消息给队列，否则会造成内存溢出)。 Work工作模式 (资源的竞争) 消息产生者将消息放入队列消费者可以有多个,消费者1,消费者2同时监听同一个队列,消息被消费。 C1 C2共同争抢当前的消息队列内容,谁先拿到谁负责消费消息(隐患：高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关(synchronize) 保证一条消息只能被一个消费者使用)。 Publish/Subscribe发布订阅 (共享资源) 每个消费者监听自己的队列； 生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。 Routing路由模式 消息生产者将消息发送给交换机按照路由判断,路由是字符串(info) 当前产生的消息携带路由字符(对象的方法),交换机根据路由的key,只能匹配上路由key对应的消息队列,对应的消费者才能消费消息; 根据业务功能定义路由字符串 从系统的代码逻辑中获取对应的功能字符串,将消息任务扔到对应的队列中。 业务场景:error 通知;EXCEPTION;错误通知的功能;传统意义的错误通知;客户通知;利用key路由,可以将程序中的错误封装成消息传入到消息队列中,开发者可以自定义消费者,实时接收错误; Topic主题模式 (路由模式的一种) 星号井号代表通配符 星号代表多个单词,井号代表一个单词 路由功能添加模糊匹配 消息产生者产生消息,把消息交给交换机 交换机根据key的规则模糊匹配到对应的队列,由队列的监听消费者接收消息消费 如何保证RabbitMQ消息的顺序性 ?如何确保消息正确地发送至 RabbitMQ ?发送方确认模式 将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。 一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。 如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（not acknowledged，未确认）消息。 发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。 接收方确认机制 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。 这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性； 下面罗列几种特殊情况 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重） 如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将不会给该消费者分发更多的消息。 如何保证RabbitMQ消息的可靠传输 ?消息不可靠的情况可能是消息丢失，劫持等原因； 丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息； 生产者丢失消息从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息； transaction机制 发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降； confirm模式 一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。 消息队列丢失消息 消息持久化。处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。 如何持久化? 将queue的持久化标识durable设置为true,则代表是一个持久的队列 发送消息的时候将deliveryMode=2 消费者丢失消息 消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！解决方案：处理消息成功后，手动回复确认消息。 RabbitMQ 上的一个 queue 中存放的 message 是否有数量限制 ? 可以认为是无限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。 消息基于什么传输 ? RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。 消息如何分发 ? 若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能 消息怎么路由 ? 消息提供方-&gt;路由-&gt;一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换机有不同的路由规则）； 常用的交换机主要分为一下三种： fanout: 如果交换机收到消息，将会广播到所有绑定的队列上 direct: 如果路由键完全匹配，消息就被投递到相应的队列 topic: 可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换机时，可以使用通配符 RabbitMQ 的优缺点 ?优点 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。 日志处理 - 解决大量日志传输。 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。 缺点 系统可用性降低 系统复杂度提高 一致性问题","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.caoxl.com/tags/RabbitMQ/"}]},{"title":"RabbitMQ 实战记录","slug":"RabbitMq-Actual-Combat-1","date":"2020-04-03T01:37:50.000Z","updated":"2020-04-03T06:57:24.000Z","comments":true,"path":"2020/04/03/RabbitMq-Actual-Combat-1/","link":"","permalink":"http://blog.caoxl.com/2020/04/03/RabbitMq-Actual-Combat-1/","excerpt":"啊 好久没有写博客了, 我的博客就是总结自己的学习之路加油 重新启程 keep calm and think more.","text":"啊 好久没有写博客了, 我的博客就是总结自己的学习之路加油 重新启程 keep calm and think more. 准备 composer require php-amqplib/php-amqplib 生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpnamespace app\\api\\controller;use PhpAmqpLib\\Connection\\AMQPStreamConnection;use PhpAmqpLib\\Message\\AMQPMessage;use PhpAmqpLib\\Wire\\AMQPTable;use think\\Request;class Test&#123; /** * 消息队列 * @throws \\Exception */ public function deliver() &#123; $params = Request::instance()-&gt;param(); unset($params['sign']); $params['send_time'] = time(); $params['create_time'] = time(); $this-&gt;deliverMessage(json_encode($params), 'test_exchange', 'api_test_queue', 'api_test'); echo 'Done';exit(); &#125; /** * 消息队列 - 投递消息 * @param $message * @param $exchangeName * @param $queueName * @param $routingKey * @throws \\Exception */ private function deliverMessage($message, $exchangeName, $queueName, $routingKey) &#123; // 创建连接和信道 $connection = new AMQPStreamConnection( RABBITMQ_CONFIG['host'], RABBITMQ_CONFIG['port'], RABBITMQ_CONFIG['TEST']['user'], RABBITMQ_CONFIG['TEST']['password'], RABBITMQ_CONFIG['TEST']['vhost'] ); if (!$connection-&gt;isConnected()) &#123; var_dump('Connection failed'); &#125; $channel = $connection-&gt;channel(); // 声明交换机 // type参数: (direct:精准推送 fanout:广播 topic:组播) $channel-&gt;exchange_declare($exchangeName, 'direct', false, false, false); $table = new AMQPTable(); $table-&gt;set('x-queue-mode', 'lazy'); // 声明队列 $channel-&gt;queue_declare($queueName, false, true, false, false, false, $table); // 将队列绑定到交换机 $channel-&gt;queue_bind($queueName, $exchangeName, $routingKey); $msg = new AMQPMessage($message, [ 'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_NON_PERSISTENT, ]); // 向队列发送消息 $channel-&gt;basic_publish($msg, $exchangeName, $routingKey); // 关闭信道, 关闭连接 $channel-&gt;close(); $connection-&gt;close(); &#125;&#125; http://tp5.test/api/test/deliver 消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpnamespace app\\api\\command;require_once APP_PATH . 'api.php';use think\\console\\&#123; Command, Input, Output&#125;;use PhpAmqpLib\\Connection\\AMQPStreamConnection;use PhpAmqpLib\\Wire\\AMQPTable;class Test extends Command&#123; protected function configure() &#123; $this-&gt;setName('cmd_test') -&gt;setDescription('RabbitMQ Consumer Test'); &#125; /** * 执行命令 * @param Input $input * @param Output $output * @return int|void|null * @throws \\ErrorException * @throws \\Exception */ protected function execute(Input $input, Output $output) &#123; // 交换机 $exchangeName = \"test_exchange\"; // 队列 $queueName = \"api_test_queue\"; // 路由键 $routingKey = \"api_test\"; // 创建连接和信道 $connection = new AMQPStreamConnection( RABBITMQ_CONFIG['host'], RABBITMQ_CONFIG['port'], RABBITMQ_CONFIG['TEST']['user'], RABBITMQ_CONFIG['TEST']['password'], RABBITMQ_CONFIG['TEST']['vhost'] ); $channel = $connection-&gt;channel(); // 声明交换机 $channel-&gt;exchange_declare($exchangeName, 'direct', false, false, false); // 设置惰性队列 $table = new AMQPTable(); $table-&gt;set('x-queue-mode', \"lazy\"); // 声明队列 $channel-&gt;queue_declare($queueName, false, true, false, false, false, $table); // 将队列绑定到交换机 $channel-&gt;queue_bind($queueName, $exchangeName, $routingKey); $callback = function ($msg) &#123; // TODO 处理数据 try &#123; $msg-&gt;delivery_info['channel']-&gt;basic_ack($msg-&gt;delivery_info['delivery_tag']); &#125; catch (\\Exception $e) &#123; var_dump($e-&gt;getMessage()); &#125; &#125;; // 设置consumer同时处理队列数量 $channel-&gt;basic_qos(null, 1, null); // 消费队列 $channel-&gt;basic_consume($queueName, '', false, false, false, false, $callback); while (count($channel-&gt;callbacks)) &#123; $channel-&gt;wait(); &#125; // 关闭信道,关闭连接 $channel-&gt;close(); $connection-&gt;close(); &#125;&#125; php think cmd_test api.php 12345678910// Rabbit配置信息define('RABBITMQ_CONFIG', [ 'host' =&gt; '127.0.0.1', 'port' =&gt; 5672, 'TEST' =&gt; [ // 玩法虚拟机 'user' =&gt; 'test' , 'password' =&gt; 'test', 'vhost' =&gt; 'test' ],]);","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.caoxl.com/tags/RabbitMQ/"}]},{"title":"Yii2 邮件发送","slug":"Yii2-Send-Mail-Notes","date":"2020-01-02T02:35:11.000Z","updated":"2020-01-02T03:31:45.000Z","comments":true,"path":"2020/01/02/Yii2-Send-Mail-Notes/","link":"","permalink":"http://blog.caoxl.com/2020/01/02/Yii2-Send-Mail-Notes/","excerpt":"Yii2中官方为了解决邮件发送问题，提供了swiftMailer扩展。","text":"Yii2中官方为了解决邮件发送问题，提供了swiftMailer扩展。 安装 官方的包自带了yii2-swiftmailer, 如果需要自行下载可以使用下面这个 1composer require --prefer-dist yiisoft/yii2-swiftmailer 配置 config/web.php 1234567891011121314151617181920212223242526return [ //.... 'components' =&gt; [ 'mailer' =&gt; [ 'class' =&gt; 'yii\\swiftmailer\\Mailer', 'viewPath' =&gt; '@common/mail', // send all mails to a file by default. You have to set // 'useFileTransport' to false and configure a transport // for the mailer to send real emails. 'useFileTransport' =&gt; false, 'transport' =&gt; [ //这里如果你是qq的邮箱，可以参考qq客户端设置后再进行配置 http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;id=28&amp;&amp;no=1001256 'class' =&gt; 'Swift_SmtpTransport', 'host' =&gt; 'smtp.163.com', 'username' =&gt; '******@163.com', 'password' =&gt; '******', 'port' =&gt; '25', 'encryption' =&gt; 'tls', ], 'messageConfig' =&gt; [ 'charset' =&gt; 'UTF-8', 'from' =&gt; ['***@163.com' =&gt; '白狼栈'] ], ], ], ]; 简单使用12345678910111213141516171819202122232425&lt;?phpnamespace app\\controllers;use yii\\web\\Controller;class EmailController extends Controller&#123; public function actionEmail() &#123; try &#123; $result = \\Yii::$app-&gt;mailer-&gt;compose() -&gt;setFrom('******@163.com') -&gt;setTo('******@163.com') -&gt;setSubject('测试邮件') -&gt;setTextBody('测试邮件') -&gt;setHtmlBody('&lt;b&gt;测试邮件&lt;/b&gt;') -&gt;send(); &#125; catch (\\Exception $e) &#123; var_dump($e-&gt;getMessage()); &#125; var_dump(1024);die; &#125;&#125; 批量发送1234567891011121314151617181920public function actionEmailMulti()&#123; $users = ['***@qq.com', '******@qq.com']; $messages = []; foreach ($users as $user) &#123; $messages[] = Yii::$app-&gt;mailer-&gt;compose() -&gt;setTo($user) -&gt;setSubject('测试主题') -&gt;setHtmlBody('测试内容'); &#125; try &#123; \\Yii::$app-&gt;mailer-&gt;sendMultiple($messages); &#125; catch (\\Exception $e) &#123; var_dump($e-&gt;getMessage()); &#125; var_dump(1024);die;&#125;","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Email","slug":"Email","permalink":"http://blog.caoxl.com/tags/Email/"},{"name":"Yii2","slug":"Yii2","permalink":"http://blog.caoxl.com/tags/Yii2/"},{"name":"邮件发送","slug":"邮件发送","permalink":"http://blog.caoxl.com/tags/邮件发送/"}]},{"title":"Linux 查看CPU信息","slug":"Linux-CPU-Information","date":"2019-12-23T07:59:39.000Z","updated":"2019-12-23T08:25:43.000Z","comments":true,"path":"2019/12/23/Linux-CPU-Information/","link":"","permalink":"http://blog.caoxl.com/2019/12/23/Linux-CPU-Information/","excerpt":"总核数 = 物理CPU个数 X 每颗物理CPU的核数总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数","text":"总核数 = 物理CPU个数 X 每颗物理CPU的核数总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数 查看物理CPU个数12[root@caoxl ~]# cat /proc/cpuinfo | grep \"physical id\" | sort | uniq | wc -l1 查看每个物理CPU中core的个数(即核数)12[root@caoxl ~]# cat /proc/cpuinfo | grep \"cpu cores\" | uniqcpu cores : 1 查看逻辑CPU的个数12[root@caoxl ~]# cat /proc/cpuinfo | grep \"processor\" | wc -l2 查看位于相同物理封装的处理器中的逻辑处理器的数量。12[root@caoxl ~]# cat /proc/cpuinfo | grep \"siblings\" | sort | uniqsiblings : 2 查看CPU信息（型号）12[root@caoxl ~]# cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 2 Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHz /proc/cpuinfo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@caoxl ~]# cat /proc/cpuinfoprocessor : 0vendor_id : GenuineIntelcpu family : 6model : 79model name : Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHzstepping : 1microcode : 0x1cpu MHz : 2499.996cache size : 40960 KBphysical id : 0siblings : 2core id : 0cpu cores : 1apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ibrs ibpb stibp fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt spec_ctrl intel_stibpbogomips : 4999.99clflush size : 64cache_alignment : 64address sizes : 46 bits physical, 48 bits virtualpower management:processor : 1vendor_id : GenuineIntelcpu family : 6model : 79model name : Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHzstepping : 1microcode : 0x1cpu MHz : 2499.996cache size : 40960 KBphysical id : 0siblings : 2core id : 0cpu cores : 1apicid : 1initial apicid : 1fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ibrs ibpb stibp fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt spec_ctrl intel_stibpbogomips : 4999.99clflush size : 64cache_alignment : 64address sizes : 46 bits physical, 48 bits virtualpower management: 以上输出项的含义如下： processor ：系统中逻辑处理核的编号。对于单核处理器，则可认为是其CPU编号，对于多核处理器则可以是物理核、或者使用超线程技术虚拟的逻辑核vendor_id：CPU制造商cpu family：CPU产品系列代号model：CPU属于其系列中的哪一代的代号model name：CPU属于的名字及其编号、标称主频stepping：CPU属于制作更新版本cpu MHz：CPU的实际使用主频cache size：CPU二级缓存大小physical id：单个CPU的标号siblings：单个CPU逻辑物理核数core id：当前物理核在其所处CPU中的编号，这个编号不一定连续cpu cores：该逻辑核所处CPU的物理核数apicid：用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续fpu：是否具有浮点运算单元（Floating Point Unit）fpu_exception：是否支持浮点计算异常cpuid level：执行cpuid指令前，eax寄存器中的值，根据不同的值cpuid指令会返回不同的内容wp：表明当前CPU是否在内核态支持对用户空间的写保护（Write Protection）flags：当前CPU支持的功能bogomips：在系统内核启动时粗略测算的CPU速度（Million Instructions Per Second）clflush size：每次刷新缓存的大小单位cache_alignment：缓存地址对齐单位address sizes：可访问地址空间位数power management：对能源管理的支持 lscpu命令123456789101112131415161718192021222324[root@caoxl ~]# lscpuArchitecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 24On-line CPU(s) list: 0-23Thread(s) per core: 2Core(s) per socket: 12Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 85Model name: Intel(R) Xeon(R) Platinum 8163 CPU @ 2.50GHzStepping: 4CPU MHz: 2494.132BogoMIPS: 4988.26Hypervisor vendor: KVMVirtualization type: fullL1d cache: 32KL1i cache: 32KL2 cache: 1024KL3 cache: 33792KNUMA node0 CPU(s): 0-23","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"CPU","slug":"CPU","permalink":"http://blog.caoxl.com/tags/CPU/"}]},{"title":"Yii2 速查表","slug":"Yii2-Cheat-Sheet","date":"2019-12-20T06:21:48.000Z","updated":"2019-12-20T09:20:40.000Z","comments":true,"path":"2019/12/20/Yii2-Cheat-Sheet/","link":"","permalink":"http://blog.caoxl.com/2019/12/20/Yii2-Cheat-Sheet/","excerpt":"Yii2 速查表","text":"Yii2 速查表 Composer 安装yii程序 1composer create-project --prefer-dist yiisoft/yii2-app-basic basic 通过composer.json安装扩展 1composer install 更新本地composer扩展库 1composer update 直接安装某个composer扩展 1composer require [options] [--] [vendor/packages]... DAO Yii的数据库读取对象，在PDO之上，DAO后有了Query Builder和AR 获得数据库连接 1$conn = Yii::$app-&gt;db; 执行数据库查询语句 123Yii::$app-&gt;db-&gt;createCommand(\"SELECT * FROM `user`\");Yii::$app-&gt;db-&gt;createCommand(\"SELECT * FROM `user` WHERE uid=:uid\",[\":uid\"=&gt;1]);Yii::$app-&gt;db-&gt;createCommand(\"SELECT * FROM `user` WHERE uid=:uid\")-&gt;addValue([\":uid\"=&gt;1]); SQL语句插入数据 12Yii::$app-&gt;db-&gt;createCommand('INSERT INTO user (email, password) VALUES(\"test3@example.com\", \"test3\");')-&gt;execute(); 数组形式插入数据 12345Yii::$app-&gt;db-&gt;createCommand()-&gt;insert('user', [ 'email' =&gt; 'test4@example.com', 'password' =&gt; 'changeme7', 'first_name' =&gt; 'Test'])-&gt;execute(); 批量插入数据 12345Yii::$app-&gt;db-&gt;createCommand()-&gt;batchInsert('user', ['email', 'password', 'first_name'],[ ['james.franklin@example.com', 'changeme7', 'James'], ['linda.marks@example.com', 'changeme7', 'Linda'] ['roger.martin@example.com', 'changeme7']])-&gt;execute(); 更新数据 1Yii::$app-&gt;db-&gt;createCommand()-&gt;update('user', ['updated_at' =&gt; time()], 'id = 2')-&gt;execute(); 删除数据 1Yii::$app-&gt;db-&gt;createCommand()-&gt;delete('user', 'id = 3')-&gt;execute(); 获取所有数据(数组形式返回) 1Yii::$app-&gt;db-&gt;createCommand(\"SELECT * FROM `user`\")-&gt;queryAll(); 获取一条数据（一维数组） 1Yii::$app-&gt;db-&gt;createCommand(\"SELECT * FROM `user` WHERE id = 1\")-&gt;queryOne(); 获取一个值 1Yii::$app-&gt;db-&gt;createCommand(\"SELECT count(*) AS total FROM `user` WHERE id = 1\")-&gt;queryScalar(); 获取某一列（放到一位数组中） 1Yii::$app-&gt;db-&gt;createCommand(\"SELECT username FROM `user`\")-&gt;queryColumn(); Logging trace 1Yii::trace($message,$category) info 1Yii::info($message,$category) warning 1Yii::warning($message,$category) error 1Yii::error($message,$category) Validator 数据验证，最常用于模型的rules()函数 required 必须值 1234[\"username\",'required'][[\"username\",\"email\"],'required'][[\"username\"],'required',\"message\"=&gt;\"&#123;attribute&#125;必须填写\"][[\"username\"],'required','requiredValue'=&gt;\"abei\"] // 用户填写的值必须等于requiredValue才能通过验证。 Email验证 12[\"email\",'email'][[\"email\",\"work_email\"],'email'] Boolean验证 1['sex', 'boolean', 'trueValue' =&gt; true, 'falseValue' =&gt; false, 'strict' =&gt; true];// 可以认为置顶 true / false 值。 captcha验证码 1['verificationCode', 'captcha']; compare比较 123['username', 'compare', 'compareAttribute' =&gt; 'province','message'=&gt;'username和province必须一样'] //错误信息将提示给username['age', 'compare', 'compareValue' =&gt; 30, 'operator' =&gt; '&gt;=','type' =&gt; 'number'];//compareValue:比较常量值 operator:比较操作符 type为值类型，默认为string，会一个每个字符对比，若为number则直接判断数值// operator 待选值==、===、!=、!==、&gt;、&gt;=、&lt;、&lt;= date验证 1[\"birth\",\"date\",\"format\"=&gt;\"Y-m-d\"] default验证 123456['age','default','value'=&gt;null] // 当age为空的时候设置为null['country','default','value'=&gt;'USA'] // 当 country为空时设置为USA/* 如果from为空，则=今天+3天，如果to为空，则=今天+6天 */[['from','to'],'default','value'=&gt;function($model,$attribute)&#123; return date('Y-m-d', strtotime($attribute === 'to' ? '+3 days' : '+6 days'));&#125;] double/number验证 12['v','double'] // 判断v是否为数字['v','double','max'=&gt;90,'min'=&gt;1]//判断v是否为数字且大于等于1、小于等于90 数组各元素验证 12/* 要求验证的元素必须为数组，否则会返回假并报错 */[\"categoryIds\",\"each\",\"rule\"=&gt;['integer']] exist是否存在验证 12345/* 所谓对存在的检查实质为where的与操作，必须同时满足的记录存在方可。兄弟们可以研究下，exist是对sql语句EXISTS的应用*/[\"username\",\"exist\"] // username输入的值已经存在[\"username\",\"exist\",\"targetAttribute\"=&gt;\"province\"] // username的输入值必须在province列存在[\"username\",\"exist\",'targetAttribute' =&gt; ['username', 'province']] // username的输入值必须在username和province中存在[[\"username\",\"province\"],\"exist\",'targetAttribute' =&gt; ['username', 'province']] // username和province的输入值必须在username和province中存在 file验证 12/* maxFiles代表一次最多传几个，mimeTypes代表上传文件类型 */['primaryImage', 'file', 'extensions' =&gt; ['png', 'jpg', 'gif'],'mimeTypes'=&gt;[\"image/*\"], 'maxSize' =&gt; 1024*1024,'minSize'=&gt;100*1024,'maxFiles'=&gt;6,'checkExtensionByMimeType'=&gt;true], filter过滤验证函数 12345[['username', 'email'], 'filter', 'filter' =&gt; 'trim', 'skipOnArray' =&gt; true],['phone', 'filter', 'filter' =&gt; function ($value) &#123; // normalize phone input here return $value;&#125;], image验证 12/* 上传png/jpg格式，最大宽度不能超过1000px，最小宽度不能低于100px，最大高度不能高于1000px。最小高度不能低于100px */['primaryImage', 'image', 'extensions' =&gt; 'png, jpg','minWidth' =&gt; 100, 'maxWidth' =&gt; 1000,'minHeight' =&gt; 100, 'maxHeight' =&gt; 1000] ip验证 1[\"ip_addess\",\"ip\"] in方法验证 1[\"level\",\"in\",\"range\"=&gt;[1,2,3]] integer验证 12[\"age\",'integer'];[\"age\",\"integer\",\"max\"=&gt;90,\"min\"=&gt;1] 正则匹配验证 1[\"username\",\"match\",\"pattern\"=&gt;\"/^[a-z]\\w*$/i\"] in方法验证 1[\"level\",\"in\",\"range\"=&gt;[1,2,3]] safe验证（多用于设置一个model的attribute） 1[\"description\",\"safe\"] string验证 1234[\"username\",\"string\",\"length\"=&gt;[4,24]];[\"username\",\"string\",\"min\"=&gt;4];[\"username\",\"string\",\"max\"=&gt;32];[\"username\",\"string\",\"encoding\"=&gt;\"UTF-8\"]; unique唯一验证 12[\"username\",\"unique\"][\"username\",\"unique\",\"targetAttribute\"=&gt;\"province\"] url验证 12[\"website\",\"url\"][\"website\",\"url\",\"validSchemes\"=&gt;[\"http\",\"https\"]] String 一个字符串中单词数量 1StringHelper::countWords(\"hello world\"); // 2 返回路径中的文件名部分 1StringHelper::basename(\"/path/hello.txt\",\".txt\"); // hello 返回路径中的目录名 1StringHelper::dirname(\"/home/path/hello.txt\");// /home/path 超出内容用…代替(不含HTML) 1StringHelper::truncate(\"hello world\",7,'...'); //hello w... 超出内容用…代替(识别HTML) 1StringHelper::truncate(\"hello world\",7,'...',null,true); // hello w... 以单词为单位超出部分用..代替（不解析HTML） 1StringHelper::truncateWords('This is a test sentance', 4, '...') //This is a test ... 以单词为单位超出部分用..代替（解析HTML） 1StringHelper::truncateWords('This is a test for a sentance', 5, '...',true) //This is a test for... 一个字符串是否以另一个字符串开始 1StringHelper::startsWith(\"hello world\",\"he\"); // true 一个字符串是否以另一个字符串结尾 1StringHelper::endsWith(\"hello world\",\"ald\");//false 按照分隔符分隔字符串为数组 123StringHelper::explode('It, is, a first, test'));//['It','is','a first','test']StringHelper::explode(\"a@b@c\",\"@\");['a','b','c']StringHelper::explode(\"a, b ,c \");['a','b','c'] Session&amp;Cookie Session被封装成一个应用组件，直接通过 Yii::$app-&gt;session 来访问；Cookie通过Request和Response来操作。 Session 获得session 1$session = Yii::$app-&gt;session; 检查session是否开启 1Yii::$app-&gt;session-&gt;isActive 开启一个session 1Yii::$app-&gt;session-&gt;open() 关闭session 1Yii::$app-&gt;session-&gt;close(); 销毁session中所有已注册的数据 1Yii::$app-&gt;session-&gt;destroy(); 访问一个session 1234/* 以下三种方法效果等同 */$language = $session-&gt;get('language');$language = $session['language'];$language = isset($_SESSION['language']) ? $_SESSION['language'] : null; 设置一个session 1234/* 以下三种方法效果等同 */$session-&gt;set('language', 'en-US');$session['language'] = 'en-US';$_SESSION['language'] = 'en-US'; 删除一个session变量 1234/* 下面三种方法效果等同 */$session-&gt;remove('language');unset($session['language']);unset($_SESSION['language']); 检查一个session变量是否存在 1234/* 以下三种方法效果一致 */if ($session-&gt;has('language')) ...if (isset($session['language'])) ...if (isset($_SESSION['language'])) ... Cookie 获取cookie 1$cookies = Yii::$app-&gt;request-&gt;cookies; 设置cookie 1$cookies = Yii::$app-&gt;response-&gt;cookies; 获取一个cookie值 1$language = $cookies-&gt;getValue('language', 'en');// 如果获取language失败，则返回\"en\"代替 另一种获取cookie值方法 123if (($cookie = $cookies-&gt;get('language')) !== null) &#123; $language = $cookie-&gt;value;&#125; 数组方式获取cookie值 123if (isset($cookies['language'])) &#123; $language = $cookies['language']-&gt;value;&#125; 检查一个cookie是否存在 12if ($cookies-&gt;has('language')) ...if (isset($cookies['language'])) ... 新增一个cookie 1234$cookies-&gt;add(new \\yii\\web\\Cookie([ 'name' =&gt; 'language', 'value' =&gt; 'zh-CN',])); 删除一个cookie 12$cookies-&gt;remove('language');unset($cookies['language']); Request Request 被配置为一个应用组件，我们可以通过Yii::$app-&gt;request访问它。 URL相关 获得当前请求的绝对url 1Yii::$app-&gt;request-&gt;getAbsoluteUrl(); 返回一个请求URL的hostInfo部分 1Yii::$app-&gt;request-&gt;getHostInfo(); 获得URL问号后的参数字符串 1Yii::$app-&gt;request-&gt;getQueryString() 返回服务器端口 1Yii::$app-&gt;request-&gt;getServerPort(); HTTP头 返回用户接受的内容类型 1Yii::$app-&gt;request-&gt; getAcceptableContentTypes (); // Header Accept 返回用户可接受的语言 1Yii::$app-&gt;request-&gt; getAcceptableLanguages(); // Header Accept-Language 返回GET/POST请求 1234Yii::$app-&gt;request-&gt;get();Yii::$app-&gt;request-&gt;get(\"id\");Yii::$app-&gt;request-&gt;POST();Yii::$app-&gt;request-&gt;POST(\"username\"); 判断请求类型（返回boolean） 123456Yii::$app-&gt;request-&gt;isAjax // 判断是否为ajax请求Yii::$app-&gt;request-&gt;isConsoleRequest // 判断是否为控制发起的请求Yii::$app-&gt;request-&gt;isDelete // 判断是否为DELETE请求Yii::$app-&gt;request-&gt;isGet // 判断是否为GET请求Yii::$app-&gt;request-&gt;isPost // 判断是否为POST请求Yii::$app-&gt;request-&gt;isPjax // 判断是否为isPjax请求 返回用户的 IP 1Yii::$app-&gt;request-&gt;getUserIP(); Response 和Request一样，Response被封装成Yii的一个组件，你可以通过Yii::$app-&gt;response轻松的访问它。 Status Code状态码 设置一个Status Code 1Yii::$app-&gt;response-&gt;statusCode = 200; Yii内置的通过异常形式返回状态码 1234567891011yii\\web\\BadRequestHttpException: status code 400.yii\\web\\ConflictHttpException: status code 409.yii\\web\\ForbiddenHttpException: status code 403.yii\\web\\GoneHttpException: status code 410.yii\\web\\MethodNotAllowedHttpException: status code 405.yii\\web\\NotAcceptableHttpException: status code 406.yii\\web\\NotFoundHttpException: status code 404.yii\\web\\ServerErrorHttpException: status code 500.yii\\web\\TooManyRequestsHttpException: status code 429.yii\\web\\UnauthorizedHttpException: status code 401.yii\\web\\UnsupportedMediaTypeHttpException: status code 415. HTTP Headers 添加设置删除Http Headers内容 1234567$headers = Yii::$app-&gt;response-&gt;headers;// add a Pragma header. Existing Pragma headers will NOT be overwritten.$headers-&gt;add('Pragma', 'no-cache');// set a Pragma header. Any existing Pragma headers will be discarded.$headers-&gt;set('Pragma', 'no-cache');// remove Pragma header(s) and return the removed Pragma header values in an array$values = $headers-&gt;remove('Pragma'); Response Body 相应主体 1Yii::$app-&gt;response-&gt;content = 'hello world!'; Controller 控制器，可在action内直接用$this调用。 渲染一个视图（如果布局有效则使用布局） 1$this-&gt;render('index', ['model' =&gt; $model]) 渲染视图（不使用布局） 1$this-&gt;renderPartial('index',['model'=&gt;$model]) 渲染视图（不使用布局） 12// 注入所有注册的JS/CSS脚本和文件,通常使用在响应AJAX网页请求的情况下$this-&gt;renderAjax('index',['model'=&gt;$model]) 只渲染布局 1$this-&gt;renderContent($content); ActiveForm 重点！列出最常用的ActiveForm方法。 取消客户端规则验证 123$form = ActiveForm::begin([ 'enableClientValidation'=&gt;false]); 取消yii.js的引入 123$form = ActiveForm::begin([ 'enableClientScript'=&gt;false]); 表单目标地址设置 123$form = ActiveForm::begin([ \"action\"=&gt;$url ]) GET &amp; POST 方法设置 123$form = ActiveForm::begin([ \"method\"=&gt;\"POST\"]); 设置Form的类及自己定义标签属性 123$form = ActiveForm::begin([ 'options'=&gt;[\"class\"=&gt;\"f\",\"data-name\"=&gt;\"xxx\"]]); 生成文本框 1$form-&gt;field($model, 'date')-&gt;textInput([\"key\"=&gt;\"value\"]); 生成文本域 1$form-&gt;field($model, 'date')-&gt;textarea([\"key\"=&gt;\"value\"]); 单选列表 1$form-&gt;field($model,'sex')-&gt;radioList($arr,[\"key\"=&gt;\"value\"]); 密码框 1$form-&gt;field($model,\"password\")-&gt;passwordInput(); 复选框 1$form-&gt;field($model,\"city_id\")-&gt;checkboxList($arr); 文件上传 1$form-&gt;field($model,\"image\")-&gt;fileInput(); 隐藏域 1$form-&gt;field($model,\"name\")-&gt;hiddenInput(); FileHelper 几个常用也好用的文件帮助方法 遍历一个文件夹下文件&amp;子文件夹 123FileHelper::findFiles('/path/to/search/');FileHelper::findFiles('.', ['only' =&gt; ['*.php', '*.txt']]); // 只返回php和txt文件FileHelper::findFiles('.', ['except' =&gt; ['*.php', '*.txt']]); // 排除php和txt文件 获得指定文件的MIME类型 1FileHelper::getMimeType('/path/to/img.jpeg'); 复制文件夹 1FileHelper::copyDirectory($src, $dst, $options = []) 删除一个目录及内容 1FileHelper::removeDirectory($dir, $options = []) 生成一个文件夹（同时设置权限） 1FileHelper::createDirectory($path, $mode = 0775, $recursive = true) UploadedFile 上传文件帮助类 通过模型的属性获取一个文件 1$file = UploadedFile::getInstance($model,'avatar') 通过模型的属性来获取一组文件 12$files = UploadedFile::getInstances($model,'avatar')//view $form-&gt;field($model,'avatar[]')-&gt;fileInput() 通过名字上传一个文件 1$file = UploadedFile::getInstanceByName('avatar'); 通过名字获取一组上传的文件 12$file = UploadedFile::getInstancesByName('avatar');// view Html::fileInput('avatar[]') 保存一个文件 1$file-&gt;saveAs(Yii::getAlias(\"@webroot\").'/data/test.jpg'); 获取上传文件原始名(不含扩展名) 1$file-&gt;getBaseName(); // test.jpg ===&gt; test 获取上传文件的扩展名(已经自动格式化为小写) 1$file-&gt;getExtension(); // 是png、不是image/png 获取文件的原始名 1$file-&gt;name; // test.jpg 获取文件媒体类型 1$file-&gt;type; // image/png 获取文件临时名 1$file-&gt;tempName; 获取文件大小 1$file-&gt;size; // 21744 Html 通过Html类的一些静态方法生成Html标签。 生成一个超级链接 1Html::a('链接的文本', $url); 通过Yii2的路由生成一个链接 12Html::a('链接文本', Url::to(['/site/index'], true));Html::a('链接文本', Yii::$app-&gt;urlManager-&gt;createUrl(['/site/index'])); 生成一个图片链接 1Html::img(\"/images/logo.png\",['class'=&gt;'img']); 生成一个按钮 1Html::button(\"按钮文本\",['class'=&gt;'button-action']); 发送邮件链接 1Html::mailto(\"阿北\",'abei@nai8.me',$options); 生成有序列表 12$list = ['china','usa'];Html::ol($list); 生成无须列表 12$list = ['china','usa','japan'];Html::ul($list); 生成javascript代码 1Html::script(\"alert('hello world');\") 生成style代码 12Html::style(\"color:#F60\");Html::style(\".list &#123;background:#FFF;&#125;\"); 生成一个css引用链接 1Html::cssFile(\"http://baidu.com/style.css\",[]); 生成一个js文件引用 1Html::jsFile($url,[]); 把字符 “&lt;” （小于）和 “&gt;” （大于）转换为HTML实体 1Html::encode($html); 将特色的HTML实体转化为&gt;和&lt; 1Html::decode($string); Query Builder 主要解决DAO在查询语句上的繁琐问题，无需输入原生SQL语句就可以完成数据库检索。 使用Query Builder需要使用的类 1$query = (new \\yii\\db\\Query()); // yii2使用Query对象来采集SQL的各个部分，然后由Query Builder组成SQL语句后由DAO发给数据库获得请求。 SELECT方法 1234$query-&gt;select(\"id,username\"); // 字符串形式$query-&gt;select(['id','username']); // 数组形式$query-&gt;select([\"userId\"=&gt;\"id\",\"fName\"=&gt;\"user.frist_name\"]); // 起别名$query-&gt;select([\"full_name\"=&gt;\"CONCAT(id,'-',username)\"]); // 支持MYSQL函数 FROM方法 12$query-&gt;from(\"user\"); // 字符串形式$query-&gt;from([\"u\"=&gt;\"user\"]); // 数据表别名 过滤掉重复记录 1$query-&gt;select(\"username\")-&gt;distinct()-&gt;from(\"user\"); // distinct WHERE函数用法 12345678910111213141516171819202122232425/* 传递字符串 */$query-&gt;where(\"id = 1\");$query-&gt;where(\"id = :id\")-&gt;addParams([\":id\"=&gt;1]);$query-&gt;where(\"id = :id\",[\":id\"=&gt;1]);/* 传递数组 */$query-&gt;where([\"username\"=&gt;\"abei\",\"age\"=&gt;[20,19,26]])-&gt;from(\"user\");// select * from user where username=\"abei\" AND age in (20,19,26)/* 操作符 */$query-&gt;where([\"&gt;\",\"id\",10]);// id &gt; 10$query-&gt;where([\"&lt;\",\"id\",10]); // id &lt; 10$query-&gt;where([\"&lt;&gt;\",\"id\",10]); // id &lt;&gt; 10$query-&gt;where([\"in\",\"id\",[10,12]]);// id in (10,20)$query-&gt;where([\"not in\",\"id\",[10,12]]);// id not in (10,20)$query-&gt;where([\"and\",\"id=1\",\"id=2\"]); id=1 AND id=2$query-&gt;where(['or', ['type' =&gt; [7, 8, 9]], ['id' =&gt; [1, 2, 3]]]); // (type IN (7, 8, 9) OR (id IN (1, 2, 3)))$query-&gt;where([\"between\", 'id', 1, 10]);// id between 1 AND 10$query-&gt;where([\"not\",[\"id\"=&gt;5]]);// not (id=5)$query-&gt;where([\"not between\",\"id\",1,10]);// id not between 1 AND 10$query-&gt;where([\"like\",\"username\",\"abei\"]); // username like \"%abei%\"$query-&gt;where([['like', 'username', ['abei', 'liuhuan']]]); // username like \"%abei%\" AND username like \"%liuhuan%\"$query-&gt;where(['like', 'username', '%abei', false]); // username like \"%abei\"$query-&gt;where([\"or like\", 'username', ['abei', 'liuhuan']]);// username like \"%abei%\" OR username like \"%liuhuan%\"，只作用于范围为数组的形式$query-&gt;where([\"not like\",xxxxx]);// 与like用法一致$query-&gt;where([\"or not like\",xxx])// 与not like用法一致 一个要单独说明的exists 12/* EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False */$query-&gt;where(['exists', (new Query())-&gt;select('id')-&gt;from('user')-&gt;where(['id' =&gt; 1])]); ORDER BY 方法 123$query-&gt;orderBy(\"id DESC\");$query-&gt;orderBy([\"id\"=&gt;SORT_DESC]);$query-&gt;orderBy([\"id\"=&gt;SORT_DESC,'create_time'=&gt;SORT_ASC]); GROUP BY &amp;&amp; HAVING 12$query-&gt;groupBy([\"username\"]);$query-&gt;groupBy([\"id\"])-&gt;having([\"&gt;\",'id',20]); 获取生成的SQL语句 1$query-&gt;createCommand()-&gt;sql; 获得查询结果 获取所有结果 1$query-&gt;all();// 二位数组 获取一条记录 1$query-&gt;one(); 检查一个数据库中是否含有某个表 1(new \\yii\\db\\Query)-&gt;from('user')-&gt;exists(); 获取count 1$query-&gt;count(); 获取一个值 1$query-&gt;scalar(); 获取一列值 1$query-&gt;column(); // 一位数组 获取一个user表的内容 12345$query = new \\yii\\db\\Query;$query-&gt;from(\"user\");$query-&gt;select([\"fname\"=&gt;\"username\"]);$query-&gt;where([\"&gt;\",'id',10]);$query-&gt;all(); Migrate 生成一个迁移文件 1./yii migrate/create script_name // script_name为脚本名字（需要英文格式） 执行所有没有迁移的脚本 12./yii migrate./yii migrate/up 执行置顶的迁移 1./yii migrate/up 脚本名 // 不用含有扩展名 Asset Management Asset资源管理 类属性说明 12345678$basePath // 资源文件所在的web服务器目录路径，一般为@webroot$baseUrl // js和css文件相对url基地址$css // asset bundle 所包含的css文件数组$cssOptions // 对link标签的属性控制$js // asset bundle 所包含的js文件数组$jsOptions // 对script标签的属性控制$publishOptions // 发布操作$sourcePath // 当资源网络不可以访问，则必须指定此目录。 去掉浏览器缓存 1'appendTimestamp' =&gt; true // 在web.php里的components - assetManager 发布资源筛选 1234567891011public $publishOptions = [ 'only' =&gt; [ 'fonts/*', 'css/*', 'test.js' ], 'except'=&gt;[ 'img' ],]; js文件在页面的位置 123public $jsOptions = ['position' =&gt; \\yii\\web\\View::POS_HEAD];//js文件发布到head标签内public $jsOptions = ['position' =&gt; \\yii\\web\\View::POS_END];//js文件发布到body标签底部public $jsOptions = ['position' =&gt; \\yii\\web\\View::POS_BEGIN];//js文件放到body标签开始处 浏览器兼容问题 1public $cssOptions = ['condition' =&gt; 'IE 11'];// 代表兼容ie11 是否使用符号链接 1'linkAssets' =&gt; true // 在web.php里的components - assetManager 配置yii自身的asset资源 1234567// 在web.php里的components - assetManager，配置自定义的也可以'bundles' =&gt; [ 'yii/web/YiiAsset'=&gt;[ 'js'=&gt;[], ...... ]] Event 有关事件的所有，系统自带事件通通给你。 Application 应用处理请求before之前触发 1Application::EVENT_BEFORE_REQUEST 应用处理请求after之后触发 1Application::EVENT_AFTER_REQUEST Controller 在每个Action运行之前触发 1Controller::EVENT_BEFORE_ACTION 在每个Action运行之后触发 1Controller::EVENT_AFTER_ACTION Model 在验证Model属性之前触发 1Model::EVENT_BEFORE_VALIDATE 在验证Model属性之后触发 1Model::EVENT_AFTER_VALIDATE Module 一个模块的Action运行前触发 1Module::EVENT_BEFORE_ACTION 一个模块的Action运行后触发 1Module::EVENT_AFTER_ACTION View 执行视图的beforePage时触发 1View::EVENT_BEGIN_PAGE 执行视图的endPage函数时触发 1View::EVENT_END_PAGE 在renderFile渲染一个视图文件之前触发 1View::EVENT_BEFORE_RENDER 在renderFile渲染一个视图文件之后触发 1View::EVENT_AFTER_RENDER 执行视图的beginBody函数时触发 1View::EVENT_BEGIN_BODY 执行视图的endBody函数时触发 1View::EVENT_END_BODY Widget Widget初始化时触发 1Widget::EVENT_INIT Widget执行前触发 1Widget::EVENT_BEFORE_RUN Widget执行之后触发 1Widget::EVENT_AFTER_RUN ActiveQuery 由ActiveQuery的init函数触发 1ActiveQuery::EVENT_INIT BaseActiveRecord &amp; ActiveRecord AR对象被初始化init时触发 1BaseActiveRecord::EVENT_INIT AR执行查询结束时触发 1BaseActiveRecord::EVENT_AFTER_FIND 插入结束时触发 1BaseActiveRecord::EVENT_BEFORE_INSERT 插入之后触发 1BaseActiveRecord::EVENT_AFTER_INSERT 更新记录之前触发 1BaseActiveRecord::EVENT_BEFORE_UPDATE 更新记录之后触发 1BaseActiveRecord::EVENT_AFTER_UPDATE 删除记录之前触发 1BaseActiveRecord::EVENT_BEFORE_DELETE 删除记录之后触发 1BaseActiveRecord::EVENT_AFTER_DELETE 在数据refresh成功之后触发 1BaseActiveRecord::EVENT_AFTER_REFRESH Connection 数据库连接被打开后触发 1Connection::EVENT_AFTER_OPEN 事务被启动时触发 1Connection::EVENT_BEGIN_TRANSACTION 事务被提交后触发 1Connection::EVENT_COMMIT_TRANSACTION 事务回滚后触发 1Connection::EVENT_ROLLBACK_TRANSACTION Response Response响应发送之前触发 1Response::EVENT_BEFORE_SEND Response响应发送之后触发 1Response::EVENT_AFTER_SEND Response响应内容准备好之后触发 1Response::EVENT_AFTER_PREPARE User 登陆之前触发 1User::EVENT_BEFORE_LOGIN 登陆之后触发 1User::EVENT_AFTER_LOGIN 注销之前触发 1User::EVENT_BEFORE_LOGOUT 注销之后触发 1User::EVENT_AFTER_LOGOUT Route&amp;UrlManager URL美化配置 123456789// conf/web.php'urlManager' =&gt; [ 'enablePrettyUrl' =&gt; true, 'showScriptName' =&gt; false, 'suffix'=&gt;'.html',// 统一后缀名，若不需要则无需配置 'enableStrictParsing'=&gt;false,//默认为false，是否采用严格解析 'rules' =&gt; [ ], ] Apache开启url重写方法 12345678// Apache需要支持url重写其AllowOverride为allAllowOverride:all//web目录下增加.htaccess，隐藏index.php文件 内容如下RewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule . index.php Nginx支持url重写 12345location / &#123; if (!-e $request_filename)&#123; rewrite ^/(.*) /index.php last; &#125;&#125; Apache开启url重写方法2 12345RewriteEngine OnRewriteBase /RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^(.*)\\?*$ index.php/$1 [L,QSA] RESTful 分页获得所有的会员 1234GET /usersGET /users?page=2GET /users?fields=id,username,created_atGET /users?sort=id,-username HTTP状态码 12345678910111213200: OK。一切正常。201: 响应 POST 请求时成功创建一个资源。Location header 包含的URL指向新创建的资源。204: 该请求被成功处理，响应不包含正文内容 (类似 DELETE 请求)。304: 资源没有被修改。可以使用缓存的版本。400: 错误的请求。可能通过用户方面的多种原因引起的，例如在请求体内有无效的JSON 数据，无效的操作参数，等等。401: 验证失败。403: 已经经过身份验证的用户不允许访问指定的 API 末端。404: 所请求的资源不存在。405: 不被允许的方法。 请检查 Allow header 允许的HTTP方法。415: 不支持的媒体类型。 所请求的内容类型或版本号是无效的。422: 数据验证失败 (例如，响应一个 POST 请求)。 请检查响应体内详细的错误消息。429: 请求过多。 由于限速请求被拒绝。500: 内部服务器错误。 这可能是由于内部程序错误引起的。 参考 Yii2 速查表","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Yii2","slug":"Yii2","permalink":"http://blog.caoxl.com/tags/Yii2/"},{"name":"速查表","slug":"速查表","permalink":"http://blog.caoxl.com/tags/速查表/"}]},{"title":"Yii2 Yes It is","slug":"Yii2-Learning-Notes","date":"2019-12-15T02:18:49.000Z","updated":"2019-12-27T03:34:06.000Z","comments":true,"path":"2019/12/15/Yii2-Learning-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/12/15/Yii2-Learning-Notes/","excerpt":"Yii2 Yes It is","text":"Yii2 Yes It is 关于YiiYii 是什么Yii 是一个高性能，基于组件的 PHP 框架，用于快速开发现代 Web 应用程序。 名字 Yii （读作 易）在中文里有“极致简单与不断演变”两重含义， 也可看作 Yes It Is! 的缩写。 Yii 版本Yii 当前有两个主要版本：1.1 和 2.0。 1.1 版是上代的老版本，现在处于维护状态。 2.0 版是一个完全重写的版本，采用了最新的技术和协议，包括依赖包管理器 Composer、PHP 代码规范 PSR、命名空间、Traits（特质）等等。 2.0 版代表新一代框架，是未来几年中我们的主要开发版本。 安装 Yii 通过 Composer 安装 1composer create-project --prefer-dist yiisoft/yii2-app-basic Yii2 验证安装的结果当安装完成之后， 或配置你的Web服务器(看下面的文章)或使用内置Web Server， 当在项目 web 目录下可以通过下面的命令: 1php yii serve 应用结构 Yii2 项目根目录 assets commands 控制台命令类目录 config 应用配置及其它配置目录 console.php 控制台应用配置信息 web.php Web 应用配置信息 controllers 控制器类目录 mail 邮件类目录 models 模型类目录 runtime Yii 在运行时生成的文件，例如日志和缓存文件 tests 单元测试 vagrant vendor 已经安装的 Composer 包，包括 Yii 框架自身 views 视图目录 web Web 应用根目录，包含 Web 入口文件 assets Yii 发布的资源文件（javascript 和 css） index.php 应用入口文件 widgets composer.json Composer 配置文件, 描述包信息 composer.lock yii 一般来说，应用中的文件可被分为两类：在 basic/web 下的和在其它目录下的。 前者可以直接通过 HTTP 访问（例如浏览器），后者不能也不应该被直接访问。一般来说，应用中的文件可被分为两类：在 basic/web 下的和在其它目录下的。 前者可以直接通过 HTTP 访问（例如浏览器），后者不能也不应该被直接访问。 请求生命周期 用户提交指向 入口脚本 web/index.php的请求 入口脚本会加载 配置数组 并创建一个 应用 实例用于处理该请求 应用会通过 request(请求) 应用组件解析被请求的 路由 应用创建一个 controller(控制器) 实例具体处理请求 控制器会创建一个 action(动作) 实例并为该动作执行相关的 Filters(访问过滤器) 如果任何一个过滤器验证失败, 该动作会被取消 如果全部的过滤器都通过, 该动作就会被执行 动作后悔加载一个数据模型, 一般是从数据库中加载 动作后悔渲染一个View(视图), 并为其提供所需的数据模型 渲染得到的结果会返回给 response(响应) 应用组件 响应组件会把渲染结果发回给用户的浏览器 说声 Hello这个章节，你将会掌握三件事： 如何创建一个动作去响应请求， 如何创建一个视图去构造响应内容， 以及一个应用如何分派请求给动作。 创建动作操作必须声明在控制器中。为了简单起见， 你可以直接在 SiteController 控制器里声明 say 操作。 这个控制器是由文件 controllers/SiteController.php 定义的。以下是一个操作的声明： 123456789101112131415&lt;?phpnamespace app\\controllers;use yii\\web\\Controller;class SiteController extends Controller&#123; // ...现存的代码... public function actionSay($message = 'Hello') &#123; return $this-&gt;render('say', ['message' =&gt; $message]); &#125;&#125; 创建视图视图是你用来生成响应内容的脚本。为了说 “Hello”， 你需要创建一个 say 视图，以便显示从操作方法中传来的 message 参数。 1234&lt;?phpuse yii\\helpers\\Html;?&gt;&lt;?= Html::encode($message) ?&gt; say 视图应该存为 views/site/say.php 文件。当一个操作中调用了 render() 方法时， 它将会按 views/控制器 ID/视图名.php路径加载 PHP 文件。 试运行创建完动作和视图后，你就可以通过下面的 URL 访问新页面了： 1http://hostname/index.php?r=site/say&amp;message=Hello+World 使用表单这个章节，你将会掌握三件事： 创建一个模型代表用户通过表单输入的数据 声明规则去验证输入的数据 在视图中生成一个 HTML 表单 创建模型模型类 EntryForm 代表从用户那请求的数据， 该类如下所示并存储在 models/EntryForm.php 文件中。 1234567891011121314151617181920&lt;?phpnamespace app\\models;use Yii;use yii\\base\\Model;class EntryForm extends Model&#123; public $name; public $email; public function rules() &#123; return [ [['name', 'email'], 'required'], ['email', 'email'], ]; &#125;&#125; 创建动作下面你得在 site 控制器中创建一个 entry 操作用于新建的模型。 12345678910111213141516171819202122232425262728&lt;?phpnamespace app\\controllers;use Yii;use yii\\web\\Controller;use app\\models\\EntryForm;class SiteController extends Controller&#123; // ...现存的代码... public function actionEntry() &#123; $model = new EntryForm; if ($model-&gt;load(Yii::$app-&gt;request-&gt;post()) &amp;&amp; $model-&gt;validate()) &#123; // 验证 $model 收到的数据 // 做些有意义的事 ... return $this-&gt;render('entry-confirm', ['model' =&gt; $model]); &#125; else &#123; // 无论是初始化显示还是数据验证错误 return $this-&gt;render('entry', ['model' =&gt; $model]); &#125; &#125;&#125; 表达式 Yii::$app 代表应用实例，它是一个全局可访问的单例。 同时它也是一个服务定位器， 能提供 request，response，db 等等特定功能的组件。 在上面的代码里就是使用 request 组件来访问应用实例收到的 $_POST 数据。 创建视图最后创建两个视图文件 entry-confirm 和 entry。 他们会被刚才创建的 entry 操作渲染。 entry-confirm 视图简单地显示提交的 name 和 email 数据。视图文件应该保存在 views/site/entry-confirm.php。 123456789&lt;?phpuse yii\\helpers\\Html;?&gt;&lt;p&gt;You have entered the following information:&lt;/p&gt;&lt;ul&gt; &lt;li&gt;&lt;label&gt;Name&lt;/label&gt;: &lt;?= Html::encode($model-&gt;name) ?&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;Email&lt;/label&gt;: &lt;?= Html::encode($model-&gt;email) ?&gt;&lt;/li&gt;&lt;/ul&gt; entry 视图显示一个 HTML 表单。视图文件应该保存在 views/site/entry.php。 123456789101112131415&lt;?phpuse yii\\helpers\\Html;use yii\\widgets\\ActiveForm;?&gt;&lt;?php $form = ActiveForm::begin(); ?&gt; &lt;?= $form-&gt;field($model, 'name') ?&gt; &lt;?= $form-&gt;field($model, 'email') ?&gt; &lt;div class=\"form-group\"&gt; &lt;?= Html::submitButton('Submit', ['class' =&gt; 'btn btn-primary']) ?&gt; &lt;/div&gt;&lt;?php ActiveForm::end(); ?&gt; 尝试下用浏览器访问下面的 URL 看它能否工作： 1http://hostname/index.php?r=site/entry 使用数据库这个章节，你将会掌握四件事： 配置一个数据库连接 定义一个活动记录类 使用活动记录从数据库中查询数据 以分页方式在视图中显示数据 准备数据库首先创建一个名为 yii2 的数据库，应用将从这个数据库中读取数据。 然后在数据库中创建一个名为 country 的表并插入简单的数据。可以执行下面的语句： 12345678910111213141516CREATE TABLE `country` ( `code` CHAR(2) NOT NULL PRIMARY KEY, `name` CHAR(52) NOT NULL, `population` INT(11) NOT NULL DEFAULT &apos;0&apos;) ENGINE=InnoDB DEFAULT CHARSET=utf8;INSERT INTO `country` VALUES (&apos;AU&apos;,&apos;Australia&apos;,18886000);INSERT INTO `country` VALUES (&apos;BR&apos;,&apos;Brazil&apos;,170115000);INSERT INTO `country` VALUES (&apos;CA&apos;,&apos;Canada&apos;,1147000);INSERT INTO `country` VALUES (&apos;CN&apos;,&apos;China&apos;,1277558000);INSERT INTO `country` VALUES (&apos;DE&apos;,&apos;Germany&apos;,82164700);INSERT INTO `country` VALUES (&apos;FR&apos;,&apos;France&apos;,59225700);INSERT INTO `country` VALUES (&apos;GB&apos;,&apos;United Kingdom&apos;,59623400);INSERT INTO `country` VALUES (&apos;IN&apos;,&apos;India&apos;,1013662000);INSERT INTO `country` VALUES (&apos;RU&apos;,&apos;Russia&apos;,146934000);INSERT INTO `country` VALUES (&apos;US&apos;,&apos;United States&apos;,278357000); 此时便有了一个名为 yii2 的数据库，在这个数据库中有一个包含三个字段的数据表 country，表中有十行数据。 配置数据库连接开始之前，请确保你已经安装了 PHP PDO 扩展和你所使用的数据库的 PDO 驱动（例如 MySQL 的 pdo_mysql）。 对于使用关系型数据库来讲，这是基本要求。 1php -m // 查看即可 驱动和扩展安装可用后，打开 config/db.php 修改里面的配置参数对应你的数据库配置。 该文件默认包含这些内容： 123456789&lt;?phpreturn [ 'class' =&gt; 'yii\\db\\Connection', 'dsn' =&gt; 'mysql:host=localhost;dbname=yii2', 'username' =&gt; 'root', 'password' =&gt; '', 'charset' =&gt; 'utf8',]; 上面配置的数据库连接可以在应用中通过 Yii::$app-&gt;db 表达式访问。 创建活动记录创建一个继承自活动记录类的类 Country， 把它放在 models/Country.php 文件，去代表和读取 country 表的数据。 123456789&lt;?phpnamespace app\\models;use yii\\db\\ActiveRecord;class A extends ActiveRecord&#123;&#125; 这个 Country 类继承自 yii\\db\\ActiveRecord。你不用在里面写任何代码。 只需要像现在这样，Yii 就能根据类名去猜测对应的数据表名。 使用 Country 类可以很容易地操作 country 表数据，就像这段代码： 1234567891011121314use app\\models\\Country;// 获取 country 表的所有行并以 name 排序$countries = Country::find()-&gt;orderBy('name')-&gt;all();// 获取主键为 “US” 的行$country = Country::findOne('US');// 输出 “United States”echo $country-&gt;name;// 修改 name 为 “U.S.A.” 并在数据库中保存更改$country-&gt;name = 'U.S.A.';$country-&gt;save(); 创建动作新控制器名为 CountryController，并在其中创建一个 index 操作， 如下： 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace app\\controllers;use yii\\web\\Controller;use yii\\data\\Pagination;use app\\models\\Country;class CountryController extends Controller&#123; public function actionIndex() &#123; $query = Country::find(); // 分页 $pagination = new Pagination([ 'defaultPageSize' =&gt; 5, 'totalCount' =&gt; $query-&gt;count(), ]); // 查询 $countries = $query-&gt;orderBy('name') -&gt;offset($pagination-&gt;offset) -&gt;limit($pagination-&gt;limit) -&gt;all(); // 渲染 return $this-&gt;render('index', [ 'countries' =&gt; $countries, 'pagination' =&gt; $pagination, ]); &#125;&#125; 创建视图在 views 目录下先创建一个名为 country 的子目录。 这个目录存储所有由 country 控制器渲染的视图。在 views/country 目录下 创建一个名为 index.php 的视图文件，内容如下： 123456789101112131415&lt;?phpuse yii\\helpers\\Html;use yii\\widgets\\LinkPager;?&gt;&lt;h1&gt;Countries&lt;/h1&gt;&lt;ul&gt;&lt;?php foreach ($countries as $country): ?&gt; &lt;li&gt; &lt;?= Html::encode(\"&#123;$country-&gt;name&#125; (&#123;$country-&gt;code&#125;)\") ?&gt;: &lt;?= $country-&gt;population ?&gt; &lt;/li&gt;&lt;?php endforeach; ?&gt;&lt;/ul&gt;&lt;?= LinkPager::widget(['pagination' =&gt; $pagination]) ?&gt; 试运行浏览器访问下面的 URL 看看能否工作： 1http://hostname/index.php?r=country/index 打印SQL1234567891011// 1、查询结构$record = Article::find()-&gt;joinWith('articleClass');// 2、复制一下查询语句$query = clone $record;// 3、调用createComment()和getSql()方法$sql = $query-&gt;createCommand()-&gt;getSql();// 4、打印出来var_dump($sql);die(); 使用 Gii 生成代码本章节， 你将学到： 在你的应用中开启 Gii 使用 Gii 去生成活动记录类 使用 Gii 去生成数据表操作的增查改删（CRUD）代码 自定义 Gii 生成的代码 开始 GiiGii 是 Yii 中的一个模块。 可以通过配置应用的 modules 属性开启它。通常来讲在 config/web.php 文件中会有以下配置代码： 12345678$config = [ ... ];if (YII_ENV_DEV) &#123; $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = [ 'class' =&gt; 'yii\\gii\\Module', ];&#125; 这段配置表明，如果当前是开发环境， 应用会包含 gii 模块，模块类是 yii\\gii\\Module。 如果你检查应用的入口脚本 web/index.php， 将看到这行代码将 YII_ENV_DEV 设为 true： 1defined('YII_ENV') or define('YII_ENV', 'dev'); 鉴于这行代码的定义，应用处于开发模式下，按照上面的配置会打开 Gii 模块。你可以直接通过 URL 访问 Gii： 1http://hostname/index.php?r=gii 信息： 如果你通过本机以外的机器访问 Gii，请求会被出于安全原因拒绝。 你可以配置 Gii 为其添加允许访问的 IP 地址： 1234'gii' =&gt; [ 'class' =&gt; 'yii\\gii\\Module', 'allowedIPs' =&gt; ['127.0.0.1', '::1', '192.168.0.*', '192.168.178.20'] // 按需调整这里] 生成活动记录类选择 “Model Generator”（点击 Gii 首页的链接）去生成活动记录类。并像这样填写表单： Table Name: country Model Class: Country 然后点击 “Preview” 按钮。你会看到 models/Country.php 被列在将要生成的文件列表中。可以点击文件名预览内容。 如果你已经创建过同样的文件，使用 Gii 会覆写它， 点击文件名旁边的 diff 能查看现有文件与将要 生成的文件的内容区别。 想要覆写已存在文件，选中 “overwrite” 下的复选框然后点击 “Generator”。如果是新文件，只点击 “Generator” 就好。 接下来你会看到一个包含已生成文件的说明页面。如果生成过程中覆写过文件， 还会有一条信息说明代码是重新生成覆盖的。 Generating code using template “/Users/caoxl/WWW/Yii2/vendor/yiisoft/yii2-gii/src/generators/model/default”… overwrote models/Country.php done! 生成 CRUD 代码CRUD 代表增，查，改，删操作，这是绝大多数 Web 站点常用的数据处理方式。选择 Gii 中的 “CRUD Generator” （点击 Gii 首页的链接）去创建 CRUD 功能。本例 “country” 中需要这样填写表单： Model Class: app\\models\\Country Search Model Class: app\\models\\CountrySearch Controller Class: app\\controllers\\CountryController 如果你之前创建过 controllers/CountryController.php 和 views/country/index.php 文件（在指南的使用数据库章节）， 选中 “overwrite” 下的复选框覆写它们（之前的文件没能全部支持 CRUD）。 Generating code using template “/Users/caoxl/WWW/Yii2/vendor/yiisoft/yii2-gii/src/generators/crud/default”… overwrote controllers/CountryController.php generated models/CountrySearch.php generated views/country/_form.php generated views/country/_search.php generated views/country/create.php overwrote views/country/index.php generated views/country/update.php generated views/country/view.php done! 试运行用浏览器访问下面的 URL 查看生成代码的运行： 1http://hostname/index.php?r=country/index 下面列出由 Gii 生成的文件，以便你研习功能和实现， 或修改它们。 控制器：controllers/CountryController.php 模型：models/Country.php 和 models/CountrySearch.php 视图：views/country/*.php 应用结构入口脚本入口脚本主要完成以下工作： 定义全局常量； 注册 Composer 自动加载器； 包含 Yii 类文件； 加载应用配置； 创建一个应用实例并配置; 调用 yii\\base\\Application::run() 来处理请求。 Web 应用12345678910111213141516&lt;?phpdefined('YII_DEBUG') or define('YII_DEBUG', true);defined('YII_ENV') or define('YII_ENV', 'dev');// 注册 Composer 自动加载器require __DIR__ . '/../vendor/autoload.php';// 包含 Yii 类文件require __DIR__ . '/../vendor/yiisoft/yii2/Yii.php';// 加载应用配置$config = require __DIR__ . '/../config/web.php';// 创建、配置、运行一个应用(new yii\\web\\Application($config))-&gt;run(); 当运行 入口脚本 处理请求时， 应用主体会经历以下生命周期: 入口脚本加载应用主体配置数组。 入口脚本创建一个应用主体实例： 调用 preInit() 配置几个高级别应用主体属性， 比如 basePath。 注册 error handler 错误处理方法。 配置应用主体属性。 调用 init() 初始化，该函数会调用 bootstrap() 运行引导启动组件。 入口脚本调用 yii\\base\\Application::run() 运行应用主体: 触发 EVENT_BEFORE_REQUEST 事件。 处理请求：解析请求 路由 和相关参数； 创建路由指定的模块、控制器和动作对应的类，并运行动作。 触发 EVENT_AFTER_REQUEST 事件。 发送响应到终端用户。 入口脚本接收应用主体传来的退出状态并完成请求的处理。 过滤器过滤器是 控制器动作 执行之前或之后执行的对象。 使用过滤器过滤器本质上是一类特殊的 行为， 所以使用过滤器和 使用行为一样。 可以在控制器类中覆盖它的 behaviors() 方法来声明过滤器，如下所示： 12345678910111213public function behaviors()&#123; return [ [ 'class' =&gt; 'yii\\filters\\HttpCache', 'only' =&gt; ['index', 'view'], 'lastModified' =&gt; function ($action, $params) &#123; $q = new \\yii\\db\\Query(); return $q-&gt;from('user')-&gt;max('updated_at'); &#125;, ], ];&#125; 当一个动作有多个过滤器时，根据以下规则先后执行： 预过滤 按顺序执行应用主体中 behaviors() 列出的过滤器。 按顺序执行模块中 behaviors() 列出的过滤器。 按顺序执行控制器中 behaviors() 列出的过滤器。 如果任意过滤器终止动作执行， 后面的过滤器（包括预过滤和后过滤）不再执行。 成功通过预过滤后执行动作。 后过滤 倒序执行控制器中 behaviors() 列出的过滤器。 倒序执行模块中 behaviors() 列出的过滤器。 倒序执行应用主体中 behaviors() 列出的过滤器。 创建过滤器12345678910111213141516171819202122namespace app\\components;use Yii;use yii\\base\\ActionFilter;class ActionTimeFilter extends ActionFilter&#123; private $_startTime; public function beforeAction($action) &#123; $this-&gt;_startTime = microtime(true); return parent::beforeAction($action); &#125; public function afterAction($action, $result) &#123; $time = microtime(true) - $this-&gt;_startTime; Yii::debug(\"Action '&#123;$action-&gt;uniqueId&#125;' spent $time second.\"); return parent::afterAction($action, $result); &#125;&#125; 扩展核心扩展 yiisoft/yii2-apidoc： 提供了一个可扩展的、高效的 API 文档生成器。核心框架的 API 文档也是用它生成的。 yiisoft/yii2-authclient： 提供了一套常用的认证客户端，例如 Facebook OAuth2 客户端、GitHub OAuth2 客户端。 yiisoft/yii2-bootstrap： 提供了一套挂件，封装了 Bootstrap 的组件和插件。 yiisoft/yii2-codeception： 提供了基于 Codeception 的测试支持。 yiisoft/yii2-debug： 提供了对 Yii 应用的调试支持。当使用该扩展是， 在每个页面的底部将显示一个调试工具条。 该扩展还提供了一个独立的页面，以显示更详细的调试信息。 yiisoft/yii2-elasticsearch： 提供对 Elasticsearch 的使用支持。它包含基本的查询/搜索支持， 并实现了 Active Record 模式让你可以将活动记录 存储在 Elasticsearch 中。 yiisoft/yii2-faker： 提供了使用 Faker 的支持，为你生成模拟数据。 yiisoft/yii2-gii： 提供了一个基于页面的代码生成器，具有高可扩展性，并能用来快速生成模型、 表单、模块、CRUD 等。 yiisoft/yii2-httpclient： 提供 HTTP 客户端。 yiisoft/yii2-imagine： 提供了基于 Imagine 的常用图像处理功能。 yiisoft/yii2-jui： 提供了一套封装 JQuery UI 的挂件以及它们的交互。 yiisoft/yii2-mongodb： 提供了对 MongoDB 的使用支持。它包含基本 的查询、活动记录、数据迁移、缓存、代码生成等特性。 yiisoft/yii2-queue： 通过队列异步提供运行任务的支持。 它支持基于 DB，Redis，RabbitMQ，AMQP，Beanstalk 和 Gearman 的队列。 yiisoft/yii2-redis： 提供了对 redis 的使用支持。它包含基本的 查询、活动记录、缓存等特性。 yiisoft/yii2-shell： 提供基于 psysh 的交互式 shell。 yiisoft/yii2-smarty： 提供了一个基于 Smarty 的模板引擎。 yiisoft/yii2-sphinx： 提供了对 Sphinx 的使用支持。它包含基本的 查询、活动记录、代码生成等特性。 yiisoft/yii2-swiftmailer： 提供了基于 swiftmailer 的邮件发送功能。 yiisoft/yii2-twig： 提供了一个基于 Twig 的模板引擎。 以下官方扩展适用于 Yii 2.1 及以上版本。 您不需要为 Yii 2.0 安装它们，因为它们包含在核心框架中。 yiisoft/yii2-captcha： 提供 CAPTCHA。 yiisoft/yii2-jquery： 为 jQuery 提供支持。 yiisoft/yii2-maskedinput： 提供基于 jQuery Input Mask plugin 的格式化输入小部件。 yiisoft/yii2-mssql： 提供对使用 MSSQL 的支持。 yiisoft/yii2-oracle： 提供对使用 Oracle 的支持。 yiisoft/yii2-rest： 提供对 REST API 的支持。 请求处理请求请求参数要获取请求参数，你可以调用 request 组件的 get() 方法和 post() 方法。 他们分别返回 $_GET 和 $_POST 的值。例如， 12345678910111213141516171819$request = Yii::$app-&gt;request;$get = $request-&gt;get(); // 等价于: $get = $_GET;$id = $request-&gt;get('id'); // 等价于: $id = isset($_GET['id']) ? $_GET['id'] : null;$id = $request-&gt;get('id', 1); // 等价于: $id = isset($_GET['id']) ? $_GET['id'] : 1;$post = $request-&gt;post(); // 等价于: $post = $_POST;$name = $request-&gt;post('name'); // 等价于: $name = isset($_POST['name']) ? $_POST['name'] : null;$name = $request-&gt;post('name', ''); // 等价于: $name = isset($_POST['name']) ? $_POST['name'] : ''; 请求方法你可以通过 Yii::$app-&gt;request-&gt;method 表达式来获取当前请求使用的HTTP方法。 123456$request = Yii::$app-&gt;request;if ($request-&gt;isAjax) &#123; /* 该请求是一个 AJAX 请求 */ &#125;if ($request-&gt;isGet) &#123; /* 请求方法是 GET */ &#125;if ($request-&gt;isPost) &#123; /* 请求方法是 POST */ &#125;if ($request-&gt;isPut) &#123; /* 请求方法是 PUT */ &#125; 请求URLs假设被请求的 URL 是 http://example.com/admin/index.php/product?id=100， 你可以像下面描述的那样获取 URL 的各个部分： url：返回 /admin/index.php/product?id=100, 此 URL 不包括主机信息部分。 absoluteUrl：返回 http://example.com/admin/index.php/product?id=100, 包含host info的整个URL。 hostInfo：返回 http://example.com, 只有主机信息部分。 pathInfo：返回 /product， 这个是入口脚本之后，问号之前（查询字符串）的部分。 queryString：返回 id=100，问号之后的部分。 baseUrl：返回 /admin，主机信息之后， 入口脚本之前的部分。 scriptUrl：返回 /admin/index.php，没有路径信息和查询字符串部分。 serverName：返回 example.com，URL 中的主机名。 serverPort：返回 80，这是 web 服务中使用的端口。 响应状态码1Yii::$app-&gt;response-&gt;statusCode = 200; 尽管如此，大多数情况下不需要明确设置状态码， 因为 yii\\web\\Response::$statusCode 状态码默认为 200， 如果需要指定请求失败，可抛出对应的 HTTP 异常，如下所示： 1throw new \\yii\\web\\NotFoundHttpException; HTTP 头部可在 response 组件中操控 header collection 来发送 HTTP 头部信息， 例如： 12345678910$headers = Yii::$app-&gt;response-&gt;headers;// 增加一个 Pragma 头，已存在的Pragma 头不会被覆盖。$headers-&gt;add('Pragma', 'no-cache');// 设置一个Pragma 头. 任何已存在的Pragma 头都会被丢弃$headers-&gt;set('Pragma', 'no-cache');// 删除Pragma 头并返回删除的Pragma 头的值到数组$values = $headers-&gt;remove('Pragma'); 响应主体如果已有格式化好的主体字符串，可赋值到响应的 yii\\web\\Response::$content 属性， 例如： 1Yii::$app-&gt;response-&gt;content = 'hello world!'; 发送响应在 yii\\web\\Response::send() 方法调用前响应中的内容不会发送给用户， 该方法默认在 yii\\base\\Application::run() 结尾自动调用，尽管如此，可以明确调用该方法强制立即发送响应。 yii\\web\\Response::send() 方法使用以下步骤来发送响应： 触发 yii\\web\\Response::EVENT_BEFORE_SEND 事件。 调用 yii\\web\\Response::prepare() 来格式化 response data 为 response content。 触发 yii\\web\\Response::EVENT_AFTER_PREPARE 事件。 调用 yii\\web\\Response::sendHeaders() 来发送注册的HTTP头 调用 yii\\web\\Response::sendContent() 来发送响应主体内容 触发 yii\\web\\Response::EVENT_AFTER_SEND 事件。 Sessions 和 CookiesSessions开启和关闭 Sessions12345678910111213$session = Yii::$app-&gt;session;// 检查session是否开启 if ($session-&gt;isActive) ...// 开启session$session-&gt;open();// 关闭session$session-&gt;close();// 销毁session中所有已注册的数据$session-&gt;destroy(); 访问 Session 数据12345678910111213141516171819202122232425$session = Yii::$app-&gt;session;// 获取session中的变量值，以下用法是相同的：$language = $session-&gt;get('language');$language = $session['language'];$language = isset($_SESSION['language']) ? $_SESSION['language'] : null;// 设置一个session变量，以下用法是相同的：$session-&gt;set('language', 'en-US');$session['language'] = 'en-US';$_SESSION['language'] = 'en-US';// 删除一个session变量，以下用法是相同的：$session-&gt;remove('language');unset($session['language']);unset($_SESSION['language']);// 检查session变量是否已存在，以下用法是相同的：if ($session-&gt;has('language')) ...if (isset($session['language'])) ...if (isset($_SESSION['language'])) ...// 遍历所有session变量，以下用法是相同的：foreach ($session as $name =&gt; $value) ...foreach ($_SESSION as $name =&gt; $value) ... Cookies读取 Cookies12345678910111213141516171819// 从 \"request\" 组件中获取 cookie 集合(yii\\web\\CookieCollection)$cookies = Yii::$app-&gt;request-&gt;cookies;// 获取名为 \"language\" cookie 的值，如果不存在，返回默认值 \"en\"$language = $cookies-&gt;getValue('language', 'en');// 另一种方式获取名为 \"language\" cookie 的值if (($cookie = $cookies-&gt;get('language')) !== null) &#123; $language = $cookie-&gt;value;&#125;// 可将 $cookies 当作数组使用if (isset($cookies['language'])) &#123; $language = $cookies['language']-&gt;value;&#125;// 判断是否存在名为 \"language\" 的 cookieif ($cookies-&gt;has('language')) ...if (isset($cookies['language'])) ... 发送 Cookies12345678910111213// 从 \"response\" 组件中获取 cookie 集合(yii\\web\\CookieCollection)$cookies = Yii::$app-&gt;response-&gt;cookies;// 在要发送的响应中添加一个新的 cookie$cookies-&gt;add(new \\yii\\web\\Cookie([ 'name' =&gt; 'language', 'value' =&gt; 'zh-CN',]));// 删除一个 cookie$cookies-&gt;remove('language');// 等同于以下删除代码unset($cookies['language']); 错误处理Yii 内置了一个 error handler 错误处理器，它使错误处理更方便， Yii错误处理器做以下工作来提升错误处理效果 使用错误处理器error handler 注册成一个名称为errorHandler应用组件， 可以在应用配置中配置它类似如下： 1234567return [ 'components' =&gt; [ 'errorHandler' =&gt; [ 'maxSourceLines' =&gt; 20, ], ],]; 日志日志消息记录日志消息就跟调用下面的日志方法一样简单： Yii::trace()：记录一条消息去跟踪一段代码是怎样运行的。这主要在开发的时候使用。 Yii::info()：记录一条消息来传达一些有用的信息。 Yii::warning()：记录一个警告消息用来指示一些已经发生的意外。 Yii::error()：记录一个致命的错误，这个错误应该尽快被检查。 Restful web 服务助手类Array 助手(ArrayHelper)获取值（Getting Values）1$value = ArrayHelper::getValue($array, 'foo.bar.name'); 设定值（Setting values）123456789$array = [ 'key' =&gt; [ 'in' =&gt; ['k' =&gt; 'value'] ]];ArrayHelper::setValue($array, 'key.in', ['arr' =&gt; 'val']);// 在 `$array` 中写入值的路径可以被指定为一个数组ArrayHelper::setValue($array, ['key', 'in'], ['arr' =&gt; 'val']); 检查键名的存在（Checking Existence of Keys）1234567891011$data1 = [ 'userName' =&gt; 'Alex',];$data2 = [ 'username' =&gt; 'Carsten',];if (!ArrayHelper::keyExists('username', $data1, false) || !ArrayHelper::keyExists('username', $data2, false)) &#123; echo \"Please provide username.\";&#125; 多维排序（Multidimensional Sorting）123456$data = [ ['age' =&gt; 30, 'name' =&gt; 'Alexander'], ['age' =&gt; 30, 'name' =&gt; 'Brian'], ['age' =&gt; 19, 'name' =&gt; 'Barney'],];ArrayHelper::multisort($data, ['age', 'name'], [SORT_ASC, SORT_DESC]); 对象转换为数组（Converting Objects to Arrays）12345678910111213$posts = Post::find()-&gt;limit(10)-&gt;all();$data = ArrayHelper::toArray($posts, [ 'app\\models\\Post' =&gt; [ 'id', 'title', // the key name in array result =&gt; property name 'createTime' =&gt; 'created_at', // the key name in array result =&gt; anonymous function 'length' =&gt; function ($post) &#123; return strlen($post-&gt;content); &#125;, ],]); Html 助手(Html)生成标签（Generating Tags）1&lt;?= Html::tag('p', Html::encode($user-&gt;name), ['class' =&gt; 'username']) ?&gt; 生成 CSS 类和样式（Forming CSS Classes and Styles）12345678910$options = ['class' =&gt; 'btn btn-default'];if ($type === 'success') &#123; Html::removeCssClass($options, 'btn-default'); Html::addCssClass($options, 'btn-success');&#125;echo Html::tag('div', 'Pwede na', $options);// in case of $type of 'success' it will render 创建表单（Creating Forms）1&lt;?= Html::beginForm(['order/update', 'id' =&gt; $id], 'post', ['enctype' =&gt; 'multipart/form-data']) ?&gt; Url 助手(Url)获得通用 URL（Getting Common URLs）有两种获取通用 URLS 的方法 ：当前请求的 home URL 和 base URL 。 为了获取 home URL ，使用如下代码： 123$relativeHomeUrl = Url::home();$absoluteHomeUrl = Url::home(true);$httpsAbsoluteHomeUrl = Url::home('https'); 如下代码可以获得当前请求的 base URL： 123$relativeBaseUrl = Url::base();$absoluteBaseUrl = Url::base(true);$httpsAbsoluteBaseUrl = Url::base('https'); 创建 URLs（Creating URLs）1$url = Url::toRoute(['product/view', 'id' =&gt; 42]); 记住 URLs（Remember URLs）12345678// 记住当前 URL Url::remember();// 记住指定的 URL。参数格式请参阅 Url::to()。Url::remember(['product/view', 'id' =&gt; 42]);// 记住用给定名称指定的 URLUrl::remember(['product/view', 'id' =&gt; 42], 'product'); 检查相对 URLs（Checking Relative URLs）1$isRelative = Url::isRelative('test/it'); 参考 Yii 2.0 权威指南","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Yii2","slug":"Yii2","permalink":"http://blog.caoxl.com/tags/Yii2/"}]},{"title":"面试/笔试实战 II","slug":"Learning-From-Interview-II","date":"2019-12-11T10:17:37.000Z","updated":"2019-12-23T03:34:41.000Z","comments":true,"path":"2019/12/11/Learning-From-Interview-II/","link":"","permalink":"http://blog.caoxl.com/2019/12/11/Learning-From-Interview-II/","excerpt":"从面试中学习，从面试中成长。","text":"从面试中学习，从面试中成长。 禁用COOKIE后SESSION还能用吗 ? 客户端禁用cookie采用url重写的方式 ，也就是将sessionid写在url上， 抓取远程图片到本地，你会用什么函数 ?1file_get_contents($url); 什么是CGI? 什么是FastCGI? php-fpm,FastCGI,Nginx之间是什么关系? CGI: 公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范 FastCGI: 快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。 php-fpm: PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)是一个PHPFastCGI管理器 关系: 用户的请求通过WEB服务器（如Nginx）转发给FastCGI进程，FastCGI进程再调用应用程序进行处理（如PHP解析器），应用程序的处理结果如html返回给FastCGI，FastCGI返回给Nginx进行输出。 简述POST和GET传输的最大容量分别是多少? GET get 是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。很多文章都说GET方式提交的数据最多只能是1024字节，而 实际上，URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制 是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统。即 如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。 POST post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。因为我们一般 post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较 大的文件到服务器时候，可能上传不上去，以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.conf的post_max_size这个值。 列出能够使HTML和PHP分离开使用的模板 有Smarty, Dwoo, tinyButStrong, phemplate, XTemplate等模板引擎。 请写一个函数，实现以下功能： 字符串”open_door”转换成”OpenDoor”.12345678910111213&lt;?phpfunction convert($string = 'open_door') &#123; $array = explode('_', $string); array_walk($array, function (&amp;$v) &#123; $v = ucwords($v); &#125;); $string = implode('', $array); var_dump($string);&#125;convert(); echo(), print(), print_r()的区别? echo()是语言结构(language construct)，而并不是真正的函数，没有返回值。 pirnt()实际上也不是函数（而是语言结构），所以可以不用圆括号包围参数列表。 print_r()可以把字符串和数字简单地打印出来，而数组则以括起来的键和值得列表形式显示，并以Array开头。 printf()函数返回一个格式化后的字符串。 isset, empty(), is_null的区别? isset 判断变量是否已存在，如果变量存在则返回 TRUE，否则返回 FALSE。 empty 判断变量是否为空，如果变量是非空 或非零 的值，则 empty() 返回 FALSE。 is_null 判断变量是否为NULL FILE表示什么意思? __FILE__ 文件的完整路径和文件名。 __LINE__ 文件中的当前行号。 __DIR__ 文件所在的目录。 __FUNCTION__ 函数名称（PHP 4.3.0 新加）。 __CLASS__ 类的名称（PHP 4.3.0 新加）。 __TRAIT__ Trait 的名字（PHP 5.4.0 新加） __METHOD__ 类的方法名（PHP 5.0.0 新加） __NAMESPACE__ 当前命名空间的名称（区分大小写）。 如何获取客户端的IP地址?1234567891011121314151617181920212223public function getIp()&#123; if ($_SERVER[\"HTTP_X_FORWARDED_FOR\"] ?? false) &#123; $ip = $_SERVER[\"HTTP_X_FORWARDED_FOR\"]; $ips = explode(',', $ip);//阿里cdn $ip = $ips[0]; &#125; elseif ($_SERVER[\"HTTP_CDN_SRC_IP\"] ?? false) &#123; $ip = $_SERVER[\"HTTP_CDN_SRC_IP\"]; &#125; elseif (getenv('HTTP_CLIENT_IP')) &#123; $ip = getenv('HTTP_CLIENT_IP'); &#125; elseif (getenv('HTTP_X_FORWARDED')) &#123; $ip = getenv('HTTP_X_FORWARDED'); &#125; elseif (getenv('HTTP_FORWARDED_FOR')) &#123; $ip = getenv('HTTP_FORWARDED_FOR'); &#125; elseif (getenv('HTTP_FORWARDED')) &#123; $ip = getenv('HTTP_FORWARDED'); &#125; else &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; $ip = str_replace(array('::ffff:', '[', ']'), array('', '', ''), $ip); return $ip;&#125; 写出使用header函数跳转页面的语句1header(\"Location:http://blog.caoxl.com\"); 写出将一个数组里的空值去掉的函数?1array_filter(); 什么事CSRF攻击? XSS攻击? 如何防范?CSRF攻击 跨站请求伪造（英語：Cross-site request forgery），也被称为one-click attack 或者 session riding，通常缩写为 CSRF 或者XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 防范: Cookie Hashing(所有表单都包含同一个伪随机值)： 验证码 One-Time Tokens(不同的表单包含一个不同的伪随机值) 请求时附带验证信息，比如验证码或者token XSS攻击 人们经常将跨站脚本攻击（Cross Site Scripting）缩写为CSS，但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为XSS。XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。 这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。 防范: Content Security Policy(CSP) 输入内容长度控制 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 简单描述MySQL中，索引，主键，唯一索引，联合索引的区别，对数据的性能有什么影响? 索引的遵循原则: 1、最左侧原则，表的最左侧的一列，往往数据不会发生改变，不影响其他列的数据； 2、命名短小原则，索引命名过长会使索引文件变大，损耗内存。 普通索引（由关键字KEY或INDEX定义得到索引）：加快数据的查询速度 唯一索引（由关键字UNIQUE把它定义为唯一索引）：保证数据记录的唯一性 主键：一种特殊的唯一索引，在一张表中只能定义一个主键索引，用来标识唯一一条数据，用PRIMARY KEY创建。 联合索引：索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。 索引可以极大的提高查询访问速度，但是会降低插入，删除，更新表的速度，因为在执行写操作的时候还要操作索引文件。 简述在MySQL数据库中MyISAM和InnoDB的区别? 构成上，MyISAM的表在磁盘中有三个文件组成，分别是表定义文件(.frm)、数据文件(.MYD)、索引文件(.MYI)，而InnoDB的表由表定义文件(.frm)、表空间数据和日志文件组成。 安全方面，MyISAM强调的是性能，其查询查询效率较高，但不支持事务和外键等安全性方面的功能，而InnoDB支持事务和外键等高级功能，查询效率稍低。 对锁的支持，MyISAM支持表锁，而InnoDB支持行锁。 Memcache和Redis的读写性能如何? 两者优缺点? 读写性能 memcache更加快速，在读取性能上比 Redis 快，缺点是仅支持字符串。Redis支持丰富的数据结构类型，字符串，散列（哈希），集合，有序集合，还支持订阅发布，地理位置等等。实际运用中可以redis，memcache结合，memcache可作为session存储的方式，session都是KV类型键值对 优缺点 Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。 请写一个函数验证电子邮件的格式是否正确?12345678910111213141516&lt;?php$email = 'code08091@163.com';// 方法1: 原生自带验证$is_email = filter_var($email, FILTER_VALIDATE_EMAIL);var_dump($is_email); // true则返回email, false则返回falseecho \"&lt;hr&gt;\";// 方法2: 正则验证$regex = '/^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$/';$is_email = preg_match($regex, $email);var_dump($is_email); 封装一下 123456789101112function checkEmail($email) &#123; $is_email = filter_var($email, FILTER_VALIDATE_EMAIL); if ($is_email) &#123; $regex = '/^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$/'; $is_email = preg_match($regex, $email); return $is_email; &#125;&#125;var_dump(checkEmail('code08091@163.com')); 使用正则表达式去除其中的所有JS脚本?写一个函数，能够遍历一个文件夹下的所有文件和子文件夹。1234567891011121314151617181920212223&lt;?phpfunction scan_dir($dir)&#123; $files = array(); if ( $handle = opendir($dir) ) &#123; while ( ($file = readdir($handle)) !== false ) &#123; if ( $file != \"..\" &amp;&amp; $file != \".\" ) &#123; if ( is_dir($dir . \"/\" . $file) ) &#123; $files[$file] = scandir($dir . \"/\" . $file); &#125;else &#123; $files[] = $file; &#125; &#125; &#125; closedir($handle); return $files; &#125;&#125;$files = scan_dir('F:\\Code\\Hexo');print_r($files); 函数内部static和global关键字的作用 static 是静态变量,在局部函数中存在且只初始化一次,使用过后再次使用会使用上次执行的结果; 作为计数，程序内部缓存，单例模式中都有用到。global 关键字,引用全局变量，wordpress中大量用到，如面向过程开发。static 静态方法,是类的成员方法,但不需要实例化类可直接使用$GLOBAL 在函数内使用具有全局作用域的变量,如$GLOBAL[&#39;a&#39;] 子类重写父类的Protected方法有什么限制? 或者说有什么要遵守的规则?用例子说明，以 Laravel 框架中的控制器作为说明 final 修饰的类方法不可被子类重写 PHP是否重写父类方法只会根据方法名是否一致判断 (5.3以后重写父类方法参数个数必须一致) 重写时访问级别只可以等于或者宽松于父类 不可提升访问级别 PHP文件末尾是否应该加 ? &gt;结束符号， 为什么? 不应该 主要防止 include，require 引用文件，把文件末尾可能的回车和空格等字符引用进来。 还有一些函数比如 session_start() 必须在没有任何输出之前调用，就会造成不是期望的结果。 PHP文件的编码不包含BOM的 UTF8，这也是PSR-2中的规范，纯PHP代码文件必须省略最后的 ?&gt; 结束标签。 PHP开源框架CI，ThinkPHP，Laravel的优缺点以及选型依据。 CI非常轻量级，是一个简单的MVC框架，性能也很快。 ThinkPHP国内使用比较多，优点是文档非常多，各种问题解决方案比较多，缺点是代码不够规范，理念落后。 Laravel 是一个现代化的PHP开发框架，代码优雅，使用 composer 方式扩展功能，社区活跃，缺点是比较重，比较适合做后台管理或者应用型WEB系统。 Ajax中如何执行跨域访问? 同子域的情况如何处理? 不同子域的情况如何处理? 什么是跨域？狭义的理解跨域是指受到浏览器同源策略限制的一类请求，通常我们说的跨域就是指的这一类请求。当协议、域名（包含子域名）、端口号中任意一个不相同时，都属于不同域。不同域之间相互请求资源，就会受到浏览器的同源策略限制。 CORS script标签解决跨域 jsonp解决跨域 文件上传时需要在form中加入enctype=multipart/form-data的目的是什么? 使用application/x-www,form-urlencoded不能成功的原因是?首先知道enctype这个属性管理的是表单的MIME编码。共有三个值可选： application/x-www-form-urlencoded multipart/form-data text/plain 其中application/x-www-form-urlencoded是默认值，作用是设置表单传输的编码。 表单中enctype=&quot;multipart/form-data&quot;的意思，是设置表单的MIME编码。默认情况，这个编码格式是application/x-www-form-urlencoded，不能用于文件上传；只有使用了multipart/form-data，才能完整的传递文件数据 设计一个名为car的类，使其拥有color属性、getColor与setColor方法12345678910111213141516171819202122&lt;?phpclass Car&#123; public $color; /** * @return mixed */ public function getColor() &#123; return $this-&gt;color; &#125; /** * @param mixed $color */ public function setColor($color) &#123; $this-&gt;color = $color; &#125;&#125; 请写出3种多服务器共享Session的方案 文件方式 这种方式，将文件作为一个map，当新增一个数据的时候，就在文件中增加类似这样的一条数据 cache方式 memcache可以做分布式，如果没有这功能，他也不能用来做session同步。他可以把web服务器中的内存组合起来，成为一个”内存池”，不管是哪个服务器产生的sessoin都可以放到这个”内存池”中，其他的都可以使用。redis与memcache一样，都是将数据放在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 cookie方式 把用户访问页面产生的session放到cookie里面，就是以cookie为中转站。 通过数据库mysql共享session 采用一台专门的mysql服务器来存储所有的session信息。 通过NFS共享Session 选择一台公共的NFS服务器（Network File Server）做共享服务器，所有的Web服务器登陆的时候把session数据写到这台服务器上，那么所有的session数据其实都是保存在这台NFS服务器上的，不论用户访问哪台Web服务器，都要来这台服务器获取session数据，那么就能够实现共享session数据了。 假设有10道题，如何从中随机取出5道题? rand(), random_bytes(), mt_rand() 谈谈抢红包这种互动活动实现的技术难点及解决方案 高并发,大流量,减少库存问题,锁问题,前后端缓存问题,队列问题 如何保证同时向同一个文件内写入内容的完整性以及准确性 LOCK_EX (独占锁定) process_1.php 1234567891011121314151617181920&lt;?php// 脚本开始$start_time = microtime();$filename = './process_data.txt';$fp = fopen($filename, 'a+');for ($i = 0; $i &lt; 100; $i++) &#123; fwrite($fp, \"process_1:\" . $i . \"\\r\\n\"); usleep(100000);&#125;fclose($fp);// 脚本结束$end_time = microtime();echo \"Process_1 Done for\" . ($end_time - $start_time) . 'seconds'; process_2.php 1234567891011121314151617181920&lt;?php// 脚本开始$start_time = microtime();$filename = './process_data.txt';$fp = fopen($filename, 'a+');for ($i = 0; $i &lt; 100; $i++) &#123; fwrite($fp, \"process_2:\" . $i . \"\\r\\n\"); usleep(100000);&#125;fclose($fp);// 脚本结束$end_time = microtime();echo \"Process_2 Done for \" . ($end_time - $start_time) . ' seconds'; 多次同时执行，虽然都写了100行，但是事务1和事务2的数据交错写入，这并不是我们想要的结果。我们要的是事务完整的执行，此时我们需要有个机制 去保证在第一个事务执行完后再执行第二个。在PHP中，flock函数完成了这一使命。在事物1和事务2的循环前面都加上： flock($fp, LOCK_EX); 就能 满足我们的需求，将两个事务串行。 1234567891011121314151617181920212223&lt;?php// 脚本开始$start_time = microtime();$filename = './process_data.txt';$fp = fopen($filename, 'a+');// 独占锁定flock($fp, LOCK_EX);for ($i = 0; $i &lt; 100; $i++) &#123; fwrite($fp, \"process_1:\" . $i . \"\\r\\n\"); usleep(100000);&#125;fclose($fp);// 脚本结束$end_time = microtime();echo \"Process_1 Done for \" . ($end_time - $start_time) . ' seconds'; 在PHP的fopen函数的实现中，如果我们使用a参数在文件的尾部追加内容，其调用open函数中oflag参数为 O_CREAT|O_APPEND，即我们使用追加操作 不用担心并发追加写入的问题 请简述cookie与session的区别和联系 区别 cookie保存在客户端，未设置存储时间的cookie为会话cookie保存在浏览器的进程开辟的内存中，当浏览器关闭后会话cookie也会被删除；设置了存储时间的cookie保存在用户设备的磁盘中直到过期。session保存在服务器端，存储在IIS的进程开辟的内存中。 联系 当服务器端生成一个session时就会向客户端发送一个cookie保存在客户端，这个cookie保存的是session的sessionId。这样才能保证客户端发起请求后客户端已经登录的用户能够与服务器端成千上万的session中准确匹配到已经保存了该用户信息的session，同时也能够确保不同页面之间传值时的正确匹配。","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://blog.caoxl.com/tags/面试题/"},{"name":"笔试题","slug":"笔试题","permalink":"http://blog.caoxl.com/tags/笔试题/"}]},{"title":"PHP面试/笔试题杂记 VII","slug":"Interview-Questions-Notes-VII","date":"2019-11-25T07:55:59.000Z","updated":"2019-12-02T02:57:01.000Z","comments":true,"path":"2019/11/25/Interview-Questions-Notes-VII/","link":"","permalink":"http://blog.caoxl.com/2019/11/25/Interview-Questions-Notes-VII/","excerpt":"一个PHP高级工程师 需要具备哪些知识?","text":"一个PHP高级工程师 需要具备哪些知识? 准备 自我介绍: 说上家公司负责的项目或者浓缩简历。 简历项目经验层次 利用什么技术 实现了什么功能 遇到了什么问题 达到了什么结果 期望薪资 应用型的问题：要记得站高看远、架构分层 及管理经验及自身对项目管理的理解 知识点列表PHP 代码解释过程(大多的非编译语言) lexical 词法分析, 输入为源代码, 输出为token 语法分析工具为文法(LALR), 输出为表达式, 7.0为AST, 涉及 注释 分号 &amp; 分隔符 变量 常量 操作数 类型检查、关键字处理、导入, 输出为中间代码.工具为选定的编译器优化工具 中间代码生成(Opcodes) 机器码生成 (编译语言) Session共享配置 PHPUnit用法 Cookie购物车和Session购物车的实现 弱类型实现 zval(不仅是变量名) &amp; zend_val 变量值 代码规范 自动化: sonarquebe+jenkins 单元测试 PHP进程间如何通信 信号量(消息同步|互斥) 信号(信号触发事件)(pcntl_signal, pcntl_wait*) 消息队列(msg_*) 管道(pipe) socket | unix_*.sock 共享内存(shm_,shmop_) PHP并发模型 PHP执行流程 变量底层存储结构 常用的数组函数(列出10个) array_combine(前面数组作为其键，后面数组做为其值) array_merge(合并两个数组，后面覆盖前面，但数字索引会重新索引，不会覆盖) … PHP垃圾回收机制(gc) zend.enable_gc (php.ini) gc_enable() (function) 引入计数(zval指向zend_value个数为0时) + 写时拷贝 (copy on write) 循环引用问题 (array、object引用自身成员), 垃圾回收器将收集于一个buffer(_zend_gc_global -&gt; gc_root_buffer) 后启动垃圾鉴定程序 把Session放入Redis里面还会触发类似文件的state session session.gc_probability (default 1) session.gc_divisor (default 100) session.gc_maxlifetime (单位秒) session.cookie_lifetime (单位秒, 0表示直到关闭浏览器) session.save_path session.write_close (显示关闭, 后期使用需要显示开启) 内存模型 整型、浮点、bool、NULL、内部字符串、不可变数组都是通过zval直接保存,不会用到引用计数 string、array都会使用引入计数(支持复制cow), object、resource本身可以理解为引用 fpm三种配置及场景 dynamic pm.start_servers pm.max_children pm.max_spare_servers pm.min_spare_servers static pm.max_children ondaemon pm.process_idle_timeout 数组底层 如何保证有序: 又加了一层映射表 (与bucket大小相同) 如何解决hash冲突: 拉链法(头插) 扩容: 逻辑删除 (考虑unset内存情况, 是否需要重建索引) MySQL 索引 物理存储 聚簇索引 非聚簇索引 数据结构 B + 树 hash fulltext R-tree 逻辑角度 唯一索引 unique 普通索引 index 主键索引 primary key 全文索引 full index (myisam) 复合索引 (最左前缀原则) 类似 where a and b and c a b c 问题 联合索引(a,b,c) 能够正确使用索引的有 (a=1), (a=1 and b=1), (a=1 and b=1 and c=1) (b=1 and c =1) 引擎类型 myisam innodb 区别 myisam采用非聚簇索引, innodb采用聚簇索引 myisam索引myi与数据myd文件分离, 索引文件仅保存数据记录指针地址 myisam的主索引与辅助索引在结构上没区别, 而innodb不一样: innodb的所有辅助索引都引用主索引为data域 innodb支持事务, 行级锁, myisam不行 innodb必须有主键, 而myisam可以没有 事务 原子性 atomicity 一致性 consistency 隔离性 isolation 持久性 durability 分表数量级 单表在500w左右, 性能最佳, BTREE索引树在3-5之间 隔离级别 事务的隔离性是数据库处理数据的基础之一，隔离级别是提供给用户在性能和可靠性做除选择和权衡的配置项目，以下四种情况都有一个前提（在同一个事务中） read_uncommited: 未提交读(脏读) read_commit: 已提交读 (不可重复读) repeatable_read: 可重复读 serialize: 可串行化 索引机制(算法) hash b+tree b-tree(不要念成b减tree，-只是个符号) 锁 种类 optimistic lock 乐观锁 特点: 不会真的死锁 pessimistic lock 悲观锁 为了保证事务的隔离性, 就需要一致性锁定读.读的时候要加锁，防止其他事务再次更改，修改的时候也要加锁，其他事务无法读取。主要就是依靠数据库的锁机制来实现，同时缺点很明显，就是会带来性能的开销，并发的减少 innodb的MVCC(Multi-Version Concurrency Control) 多版本并发控制, 适用于行锁的、事务性的数据库模型 适用于innodb的rc和rr级别, 因为可串行化涉及到锁表 实现思想是在每行增加一个create_verison和delete_version字段 update 是插入一个新行，先保存当前版本号到旧行的delete_version,且新建行的new_create_version也就是delete_version delete操作就是直接标记delete_version insert的时候，就是保存至create_version select的时候可以这样 读delete_version为空的 大于当前事务版本号的 创建版本号 &lt;= 当前事务版本号的 粒度划分 行锁 表锁 意向锁 intention lock (表级锁) 场景：A对表中一行进行修改，B对整个表修改。如果没有以下的两个锁，B将对全表扫描是否被锁定。反之，A可以对某行添加意向互斥锁（表级），然后再添加互斥锁（行级），然后B只需要等待意向互斥锁释放） 意向共享锁 意向互斥锁 共享锁 shard lock 读锁(行锁) 排它锁 exclusive lock 写锁(行锁) 关于innodb必须要知道的 可以通过 SELECT \\* FROM products WHERE id=&#39;3&#39; FOR UPDATE 进行锁，但是必须在事务中 上述语句必须是命中索引才会行锁，否则是 table lock 锁的算法 record lock：加到索引记录上的锁，如果通过where条件上锁，而不知道具体哪行，这样会锁定整个表 gap lock：间隙锁某个区间的锁定，对索引记录中的一段连续区域的锁。 next-key lock：行锁和GAP（间隙锁）的合并，next-key锁是解决RR级别中 幻读问题的主要方案。可以搜索关键字 快照读（snapshot read）和当前读（current read）去了解 分库分表 主从复制 读写分离 ACID 覆盖索引(复合索引) 定义：包含两个或多个属性列的索引称为复合索引。如果查询字段是普通索引，或者是联合索引的最左原则字段，查询结果是联合索引的字段或者是主键。这种就不必通过主键（聚集索引再次查询） 目的: 减少磁盘IO, 不用回表 b+树索引 Nginx Nginx worker_connections upstream weight 负责均衡实现方式 轮询 IP哈希 指定权重 第三方 fair url_hash Linux Linux epoll select netstat 查看tcp udp unixsock网络 查看负载 cat /proc/loadavg | w | top df lstat: strace的时候常常可见它 top: shift+M free lsof: 查看当前进程ID, 进程名等占用的文件描述符 ipstat strace grep [-A ,-B, -C]&#39;HTTP/1.1&quot; 200&#39; access.log | wc -l socket和管道(pipe)的区别: socket全双工, pipe半双工*2 awk &amp; sed awk &#39;{print $1}&#39; access.log | sort | uniq | wc -l Redis 类型/应用场景 string: cache, incr hash: key为key, value为Hashmap set: 去重(中奖只一次 sismember), 交/并/差 (如微博社交关系), 内部实现为value为null的hashmap zset: (sorted set), 既去重又能保证按照score排序, 比如按照帖子的关注个数排序，value为帖子id，个数为score。 list: (阻塞rpop) 消息队列、列表旋转(常用于监控, rpoplpush) HyperLogLog: 大量统计 (非精确) bitmaps OBJ_ENCODING string OBJ_ENCODING_RAW, 代表sds, 原生string类型 OBJ_ENCODING_INT, long类型 OBJ_ENCODING_EMBSTR, 嵌入 OBJ_HASH OBJ_ENCODING_HT, 表示成dict OBJ_ENCODING_ZPILIST, hash用ziplist表示 OBJ_SET OBJ_ENCODING_INTSET, 表示成intest config set-max-intset-entries 512 OBJ_ZSET OBJ_ENCODING_SKIPLIST, 表示成skiplist OBJ_LIST OBJ_ENCODING_QUICKLIST config list-max-ziplist-size-2 list-compress-depth 0 扩展问题 zset如何根据两个属性排序? 比如根据id和age 可以用位操作, 把两个属性合成一个double 用zunionstore合并存储为新的key, 再zrange redis是如何保证原子性操作的? 因为它是单线程的! (MySQL是多线程) 在并发脚本中的 get set 等不是原子的 在并发的原子命令 incr setnx 等是原子的 事务是保证批量操作的原子性 主从复制过程 从服务器向主服务器发送sync 主服务器收到sync命令执行BGSAVE, 且在这期间新执行的命令到一个缓冲区 主执行(BGSAVE) 完毕后,将.rdb文件发送给从服务器, 从服务器将文件载入内存 BGSAVE期间到缓冲区的命令会以redis命令协议的方式, 将内容发送给从服务器 特性 单线程, 自实现(event driver库, 见下面四个io多路复用函数) io多路复用, 最常用调用函数: select (epoll, kquene, avport等), 同时监控多个文件描述符的可读可写 reactor方式实现文件处理器 (每一个网络连接对应一个文件描述符), 同时监听多个fd的accept, read (from client), write (to client), close文件事件 备份与持久化 rdb (fork进程dump到file) 手动: save(阻塞) &amp; bgsave (fork 子进程), 但是这两个不会同时进行 自动触发: conf:save 900 1 save 300 10 save 60 10000 dbfilename dump.rdb rdb优点: 对服务进程影响小, 记录原数据文件方式便于管理还原 rdb缺点: 可能数据不完整 rdb为纯文本文件, 可以用 od -c dump.rdb 分析 aof (类似binlog) 三种写入同步方式 appendfsync no appendfsync everysec (每个事件循环写入缓冲区, 但是每隔一秒同步到磁盘文件) appendfsync always (每执行一个命令, 每个事件循环都会执行写入aof 缓冲区并同步到磁盘文件，效率最慢，但是最安全) aof优点: 数据最完整, 可以通过数据重写rewrite来减少体积, 存储内存为redis的纯文本协议 aof缺点: 文件相对rdb更大, 导入速度比rdb慢 一般有了aof就不rdb, 因为aof更新频率更高 过期策略 定时过期: 时间到了立即删除, cpu不友好, 内存友好 惰性过期: 访问时判断是否过期, cpu友好, 内存不友好 定期过期: expires dict中scan, 清除已过期的key, cpu和内存最优解 内存淘汰机制 noeviction: 新写入时会报错 allkeys-lru: 移除最近最少使用的key allkeys-random: 随机移除某些key volatile-lru: 设置了过期时间的key中, 移除最近最少使用 volatile-random: 随机移除某些key volatile-ttl: 设置类过期时间的键中, 有更早过期时间的key优先移除 redis队列特殊关注之处 队列可能丢东西 比如redis挂了, producer没有停止, 但是队列数据无法写入 队列的consumer需要手动处理commit协议 如果consumer处理完, 表示真正完成 如果没有处理完?放回队列?直接丢弃? 事件重放机制不支持 比如consumer消费错了, 那能不能将队列回放呢?再次处理呢? 队列最大长度及过期时间 如果producer远大于consumer, 撑爆了怎么办 如果comsumer一直没有处理, producer的数据如何处理 exactly once 单机锁setnx或者基于set众多参数没有问题, 集群下可利用tag机制 如何保证业务执行时间超过锁的过期时间, 而引起误删除操作, 答案是可以加一个唯一标识 vs memcache memcached 优势 多线程(listen &amp; worker), 利用多核 round robin cas (check and set, compare and swap) 劣势 cache coherency、 锁 key大小有限制 (1M) 特点 内存预分配: slab + trunk redis 优势 自己封装了一个AEEvent (epoll + select + kqueue), io多路复用 丰富的数据结构 (对内 + 对外) 良好的持久化策略 (rdb + aof) 劣势 排序、聚会cpu密集操作会影响吞吐量 key 大小最大为 1g redis的事务机制 基于乐观锁的watch multi exec redis call lua 脚本 (比如get+del一起) 2.6.12后set命令支持(setnx + expire就不需要写lua script了) redis 下的分布式锁，当主从不同步或者主重新被选举需要多想想，主从情况下一般采用从节点的大多数 (es也是这样) redis 主从哨兵配置，copy三份redis.conf文件，以下设置一主二从一哨兵 12345678910111213141516vim redis01.confport 63791vim redis02.confport 63792slaveof 127.0.0.1 63791vim redis03.confport 63793slaveof 127.0.0.1 63791vim sentinel.confdaemonize yesport 26379sentinel monitor mymaster 127.0.0.1 63791 1 // mymaster为自定义命名，127.0.0.1 63791为master，1为选举主节点的时候投票数目的同意个数，1代表有一个哨兵同意就行。 redis cluster 集群会将数据自动按照算法分割在不同节点负责的槽上 (data sharding) 算法&amp;数据结构 最小堆: 根节点为最小值, 且节点比其他子节点小 平衡树 (avl红黑树) 最大堆: 根节点为最大值, 且节点比其他子节点大 sikplist hash hash 碰撞原因 hash 碰撞解决方案 拉链, 塞到链表里. 有点是相对简单, 但是需要附加空间 开发寻址, 有点是空间利用率高, 一直找 线性探测 二次探测再散列函数 伪随机数 给定数组n, 判断n是斐波那契数列的第几项? 写算法 反转列表如A-&gt;B-&gt;C-&gt;D 到 A-&gt;D-&gt;C-&gt;B 插入排序 数组与链表区别与联系 链表操作 单链表删除 单链表插入 快慢指针判断环路、找链表中点 应用问题 如何实现一个LRU功能 (双向链表) 如何实现浏览器前进后退功能 (两个栈) 网络协议 HTTP 构成: 起始行(Get=&gt;200), 首部头(Accept=&gt;Content-Type), 主体(name =&gt; tongbo) 版本 1.0 1.1 2.0 多路复用, 流量控制 长连接 在一个连接上发送多个数据包 心跳、如何发送心跳 HTTP DNS 定义: 用http协议代替元素的udp dns协议, 可以绕过运营商的local dns 解决问题: 避免local dns造成的域名劫持问题和调度不精确问题 其他解决方案 客户端dns缓存 热点域名解析 懒更新策略 (ttl过期后再同步) Post请求分割head和body Get vs Post Get 安全幂等, 请求实体资源 参数只能url编码, 且参数长度有限制 浏览器会自动加cache Post 附加请求实体于服务器 产生两个TCP数据包 数据支持多种编码格式 Resultful get: 获取资源 post: 新建资源 put: 跟新完整资源 delete: 删除资源 patch: 更新部分资源 RPC RPC框架涉及基本组件服务 客户端、服务端自动代码生成、多语言支持 消息序列化、反序列化 连接池、负载、故障、队列、超时、异步 常见协议 soap (http jsonrpc) GRPC thrift(tcp) TCP 面向连接, 先建立(握手), 然后释放(挥手确认拜拜) 只能点对点 可靠交付, 全双工, 接收和发送端都设有发送和接收cache 面向字节流 特性协议 停等 超时重传 慢启动 滑动窗口 快速重传 UDP 无连接、best effort、面向报文(不合并、不拆分、保留边界) 无拥塞控制、流量控制、首部开销小(8个字节, 而TCP有20个首部) 支持一对一、一对多、多对一 自定义协议 PHP框架 laravel AppServerProvider register:服务提供者注册 IocContainer: (IoC容器, 工厂模式的升华) 控制反转 (inversion of control) 可以降低计算机代码直接的耦合, 其中最常见的方式叫做依赖注入 (Dependence Injection), 还有一种方式叫依赖查找 实现方式 基于接口: 实现特定接口以供外部容器注入所依赖类型的对象 基于Set方法: 基于构造函数: 实现特定参数的构造函数 管理类依赖 执行 (依赖注入DI): 通过构造函数或者某些情况下通过Setter方法将类依赖注入到类中, 容器并不需要被告知如何构建对象,因为他会使用PHP的反射服务自动解析出具体的对象 swoole thinkphp ci yii easyswoole 操作系统 操作系统 多线程 多进程 协程的理解 socket和管道的区别 进程间通信手段 共享内存 rpc 管道 线程间通信手段 读写进程数据段 设计模式 单例模式 (static, construct) 12345678910111213141516171819&lt;?phpstatic private $instance;private $config;private function __construct($config)&#123; $this-&gt;config = $config;&#125;static public function instance($config)&#123; if (! self::$instance instanceof self) &#123; self::$instance = new self($config); &#125; return self::$instance;&#125; 简单工厂 (switch case include new return) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php&#123; public function makeModule($moduleName, $options) &#123; switch ($moduleName) &#123; case 'Fight': return new Fight($options[0], $options[1]); case 'Force': return new Force($options[0]); case 'Shot': return new Shot($options[0], $options[1], $options[2]); &#125; &#125;&#125;# 使用工厂方式 001class Superman&#123; protected $power; public function __construct() &#123; // 初始化工厂 $factory = new SuperModuleFactory; // 通过工厂提供的方法制造需要的模块 $this-&gt;power = $factory-&gt;makeModule('Fight', [9, 100]); // $this-&gt;power = $factory-&gt;makeModule('Force', [45]); // $this-&gt;power = $factory-&gt;makeModule('Shot', [99, 50, 2]); /* $this-&gt;power = array( $factory-&gt;makeModule('Force', [45]), $factory-&gt;makeModule('Shot', [99, 50, 2]) ); */ &#125;&#125;# 使用工厂方式 002 class Superman&#123; protected $power; public function __construct(array $modules) &#123; // 初始化工厂 $factory = new SuperModuleFactory; // 通过工厂提供的方法制造需要的模块 foreach ($modules as $moduleName =&gt; $moduleOptions)&#123; $this-&gt;power[] = $factory-&gt;makeModule($moduleName, $moduleOptions); &#125; &#125;&#125;// 创建超人$superman = new Superman([ 'Fight' =&gt; [9, 100], 'Shot' =&gt; [99, 50, 2]; 门面模式 对客户屏蔽子系统组件, 减少子系统与客户之间的松耦合关系 依赖注入(DI) 和 AOP思想 大前端 js 百度统计的实现 基于cookie, 引入js脚本及百度个人账户ID, 读取当前信息, 适当节点发送请求给百度服务 前后端分离 运维 运维&amp;架构 服务器CPU99%如何分析 MySQL占CPU如何分析 PHP占CPU较高如何分析 SSO实现方法 MySQL优化方法 如何提高监测数据的准确性 Dcoker原理及引用及编排管理 分布式|微服务 分布式 redis分布式锁问题 cap及常见应用关注cap哪两点 微服务 优点 相对于单体服务更简单, 注重单一功能 每个服务可以独立开发打包测试部署, 且语言环境无关 可以水平、高效扩展 缺点 运营成本, 服务发现, 治理, 降级, 熔断 网络信息传输、安全、延迟 服务调用排查追踪 最佳原则 高内聚: 修改了一个功能, 只需要改一个服务 低耦合: 修改了一个地方, 不需要改其他的地方 业务内原则 新服务用新的微服务, 确定无误后保留推进, 否则调整 老的保留, 直到新服务稳定再切换 必须的监控与日志 | 生产 - 订阅 - 消费模型 尝试对外不可见的服务先做是试点, 错误邮件, 日志, 系统内调用, API内部分成熟接口 考虑问题 分布式数据一致性问题?CAP如何权衡 调用链追踪(基于OpenTracing协议的JeagerORZipkin) 其他","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://blog.caoxl.com/tags/面试题/"},{"name":"笔试题","slug":"笔试题","permalink":"http://blog.caoxl.com/tags/笔试题/"}]},{"title":"PHP面试/笔试题杂记 VI","slug":"Interview-Questions-Notes-VI","date":"2019-11-25T02:28:12.000Z","updated":"2019-11-27T03:10:27.000Z","comments":true,"path":"2019/11/25/Interview-Questions-Notes-VI/","link":"","permalink":"http://blog.caoxl.com/2019/11/25/Interview-Questions-Notes-VI/","excerpt":"","text":"通过哪一个函数，可以把错误转换为异常处理？ A: set_error_handler B: error_reporting C: error2exception D: catch 正确答案：A答案分析：set_error_handler () 可指定一个回调函数，错误发生时，会自动通过指定的回调函数处理。在回调函数中抛出新的异常即可。 下列哪个 shell 函数的描述是正确的？ A：shell 函数可以先调用后定义 shell 函数需使用关键字 function 定义 shell 函数内的变量可以声明为局部变量 shell 函数只能通过 return 返回值，1 是成功，0 是失败 正确答案：C答案分析：shell 函数必须先定义在调用；声明时，无需使用关键字；通过 local 可以定义函数内的局部变量；shell 函数返回值，0 是成功，非 0 是错误，其他选项正确 下列关于全文检索技术的说法，不对的是： A: Solr 是新一代的全文检索组件，它比 Lucene 的搜索效率高很多，还能支持 HTTP 的访问方式，PHP 调用 Solr 也很方便。 B: MySQL 中把一个字段建立 FULLTEXT 索引，就可以实现全文检索，目前 MyISAM 和 InnoDB 的 table 都支持 FULLTEXT 索引。 C: Sphinx 是一个基于 SQL 的全文检索引擎，可以结合 MySQL 做全文搜索，它可以提供比数据库本身更专业的搜索功能。 D: Lucene 附带的二元分词分析器 CJKAnalyzer 切词速度很快，能满足一般的全文检索需要。 正确答案：A答案分析： Solr 是新一代的全文检索组件，它基于 Lucene，所以说它比 Lucene 快就是胡扯 ：） 关于单例模式的说法，错误的是？ A：单例模式的目的是确保在全局环境中，一个类只能有一个实例存在 B：单例模式一般要将构造函数设置为 private C：只需要将构造函数设置为 private 即可确保全局中只有一个实例 D：连接数据库的功能通常用单例模式实现 正确答案：C答案分析：构造函数设置为 private，仅能确保无法通过 new 创建新实例，但仍可以通过 clone、反序列化等方式创建多个实例。 正则的引擎表述错误的是？ A: 正则引擎主要可以分为两大类：一种是 DFA，一种是 NFA。 B: 一般而论，NFA 引擎则搜索更快一些。但是 DFA 以表达式为主导，更容易操纵，因此一般程序员更偏爱 DFA 引擎！ C: NFA 表达式主导，DFA 文本主导. D: 可以使用是否支持忽略优先量词和分组捕获来判断引擎类型：支持 NFA, 不支持 DFA 正确答案：B答案分析：正确的说法应该是：一般而论，DFA 引擎则搜索更快一些。但是 NFA 以表达式为主导，更容易操纵，因此一般程序员更偏爱 NFA 引擎 下面哪个不是 XSS 漏洞的修复方式？ A: 对参数进行 htmlspecialchas 过滤 B: 对参数使用白名单过滤 C: 不允许输入的内容显示到浏览器 D: 禁止在 js 标签内输出用户输入的内容 正确答案：A答案分析：这类过滤可以解决尖括号类型的 xss，无法解决 js 标签内的 xss 下列哪一项不是 PHP SAPI 模式？ A: ISAPI B: CGI C: FastCGI D: RESTFUL API 正确答案：D答案分析：A~C 是最常用的模式，D 是一种接口的组织方式。 对一个大文件进行逐行遍历，如下方法性能较高的是？ A：写一个实现了 IteratorAggregate 接口的类，通过该类使用 foreach 遍历。 B：使用 file_get_contents 将文件内容一次性载入内存，然后逐行遍历。 C：通过 exec 函数，调用 shell 工具遍历 D：使用别人写的类库 正确答案：A答案分析：使用 IteratorAggregate 可将文件打开后通过移动指针的方式逐行遍历，不受文件大小影响。使用 file_get_contents 处理大文件很容易导致 PHP 内存溢出；调用 exec 会产生额外的进程，影响性能；其他人写的类库质量不一定高。 函数中如果使用了 try catch finally 语法结构，return 应该写在哪儿？ A：finally 中 B：try 中 C：catch 中 D：任意位置 正确答案：A答案分析：try 中 return 后 finally 会继续执行，如果 finally 中也有 return，则最终返回值为 finally 中 return 的值 以下关于 NOSQL 的说法，不对的是： A: Redis 支持字符串、哈希、列表、集合、有序集合等数据结构，目前 Redis 不支持事务。 B: MongoDB 支持 CAP 定理中的 AP，MySQL 支持 CAP 中的 CA，全部都支持不可能存在 C: MongoDB 不用先创建 Collection 的结构就可以直接插入数据，目前 MongoDB 不支持事务。 D: Memcache 既支持 TCP 协议，也支持 UDP 协议，我们可以把 PHP 的 Session 存放到 Memcache 中。 正确答案：A答案分析：Redis 支持事务。 Innodb 锁机制说法错误的是？ A：Innodb 提供了表锁与行锁两种锁机制 B：Innodb 的表锁所会在表变更的时候触发 C：Innodb 下 update 时会自动给涉及到的行加上排他锁，并创建出一个镜像副本， 此时进行 select 时查询的是镜像副本的数据 D：Innodb 行锁状态下读不受影响，写会受影响（涉及到的数据） 正确答案：A 在拆分之前，系统中很多列表和详情页所需的数据是可以通过 sql join 来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join 将变得非常麻烦。下面哪种方法不能有效解决这个问题？ A: 全局表，系统中所有模块都可能会依赖到的一些表在各个库中都保存。 B: 字段冗余，“订单表” 中保存 “卖家 Id” 的同时，将卖家的 “Name” 字段也冗余，这样查询订单详情的时候就不需要再去查询 “卖家用户表”。 C: 主从复制，将数据库的读写分离。 D: 数据同步，定时 A 库中的 tbl_a 表和 B 库中 tbl_b 关联，可以定时将指定的表做主从同步。 正确答案：C答案分析：主从复制，将数据库的读写分离。只能扩容读并发，并不能缓解跨库 join 的问题。 关于网络 IO 模型，下列哪一项是正确的？ A: Select 比 Epoll 更快 B: nginx 使用的是 select 模型 C: apache 支持 select 和 epoll 两种方式的切换 D: epoll 能支持更大的并发 正确答案：D答案分析：A epoll 更快一些。B nginx 使用 epoll 模型。C apache 只支持 select PHP 执行的时候有如下执行过程：Scanning (Lexing) - Compilation - Execution - Parsing，其含义分别为： A：将 PHP 代码转换为语言片段 (Tokens)、将 Tokens 转换成简单而有意义的表达式、将表达式编译成 Opocdes、顺次执行 Opcodes B：将 PHP 代码转换为语言片段 (Tokens)、将 Tokens 转换成简单而有意义的表达式、顺次执行 Opcodes、将表达式编译成 Opocdes C：将 PHP 代码转换为语言片段 (Tokens)、将表达式编译成 Opocdes、顺次执行 Opcodes、将 Tokens 转换成简单而有意义的表达式 D：将 PHP 代码转换为语言片段 (Tokens)、将表达式编译成 Opocdes、将 Tokens 转换成简单而有意义的表达式、顺次执行 Opcodes 正确答案：C答案分析：正确答案为 C，正确的顺序为：Scanning (Lexing)、Parsing、Compilation、Execution 用PHP打印出前一天的时间; 格式是 2019-11-26 22:21:211234&lt;?phpvar_dump(date('Y-m-d H:i:s', strtotime('yesterday')));var_dump(date('Y-m-d H:i:s', strtotime('-1 day'))); 简单描述下Git的开发流程1234567891011121314151617181920// 初始化Git仓库git init// 拉取远程仓库git pull git@github.com:laravel/laravel.git// 创建分支git branch branch_name// 切换分支git checkout branch_name// 提交代码git add -A// 提交代码说明git commit -m '代码更新'// 查看状态git status// 添加远程地址git remote addorigin git@github.com:laravel/laravel.git// 同步代码到远程分支git push origin master// 查看git日志git log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)' var $empty = ‘’ var $empty = ‘ ‘;var $null = NULL;var $bool = FALSE;var $notSet;var $array = array(); 12if. $a = \"hello\";$b = &amp;$a; unset($b);$b = \"world\";what is $a? $a = “hello” 12if. $a = 1; $x = &amp;$a; $b = $a++;what is $b? $b = 1 12if. $x = empty($array);what is $x? true 索引的作用? 索引有什么优点和缺点? 索引的作用/优点 创建索引可以大大提高系统的性能 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性 可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 索引缺点 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 什么是fpm? 简单介绍php-fpm配置文件的相关参数 PHP FastCGI Process Manager 进程管理器 php-fpm 重要配置 123456789101112131415161718192021222324252627282930313233343536373839404142// pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启pid = run/php-fpm.pid// 错误日志，默认在安装目录中的var/log/php-fpm.logerror_log = log/php-fpm.log// 错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice.log_level = notice// 表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。emergency_restart_threshold = 60emergency_restart_interval = 60s// 设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0.process_control_timeout = 0// 后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置daemonize = yes// fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: 'ip:port', 'port', '/path/to/unix/socket'. 每个进程池都需要设置.listen = 127.0.0.1:9000// 启动进程的帐户和组启动进程的帐户和组user = wwwgroup = www// 对于专用服务器，pm可以设置为static。pm = dynamic// 如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：pm.max_children // 子进程最大数pm.start_servers // 启动时的进程数pm.min_spare_servers // 保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程pm.max_spare_servers // 保证空闲进程数最大值，如果空闲进程大于此值，此进行清理// FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到pm.status_path = /status// 设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的'max_execution_time'因为某些特殊原因没有中止运行的脚本有用. 设置为 '0' 表示 'Off'.当经常出现502错误时可以尝试更改此选项。request_terminate_timeout = 20 // #设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。rlimit_files = 1024 如何保证API到后端的幂等性 什么是幂等性 Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.– HTTP/1.1规范中幂等性的定义 从定义上看，HTTP 方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。说白了就是，同一个请求，发送一次和发送 N 次效果是一样的! HTTP的幂等性 GET 方法用于获取资源，不应有副作用，所以是幂等的。 DELETE 方法用于删除资源，有副作用，但它应该满足幂等性 POST 方法用于创建资源，所对应的 URI 并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性。 PUT 方法用于创建或更新操作，所对应的 URI 是要创建或更新的资源本身，有副作用，它应该满足幂等性。 什么是CC攻击? 如何防止CC攻击? 什么是CC攻击 ? CC 攻击是 DDoS 攻击的一种类型，使用代理服务器向受害服务器发送大量貌似合法的请求（通常使用 HTTP GET)。CC（Challenge Collapsar，挑战黑洞）根据其工具命名，攻击者创造性地使用代理机制，利用众多广泛可用的免费代理服务器发动 DDoS 攻击。许多免费代理服务器支持匿名模式，这使追踪变得非常困难。 如何防止CC攻击 服务器垂直扩展和水平扩容 数据缓存 (内存级别, 不要用文件) 页面静态化 用户级别的调用频率限制 IP限制","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://blog.caoxl.com/tags/面试题/"},{"name":"笔试题","slug":"笔试题","permalink":"http://blog.caoxl.com/tags/笔试题/"}]},{"title":"Linux 笔试题 I","slug":"Linux-DevOps-Numercal-Test","date":"2019-11-13T06:13:12.000Z","updated":"2019-11-13T08:33:43.000Z","comments":true,"path":"2019/11/13/Linux-DevOps-Numercal-Test/","link":"","permalink":"http://blog.caoxl.com/2019/11/13/Linux-DevOps-Numercal-Test/","excerpt":"","text":"Linux 常用命令系统安全 sudo // 超级用户 su // 用于切换当前用户身份到其他身份，变更时需输入所要变更的用户账号与密码。 chmod // 用来变更文件或目录的权限 setfacl // 设置文件访问控制列表 进程管理 w // 用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。 top // 可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。 ps // 用于报告当前系统的进程状态。 kill // 可以按照进程名杀死进程。 pstree // 以树状图的方式展现进程之间的派生关系，显示效果比较直观。 killall // 使用进程的名称来杀死进程，使用此指令可以杀死一组同名进程。 用户管理 id // 可以显示真实有效的用户ID（UID）和组ID（GID）。 usermod // 用于修改用户的基本信息。 useradd // 用于 Linux中创建的新的系统用户。 groupadd // 用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。 userdel // 用户删除给定的用户，以及与用户相关的文件。 文件系统 mount // 用户加载文件系统到指定的加载点。 unmount // 用于卸载已经加载的文件。 fsck // 用于检查并且试图修复文件系统中的错误。 df // 用于显示磁盘分区上的可使用的磁盘空间。 du // 对文件和目录磁盘使用的空间的查看。 系统关机和重启 shutdown // 关机 reboot // 重启 网络应用 curl // 是一个利用URL规则在命令行下工作的文件传输工具。 telnet // 用于登录远程主机，对远程主机进行管理。 mail // 命令行的电子邮件发送和接收工具。 elinks // 能实现一个纯文本界面的WWW浏览器 网络测试 ping // 用于测试主机之间网络的连通性。 netstat // 用来打印Linux中网络系统的状态信息，可让你得知整个Linux系统的网络情况。 host // 常用的分析域名查询工具，可以用来测试域名系统工作是否正常。 网络配置 hostname // 用于显示和设置系统的主机名称。 ifconfig // 被用于配置和显示Linux内核中网络接口的网络参数。 常用工具 ssh // openssh套件中的客户端连接工具，可以给予ssh加密协议实现安全的远程登录服务器。 screen // 是一款由GNU计划开发的用于命令行终端切换的自由软件。 clear // 用于清除当前屏幕终端上的任何信息。 who // 显示当前登录系统的用户信息。 date // 显示或设置系统时间与日期。 软件包管理 yum // 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 rpm // rpm软件包的管理工具。 apt-get // Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体如同 Windows上的安装文件。 文件查找和比较 locate // 用来查找文件或目录。 find // 用来在指定目录下查找文件。 文件内容查看 head // 用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。 tail // 用于输入文件中的尾部内容。tail命名默认在屏幕上显示指定文件的末尾10行。 more // 用来浏览文件档案的内容（只能向前浏览）。 less // 用来浏览文字档案的内容，允许用户向前或向后浏览文件。使用该命令时，用PageUp键向上翻页，用PageDown键向下翻页。要退出less程序，应按Q键。 文件处理 unlink // 用于系统调用函数 unlink 去删除指定的文件。 rename // 用字符串替换的方式批量改变文件名。 cat // 连接文件并打印到标准输出设备上，cat经常用来显示文件的内容。 touch // 有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。 ln // 用来为文件创建连接，连接类型分为硬连接和符号连接两种，默认的连接类型是硬连接。如果要创建符号连接必须使用”-s”选项（注意：符号链接文件不是一个独立的文件，它的许多属性依赖于源文件，所以给符号链接文件设置存取权限时没有意义的） 目录操作 cd // 用来切换工作目录至 dirname。 mv // 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。 rm // 可以删除一个目录中的一个或多个文件或目录，也可以将某个目录及其下属的所有文件及其子目录均删除掉。 pwd // 以绝对路径的方式显示用户当前工作目录。 tree // 以树状图列出目录的内容。 cp // 用来将一个或过个源文件或者目录复制到指定的目的文件或目录 ls // 用来显示目录列表，在 Linux中是使用率较高的命令。ls命令的输出信息可以进行彩色加亮显示，以区分不同类型的文件。 文件权限属性 setfacl // 用来变更文件或目录的权限。 chmod // 设置文件访问控制列表。 chgrp // 用来改变文件或目录所属的用户组。 chown // 改变某个文件或目录的所有者和所属的组，该命令可以向某个用户授权，使该用户变成指定文件的所有者。 文件传输 ftp // 用来设置文件系统相关功能。 scp // 用于在Linux下远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。 Linux系统定时任务crontab 命令12contab -e // 创建定时任务* * * * * 命令 // 分、时、日、月、周（每过多长时间去执行，根据我们所设置的分、时、日、月、周） at 命令12345# at 2:00 tomorrow // 在明天的两点去执行at&gt;/home/Jason/do_job // 执行结果是这种格式的at&gt;Ctrl + D // 退出总体意思，明天两点执行 do_job，最终退出 注：at 命令 是一次性执行，不是循环执行，也不是周期性执行。 面试/笔试题获取文件行数1wc-l filename 输入文件的最后5行到另一个文件中1tail -n 5 file1 &gt;&gt; file2 查找文件中包含hello的行1grep hello filename 查找当前目录下所有目录名为var的子目录的命令1find ./var -maxdepth 1 -type d -print 如何让一个程序在后台运行并把输入定向到指定的文件1nohup 程序 &gt;&gt; 文件名 2&gt;&amp;1 如何实时的显示一个文件的输出1234使用more或者less// 或者tail -100f // 实时显示输出的后100行 查看所有用户1cat /etc/passwd 有mail.log的一个文档，内容为若干邮件地址，其中用’\\n’将邮件地址分隔。要求从中 有mail.log的一个文档，内容为若干邮件地址，其中用’\\n’将邮件地址分隔。要求从中挑选出sina.com的邮件地址（包括从文件读取、过滤到列印出来）。 mail.log内容如下： james@sina.com.cn jack@163.com zhansan@sohu.com lisi@hotmail.com wangwu@gmail.com 1cat mail.log | grep sina.com 请解释下列10个shell命令的用途 top、ps、mv、find、df、cat、chmod、chgrp、grep、wc top: 该命令提供了实时对系统处理器状态的监控，它能够实时显示系统中各个进程的资源占用情况。 ps: 显示系统进程在瞬间的运行动态。 mv: 文件/目录改名或变更存储位置 find: 在指定的路径下查找指定文件。 df: 检查磁盘空间占用情况。 cat: 将文件的内容打印到标准输出。 chmod: 改变文件的权限。 chgrp: 改变文件所属组 grep: 过滤文本，根据指定的字符串，对文件的每一行进行搜索，如找到，则输出该行内容。 wc: 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"运维笔试题","slug":"运维笔试题","permalink":"http://blog.caoxl.com/tags/运维笔试题/"}]},{"title":"Lumen5.7 实现邮件发送","slug":"Lumen57-Use-Email","date":"2019-11-07T02:24:42.000Z","updated":"2019-11-07T07:12:20.000Z","comments":true,"path":"2019/11/07/Lumen57-Use-Email/","link":"","permalink":"http://blog.caoxl.com/2019/11/07/Lumen57-Use-Email/","excerpt":"","text":"Lumen5.7 实现邮件发送 安装依赖包123composer require illuminate/mail:5.7composer require guzzlehttp/guzzle:6.3composer require jeremeamia/SuperClosure 查看相关版本要求illuminate/mail:5.7guzzlehttp/guzzle:6.3jeremeamia/SuperClosure 添加配置 添加mail.php配置文件 12345678910111213141516171819202122&lt;?phpreturn [ 'driver' =&gt; env('MAIL_DRIVER', 'smtp'), 'host' =&gt; env('MAIL_HOST', 'smtp.mailgun.org'), 'port' =&gt; env('MAIL_PORT', 587), 'from' =&gt; [ 'address' =&gt; env('MAIL_FROM_ADDRESS', 'hello@example.com'), 'name' =&gt; env('MAIL_FROM_NAME', 'Example'), ], 'encryption' =&gt; env('MAIL_ENCRYPTION', 'tls'), 'username' =&gt; env('MAIL_USERNAME'), 'password' =&gt; env('MAIL_PASSWORD'), 'sendmail' =&gt; '/usr/sbin/sendmail -bs', 'markdown' =&gt; [ 'theme' =&gt; 'default', 'paths' =&gt; [ resource_path('views/vendor/mail'), ], ], 'log_channel' =&gt; env('MAIL_LOG_CHANNEL'),]; 加载配置文件 bootstrap/app.php 1$app-&gt;configure('mail'); 注册 mailer – 在 bootstrap/app.php 中，return $app; 之前，增加以下内容： 123$app-&gt;singleton('mailer', function () use ($app) &#123; return $app-&gt;loadComponent('mail', Illuminate\\Mail\\MailServiceProvider::class, 'mailer');&#125;); 使用 EmailSendController 1Mail::to($email)-&gt;send(new EmailVerify($code, $prefix)); EmailVerify 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace App\\Support;use Illuminate\\Bus\\Queueable;use Illuminate\\Mail\\Mailable;use Illuminate\\Queue\\SerializesModels;class EmailVerify extends Mailable&#123; use Queueable, SerializesModels; public $code; public $subject; const EMAIL_SUBJECT = [ 'register' =&gt; '【爱豆盒子】用户注册确认', 'password' =&gt; '【爱豆盒子】重置密码' ]; /** * EmailVerify constructor. * @param $code * @param string $prefix */ public function __construct($code, $prefix = 'register') &#123; $this-&gt;code = $code; $this-&gt;subject = static::EMAIL_SUBJECT[$prefix]; &#125; /** * Build the message. * * @return $this */ public function build() &#123; return $this-&gt;from(env('MAIL_FROM_ADDRESS'), env('MAIL_FROM_NAME')) -&gt;view('emails.email') -&gt;subject($this-&gt;subject) -&gt;with([ 'verify_code' =&gt; $this-&gt;code, ]); &#125;&#125;","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"Email","slug":"Email","permalink":"http://blog.caoxl.com/tags/Email/"}]},{"title":"使用Supervisor监管LaravelS","slug":"Supervisor-For-Laravels","date":"2019-11-06T02:42:02.000Z","updated":"2019-11-06T03:24:42.000Z","comments":true,"path":"2019/11/06/Supervisor-For-Laravels/","link":"","permalink":"http://blog.caoxl.com/2019/11/06/Supervisor-For-Laravels/","excerpt":"Supervisor 是一个 Python 写的进程管理工具，有时一个进程需要在后台运行，并且意外挂掉后能够自动重启，就需要这么一个管理进程的工具。","text":"Supervisor 是一个 Python 写的进程管理工具，有时一个进程需要在后台运行，并且意外挂掉后能够自动重启，就需要这么一个管理进程的工具。 安装 使用 pip 工具进行安装： 1[root@caoxl ~]# sudo pip install supervisor Ubuntu 系统使用 apt-get 1sudo apt-get install supervisor 检查是否安装完成 12345678910111213[root@caoxl ~]# supervisord --helpsupervisord -- run a set of applications as daemons.Usage: /usr/bin/supervisord [options]Options:-c/--configuration FILENAME -- configuration file path (searches if not given)-n/--nodaemon -- run in the foreground (same as 'nodaemon=true' in config file)-h/--help -- print this usage message and exit-v/--version -- print supervisord version number and exit-u/--user USER -- run supervisord as this user (or numeric uid)-m/--umask UMASK -- use this umask for daemon subprocess (default is 022)... 配置运行这个命令可以生成一个默认的配置文件： 1echo_supervisord_conf &gt; /etc/supervisord/supervisord.conf 生成成功后，打开编辑这个文件，把最后的 include 块的注释打开，并修改如下： 12[include]files = /etc/supervisor/*.conf 新增的 Supervisor 配置文件放在 /etc/supervisor 目录下，并且以 conf 结尾。 这时我们使用新的配置文件来启动 Supervisor： 1supervisord -c /etc/supervisord.conf 如果提示已经有进程在运行，那么先 kill 掉它。 123[root@caoxl ~]# supervisord -c /etc/supervisord.conf Error: Another program is already listening on a port that one of our HTTP servers is configured to use. Shut this program down first before starting supervisord.For help, use /usr/bin/supervisord -h 找到旧进程, kill掉 1234[root@caoxl ~]# ps -ef | grep supervisordroot 551 31716 0 10:53 pts/3 00:00:00 grep --color=auto supervisordroot 32156 1 0 10:18 ? 00:00:00 /usr/bin/python2 /usr/bin/supervisord -c ./supervisor/supervisord.conf[root@caoxl ~]# kill -9 32156 使用 Supervisor管理LaravelS进程 新增 /etc/supervisor/supervisord.conf 配置文件 1234567891011[program: laravel6]command=/usr/local/php/php72/bin/php /var/www/laravel6/bin/laravels start -idirectory=/var/www/laravel6process_name=%(process_num)sautorestart=trueautostart=truestderr_logfile=/var/www/laravel6/storage/logs/supervisord-stderr.logstdout_logfile=/var/www/laravel6/storage/logs/supervisord-stdout.loguser=rootnumprocs=1startsecs=1 说明 command: 运行程序的命令 directory: 命令执行的目录 autorestart: 程序意外退出是否自动重启 autostart: 是否自动启动 stderr_logfile: 错误日志文件 stdout_logfile: 输出日志文件 user: 进程执行的用户身份 numprocs: 进程数量 startsecs: 自动重启间隔 一切就绪后，我们使用如下命令就可以启动进程的监听了： 12345678[root@caoxl ~]# sudo supervisorctl rereadlaravel6: changed[root@caoxl ~]# sudo supervisorctl updatelaravel6: stoppedlaravel6: updated process group[root@caoxl ~]# sudo supervisorctl start laravel6:* 检查开启成功 123456789101112[root@caoxl ~]# ps -ef | grep laravelsroot 2258 593 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: master processroot 2269 2258 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: manager processroot 2275 2269 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: task worker process 4root 2276 2269 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: task worker process 5root 2277 2269 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: task worker process 6root 2278 2269 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: task worker process 7root 2279 2269 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: worker process 0root 2280 2269 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: worker process 1root 2281 2269 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: worker process 2root 2282 2269 0 11:15 ? 00:00:00 /var/www/laravel6 laravels: worker process 3root 2337 1412 0 11:16 pts/4 00:00:00 grep --color=auto laravels 检查LaravelS进程 12345678910111213141516171819202122232425262728[root@caoxl laravel6]# php bin/laravels info _ _ _____ | | | |/ ____|| | __ _ _ __ __ ___ _____| | (___ | | / _` | '__/ _` \\ \\ / / _ \\ |\\___ \\ | |___| (_| | | | (_| |\\ V / __/ |____) ||______\\__,_|_| \\__,_| \\_/ \\___|_|_____/ Speed up your Laravel/Lumen&gt;&gt;&gt; Components+---------------------------+---------+| Component | Version |+---------------------------+---------+| PHP | 7.2.7 || Swoole | 4.4.7 || LaravelS | 3.5.12 || Laravel Framework [local] | 6.4.1 |+---------------------------+---------+&gt;&gt;&gt; Protocols+------------------------+--------+-------------------------------+----------------+| Protocol | Status | Handler | Listen At |+------------------------+--------+-------------------------------+----------------+| Main HTTP | On | Laravel Framework | 127.0.0.1:5200 || Main WebSocket | On | App\\Services\\WebSocketService | 127.0.0.1:5200 || Port#0 TCP IPV4 Socket | On | App\\Sockets\\SwooleTcpSocket | 127.0.0.1:5300 || Port#1 UDP IPV4 Socket | On | App\\Sockets\\SwooleUdpSocket | 0.0.0.0:5301 |+------------------------+--------+-------------------------------+----------------+&gt;&gt;&gt; Feedback: https://github.com/hhxsv5/laravel-s","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"LaravelS","slug":"LaravelS","permalink":"http://blog.caoxl.com/tags/LaravelS/"},{"name":"Supervisor","slug":"Supervisor","permalink":"http://blog.caoxl.com/tags/Supervisor/"}]},{"title":"Linux 命令行测试WebSocket","slug":"Linux-Testing-WebSocket","date":"2019-10-29T03:36:37.000Z","updated":"2019-10-29T03:52:10.000Z","comments":true,"path":"2019/10/29/Linux-Testing-WebSocket/","link":"","permalink":"http://blog.caoxl.com/2019/10/29/Linux-Testing-WebSocket/","excerpt":"Linux环境下，分别使用curl和wscat命令测试websocket连接。","text":"Linux环境下，分别使用curl和wscat命令测试websocket连接。 websocket 这里用swoole搭建一个websocket server 123456789101112131415161718192021222324252627&lt;?php// 创建WebSocket服务器对象, 监听0.0.0.0:9502$web_socket = new swoole_websocket_server('0.0.0.0', 9502);$web_socket-&gt;on('start', function ($web_socket) &#123; echo \"WebSocket server is started at http://127.0.0.1:9502\\n\";&#125;);// 监听WebSocket连接打开事件$web_socket-&gt;on('open', function ($web_socket, $request) &#123; var_dump($request-&gt;fd, \"Hello, Welcome client-&#123;$fd&#125;\\n\");&#125;);// 监听WebSocket消息事件$web_socket-&gt;on('message', function ($web_socket, $frame) &#123; echo \"received message: &#123;$frame-&gt;data&#125;\\n\"; $web_socket-&gt;push($frame-&gt;fd, \"server: &#123;$frame-&gt;data&#125;\");&#125;);// 监听WebSocket连接关闭事件$web_socket-&gt;on('close', function ($web_socket, $fd) &#123; echo \"client-&#123;$fd&#125; is closed\\n\";&#125;);// 开启服务$web_socket-&gt;start(); 开启websocket server 12[root@caoxl Start]# php websocket_server.php WebSocket server is started at http://127.0.0.1:950 wscat wscat是一个用来连接websocket的命令行工具，nodejs开发的。 12345678[root@caoxl Start]# npm install -g wscat/root/.nvm/versions/node/v11.1.0/bin/wscat -&gt; /root/.nvm/versions/node/v11.1.0/lib/node_modules/wscat/bin/wscat+ wscat@3.0.0added 12 packages from 9 contributors in 8.03s// 测试一下[root@caoxl Start]# wscat -V3.0.0 使用wscat测试WebSocket 123&gt; [root@caoxl Start]# wscat -c ws://127.0.0.1:9502Connected (press CTRL+C to quit)&gt; curl123456789curl --include \\ --no-buffer \\ --header \"Connection: Upgrade\" \\ --header \"Upgrade: websocket\" \\ --header \"Host: http://127.0.0.1:9502\" \\ --header \"Origin: http://www.caoxl.com\" \\ --header \"Sec-WebSocket-Key: NVwjmQUcWCenfWu98asDmg==\" \\ --header \"Sec-WebSocket-Version: 13\" \\ http://127.0.0.1:9502 注意这里不需要特定的密钥（Sec-WebSocket-Key），所以随便取一个都可以。该头文件的作用是防止缓存websocket请求。 正常情况下输出如下： 123456HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: oPhRcOTYgRvrC0D+cTPcN3XYC1k=Sec-WebSocket-Version: 13Server: swoole-http-server","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://blog.caoxl.com/tags/WebSocket/"}]},{"title":"Linux下安装Go环境","slug":"Linux-Install-Golang-Environment","date":"2019-10-25T08:33:18.000Z","updated":"2019-10-28T08:14:16.000Z","comments":true,"path":"2019/10/25/Linux-Install-Golang-Environment/","link":"","permalink":"http://blog.caoxl.com/2019/10/25/Linux-Install-Golang-Environment/","excerpt":"Golang官网下载地址：https://golang.org/dl/","text":"Golang官网下载地址：https://golang.org/dl/ 安装流程 打开官网下载地址选择对应的系统版本, 复制下载链接 这里我选择的最新的Linux版本: go1.13.3.linux-amd64.tar.gz cd 进入你用来存放安装包的目录, 执行下载操作 12[root@caoxl ~]# cd /download/[root@caoxl download]# wget https://dl.google.com/go/go1.13.3.linux-amd64.tar.gz 下载完成, 执行解压 1[root@caoxl download]# tar -C /usr/local/ -zxvf go1.13.3.linux-amd64.tar.gz 添加/usr/loacl/go/bin目录到PATH变量中。添加到/etc/profile 或$HOME/.profile都可以 12345[root@caoxl go]# vim /etc/profile# 在最后一行添加export GOROOT=/usr/local/goexport PATH=$PATH:$GOROOT/bin 保存退出, source一下 1[root@caoxl go]# source /etc/profile 执行go version，如果出现版本号，则Go环境安装成功 12[root@caoxl go]# go versiongo version go1.13.3 linux/amd64 常见问题","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Go","slug":"Go","permalink":"http://blog.caoxl.com/tags/Go/"}]},{"title":"广州黄埔区学历入户指南","slug":"Settled-In-Guangzhou","date":"2019-10-21T02:57:57.000Z","updated":"2019-11-29T08:14:02.000Z","comments":true,"path":"2019/10/21/Settled-In-Guangzhou/","link":"","permalink":"http://blog.caoxl.com/2019/10/21/Settled-In-Guangzhou/","excerpt":"黄埔区引进人才入户指南(学历入户)实际使用记录","text":"黄埔区引进人才入户指南(学历入户)实际使用记录 完整入户流程 申请 -&gt; 领取入户卡 -&gt; 领取户口准予迁入证 -&gt; 原籍户口迁出 -&gt; 落户 办理流程 个人网上填报 -&gt; 用人单位确认提交 -&gt; 区人才交流服务中心初审 -&gt; 预约（按审批意见要求） -&gt; 提交纸质资料 -&gt; 区人社局审核 -&gt; 网上公示 -&gt; 公示无异议打印批复 -&gt; 核发入户卡。引进人才入户申办指南 一、个人网上填报 广东省统一身份认证平台 登录选择 人才引进申报系统 二、用人单位确认提交 用人单位如未开通法人单位权限请广州人才入户申请法人单位管理员权限操作指南开通;黄埔区用人单位向“广州市黄埔区人力资源和社会保障局(800005)”提交审批; 三、 区人才交流服务中心预审 区人才交流服务中心网上预审申请人资料。 若“审批结果”为“同意”，申请人请登录预约网址预约提交资料时间，预约成功后申请人本人持身份证原件、申办资料所有原件及复印件到黄埔区人才交流服务中心窗口递交纸质资料现场初审。 在线预约网址 - 广州市政务服务中心 若“审批结果”为“退案”，可致电黄埔区人才交流服务中心中心咨询了解退案原因。咨询电话: 020-82012125 四、 预约及提交纸质申报资料 “审批结果”为 “同意” 的，申请人请登录预约网址预约提交资料时间，预约成功后申请人本人持身份证原件、申办资料所有原件及复印件到黄埔区人才交流服务中心窗口递交纸质资料现场初审。 初审资料清单 申请人本人持身份证原件、申办资料所有原件及复印件 广州市人才引进申报表(原件需要正反面打印, 需要盖章,签字) 主迁人的户口簿首页加个人页 (复印件) 落户地址材料 (复印件) 毕业证书、学历认证资料、学位证书、学位认证资料 (复印件) 如有配偶随迁: 结婚证一份、配偶户口簿首页加个人页 (复印件) 如有小孩随迁: 小孩户口簿首页加个人页、出生证 (复印件) 五、 审核、公示、打印批复 区人社局审核材料，审核通过的及时公示（公示期为5个工作日），不通过的予以退案并告知理由。公示无异议，打印批复。 六、 领取入户卡 区人才交流服务中心发放 《广州市入户信息卡》 和批复。申请人按通知要求，持本人身份证原件到黄埔区人才交流服务中心领取或注意EMS邮件查收。(取决于你提交资料选择的接收方式)领取入户卡后，需到公安局进行落户 七、 领取户口准予迁入证(入户复核) 广州政务服务网 - 入户核准 拿到入户卡后微信搜索微信公众号 广州公安 -&gt; 关注 -&gt; 办事大厅 -&gt; 户政业务 -&gt; 户政业务智能咨询预约 -&gt; 入户核准 -&gt; 是 -&gt; 是 -&gt; 人才引进类人员 -&gt; 工作调动、招聘、招录 -&gt; 迁入个人房产地址/否 -&gt; 迁入单位集体户/否 -&gt; 预约办理 -&gt; 填写身份信息 -&gt; 选区级 -&gt; 预约时间 现场审核通过会给准迁证或不通过不给（所有原件不得涂改） 所需资料: 入户信息卡 户口本 结婚证 出生证明 迁入人名下不动产证明 注意: 需要不动产证明; 关注 &quot;广州不动产登记&quot;, 查询并且截图即可. 广州市公安局黄埔区分局办证中心地址: 广州 黄埔区 港湾路83号一层电话: 020-82286220 八、 原籍户口迁出 本省直接网签/外省带准迁证回老家办理迁出或寄回找人代办（如果委托代办就打电话问老家乡镇派出所户籍科要准备什么资料和人，不知道电话就打区县114查询 办理资料: 准予迁入证明 户口本 结婚证 出生证明 人社局入户批复 九、 落户 广州政务服务网 - 入户登记到市区内任一区公安分局办证中心（或可办理户政业务的派出所）办理入户手续。老家迁出后 → 与需要随迁的家属先拍身份证照拿上回执再前往 落户乡镇街道派出所 上户口 → 户口本现场会办好的/身份证制作一个月内需要回家坐等 办理资料: 广州市入户人员信息卡 户口迁移证 准予迁入证明(第三联) 居民身份证 关系证明(结婚证, 出生证) 工作单位的营业执照副本 户口簿 身份证回执 受理时间/地点/电话领取入户卡 受理地点: 广州市黄埔区香雪大道中81号广州国际人才城1楼2-3号窗 受理时间: 工作日 上午8：30-12:00 下午13:30-17:00 咨询电话: 020-82012125 领取准迁证黄埔区公安分局办证中心港湾路办证点 受理地点: 广州市公安局黄埔区分局办证中心港湾路83号一层 受理时间: 工作日8:30-12:00、14:00-17:30；双休日首日及其他国家法定节假日首日8:30-12:00、14:00-17:30 咨询电话: 020-82286220 将于2019年12月1日整合, 统一进驻广州市黄埔区广州开发区政务服务中心广州市黄埔区香雪三路3号2楼A区 黄埔区公安分局办证中心香雪三路办证点 受理地点: 广州市公安局黄埔区香雪三路3号 受理时间: 工作日 上午8:45-11:45 下午13:30-16:45 咨询电话: 020-83112265 落户市区内任一区公安分局办证中心 受理地点: 广州市公安局黄埔区分局办证中心港湾路83号二层 受理时间: 工作日8:30-12:00、14:00-17:30；双休日首日及其他国家法定节假日首日8:30-12:00、14:00-17:30 咨询电话: 020-82286220 可办理户政业务的派出所 受理地点: 迁入街道所属派出所(鱼珠派出所)(广东省广州市黄埔区鱼珠直街16号) 受理时间: 工作日 上午8：30-12:00 下午13:30-17:00 咨询电话: 020-82270217 准备资料 户口本 办理人身份证;随迁人员身份证;新生儿出生医学证明;结婚证; 毕业证;学位证;学历认证资料;学位认证资料; 落户公共集体户承诺书(需要签名) 人才引进申办系统申报表 (黄埔区公共集体户落户地址指引 - 点击下载)(落户公共集体户承诺书 - 点击下载) 附件上传说明 户口簿(需要上传主页,有详细地址信息和登记机关盖章页) 本人学历证书 本人学历鉴定(中国高等教育学生信息网) 本人学位证书 本人学位鉴定(中国学位与研究生教育信息网) 落户地址材料(落户公共集体户承诺书(需要手写签名)) 结婚证/离婚证（协议书/民事调解、判决书） 配偶身份证(随迁) 配偶户口簿(随迁) 子女户口簿(随迁) 子女出生医学证明(随迁) 相关网址 学历认证 - 中国高等教育学校信息网 学位认证 - 中国学位与研究生教育信息网 在线预约 - 黄埔区人才交流服务中心 引进人才入户申办指南 单位法人权限申办指南 入户核准及入户登记办理须知","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"落户广州","slug":"落户广州","permalink":"http://blog.caoxl.com/tags/落户广州/"},{"name":"学历入户","slug":"学历入户","permalink":"http://blog.caoxl.com/tags/学历入户/"}]},{"title":"Swoole 再学习","slug":"Swoole-Relearning","date":"2019-10-17T02:35:16.000Z","updated":"2019-10-30T03:11:56.000Z","comments":true,"path":"2019/10/17/Swoole-Relearning/","link":"","permalink":"http://blog.caoxl.com/2019/10/17/Swoole-Relearning/","excerpt":"书读百遍其义自见","text":"书读百遍其义自见 学习Swoole必备基础多进程/多线程 了解Linux操作系统进程和线程的概念 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位. 了解Linux进程/线程切换调度的基本知识 在引入线程的操作系统中，线程是调度和分配的基本单位 ，进程是资源拥有的基本单位 。把传统进程的两个属性分开，线程便能轻装运行，从而可显著地提高系统的并发程度。在同一进程中，线程的切换不会引起进程的切换；在由一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。 了解进程间通信的基本知识，如管道、UnixSocket、消息队列、共享内存 Socket 了解SOCKET的基本操作如 accept/connect、send/recv、close、listen、bind 了解SOCKET的接收缓存区、发送缓存区、阻塞/非阻塞、超时等概念 IO复用 了解select/poll/epoll 了解基于select/epoll实现的事件循环，Reactor模型 了解可读事件、可写事件 TCP/IP网络协议 了解TCP/IP协议 了解TCP、UDP传输协议 调试工具使用 gdb 调试 Linux 程序123gdb -p 进程IDgdb phpgdb php core gdb有3种使用方式: 跟踪正在运行的PHP程序，使用 gdb -p 进程ID 使用gdb运行并调试PHP程序，使用 gdb php -&gt; run server.php 进行调试 PHP程序发生coredump后使用gdb加载core内存镜像进行调试 gdb php core 使用 strace 跟踪进程的系统调用strace可以跟踪系统调用的执行情况，在程序发生问题后，可以用strace分析和跟踪问题。 使用方法： strace -o /tmp/strace.log -f -p $PID -f: 表示跟踪多线程和多进程，如果不加-f参数，无法抓取到子进程和子线程的运行情况 -o: 表示将结果输出到一个文件中 -p $PID: 指定跟踪的进程ID，通过ps aux可以看到 -tt: 打印系统调用发生的时间，精确到微妙 -s: 限定字符串打印的长度，如recvfrom系统调用收到的数据，默认只打印32字节 -c 实时统计每个系统调用的耗时 -T 打印每个系统调用的耗时 使用 tcpdump 跟踪网络通信过程1sudo tcpdump -i any tcp port 9501 -i 参数制定了网卡，any表示所有网卡 tcp 指定仅监听TCP协议 port 制定监听的端口 Server 强大的TCP/UDP Server框架, EventLoop, 事件驱动, 异步, Worker进程组, Task异步任务, 毫秒定时器, SSL/TLS隧道加密 Http\\Server是Server的子类, 内置了Http的支持 WebSocket\\Server是Http\\Server的子类, 内置了WebSocket的支持 Redis\\Server是Server的子类, 内置了Redis服务器端协议的支持 子类可以调用父类的所有方法和属性 Client TCP/UDP/UnixSocket客户端，支持IPv4/IPv6，支持SSL/TLS隧道加密，支持SSL双向证书，支持同步并发调用，支持异步事件驱动编程。 Coroutine 协程可以理解为纯用户态的线程，其通过协作而不是抢占来进行切换。相对于进程或者线程，协程所有的操作都可以在用户态完成，创建和切换的消耗更低。Swoole可以为每一个请求创建对应的协程，根据IO的状态来合理的调度协程，这会带来了以下优势： 开发者可以无感知的用同步的代码编写方式达到异步IO的效果和性能，避免了传统异步回调所带来的离散的代码逻辑和陷入多层回调中导致代码无法维护。 Process 进程管理模块，可以方便的创建子进程，进程间通信，进程管理。 Table 基于共享内存和自旋锁实现的超高性能内存表。彻底解决线程，进程间数据共享，加锁同步等问题。Table的性能可以达到单线程每秒读写200W次 Event EventLoop API，让用户可以直接操作底层的事件循环，将socket，stream，管道等Linux文件加入到事件循环中。eventloop接口仅可用于socket类型的文件描述符，不能用于磁盘文件读写 常见问题无法连接到服务器的简单检测手段 在Linux下，使用netstat -an | grep 端口，查看端口是否已经被打开处于Listening状态 12345[root@caoxl Start]# netstat -an | grep 9501tcp 0 0 127.0.0.1:9501 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:9501 127.0.0.1:44212 TIME_WAIT [root@caoxl Start]# netstat -an | grep 9501tcp 0 0 127.0.0.1:9501 127.0.0.1:44212 TIME_WAIT 上一步确认后，再检查防火墙问题 123[root@caoxl Start]# iptables -hiptables v1.4.21... 注意服务器所使用的IP地址，如果是 127.0.0.1 回环地址，则客户端只能使用127.0.0.1 才能连接上 用的阿里云服务或者腾讯服务，需要在安全权限组进行设置开发的端口 参考 Swoole Linux 命令大全","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"}]},{"title":"MySQL 自动备份","slug":"MySQL-Auto-Backup-In-CentOs","date":"2019-10-16T02:37:05.000Z","updated":"2019-10-16T03:40:32.000Z","comments":true,"path":"2019/10/16/MySQL-Auto-Backup-In-CentOs/","link":"","permalink":"http://blog.caoxl.com/2019/10/16/MySQL-Auto-Backup-In-CentOs/","excerpt":"定时备份数据库是一件必须做的事情","text":"定时备份数据库是一件必须做的事情 备份脚本 123456789101112131415161718192021#!/bin/sh# DB_USERNAMEdb_username='root'# DB_PASSWORDdb_password='110119'# DB_HOSTdb_host='127.0.0.1'# Backup DB_NAMEdb_name='test'# Backup Dirbackup_dir=\"test\"# Date Formate (dd-mm-yyyy)time=\"$(date +\"%Y_%m_%d_%H_%M_%S\")\"# MYSQL CLIMYSQL=\"/usr/local/mysql/bin/mysql\"# MySQLDump CLIMYSQLDUMP=\"/usr/local/mysql/bin/mysqldump\"# Gzip CLIGZIP=\"/bin/gzip\"$MYSQLDUMP -u $db_username -h $db_host -p$db_password $db_name | $GZIP -9 &gt; \"/data/backup/$time\"_\"$db_name.gz\" 创建定时器 1234crontab -e// 或者vim /etc/crontab 添加定时器 12# 每天凌晨 1 点 30 分 进行数据备份30 1 * * * root /root/mysql-backup.sh 注意: 需要生命脚本执行用户: 如root 重启定时器 1[root@caoxl ~]# service crond restart 查看crontab状态 12345678910[root@caoxl ~]# service crond statusRedirecting to /bin/systemctl status crond.service● crond.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2019-10-16 10:50:48 CST; 51s ago Main PID: 15813 (crond) Tasks: 1 Memory: 620.0K CGroup: /system.slice/crond.service └─15813 /usr/sbin/crond -n 结果 12345[root@caoxl backup]# ll -stotal 12K4.0K -rw-rw-r-- 1 root root 440 Oct 16 11:30 2019_10_16_11_30_38_test.gz4.0K -rw-r--r-- 1 root root 440 Oct 16 11:38 2019_10_16_11_38_01_test.gz4.0K -rw-r--r-- 1 root root 441 Oct 16 11:39 2019_10_16_11_39_01_test.gz","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"自动备份","slug":"自动备份","permalink":"http://blog.caoxl.com/tags/自动备份/"}]},{"title":"Hyperf 学习日志 II","slug":"Hyperf-Learning-Notes-II","date":"2019-10-12T03:54:00.000Z","updated":"2019-10-14T08:08:28.000Z","comments":true,"path":"2019/10/12/Hyperf-Learning-Notes-II/","link":"","permalink":"http://blog.caoxl.com/2019/10/12/Hyperf-Learning-Notes-II/","excerpt":"本文学习Hyperf 的基础功能","text":"本文学习Hyperf 的基础功能 基础功能路由默认情况下路由由 nikic/fast-route 提供支持，并由 hyperf/http-server 组件负责接入到 Hyperf 中，RPC 路由由对应的 hyperf/rpc-server 组件负责。 HTTP 路由通过闭包定义路由构建一个最基本的路由只需一个 URI 和一个 闭包(Closure)，我们直接通过代码来演示一下： 123456&lt;?phpuse Hyperf\\HttpServer\\Router\\Router;Router::get('/hello-hyperf', function () &#123; return 'Hello Hyperf.';&#125;); 定义标准路由所谓标准路由指的是由 控制器(Controller) 和 操作(Action) 来处理的路由，如果您使用 请求处理器(Request Handler) 模式也是类似的，我们通过代码来演示一下： 1234567&lt;?phpuse Hyperf\\HttpServer\\Router\\Router;// 下面三种方式的任意一种都可以达到同样的效果Router::get('/hello-hyperf', 'App\\Controller\\IndexController::hello');Router::get('/hello-hyperf', 'App\\Controller\\IndexController@hello');Router::get('/hello-hyperf', [App\\Controller\\IndexController::class, 'hello']); 可用的路由方法123456789101112use Hyperf\\HttpServer\\Router\\Router;// 注册与方法名一致的 HTTP METHOD 的路由Router::get($uri, $callback);Router::post($uri, $callback);Router::put($uri, $callback);Router::patch($uri, $callback);Router::delete($uri, $callback);Router::head($uri, $callback);// 注册任意 HTTP METHOD 的路由Router::addRoute($httpMethod, $uri, $callback); 路由组的定义方式实际路由为 gourp/route, 即 /user/index, /user/store, /user/update, /user/delete 123456Router::addGroup('/user/',function ()&#123; Router::get('index','App\\Controller\\UserController@index'); Router::post('store','App\\Controller\\UserController@store'); Router::get('update','App\\Controller\\UserController@update'); Router::post('delete','App\\Controller\\UserController@delete');&#125;); 注解路由 Hyperf 学习日志 注解 中间件定义全局中间件全局中间件只可通过配置文件的方式来配置，配置文件位于 config/autoload/middlewares.php ，配置如下： 12345678&lt;?phpreturn [ // http 对应 config/autoload/server.php 内每个 server 的 name 属性对应的值，该配置仅应用在该 Server 中 'http' =&gt; [ // 数组内配置您的全局中间件，顺序根据该数组的顺序 YourMiddleware::class ],]; 只需将您的全局中间件配置在该文件及对应的 Server Name 内，即该 Server 下的所有请求都会应用配置的全局中间件。 定义局部中间件通过配置文件定义在使用配置文件定义路由时，推荐通过配置文件来定义对应的中间件，局部中间件的配置将在路由配置上完成。 123456789101112131415161718192021&lt;?phpuse App\\Middleware\\FooMiddleware;use Hyperf\\HttpServer\\Router\\Router;// 每个路由定义方法都可接收一个 $options 参数Router::get('/', [\\App\\Controller\\IndexController::class, 'index'], ['middleware' =&gt; [ForMiddleware::class]]);Router::post('/', [\\App\\Controller\\IndexController::class, 'index'], ['middleware' =&gt; [ForMiddleware::class]]);Router::put('/', [\\App\\Controller\\IndexController::class, 'index'], ['middleware' =&gt; [ForMiddleware::class]]);Router::patch('/', [\\App\\Controller\\IndexController::class, 'index'], ['middleware' =&gt; [ForMiddleware::class]]);Router::delete('/', [\\App\\Controller\\IndexController::class, 'index'], ['middleware' =&gt; [ForMiddleware::class]]);Router::head('/', [\\App\\Controller\\IndexController::class, 'index'], ['middleware' =&gt; [ForMiddleware::class]]);Router::addRoute(['GET', 'POST', 'HEAD'], '/index', [\\App\\Controller\\IndexController::class, 'index'], ['middleware' =&gt; [ForMiddleware::class]]);// 该 Group 下的所有路由都将应用配置的中间件Router::addGroup( '/v2', function () &#123; Router::get('/index', [\\App\\Controller\\IndexController::class, 'index']); &#125;, ['middleware' =&gt; [ForMiddleware::class]]); 通过注解定义 定义单个中间件： 1234567891011121314151617&lt;?phpuse App\\Middleware\\FooMiddleware;use Hyperf\\HttpServer\\Annotation\\AutoController;use Hyperf\\HttpServer\\Annotation\\Middleware;/** * @AutoController() * @Middleware(FooMiddleware::class) */class IndexController&#123; public function index() &#123; return 'Hello Hyperf.'; &#125;&#125; 定义多个中间件： 123456789101112131415161718192021&lt;?phpuse App\\Middleware\\BarMiddleware;use App\\Middleware\\FooMiddleware;use Hyperf\\HttpServer\\Annotation\\AutoController;use Hyperf\\HttpServer\\Annotation\\Middleware;/** * @AutoController() * @Middlewares(&#123; * @Middleware(FooMiddleware::class), * @Middleware(BarMiddleware::class) * &#125;) */class IndexController&#123; public function index() &#123; return 'Hello Hyperf.'; &#125;&#125; 定义方法级别的中间件 123456789101112131415161718192021222324252627&lt;?phpuse App\\Middleware\\BarMiddleware;use App\\Middleware\\FooMiddleware;use Hyperf\\HttpServer\\Annotation\\AutoController;use Hyperf\\HttpServer\\Annotation\\Middleware;use Hyperf\\HttpServer\\Annotation\\Middlewares;/** * @AutoController() * @Middlewares(&#123; * @Middleware(FooMiddleware::class) * &#125;) */class IndexController&#123; /** * @Middlewares(&#123; * @Middleware(BarMiddleware::class) * &#125;) */ public function index() &#123; return 'Hello Hyperf.'; &#125;&#125; 生成中间件1php ./bin/hyperf.php gen:middleware Auth/FooMiddleware 常用中间件跨域中间件12345678910111213141516171819202122232425262728293031&lt;?phpdeclare(strict_types=1);namespace App\\Middleware;use Hyperf\\Utils\\Context;use Psr\\Http\\Message\\ResponseInterface;use Psr\\Http\\Message\\ServerRequestInterface;use Psr\\Http\\Server\\MiddlewareInterface;use Psr\\Http\\Server\\RequestHandlerInterface;class CorsMiddleware implements MiddlewareInterface&#123; public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface &#123; $response = Context::get(ResponseInterface::class); $response = $response-&gt;withHeader('Access-Control-Allow-Origin', '*') -&gt;withHeader('Access-Control-Allow-Credentials', 'true') // Headers 可以根据实际情况进行改写。 -&gt;withHeader('Access-Control-Allow-Headers', 'DNT,Keep-Alive,User-Agent,Cache-Control,Content-Type,Authorization'); Context::set(ResponseInterface::class, $response); if ($request-&gt;getMethod() == 'OPTIONS') &#123; return $response; &#125; return $handler-&gt;handle($request); &#125;&#125; 实际上，跨域配置也可以直接挂在 Nginx 上。 123456789location / &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,Keep-Alive,User-Agent,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') &#123; return 204; &#125;&#125; 控制器编写控制器123456789101112131415161718&lt;?phpdeclare(strict_types=1);namespace App\\Controller;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\HttpServer\\Contract\\ResponseInterface;class IndexController&#123; // 在参数上通过定义 RequestInterface 和 ResponseInterface 来获取相关对象，对象会被依赖注入容器自动注入 public function index(RequestInterface $request, ResponseInterface $response) &#123; $target = $request-&gt;input('target', 'World'); return 'Hello ' . $target; &#125;&#125; 请求安装1composer require hyperf/http-message 获取请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 获取请求路径$uri = $request-&gt;path();# 获取请求的 URL// 没有查询参数$url = $request-&gt;url();// 带上查询参数$url = $request-&gt;fullUrl();# 获取请求方法$method = $request-&gt;getMethod();if ($request-&gt;isMethod('post')) &#123; // ...&#125;# 获取所有输入$all = $request-&gt;all();# 获取指定输入值// 存在则返回，不存在则返回 null$name = $request-&gt;input('name');// 存在则返回，不存在则返回默认值 Hyperf$name = $request-&gt;input('name', 'Hyperf');# 从查询字符串获取输入// 存在则返回，不存在则返回 null$name = $request-&gt;query('name');// 存在则返回，不存在则返回默认值 Hyperf$name = $request-&gt;query('name', 'Hyperf');// 不传递参数则以关联数组的形式返回所有 Query 参数$name = $request-&gt;query();# 获取 JSON 输入信息// 存在则返回，不存在则返回 null$name = $request-&gt;input('user.name');// 存在则返回，不存在则返回默认值 Hyperf$name = $request-&gt;input('user.name', 'Hyperf');// 以数组形式返回所有 Json 数据$name = $request-&gt;all();# 确定是否存在输入值// 仅判断单个值if ($request-&gt;has('name')) &#123; // ...&#125;// 同时判断多个值if ($request-&gt;has(['name', 'email'])) &#123; // ...&#125; 大致上和Laravel一样… 响应在 Hyperf 里可通过 Hyperf\\HttpServer\\Contract\\ResponseInterface 接口类来注入 Response 代理对象对响应进行处理，默认返回 Hyperf\\HttpServer\\Response 对象，该对象可直接调用所有 Psr\\Http\\Message\\ResponseInterface 的方法。 返回JSON格式1234567891011121314151617&lt;?phpnamespace App\\Controller;use Hyperf\\HttpServer\\Contract\\ResponseInterface;use Psr\\Http\\Message\\ResponseInterface as Psr7ResponseInterface;class IndexController&#123; public function json(ResponseInterface $response): Psr7ResponseInterface &#123; $data = [ 'key' =&gt; 'value' ]; return $response-&gt;json($data); &#125;&#125; 返回 Xml 格式1234567891011121314151617&lt;?phpnamespace App\\Controller;use Hyperf\\HttpServer\\Contract\\ResponseInterface;use Psr\\Http\\Message\\ResponseInterface as Psr7ResponseInterface;class IndexController&#123; public function xml(ResponseInterface $response): Psr7ResponseInterface &#123; $data = [ 'key' =&gt; 'value' ]; return $response-&gt;xml($data); &#125;&#125; 返回 Raw 格式Hyperf\\HttpServer\\Contract\\ResponseInterface 提供了 raw($data) 方法用于快速返回 raw 格式，并设置 Content-Type 为 plain/text，$data 接受一个字符串或为一个实现了 __toString() 方法的对象。 1234567891011121314&lt;?phpnamespace App\\Controller;use Hyperf\\HttpServer\\Contract\\ResponseInterface;use Psr\\Http\\Message\\ResponseInterface as Psr7ResponseInterface;class IndexController&#123; public function raw(ResponseInterface $response): Psr7ResponseInterface &#123; return $response-&gt;raw('Hello Hyperf.'); &#125;&#125; 重定向123456789101112131415&lt;?phpnamespace App\\Controller;use Hyperf\\HttpServer\\Contract\\ResponseInterface;use Psr\\Http\\Message\\ResponseInterface as Psr7ResponseInterface;class IndexController&#123; public function redirect(ResponseInterface $response): Psr7ResponseInterface &#123; // redirect() 方法返回的是一个 Psr\\Http\\Message\\ResponseInterface 对象，需再 return 回去 return $response-&gt;redirect('/anotherUrl'); &#125;&#125; 异常处理注册异常处理器 目前仅支持配置文件的形式注册 异常处理器(ExceptionHandler)，配置文件位于 config/autoload/exceptions.php，将您的自定义异常处理器配置在对应的 server 下即可： 123456789101112&lt;?php// config/autoload/exceptions.phpreturn [ 'handler' =&gt; [ // 这里的 http 对应 config/autoload/server.php 内的 server 所对应的 name 值 'http' =&gt; [ // 这里配置完整的类命名空间地址已完成对该异常处理器的注册 \\App\\Exception\\Handler\\FooExceptionHandler::class, ], ],]; 定义异常处理器123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\Exception\\Handler;use Hyperf\\ExceptionHandler\\ExceptionHandler;use Hyperf\\HttpMessage\\Stream\\SwooleStream;use Psr\\Http\\Message\\ResponseInterface;use App\\Exception\\TestException;use Throwable;class TestExceptionHandler extends ExceptionHandler&#123; /** * @param Throwable $throwable * @param ResponseInterface $response * @return ResponseInterface */ public function handle(Throwable $throwable, ResponseInterface $response) &#123; // 判断被捕获到的异常是希望被捕获的异常 if ($throwable instanceof TestException) &#123; // 格式化输出 $data = json_encode([ 'code' =&gt; $throwable-&gt;getCode(), 'message' =&gt; $throwable-&gt;getMessage(), ], JSON_UNESCAPED_UNICODE); // 阻止异常冒泡 $this-&gt;stopPropagation(); return $response-&gt;withStatus(500)-&gt;withBody(new SwooleStream($data)); &#125; // 交给下一个异常处理器 return $response; &#125; public function isValid(Throwable $throwable): bool &#123; return true; &#125;&#125; 定义异常类12345678910&lt;?phpnamespace App\\Exception;use Hyperf\\Server\\Exception\\ServerException;class TestException extends ServerException&#123;&#125; 触发异常1234public function exception()&#123; throw new TestException('Test Exception...', 200);&#125; 缓存hyperf/cache 提供了基于 Aspect 实现的切面缓存，也提供了实现 Psr\\SimpleCache\\CacheInterface 的缓存类。 安装1composer require hyperf/cache 使用SimpleCache方式如果您只想使用实现 Psr\\SimpleCache\\CacheInterface 缓存类，比如重写 EasyWeChat 缓存模块，可以很方便的从 Container 中获取相应对象。 1$cache = $container-&gt;get(Psr\\SimpleCache\\CacheInterface::class); 注解方式1234567891011121314151617181920212223&lt;?phpnamespace App\\Services;use App\\Models\\User;use Hyperf\\Cache\\Annotation\\Cacheable;class UserService&#123; /** * @Cacheable(prefix=\"user\", ttl=9000, listener=\"user-update\") */ public function user($id) &#123; $user = User::query()-&gt;where('id',$id)-&gt;first(); if($user)&#123; return $user-&gt;toArray(); &#125; return null; &#125;&#125; 清理注解缓存123456789101112/** * @Inject * @var EventDispatcherInterface */protected $dispatcher;public function flushCache($userId)&#123; $this-&gt;dispatcher-&gt;dispatch(new DeleteListenerEvent('user-update', [$userId])); return true;&#125; 注解缓存介绍Cacheable例如以下配置，缓存前缀为 user, 超时时间为 7200, 删除事件名为 USER_CACHE。生成对应缓存 KEY 为 c:user:1 123456789101112131415use App\\Models\\User;use Hyperf\\Cache\\Annotation\\Cacheable;/** * @Cacheable(prefix=\"user\", ttl=7200, listener=\"USER_CACHE\") */public function user(int $id): array&#123; $user = User::query()-&gt;find($id); return [ 'user' =&gt; $user-&gt;toArray(), 'uuid' =&gt; $this-&gt;unique(), ];&#125; 当设置 value 后，框架会根据设置的规则，进行缓存 KEY 键命名。如下实例，当 $user-&gt;id = 1 时，缓存 KEY 为 c:userBook:_1 12345678910111213use App\\Models\\User;use Hyperf\\Cache\\Annotation\\Cacheable;/** * @Cacheable(prefix=\"userBook\", ttl=6666, value=\"_#&#123;user.id&#125;\") */public function userBook(User $user): array&#123; return [ 'book' =&gt; $user-&gt;book-&gt;toArray(), 'uuid' =&gt; $this-&gt;unique(), ];&#125; CachePutCachePut 不同于 Cacheable，它每次调用都会执行函数体，然后再对缓存进行重写。所以当我们想更新缓存时，可以调用相关方法。 1234567891011121314151617use App\\Models\\User;use Hyperf\\Cache\\Annotation\\CachePut;/** * @CachePut(prefix=\"user\", ttl=3601) */public function updateUser(int $id)&#123; $user = User::query()-&gt;find($id); $user-&gt;name = 'HyperfDoc'; $user-&gt;save(); return [ 'user' =&gt; $user-&gt;toArray(), 'uuid' =&gt; $this-&gt;unique(), ];&#125; CacheEvict123456789use Hyperf\\Cache\\Annotation\\CacheEvict;/** * @CacheEvict(prefix=\"userBook\", value=\"_#&#123;id&#125;\") */public function updateUserBook(int $id)&#123; return true;&#125; 日志安装1composer require hyperf/logger 配置在 hyperf-skeleton 项目内默认提供了一些日志配置，默认情况下，日志的配置文件为 config/autoload/logger.php ，示例如下： 123456789101112131415161718192021&lt;?phpreturn [ 'default' =&gt; [ 'handler' =&gt; [ 'class' =&gt; \\Monolog\\Handler\\StreamHandler::class, 'constructor' =&gt; [ 'stream' =&gt; BASE_PATH . '/runtime/logs/hyperf.log', 'level' =&gt; \\Monolog\\Logger::DEBUG, ], ], 'formatter' =&gt; [ 'class' =&gt; \\Monolog\\Formatter\\LineFormatter::class, 'constructor' =&gt; [ 'format' =&gt; null, 'dateFormat' =&gt; null, 'allowInlineLineBreaks' =&gt; true, ] ], ],]; 使用1234567891011121314151617181920212223242526272829&lt;?phpdeclare(strict_types=1);namespace App\\Service;use Psr\\Container\\ContainerInterface;use Hyperf\\Logger\\LoggerFactory;class DemoService&#123; /** * @var \\Psr\\Log\\LoggerInterface */ protected $logger; public function __construct(LoggerFactory $loggerFactory) &#123; // 第一个参数对应日志的 name, 第二个参数对应 config/autoload/logger.php 内的 key $this-&gt;logger = $loggerFactory-&gt;get('log', 'default'); &#125; public function method() &#123; // Do somthing. $this-&gt;logger-&gt;info(\"Your log message.\"); &#125;&#125; 不同环境下输出不同格式的日志上面这么多的使用, 都还只在 monolog 中的 Logger 这里打转, 这里来看看 Handler 和 Formatter 123456789101112131415161718192021222324252627282930// config/autoload/logger.php$appEnv = env('APP_ENV', 'dev');if ($appEnv == 'dev') &#123; $formatter = [ 'class' =&gt; \\Monolog\\Formatter\\LineFormatter::class, 'constructor' =&gt; [ 'format' =&gt; \"||%datetime%||%channel%||%level_name%||%message%||%context%||%extra%\\n\", 'allowInlineLineBreaks' =&gt; true, 'includeStacktraces' =&gt; true, ], ];&#125; else &#123; $formatter = [ 'class' =&gt; \\Monolog\\Formatter\\JsonFormatter::class, 'constructor' =&gt; [], ];&#125;return [ 'default' =&gt; [ 'handler' =&gt; [ 'class' =&gt; \\Monolog\\Handler\\StreamHandler::class, 'constructor' =&gt; [ 'stream' =&gt; 'php://stdout', 'level' =&gt; \\Monolog\\Logger::INFO, ], ], 'formatter' =&gt; $formatter, ],] 默认配置了名为 default 的 Handler, 并包含了此 Handler 及其 Formatter 的信息 获取 Logger 时, 如果没有指定 Handler, 底层会自动把 default 这一 Handler 绑定到 Logger 上 dev(开发)环境: 日志使用 php://stdout 输出到 标准输出(stdout), 并且 Formatter 中设置 allowInlineLineBreaks, 方便查看多行日志 非 dev 环境: 日志使用 JsonFormatter, 会被格式为 json, 方便投递到第三方日志服务 分页器基本使用1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Controller;use Hyperf\\HttpServer\\Annotation\\AutoController;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\Paginator\\Paginator;/** * @AutoController() */class UserController&#123; public function index(RequestInterface $request) &#123; $currentPage = $request-&gt;input('page', 1); $perPage = 2; $users = [ ['id' =&gt; 1, 'name' =&gt; 'Tom'], ['id' =&gt; 2, 'name' =&gt; 'Sam'], ['id' =&gt; 3, 'name' =&gt; 'Tim'], ['id' =&gt; 4, 'name' =&gt; 'Joe'], ]; return new Paginator($users, $perPage, $currentPage); &#125;&#125; 分页器方法123456789101112131415161718192021222324252627282930313233343536373839&lt;?php// 获取当前页数$currentPage = $paginator-&gt;currentPage();// 获取当前页的条数$count = $paginator-&gt;count();// 获取当前页中第一条数据的编号$firstItem = $paginator-&gt;firstItem();// 获取当前页中最后一条数据的编号$lastItem = $paginator-&gt;lastItem();// 获取是否还有更多的分页&lt;?phpif ($paginator-&gt;hasMorePages()) &#123; // ...&#125;// 获取对应分页的 URL// 下一页的 URL$nextPageUrl = $paginator-&gt;nextPageUrl();// 上一页的 URL$previousPageUrl = $paginator-&gt;previousPageUrl();// 获取指定 $page 页数的 URL$url = $paginator-&gt;url($page);// 是否处于第一页$onFirstPage = $paginator-&gt;onFirstPage();// 是否有更多分页$hasMorePages = $paginator-&gt;hasMorePages();// 每页的数据条数$perPage = $paginator-&gt;perPage();// 数据总数$total = $paginator-&gt;total(); 命令行安装1composer require hyperf/command 查看命令列表1php bin/hyperf.php 1234567891011121314151617181920212223242526272829303132333435Available commands: help Displays help for a command info Dump the server info. list Lists commands migrate start Start hyperf servers. db db:seed demo demo:command Hyperf Demo Command di di:init-proxy gen gen:amqp-consumer Create a new amqp consumer class gen:amqp-producer Create a new amqp producer class gen:aspect Create a new aspect class gen:command Create a new command class gen:controller Create a new controller class gen:job Create a new job class gen:listener Create a new listener class gen:middleware Create a new middleware class gen:migration gen:model gen:process Create a new process class gen:request Create a new form request class gen:seeder Create a new seeder class migrate migrate:fresh migrate:install migrate:refresh migrate:reset migrate:rollback migrate:status vendor vendor:publish Publish any publishable configs from vendor packages. 自定义命令生成命令如果你有安装 hyperf/devtool 组件的话，可以通过 gen:command 命令来生成一个自定义命令： 1php bin/hyperf.php gen:command TestCommand 定义命令定义该命令类所对应的命令有两种形式， 一种是通过 $name 属性定义， 另一种是通过构造函数传参来定义， 我们通过代码示例来演示一下，假设我们希望定义该命令类的命令为 test:hello： $name 属性定义：123456789101112131415161718192021&lt;?phpdeclare(strict_types=1);namespace App\\Command;use Hyperf\\Command\\Command as HyperfCommand;use Hyperf\\Command\\Annotation\\Command;/** * @Command */class TestCommand extends HyperfCommand&#123; /** * 执行的命令行 * * @var string */ protected $name = 'test:hello';&#125; 构造函数传参定义：12345678910111213141516171819&lt;?phpdeclare(strict_types=1);namespace App\\Command;use Hyperf\\Command\\Command as HyperfCommand;use Hyperf\\Command\\Annotation\\Command;/** * @Command */class TestCommand extends HyperfCommand&#123; public function __construct() &#123; parent::__construct('test:hello'); &#125;&#125; 数据库模型快速开始Hyperf框架1composer require hyperf/db-connection 其他框架1composer require hyperf/database 读写分离12345678910111213141516171819202122232425262728&lt;?phpreturn [ 'default' =&gt; [ 'driver' =&gt; env('DB_DRIVER', 'mysql'), 'read' =&gt; [ 'host' =&gt; ['192.168.1.1'], ], 'write' =&gt; [ 'host' =&gt; ['196.168.1.2'], ], 'sticky' =&gt; true, 'database' =&gt; env('DB_DATABASE', 'hyperf'), 'username' =&gt; env('DB_USERNAME', 'root'), 'password' =&gt; env('DB_PASSWORD', ''), 'charset' =&gt; env('DB_CHARSET', 'utf8'), 'collation' =&gt; env('DB_COLLATION', 'utf8_unicode_ci'), 'prefix' =&gt; env('DB_PREFIX', ''), 'pool' =&gt; [ 'min_connections' =&gt; 1, 'max_connections' =&gt; 10, 'connect_timeout' =&gt; 10.0, 'wait_timeout' =&gt; 3.0, 'heartbeat' =&gt; -1, 'max_idle_time' =&gt; (float) env('DB_MAX_IDLE_TIME', 60), ], ],]; 注意在以上的例子中，配置数组中增加了三个键，分别是 read， write 和 sticky。 read 和 write 的键都包含一个键为 host 的数组。而 read 和 write 的其他数据库都在键为 mysql 的数组中。 如果你想重写主数组中的配置，只需要修改 read 和 write 数组即可。所以，这个例子中： 192.168.1.1 将作为 「读」 连接主机，而 192.168.1.2 将作为 「写」 连接主机。这两个连接会共享 mysql 数组的各项配置，如数据库的凭据（用户名 / 密码），前缀，字符编码等。 多库配置12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpreturn [ 'default' =&gt; [ 'driver' =&gt; env('DB_DRIVER', 'mysql'), 'host' =&gt; env('DB_HOST', 'localhost'), 'database' =&gt; env('DB_DATABASE', 'hyperf'), 'username' =&gt; env('DB_USERNAME', 'root'), 'password' =&gt; env('DB_PASSWORD', ''), 'charset' =&gt; env('DB_CHARSET', 'utf8'), 'collation' =&gt; env('DB_COLLATION', 'utf8_unicode_ci'), 'prefix' =&gt; env('DB_PREFIX', ''), 'pool' =&gt; [ 'min_connections' =&gt; 1, 'max_connections' =&gt; 10, 'connect_timeout' =&gt; 10.0, 'wait_timeout' =&gt; 3.0, 'heartbeat' =&gt; -1, 'max_idle_time' =&gt; (float) env('DB_MAX_IDLE_TIME', 60), ], ], 'test'=&gt;[ 'driver' =&gt; env('DB_DRIVER', 'mysql'), 'host' =&gt; env('DB_HOST2', 'localhost'), 'database' =&gt; env('DB_DATABASE', 'hyperf'), 'username' =&gt; env('DB_USERNAME', 'root'), 'password' =&gt; env('DB_PASSWORD', ''), 'charset' =&gt; env('DB_CHARSET', 'utf8'), 'collation' =&gt; env('DB_COLLATION', 'utf8_unicode_ci'), 'prefix' =&gt; env('DB_PREFIX', ''), 'pool' =&gt; [ 'min_connections' =&gt; 1, 'max_connections' =&gt; 10, 'connect_timeout' =&gt; 10.0, 'wait_timeout' =&gt; 3.0, 'heartbeat' =&gt; -1, 'max_idle_time' =&gt; (float) env('DB_MAX_IDLE_TIME', 60), ], ],]; 使用时，只需要规定 connection 为 test，就可以使用 test 中的配置，如下。 123456789&lt;?phpuse Hyperf\\DbConnection\\Db;// defaultDb::select('SELECT * FROM user;');Db::connection('default')-&gt;select('SELECT * FROM user;');// testDb::connection('test')-&gt;select('SELECT * FROM user;'); 模型中修改 connection 字段，即可使用对应配置，例如一下 Model 使用 test 配置。 123456/** * The connection name for the model. * * @var string */protected $connection = 'test'; 执行原生SQL语句Query 查询类123456789&lt;?phpuse Hyperf\\DbConnection\\Db;$users = Db::select('SELECT * FROM `user` WHERE gender = ?',[1]); // 返回array foreach($users as $user)&#123; echo $user-&gt;name;&#125; Execute 执行类1234567891011&lt;?phpuse Hyperf\\DbConnection\\Db;$inserted = Db::insert('INSERT INTO user (id, name) VALUES (?, ?)', [1, 'Hyperf']); // 返回是否成功 bool$affected = Db::update('UPDATE user set name = ? WHERE id = ?', ['John', 1]); // 返回受影响的行数 int$affected = Db::delete('DELETE FROM user WHERE id = ?', [1]); // 返回受影响的行数 int$result = Db::statement(\"CALL pro_test(?, '?')\", [1, 'your words']); // 返回 bool CALL pro_test(?，?) 为存储过程，属性为 MODIFIES SQL DATA 自动管理数据库事务123456789&lt;?phpuse Hyperf\\DbConnection\\Db;Db::transaction(function () &#123; Db::table('user')-&gt;update(['votes' =&gt; 1]); Db::table('posts')-&gt;delete();&#125;); 手动管理数据库事务12345678910111213&lt;?phpuse Hyperf\\DbConnection\\Db;Db::beginTransaction();try &#123; // Do something... Db::commit();&#125; catch(\\Throwable $ex) &#123; Db::rollBack();&#125; 查询构造器 Hyperf 查询构造器 参考 Hyperf Hyperf Github","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"},{"name":"Hyperf","slug":"Hyperf","permalink":"http://blog.caoxl.com/tags/Hyperf/"}]},{"title":"Hyperf 学习日志","slug":"Hyperf-Learning-Notes","date":"2019-10-10T09:11:12.000Z","updated":"2019-10-12T03:57:52.000Z","comments":true,"path":"2019/10/10/Hyperf-Learning-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/10/10/Hyperf-Learning-Notes/","excerpt":"本文是根据Hyperf官方文档的学习日志, 看官请直接访问 Hyperf","text":"本文是根据Hyperf官方文档的学习日志, 看官请直接访问 Hyperf 什么是Hyperf ? Hyperspeed + Flexibility = Hyperf Hyperf 是基于 Swoole 4.4+ 实现的高性能、高灵活性的 PHP 协程框架，内置协程服务器及大量常用的组件，性能较传统基于 PHP-FPM 的框架有质的提升，提供超高性能的同时，也保持着极其灵活的可扩展性，标准组件均基于 PSR 标准 实现，基于强大的依赖注入设计，保证了绝大部分组件或类都是 可替换 与 可复用 的。 安装Hyperf服务器要求Hyperf 对系统环境有一些要求，仅可运行于 Linux 和 Mac 环境下，但由于 Docker 虚拟化技术的发展，在 Windows 下也可以通过 Docker for Windows 来作为运行环境 hyperf-cloud\\hyperf-docker 项目内已经为您准备好了各种版本的 Dockerfile ，或直接基于已经构建好的 hyperf\\hyperf 镜像来运行。 确保你的运行环境达到了以下的要求： PHP &gt;= 7.2 Swoole PHP 扩展 &gt;= 4.4，并关闭了 Short Name OpenSSL PHP 扩展 JSON PHP 扩展 PDO PHP 扩展 （如需要使用到 MySQL 客户端） Redis PHP 扩展 （如需要使用到 Redis 客户端） Protobuf PHP 扩展 （如需要使用到 gRPC 服务端或客户端） 查看Swoole扩展版本12345678[root@caoxl ~]# php --ri swooleswooleSwoole =&gt; enabledAuthor =&gt; Swoole Team &lt;team@swoole.com&gt;Version =&gt; 4.4.7Built =&gt; Oct 11 2019 10:26:37 升级Swoole扩展1pecl upgrade swoole 升级swoole版本的常见问题 查看PHP版本12345[root@caoxl ~]# php -vPHP 7.2.7 (cli) (built: Nov 15 2018 11:33:02) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.7, Copyright (c) 1999-2018, by Zend Technologies 升级PHP版本 Linux 下安装开发环境(多版本PHP) 安装HyperfComposer 安装1composer create-project hyperf/hyperf-skeleton 开始安装 123456789101112131415[root@caoxl www]# composer create-project hyperf/hyperf-skeleton Do not run Composer as root/super user! See https://getcomposer.org/root for detailsInstalling hyperf/hyperf-skeleton (v1.1.0) - Installing hyperf/hyperf-skeleton (v1.1.0): Downloading (100%) Created project in /var/www/hyperf-skeleton&gt; @php -r \"file_exists('.env') || copy('.env.example', '.env');\"&gt; Installer\\Script::installSetting up optional packagesSetup data and cache dirRemoving installer development dependencies...Writing lock fileGenerating autoload filesocramius/package-versions: Generating version class...ocramius/package-versions: ...done generating version class 安装完成 123456789101112131415[root@caoxl hyperf-skeleton]# ll -stotal 344K4.0K drwxrwxr-x 6 root root 4.0K Oct 8 01:26 app4.0K drwxrwxr-x 2 root root 4.0K Oct 8 01:26 bin4.0K -rw-rw-r-- 1 root root 2.6K Oct 11 10:41 composer.json296K -rw-rw-r-- 1 root root 295K Oct 11 10:41 composer.lock4.0K drwxrwxr-x 3 root root 4.0K Oct 8 01:26 config4.0K -rw-rw-r-- 1 root root 580 Oct 8 01:26 deploy.test.yml4.0K -rw-rw-r-- 1 root root 1.6K Oct 8 01:26 Dockerfile4.0K -rw-rw-r-- 1 root root 339 Oct 8 01:26 phpstan.neon4.0K -rw-rw-r-- 1 root root 695 Oct 8 01:26 phpunit.xml4.0K -rw-rw-r-- 1 root root 2.3K Oct 8 01:26 README.md4.0K drwxrwxr-x 2 root root 4.0K Oct 11 10:40 runtime4.0K drwxrwxr-x 3 root root 4.0K Oct 8 01:26 test4.0K drwxrwxr-x 44 root root 4.0K Oct 11 10:41 vendor Dockter 下开发123456789101112131415161718# 下载并运行 hyperf/hyperf 镜像，并将镜像内的项目目录绑定到宿主机的 /tmp/skeleton 目录docker run -v /tmp/skeleton:/hyperf-skeleton -p 9501:9501 -it --entrypoint /bin/sh hyperf/hyperf:7.2-alpine-cli# 镜像容器运行后，在容器内安装 Composerwget https://github.com/composer/composer/releases/download/1.8.6/composer.pharchmod u+x composer.pharmv composer.phar /usr/local/bin/composer# 将 Composer 镜像设置为阿里云镜像，加速国内下载速度composer config -g repo.packagist composer https://mirrors.aliyun.com/composer# 通过 Composer 安装 hyperf/hyperf-skeleton 项目composer create-project hyperf/hyperf-skeleton# 进入安装好的 Hyperf 项目目录cd hyperf-skeleton# 启动 Hyperfphp bin/hyperf.php start 接下来，就可以在 /tmp/skeleton 中看到您安装好的代码了。由于 Hyperf 是持久化的 CLI 框架，当您修改完您的代码后，通过 CTRL + C 终止当前启动的进程实例，并重新执行 php bin/hyperf.php start 启动命令即可。 存在兼容性问题的扩展由于 Hyperf 基于 Swoole 协程实现，而 Swoole 4 带来的协程功能是 PHP 前所未有的，所以与不少扩展都仍存在兼容性的问题。以下扩展（包括但不限于）都会造成一定的兼容性问题，不能与之共用或共存： xhprof xdebug blackfire trace uopz 快速开始为了让您更快的了解 Hyperf 的使用，本章节将以 创建一个 HTTP Server 为例，通过对路由、控制器的定义实现一个简单的 Web 服务，但 Hyperf 不止于此，完善的服务治理、gRPC 服务、注解、AOP 等功能将由具体的章节阐述。 定义访问路由Hyperf 使用 nikic/fast-route 作为默认的路由组件并提供服务，您可以很方便的在 config/routes.php 中定义您的路由。 通过配置文件定义路由路由的文件位于 hyperf-skeleton 项目的 config/routes.php ，下面是一些常用的用法示例。 1234567891011121314151617181920212223242526272829303132&lt;?phpdeclare(strict_types=1);/** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://doc.hyperf.io * @contact group@hyperf.io * @license https://github.com/hyperf-cloud/hyperf/blob/master/LICENSE */use Hyperf\\HttpServer\\Router\\Router;Router::addRoute(['GET', 'POST', 'HEAD'], '/', 'App\\Controller\\IndexController@index');// 此处代码示例为每个示例都提供了三种不同的绑定定义方式，实际配置时仅可采用一种且仅定义一次相同的路由// 设置一个 GET 请求的路由，绑定访问地址 '/get' 到 App\\Controller\\IndexController 的 get 方法Router::get('/get', 'App\\Controller\\IndexController::get');Router::get('/get', 'App\\Controller\\IndexController@get');Router::get('/get', [\\App\\Controller\\IndexController::class, 'get']);// 设置一个 POST 请求的路由，绑定访问地址 '/post' 到 App\\Controller\\IndexController 的 post 方法Router::post('/post', 'App\\Controller\\IndexController::post');Router::post('/post', 'App\\Controller\\IndexController@post');Router::post('/post', [\\App\\Controller\\IndexController::class, 'post']);// 设置一个允许 GET、POST 和 HEAD 请求的路由，绑定访问地址 '/multi' 到 App\\Controller\\IndexController 的 multi 方法Router::addRoute(['GET', 'POST', 'HEAd'], 'multi', 'App\\Controller\\IndexController::multi');Router::addRoute(['GET', 'POST', 'HEAd'], 'multi', 'App\\Controller\\IndexController@multi');Router::addRoute(['GET', 'POST', 'HEAd'], 'multi', [\\App\\Controller\\IndexController::class, 'multi']); 通过注解来定义路由Hyperf 提供了极其强大和方便灵活的 注解 功能，在路由的定义上也毫无疑问地提供了注解定义的方式，Hyperf 提供了 @Controller 和 @AutoController 两种注解来定义一个 Controller. 通过 @AutoController 注解定义路由@AutoController 为绝大多数简单的访问场景提供路由绑定支持，使用 @AutoController 时则 Hyperf 会自动解析所在类的所有 public 方法并提供 GET 和 POST 两种请求方式。 使用 @AutoController 注解时需 use Hyperf\\HttpServer\\Annotation\\AutoController; 命名空间； 123456789101112131415161718192021&lt;?phpdeclare(strict_types=1);namespace App\\Controller;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\HttpServer\\Annotation\\AutoController;/** * @AutoController() */class IndexController&#123; // Hyperf 会自动为此方法生成一个 /index/index 的路由，允许通过 GET 或 POST 方式请求 public function index(RequestInterface $request) &#123; // 从请求中获得 id 参数 $id = $request-&gt;input('id', 1); return (string)$id; &#125;&#125; 通过 @Controller 注解定义路由@Controller 为满足更细致的路由定义需求而存在，使用 @Controller 注解用于表明当前类为一个 Controller 类，同时需配合 @RequestMapping 注解来对请求方法和请求路径进行更详细的定义。 使用 @Controller 注解时需 use Hyperf\\HttpServer\\Annotation\\Controller; 命名空间； 使用 @RequestMapping 注解时需 use Hyperf\\HttpServer\\Annotation\\RequestMapping; 命名空间； 使用 @GetMapping 注解时需 use Hyperf\\HttpServer\\Annotation\\GetMapping; 命名空间； 使用 @PostMapping 注解时需 use Hyperf\\HttpServer\\Annotation\\PostMapping; 命名空间； 使用 @PutMapping 注解时需 use Hyperf\\HttpServer\\Annotation\\PutMapping; 命名空间； 使用 @PatchMapping 注解时需 use Hyperf\\HttpServer\\Annotation\\PatchMapping; 命名空间； 使用 @DeleteMapping 注解时需 use Hyperf\\HttpServer\\Annotation\\DeleteMapping; 命名空间； 12345678910111213141516171819202122232425&lt;?phpdeclare(strict_types=1);namespace App\\Controller;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\HttpServer\\Annotation\\Controller;use Hyperf\\HttpServer\\Annotation\\RequestMapping;/** * @Controller() */class IndexController&#123; // Hyperf 会自动为此方法生成一个 /index/index 的路由，允许通过 GET 或 POST 方式请求 /** * @RequestMapping(path=\"index\", methods=\"get,post\") */ public function index(RequestInterface $request) &#123; // 从请求中获得 id 参数 $id = $request-&gt;input('id', 1); return (string)$id; &#125;&#125; 处理HTTP请求Hyperf 是完全开放的，本质上没有规定您必须基于某种模式下去实现请求的处理，您可以采用传统的 MVC模式，亦可以采用 RequestHandler模式 来进行开发。 在 app 文件夹内创建一个 Controller 文件夹并创建 IndexController.php 如下，index 方法内从请求中获取了 id 参数，并转换为 字符串 类型返回到客户端。 12345678910111213141516171819202122&lt;?phpdeclare(strict_types=1);namespace App\\Controller;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\HttpServer\\Annotation\\AutoController;/** * @AutoController() */class IndexController&#123; // Hyperf 会自动为此方法生成一个 /index/index 的路由，允许通过 GET 或 POST 方式请求 public function index(RequestInterface $request) &#123; // 从请求中获得 id 参数 $id = $request-&gt;input('id', 1); // 转换 $id 为字符串格式并以 plain/text 的 Content-Type 返回 $id 的值给客户端 return (string)$id; &#125;&#125; 依赖自动注入依赖自动注入是 Hyperf 提供的一个非常强大的功能，也是保持框架灵活性的根基。Hyperf 提供了两种注入方式，一种是大家常见的通过构造函数注入，另一种是通过 @Inject 注解注入 通过构造函数注入只需在构造函数的参数内声明参数的类型，Hyperf 会自动注入对应的对象或值。 1234567891011121314151617181920212223242526272829303132&lt;?phpdeclare(strict_types=1);namespace App\\Controller;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\HttpServer\\Annotation\\AutoController;use App\\Service\\UserService;/** * @AutoController() */class IndexController&#123; /** * @var UserService */ private $userService; // 在构造函数声明参数的类型，Hyperf 会自动注入对应的对象或值 public function __construct(UserService $userService) &#123; $this-&gt;userService = $userService; &#125; // /index/info public function info(RequestInterface $request) &#123; $id = $request-&gt;input('id', 1); return $this-&gt;userService-&gt;getInfoById((int)$id); &#125;&#125; 通过 @Inject 注解注入只需对对应的类属性通过 @var 声明参数的类型，并使用 @Inject 注解标记属性 ，Hyperf 会自动注入对应的对象或值。 使用 @Inject 注解时需 use Hyperf\\Di\\Annotation\\Inject; 命名空间； 12345678910111213141516171819202122232425262728&lt;?phpdeclare(strict_types=1);namespace App\\Controller;use Hyperf\\HttpServer\\Contract\\RequestInterface;use Hyperf\\HttpServer\\Annotation\\AutoController;use Hyperf\\Di\\Annotation\\Inject;use App\\Service\\UserService;/** * @AutoController() */class IndexController&#123; /** * @Inject() * @var UserService */ private $userService; // /index/info public function info(RequestInterface $request) &#123; $id = $request-&gt;input('id', 1); return $this-&gt;userService-&gt;getInfoById((int)$id); &#125;&#125; 启动 Hyperf 服务由于 Hyperf 内置了协程服务器，也就意味着 Hyperf 将以 CLI 的形式去运行，所以在定义好路由及实际的逻辑代码之后，我们需要在项目根目录并通过命令行运行 php bin/hyperf.php start 来启动服务。 12345[root@caoxl hyperf-skeleton]# php bin/hyperf.php startDetected an available cache, skip the app scan process.Detected an available cache, skip the vendor scan process.[DEBUG] Event Hyperf\\Framework\\Event\\BootApplication handled by Hyperf\\Di\\Listener\\BootApplicationListener listener.... 当 Console 界面显示服务启动后便可通过 cURL 或 浏览器对服务正常发起访问了，默认服务会提供一个首页 http://127.0.0.1:9501/，对于本章示例引导的情况下，也就是上面的例子所对应的访问地址为 http://127.0.0.1:9501/index/info?id=1。 访问: http://caoxl.com:9501/ 1234&#123; method: \"GET\", message: \"Hello Hyperf.\"&#125; 重新加载代码由于 Hyperf 是持久化的 CLI 应用，也就意味着一旦进程启动，已解析的 PHP 代码会持久化在进程中，也就意味着启动服务后您再修改的 PHP 代码不会改变已启动的服务，如希望服务重新加载您修改后的代码，需要通过在启动的 Console 中键入 CTRL + C 终止服务，再重新执行启动命令完成重启和重新加载。 核心架构生命周期框架生命周期Hyperf 是运行于 Swoole 之上的，想要理解透彻 Hyperf 的生命周期，那么理解 Swoole 的生命周期也至关重要。Hyperf 的命令管理默认由 symfony/console 提供支持(如果您希望更换该组件您也可以通过改变 skeleton 的入口文件更换成您希望使用的组件)，在执行 php bin/hyperf.php start 后，将由 Hyperf\\Server\\Command\\StartServer 命令类接管，并根据配置文件 config/autoload/server.php 内定义的 Server 逐个启动。 123456789101112131415[DEBUG] Event Hyperf\\Framework\\Event\\BootApplication handled by Hyperf\\Di\\Listener\\BootApplicationListener listener.[DEBUG] Event Hyperf\\Framework\\Event\\BootApplication handled by Hyperf\\Config\\Listener\\RegisterPropertyHandlerListener listener.[DEBUG] Event Hyperf\\Framework\\Event\\BootApplication handled by Hyperf\\Paginator\\Listener\\PageResolverListener listener.[DEBUG] Event Hyperf\\Framework\\Event\\BeforeMainServerStart handled by Hyperf\\Amqp\\Listener\\BeforeMainServerStartListener listener.[DEBUG] Event Hyperf\\Framework\\Event\\BeforeMainServerStart handled by Hyperf\\Process\\Listener\\BootProcessListener listener.[DEBUG] Event Hyperf\\Framework\\Event\\OnStart handled by Hyperf\\Server\\Listener\\InitProcessTitleListener listener.[DEBUG] Event Hyperf\\Framework\\Event\\OnManagerStart handled by Hyperf\\Server\\Listener\\InitProcessTitleListener listener.[DEBUG] Event Hyperf\\Framework\\Event\\MainWorkerStart handled by Hyperf\\Amqp\\Listener\\MainWorkerStartListener listener.[INFO] Worker#0 started.[DEBUG] Event Hyperf\\Framework\\Event\\AfterWorkerStart handled by Hyperf\\Server\\Listener\\InitProcessTitleListener listener.[INFO] HTTP Server listening at 0.0.0.0:9501[DEBUG] Event Hyperf\\Framework\\Event\\AfterWorkerStart handled by Hyperf\\Server\\Listener\\AfterWorkerStartListener listener.[INFO] Worker#1 started.[DEBUG] Event Hyperf\\Framework\\Event\\AfterWorkerStart handled by Hyperf\\Server\\Listener\\InitProcessTitleListener listener.[DEBUG] Event Hyperf\\Framework\\Event\\AfterWorkerStart handled by Hyperf\\Server\\Listener\\AfterWorkerStartListener listener. 关于依赖注入容器的初始化工作，并没有由组件来实现，因为一旦交由组件来实现，这个耦合就会非常的明显，所以在默认的情况下，是由入口文件来加载 config/container.php 来实现的。 请求与协程生命周期Swoole 在处理每个连接时，会默认创建一个协程去处理，主要体现在 onRequest、onReceive、onConnect 事件，所以可以理解为每个请求都是一个协程，由于创建协程也是个常规操作，所以一个请求协程里面可能会包含很多个协程，同一个进程内协程之间是内存共享的，但调度顺序是非顺序的，且协程间本质上是相互独立的没有父子关系，所以对每个协程的状态处理都需要通过 协程上下文 来管理。 协程上下文由于同一个进程内协程间是内存共享的，但协程的执行/切换是非顺序的，也就意味着我们很难掌控当前的协程是哪一个(事实上可以，但通常没人这么干)，所以我们需要在发生协程切换时能够同时切换对应的上下文。 在 Hyperf 里实现协程的上下文管理将非常简单，基于 Hyperf\\Utils\\Context 类的 set(string $id, $value)、get(string $id, $default = null)、has(string $id)、override(string $id, \\Closure $closure) 静态方法即可完成上下文数据的管理，通过这些方法设置和获取的值，都仅限于当前的协程，在协程结束时，对应的上下文也会自动跟随释放掉，无需手动管理，无需担忧内存泄漏的风险。 Hyperf\\Utils\\Context::set()通过调用 set(string $id, $value) 方法储存一个值到当前协程的上下文中，如下： 123456&lt;?phpuse Hyperf\\Utils\\Context;// 将 bar 字符串以 foo 为 key 储存到当前协程上下文中$foo = Context::set('foo', 'bar');// set 方法会再将 value 作为方法的返回值返回回来，所以 $foo 的值为 bar Hyperf\\Utils\\Context::get()通过调用 get(string $id, $default = null) 方法可从当前协程的上下文中取出一个以 $id 为 key 储存的值，如不存在则返回 $default ，如下： 12345&lt;?phpuse Hyperf\\Utils\\Context;// 从当前协程上下文中取出 key 为 foo 的值，如不存在则返回 bar 字符串$foo = Context::get('foo', 'bar'); Hyperf\\Utils\\Context::has()通过调用 has(string $id) 方法可判断当前协程的上下文中是否存在以 $id 为 key 储存的值，如存在则返回 true，不存在则返回 false，如下： 12345&lt;?phpuse Hyperf\\Utils\\Context;// 从当前协程上下文中判断 key 为 foo 的值是否存在$foo = Context::has('foo'); Hyperf\\Utils\\Context::override() Override 方法仅可在 1.0.12 版本或更高版本使用 当我们需要做一些复杂的上下文处理，比如先判断一个 key 是否存在，如果存在则取出 value 来再对 value 进行某些修改，然后再将 value 设置回上下文容器中，此时会有比较繁杂的判断条件，可直接通过调用 override 方法来实现这个逻辑，如下： 12345678&lt;?phpuse Psr\\Http\\Message\\ServerRequestInterface;use Hyperf\\Utils\\Context;// 从协程上下文取出 $request 对象并设置 key 为 foo 的 Header，然后再保存到协程上下文中$request = Context::override(ServerRequestInterface::class, function (ServerRequestInterface $request) &#123; return $request-&gt;withAddedHeader('foo', 'bar');&#125;); 协程概念Hyperf 是运行于 Swoole 4 的协程之上的，这也是 Hyperf 能提供高性能的其中一个很大的因素。 Hyperf 协程Swoole 协程 配置安装1composer require hyperf/config 配置文件结构以下结构仅为 Hyperf-Skeleton 所提供的默认配置的情况下的结构，实际情况由于依赖或使用的组件的差异，文件会有差异。 123456789101112131415161718192021222324config├── autoload // 此文件夹内的配置文件会被配置组件自己加载，并以文件夹内的文件名作为第一个键值│ ├── amqp.php // 用于管理 AMQP 组件│ ├── annotations.php // 用于管理注解│ ├── apollo.php // 用于管理基于 Apollo 实现的配置中心│ ├── aspects.php // 用于管理 AOP 切面│ ├── async_queue.php // 用于管理基于 Redis 实现的简易队列服务│ ├── cache.php // 用于管理缓存组件│ ├── commands.php // 用于管理自定义命令│ ├── consul.php // 用于管理 Consul 客户端│ ├── databases.php // 用于管理数据库客户端│ ├── devtool.php // 用于管理开发者工具│ ├── exceptions.php // 用于管理异常处理器│ ├── listeners.php // 用于管理事件监听者│ ├── logger.php // 用于管理日志│ ├── middlewares.php // 用于管理中间件│ ├── opentracing.php // 用于管理调用链追踪│ ├── processes.php // 用于管理自定义进程│ ├── redis.php // 用于管理 Redis 客户端│ └── server.php // 用于管理 Server 服务├── config.php // 用于管理用户或框架的配置，如配置相对独立亦可放于 autoload 文件夹内├── container.php // 负责容器的初始化，作为一个配置文件运行并最终返回一个 Psr\\Container\\ContainerInterface 对象├── dependencies.php // 用于管理 DI 的依赖关系和类对应关系└── routes.php // 用于管理路由 设置配置只需在 config/config.php 与 config/autoload/server.php 与 autoload 文件夹内的配置，都能在服务启动时被扫描并注入到 Hyperf\\Contract\\ConfigInterface 对应的对象中，这个流程是由 Hyperf\\Config\\ConfigFactory 在 Config 对象实例化时完成的。 获取配置Config 组件提供了三种方式获取配置， 通过 Hyperf\\Config\\Config 对象获取 12345/** * @var \\Hyperf\\Contract\\ConfigInterface */// 通过 get(string $key, $default): mixed 方法获取 $key 所对应的配置，$key 值可以通过 . 连接符定位到下级数组，$default 则是当对应的值不存在时返回的默认值$config-&gt;get($key，$default); 通过 @Value 注解获取 123456789101112class IndexController&#123; /** * @Value(\"config.key\") */ private $configValue; public function index() &#123; return $this-&gt;configValue; &#125;&#125; 通过 config(string $key, $default) 函数获取。 在任意地方可以通过 config(string $key, $default) 函数获取对应的配置，但这样的使用方式也就意味着您对 hyperf/config 和 hyperf/utils 组件是强依赖的。 判断配置是否存在12345/** * @var \\Hyperf\\Contract\\ConfigInterface */// 通过 has(): bool 方法判断对应的 $key 值是否存在于配置中，$key 值可以通过 . 连接符定位到下级数组$config-&gt;has($key); 环境变量读取环境变量1234// config/config.phpreturn [ 'app_name' =&gt; env('APP_NAME', 'Hyperf Skeleton'),]; 注解什么是注解? 什么是注释？在解释注解之前我们需要先定义一下 注解 与 注释 的区别： 注释: 给程序员看，帮助理解代码，对代码起到解释、说明的作用。 注解: 给应用程序看，用于元数据的定义，单独使用时没有任何作用，需配合应用程序对其元数据进行利用才有作用。 注解解析如何实现？Hyperf 使用了 doctrine/annotations 包来对代码内的注解进行解析，注解必须写在下面示例的标准注释块才能被正确解析，其它格式均不能被正确解析。 注释块示例： 123/** * @AnnotationClass() */ 注解是如何发挥作用的？我们有说到注解只是元数据的定义，需配合应用程序才能发挥作用，在 Hyperf 里，注解内的数据会被收集到 Hyperf\\Di\\Annotation\\AnnotationCollector 类供应用程序使用，当然根据您的实际情况，也可以收集到您自定义的类去，随后在这些注解本身希望发挥作用的地方对已收集的注解元数据进行读取和利用，以达到期望的功能实现。 忽略某些注解我们可以通过在 config/autoload/annotations.php 内将相关注解设置为忽略。 12345678return [ 'scan' =&gt; [ // ignore_annotations 数组内的注解都会被注解扫描器忽略 'ignore_annotations' =&gt; [ 'mixin', ], ],]; 使用注解注解一共有3种应用对象，分别是 类、类方法 和 类属性。 使用类注解类注解定义是在 class 关键词上方的注释块内，比如常用的 @Controller 和 @AutoController 就是类注解的使用典范，下面的代码示例则为一个正确使用类注解的示例，表明 @ClassAnnotation 注解应用于 Foo 类。 1234/** * @ClassAnnotation() */class Foo &#123;&#125; 使用类方法注解类方法注解定义是在方法上方的注释块内，比如常用的 @RequestMapping 就是类方法注解的使用典范，下面的代码示例则为一个正确使用类方法注解的示例，表明 @MethodAnnotation 注解应用于 Foo::bar() 方法。 12345678910class Foo&#123; /** * @MethodAnnotation() */ public function bar() &#123; // some code &#125;&#125; 使用类属性注解类属性注解定义是在属性上方的注释块内，比如常用的 @Value 和 @Inject 就是类属性注解的使用典范，下面的代码示例则为一个正确使用类属性注解的示例，表明 @PropertyAnnotation 注解应用于 Foo 类的 $bar 属性。 1234567class Foo&#123; /** * @PropertyAnnotation() */ private $bar;&#125; 注解参数传递 传递主要的单个参数 @DemoAnnotation(&quot;value&quot;) 传递字符串参数 @DemoAnnotation(key1=&quot;value1&quot;, key2=&quot;value2&quot;) 传递数组参数 @DemoAnnotation(key={&quot;value1&quot;, &quot;value2&quot;}) 自定义注解1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Annotation;use Hyperf\\Di\\Annotation\\AbstractAnnotation;/** * Class Bar * @package App\\Annotation * @Annotation * @Target(&#123;\"METHOD\", \"PROPERTY\"&#125;) */class Bar extends AbstractAnnotation&#123; // some code&#125;/** * Class Foo * @package App\\Annotation * @Target(\"CLASS\") */class Foo extends AbstractAnnotation&#123; // some code&#125; 注意注解类的 @Annotation 和 @Target 注解为全局注解，无需 use 其中 @Target 有如下参数： METHOD 注解允许定义在类方法上 PROPERTY 注解允许定义在类属性上 CLASS 注解允许定义在类上 ALL 注解允许定义在任何地方 自定义注解收集器注解的收集时具体的执行流程也是在注解类内实现的，相关的方法由 Hyperf\\Di\\Annotation\\AnnotationInterface 约束着，该接口类要求了下面 3 个方法的实现，您可以根据自己的需求实现对应的逻辑： public function collectClass(string $className): void; 当注解定义在类时被扫描时会触发该方法 public function collectMethod(string $className, ?string $target): void; 当注解定义在类方法时被扫描时会触发该方法 public function collectProperty(string $className, ?string $target): void; 当注解定义在类属性时被扫描时会触发该方法 依赖注入安装该组件默认存在 hyperf-skeleton 项目中并作为主要组件存在，如希望在其它框架内使用该组件可通过下面的命令安装。 1composer require hyperf/di 事件机制事件模式必须基于 PSR-14 去实现。Hyperf 的事件管理器默认由 hyperf/event 实现，该组件亦可用于其它框架或应用，只需通过 Composer 将该组件引入即可。 1composer require hyperf/event 事件模式是一种经过了充分测试的可靠机制，是一种非常适用于解耦的机制，分别存在以下 3 种角色： 事件(Event) 是传递于应用代码与 监听器(Listener) 之间的通讯对象 监听器(Listener) 是用于监听 事件(Event) 的发生的监听对象 事件调度器(EventDispatcher) 是用于触发 事件(Event) 和管理 监听器(Listener) 与 事件(Event) 之间的关系的管理者对象 常见问题Swoole 短名未关闭 [ERROR] Swoole short name have to disable before start server, please set swoole.use_shortname = ‘Off’ into your php.ini. 1234567// 这些都是错误的，注意 `大小写` 和 `引号`swoole.use_shortname = 'off' // 经测试这样也可以swoole.use_shortname = offswoole.use_shortname = Off// 下面的才是正确的swoole.use_shortname = 'Off' 不能通过全局变量获取属性参数在 PHP-FPM 下可以通过全局变量获取到请求的参数，服务器的参数等，在 Hyperf 和 Swoole 内，都 无法 通过 $_GET/$_POST/$_REQUEST/$_SESSION/$_COOKIE/$_SERVER等$_开头的变量获取到任何属性参数。 参考 Hyperf","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"},{"name":"Hyperf","slug":"Hyperf","permalink":"http://blog.caoxl.com/tags/Hyperf/"}]},{"title":"Shell脚本 学习日志","slug":"Shell-Learning-Notes","date":"2019-10-10T02:40:32.000Z","updated":"2019-10-10T06:44:09.000Z","comments":true,"path":"2019/10/10/Shell-Learning-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/10/10/Shell-Learning-Notes/","excerpt":"什么是Shell脚本?","text":"什么是Shell脚本? 示例打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。 12345678#!/bin/shcd ~mkdir shell_testcd shell_testfor ((i=0; i&lt;10; i++)); do touch test_$i.txtdone 示例解释 第1行: 指定脚本解释器, 这里用/bin/sh做解释器的 第2行: 切换到当前用户的home目录 第3行: 创建一个目录 shell_test 第4行: 切换到shell_test目录 第5行: 循环条件, 一共循环10次 第6行: 创建一个test_0…9.txt文件 第7行: 循环体 结束 “#!” 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。 示例结果123456[root@caoxl ~]# lsshell_test[root@caoxl ~]# cd shell_test/[root@caoxl shell_test]# lstest_0.txt test_2.txt test_4.txt test_6.txt test_8.txttest_1.txt test_3.txt test_5.txt test_7.txt test_9.txt Shell和Shell脚本的概念 shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。shell脚本（shell script） ，是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。 Shell编程环境shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 脚本解释器sh即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。 bashBash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。 在CentOS里，/bin/sh是一个指向/bin/bash的符号链接: 1234[root@caoxl ~]# ls -l /bin/*sh-rwxr-xr-x 1 root root 964544 Apr 11 2018 /bin/bash-rws--x--x 1 root root 23960 Oct 31 2018 /bin/chshlrwxrwxrwx 1 root root 4 Nov 22 2018 /bin/sh -&gt; bash 但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右: 1234567-r-xr-xr-x 1 root wheel 623344 9 30 04:28 /bin/bash-rwxr-xr-x 1 root wheel 528688 9 30 04:28 /bin/csh-rwxr-xr-x 1 root wheel 110848 9 30 04:28 /bin/dash-r-xr-xr-x 1 root wheel 1300128 9 30 04:28 /bin/ksh-rwxr-xr-x 1 root wheel 31440 9 30 04:28 /bin/sh-rwxr-xr-x 1 root wheel 528688 9 30 04:28 /bin/tcsh-rwxr-xr-x 1 root wheel 633328 9 30 04:28 /bin/zsh 运行Shell脚本的方法作为可执行程序12chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本 作为解释器参数直接运行解释器，其参数就是 shell 脚本的文件名，如： 12/bin/sh test.sh/bin/php test.php Shell 基础Shell 变量定义变量定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如： 1var=\"bar\" 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（查看保留关键字） 使用变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=\"caoxl\"echo $your_nameecho $&#123;your_name&#125; 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 1234#!/bin/bashmyUrl=\"http://www.google.com\"readonly myUrlmyUrl=\"http://www.caoxl.com\" 删除变量使用 unset 命令可以删除变量。语法： 1unset variable_name Shell 字符串字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号1str='this is a string' 双引号123your_name='caoxl'str=\"Hello, I know you are \\\"$your_name\\\"! \\n\"echo -e $str 双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串1234567891011your_name=\"caoxl\"# 使用双引号拼接greeting=\"hello, \"$your_name\" !\"greeting_1=\"hello, $&#123;your_name&#125; !\"echo $greeting $greeting_1# 使用单引号拼接greeting_2='hello, '$your_name' !'greeting_3='hello, $&#123;your_name&#125; !'echo $greeting_2 $greeting_3 获取字符串长度12string=\"abcd\"echo $&#123;#string&#125; #输出 4 提取子字符串以下实例从字符串第 2 个字符开始截取 4 个字符： 12string=\"caoxl is a great site\"echo $&#123;string:1:4&#125; # 输出 aoxl Shell 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。 定义数组在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为： 1234567891011121314151617数组名=(值1 值2 ... 值n)// 例如:array_name=(value0 value1 value2 value3)// 或者:array_name=(value0value1value2value3)// 还可以单独定义数组的各个分量：array_name[0]=value0array_name[1]=value1array_name[n]=valuen 读取数组读取数组元素值的一般格式是： 1234$&#123;数组名[下标]&#125;// 例如:valuen=$&#123;array_name[n]&#125; 使用 @ 符号可以获取数组中的所有元素，例如： 1echo $&#123;array_name[@]&#125; 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如： 12345678# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; Shell注释以 # 开头的行就是注释，会被解释器忽略。 通过每一行加一个 # 号设置多行注释，像这样： 12345678910111213#--------------------------------------------# 这是一个注释# author：caoxl# site：www.caoxl.com# slogan：keep calm and think more !#--------------------------------------------##### 用户配置区 开始 ######## 这里可以添加脚本描述信息# ###### 用户配置区 结束 ##### 多行注释多行注释还可以使用以下格式： 12345:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF EOF 也可以使用其他符号: 12345678910111213:&lt;&lt;'注释内容...注释内容...注释内容...'// 或者:&lt;&lt;!注释内容...注释内容...注释内容...! Shell 传递参数我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 123456789#!/bin/bash# author:caoxl# url:www.caoxl.comecho \"Shell 传递参数实例！\";echo \"执行的文件名：$0\";echo \"第一个参数为：$1\";echo \"第二个参数为：$2\";echo \"第三个参数为：$3\"; 为脚本设置可执行权限，并执行脚本，输出结果如下所示： 12345678[root@caoxl shell]# vi params.sh[root@caoxl shell]# chmod +x params.sh [root@caoxl shell]# ./params.sh 1 2 3Shell 传递参数实例！执行的文件名：./params.sh第一个参数为：1第二个参数为：2第三个参数为：3 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。 $- 显示Shell使用的当前选项 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 123456789#!/bin/bash# author:caoxl# url:www.caoxl.comecho \"Shell 传递参数实例！\";echo \"第一个参数为：$1\";echo \"参数个数为：$#\";echo \"传递的参数作为一个字符串显示：$*\"; 执行脚本，输出结果如下所示： 123456[root@caoxl shell]# chmod +x params2.sh [root@caoxl shell]# ./params2.sh 1 2 3Shell 传递参数实例！第一个参数为：1参数个数为：3传递的参数作为一个字符串显示：1 2 3 Shell 函数linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。 shell中函数的定义格式如下： 123456789[ function ] funname [()]&#123; action; [return int;]&#125; 说明: 可以带 function fun() 定义，也可以直接 fun() 定义,不带任何参数。 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255 Shell 输入/输出重定向 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt;tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。 参考 Shell脚本：Linux Shell脚本学习指南（超详细）","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://blog.caoxl.com/tags/Shell/"}]},{"title":"JWT 完整使用详解","slug":"JWT-Full-Use-Details","date":"2019-10-08T03:16:26.000Z","updated":"2019-10-09T10:34:05.000Z","comments":true,"path":"2019/10/08/JWT-Full-Use-Details/","link":"","permalink":"http://blog.caoxl.com/2019/10/08/JWT-Full-Use-Details/","excerpt":"假期综合征, 需要找一个东西复习复习找回一下PHPer的感觉 JWT 全称 JSON Web Tokens ，是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。它的两大使用场景是：认证和数据交换。","text":"假期综合征, 需要找一个东西复习复习找回一下PHPer的感觉 JWT 全称 JSON Web Tokens ，是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。它的两大使用场景是：认证和数据交换。 原文地址: JWT 完整使用详解 安装及基础配置Laravel使用 composer 安装12# 建议使用1.0以上版本composer require tymon/jwt-auth 1.*@rc 进行一些配置这里指的注意的是，有些文档会说要添加 Tymon\\JWTAuth\\Providers\\LaravelServiceProvider::class ，这只在 Laravel 5.4 及以下版本是必要的，更新的 Laravel 版本无需添加。 还有一些文档说要添加 Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider 这是很久以前的 JWT 版本的（大概 0.5.3 以前的版本）。 发布配置文件12# 这条命令会在 config 下增加一个 jwt.php 的配置文件php artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\LaravelServiceProvider\" 生成加密密钥12# 这条命令会在 .env 文件下生成一个加密密钥，如：JWT_SECRET=foobarphp artisan jwt:secret 更新你的模型如果你使用默认的 User 表来生成 token，你需要在该模型下增加一段代码 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App;use Tymon\\JWTAuth\\Contracts\\JWTSubject;use Illuminate\\Notifications\\Notifiable;use Illuminate\\Foundation\\Auth\\User as Authenticatable;class User extends Authenticatable implements JWTSubject # 这里别忘了加&#123; use Notifiable; // Rest omitted for brevity /** * Get the identifier that will be stored in the subject claim of the JWT. * * @return mixed */ public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; /** * Return a key value array, containing any custom claims to be added to the JWT. * * @return array */ public function getJWTCustomClaims() &#123; return []; &#125;&#125; 注册两个 Facade这两个 Facade 并不是必须的，但是使用它们会给你的代码编写带来一点便利。 config/app.php 123456'aliases' =&gt; [ ... // 添加以下两行 'JWTAuth' =&gt; Tymon\\JWTAuth\\Facades\\JWTAuth::class, 'JWTFactory' =&gt; Tymon\\JWTAuth\\Facades\\JWTFactory::class,], 如果你不使用这两个 Facade，你可以使用辅助函数 auth () auth () 是一个辅助函数，返回一个 guard，暂时可以看成 Auth Facade。 了解更多: Laravel 辅助函数 auth 与 JWT 扩展详解 12345// 如果你不用 Facade，你可以这么写auth('api')-&gt;refresh();// 用 JWTAuth FacadeJWTAuth::parseToken()-&gt;refresh(); 两个 Facede 常用可使用方法，可以看文章后面的附录。 修改 auth.php config/auth.php 1234567891011'guards' =&gt; [ 'web' =&gt; [ 'driver' =&gt; 'session', 'provider' =&gt; 'users', ], 'api' =&gt; [ 'driver' =&gt; 'jwt', // 原来是 token 改成jwt 'provider' =&gt; 'users', ],], 注册一些路由注意：在 Laravel 下，route/api.php 中的路由默认都有前缀 api 。 123456789101112Route::group([ 'prefix' =&gt; 'auth'], function ($router) &#123; Route::post('login', 'AuthController@login'); Route::post('logout', 'AuthController@logout'); Route::post('refresh', 'AuthController@refresh'); Route::post('me', 'AuthController@me');&#125;); 创建 token 控制器1php artisan make:controller AuthController AuthController 值得注意的是 Laravel 这要用 auth(&#39;api&#39;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Support\\Facades\\Auth;use App\\Http\\Controllers\\Controller;class AuthController extends Controller&#123; /** * Create a new AuthController instance. * 要求附带email和password（数据来源users表） * * @return void */ public function __construct() &#123; // 这里额外注意了：官方文档样例中只除外了『login』 // 这样的结果是，token 只能在有效期以内进行刷新，过期无法刷新 // 如果把 refresh 也放进去，token 即使过期但仍在刷新期以内也可刷新 // 不过刷新一次作废 $this-&gt;middleware('auth:api', ['except' =&gt; ['login']]); // 另外关于上面的中间件，官方文档写的是『auth:api』 // 但是我推荐用 『jwt.auth』，效果是一样的，但是有更加丰富的报错信息返回 &#125; /** * Get a JWT via given credentials. * * @return \\Illuminate\\Http\\JsonResponse */ public function login() &#123; $credentials = request(['email', 'password']); if (! $token = auth('api')-&gt;attempt($credentials)) &#123; return response()-&gt;json(['error' =&gt; 'Unauthorized'], 401); &#125; return $this-&gt;respondWithToken($token); &#125; /** * Get the authenticated User. * * @return \\Illuminate\\Http\\JsonResponse */ public function me() &#123; return response()-&gt;json(auth('api')-&gt;user()); &#125; /** * Log the user out (Invalidate the token). * * @return \\Illuminate\\Http\\JsonResponse */ public function logout() &#123; auth('api')-&gt;logout(); return response()-&gt;json(['message' =&gt; 'Successfully logged out']); &#125; /** * Refresh a token. * 刷新token，如果开启黑名单，以前的token便会失效。 * 值得注意的是用上面的getToken再获取一次Token并不算做刷新，两次获得的Token是并行的，即两个都可用。 * @return \\Illuminate\\Http\\JsonResponse */ public function refresh() &#123; return $this-&gt;respondWithToken(auth('api')-&gt;refresh()); &#125; /** * Get the token array structure. * * @param string $token * * @return \\Illuminate\\Http\\JsonResponse */ protected function respondWithToken($token) &#123; return response()-&gt;json([ 'access_token' =&gt; $token, 'token_type' =&gt; 'bearer', 'expires_in' =&gt; auth('api')-&gt;factory()-&gt;getTTL() * 60 ]); &#125;&#125; Lumen使用 composer 安装上面是用命令行安装的，这里用 composer.json 安装。 12// 我当时可用的版本是这个\"tymon/jwt-auth\": \"1.*@rc\" 执行 1composer update 进行一些配置开启 Facade 和 Eloquent取消以下行的注释。 bootstrap/app.php 123// $app-&gt;withFacades();// $app-&gt;withEloquent(); 开启中间件认证取消以下行的注释。 bootstrap/app.php 12345// $app-&gt;routeMiddleware([// 'auth' =&gt; App\\Http\\Middleware\\Authenticate::class,// ]);// $app-&gt;register(App\\Providers\\AuthServiceProvider::class); 添加服务提供者 bootstrap/app.php 12// 有些文档里是说添加 Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class，那是旧版本的$app-&gt;register(\\Tymon\\JWTAuth\\Providers\\LumenServiceProvider::class); 生成加密密钥这条命令会在 .env 文件下生成一个加密密钥，如：JWT_SECRET=foobar 1php artisan jwt:secret 更新你的模型如果你使用默认的 User 表来生成 token，你需要在该模型下增加一段代码 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App;use Illuminate\\Auth\\Authenticatable;use Laravel\\Lumen\\Auth\\Authorizable;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Contracts\\Auth\\Authenticatable as AuthenticatableContract;use Illuminate\\Contracts\\Auth\\Access\\Authorizable as AuthorizableContract;use Tymon\\JWTAuth\\Contracts\\JWTSubject;class User extends Model implements AuthenticatableContract, AuthorizableContract, JWTSubject&#123; use Authenticatable, Authorizable; ... /** * Get the identifier that will be stored in the subject claim of the JWT. * * @return mixed */ public function getJWTIdentifier() &#123; return $this-&gt;getKey(); &#125; /** * Return a key value array, containing any custom claims to be added to the JWT. * * @return array */ public function getJWTCustomClaims() &#123; return []; &#125;&#125; 注册两个 FacadeLumen 中没有辅助函数 auth ()，这两个 Facade 就挺有用了。 bootstrap/app.php 把原先去了注释的那一行再改一下。 1234$app-&gt;withFacades(true, [ 'Tymon\\JWTAuth\\Facades\\JWTAuth' =&gt; 'JWTAuth', 'Tymon\\JWTAuth\\Facades\\JWTFactory' =&gt; 'JWTFactory',]); 设置 auth.php把 \\vendor\\laravel\\lumen-framework\\config\\auth.php 也复制到 项目根目录 config 文件夹（没有就新建）。 auth.php 1234567891011121314'guards' =&gt; [ 'api' =&gt; [ 'driver' =&gt; 'jwt', 'provider' =&gt; 'users', ],],...'providers' =&gt; [ 'users' =&gt; [ 'driver' =&gt; 'eloquent', 'model' =&gt; \\App\\User::class] 注册一些路由123456789101112Route::group([ 'prefix' =&gt; 'auth'], function ($router) &#123; Route::post('login', 'AuthController@login'); Route::post('logout', 'AuthController@logout'); Route::post('refresh', 'AuthController@refresh'); Route::post('me', 'AuthController@me');&#125;); 创建 token 控制器Lumen 还精简了很多辅助函数，比如 auth 和 bcrypt 等。 可以安装 cosmicvelocity/lumen-helpers 或 albertcht/lumen-helpers 补全（建议用后者，更好安装） AuthController.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use Tymon\\JWTAuth\\Facades\\JWTAuth;class AuthController extends Controller&#123; /** * Create a new AuthController instance. * * @return void */ public function __construct() &#123; // 这里额外注意了：官方文档样例中只除外了『login』 // 这样的结果是，token 只能在有效期以内进行刷新，过期无法刷新 // 如果把 refresh 也放进去，token 即使过期但仍在刷新期以内也可刷新 // 不过刷新一次作废 $this-&gt;middleware('auth:api', ['except' =&gt; ['login']]); // 另外关于上面的中间件，官方文档写的是『auth:api』 // 但是我推荐用 『jwt.auth』，效果是一样的，但是有更加丰富的报错信息返回 &#125; /** * Get a JWT via given credentials. * * @return \\Illuminate\\Http\\JsonResponse */ public function login(Request $request) &#123; $credentials = $request-&gt;only('email', 'password'); if (! $token = JWTAuth::attempt($credentials)) &#123; return response()-&gt;json(['error' =&gt; 'Unauthorized'], 401); &#125; return $this-&gt;respondWithToken($token); &#125; /** * Get the authenticated User. * * @return \\Illuminate\\Http\\JsonResponse */ public function me() &#123; return response()-&gt;json(JWTAuth::parseToken()-&gt;touser()); &#125; /** * Log the user out (Invalidate the token). * * @return \\Illuminate\\Http\\JsonResponse */ public function logout() &#123; JWTAuth::parseToken()-&gt;invalidate(); return response()-&gt;json(['message' =&gt; 'Successfully logged out']); &#125; /** * Refresh a token. * * @return \\Illuminate\\Http\\JsonResponse */ public function refresh() &#123; return $this-&gt;respondWithToken(JWTAuth::parseToken()-&gt;refresh()); &#125; /** * Get the token array structure. * * @param string $token * * @return \\Illuminate\\Http\\JsonResponse */ protected function respondWithToken($token) &#123; return response()-&gt;json([ 'access_token' =&gt; $token, 'token_type' =&gt; 'bearer', 'expires_in' =&gt; JWTAuth::factory()-&gt;getTTL() * 60 ]); &#125;&#125; JWT Token 详解token 的组成、创建以及解析组成一个 JWT token 是一个字符串，它由三部分组成，头部、载荷与签名，中间用 . 分隔，例如：xxxxx.yyyyy.zzzzz 头部（Header）头部通常由两部分组成：令牌的类型（即 JWT）和正在使用的签名算法（如 HMAC SHA256 或 RSA.）。 例如： 1234&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; 然后用 Base64Url 编码得到头部，即 xxxxx。 载荷（Payload）载荷中放置了 token 的一些基本信息，以帮助接受它的服务器来理解这个 token。同时还可以包含一些自定义的信息，用户信息交换。 载荷的属性也分三类： 预定义 (Registered) 公有 (Public) 私有 (Private) 预定义的载荷123456789&#123; \"sub\": \"1\", \"iss\": \"http://localhost:8000/auth/login\", \"iat\": 1651888119, \"exp\": 1654516119, \"nbf\": 1651888119, \"jti\": \"37c107e4609ddbcc9c096ea5ee76c667\", \"aud\": \"dev\"&#125; 这里面的前 7 个字段都是由官方所定义的，也就是预定义（Registered claims）的，并不都是必需的。 iss (issuer): 签发人 sub (subject): 主题 aud (audience): 受众 exp (expiration time): 过期时间 nbf (Not Before): 生效时间, 在此之前是无效的 iat (Issued At): 签发时间 jti (JWT ID): 编号 公有的载荷在使用 JWT 时可以额外定义的载荷。为了避免冲突，应该使用 IANA JSON Web Token Registry 中定义好的，或者给额外载荷加上类似命名空间的唯一标识。 私有的载荷在信息交互的双方之间约定好的，既不是预定义载荷也不是公有载荷的一类载荷。这一类载荷可能会发生冲突，所以应该谨慎使用。 将上面的 json 进行 Base64Url 编码得到载荷，，即 yyyyy。 签名（Signature）签名时需要用到前面编码过的两个字符串，如果以 HMACSHA256 加密，就如下： 12345HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret) 加密后再进行 base64url 编码最后得到的字符串就是 token 的第三部分 zzzzz。 组合便可以得到 token：xxxxx.yyyyy.zzzzz。 签名的作用：保证 JWT 没有被篡改过，原理如下： HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先共享的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。 Hash-based Message Authentication Code PHP 代码示例 123456// 这里要开启true$zzzzz = $this-&gt;base64url_encode(hash_hmac('sha256', 'xxxxx.yyyyy', getenv('JWT_SECRET'), true));protected function base64url_encode($data) &#123; return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');&#125; 创建前面的 AuthController.php 中有两行展现了这一种 token 的创建方法，即用用户所给的账号和密码进行尝试，密码正确则用对应的 User 信息返回一个 token 。 但 token 的创建方法不止这一种，接下来介绍 token 的三种创建方法： 基于账密参数 基于 users 模型返回的实例 基于 users 模型中的用户主键ID 基于账密参数这就是刚刚说的那一种，贴出具体代码。 1234567// 使用辅助函数$credentials = request(['email', 'password']); $token = auth()-&gt;attempt($credentials)// 使用 Facade$credentials = $request-&gt;only('email', 'password');$token = JWTAuth::attempt($credentials); 基于 users 模型返回的实例1234567// 使用辅助函数$user = User::first();$token = auth()-&gt;login($user);// 使用 Facade$user = User::first();$token = JWTAuth::fromUser($credentials); 基于 users 模型中的主键 id12345// 使用辅助函数$token = auth()-&gt;tokenById(1);// 使用 Facade源码中没找到 解析解析 token 到对象只有 Facade 需要这样。 12// 把请求发送过来的直接解析到对象JWTAuth::parseToken(); 获取 token 中的 user 信息12345// 辅助函数$user = auth()-&gt;user();// Facade$user = JWTAuth::parseToken()-&gt;authenticate(); 获取 token如果 token 被设置则会返回，否则会尝试使用方法从请求中解析 token ，如果 token 未被设置或不能解析最终返回 false。 12345// 辅助函数$token = auth()-&gt;getToken();// Facade$token = JWTAuth::parseToken()-&gt;getToken(); 如果是前端直接 base64 解码 token 的前两段即可以知道所需的信息。 载荷的设置和获取载荷设置载荷信息会在 token 解码时得到，同时越大的数组会生成越长的 token ，所以不建议放太多的数据。同时因为载荷是用 Base64Url 编码，所以相当于明文，因此绝对不能放密码等敏感信息。 1234567891011121314151617$customClaims = ['foo' =&gt; 'bar', 'baz' =&gt; 'bob'];// 辅助函数$token = auth()-&gt;claims($customClaims)-&gt;attempt($credentials);// Facade - 1$token = JWTAuth::claims($customClaims)-&gt;attempt($credentials);--- 下面两种试了好像不行，不过前面的够用了// Facade - 2$payload = JWTFactory::make($customClaims);$token = JWTAuth::encode($payload);// Facade - 3$payload = JWTFactory::sub(123)-&gt;aud('foo')-&gt;foo(['bar' =&gt; 'baz'])-&gt;make();$token = JWTAuth::encode($payload); 载荷解析从请求中把载荷解析出来。可以去看扩展源代码，里面还有很多的方法。 123456789101112131415// 辅助函数$exp = auth()-&gt;payload()-&gt;get('exp');$json = auth()-&gt;payload()-&gt;toJson();$array = auth()-&gt;payload()-&gt;jsonSerialize();$sub = $array['sub'];// Facade - 1$payload = JWTAuth::parseToken()-&gt;getPayload();$payload-&gt;get('sub'); // = 123$payload['jti']; // = 'asfe4fq434asdf'$payload('exp') // = 123456$payload-&gt;toArray(); // = ['sub' =&gt; 123, 'exp' =&gt; 123456, 'jti' =&gt; 'asfe4fq434asdf'] etc// Facade - 2$exp = JWTAuth::parseToken()-&gt;getClaim('exp'); token 的三个时间一个 token 一般来说有三个时间属性，其配置都在 config/jwt.php 内。 有效时间有效时间指的的是你获得 token 后，在多少时间内可以凭这个 token 去获取内容，逾时无效。 12// 单位：分钟'ttl' =&gt; env('JWT_TTL', 60) 刷新时间刷新时间指的是在这个时间内可以凭旧 token 换取一个新 token。例如 token 有效时间为 60 分钟，刷新时间为 20160 分钟，在 60 分钟内可以通过这个 token 获取新 token，但是超过 60 分钟是不可以的，然后你可以一直循环获取，直到总时间超过 20160 分钟，不能再获取。 12// 单位：分钟'refresh_ttl' =&gt; env('JWT_REFRESH_TTL', 20160) 宽限时间宽限时间是为了解决并发请求的问题，假如宽限时间为 0s ，那么在新旧 token 交接的时候，并发请求就会出错，所以需要设定一个宽限时间，在宽限时间内，旧 token 仍然能够正常使用。 12345// 宽限时间需要开启黑名单（默认是开启的），黑名单保证过期token不可再用，最好打开'blacklist_enabled' =&gt; env('JWT_BLACKLIST_ENABLED', true)// 设定宽限时间，单位：秒'blacklist_grace_period' =&gt; env('JWT_BLACKLIST_GRACE_PERIOD', 60) 关于 JWT 的讨论为什么用 JWT？ JWT 超详细分析 token 的刷新问题？token 为什么要刷新？首先 Basic Auth 是一种最简单的认证方法，但是由于每次请求都带用户名和密码，频繁的传输肯定不安全，所以才有 cookies 和 session 的运用。如果 token 不刷新，那么 token 就相当于上面的 用户名 + 密码，只要获取到了，就可以一直盗用，因此 token 设置有效期并能够进行刷新是必要的。 token 有效期多久合适，刷新频率多久合适？有效期越长，风险性越高，有效性越短，刷新频率越高，刷新就会存在刷新开销，所以这需要综合考虑。而且 web 端应该设置为分钟级和小时级，而移动端应该设置为天级和周级。 附录JWT 的 两个 FacadeJWTAuthJWTAuth::parseToken()-&gt;方法() 一般都可以换成 auth()-&gt;方法()。 token 生成attempt 根据 user 账密新建一个 token。 12$credentials = $request-&gt;only('email', 'password');$token = JWTAuth::attempt($credentials)； fromUser or fromSubject 根据 user 对象生成一个 token。后者是前者别名。 12$user = User::find(1);$token = JWTAuth::fromUser($user); token 控制refresh 更新 token。 1$newToken = JWTAuth::parseToken()-&gt;refresh(); invalidate 让一个 token 无效。 1JWTAuth::parseToken()-&gt;invalidate(); check 检验 token 的有效性。 123if(JWTAuth::parseToken()-&gt;check()) &#123; dd(\"token是有效的\");&#125; token 解析authenticate or toUser or user 这三个效果是一样的，toUser 是 authenticate 的别名，而 user 比前两者少一个 user id 的校验，但并没有什么影响。 1$user = JWTAuth::parseToken()-&gt;toUser(); parseToken 从 request 中解析 token 到对象中，以便进行下一步操作。 getToken 从 request 中获取 token。 1$token = JWTAuth::getToken(); // 这个不用 parseToken ，因为方法内部会自动执行一次 JWTGuard这个 Facade 主要进行载荷的管理，返回一个载荷对象，然后可以通过 JWTAuth 来对其生成一个 token。 123// 载荷的高度自定义$payload = JWTFactory::sub(123)-&gt;aud('foo')-&gt;foo(['bar' =&gt; 'baz'])-&gt;make();$token = JWTAuth::encode($payload); 123$customClaims = ['foo' =&gt; 'bar', 'baz' =&gt; 'bob'];$payload = JWTFactory::make($customClaims);$token = JWTAuth::encode($payload); 参考 JWT Wiki JWT 官方安装指导文档 JWT 超详细分析 JWT 完整使用详解 JWT 的介绍","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://blog.caoxl.com/tags/JWT/"}]},{"title":"Uni-App 学习日志","slug":"Uni-App-Learning-Log","date":"2019-09-30T10:24:57.000Z","updated":"2019-10-15T06:56:08.000Z","comments":true,"path":"2019/09/30/Uni-App-Learning-Log/","link":"","permalink":"http://blog.caoxl.com/2019/09/30/Uni-App-Learning-Log/","excerpt":"uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。","text":"uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。 快速上手通过 HBuilderX 可视化界面 通过 HBuilderX 可视化界面捆绑性太强, 不建议使用这种方法. 通过 Vue-Cli 命令行全局安装vue-cli1npm install -g @vue/cli 创建uni-app1vue create -p dcloudio/uni-preset-vue my-project 此时，会提示选择项目模板，初次体验建议选择 hello uni-app 项目模板 运行并发布 uni-app12npm run dev:%PLATFORM%npm run build:%PLATFORM% %PLATFORM% 可取值如下： 值 平台 h5 H5 mp-alipay 支付宝小程序 mp-baidu 百度小程序 mp-weixin 微信小程序 mp-toutiao 头条小程序 mp-qq QQ小程序 使用须知uni-app跨了很多端，虽然代码层面可以开发一次，生成多端。但注意每个端，有每个端的管理规则 比如H5端的浏览器有跨域限制； 比如微信小程序会强制要求https链接，并且所有要联网的服务器域名都要配到微信的白名单中； 比如App端，iOS对隐私控制和虚拟支付控制非常严格； 比如App端，Android、国产rom各种兼容性差异，尤其是因为谷歌服务被墙，导致的push、定位等开发混乱的坑； 如果你的App要使用三方sdk，比如定位、地图、支付、推送…还要遵循他们的规则和限制； 开发规范为了实现多端兼容，综合考虑编译速度、运行性能等因素，uni-app 约定了如下开发规范： 页面文件遵循 Vue 单文件组件 (SFC) 规范 组件标签靠近小程序规范，详见uni-app 组件规范 接口能力（JS API）靠近微信小程序规范，但需将前缀 wx 替换为 uni，详见 uni-app接口规范 数据绑定及事件处理同 Vue.js 规范，同时补充了App及页面的生命周期 为兼容多端运行，建议使用 flex 布局进行开发 目录结构123456789101112131415┌─components uni-app组件目录│ └─comp-a.vue 可复用的a组件├─hybrid 存放本地网页的目录├─platforms 存放各平台专用页面的目录├─pages 业务页面文件存放的目录│ ├─index│ │ └─index.vue index页面│ └─list│ └─list.vue list页面├─static 存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此├─wxcomponents 存放小程序组件的目录├─main.js Vue初始化入口文件├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期├─manifest.json 配置应用名称、appid、logo、版本等打包信息└─pages.json 配置页面路由、导航条、选项卡等页面类信息 生命周期应用生命周期 函数名 说明 onLaunch 当uni-app初始化时触发(全局只触发一次) onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 onError 当 uni-app 报错时触发 onUniNViewMessage 对 nvue 页面发送的数据进行监听 页面生命周期 函数名 说明 onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参） onshow 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 onReady 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 onHide 监听页面隐藏 onUnload 监听页面卸载 onResize 监听窗口尺寸变化 onPullDownRefresh 监听用户下拉动作，一般用于下拉刷新 onReachBottom 页面上拉触底事件的处理函数 onTabItemTap 点击 tab 时触发，参数为Object，具体见下方注意事项 onShareAppMessage 用户点击右上角分享 onPageScroll 监听页面滚动，参数为Object onBackPress 监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ； onNavigationBarSearchInputChanged 监听原生标题栏搜索输入框输入内容变化事件 onNavigationBarSearchInputConfirmed 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。 onNavigationBarSearchInputClicked 监听原生标题栏搜索输入框点击事件 onPageScroll 参数说明： 属性 类型 说明 scrollTop Number 页面在垂直方向已滚动的距离（单位px） onTabItemTap 参数说明： 属性 类型 说明 index String 被点击tabItem的序号，从0开始 pagePath String 被点击tabItem的页面路径 text String 被点击tabItem的按钮文字","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Uni-App","slug":"Uni-App","permalink":"http://blog.caoxl.com/tags/Uni-App/"}]},{"title":"Redis 集群","slug":"Redis-Cluster-Notes","date":"2019-09-30T01:34:18.000Z","updated":"2019-09-30T06:27:47.000Z","comments":true,"path":"2019/09/30/Redis-Cluster-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/09/30/Redis-Cluster-Notes/","excerpt":"前面是理论知识, 实操直接拉到 9. Linux下创建Redis集群 什么是Redis集群 ? Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施(installation)。 Redis 集群是一个分布式(distributed)、容错(fault-tolerant)的Redis实现, 集群可以使用的功能是普通单机Redis所能使用的功能的一个子集(subset). Redis 集群中不存在 中心(central)节点 或者 代理(proxy)节点, 集群的其中一个主要设计目标是达到线性可扩展性(linear scalability) Redis 集群为了保证一致性(consistency)而牺牲了一部分容错性: 系统会在保证对网络断线(net split)和节点失效(node failure)具有有限(limited)抵抗力的前提下， 尽可能地保持数据的一致性。","text":"前面是理论知识, 实操直接拉到 9. Linux下创建Redis集群 什么是Redis集群 ? Redis 集群是一个可以在多个 Redis 节点之间进行数据共享的设施(installation)。 Redis 集群是一个分布式(distributed)、容错(fault-tolerant)的Redis实现, 集群可以使用的功能是普通单机Redis所能使用的功能的一个子集(subset). Redis 集群中不存在 中心(central)节点 或者 代理(proxy)节点, 集群的其中一个主要设计目标是达到线性可扩展性(linear scalability) Redis 集群为了保证一致性(consistency)而牺牲了一部分容错性: 系统会在保证对网络断线(net split)和节点失效(node failure)具有有限(limited)抵抗力的前提下， 尽可能地保持数据的一致性。 Redis集群实现的功能子集Redis 集群实现了单机 Redis 中， 所有处理单个数据库键的命令。 针对多个数据库键的复杂计算操作， 比如集合的并集操作、合集操作没有被实现， 那些理论上需要使用多个节点的多个数据库键才能完成的命令也没有被实现。 在将来， 用户也许可以通过 MIGRATE COPY 命令， 在集群的计算节点（computation node）中执行针对多个数据库键的只读操作， 但集群本身不会去实现那些需要将多个数据库键在多个节点中移来移去的复杂多键命令。 Redis 集群不像单机 Redis 那样支持多数据库功能， 集群只使用默认的 0 号数据库， 并且不能使用 SELECT index 命令。 Redis集群协议中的客户端和服务器Redis 集群中的节点有以下责任： 持有键值对数据。 记录集群的状态，包括键到正确节点的映射（mapping keys to right nodes）。 自动发现其他节点，识别工作不正常的节点，并在有需要时，在从节点中选举出新的主节点。 为了执行以上列出的任务， 集群中的每个节点都与其他节点建立起了“集群连接(cluster bus)”， 该连接是一个 TCP 连接， 使用二进制协议进行通讯。 节点之间使用 Gossip协议 来进行以下工作: 传播 (propagate) 关于集群的信息，以此来发现新的节点。 向其他节点发送 PING 数据包，以此来检查目标节点是否正常运作。 在特定事件发生时，发送集群信息。 除此之外， 集群连接还用于在集群中发布或订阅信息。 因为集群节点不能代理（proxy）命令请求， 所以客户端应该在节点返回 -MOVED 或者 -ASK 转向（redirection）错误时， 自行将命令请求转发至其他节点。 因为客户端可以自由地向集群中的任何一个节点发送命令请求， 并可以在有需要时， 根据转向错误所提供的信息， 将命令转发至正确的节点， 所以在理论上来说， 客户端是无须保存集群状态信息的。 不过， 如果客户端可以将键和节点之间的映射信息保存起来， 可以有效地减少可能出现的转向次数， 籍此提升命令执行的效率。 Redis集群键分布模型Redis 集群的键空间被分割为 16384 个槽（slot）， 集群的最大节点数量也是 16384 个。 推荐的最大节点数量为 1000 个左右。 每个主节点都负责处理 16384 个哈希槽的其中一部分。 当我们说一个集群处于“稳定”（stable）状态时， 指的是集群没有在执行重配置（reconfiguration）操作， 每个哈希槽都只由一个节点进行处理。 以下是负责将键映射到槽的算法： 1HASH_SLOT = CRC16(key) mod 16384 以下是该算法所使用的参数： 算法的名称: XMODEM (又称ZMODEM 或者 CRC-16/ACORN) 结果的长度: 16位 多项数 (poly): 1021 (也即是 x16 + x12 + x5 + 1) 初始化值: 0000 反射输入字节 (Reflect Input byte): False 发射输出CRC (Reflect Output CRC): False 用于 CRC 输出值的异或常量 (Xor constant to output CRC) : 0000 该算法对于输入 &quot;123456789&quot; 的输出: 31C3 Redis 集群数据共享Redis 集群使用数据分片 (sharding) 而非一致性哈希 (consistency hashing) 来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。 集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个哈希槽， 其中： 节点 A 负责处理 0 号至 5500 号哈希槽。 节点 B 负责处理 5501 号至 11000 号哈希槽。 节点 C 负责处理 11001 号至 16384 号哈希槽。 种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说： 如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。 与此类似， 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。 因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线。 Redis集群中的主从复制为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作， Redis 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。 在之前列举的节点 A 、B 、C 的例子中， 如果节点 B 下线了， 那么集群将无法正常运行， 因为集群找不到节点来处理 5501 号至 11000 号的哈希槽。 另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。另一方面， 假如在创建集群的时候（或者至少在节点 B 下线之前）， 我们为主节点 B 添加了从节点 B1 ， 那么当主节点 B 下线的时候， 集群就会将 B1 设置为新的主节点， 并让它代替下线的主节点 B ， 继续处理 5501 号至 11000 号的哈希槽， 这样集群就不会因为主节点 B 的下线而无法正常运作了。 不过如果节点 B 和 B1 都下线的话， Redis 集群还是会停止运作。 Redis 集群的一致性保证（guarantee）Redis 集群不保证数据的强一致性（strong consistency）： 在特定条件下， Redis 集群可能会丢失已经被执行过的写命令。 使用异步复制（asynchronous replication）是 Redis 集群可能会丢失写命令的其中一个原因。 考虑以下这个写命令的例子： 客户端向主节点 B 发送一条写命令。 主节点 B 执行写命令，并向客户端返回命令回复。 主节点 B 将刚刚执行的写命令复制给它的从节点 B1 、 B2 和 B3 。 如你所见， 主节点对命令的复制工作发生在返回命令回复之后， 因为如果每次处理命令请求都需要等待复制操作完成的话， 那么主节点处理命令请求的速度将极大地降低 —— 我们必须在性能和一致性之间做出权衡。 Redis 集群另外一种可能会丢失命令的情况是， 集群出现网络分裂 (network partition)， 并且一个客户端与至少包括一个主节点在内的少数 (minority) 实例被孤立。 创建并使用Redis集群Redis 集群由多个运行在集群模式 (cluster mode) 下的 Redis 实例组成， 实例的集群模式需要通过配置来开启， 开启集群模式的实例将可以使用集群特有的功能和命令。 以下是一个包含了最少选项的集群配置文件示例： 12345port 7000cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes 文件中的 cluster-enabled 选项用于开实例的集群模式， 而 cluster-conf-file 选项则设定了保存节点配置文件的路径， 默认值为 nodes.conf 。 节点配置文件无须人为修改， 它由 Redis 集群在启动时创建， 并在有需要时自动进行更新。 要让集群正常运作至少需要三个主节点， 不过在刚开始试用集群功能时， 强烈建议使用六个节点： 其中三个为主节点， 而其余三个则是各个主节点的从节点。 首先， 让我们进入一个新目录， 并创建六个以端口号为名字的子目录， 稍后我们在将每个目录中运行一个 Redis 实例： 123mkdir cluster-testcd cluster-testmkdir 7000 7001 7002 7003 7004 7005 在文件夹 7000 至 7005 中， 各创建一个 redis.conf 文件， 文件的内容可以使用上面的示例配置文件， 但记得将配置中的端口号从 7000 改为与文件夹名字相同的号码。 现在， 从 Redis Github 页面 的 unstable 分支中取出最新的 Redis 源码， 编译出可执行文件 redis-server ， 并将文件复制到 cluster-test 文件夹， 然后使用类似以下命令， 在每个标签页中打开一个实例： 12cd 7000../redis-server ./redis.conf 实例打印的日志显示， 因为 nodes.conf 文件不存在， 所以每个节点都为它自身指定了一个新的 ID ： 1[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I'm 97a3a64667477371c4479320d683e4c8db5858b1 实例会一直使用同一个 ID ， 从而在集群中保持一个独一无二 (unique) 的名字。 每个节点都使用 ID 而不是 IP 或者端口号来记录其他节点， 因为 IP 地址和端口号都可能会改变， 而这个独一无二的标识符 (identifier) 则会在节点的整个生命周期中一直保持不变。 我们将这个标识符称为节点 ID。 创建集群现在我们已经有了六个正在运行中的 Redis 实例， 接下来我们需要使用这些实例来创建集群， 并为每个节点编写配置文件。 通过使用 Redis 集群命令行工具 redis-trib ， 编写节点配置文件的工作可以非常容易地完成： redis-trib 位于 Redis 源码的 src 文件夹中， 它是一个 Ruby 程序， 这个程序通过向实例发送特殊命令来完成创建新集群， 检查集群， 或者对集群进行重新分片 (reshared) 等工作。 我们需要执行以下命令来创建集群： 12./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \\127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 命令的意义如下： 给定 redis-trib.rb 程序的命令是 create ， 这表示我们希望创建一个新的集群。 选项 --replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。 后跟着的其他参数则是实例的地址列表， 我们希望程序使用这些地址所指示的实例来创建新集群。 简单来说， 以上命令的意思就是让 redis-trib 程序创建一个包含三个主节点和三个从节点的集群。 接着， redis-trib 会打印出一份预想中的配置给你看， 如果你觉得没问题的话， 就可以输入 yes ， redis-trib 就会将这份配置应用到集群当中： 输入 yes 并按下回车确认之后， 集群就会将配置应用到各个节点， 并连接起 (join) 各个节点 —— 也即是， 让各个节点开始互相通讯： 如果一切正常的话， redis-trib 将输出以下信息： 123&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. 这表示集群中的 16384 个槽都有至少一个主节点在处理， 集群运作正常。 Linux下创建Redis集群创建目录1234[root@caoxl redis]# cd /usr/local/redis/[root@caoxl redis]# mkdir cluster[root@caoxl redis]# cd cluster/[root@caoxl cluster]# mkdir 7000 7001 7002 7003 7004 7005 复制和修改配置文件1[root@caoxl cluster]# cp ../bin/redis.conf ./7000 修改配置文件 redis.conf，将下面的选项修改 123456789101112131415161718# 端口号port 7000# 后台启动daemonize yes# 开启集群cluster-enabled yes#集群节点配置文件cluster-config-file nodes-7000.conf# 集群连接超时时间cluster-node-timeout 5000# 进程pid的文件位置pidfile /var/run/redis-7000.pid# 开启aofappendonly yes# aof文件路径appendfilename \"appendonly-7000.aof\"# rdb文件路径dbfilename dump-7000.rdb 6个配置文件按照对应的端口分别修改配置文件 创建启动脚本在 /usr/local/redis 目录下创建一个 start.sh 1234567#!/bin/bashbin/redis-server cluster/7000/redis.confbin/redis-server cluster/7001/redis.confbin/redis-server cluster/7002/redis.confbin/redis-server cluster/7003/redis.confbin/redis-server cluster/7004/redis.confbin/redis-server cluster/7005/redis.conf 这个时候我们查看一下进程看启动情况 12[root@caoxl redis]# ps -ef | grep redisroot 20142 19734 0 11:29 pts/2 00:00:00 grep --color=auto redis 执行 start.sh 1234[root@caoxl redis]# sh start.sh 20169:C 30 Sep 2019 11:31:39.052 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo20169:C 30 Sep 2019 11:31:39.052 # Redis version=5.0.1, bits=64, commit=00000000, modified=0, pid=20169, just started... 这个时候我们查看一下进程看启动情况 12345678[root@caoxl redis]# ps -ef | grep redisroot 20155 1 0 11:31 ? 00:00:00 bin/redis-server 127.0.0.1:7000 [cluster]root 20162 1 0 11:31 ? 00:00:00 bin/redis-server 127.0.0.1:7001 [cluster]root 20174 1 0 11:31 ? 00:00:00 bin/redis-server 127.0.0.1:7002 [cluster]root 20176 1 0 11:31 ? 00:00:00 bin/redis-server 127.0.0.1:7003 [cluster]root 20181 1 0 11:31 ? 00:00:00 bin/redis-server 127.0.0.1:7004 [cluster]root 20189 1 0 11:31 ? 00:00:00 bin/redis-server 127.0.0.1:7005 [cluster]root 20194 19734 0 11:31 pts/2 00:00:00 grep --color=auto redis 有6个Redis进程在开启，说明我们的Redis就启动成功了 创建/开启集群这里我们只是开启了6个redis进程而已，它们都还只是独立的状态，还么有组成集群这里我们使用官方提供的工具redis-trib，不过这个工具是用ruby写的，要先安装ruby的环境 1yum install ruby rubygems -y 12345678910111213141516171819202122232425262728293031323334353637383940414243[root@caoxl redis]# redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 2730Master[1] -&gt; Slots 2731 - 5460Master[2] -&gt; Slots 5461 - 8191Master[3] -&gt; Slots 8192 - 10922Master[4] -&gt; Slots 10923 - 13652Master[5] -&gt; Slots 13653 - 16383M: ec6743b088fafa480bb6f06f2f5189df1ede2b1d 127.0.0.1:7000 slots:[0-2730] (2731 slots) masterM: 61d89b9786b7785633224c5950eef2aa5cee7dfa 127.0.0.1:7001 slots:[2731-5460] (2730 slots) masterM: 4449a1b0bd65e9688995907215c4ef1311dbdfc8 127.0.0.1:7002 slots:[5461-8191] (2731 slots) masterM: 6ad224baedff1134cd443a249d5eb13a80c51017 127.0.0.1:7003 slots:[8192-10922] (2731 slots) masterM: 797ad1ef54e859f724bc153223284a85c1afef44 127.0.0.1:7004 slots:[10923-13652] (2730 slots) masterM: 32158e5b4e5815ffd253d8eb94ace27c8c96e84e 127.0.0.1:7005 slots:[13653-16383] (2731 slots) masterCan I set the above configuration? (type 'yes' to accept): yes&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join...&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)M: ec6743b088fafa480bb6f06f2f5189df1ede2b1d 127.0.0.1:7000 slots:[0-2730] (2731 slots) masterM: 32158e5b4e5815ffd253d8eb94ace27c8c96e84e 127.0.0.1:7005 slots:[13653-16383] (2731 slots) masterM: 797ad1ef54e859f724bc153223284a85c1afef44 127.0.0.1:7004 slots:[10923-13652] (2730 slots) masterM: 61d89b9786b7785633224c5950eef2aa5cee7dfa 127.0.0.1:7001 slots:[2731-5460] (2730 slots) masterM: 4449a1b0bd65e9688995907215c4ef1311dbdfc8 127.0.0.1:7002 slots:[5461-8191] (2731 slots) masterM: 6ad224baedff1134cd443a249d5eb13a80c51017 127.0.0.1:7003 slots:[8192-10922] (2731 slots) master[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered. redis-cli –cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 连接集群这里我们使用 reids-cli 连接集群，使用时加上-c参数，就可以连接到集群连接 7000 端口的节点 1234567891011[root@caoxl redis]# redis-cli -c -p 7000127.0.0.1:7000&gt; set key_7000 value_7000-&gt; Redirected to slot [10168] located at 127.0.0.1:7003OK127.0.0.1:7003&gt; get key_7000\"value_7000\"127.0.0.1:7003&gt; set key_7003 value_7003-&gt; Redirected to slot [6107] located at 127.0.0.1:7002OK127.0.0.1:7002&gt; get key_7003\"value_7003\" 我们发现数据会在 7000-7002这3个节点之间来回跳转 测试集群中的节点挂掉上面我们建立了一个集群，3个主节点和3个从节点，7000-7002负责存取数据，7003-7005负责把7000-7005的数据同步到自己的节点上来。我们现在来模拟一下一台matser服务器宕机的情况 12345678[root@caoxl redis]# ps -ef | grep redisroot 20155 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7000 [cluster]root 20162 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7001 [cluster]root 20174 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7002 [cluster]root 20176 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7003 [cluster]root 20181 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7004 [cluster]root 20189 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7005 [cluster]root 20571 19734 0 11:49 pts/2 00:00:00 grep --color=auto redis 杀死一个redis master进程 12345678[root@caoxl redis]# kill 20155[root@caoxl redis]# ps -ef | grep redisroot 20162 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7001 [cluster]root 20174 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7002 [cluster]root 20176 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7003 [cluster]root 20181 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7004 [cluster]root 20189 1 0 11:31 ? 00:00:01 bin/redis-server 127.0.0.1:7005 [cluster]root 20578 19734 0 11:50 pts/2 00:00:00 grep --color=auto redis 123456789101112131415161718192021222324[root@caoxl bin]# redis-cli --cluster check 127.0.0.1:7001Could not connect to Redis at 127.0.0.1:7000: Connection refused127.0.0.1:7001 (61d89b97...) -&gt; 0 keys | 2730 slots | 0 slaves.127.0.0.1:7004 (797ad1ef...) -&gt; 0 keys | 2730 slots | 0 slaves.127.0.0.1:7002 (4449a1b0...) -&gt; 1 keys | 2731 slots | 0 slaves.127.0.0.1:7005 (32158e5b...) -&gt; 0 keys | 2731 slots | 0 slaves.127.0.0.1:7003 (6ad224ba...) -&gt; 1 keys | 2731 slots | 0 slaves.[OK] 2 keys in 5 masters.0.00 keys per slot on average.&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)M: 61d89b9786b7785633224c5950eef2aa5cee7dfa 127.0.0.1:7001 slots:[2731-5460] (2730 slots) masterM: 797ad1ef54e859f724bc153223284a85c1afef44 127.0.0.1:7004 slots:[10923-13652] (2730 slots) masterM: 4449a1b0bd65e9688995907215c4ef1311dbdfc8 127.0.0.1:7002 slots:[5461-8191] (2731 slots) masterM: 32158e5b4e5815ffd253d8eb94ace27c8c96e84e 127.0.0.1:7005 slots:[13653-16383] (2731 slots) masterM: 6ad224baedff1134cd443a249d5eb13a80c51017 127.0.0.1:7003 slots:[8192-10922] (2731 slots) master[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[ERR] Not all 16384 slots are covered by nodes. 注意: redis-trib.rb是redis 5.0以下的版本创建集群所使用的脚本，注意，redis5.0版本已不需要再使用此脚本，而是使用自带的redis-cli创建[root@caoxl redis]# redis-cli -v redis-cli 5.0.1 Redis集群命令12345678910111213141516171819202122232425262728293031323334[root@caoxl bin]# redis-cli --cluster helpCluster Manager Commands: create host1:port1 ... hostN:portN --cluster-replicas &lt;arg&gt; check host:port info host:port fix host:port reshard host:port --cluster-from &lt;arg&gt; --cluster-to &lt;arg&gt; --cluster-slots &lt;arg&gt; --cluster-yes --cluster-timeout &lt;arg&gt; --cluster-pipeline &lt;arg&gt; rebalance host:port --cluster-weight &lt;node1=w1...nodeN=wN&gt; --cluster-use-empty-masters --cluster-timeout &lt;arg&gt; --cluster-simulate --cluster-pipeline &lt;arg&gt; --cluster-threshold &lt;arg&gt; add-node new_host:new_port existing_host:existing_port --cluster-slave --cluster-master-id &lt;arg&gt; del-node host:port node_id call host:port command arg arg .. arg set-timeout host:port milliseconds import host:port --cluster-from &lt;arg&gt; --cluster-copy --cluster-replace help For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster. 参考 Redis cluster tutorial Redis - 集群教程 Redis集群的原理和搭建 集群部署交互式命令行工具 集群运维命令行工具 Redis-5.0.0集群配置 Redis-5.0.0 以下版本的安装和部署","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"集群","slug":"集群","permalink":"http://blog.caoxl.com/tags/集群/"}]},{"title":"Taro 学习日志","slug":"Taro-Learning-Log","date":"2019-09-29T10:24:41.000Z","updated":"2019-09-29T09:50:15.000Z","comments":true,"path":"2019/09/29/Taro-Learning-Log/","link":"","permalink":"http://blog.caoxl.com/2019/09/29/Taro-Learning-Log/","excerpt":"Taro 是一套遵循 React 语法规范的 多端开发 解决方案。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ小程序、快应用、H5、React-Native 等）运行的代码。","text":"Taro 是一套遵循 React 语法规范的 多端开发 解决方案。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ小程序、快应用、H5、React-Native 等）运行的代码。 快速开始安装 Taro 项目基于 node，请确保已具备较新的 node 环境（&gt;=8.0.0），推荐使用 node 版本管理工具 nvm 来管理 node，这样不仅可以很方便地切换 node 版本，而且全局安装时候也不用加 sudo 了。 CLI 工具安装首先，你需要使用 npm 或者 yarn 全局安装 @tarojs/cli，或者直接使用npx: 12345678# 使用 npm 安装 CLI$ npm install -g @tarojs/cli# OR 使用 yarn 安装 CLI$ yarn global add @tarojs/cli# OR 安装了 cnpm，使用 cnpm 安装 CLI$ cnpm install -g @tarojs/cli 安装完成 12345678910111213141516171819$ taro --help👽 Taro v1.3.19Usage: taro &lt;command&gt; [options]Options: -V, --version output the version number -h, --help output usage informationCommands: init [projectName] Init a project with default templete config &lt;cmd&gt; Taro config create Create page for project build Build a project with options update Update packages of taro convert Convert weapp to taro info Diagnostics Taro env info doctor Diagnose taro project help [cmd] display help for [cmd] 注意事项如果安装过程出现sass相关的安装错误，请在安装mirror-config-china后重试。 1npm install -g mirror-config-china 项目初始化使用命令创建模板项目 12345678910111213141516171819202122232425taro init TaroApp$ taro init TaroApp👽 Taro v1.3.19Taro即将创建一个新项目!Need help? Go and open issue: https://github.com/NervJS/taro/issues/new? 请输入项目介绍！ Taro Test? 请输入项目介绍！ Taro Test? 是否需要使用 TypeScript ？ (Y/n) Y? 是否需要使用 TypeScript ？ Yes? 请选择 CSS 预处理器（Sass/Less/Stylus） (Use arrow keys)? 请选择 CSS 预处理器（Sass/Less/Stylus） Sass? 请选择模板 (Use arrow keys)? 请选择模板 默认模板✔ 创建项目: TaroApp✔ 创建文件: TaroApp\\.npmrc✔ 创建文件: TaroApp\\.editorconfig✔ 创建文件: TaroApp\\.eslintrc✔ 创建文件: TaroApp\\.gitignore...创建项目 TaroApp 成功！请进入项目目录 TaroApp 开始工作吧！😝 npm 5.2+ 也可在不全局安装的情况下使用 npx 创建模板项目 1npx @tarojs/cli init TaroApp 在创建完项目之后，Taro 会默认开始安装项目所需要的依赖，安装使用的工具按照 yarn&gt;cnpm&gt;npm 顺序进行检测，一般来说，依赖安装会比较顺利，但某些情况下可能会安装失败，这时候你可以在项目目录下自己使用安装命令进行安装 12345678# 使用 yarn 安装依赖$ yarn# OR 使用 cnpm 安装依赖$ cnpm install# OR 使用 npm 安装依赖$ npm install 运行 Taro 需要运行不同的命令，将 Taro 代码编译成不同端的代码，然后在对应的开发工具中查看效果。 微信小程序微信小程序编译预览及打包（去掉 –watch 将不会监听文件修改，并会对代码进行压缩打包） yarn 12yarn dev:weappyarn build:weapp npm 12npm run dev:weappnpm run build:weapp taro 123// 仅限全局安装taro build --type weapp --watchtaro build --type weapp npx 12npx taro build --type weapp --watchnpx taro build --type weapp 12345678910111213141516171819$ taro build --type weapp👽 Taro v1.3.19开始编译项目 TaroApp生成 工具配置 dist/project.config.json编译 入口文件 src/app.tsx拷贝 NPM文件 dist/npm/@tarojs/taro-weapp/npm/@tarojs/taro/dist/index.js拷贝 NPM文件 dist/npm/@tarojs/taro-weapp/npm/@tarojs/taro/index.js拷贝 NPM文件 dist/npm/@tarojs/taro-weapp/dist/index.js拷贝 NPM文件 dist/npm/@tarojs/taro-weapp/index.js生成 入口配置 dist/app.json生成 入口文件 dist/app.js生成 入口样式 dist/app.wxss编译 所有页面编译 页面文件 src/pages/index/index生成 页面配置 dist/pages/index/index.json生成 页面逻辑 dist/pages/index/index.js生成 页面模板 dist/pages/index/index.wxml生成 页面样式 dist/pages/index/index.wxss 常用CLI命令 查看 Taro 所有命令及帮助 1taro --help 更新Taro CLI工具 12345678# taro$ taro update self# npmnpm i -g @tarojs/cli@latest# yarnyarn global add @tarojs/cli@latest 更新项目中Taro相关的依赖 1taro update project 环境及依赖检测 12345678910$ taro info👽 Taro v1.3.19 Taro CLI 1.3.19 environment info: System: OS: Windows 10 Binaries: Node: 8.12.0 - D:\\nodeJs\\node.EXE npm: 6.9.0 - D:\\nodeJs\\npm.CMD Taro Doctor 1taro doctor 其他常见问题回到某个版本需要安装某个固定版本，或者回到某个版本，例如我们要安装 1.3.9 ， 则如下： 12345678# 使用 npm 安装 CLI$ npm install -g @tarojs/cli@1.3.9# OR 使用 yarn 安装 CLI$ yarn global add @tarojs/cli@1.3.9# OR 安装了 cnpm，使用 cnpm 安装 CLI$ cnpm install -g @tarojs/cli@1.3.9 CLI 配置1.3.9 开始 Taro 会在用户根目录下创建 .taro 文件夹，其中 .taro/index.json 用于存放 CLI 相关配置。 开发者可以使用 taro config 命令对配置项进行一系列操作： 查看用法 1234567891011121314$ taro config --help👽 Taro v1.3.19Usage: taro-config [options]Options: --json 以 JSON 形式输出 -h, --help output usage informationSynopsis: $ taro config set &lt;key&gt; &lt;value&gt; $ taro config get &lt;key&gt; $ taro config delete &lt;key&gt; $ taro config list [--json] 设置配置项的值为 12$ taro config set key_taro value_taro👽 Taro v1.3.19 读取配置项 1234$ taro config get key_taro👽 Taro v1.3.19value_taro 删除配置项 12$ taro config delete key_taro👽 Taro v1.3.19 打印所有配置项 1234567891011$ taro config list👽 Taro v1.3.19templateSource=github:NervJS/taro-project-templates$ taro config list --json👽 Taro v1.3.19&#123; \"templateSource\": \"github:NervJS/taro-project-templates\"&#125; 基础教程目录结构123456789101112131415├── config 配置目录| ├── dev.js 开发时配置| ├── index.js 默认配置| └── prod.js 打包时配置├── src 源码目录| ├── components 公共组件目录| ├── pages 页面文件目录| | ├── index index 页面目录| | | ├── banner 页面 index 私有组件| | | ├── index.js index 页面逻辑| | | └── index.css index 页面样式| ├── utils 公共方法库| ├── app.css 项目总通用样式| └── app.js 项目入口文件└── package.json Taro规范文件命名Taro 中普通 JS/TS 文件以小写字母命名，多个单词以下划线连接，例如 util.js、util_helper.js Taro 组件文件命名遵循 Pascal 命名法，例如 ReservationCard.jsx 文件后缀Taro 中普通 JS/TS 文件以 .js 或者 .ts 作为文件后缀 Taro 组件则以 .jsx 或者 .tsx 作为文件后缀，当然这不是强制约束，只是作为一个实践的建议，组件文件依然可以以 .js 或者 .ts 作为文件后缀 JavaScript 书写规范 在 Taro 中书写 JavaScript 请遵循以下规则… Taro框架项目目录结构12345678910111213├── dist 编译结果目录├── config 配置目录| ├── dev.js 开发时配置| ├── index.js 默认配置| └── prod.js 打包时配置├── src 源码目录| ├── pages 页面文件目录| | ├── index index 页面目录| | | ├── index.js index 页面逻辑| | | └── index.css index 页面样式| ├── app.css 项目总通用样式| └── app.js 项目入口文件└── package.json 入口文件入口文件默认是 src 目录下的 app.js。 代码示例一个普通的入口文件示例如下 123456789101112131415161718192021222324252627282930313233import Taro, &#123; Component &#125; from '@tarojs/taro'import Index from './pages/index'import './app.scss'class App extends Component &#123; // 项目配置 config = &#123; pages: [ 'pages/index/index' ], window: &#123; backgroundTextStyle: 'light', navigationBarBackgroundColor: '#fff', navigationBarTitleText: 'WeChat', navigationBarTextStyle: 'black' &#125; &#125; componentWillMount () &#123;&#125; componentDidMount () &#123;&#125; componentDidShow () &#123;&#125; componentDidHide () &#123;&#125; render () &#123; return ( &lt;Index /&gt; ) &#125;&#125; 可以看出入口文件也是 React 风格的写法，首先需要引用依赖 @tarojs/taro，这是 Taro 方案的基础框架，在这里我们继承了 Component 组件基类。 路由功能路由API在 Taro 中，路由功能是默认自带的，不需要开发者进行额外的路由配置。 我们只需要在入口文件的 config 配置中指定好 pages，然后就可以在代码中通过 Taro 提供的 API 来跳转到目的页面，例如： 123456789// 跳转到目的页面，打开新页面Taro.navigateTo(&#123; url: '/pages/page/path/name' &#125;)// 跳转到目的页面，在当前页面打开Taro.redirectTo(&#123; url: '/pages/page/path/name'&#125;) 路由传参我们可以通过在所有跳转的 url 后面添加查询字符串参数进行跳转传参，例如 1234// 传入参数 id=2&amp;type=testTaro.navigateTo(&#123; url: '/pages/page/path/name?id=2&amp;type=test'&#125;) 这样的话，在跳转成功的目标页的生命周期方法里就能通过 this.$router.params 获取到传入的参数，例如上述跳转，在目标页的 componentWillMount 生命周期里获取入参 12345class C extends Taro.Component &#123; componentWillMount () &#123; console.log(this.$router.params) &#125;&#125; 静态资源引用引用样式文件12345// 引用CSS文件import './css/path/name.css'// 引用SCSS文件import './css/path/name.scss' 引用 JS 文件12import &#123; functionName &#125; from './css/path/name.js'import defaultExportName from './css/path/name.js' 引用图片、音频、字体等文件1234567// 引用文件import namedPng from '../../images/path/named.png'// 使用&lt;View&gt; &lt;Image src=&#123;namedPng&#125; /&gt;&lt;/View&gt; 引用 JSON 文件12345678910 // 引用 json 文件/** * named.json * &#123; * x: 1 * &#125; **/ import namedJson from '../../json/path/named.json' console.log(namedJson.x) 编译配置编译配置存放于项目根目录下 config 目录中，包含三个文件 index.js 是通用配置 dev.js 是项目预览时的配置 prod.js 是项目打包时定的配置 index.js - 通用配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113const config = &#123; // 项目名称 projectName: 'TaroApp', // 项目创建日期 date: '2019-9-29', // 设计稿尺寸 designWidth: 750, deviceRatio: &#123; '640': 2.34 / 2, '750': 1, '828': 1.81 / 2 &#125;, // 项目源码目录 sourceRoot: 'src', // 项目产出目录 outputRoot: 'dist', // 通用插件配置 plugins: &#123; babel: &#123; sourceMap: true, presets: [ ['env', &#123; modules: false &#125;] ], plugins: [ 'transform-decorators-legacy', 'transform-class-properties', 'transform-object-rest-spread' ] &#125; &#125;, // 全局变量设置 defineConstants: &#123; &#125;, // 文件 copy 配置 copy: &#123; patterns: [ ], options: &#123; &#125; &#125;, // 小程序端专用配置 weapp: &#123; module: &#123; postcss: &#123; autoprefixer: &#123; enable: true, config: &#123; browsers: [ 'last 3 versions', 'Android &gt;= 4.1', 'ios &gt;= 8' ] &#125; &#125;, pxtransform: &#123; enable: true, config: &#123; &#125; &#125;, // 小程序端样式引用本地资源内联配置 url: &#123; enable: true, config: &#123; limit: 10240 // 设定转换尺寸上限 &#125; &#125;, cssModules: &#123; enable: false, // 默认为 false，如需使用 css modules 功能，则设为 true config: &#123; namingPattern: 'module', // 转换模式，取值为 global/module generateScopedName: '[name]__[local]___[hash:base64:5]' &#125; &#125; &#125; &#125; &#125;, // H5端专用配置 h5: &#123; publicPath: '/', staticDirectory: 'static', module: &#123; postcss: &#123; autoprefixer: &#123; enable: true, config: &#123; browsers: [ 'last 3 versions', 'Android &gt;= 4.1', 'ios &gt;= 8' ] &#125; &#125;, cssModules: &#123; enable: false, // 默认为 false，如需使用 css modules 功能，则设为 true config: &#123; namingPattern: 'module', // 转换模式，取值为 global/module generateScopedName: '[name]__[local]___[hash:base64:5]' &#125; &#125; &#125; &#125; &#125;&#125;module.exports = function (merge) &#123; if (process.env.NODE_ENV === 'development') &#123; return merge(&#123;&#125;, config, require('./dev')) &#125; return merge(&#123;&#125;, config, require('./prod'))&#125; 异步编程Taro 支持使用 async functions 来让开发者获得不错的异步编程体验，开启 async functions 支持需要安装包 @tarojs/async-await 1234$ yarn add @tarojs/async-await# 或者使用 npm$ npm install --save @tarojs/async-await 随后在项目入口文件 app.js 中直接 import ，就可以开始使用 async functions 功能了 12// src/app.jsimport '@tarojs/async-await' 参考 Taro - 官方文档","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Taro","slug":"Taro","permalink":"http://blog.caoxl.com/tags/Taro/"}]},{"title":"微信小程序 学习日志","slug":"Wechat-Program-Learning-Log","date":"2019-09-29T02:24:17.000Z","updated":"2019-09-29T06:47:07.000Z","comments":true,"path":"2019/09/29/Wechat-Program-Learning-Log/","link":"","permalink":"http://blog.caoxl.com/2019/09/29/Wechat-Program-Learning-Log/","excerpt":"小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。","text":"小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 准备申请账号 小程序注册页 (国庆期间)小程序注册帐号功能维护… 安装开发者工具 开发者工具下载 小程序代码构成123456789101112131415161718pages ├─index 首页文件夹 │ ├─index.js JS 脚本逻辑文件 │ ├─index.json JSON 配置文件│ ├─index.wxml WXML 模板文件 │ ├─index.wxss WXSS 样式文件 ├─logs 日志文件夹 │ ├─logs.js │ ├─logs.json │ ├─logs.wxml │ ├─logs.wxss ├─utils │ ├─util.js ├─app.js 小程序逻辑├─app.json 小程序公共配置├─app.wxss 小程序公共样式表├─project.config.json└─sitemap.json JSON 配置JSON 是一种数据格式，并不是编程语言，在小程序中，JSON扮演的静态配置的角色。 全局配置 app.jsonapp.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。 工具配置 project.config.json 开发者工具个性化配置 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"description\": \"项目配置文件\", \"packOptions\": &#123; \"ignore\": [] &#125;, \"setting\": &#123; \"urlCheck\": true, \"es6\": true, \"postcss\": true, \"minified\": true, \"newFeature\": true, \"autoAudits\": false, \"coverView\": true &#125;, \"compileType\": \"miniprogram\", \"libVersion\": \"2.0.4\", \"appid\": \"wx91ca1fd41ee5832c\", \"projectname\": \"miniprogram-1\", \"debugOptions\": &#123; \"hidedInDevtools\": [] &#125;, \"isGameTourist\": false, \"simulatorType\": \"wechat\", \"simulatorPluginLibVersion\": &#123;&#125;, \"condition\": &#123; \"search\": &#123; \"current\": -1, \"list\": [] &#125;, \"conversation\": &#123; \"current\": -1, \"list\": [] &#125;, \"game\": &#123; \"currentL\": -1, \"list\": [] &#125;, \"miniprogram\": &#123; \"current\": -1, \"list\": [] &#125; &#125;&#125; sitemap配置 sitemap.json小程序根目录下的 sitemap.json 文件用来配置小程序及其页面是否允许被微信索引。 所有页面都会被微信索引（默认情况） 123456&#123; \"rules\":[&#123; \"action\": \"allow\", \"page\": \"*\" &#125;]&#125; 配置 path/to/page 页面不被索引，其余页面允许被索引 123456&#123; \"rules\":[&#123; \"action\": \"disallow\", \"page\": \"path/to/page\" &#125;]&#125; 配置 path/to/page 页面被索引，其余页面不被索引 123456789&#123; \"rules\":[&#123; \"action\": \"allow\", \"page\": \"path/to/page\" &#125;, &#123; \"action\": \"disallow\", \"page\": \"*\" &#125;]&#125; 更多参考: 配置小程序 - sitemap 配置 WXML 模板从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。 在小程序中也有同样的角色，其中 WXML 充当的就是类似 HTML 的角色。 12345678910111213&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view class=\"userinfo\"&gt; &lt;button wx:if=\"&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" mode=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; WXSS 样式 WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。 12345678910/**app.wxss**/.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。 新增了尺寸单位. WXSS 在底层支持新的尺寸单位 rpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可. 提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效 此外 WXSS 仅支持部分 CSS 选择器 目前支持的选择器 选择器 样例 样例描述 .class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件 element view 选择所有 view 组件 element,element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前边插入内容 JS 逻辑交互一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。 123456789101112131415161718192021222324252627282930313233343536373839//app.jsApp(&#123; onLaunch: function () &#123; // 展示本地存储能力 var logs = wx.getStorageSync('logs') || [] logs.unshift(Date.now()) wx.setStorageSync('logs', logs) // 登录 wx.login(&#123; success: res =&gt; &#123; // 发送 res.code 到后台换取 openId, sessionKey, unionId &#125; &#125;) // 获取用户信息 wx.getSetting(&#123; success: res =&gt; &#123; if (res.authSetting['scope.userInfo']) &#123; // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框 wx.getUserInfo(&#123; success: res =&gt; &#123; // 可以将 res 发送给后台解码出 unionId this.globalData.userInfo = res.userInfo // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 if (this.userInfoReadyCallback) &#123; this.userInfoReadyCallback(res) &#125; &#125; &#125;) &#125; &#125; &#125;) &#125;, globalData: &#123; userInfo: null &#125;&#125;) 框架相关生命周期 注册页面使用 Page 构造器注册页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Page(&#123; data: &#123; text: \"This is page data.\" &#125;, onLoad: function (options) &#123; // 页面创建时执行 &#125;, onShow: function() &#123; // 页面出现在前台时执行 &#125;, onReady: function() &#123; // 页面首次渲染完毕时执行 &#125;, onHide: function() &#123; // 页面从前台变为后台时执行 &#125;, onUnload: function() &#123; // 页面销毁时执行 &#125;, onPullDownRefresh: function() &#123; // 触发下拉刷新时执行 &#125;, onReachBottom: function() &#123; // 页面触底时执行 &#125;, onShareAppMessage: function() &#123; // 页面被用户分享时执行 &#125;, onPageScroll: function() &#123; // 页面滚动时执行 &#125;, onResize: function() &#123; // 页面尺寸变化时执行 &#125;, onTabItemTap(item) &#123; // tab 点击时执行 console.log(item.index); console.log(item.pagePath); console.log(item.text); &#125;, // 实践响应函数 viewTap: function() &#123; this.setData(&#123; text: 'Set some data for updating view.' &#125;, function() &#123; // this is setData callback &#125;) &#125;, // 自由数据 customData: &#123; hi: 'MINA' &#125;&#125;); 使用 Component 构造器构造页面Page 构造器适用于简单的页面。但对于复杂的页面， Page 构造器可能并不好用。 此时，可以使用 Component 构造器来构造页面。 Component 构造器的主要区别是：方法需要放在 methods: { } 里面。 1234567891011121314151617Page(&#123; data: &#123; text: \"This is page data.\" &#125;, methods: &#123; onLoad: function(options) &#123; // 页面创建时执行 &#125;, onPullDownRefresh: function() &#123; // 下拉刷新时执行 &#125;, // 事件响应函数 viewTap: function() &#123; // ... &#125; &#125;&#125;); 自定义组件组件生命周期 生命周期 参数 描述 created 无 在组件实例刚刚被创建时执行 attached 无 在组件实例进入页面节点树时执行 ready 无 在组件在视图层布局完成后执行 moved 无 在组件实例被移动到节点树另一个位置时执行 detached 无 在组件实例被从页面节点树移除时执行 error Object Error 每当组件方法抛出错误时执行 参考 微信小程序 - 文档 微信小程序 - API 微信小程序 - 开发者工具 微信小程序示例","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://blog.caoxl.com/tags/微信小程序/"}]},{"title":"PHP面试/笔试题杂记 V","slug":"Interview-Questions-Notes-V","date":"2019-09-20T09:08:55.000Z","updated":"2019-09-27T03:22:14.000Z","comments":true,"path":"2019/09/20/Interview-Questions-Notes-V/","link":"","permalink":"http://blog.caoxl.com/2019/09/20/Interview-Questions-Notes-V/","excerpt":"一份来自同事大哥的笔试题.","text":"一份来自同事大哥的笔试题. 对于大流量的网站, 采用什么样的方法来解决网站打开速度过慢的问题 ? 硬件方面 普通的一个 p4 的服务器每天最多能支持大约 10 万左右的 IP，主要影响服务器的速度有：网络 - 硬盘读写速度 - 内存大小 - cpu 处理速度。 软件方面 静态页面 前台实现完全的静态化当然最好，可以完全不用访问数据库 数据库优化 表字段优化 语句优化 索引优化 分库分表 读写分离 禁止外部的盗链 外部盗链往往会加大服务器的请求和流量的负载压力，因此应该严格限制外部对于自身的图片或者文件盗链， 好在目前可以简单地通过 refer 来控制盗链， Apache 自己就可以通过配置来禁止盗链 IIS 也有一些第三方的 ISAPI 可以实现同样的功能。 或者使用非技术手段来解决，比如在图片上增加水印 控制大文件的下载。 大文件的下载会占用很大的流量，并且对于非 SCSI 硬盘来说，大量文件下载会消耗 CPU，使得网站响应能力下降。因此，尽量不要提供超过 2M 的大文件下载，如果需要提供，建议将大文件放在另外一台服务器上 使用不同主机分流主要流量 将文件放在不同的主机上，提供不同的镜像供用户下载。比如如果觉得 RSS 文件占用 流量大，那么使用 FeedBurner 或者 FeedSky 等服务将 RSS 输出放在其他主机上，这样别人访问的流量压力就大多集中在 FeedBurner 的主机上，RSS 就不占用太多资源了 使用流量分析统计软件。 在网站上安装一个流量分析统计软件，可以即时知道哪些地方耗费了大量流量，哪些页面需要再进行优化，因此，解决流量问题还需要进行精确的统计分析才可以。比如：Google Analytics（Google 分析）。 网站被劫持, 有什么解决办法 ? 网站域名被泛解析 关闭域名的泛解析，进入了域名解析后台以后点击我们的域名找到带*号的域名解析，删除去就可以了。 黑客劫持 建议不定期对你正常运行的网站进行备份 浏览器被劫持 直接卸载掉，去官网在从新下载一个浏览器程序安装即可。 运营商劫持 运用https加密 网站被DDOS攻击, 有什么解决办法 ? 分布式拒绝服务攻击（DDOS）是目前常见的网络攻击方法，它的英文全称为Distributed Denial of Service 备份网站 防范 DDOS 的第一步，就是你要有一个备份网站，或者最低限度有一个临时主页。生产服务器万一下线了，可以立刻切换到备份网站，不至于毫无办法。 保证服务器系统的安全 首先要确保服务器软件没有任何漏洞，防止攻击者入侵。确保服务器采用最新系统，并打上安全补丁。在服务器上删除未使用的服务，关闭未使用的端口。对于服务器上运行的网站，确保其打了最新的补丁，没有安全漏洞。 隐藏服务器的真实IP地址 不要把域名直接解析到服务器的真实IP地址，不能让服务器真实IP泄漏，服务器前端加CDN中转（免费的CDN一般能防止5G左右的DDOS），如果资金充裕的话，可以购买高防的盾机，用于隐藏服务器真实IP，域名解析使用CDN的IP，所有解析的子域名都使用CDN的IP地址。此外，服务器上部署的其他域名也不能使用真实IP解析，全部都使用CDN来解析。 HTTP 请求的拦截 HTTP 请求的特征一般有两种：IP 地址和 User Agent 字段。比如，恶意请求都是从某个 IP 段发出的，那么把这个 IP 段封掉就行了。或者，它们的 User Agent 字段有特征（包含某个特定的词语），那就把带有这个词语的请求拦截。 拦截可以在三个层次做。 专用硬件 Web 服务器的前面可以架设硬件防火墙，专门过滤请求。这种效果最好，但是价格也最贵。 本机防火墙 操作系统都带有软件防火墙，Linux 服务器一般使用 iptables。比如，拦截 IP 地址1.2.3.4的请求，可以执行下面的命令。 1iptables -A INPUT -s 1.2.3.4 -j DROP Web 服务器 Web 服务器也可以过滤请求。拦截 IP 地址1.2.3.4，nginx 的写法如下。 123location / &#123; deny 1.2.3.4;&#125; 带宽扩容 对于网站来说，就是在短时间内急剧扩容，提供几倍或几十倍的带宽，顶住大流量的请求。这就是为什么云服务商可以提供防护产品，因为他们有大量冗余带宽，可以用来消化 DDOS 攻击。 CDN CDN 指的是网站的静态内容分发到多个服务器，用户就近访问，提高速度。因此，CDN 也是带宽扩容的一种方法，可以用来防御 DDOS 攻击。 对千万级别数据库有哪些优化方法 ?对于一个存储设计，必须考虑业务特点，收集的信息如下： 数据的容量：1-3年内会大概多少条数据，每条数据大概多少字节； 数据项：是否有大字段，那些字段的值是否经常被更新； 数据查询SQL条件：哪些数据项的列名称经常出现在WHERE、GROUP BY、ORDER BY子句中等； 数据更新类SQL条件：有多少列经常出现UPDATE或DELETE 的WHERE子句中； SQL量的统计比，如：SELECT：UPDATE+DELETE：INSERT=多少？ 预计大表及相关联的SQL，每天总的执行量在何数量级？ 表中的数据：更新为主的业务 还是 查询为主的业务 打算采用什么数据库物理服务器，以及数据库服务器架构？ 并发如何？ 存储引擎选择InnoDB还是MyISAM？ 假如网站用 cookie 保存用户信息, 怎么样防止串号的问题及 cookie 被篡改 ? 防篡改签名 服务器为每个Cookie项生成签名。如果用户篡改Cookie，则与签名无法对应上。以此，来判断数据是否被篡改。 服务端提供一个签名生成算法 secret 根据方法生成签名 secret(wall)=34Yult8i 将生成的签名放入对应的Cookie项 username=wall|34Yult8i。其中，内容和签名用|隔开。 服务端根据接收到的内容和签名，校验内容是否被篡改 比如服务器接收到请求中的Cookie项 username=pony|34Yult8i，然后使用签名生成算法secret(pony)=666。 算法得到的签名666和请求中数据的签名不一致，则证明数据被篡改 对于网站并发或秒杀功能, 你是如何实现的 ?一个秒杀系统的基本流程基本如下: 用户请求详情页、系统时间、请求秒杀接口、执行秒杀操作、返回结果 用户请求详情页，系统时间，请求秒杀接口，执行秒杀操作都是位于服务端，都会被大量访问，那么我们优化系统高并发就是从这四点着手 请求详情页的优化 详情页是属于静态济源，例如css，js等，对于这些静态资源，如果全部放在服务端主机中，势必对服务主机造成很大的压力，并发量也得不到支持，我们可以使用CDN来进行优化 获取系统时间操作的优化 获取系统时间的操作不用优化 秒杀地址接口获取的优化 cdn适合存放不变的内容，例如css，js等静态内存，所以它不适合放在cdn中缓存，但是适合在服务端缓存，例如redis，甚至可以做redis集群。 优化秒杀操作 首先，可以用NoSQL例如redis作为一个原子计数器，记录商品的库存，当用户秒杀该商品时，该计数器便减1，当计数器为0时，则隐藏秒杀接口，用户就不能秒杀操作了； 然后记录哪个用户秒杀了该商品，作为一个消息，存储到分布式mq(例如: RabbitMQ)中，然后用户立即返回提示（例如：正在秒杀，请等待） 最后由接着由消息队列的消费者进程异步取出数据，再让服务端的服务去执行数据库的update操作。 重启与过载保护 如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候，最好在入口层将流量拒绝，然后再将重启。如果是redis/memcache这种服务也挂了，重启的时候需要注意“预热”，并且很可能需要比较长的时间。 假如一个大型项目给分配3台服务器, 如何分配服务器 ? 集群结构 同一个业务，部署在多个服务器上 分布式结构 一个业务分拆多个子业务，部署在不同的服务器上","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"PHP面试题","slug":"PHP面试题","permalink":"http://blog.caoxl.com/tags/PHP面试题/"},{"name":"PHP笔试题","slug":"PHP笔试题","permalink":"http://blog.caoxl.com/tags/PHP笔试题/"}]},{"title":"EasySwoole 学习日志","slug":"Easy-Swoole-Learning","date":"2019-09-20T03:37:31.000Z","updated":"2019-09-29T02:20:33.000Z","comments":true,"path":"2019/09/20/Easy-Swoole-Learning/","link":"","permalink":"http://blog.caoxl.com/2019/09/20/Easy-Swoole-Learning/","excerpt":"EasySwoole 是一款基于 Swoole Server 开发的常驻内存型的分布式PHP框架，专为API而生，摆脱传统PHP运行模式在进程唤起和文件加载上带来的性能损失。 EasySwoole 高度封装了 Swoole Server 而依旧维持 Swoole Server 原有特性，支持同时混合监听HTTP、自定义TCP、UDP协议","text":"EasySwoole 是一款基于 Swoole Server 开发的常驻内存型的分布式PHP框架，专为API而生，摆脱传统PHP运行模式在进程唤起和文件加载上带来的性能损失。 EasySwoole 高度封装了 Swoole Server 而依旧维持 Swoole Server 原有特性，支持同时混合监听HTTP、自定义TCP、UDP协议 环境满足基本的环境要求才能运行框架，easySwoole 框架对环境的要求十分简单，只需要满足运行 Swoole 拓展的条件，并且 PHP 版本在 7.1 以上即可 基础运行环境 保证 PHP 版本大于等于 7.1 保证 Swoole 拓展版本大于等于 4.4.0 需要 pcntl 拓展的任意版本 使用 Linux / FreeBSD / MacOS 这三类操作系统 使用 Composer 作为依赖管理工具 建议使用 Ubuntu14 / CentOS 7.0 或更高版本操作系统 安装Composer 安装12composer require easyswoole/easyswoole=3.xphp vendor/bin/easyswoole install 使用启动框架123456789101112131415161718192021222324252627282930313233php easyswoole start[root@caoxl easy_swoole]# php easyswoole start d ______ _____ _ | ____| / ____| | | | |__ __ _ ___ _ _ | (___ __ __ ___ ___ | | ___ | __| / _` | / __| | | | | \\___ \\ \\ \\ /\\ / / / _ \\ / _ \\ | | / _ \\ | |____ | (_| | \\__ \\ | |_| | ____) | \\ V V / | (_) | | (_) | | | | __/ |______| \\__,_| |___/ \\__, | |_____/ \\_/\\_/ \\___/ \\___/ |_| \\___| __/ | |___/main server SWOOLE_WEBlisten address 0.0.0.0listen port 9500ip@eth0 172.18.52.244ip@docker0 172.17.0.1ip@br-4ee5fb2568a1 172.19.0.1worker_num 8task_worker_num 8reload_async 1task_enable_coroutine 1max_wait_time 3pid_file /var/www/easy_swoole/Temp/pid.pidlog_file /var/www/easy_swoole/Log/swoole.logdaemonize 1run at user rootdaemonize trueswoole version 4.3.4php version 7.2.7easy swoole 3.2.5develop/produce developtemp dir /var/www/easy_swoole/Templog dir /var/www/easy_swoole/Log Hello World在项目根目录下创建如下的目录结构，这个目录是编写业务逻辑的应用目录，编辑 Index.php 文件，添加基础控制器的代码 123456project 项目部署目录----------------------------------├─App 应用目录│ └─HttpController 应用的控制器目录│ └─Index.php 默认控制器文件---------------------------------- 123456789101112131415&lt;?phpnamespace App\\HttpController;use EasySwoole\\Http\\AbstractInterface\\Controller;class Index extends Controller&#123; function index() &#123; // TODO: Implement index() method. $this-&gt;response()-&gt;write('hello world'); &#125;&#125; 然后编辑根目录下的 composer.json 文件，注册应用的命名空间 12345678910&#123; \"autoload\": &#123; \"psr-4\": &#123; \"App\\\\\": \"App/\" &#125; &#125;, \"require\": &#123; \"easyswoole/easyswoole\": \"3.x\" &#125;&#125; 最后执行 composer dumpautoload 命令更新命名空间，框架已经可以自动加载 App 目录下的文件了，此时框架已经安装完毕，可以开始编写业务逻辑 1234# 更新命名空间映射composer dumpautoload# 启动框架php easyswoole start 启动框架后，访问 http://localhost:9500 即可看到 Hello World 。 目录结构EasySwoole 的目录结构是非常灵活的，基本上可以任意定制，没有太多的约束，但是仍然建议遵循下面的目录结构，方便开发 123456789101112131415EasySwoole 项目部署目录 ├─App 应用目录(可以有多个) │ ├─HttpController 控制器目录 │ │ └─Index.php 默认控制器│ └─Model 模型文件目录├─Log 日志文件目录├─Temp 临时文件目录├─vendor 第三方类库目录├─composer.json Composer架构├─composer.lock Composer锁定├─EasySwooleEvent.php 框架全局事件├─easyswoole 框架管理脚本├─easyswoole.install 框架安装锁定文件├─dev.php 开发配置文件└─produce.php 生产配置文件 框架生命周期 服务管理123456789101112131415// 启动服务php easyswoole start// 守护模式启动php easyswoole start d// 生产环境启动php easyswoole start produce// 重启服务php easyswoole reload // 只重启task进程php easyswoole reload all // 重启task+worker进程// 停止服务php easyswoole stop 基础使用EasySwoole 有着默认的5个命令: 12345php easyswoole help 命令帮助php easyswoole install 安装php easyswoole start 启动php easyswoole stop 停止(需要守护进程)php easyswoole reload 热重启(需要守护进程) 自定义命令 新建文件 App/Command/Test.php: 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\Command;use EasySwoole\\EasySwoole\\Command\\CommandInterface;use EasySwoole\\EasySwoole\\Command\\Utility;class Test implements CommandInterface&#123; public function commandName() : string &#123; return 'test'; &#125; public function exec(array $args) : ? string &#123; var_dump($args); echo 'test' . PHP_EOL; return null; &#125; public function help(array $args) : ? string &#123; $logo = Utility::easySwooleLog(); return $logo . \"this is test\"; &#125;&#125; 注入命令 新增 /bootstrap.php 文件: 123&lt;?php\\EasySwoole\\EasySwoole\\Command\\CommandContainer::getInstance()-&gt;set(new \\App\\Command\\Test()); 执行命令 12345678910[root@caoxl easy_swoole]# php easyswoole help test ______ _____ _ | ____| / ____| | | | |__ __ _ ___ _ _ | (___ __ __ ___ ___ | | ___ | __| / _` | / __| | | | | \\___ \\ \\ \\ /\\ / / / _ \\ / _ \\ | | / _ \\ | |____ | (_| | \\__ \\ | |_| | ____) | \\ V V / | (_) | | (_) | | | | __/ |______| \\__,_| |___/ \\__, | |_____/ \\_/\\_/ \\___/ \\___/ |_| \\___| __/ | |___/this is test 自定义进程处理耗时任务，比如处理死循环队列消费，清除多余redis中的token数据等等。 定义一个进程类 1234567891011121314151617181920212223242526272829&lt;?phpnamespace App\\Process;use EasySwoole\\Component\\Process\\AbstractProcess;class Process extends AbstractProcess&#123; protected function run($arg) &#123; var_dump($this-&gt;getProcessName() . \" run\"); var_dump($arg); &#125; protected function onPipeReadable(\\Swoole\\Process $process) &#123; // 当有主进程对子进程发送消息的时候，会触发的回调，触发后，务必使用 &#125; protected function onShutDown() &#123; // 当该进程退出的时候，会执行该回调 &#125; protected function onException(\\Throwable $throwable, ...$args) &#123; // 当该进程出现异常的时候，会执行该回调 &#125;&#125; 注册进程 我们在 EasySwoole 全局的 mainServerCreate 事件中进行进程注册 1234567891011use App\\Process\\Process;use EasySwoole\\Component\\Process\\Config;$processConfig = new Config();$processConfig-&gt;setProcessName('testProcess');// 传递给进程的参数$processConfig-&gt;setArg([ 'arg1'=&gt;time()]);ServerManager::getInstance()-&gt;getSwooleServer()-&gt;addProcess((new Process($processConfig))-&gt;getProcess()); 自定义事件easyswoole中,通过Container容器可实现自定义事件功能 新增 App/Event/Event.php 文件 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\Event;use EasySwoole\\Component\\Container;use EasySwoole\\Component\\Singleton;class Event extends Container &#123; use Singleton; function set($key, $item) &#123; if (is_callable($item)) &#123; return parent::set($key, $item); &#125; else &#123; return false; &#125; &#125; function hook($event, ...$arg) &#123; $call = $this-&gt;get($event); if (is_callable($call)) &#123; return call_user_func($call, ...$arg); &#125; &#123; return null; &#125; &#125;&#125; 在框架的 initialize事件中进行注册事件: 12345678public static function initialize()&#123; // TODO: Implement initialize() method. date_default_timezone_set('Asia/Shanghai'); \\App\\Event\\Event::getInstance()-&gt;set('test', function () &#123; echo 'test event'; &#125;);&#125; 在其他任意位置调用: 1Event::getInstance()-&gt;hook('test');","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"},{"name":"EasySwoole","slug":"EasySwoole","permalink":"http://blog.caoxl.com/tags/EasySwoole/"}]},{"title":"PHP7 多版本新特性","slug":"PHP-New-Features","date":"2019-09-18T02:01:32.000Z","updated":"2019-09-18T06:24:44.000Z","comments":true,"path":"2019/09/18/PHP-New-Features/","link":"","permalink":"http://blog.caoxl.com/2019/09/18/PHP-New-Features/","excerpt":"在PHP8到来之前,更加充分的了解PHP7吧","text":"在PHP8到来之前,更加充分的了解PHP7吧 PHP7.3 新特性更灵活的Heredoc和Nowdoc语法doc字符串的结束标记不再需要后跟分号或换行符。另外，关闭标记可以是缩进的，在这种情况下，将从文档字符串中的所有行剥离缩进。 1234567891011121314151617181920212223// 除了这样：$query = &lt;&lt;&lt;SQLSELECT *FROM `table`WHERE `column` = true;SQL;// 这样也可以：$query = &lt;&lt;&lt;SQL SELECT * FROM `table` WHERE `column` = true; SQL; 函数调用中允许尾部逗号在参数、元素、变量列表结尾，追加尾部逗号。 1234567891011&lt;?phpuse Foo\\Bar\\&#123; Foo, Bar,&#125;;$foo = [ 'foo', 'bar',]; 数组支持引用赋值123&lt;?php[&amp;$a, [$b, &amp;$c]] = $d; list() 也支持相同的功能。 is_countable 函数在 PHP 7.2 中，用 count() 获取对象和数组的数量。如果对象不可数，PHP 会抛出警告 。所以需要检查对象或者数组是否可数。 PHP 7.3 提供新的函数 is_countable() 来解决这个问题。 1234567891011&lt;?php// PHP7.3 之前if (is_array($foo) || $foo instanceof Countable) &#123; // $foo 是可数的&#125;// PHP7.3 之后if (is_countable($foo)) &#123; // $foo 是可数的&#125; PHP7.2 新特性新的对象类型这种新的对象类型, object, 引进了可用于逆变（contravariant）参数输入和协变（covariant）返回任何对象类型。 12345678&lt;?phpfunction test(object $obj) : object&#123; return new SqlQueue();&#125;test(new Stdclass()); 允许重写抽象方法(Abstract method)当一个抽象类继承于另外一个抽象类的时候，继承后的抽象类可以重写被继承的抽象类的抽象方法。 1234567891011&lt;?phpabstract class A&#123; abstract function test(string $s);&#125;abstract class B extends A&#123; abstract function test($s) : int;&#125; 使用Argon2算法生成密码散列Argon2 已经被加入到密码散列（password hashing） API (这些函数以 password_ 开头), 以下是暴露出来的常量: PASSWORD_ARGON2I PASSWORD_ARGON2_DEFAULT_MEMORY_COST PASSWORD_ARGON2_DEFAULT_TIME_COST PASSWORD_ARGON2_DEFAULT_THERADS 允许分组命名空间的尾部逗号命名空间可以在PHP 7中使用尾随逗号进行分组引入。 1234567&lt;?phpuse Foo\\Bar\\&#123; Foo, Bar, Baz,&#125;; PHP7.1 新特性可为空（Nullable）类型参数以及返回值的类型现在可以通过在类型前加上一个问号使之允许为空。 当启用这个特性时，传入的参数或者函数返回的结果要么是给定的类型，要么是 null 。 123456789101112131415161718192021222324&lt;?phpfunction testReturn(): ?string&#123; return 'elePHPant';&#125;var_dump(testReturn());function testReturn2(): ?string&#123; return null;&#125;var_dump(testReturn2());function test(?string $name)&#123; var_dump($name);&#125;test('elePHPant');test(null);test(); Void 函数一个新的返回值类型 void 被引入。 返回值声明为 void 类型的方法要么干脆省去 return 语句，要么使用一个空的 return 语句。 对于 void 函数来说，NULL 不是一个合法的返回值。 12345678910111213141516&lt;?phpfunction swap(&amp;$left, &amp;$right) : void&#123; if ($left === $right) &#123; return; &#125; $tmp = $left; $left = $right; $right = $tmp;&#125;$a = 1;$b = 2;var_dump(swap($a, $b), $a, $b); 类常量可见性现在起支持设置类常量的可见性。 123456789&lt;?phpclass ConstDemo&#123; const PUBLIC_CONST_A = 1; public const PUBLIC_CONST_B = 2; protected const PROTECTED_CONST = 3; private const PRIVATE_CONST = 4;&#125; iterable 伪类现在引入了一个新的被称为 iterable 的伪类 (与callable类似)。 这可以被用在参数或者返回值类型中，它代表接受数组或者实现了Traversable接口的对象。 12345678&lt;?phpfunction iterator(iterable $iter)&#123; foreach ($iter as $val) &#123; var_dump($val); &#125;&#125; 多异常捕获处理一个catch语句块现在可以通过管道字符(|)来实现多个异常的捕获。 这对于需要同时处理来自不同类的不同异常时很有用。 1234567&lt;?phptry &#123; // some code&#125; catch (FirstException | SeconedException $e) &#123; // handle first and second exceptions&#125; list() 现在支持键名现在list()和它的新的[]语法支持在它内部去指定键名。这意味着它可以将任意类型的数组 都赋值给一些变量（与短数组语法类似） 123456789101112131415161718192021&lt;?php$data = [ [\"id\" =&gt; 1, \"name\" =&gt; 'Tom'], [\"id\" =&gt; 2, \"name\" =&gt; 'Fred'],];// list() stylelist(\"id\" =&gt; $id1, \"name\" =&gt; $name1) = $data[0];// [] style[\"id\" =&gt; $id1, \"name\" =&gt; $name1] = $data[0];// list() styleforeach ($data as list(\"id\" =&gt; $id, \"name\" =&gt; $name)) &#123; // logic here with $id and $name&#125;// [] styleforeach ($data as [\"id\" =&gt; $id, \"name\" =&gt; $name]) &#123; // logic here with $id and $name&#125; 支持为负的字符串偏移量现在所有支持偏移量的 字符串操作函数 都支持接受负数作为偏移量，包括通过[]或{} 操作字符串下标。在这种情况下，一个负数的偏移量会被理解为一个从字符串结尾开始的偏移量。 1234&lt;?phpvar_dump(\"abcdef\"[-2]);var_dump(strpos(\"aabbcc\", \"b\", -3)); 通过 Closure::fromCallable() 将 callables 转为闭包1234567891011121314&lt;?phppublic function exposeFunction()&#123; return Closure::fromCallable([$this, 'privateFunction']);&#125;private function privateFunction($param)&#123; var_dump($param);&#125;$privFunc = (new Test)-&gt;exposeFunction();$privFunc('some value'); 异步信号处理一个新的名为 pcntl_async_signals() 的方法现在被引入， 用于启用无需 ticks （这会带来很多额外的开销）的异步信号处理。 123456789&lt;?phppcntl_async_signals(true);pcntl_signal(SIGHUP, function ($sig) &#123; echo \"SIGHUP\\n\";&#125;);posix_kill(posix_getpid(), SIGHUP); PHP7.0 新特性标量类型声明标量 类型声明 有两种模式: 强制 (默认) 和 严格模式。 123456&lt;?phpfunction sumOfInts(int ...$ints)&#123; return array_sum($ints);&#125; 返回值类型声明PHP 7 增加了对返回类型声明的支持。 类似于参数类型声明，返回类型声明指明了函数返回值的类型。可用的类型与参数声明中可用的类型相同。 12345678910&lt;?phpfunction arraysSum(array ...$arrays) : array&#123; return array_map(function (array $array) : int &#123; return array_sum($array); &#125;, $arrays);&#125;print_r(arraysSum([1,2,3], [4,5,6], [7,8,9])); null合并运算符由于日常使用中存在大量同时使用三元表达式和 isset() 的情况， 我们添加了 null合并运算符 (??) 这个语法糖。如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。 123&lt;?php$username = $_GET['user'] ?? 'nobody'; 太空船操作符（组合比较符）太空船操作符用于比较两个表达式。当$a小于、等于或大于$b时它分别返回-1、0或1。 比较的原则是沿用 PHP 的常规比较规则进行的。 12345678910111213141516&lt;?php// 整数echo 1 &lt;=&gt; 1; // 0echo 1 &lt;=&gt; 2; // -1echo 2 &lt;=&gt; 1; // 1// 浮点数echo 1.5 &lt;=&gt; 1.5; // 0echo 1.5 &lt;=&gt; 2.5; // -1echo 2.5 &lt;=&gt; 1.5; // 1 // 字符串echo \"a\" &lt;=&gt; \"a\"; // 0echo \"a\" &lt;=&gt; \"b\"; // -1echo \"b\" &lt;=&gt; \"a\"; // 1 通过 define() 定义常量数组Array 类型的常量现在可以通过 define() 来定义。在 PHP5.6 中仅能通过 const 定义。 123456789&lt;?phpdefine('ANIMALS', [ 'dog', 'cat', 'bird']);echo ANIMALS[1]; // 输出 \"cat\" 匿名类现在支持通过 new class 来实例化一个匿名类，这可以用来替代一些“用后即焚”的完整类定义。 12345678910111213141516171819202122232425262728293031&lt;?phpinterface Logger&#123; public function log(string $msg);&#125;class Application&#123; private $logger; public function getLogger() : Logger &#123; return $this-&gt;logger; &#125; public function setLogger(Logger $logger) &#123; $this-&gt;logger = $logger; &#125;&#125;$app = new Application;$app-&gt;setLogger(new class implements Logger &#123; public function log(string $msg) &#123; echo $msg; &#125;&#125;);var_dump($app-&gt;getLogger()); Closure::call()Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它。 123456789101112&lt;?phpclass A &#123;private $x = 1;&#125;// PHP 7 之前版本的代码$getXCB = function() &#123;return $this-&gt;x;&#125;;$getX = $getXCB-&gt;bindTo(new A, 'A'); // 中间层闭包echo $getX();// PHP 7+ 及更高版本的代码$getX = function() &#123;return $this-&gt;x;&#125;;echo $getX-&gt;call(new A); 预期预期 是向后兼用并增强之前的 assert() 的方法。 它使得在生产环境中启用断言为零成本，并且提供当断言失败时抛出特定异常的能力。 1234567&lt;?phpini_set('assert.exception', 1);class CustomError extends AssertionError &#123;&#125;assert(false, new CustomError('Some error message')); Group use declarations从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了。 12345678910111213141516171819&lt;?php// PHP 7 之前的代码use some\\namespace\\ClassA;use some\\namespace\\ClassB;use some\\namespace\\ClassC as C;use function some\\namespace\\fn_a;use function some\\namespace\\fn_b;use function some\\namespace\\fn_c;use const some\\namespace\\ConstA;use const some\\namespace\\ConstB;use const some\\namespace\\ConstC;// PHP 7+ 及更高版本的代码use some\\namespace\\&#123;ClassA, ClassB, ClassC as C&#125;;use function some\\namespace\\&#123;fn_a, fn_b, fn_c&#125;;use const some\\namespace\\&#123;ConstA, ConstB, ConstC&#125;; 会话选项session_start() 可以接受一个 array 作为参数， 用来覆盖 php.ini 文件中设置的 会话配置选项。 123456&lt;?phpsession_start([ 'cache_limiter' =&gt; 'private', 'read_and_close' =&gt; true,]); CSPRNG Functions新加入两个跨平台的函数： random_bytes() 和 random_int() 用来产生高安全级别的随机字符串和随机整数。 random_bytes() 1234&lt;?php$bytes = random_bytes(5);var_dump(bin2hex($bytes)); random_int() 123&lt;?phpvar_dump(random_int(1000, 9999));","categories":[],"tags":[]},{"title":"基于Laravel 重写Logger","slug":"Laravel-Monolog-Logger","date":"2019-09-12T08:08:34.000Z","updated":"2019-09-12T08:15:10.000Z","comments":true,"path":"2019/09/12/Laravel-Monolog-Logger/","link":"","permalink":"http://blog.caoxl.com/2019/09/12/Laravel-Monolog-Logger/","excerpt":"基于Laravel 重写Logger方法","text":"基于Laravel 重写Logger方法 Support\\LogTool 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?phpnamespace App\\Support;use Monolog\\Handler\\AbstractProcessingHandler;use Monolog\\Handler\\RotatingFileHandler;use Monolog\\Logger;/** * Class LogTool * * @method static debug($msg, array $context=[]) * @method static info($msg, array $context=[]) * @method static notice($msg, array $context=[]) * @method static warning($msg, array $context=[]) * @method static error($msg, array $context=[]) * @method static critical($msg, array $context=[]) * @method static alert($msg, array $context=[]) * @method static emergency($msg, array $context=[]) * @package App\\Support */class LogTool&#123; const LEVEL_DEFAULT = 0; const LEVEL_STR = [ 'debug' =&gt; Logger::DEBUG, 'info' =&gt; Logger::INFO, 'notice' =&gt; Logger::NOTICE, 'warning' =&gt; Logger::WARNING, 'error' =&gt; Logger::ERROR, 'critical' =&gt; Logger::CRITICAL, 'alert' =&gt; Logger::ALERT, 'emergency' =&gt; Logger::EMERGENCY, ]; /** * @param $name * @param int $log_level * @param string $file_name * @return Logger * @throws \\Exception */ public static function getLogger($name, $log_level = self::LEVEL_DEFAULT, $file_name ='logger.log')&#123; if (self::LEVEL_DEFAULT == $log_level)&#123; $log_level = static::str2level(config('logging.level', 'info')); &#125; $days = config('logging.channels.daily.days', 10); $log_path = storage_path(). '/logs/' . $file_name; $logger = new Logger($name); $handler = new RotatingFileHandler($log_path, $days); $handler-&gt;setLevel( $log_level ); $logger-&gt;pushHandler( $handler); static::addDingHandler($logger); return $logger; &#125; /** * @param string $name * @return Logger * @throws \\Exception */ public static function getDefaultLogger(string $name = 'main') &#123; /** @var Logger $instance */ static $instance = null; if (null === $instance)&#123; $instance = LogTool::getLogger($name, self::LEVEL_DEFAULT, 'logger.log'); &#125; return $instance; &#125; /** * @param string $name * @return Logger * @throws \\Exception */ public static function getSqlLogger(string $name = 'main') &#123; /** @var Logger $instance */ static $instance = null; if (null === $instance)&#123; $instance = static::getLogger($name, self::LEVEL_DEFAULT, 'db_sql.log'); &#125; return $instance; &#125; /** * @param string $name * @return Logger * @throws \\Exception */ public static function getJobLogger(string $name = 'main') &#123; /** @var Logger $instance */ static $instance = null; if (null === $instance) &#123; $instance = static::getLogger($name, self::LEVEL_DEFAULT, 'job.log'); &#125; return $instance; &#125; /** * @param string $name * @return int|mixed */ public static function str2level(string $name) &#123; $name = strtolower($name); if (key_exists($name, static::LEVEL_STR)) &#123; return static::LEVEL_STR[$name]; &#125; else &#123; return Logger::INFO; &#125; &#125; /** * add support of ding message on ERROR detected in logging. * * @param Logger $logger */ public static function addDingHandler($logger) &#123; $handler = new class extends AbstractProcessingHandler &#123; public function write(array $record) &#123; if (config('logging.alert_ding', false) &amp;&amp; $record['level'] &gt;= 400)&#123; $msg = $record['channel'] . '.'. $record['level_name'] . ' ' . $record['message']; DingRobot::textMessage(DingRobot::DING_URL, $msg); &#125; &#125; &#125;; $logger-&gt;pushHandler($handler); &#125; /** * easy interface of psr Logger. * * @param $name * @param $arguments * @throws \\Exception */ public static function __callStatic($name, $arguments) &#123; static::getDefaultLogger()-&gt;$name(...$arguments); &#125;&#125; config\\logging 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?phpuse Monolog\\Handler\\StreamHandler;use Monolog\\Handler\\SyslogUdpHandler;return [ /* |-------------------------------------------------------------------------- | Default Log Channel |-------------------------------------------------------------------------- | | This option defines the default log channel that gets used when writing | messages to the logs. The name specified in this option should match | one of the channels defined in the \"channels\" configuration array. | */ 'default' =&gt; env('LOG_CHANNEL', 'stack'), /* |-------------------------------------------------------------------------- | Log Channels |-------------------------------------------------------------------------- | | Here you may configure the log channels for your application. Out of | the box, Laravel uses the Monolog PHP logging library. This gives | you a variety of powerful log handlers / formatters to utilize. | | Available Drivers: \"single\", \"daily\", \"slack\", \"syslog\", | \"errorlog\", \"monolog\", | \"custom\", \"stack\" | */ 'channels' =&gt; [ 'stack' =&gt; [ 'driver' =&gt; 'stack', 'channels' =&gt; ['daily'], 'ignore_exceptions' =&gt; false, ], 'single' =&gt; [ 'driver' =&gt; 'single', 'path' =&gt; storage_path('logs/laravel.log'), 'level' =&gt; 'debug', ], 'daily' =&gt; [ 'driver' =&gt; 'daily', 'path' =&gt; storage_path('logs/laravel.log'), 'level' =&gt; 'debug', 'days' =&gt; 14, ], 'slack' =&gt; [ 'driver' =&gt; 'slack', 'url' =&gt; env('LOG_SLACK_WEBHOOK_URL'), 'username' =&gt; 'Laravel Log', 'emoji' =&gt; ':boom:', 'level' =&gt; 'critical', ], 'papertrail' =&gt; [ 'driver' =&gt; 'monolog', 'level' =&gt; 'debug', 'handler' =&gt; SyslogUdpHandler::class, 'handler_with' =&gt; [ 'host' =&gt; env('PAPERTRAIL_URL'), 'port' =&gt; env('PAPERTRAIL_PORT'), ], ], 'stderr' =&gt; [ 'driver' =&gt; 'monolog', 'handler' =&gt; StreamHandler::class, 'formatter' =&gt; env('LOG_STDERR_FORMATTER'), 'with' =&gt; [ 'stream' =&gt; 'php://stderr', ], ], 'syslog' =&gt; [ 'driver' =&gt; 'syslog', 'level' =&gt; 'debug', ], 'errorlog' =&gt; [ 'driver' =&gt; 'errorlog', 'level' =&gt; 'debug', ], ],];","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Monolog","slug":"Monolog","permalink":"http://blog.caoxl.com/tags/Monolog/"},{"name":"Logger","slug":"Logger","permalink":"http://blog.caoxl.com/tags/Logger/"}]},{"title":"基于Laravel 请求频次监控器","slug":"Laravel-Rate-Monitor","date":"2019-09-12T06:45:55.000Z","updated":"2019-09-12T08:11:46.000Z","comments":true,"path":"2019/09/12/Laravel-Rate-Monitor/","link":"","permalink":"http://blog.caoxl.com/2019/09/12/Laravel-Rate-Monitor/","excerpt":"监控/限制请求频次","text":"监控/限制请求频次 Support\\RaitMonitor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?phpnamespace App\\Support;use Monolog\\Logger;/** * 监控API调用频次 * Class RateMonitor * @package App\\Support */class RateMonitor&#123; const KEY_NAME = 'rate_monitor'; const KEY_ALERT_COUNT = 'rate_alert'; const IN_SECOND = '1s'; const IN_MINUTE = '1m'; const IN_MINUTE_TEN = '10m'; const IN_HOUR = '1h'; const IN_DAY = '1d'; const DING_ROBOT = 'https://oapi.dingtalk.com/robot/send?access_token=5187cd15497ab1f440cb92c49eaf29e6477ec8786251ab00133d8a89b0ee7450'; const HASH_KEYS_EXPIRE = [ self::IN_SECOND =&gt; 1, self::IN_MINUTE =&gt; 60, self::IN_HOUR =&gt; 3600, self::IN_DAY =&gt; 86400, ]; /** * @var \\Redis */ protected $redis; /** * @var Logger */ protected $logger; /** * RateMonitor constructor. * @throws \\Exception */ public function __construct() &#123; $this-&gt;logger = LogTool::getLogger('monitor', Logger::INFO, 'rate-monitor.log'); $this-&gt;redis = RedisTool::getInstance(); &#125; /** * @param string $name 被调用路由 * @param string $item IP,用户ID,帐号或者null * @param array $limit 各种阀值(秒,分,时,日)，比如 [RateMonitor::IN_SECOND =&gt; 10,] * @param callable|null $on_overflow 调用频率超限后的回调函数，默认null则直接退出。 */ public function access(string $name, string $item, array $limit, callable $on_overflow = null) &#123; $value = []; if (empty($item)) &#123; $item = 'call'; &#125; foreach (self::HASH_KEYS_EXPIRE as $key =&gt; $expire) &#123; $hash_key = self::KEY_NAME . \"/$name/$item/$key\"; $value[$key] = $this-&gt;redis-&gt;incr($hash_key); if (1 == $value[$key]) &#123; $this-&gt;redis-&gt;expire($hash_key, $expire); &#125; if (array_key_exists($key, $limit) &amp;&amp; $limit[$key] &lt; $value[$key]) &#123; $this-&gt;logger-&gt;warn(\"$hash_key $value[$key] &gt; $limit[$key]\"); $alert_count = $this-&gt;redis-&gt;incr(self::KEY_ALERT_COUNT); if (1 == $alert_count) &#123; $this-&gt;redis-&gt;expire(self::KEY_ALERT_COUNT, 600); &#125; if ($alert_count % 20 == 1 &amp;&amp; $alert_count &gt; 1) &#123; DingRobot::textMessage(self::DING_ROBOT, \"10分钟内已经超频调用 $alert_count 次。\"); &#125; if ($on_overflow) &#123; $on_overflow($value); &#125; else &#123; $this-&gt;responseAndExit(); &#125; &#125; &#125; &#125; /** * 响应信息并退出 */ private function responseAndExit() &#123; $msg = array( 'err' =&gt; 4000, 'msg' =&gt; '数据请求过于频繁, 请稍后再试', 'dat' =&gt; null, ); echo json_encode($msg); exit; &#125; /** * @return RateMonitor|null * @throws \\Exception */ public static function getInstance() &#123; static $instance = null; if (null == $instance) &#123; $instance = new static(); &#125; return $instance; &#125;&#125; config/rate_monitor 1234567891011121314&lt;?phpuse App\\Support\\RateMonitor;return [ 'rate_monitor' =&gt; [ 'test_rate' =&gt; [ RateMonitor::IN_SECOND =&gt; 1, // 每秒种1次 RateMonitor::IN_MINUTE =&gt; 5, // 每分钟5次 RateMonitor::IN_HOUR =&gt; 10, // 每小时10次 RateMonitor::IN_DAY =&gt; 60, // 每天60次 ], ]]; test_rate_monitor 123456789/** * @param Request $request * @param RateMonitor $rate_monitor * @Post(\"/test_rate\") */public function test_rate_monitor(Request $request, RateMonitor $rate_monitor)&#123; $rate_monitor-&gt;access('test_rate', $request-&gt;ip(), config('rate_monitor.rate_monitor')['test_rate']);&#125; 附录 DingMsg DingMsg II Monolog - Logging for PHP 基于Laravel 重写Logger","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"RateMonitor","slug":"RateMonitor","permalink":"http://blog.caoxl.com/tags/RateMonitor/"}]},{"title":"基于Laravel 敏感词过滤","slug":"Laravel-Phrase-Filter","date":"2019-09-12T03:56:25.000Z","updated":"2019-09-12T06:47:46.000Z","comments":true,"path":"2019/09/12/Laravel-Phrase-Filter/","link":"","permalink":"http://blog.caoxl.com/2019/09/12/Laravel-Phrase-Filter/","excerpt":"敏感词过滤,不能让用户作死带动平台作死.","text":"敏感词过滤,不能让用户作死带动平台作死. PhraseFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;?phpnamespace App\\Support;use App\\Concerns\\Singleton;/** * 敏感词过滤 * Class PhraseFilter * @package App\\Support */class PhraseFilter&#123; use Singleton; const MATCH_SIZE = 256; public $matched; protected $source_txt; /** * PhraseFilter constructor. * @param string|null $source_txt */ public function __construct(string $source_txt = null) &#123; if (null === $source_txt) &#123; $source_txt = database_path() . '/app/filter_word.txt'; &#125; // PCRE的回溯限制 ini_set('pcre.backtrack_limit', '23001337'); // PCRE的递归限制 ini_set('pcre.recursion_limit', '23001337'); $this-&gt;source_txt = $source_txt; &#125; /** * @param string $target * @return string */ private function prepare(string $target) &#123; $target = strtolower($target); $pattern = \"/([0-9a-zA-Z\\x&#123;4e00&#125;-\\x&#123;9fa5&#125;]+)/u\"; preg_match_all($pattern, $target, $matched); $result = implode('', $matched[0]); return $result; &#125; /** * 检查是否匹配 * @param string $target * @param callable|null $callback * @return bool true:detected, false:not detected. */ public function match(string $target, callable $callback = null) &#123; static $patterns = null; if (null === $patterns) &#123; $patterns = $this-&gt;getPatterns(); &#125; $this-&gt;matched = null; $target = $this-&gt;prepare($target); foreach ($patterns as $pattern) &#123; if (preg_match($pattern, $target, $this-&gt;matched)) &#123; if (strlen($this-&gt;matched[0]) &gt; 0) &#123; if (!empty($callback)) &#123; $callback($this-&gt;matched); &#125; return true; &#125; &#125; &#125; return false; &#125; /** * 敏感词匹配规则 * @return array */ private function getPatterns() &#123; $src_txt = file_get_contents($this-&gt;source_txt); $src_txt = preg_replace('/(\\r\\n)|(\\r\\n)|(\\r)|(\\n)/', '|', $src_txt); $word_list = explode('|', $src_txt); $result = []; $word_count = count($word_list); for ($i = 0; $i &lt; $word_count; $i += self::MATCH_SIZE) &#123; $src = array_splice($word_list, 0, self::MATCH_SIZE); $src_count = count($src); if (empty($src[$src_count - 1])) &#123; $src = array_slice($src, 0, $src_count - 1); &#125; $result[] = '/' . implode('|', $src) . '/'; &#125; return $result; &#125;&#125; 使用test_filter 12345678910111213141516/** * @param Request $request * @param PhraseFilter $filter * @return mixed * @Get(\"/test_filter\") */public function test_filter(Request $request, PhraseFilter $filter)&#123; $word = $request-&gt;get('word'); if (true == $filter-&gt;match($word)) &#123; return System::apiResponse(4003, '含有敏感词'); &#125; return System::apiResponse(200, 'Success');&#125;","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"PhraseFilter","slug":"PhraseFilter","permalink":"http://blog.caoxl.com/tags/PhraseFilter/"}]},{"title":"Workerman 使用日志","slug":"Workerman-Learn-Notes","date":"2019-09-09T01:50:31.000Z","updated":"2019-09-10T07:12:46.000Z","comments":true,"path":"2019/09/09/Workerman-Learn-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/09/09/Workerman-Learn-Notes/","excerpt":"Workerman 是什么? Workerman，高性能socket服务框架Workerman - Github","text":"Workerman 是什么? Workerman，高性能socket服务框架Workerman - Github 下载/安装WorkerMan实际上就是一个PHP代码包，如果你的PHP环境已经装好，只需要把WorkerMan源代码或者demo下载下来即可运行。 Composer 安装 1composer require workerman/workerman 启动停止1234567891011121314151617181920# 启动// 以debug(调试)方式启动php start.php start// 以daemon(守护进程)方式启动php start.php start-d# 停止php start.php stop# 重启php start.php restart# 平滑重启php start.php reload# 查看状态php start.php status# 查看连接状态php start.php connections 简单的开发示例实例一、使用HTTP协议对外提供Web服务 Test/http_server.php 1234567891011121314151617181920&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;// 创建HTTP服务, 监听2345端口$http_worker = new Worker(\"http://0.0.0.0:2345\");// 进程数$http_worker-&gt;count = 4;// 收到数据时触发$http_worker-&gt;onMessage = function ($connection, $data) &#123; var_dump($_GET, $_POST, $_COOKIE, $_SESSION, $_SERVER, $_FILES); $connection-&gt;send(\"Hello Workerman\\n\");&#125;;// 运行WorkerWorker::runAll(); 命令行运行 (windows用户用 cmd命令行，下同) 123456$ php http_server.php----------------------- WORKERMAN -----------------------------Workerman version:3.5.22 PHP version:7.2.1------------------------ WORKERS -------------------------------worker listen processes statusnone http://0.0.0.0:2345 4 [ok] 测试 在浏览器中访问url http://127.0.0.1:2345 浏览器返回: Hello Workerman命令行: 打印数据$_GET等数据 实例二、使用WebSocket协议对外提供服务 Test\\websocket_server.php 1234567891011121314151617181920212223242526272829&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;// 创建Websocket服务$ws_worker = new Worker(\"websocket://0.0.0.0:2000\");// 进程数(windows下只有单进程)$ws_worker-&gt;count = 4;// 有新连接时触发$ws_worker-&gt;onConnect = function ($connection) &#123; echo \"New Connection\\n\";&#125;;// 收到数据时触发$ws_worker-&gt;onMessage = function ($connection, $data) &#123; // 向客户端发送消息 $connection-&gt;send('Hello' . $data);&#125;;$ws_worker-&gt;onClose = function ($connection) &#123; echo \"Connection Closed\\n\";&#125;;// 运行WorkerWorker::runAll(); 命令行运行 123456$ php websocket_server.php----------------------- WORKERMAN -----------------------------Workerman version:3.5.22 PHP version:7.2.1------------------------ WORKERS -------------------------------worker listen processes statusnone websocket://0.0.0.0:2000 4 [ok] 测试 打开chrome浏览器，按F12打开调试控制台，在Console一栏输入(或者把下面代码放入到html页面用js运行) 12345678910// 假设服务端ip为127.0.0.1ws = new WebSocket(\"ws://127.0.0.1:2000\");ws.onopen = function() &#123; alert(\"连接成功\"); ws.send('WEBSOCKET'); alert(\"给服务端发送一个字符串：WEBSOCKET\");&#125;;ws.onmessage = function(e) &#123; alert(\"收到服务端的消息：\" + e.data);&#125;; 实例三、直接使用TCP传输数据 Test\\tcp_server.php 1234567891011121314151617181920212223242526272829&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;// 创建TCP服务$tcp_worker = new Worker(\"tcp://0.0.0.0:1234\");// 进程数$tcp_worker-&gt;count = 4;// 有新连接时触发$tcp_worker-&gt;onConnect = function ($connection) &#123; echo \"New TCP Connection\\n\";&#125;;// 收到数据时触发$tcp_worker-&gt;onMessage = function ($connection, $data) &#123; $connection-&gt;send(\"hello tcp $data\");&#125;;// 关闭连接时触发$tcp_worker-&gt;onClose = function ($connection) &#123; echo \"Connection Closed\\n\";&#125;;// 运行WorkerWorker::runAll(); 命令行运行 123456$ php tcp_server.php----------------------- WORKERMAN -----------------------------Workerman version:3.5.22 PHP version:7.2.1------------------------ WORKERS -------------------------------worker listen processes statusnone tcp://0.0.0.0:1234 4 [ok] 测试: 命令行运行 1telnet 127.0.0.1 1234 开发须知目录结构12345678910111213141516171819202122232425262728293031323334Workerman # Workerman 内核代码 ├── Connection # Socket连接相关 │ ├── AsyncTcpConnection.php // 异步TCP连接类 │ ├── AsyncUdpConnection.php // 异步UDP连接类 │ ├── ConnectionInterface.php// Socket连接接口 │ ├── TcpConnection.php // TCP连接类 │ └── UdpConnection.php // UDP连接类 ├── Events # 网络事件库 │ ├── React ## 循环相关 │ │ ├── Base.php // mime类型 │ │ ├── ExtEventLoop.php // 外部事件循环 │ │ ├── ExtLibEventLoop.php // 外部库事件循环 │ │ └── StreamSelectLoop.php // 流选择循环 │ ├── Ev.php // Libev网络事件库 │ ├── Event.php // Livevent事件循环 │ ├── EventInterface.php // 网络事件库接口 │ ├── Libevent.php // Libevent网络事件库 │ ├── Select.php // Select网络事件库 │ └── Swoole.php // Swoole网络事件库 ├── Lib # 常用的类库 │ ├── Constants.php // 常量定义 │ └── Timer.php // 定时器 ├── Protocols # 协议相关 │ ├── Http ## Http协议相关 │ │ └── mime.types // mime类型 │ ├── Frame.php // Frame协议实现 │ ├── Http.php // Http协议实现 │ ├── ProtocolInterface.php // 协议接口类 │ ├── Text.php // Text协议实现 │ ├── Websocket.php // Websocket协议实现 │ └── Ws.php // 客户端的Websocket协议实现 ├── Autoloader.php // 自动加载类 ├── WebServer.php // WebServer └── Worker.php // Worker 通讯协议WorkerMan已经支持的协议12345678910111213141516171819use Workerman\\Worker;// websocket://0.0.0.0:2345 表明用websocket协议监听2345端口$websocket_worker = new Worker('websocket://0.0.0.0:2345');// text协议$text_worker = new Worker('text://0.0.0.0:2346');// frame协议$frame_worker = new Worker('frame://0.0.0.0:2347');// tcp Worker，直接基于socket传输，不使用任何应用层协议$tcp_worker = new Worker('tcp://0.0.0.0:2348');// udp Worker，不使用任何应用层协议$udp_worker = new Worker('udp://0.0.0.0:2349');// unix domain Worker，不使用任何应用层协议$unix_worker = new Worker('unix:///tmp/wm.sock'); 基础使用常见问题心跳检测注意：长连接应用必须加心跳，否则连接可能由于长时间未通讯被路由节点强行断开。 心跳作用主要有两个: 客户端定时给服务端发送点数据，防止连接由于长时间没有通讯而被某些节点的防火墙关闭导致连接断开的情况。 服务端可以通过心跳来判断客户端是否在线，如果客户端在规定时间内没有发来任何数据，就认为客户端下线。这样可以检测到客户端由于极端情况(断电、断网等)下线的事件。 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;use Workerman\\Lib\\Timer;// 心跳间隔59秒define('HEARTBEAT_TIME', 59);$text_worker = new Worker(\"text://0.0.0.0:2345\");$text_worker-&gt;onMessage = function ($connection, $msg) &#123; // 给connection临时设置一个 lastMsgTime 属性，用来记录上次收到消息的时间 $connection-&gt;lastMsgTime = time();&#125;;$text_worker-&gt;onWorkerStart = function ($worker) &#123; Timer::add(1, function () use ($worker) &#123; $time_now = time(); foreach ($worker-&gt;connections as $connection) &#123; // 有可能该connection还没收到过消息，则 lastMsgTime 设置为当前时间 if (empty($connection-&gt;lastMsgTime)) &#123; $connection-&gt;lastMsgTime = $time_now; continue; &#125; // 上次通讯时间间隔大于心跳间隔，则认为客户端已经下线，关闭连接 if ($time_now - $connection-&gt;lastMsgTime &gt; HEARTBEAT_TIME) &#123; $connection-&gt;close(); &#125; &#125;; &#125;);&#125;;Worker::runAll(); 以上配置为如果客户端超过59秒没有发送任何数据给服务端，则服务端认为客户端已经掉线，服务端关闭连接并触发onClose。 客户端连接失败原因连接失败客户端一般会有两种报错，connection refuse 和 connection timeout Connection refuse (连接拒绝) Connection timeout (连接超时) 是否支持多线程 ?Workerman有一个依赖pthreads扩展的MT多线程版本，但是由于pthreads扩展还不够稳定，所以这个Workerman多线程版本已经不再维护。 目前Workerman及其周边产品都是基于多进程单线程的。 支持哪些协议1234567891011121314151617// http协议$worker1 = new Worker('http://0.0.0.0:1221');// websocket协议$worker2 = new Worker('websocket://0.0.0.0:1222');// text文本协议（telnet协议）$worker3 = new Worker('text://0.0.0.0:1223');// frame文本协议（可用于二进制数传输）$worker3 = new Worker('frame://0.0.0.0:1223');// 直接基于tcp传输$worker4 = new Worker('tcp://0.0.0.0:1224');// 直接基于udp传输$worker5 = new Worker('udp://0.0.0.0:1225'); 对象和资源的持久化在传统的Web开发中，PHP创建的对象、数据、资源等会在请求完毕后全部释放，导致很难做到持久化。而在WorkerMan中可以轻松做到这些。 在WorkerMan中如果想在内存中永久保存某些数据资源，可以将资源放到全局变量中或者类的静态成员中 12345678910111213141516171819202122232425262728293031&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;$worker = new Worker(\"http://0.0.0.0:5678\");// 全局变量，保存当前进程的客户端连接数$connection_count = 0;// 进程数$worker-&gt;count = 4;$worker-&gt;onConnect = function ($connection) &#123; // 有新的客户端连接时，连接数+1 global $connection_count; ++$connection_count; echo \"现在客户端连接数为: $connection_count\\n\";&#125;;$worker-&gt;onClose = function ($connection) &#123; // 客户端关闭时，连接数-1 global $connection_count; $connection_count--; echo \"现在客户端连接数为: $connection_count\\n\";&#125;;Worker::runAll(); 支出多少并发并发概念太模糊，这里以两种可以量化的指标并发连接数和并发请求数来说明。 并发连接数 是指服务器当前时刻一共维持了多少TCP连接，而这些连接上是否有数据通讯并不关注，例如一台消息推送服务器上可能维持了百万的设备连接，由于连接上很少有数据通讯，所以这台服务器上负载可能几乎为0，只要内存足够，还可以继续接受连接。 并发连接数受限于服务器内存，一般24G内存workerman服务器可以支持大概120W并发连接。 并发请求数 一般用QPS（服务器每秒处理多少请求）来衡量，而当前时刻服务器上有多少个tcp连接并不十分关注。例如一台服务器只有10个客户端连接，每个客户端连接上每秒有1W个请求，那么要求服务端需要至少能支撑10*1W=10W每秒的吞吐量（QPS）。假设10W吞吐量每秒是这台服务器的极限，如果每个客户端每秒发送1个请求给服务端，那么这台服务器能够支撑10W个客户端。 并发请求数受限于服务器cpu处理能力，一台24核workerman服务器可以达到45W每秒的吞吐量(QPS)，实际值根据业务复杂度以及代码质量有所变化。 更改代码后不生效Workerman是常驻内存运行的，常驻内存可以避免重复读取磁盘、重复解释编译PHP，以便达到最高性能。所以更改业务代码后需要手动reload或者restart才能生效。 同时workerman提供一个监控文件更新的服务，该服务检测到有文件更新后会自动运行reload，从新载入PHP文件。开发者将其放入到项目中随着项目启动即可。 注意：windows系统不支持reload，无法使用监控服务 文件监控服务下载地址 无依赖版本：https://github.com/walkor/workerman-filemonitor 依赖inotify版本:https://github.com/walkor/workerman-filemonitor-inotify 向某个特定客户端发送数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;// 创建Websocket服务$worker = new Worker(\"websocket://0.0.0.0:2000\");// 进程数$worker-&gt;count = 1;// 新增加一个属性，用来保存uid到connection的映射(uid是用户id或者客户端唯一标识)$worker-&gt;uidConnections = array();$worker-&gt;onMessage = function ($connection, $data) &#123; global $worker; // 判断当前客户端是否已经验证,即是否设置了uid if (!isset($connection-&gt;uid)) &#123; // 没验证的话把第一个包当做uid（这里为了方便演示，没做真正的验证） $connection-&gt;uid = $data; $worker-&gt;uidConnections[$connection-&gt;uid] = $connection; return $connection-&gt;send(\"Login Success, your uid is $connection-&gt;uid\"); &#125; list($recv_uid, $msg) = explode(':', $data); // 全局广播 if ($recv_uid == 'all') &#123; broadcast($msg); &#125; else &#123; sendMsgByUid($recv_uid, $msg); &#125;&#125;;$worker-&gt;onClose = function ($connection) &#123; global $worker; if (isset($connection-&gt;uid)) &#123; // 连接断开时删除映射 unset($worker-&gt;uidConnections[$connection-&gt;uid]); &#125;&#125;;// 向所有验证的用户推送数据function broadcast($msg) &#123; global $worker; foreach ($worker-&gt;uidConnections as $connection) &#123; $connection-&gt;send($msg); &#125;&#125;// 针对uid推送数据function sendMsgByUid($uid, $msg) &#123; global $worker; if (isset($worker-&gt;uidConnections[$uid])) &#123; $connection = $worker-&gt;uidConnections[$uid]; $connection-&gt;send($msg); &#125;&#125;;Worker::runAll(); 前端调用 12345678var ws = new WebSocket('ws://127.0.0.1:2000');ws.onopen = function()&#123; var uid = 'uid1'; ws.send(uid);&#125;;ws.onmessage = function(e)&#123; alert(e.data);&#125;; 如何主动推送消息 可以用定时器定时推送数据 12345678910111213141516171819&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;use Workerman\\Lib\\Timer;$worker = new Worker(\"websocket://0.0.0.0:2000\");$worker-&gt;onWorkerStart = function ($worker) &#123; // 进程启动后定时推送数据给客户端 Timer::add(1, function () use ($worker) &#123; foreach ($worker-&gt;connections as $connection) &#123; $connection-&gt;send(\"Hello Man\"); &#125; &#125;);&#125;;Worker::runAll(); 如何实现异步任务 任务进程服务端 12345678910111213141516171819&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;$task_worker = new Worker(\"text://0.0.0.0:12345\");$task_worker-&gt;count = 100;$task_worker-&gt;name = 'TaskWorker';$task_worker-&gt;reusePort = true;$task_worker-&gt;onMessage = function ($connection, $task_data) &#123; // 假设发来的是json数据 $task_data = json_decode($task_data, true); $connection-&gt;send(json_encode($task_data));&#125;;Worker::runAll(); 在Wokerman中调用 1234567891011121314151617181920212223242526272829303132&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;use Workerman\\Connection\\AsyncTcpConnection;$worker = new Worker(\"websocket://0.0.0.0:8080\");$worker-&gt;onMessage = function ($ws_connection, $msg) &#123; // 与远程task服务建立异步连接，ip为远程task服务的ip，如果是本机就是127.0.0.1，如果是集群就是lvs的ip $task_connection = new AsyncTcpConnection('Text://127.0.0.1:12345'); // 任务及参数数据 $task_data = array( 'function' =&gt; 'send_mail', 'args' =&gt; array('from'=&gt;'xxx', 'to'=&gt;'xxx', 'contents'=&gt;'xxx'), ); // 发送数据 $task_connection-&gt;send(json_encode($task_data)); // 异步获取结果 $task_connection-&gt;onMessage = function ($task_connection, $task_result) use ($ws_connection) &#123; var_dump($task_result); $task_connection-&gt;close(); // 通知对应的websocket客户端任务完成 $ws_connection-&gt;send('task_complete'); &#125;; // 执行异步连接 $task_connection-&gt;connect();&#125;;Worker::runAll(); 在浏览器中访问 1234567var ws = new WebSocket('ws://127.0.0.1:8080');ws.onopen = function()&#123; ws.send();&#125;;ws.onmessage = function(e)&#123; alert(e.data);&#125;; 监听IPv6 问：如何让客户端即能通过ipv4地址访问，也能通过ipv6地址访问? 答：在初始化容器的时候监听地址写[::]即可。 12$worker = new Worker('http://[::]:8080');$gateway = new Gateway('websocket://[::]:8081'); PHP几种回调写法 匿名函数回调 1234567891011121314&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;$http_worker = new Worker(\"http://0.0.0.0:2345\");// 匿名函数回调$http_worker-&gt;onMessage = function ($connection, $data) &#123; $connection-&gt;send(\"Hello World\");&#125;;Worker::runAll(); 普通函数回调 12345678910111213141516&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;$http_worker = new Worker(\"http://0.0.0.0:2345\");$http_worker-&gt;onMessage = 'on_message';// 普通函数回调function on_message($connection, $data) &#123; $connection-&gt;send(\"Hello World\");&#125;;Worker::runAll(); 类方法作为回调 WorkerClass.php 1234567891011&lt;?phpclass WorkerClass&#123; public function __construct()&#123;&#125; public function onWorkerStart($worker)&#123;&#125; public function onConnect($connect)&#123;&#125; public function onMessage($connection, $message)&#123;&#125; public function onClose($connection)&#123;&#125; public function onWorkerStop($connection)&#123;&#125;&#125; 启动脚本 start.php 1234567891011121314151617181920&lt;?phpuse Workerman\\Worker;require_once '../vendor/autoload.php';require_once __DIR__ . '/WorkerClass.php';$worker = new Worker(\"websocket://0.0.0.0:1234\");// 创建对象$object = new WorkerClass();// 调用类的方法$worker-&gt;onWorkerStart = array($object, 'onWorkerStart');$worker-&gt;onConnect = array($object, 'onConnect');$worker-&gt;onMessage = array($object, 'onMessage');$worker-&gt;onClose = array($object, 'onClose');$worker-&gt;onWorkerStop = array($object, 'onWorkerStop');Worker::runAll(); 注意： 以上的代码结构不允许在构造函数里初始化资源(MySQL连接、Redis连接、Memcache连接等)，因为$my_object = new MyClass();运行在主进程。以MySQL为例，在主进程初始化的MySQL连接等资源会被子进程继承，每个子进程都可以操作这个数据库连接，但是这些连接在MySQL服务端对应的是同一个连接，会发生不可预期的错误，例如mysql gone away 错误。 以上代码结构如果需要在类的构造函数里初始化资源，可以采用以下写法。 WorkerClass.php 123456789101112131415&lt;?phpclass WorkerClass&#123; protected $db = null; public function __construct()&#123; // 假设数据库连接类是MyDbClass $db = new MyDbClass(); &#125; public function onWorkerStart($worker)&#123;&#125; public function onConnect($connect)&#123;&#125; public function onMessage($connection, $message)&#123;&#125; public function onClose($connection)&#123;&#125; public function onWorkerStop($connection)&#123;&#125;&#125; 启动脚本 start.php 1234567891011121314151617181920212223&lt;?phpuse Workerman\\Worker;require_once '../vendor/autoload.php';$worker = new Worker(\"websocket://0.0.0.0:1234\");$worker-&gt;onWorkerStart = function ($worker) &#123; require_once __DIR__ . '/WorkerClass.php'; // 创建对象 $object = new WorkerClass(); // 调用类的方法 $worker-&gt;onWorkerStart = array($object, 'onWorkerStart'); $worker-&gt;onConnect = array($object, 'onConnect'); $worker-&gt;onMessage = array($object, 'onMessage'); $worker-&gt;onClose = array($object, 'onClose'); $worker-&gt;onWorkerStop = array($object, 'onWorkerStop');&#125;;Worker::runAll(); 类的静态方法作为回调 1234567891011&lt;?phpclass WorkerClass&#123; public function __construct()&#123;&#125; public static function onWorkerStart($worker)&#123;&#125; public static function onConnect($connect)&#123;&#125; public static function onMessage($connection, $message)&#123;&#125; public static function onClose($connection)&#123;&#125; public static function onWorkerStop($connection)&#123;&#125;&#125; 接收一定请求后重启123456789101112131415&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;$worker = new Worker(\"websocket://0.0.0.0:8080\");$worker-&gt;onMessage = function ($connection, $data) &#123; static $request_count; if (++$request_count &gt; 10000) &#123; // 请求数达到10000后退出当前进程，主进程会自动重启一个新的进程 Worker::stopAll(); &#125;&#125;; Chrome 请求两次问题上面操作, 计数客户端连接操作,一次chrome请求有两个连接 12345678$ php global.php----------------------- WORKERMAN -----------------------------Workerman version:3.5.22 PHP version:7.2.1------------------------ WORKERS -------------------------------worker listen processes statusnone http://0.0.0.0:5678 4 [ok]现在客户端连接数为: 1现在客户端连接数为: 2 在Swoole里面找到了答案: Chrome 请求两次问题 使用Chrome浏览器访问服务器，会产生额外的一次请求，/favicon.ico，可以在代码中响应404错误。 12345678$http-&gt;on('request', function ($request, $response) &#123; if ($request-&gt;server['path_info'] == '/favicon.ico' || $request-&gt;server['request_uri'] == '/favicon.ico') &#123; return $response-&gt;end(); &#125; var_dump($request-&gt;get, $request-&gt;post); $response-&gt;header(\"Content-Type\", \"text/html; charset=utf-8\"); $response-&gt;end(\"&lt;h1&gt;Hello Swoole. #\".rand(1000, 9999).\"&lt;/h1&gt;\");&#125;); 相关协议Websocket 协议目前Workerman的WebSocke协议版本为13 WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信 123456789101112131415&lt;?phpuse Workerman\\Worker;require_once '../vendor/autoload.php';$websocket = new Worker(\"websocket://0.0.0.0:8181\");$websocket-&gt;onConnect = function ($connection) &#123; $connection-&gt;onWebSocketConnect = function ($connection, $http_header) &#123; if ($_SERVER['HTTP_ORIGIN'] != '127.0.0.1') &#123; $connection-&gt;close(); &#125; &#125;;&#125;; WS 协议目前Workerman的ws协议版本为13 workerman可以作为客户端通过ws协议发起websocket连接，连到远程websocket服务器，实现双向通讯。 注意：ws协议只能通过AsyncTcpConnection作为客户端使用，不能作为websocket服务端监听协议。也就是说以下写法是错误的。 1$worker = new Worker('ws://0.0.0.0:8080'); ws作为websocket客户端协议示例： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;use Workerman\\Connection\\AsyncTcpConnection;$worker = new Worker();// 进程启动时$worker-&gt;onWorkerStart = function () &#123; // 以websocket协议连接远程websocket服务器 $ws_connection = new AsyncTcpConnection(\"ws:echo.websocket.org:80\"); // 连上后发送Hello字符串 $ws_connection-&gt;onConnect = function ($connection) &#123; $connection-&gt;send('Hello'); &#125;; // 远程websocket服务器发来消息时 $ws_connection-&gt;onMessage = function ($connection, $data) &#123; echo \"recv: $data\\n\"; &#125;; // 连接上发生错误时，一般是连接远程websocket服务器失败错误 $ws_connection-&gt;onError = function ($connection, $code, $msg) &#123; echo \"error: $msg\\n\"; &#125;; // 当连接远程websocket服务器的连接断开时 $ws_connection-&gt;onClose = function ($connection) &#123; echo \"connection closed\\n\"; &#125;; // 设置好以上各种回调后，执行连接操作 $ws_connection-&gt;connect();&#125;;Worker::runAll(); Text 协议Workerman定义了一种叫做text的文本协议，协议格式为 数据包+换行符，即在每个数据包末尾加上一个换行符表示包的结束。 1234567891011121314&lt;?phprequire_once '../vendor/autoload.php';use Workerman\\Worker;$text_worker = new Worker(\"text://0.0.0.0:5678\");$text_worker-&gt;onMessage = function ($connection, $data) &#123; var_dump($data); $connection-&gt;send(\"hello world\");&#125;;Worker::runAll(); Frame 协议workerman定义了一种叫做frame的协议，协议格式为 总包长+包体，其中包长为4字节网络字节序的整数，包体可以是普通文本或者二进制数据。 1234567891011121314151617181920212223242526272829&lt;?phpuse Workerman\\Connection\\TcpConnection;class Frame&#123; public static function input($buffer, TcpConnection $connection) &#123; if (strlen($buffer) &lt; 4) &#123; return 0; &#125; $unpack_data = unpack('Ntotal_length', $buffer); return $unpack_data['total_length']; &#125; public static function decode($buffer) &#123; return substr($buffer, 4); &#125; public static function encode($buffer) &#123; $total_length = 4 + strlen($buffer); return pack('N', $total_length) . $buffer; &#125;&#125; 参考 Workerman 中文文档 Workerman Github","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Workerman","slug":"Workerman","permalink":"http://blog.caoxl.com/tags/Workerman/"}]},{"title":"MongoDB 命令","slug":"MongoDB-Command-Learning","date":"2019-09-06T03:52:29.000Z","updated":"2019-09-06T08:52:43.000Z","comments":true,"path":"2019/09/06/MongoDB-Command-Learning/","link":"","permalink":"http://blog.caoxl.com/2019/09/06/MongoDB-Command-Learning/","excerpt":"MongoDB 数据库常用命令","text":"MongoDB 数据库常用命令 连接数据库 12345$ mongo --host localhost --port 27017 -u '' -p ''MongoDB shell version v4.0.10connecting to: mongodb://localhost:27017/?gssapiServiceName=mongodbImplicit session: session &#123; \"id\" : UUID(\"00722255-7236-47ae-85f4-6c731115fac9\")&#125;MongoDB server version: 4.0.10 Help查看命令提示 123helpdb.help();db.yourColl.help(); 切换/创建数据库 123// 当创建一个集合(table)的时候会自动创建当前数据库use test_mongo_1switched to db test_mongo_1 查看所有数据库 123456show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBmongo_test 0.000GBmongodb 0.000GB 删除当前使用数据库 1234use mongodb;switched to db mongodbdb.dropDatabase();&#123; \"dropped\" : \"mongodb\", \"ok\" : 1 &#125; 从指定主机上克隆数据库 1db.cloneDatabase(\"127.0.0.1\"); 从指定的机器上复制到指定数据库到某个数据库 1234567// 将本机的 mongo_test 的数据复制到 mongodb 数据库中db.copyDatabase(\"mongo_test\", \"mongodb\", \"127.0.0.1\");WARNING: db.copyDatabase is deprecated. See http://dochub.mongodb.org/core/copydb-clone-deprecation&#123; \"note\" : \"Support for the copydb command has been deprecated. See http://dochub.mongodb.org/core/copydb-clone-deprecation\", \"ok\" : 1&#125; MongoDB 4.0不推荐使用copydb 和clone命令及其 ~bin.mongo shell帮助程序db.copyDatabase（）和 db.cloneDatabase（）。 作为替代方案，用户可以使用mongodump和 mongorestore或写入使用驱动程序的脚本。 修复当前数据库 12db.repairDatabase();&#123; \"ok\" : 1 &#125; 显示当前数据库状态 12345678910111213141516db.stats();&#123; \"db\" : \"mongodb\", \"collections\" : 1, \"views\" : 0, \"objects\" : 3, \"avgObjSize\" : 65, \"dataSize\" : 195, \"storageSize\" : 16384, \"numExtents\" : 0, \"indexes\" : 1, \"indexSize\" : 16384, \"fsUsedSize\" : 70578573312, \"fsTotalSize\" : 107377324032, \"ok\" : 1&#125; 查看当前使用的数据库 12db.getName();mongodb 查看当前数据库版本 12db.version();4.0.10 查看当前数据库的连接服务器地址 12db.getMongo();connection to localhost:27017 查看/清除 之前的错误信息 12345db.getPrevError();&#123; \"err\" : null, \"n\" : 0, \"nPrev\" : -1, \"ok\" : 1 &#125;db.resetError();&#123; \"ok\" : 1 &#125; MongoDB Collection 集合 创建一个集合(table) 12db.createCollection(\"coll_test\", &#123;size:20, capped: 5, max: 100&#125;);&#123; \"ok\" : 1 &#125; 判断集合是否为定容量 12db.coll_test.isCapped(5);true 查看指定名称的集合(table) 12db.getCollection(\"mongo_test\");mongo_test.mongo_test 查看当前db的所有集合 12db.getCollectionNames();[ \"coll_test\", \"mongo_test\" ] 查看当前集合所有集合索引的状态 1db.printCollectionStats(); 查看指定集合的数据条数 12db.mongo_test.count();3 查看指定集合数据空间大小 12db.mongo_test.dataSize();195 查看当前集合所在的db 12db.mongo_test.getDB();mongo_test 查看当前集合的状态 123456db.coll.stats();&#123; \"ns\" : \"mongo_test.coll\", \"ok\" : 0, \"errmsg\" : \"Collection [mongo_test.coll] not found.\"&#125; 查看指定集合总大小 12db.mongo_test.totalSize();73728 查看指定集合存储空间大小 12db.mongo_test.storageSize();36864 集合重命名 1234db.coll_test.renameCollection(\"mongo_coll\");&#123; \"ok\" : 1 &#125;db.getCollectionNames();[ \"mongo_coll\", \"mongo_test\" ] 删除当前集合 123456db.getCollectionNames();[ \"mongo_coll\", \"mongo_test\" ]db.mongo_coll.drop();truedb.getCollectionNames();[ \"mongo_test\" ] MongoDB 用户相关 创建一个用户 1234567891011// 添加用户、设置密码、是否只读db.createUser(&#123;user: 'caoxl', pwd: '110119', roles: [&#123;role: 'readWrite', db: 'mongo_test'&#125;]&#125;);Successfully added user: &#123; \"user\" : \"caoxl\", \"roles\" : [ &#123; \"role\" : \"readWrite\", \"db\" : \"mongo_test\" &#125; ]&#125; 数据库认证、安全模式登录 12db.auth(\"caoxl\", \"110119\");1 显示当前所有用户 1234567891011121314151617show users;&#123; \"_id\" : \"mongo_test.caoxl\", \"userId\" : UUID(\"3ac6d4e3-ef04-45a6-80eb-8bd4b580ba9f\"), \"user\" : \"caoxl\", \"db\" : \"mongo_test\", \"roles\" : [ &#123; \"role\" : \"readWrite\", \"db\" : \"mongo_test\" &#125; ], \"mechanisms\" : [ \"SCRAM-SHA-1\", \"SCRAM-SHA-256\" ]&#125; 删除用户 12db.dropUser(\"caoxl\");true MongoDB 集合查询 查询指定集合所有记录 1234db.mongo_test.find();&#123; \"_id\" : ObjectId(\"5d71c62e8fb10c51c07d47b1\"), \"key_1\" : \"value_1\" &#125;&#123; \"_id\" : ObjectId(\"5d71c7528fb10c51c07d47b3\"), \"key_2\" : \"value_2\" &#125;&#123; \"_id\" : ObjectId(\"5d71d685f343000023004253\"), \"name\" : \"test_name_1\", \"info\" : \"更新后的信息\", \"updated_at\" : ISODate(\"2019-09-06T03:49:18Z\"), \"created_at\" :ISODate(\"2019-09-06T03:46:13Z\") &#125; 默认每页显示20条记录，当显示不下的情况下，可以用it迭代命令查询下一页数据。注意：键入it命令不能带”;” 但是你可以设置每页显示数据的大小，用DBQuery.shellBatchSize= 50;这样每页就显示50条记录了。 12345678DBQuery.shellBatchSize=2;2db.mongo_test.find();&#123; \"_id\" : ObjectId(\"5d71c62e8fb10c51c07d47b1\"), \"key_1\" : \"value_1\" &#125;&#123; \"_id\" : ObjectId(\"5d71c7528fb10c51c07d47b3\"), \"key_2\" : \"value_2\" &#125;Type \"it\" for moreit&#123; \"_id\" : ObjectId(\"5d71d685f343000023004253\"), \"name\" : \"test_name_1\", \"info\" : \"更新后的信息\", \"updated_at\" : ISODate(\"2019-09-06T03:49:18Z\"), \"created_at\" :ISODate(\"2019-09-06T03:46:13Z\") &#125; 查询去重后的数据 12db.mongo_test.distinct(\"name\");[ \"test_name_1\" ] 查看 key_1 = ‘value_1’ 的记录 12db.mongo_test.find(&#123;\"key_1\": \"value_1\"&#125;);&#123; \"_id\" : ObjectId(\"5d71c62e8fb10c51c07d47b1\"), \"key_1\" : \"value_1\" &#125; 条件查询 1234567891011121314151617MongoDB中条件操作符有：(&gt;) 大于 – $gt(&lt;) 小于 – $lt(&gt;=) 大于等于 – $gte(&lt;= ) 小于等于 – $ltedb.userInfo.find(&#123;age: &#123;$gt: 22&#125;&#125;);// 相当于：select * from userInfo where age&gt;22; db.userInfo.find(&#123;age: &#123;$lt: 22&#125;&#125;);// 相当于：select * from userInfo where age&lt;22;db.userInfo.find(&#123;age: &#123;$gte: 25&#125;&#125;);// 相当于：select * from userInfo where age &gt;= 25; db.userInfo.find(&#123;age: &#123;$lte: 25&#125;&#125;);// 相当于：select * from userInfo where age &lt;= 25; and查询 12345db.userInfo.find(&#123;age: &#123;$gte: 23, $lte: 26&#125;&#125;);// 相当于：select * from userInfo wher age &gt;=23 and age &lt;=26db.userInfo.find(&#123;name: 'raykaeso', age: 22&#125;);// 相当于：select * from userInfo where name = 'raykaeso' and age = '22′; or查询 12db.userInfo.find(&#123;$or: [&#123;age: 22&#125;, &#123;age: 25&#125;]&#125;);// 相当于：select * from userInfo where age = 22 or age = 25; 字符模糊查询 12db.mongo_test.find(&#123;name: /test_name/&#125;);&#123; \"_id\" : ObjectId(\"5d71d685f343000023004253\"), \"name\" : \"test_name_1\", \"info\" : \"更新后的信息\", \"updated_at\" : ISODate(\"2019-09-06T03:49:18Z\"), \"created_at\" :ISODate(\"2019-09-06T03:46:13Z\") &#125; 查询指定列数据 123db.userInfo.find(&#123;&#125;, &#123;name: 1, age: 1&#125;);// 相当于：select name, age from userInfo;// 当然name也可以用true或false 按条件查询指定列数据 12db.userInfo.find(&#123;age: &#123;$gt: 25&#125;&#125;, &#123;name: 1, age: 1&#125;);// 相当于：select name, age from userInfo where age &lt;25; 排序 12升序: db.userInfo.find().sort(&#123;age: 1&#125;);降序: db.userInfo.find().sort(&#123;age: -1&#125;); 查询前n条数据 123db.mongo_test.find().limit(2);&#123; \"_id\" : ObjectId(\"5d71c62e8fb10c51c07d47b1\"), \"key_1\" : \"value_1\" &#125;&#123; \"_id\" : ObjectId(\"5d71c7528fb10c51c07d47b3\"), \"key_2\" : \"value_2\" &#125; 查询n条以后的数据 12db.mongo_test.find().skip(2);&#123; \"_id\" : ObjectId(\"5d71d685f343000023004253\"), \"name\" : \"test_name_1\", \"info\" : \"更新后的信息\", \"updated_at\" : ISODate(\"2019-09-06T03:49:18Z\"), \"created_at\" :ISODate(\"2019-09-06T03:46:13Z\") &#125; 分页查询数据 123db.mongo_test.find().limit(2).skip(1);&#123; \"_id\" : ObjectId(\"5d71c7528fb10c51c07d47b3\"), \"key_2\" : \"value_2\" &#125;&#123; \"_id\" : ObjectId(\"5d71d685f343000023004253\"), \"name\" : \"test_name_1\", \"info\" : \"更新后的信息\", \"updated_at\" : ISODate(\"2019-09-06T03:49:18Z\"), \"created_at\" :ISODate(\"2019-09-06T03:46:13Z\") &#125; 查询第一条数据 12db.mongo_test.findOne();&#123; \"_id\" : ObjectId(\"5d71c62e8fb10c51c07d47b1\"), \"key_1\" : \"value_1\" &#125; 数据求和 12db.mongo_test.find().count();3 MongoDB 索引 创建索引 123456789101112131415db.mongo_test.ensureIndex(&#123;test_index: 1&#125;);&#123; \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 1, \"numIndexesAfter\" : 2, \"ok\" : 1&#125;db.mongo_test.ensureIndex(&#123;test_index_1: 1, ts: -1&#125;);&#123; \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 2, \"numIndexesAfter\" : 3, \"ok\" : 1&#125; 查看当前集合所有索引 12345678910111213141516171819202122232425262728db.mongo_test.getIndexes();[ &#123; \"v\" : 2, \"key\" : &#123; \"_id\" : 1 &#125;, \"name\" : \"_id_\", \"ns\" : \"mongo_test.mongo_test\" &#125;, &#123; \"v\" : 2, \"key\" : &#123; \"test_index\" : 1 &#125;, \"name\" : \"test_index_1\", \"ns\" : \"mongo_test.mongo_test\" &#125;, &#123; \"v\" : 2, \"key\" : &#123; \"test_index_1\" : 1, \"ts\" : -1 &#125;, \"name\" : \"test_index_1_1_ts_-1\", \"ns\" : \"mongo_test.mongo_test\" &#125;] 查看总索引记录大小 12db.mongo_test.totalIndexSize();69632 查看当前集合的所有索引信息 123456789101112131415161718192021222324252627282930313233db.mongo_test.reIndex();&#123; \"nIndexesWas\" : 3, \"nIndexes\" : 3, \"indexes\" : [ &#123; \"v\" : 2, \"key\" : &#123; \"_id\" : 1 &#125;, \"name\" : \"_id_\", \"ns\" : \"mongo_test.mongo_test\" &#125;, &#123; \"v\" : 2, \"key\" : &#123; \"test_index\" : 1 &#125;, \"name\" : \"test_index_1\", \"ns\" : \"mongo_test.mongo_test\" &#125;, &#123; \"v\" : 2, \"key\" : &#123; \"test_index_1\" : 1, \"ts\" : -1 &#125;, \"name\" : \"test_index_1_1_ts_-1\", \"ns\" : \"mongo_test.mongo_test\" &#125; ], \"ok\" : 1&#125; 删除指定索引 12db.mongo_test.dropIndex(\"test_index_1\");&#123; \"nIndexesWas\" : 3, \"ok\" : 1 &#125; 删除所有索引 123456db.mongo_test.dropIndexes();&#123; \"nIndexesWas\" : 1, \"msg\" : \"non-_id indexes dropped for collection\", \"ok\" : 1&#125; MongoDB 增删改 集合数据 添加数据 12db.mongo_test.save(&#123;name: 'caoxl', age: '25', sex: true&#125;);WriteResult(&#123; \"nInserted\" : 1 &#125;) 添加的数据的数据列，没有固定，根据添加的数据为准 修改数据 12345678db.mongo_test.find();&#123; \"_id\" : ObjectId(\"5d7217cca3a236aae02357ca\"), \"name\" : \"caoxl\", \"age\" : \"25\",\"sex\" : true &#125;db.mongo_test.update(&#123;\"age\": \"25\"&#125;, &#123;$set: &#123;name: 'changeName'&#125;&#125;, false, true);WriteResult(&#123; \"nMatched\" : 1, \"nUpserted\" : 0, \"nModified\" : 1 &#125;)db.mongo_test.find();&#123; \"_id\" : ObjectId(\"5d7217cca3a236aae02357ca\"), \"name\" : \"changeName\", \"age\" : \"25\", \"sex\" : true &#125; 删除数据 12db.mongo_test.remove(&#123;\"age\": \"25\"&#125;);WriteResult(&#123; \"nRemoved\" : 1 &#125;) 查询修改删除 12345db.mongo_test.findAndModify(&#123; query: &#123;age: &#123;$gte: 25&#125;&#125;, update: &#123;$set: &#123;\"name\": \"caoxl\"&#125;, $inc: &#123;\"age\": 2&#125;&#125;, remove: false&#125;); 其他 MongoDB 简介 MongoDB 可视化管理工具 基于Laravel MongoDB的部分实践","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.caoxl.com/tags/MongoDB/"}]},{"title":"Redis 命令 II","slug":"Learn-Redis-Command-II","date":"2019-09-06T01:48:32.000Z","updated":"2019-09-06T01:51:06.000Z","comments":true,"path":"2019/09/06/Learn-Redis-Command-II/","link":"","permalink":"http://blog.caoxl.com/2019/09/06/Learn-Redis-Command-II/","excerpt":"Redis 命令记录","text":"Redis 命令记录 string123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Redis-字符串 * @Post(\"/test_string\") */public function test_string()&#123; // 如果 key 已经持有其他值， SET 就覆写旧值， 无视类型 $this-&gt;redis-&gt;set('key_set', 'value_set', 3600); // 只在键 key 不存在的情况下， 将键 key 的值设置为 value;命令在设置成功时返回 1 ， 设置失败时返回 0 。 $this-&gt;redis-&gt;setnx('key_setnx', 'value_setnx'); // 将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds `秒` 钟。 $this-&gt;redis-&gt;setex('key_setex', 3600, 'value_setex'); // 这个命令和 SETEX 命令相似， 但它以 `毫秒` 为单位设置 key 的生存时间， 而不是像 SETEX 命令那样以秒为单位进行设置。 $this-&gt;redis-&gt;psetex('key_psetex', 3600, 'value_psetex'); // 如果键 key 不存在， 那么返回特殊值 nil ； 否则， 返回键 key 的值。 $this-&gt;redis-&gt;get('key_set'); // 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值; // 如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil 。 $this-&gt;redis-&gt;getSet('key_get_set', 'value_get_set'); // 返回键 key 储存的字符串值的长度; 当键 key 不存在时， 命令返回 0 ;当 key 储存的不是字符串值时， 返回一个错误。 $this-&gt;redis-&gt;strlen('key_set'); // 如果键 key 已经存在并且它的值是一个字符串， APPEND 命令将把 value 追加到键 key 现有值的末尾。 // 如果 key 不存在， APPEND 就简单地将键 key 的值设为 value ， 就像执行 SET key value 一样。 $this-&gt;redis-&gt;append('key_set', 'value_append'); // 从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。 $this-&gt;redis-&gt;setRange('key_range', 0, 'value_range'); // 返回键 key 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。 $this-&gt;redis-&gt;getRange('key_range', 0, 1000); // 为键 key 储存的数字值加上一;如果键 key 储存的值不能被解释为数字， 那么 INCR 命令将返回一个错误。 // 如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 INCR 命令。 $this-&gt;redis-&gt;incr('key_incr'); // 为键 key 储存的数字值加上增量 increment 。 $this-&gt;redis-&gt;incrBy('key_incr_by', 10); // 为键 key 储存的值加上浮点数增量 increment 。 // 如果键 key 不存在， 那么 INCRBYFLOAT 会先将键 key 的值设为 0 ， 然后再执行加法操作。 $this-&gt;redis-&gt;incrByFloat('key_incr_by', '10.24'); // 为键 key 储存的数字值减去一。 $this-&gt;redis-&gt;decr('key_decr'); // 将键 key 储存的整数值减去减量 decrement $this-&gt;redis-&gt;decrBy('key_decr', 10); // 同时为多个键设置值。如果某个给定键已经存在， 那么 MSET 将使用新值去覆盖旧值 $this-&gt;redis-&gt;mset([ 'key_mset_1' =&gt; 'value_mset_1', 'key_mset_2' =&gt; 'value_mset_2', ]); // 当且仅当所有给定键都不存在时， 为所有给定键设置值。 // 即使只有一个给定键已经存在， MSETNX 命令也会拒绝执行对所有键的设置操作。 $this-&gt;redis-&gt;msetnx([ 'key_mset_1' =&gt; 'value_mset_1', 'key_mset_2' =&gt; 'value_mset_2', ]); // 返回给定的一个或多个字符串键的值。 // 如果给定的字符串键里面， 有某个键不存在， 那么这个键的值将以特殊值 nil 表示。 $this-&gt;redis-&gt;mget(['key_mset_1','key_mset_2']);&#125; hash1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Redis-哈希表 * @Post(\"/test_hash\") */public function test_hash()&#123; // 将哈希表 hash 中域 field 的值设置为 value 。 // 如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。 $this-&gt;redis-&gt;hSet('key_hset', 'hashKey', 'value_hset'); // 当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value 。 // 如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。 $this-&gt;redis-&gt;hSetNx('key_hsetnx', 'hashKey', 'value_hsetnx'); // 返回哈希表中给定域的值。 $this-&gt;redis-&gt;hGet('key_hset', 'hashKey'); // 检查给定域 field 是否存在于哈希表 hash 当中。 // HEXISTS 命令在给定域存在时返回 1 ， 在给定域不存在时返回 0 。 $this-&gt;redis-&gt;hExists('key_hset', 'hashKey'); // 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。 $this-&gt;redis-&gt;hDel('key_hdel', 'hashKey', 'hashKey2'); // 返回哈希表 key 中域的数量。 $this-&gt;redis-&gt;hLen('key_hset'); // 返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。 // $this-&gt;redis-&gt;hstrlen() // 为哈希表 key 中的域 field 的值加上增量 increment 。 // 增量也可以为负数，相当于对给定域进行减法操作。 $this-&gt;redis-&gt;hIncrBy('key_hincr', 'hashKey', 'value_hincr'); // 为哈希表 key 中的域 field 加上浮点数增量 increment 。 $this-&gt;redis-&gt;hIncrByFloat('hashKey', 'key_hincr', 10.24); // 同时将多个 field-value (域-值)对设置到哈希表 key 中。 $this-&gt;redis-&gt;hMSet('key_hmset', [ 'hashKey1' =&gt; 'hashValue1', 'hashKey2' =&gt; 'hashValue2' ]); // 返回哈希表 key 中，一个或多个给定域的值。 $this-&gt;redis-&gt;hMGet('key_hmset', ['hashKey1', 'hashKey2']); // 返回哈希表 key 中的所有域。 $this-&gt;redis-&gt;hKeys('hashKey'); // 返回哈希表 key 中所有域的值。 $this-&gt;redis-&gt;hVals('key_hset'); // 返回哈希表 key 中，所有的域和值。 // 在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。 $this-&gt;redis-&gt;hGetAll('key_hset'); // 用于迭代哈希键中的键值对。 $this-&gt;redis-&gt;hScan('key_hset', '', '', '');&#125; list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Redis-列表 * @Post(\"/test_list\") */public function test_list()&#123; // 将一个或多个值 value 插入到列表 key 的表头 $this-&gt;redis-&gt;lPush('key_lpush', 'value_1', 'value_2'); // 将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。 // 当 key 不存在时， LPUSHX 命令什么也不做。 $this-&gt;redis-&gt;lPushx('key_lpush', 'value_3'); // 将一个或多个值 value 插入到列表 key 的表尾(最右边)。 $this-&gt;redis-&gt;rPush('key_rpush', 'value_1', 'value_2'); // 将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。 $this-&gt;redis-&gt;rPushx('key_rpush', 'value_3'); // 移除并返回列表 key 的头元素。列表的头元素。 当 key 不存在时，返回 nil 。 $this-&gt;redis-&gt;lPop('key_lpush'); // 移除并返回列表 key 的尾元素。列表的尾元素。 当 key 不存在时，返回 nil 。 $this-&gt;redis-&gt;rPop('key_rpush'); // 将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。 // 将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。 $this-&gt;redis-&gt;rpoplpush('key_src', 'key_dst'); // 根据参数 count 的值，移除列表中与参数 value 相等的元素。 // count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。 // count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。 // count = 0 : 移除表中所有与 value 相等的值。 $this-&gt;redis-&gt;lRem('key_lrem', 3, 0); // 返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 . $this-&gt;redis-&gt;lLen('key_lpush'); // 返回列表 key 中，下标为 index 的元素。 $this-&gt;redis-&gt;lIndex('key_lpush', 3); // 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。 // 当 pivot 不存在于列表 key 时，不执行任何操作。 $this-&gt;redis-&gt;lInsert('key_lpush', 0, 1, 'value_lpush'); // 将列表 key 下标为 index 的元素的值设置为 value 。 $this-&gt;redis-&gt;lSet('key_lset', 0, 'value_lset'); // 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。 $this-&gt;redis-&gt;lRange('key_lrange', 0, 100); // 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 $this-&gt;redis-&gt;lTrim('key_ltrim', 0, 100); // BLPOP 是列表的阻塞式(blocking)弹出原语。 // 它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。 $this-&gt;redis-&gt;blPop(['key_blpop'], 3600); // BRPOP 是列表的阻塞式(blocking)弹出原语。 // 它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。 $this-&gt;redis-&gt;brPop(['key_brpop'], 3600); // BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本 $this-&gt;redis-&gt;brpoplpush('key_src', 'key_dst', 3600);&#125; set1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Redis-集合 * @Post(\"/test_set\") */public function test_set()&#123; // 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。 $this-&gt;redis-&gt;sAdd('key_sadd', 'value_sadd'); // 判断 member 元素是否集合 key 的成员。 // 如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。 $this-&gt;redis-&gt;sIsMember('key_sadd', 'value_sadd'); // 移除并返回集合中的一个随机元素。 $this-&gt;redis-&gt;sPop('key_spop'); // 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素 // 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。 // 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。 $this-&gt;redis-&gt;sRandMember('key_srand', 1); // 移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。 // 被成功移除的元素的数量，不包括被忽略的元素。 $this-&gt;redis-&gt;sRem('key_sadd', 'value_sadd', 'value_sadd2'); // 将 member 元素从 source 集合移动到 destination 集合。 $this-&gt;redis-&gt;sMove('key_src', 'key_dst', 'value_sadd'); // 返回集合 key 的基数(集合中元素的数量)。集合的基数。 当 key 不存在时，返回 0 。 $this-&gt;redis-&gt;sCard('key_scard'); // 返回集合 key 中的所有成员。不存在的 key 被视为空集合。集合中的所有成员。 $this-&gt;redis-&gt;sMembers('key_smembers'); // SSCAN 命令用于迭代集合键中的元素。 $this-&gt;redis-&gt;sScan('key_sscan', '', '', ''); // 返回一个集合的全部成员，该集合是所有给定集合的交集。 // 不存在的 key 被视为空集。 $this-&gt;redis-&gt;sInter('key_sinter', 'key_sinter_2'); // 这个命令类似于 SINTER key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。 // 如果 destination 集合已经存在，则将其覆盖。 $this-&gt;redis-&gt;sInterStore('key_dst', 'key_sinter', 'key_sinter_2'); // 返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。 $this-&gt;redis-&gt;sUnion('key_sunion', 'key_sunion_2'); // 这个命令类似于 SUNION key [key …] 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。 // 如果 destination 已经存在，则将其覆盖。destination 可以是 key 本身。 $this-&gt;redis-&gt;sUnionStore('key_dst', 'key_sunion', 'key_sunion_2'); // 返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集; 一个包含差集成员的列表。 $this-&gt;redis-&gt;sDiff('key_sdiff', 'key_sdiff_2'); // 这个命令的作用和 SDIFF key [key …] 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。 // 如果 destination 集合已经存在，则将其覆盖。结果集中的元素数量 $this-&gt;redis-&gt;sDiffStore('key_dst', 'key_sdiff', 'key_sdiff_2');&#125; zset1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Redis-有序集合 * @Post(\"/test_zset\") */public function test_zset()&#123; // 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。 // 被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。 $this-&gt;redis-&gt;zAdd('key_zadd', 'score_1', 'value_zadd'); // 返回有序集 key 中，成员 member 的 score 值。 $this-&gt;redis-&gt;zScore('key_zadd', 'value_zadd'); // 为有序集 key 的成员 member 的 score 值加上增量 increment 。 $this-&gt;redis-&gt;zIncrBy('key_zincr', 1, 'value_zadd'); // 返回有序集 key 的基数。当 key 存在且是有序集类型时，返回有序集的基数。 当 key 不存在时，返回 0 。 $this-&gt;redis-&gt;zCard('key_zadd'); // 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。 $this-&gt;redis-&gt;zCount('key_zadd', 0, 100); // 返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序。 $this-&gt;redis-&gt;zRange('key_zadd', 0, 100); // 返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列 $this-&gt;redis-&gt;zRevRange('key_zadd', 0, 100); // 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 $this-&gt;redis-&gt;zRangeByScore('key_zadd', 0, 100); // 返回有序集 key 中， score 值介于 max 和 min 之间(默认包括等于 max 或 min )的所有的成员。有序集成员按 score 值递减(从大到小)的次序排列。 $this-&gt;redis-&gt;zRemRangeByScore('key_zadd', 0, 100); // 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。 $this-&gt;redis-&gt;zRank('key_zadd', 'value_zadd'); // 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。 $this-&gt;redis-&gt;zRevRank('key_zadd', 'value_zadd'); // 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。 // 被成功移除的成员的数量，不包括被忽略的成员。 $this-&gt;redis-&gt;zRem('key_zadd', 'value_zadd', 'value_zadd_2'); // 移除有序集 key 中，指定排名(rank)区间内的所有成员。 $this-&gt;redis-&gt;zRemRangeByRank('key_zadd', 0, 100); // 移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。 $this-&gt;redis-&gt;zRemRangeByScore('key_zadd', 0, 100); // 当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。 $this-&gt;redis-&gt;zRangeByLex('key_zadd', 0, 100); // 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。 // $this-&gt;redis-&gt;zLexCount(); // 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。 $this-&gt;redis-&gt;zRevRangeByLex('key_zadd', 0, 100); // 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。 $this-&gt;redis-&gt;zScan('key_zadd', '', '', ''); // 计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。 $this-&gt;redis-&gt;zUnion('key_zunion', ['key_zsets', 'key_zsets_2'], '', '');&#125; key123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Redis-数据库 * @Post(\"/test_redis_database\") */public function test_redis_database()&#123; // 检查给定 key 是否存在。若 key 存在，返回 1 ，否则返回 0 。 $this-&gt;redis-&gt;exists('key'); // 返回 key 所储存的值的类型。 // none:key不存在; string:字符串; list:列表; set:集合; zset:有序集合; hash:哈希表; stream:流; $this-&gt;redis-&gt;type('key'); // 将 key 改名为 newkey 。改名成功时提示 OK ，失败时候返回一个错误。 $this-&gt;redis-&gt;rename('key', 'key_new'); // 当且仅当 newkey 不存在时，将 key 改名为 newkey 。 // 修改成功时，返回 1 ； 如果 newkey 已经存在，返回 0 。 $this-&gt;redis-&gt;renameNx('key', 'key_new'); // 将当前数据库的 key 移动到给定的数据库 db 当中。移动成功返回 1 ，失败则返回 0 。 // 如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。 // 因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。 $this-&gt;redis-&gt;move('key', 'db_index'); // 删除给定的一个或多个 key 。被删除 key 的数量。 $this-&gt;redis-&gt;del('key'); // 从当前数据库中随机返回(不删除)一个 key // 当数据库不为空时，返回一个 key 。 当数据库为空时，返回 nil 。 $this-&gt;redis-&gt;randomKey(); // 返回当前数据库的 key 的数量。 $this-&gt;redis-&gt;dbSize(); // 查找所有符合给定模式 pattern 的 key ， 比如说： // KEYS * 匹配数据库中所有 key 。 $this-&gt;redis-&gt;keys('key*'); // SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）： $this-&gt;redis-&gt;scan('', '', ''); // 返回或保存给定列表、集合、有序集合 key 中经过排序的元素。 $this-&gt;redis-&gt;sort('key', 'desc'); // 清空当前数据库中的所有 key。此命令从不失败。总是返回 OK 。 $this-&gt;redis-&gt;flushDB(); // 清空整个 Redis 服务器的数据(删除所有数据库的所有 key )。此命令从不失败。总是返回 OK 。 $this-&gt;redis-&gt;flushAll(); // 切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。默认使用 0 号数据库。 $this-&gt;redis-&gt;select('db_index'); // 对换指定的两个数据库， 使得两个数据库的数据立即互换。 // $this-&gt;redis-&gt;swapdb();&#125;","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"}]},{"title":"Redis 更深入一点","slug":"Redis-More-In-Depth-Study","date":"2019-09-04T02:09:12.000Z","updated":"2019-09-04T07:31:27.000Z","comments":true,"path":"2019/09/04/Redis-More-In-Depth-Study/","link":"","permalink":"http://blog.caoxl.com/2019/09/04/Redis-More-In-Depth-Study/","excerpt":"Redis 更深入一点 问的更深一点","text":"Redis 更深入一点 问的更深一点 Redis 管道(Pipelining) Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。 123456789101112131415/** * @Post(\"/test_pipelie\") */public function test_pipelie()&#123; $pipe = $this-&gt;redis-&gt;multi(RedisTool::PIPELINE); for ($i = 0; $i &lt; 100; $i++) &#123; $pipe-&gt;set(\"key::$i\", str_pad($i, 4, '0', 0)); $pipe-&gt;get(\"key::$i\"); &#125; $res = $pipe-&gt;exec(); print_r($res);&#125; Redis 内存优化 Redis2.2版本及以后，存储集合数据的时候会采用内存压缩技术，以使用更少的内存存储更多的数据。如Hashes,Lists,Sets和Sorted Sets，当这些集合中的所有数都小于一个给定的元素，并且集合中元素数量小于某个值时，存储的数据会被以一种非常节省内存的方式进行编码，使用这种编码理论上至少会节省10倍以上内存（平均节省5倍以上内存）。并且这种编码技术对用户和redis api透明。因为使用这种编码是用CPU换内存，所以我们提供了更改阈值的方法，只需在redis.conf里面进行修改即可. 1234567hash-max-zipmap-entries 64 (2.6以上使用hash-max-ziplist-entries)hash-max-zipmap-value 512 (2.6以上使用hash-max-ziplist-value)list-max-ziplist-entries 512list-max-ziplist-value 64zset-max-ziplist-entries 128zset-max-ziplist-value 64set-max-intset-entries 512 1234567891011121314/** * @Post(\"/test_memory\") * $redis-&gt;config(\"GET\", \"*max-*-entries*\"); * $redis-&gt;config(\"SET\", \"dir\", \"/var/run/redis/dumps/\"); */public function test_memory()&#123; // hash-max-zipmap-entries 256 $this-&gt;redis-&gt;config('set', 'hash-max-zipmap-entries',256); // 相应的最大键值长度设置: // hash-max-zipmap-value 1024 $this-&gt;redis-&gt;config('set', 'hash-max-zipmap-value',1024);&#125; Redis 事务 MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证： 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 12345678910111213141516171819202122 /** * @Post(\"/test_transaction\") */ public function test_transaction() &#123; $this-&gt;redis-&gt;watch('number'); $this-&gt;redis-&gt;multi(); $this-&gt;redis-&gt;set('favorite_fruit', 'cherry'); $this-&gt;redis-&gt;incrBy('number', 3); $this-&gt;redis-&gt;get('favorite_fruit'); $this-&gt;redis-&gt;ping(); // $this-&gt;redis-&gt;discard(); // 取消事务 dd($this-&gt;redis-&gt;exec()); &#125; /* array:4 [ 0 =&gt; true 1 =&gt; 3 2 =&gt; \"cherry\" 3 =&gt; \"+PONG\" ] */ WATCH: 用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 UNATCH: 用于取消 WATCH 命令对所有 key 的监视。 MULTI: 用于标记一个事务块的开始。 EXEC: 用于执行所有事务块内的命令。 DISCARD: 用于取消事务放弃执行事务块内的所有命令。 为什么 Redis 不支持回 (roll back) ? 如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令” 这种做法可能会让你觉得有点奇怪。 以下是这种做法的优点： Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。 有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。 原文地址: 为什么 Redis 不支持回滚（roll back） Redis 分布式锁 分布式锁在很多场景中是非常有用的原语， 不同的进程必须以独占资源的方式实现资源共享就是一个典型的例子。这个页面试图提供一个使用Redis实现分布式锁的规范算法。我们提出一种算法，叫RedlockRedlock-PHP 算法只需具备3个特性就可以实现一个最低保障的分布式锁。 安全属性 (Safety property): 独享(相互排斥)。在任意一个时刻，只有一个客户端持有锁 活性A(Liveness property A): 无死锁。即便持有锁的客户端崩溃(crashed)或者网络被分裂(gets partitioned)，锁仍然可以被获取。 活性B(Liveness property B): 容错。 只要大部分Redis节点都活着，客户端就可以获取和释放锁. Redis 发布/订阅(Pub/Sub)12345678910111213141516171819/** * Redis-发布订阅 * @Post(\"/test_pub_sub\") */public function test_pub_sub()&#123; // 将信息 message 发送到指定的频道 channel 。 $this-&gt;redis-&gt;publish('channel', 'message'); // 订阅给定的一个或多个频道的信息。 $this-&gt;redis-&gt;subscribe(['channel'], 'callback'); // 订阅一个或多个符合给定模式的频道 $this-&gt;redis-&gt;psubscribe(['msg*'], 'callback'); // PUBSUB 是一个查看订阅与发布系统状态的内省命令， 它由数个不同格式的子命令组成， 以下将分别对这些子命令进行介绍。 // 列出当前的活跃频道。 $this-&gt;redis-&gt;pubsub('keyword', 'argument');&#125; 发布 12345678910/** * 发布 * @Post(\"/test_publish\") */public function test_publish()&#123; $this-&gt;redis-&gt;publish('msg', '来自MSG频道的推送'); echo \"MSG频道消息推送成功 \\n\"; $this-&gt;redis-&gt;close();&#125; 订阅 12345678910111213141516/** * 订阅 * @Post(\"/test_subscribe\") */public function test_subscribe()&#123; // ini_set('default_socket_timeout', -1); echo \"订阅MSG频道, 等待消息推送...\\n\"; $callback = function ($msg) &#123; echo $msg; &#125;; $this-&gt;redis-&gt;subscribe(['msg'], $callback);&#125; Redis 主从复制 在 Redis 复制的基础上，使用和配置主从复制非常简单，能使得从 Redis 服务器（下文称 slave）能精确得复制主 Redis 服务器（下文称 master）的内容。每次当 slave 和 master 之间的连接断开时， slave 会自动重连到 master 上，并且无论这期间 master 发生了什么， slave 都将尝试让自身成为 master 的精确副本。 这个系统的运行依靠三个主要的机制： 当一个 master 实例和一个 slave 实例连接正常时， master 会发送一连串的命令流来保持对 slave 的更新，以便于将自身数据集的改变复制给 slave ， ：包括客户端的写入、key 的过期或被逐出等等。 当 master 和 slave 之间的连接断开之后，因为网络问题、或者是主从意识到连接超时， slave 重新连接上 master 并会尝试进行部分重同步：这意味着它会尝试只获取在断开连接期间内丢失的命令流。 当无法进行部分重同步时， slave 会请求进行全量重同步。这会涉及到一个更复杂的过程，例如 master 需要创建所有数据的快照，将之发送给 slave ，之后在数据集更改时持续发送命令流到 slave 。 Redis 大量写入数据Redis实例需要装载大量用户在短时间内产生的数据，数以百万计的keys需要被快速的创建? 使用Luke协议 使用正常模式的Redis 客户端执行大量数据插入不是一个好主意：因为一个个的插入会有大量的时间浪费在每一个命令往返时间上。使用管道（pipelining）是一种可行的办法，但是在大量插入数据的同时又需要执行其他新命令时，这时读取数据的同时需要确保请可能快的的写入数据。 只有一小部分的客户端支持非阻塞输入/输出(non-blocking I/O),并且并不是所有客户端能以最大限度的提高吞吐量的高效的方式来分析答复。 生成Redis协议 它会非常简单的生成和解析Redis协议，Redis协议文档请参考Redis协议说明。 但是为了生成大量数据插入的目标，你需要了解每一个细节协议，每个命令会用如下方式表示： 123456*&lt;args&gt;&lt;cr&gt;&lt;lf&gt;$&lt;len&gt;&lt;cr&gt;&lt;lf&gt;&lt;arg0&gt;&lt;cr&gt;&lt;lf&gt;&lt;arg1&gt;&lt;cr&gt;&lt;lf&gt;...&lt;argN&gt;&lt;cr&gt;&lt;lf&gt; 这里的是”\\r”（或者是ASCII的13）、是”\\n”（或者是ASCII的10）。 Redis 集群Redis 集群是一个提供在多个Redis间节点间共享数据的程序集 Redis 集群教程: 入门级的Redis集群使用指南。 Redis 集群规范: 进阶版的Redis集群使用规范。","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"}]},{"title":"基于Redis实现布隆过滤器","slug":"Redis-Bloom-Filter","date":"2019-08-29T07:57:35.000Z","updated":"2019-08-29T08:03:47.000Z","comments":true,"path":"2019/08/29/Redis-Bloom-Filter/","link":"","permalink":"http://blog.caoxl.com/2019/08/29/Redis-Bloom-Filter/","excerpt":"布隆过滤器 (Bloom Filter) 是1970年由布隆提出的。 它实际上是一个很长的二进制向量和一系列随机映射函数。 布隆过滤器可以用于检索一个元素是否在一个集合中。","text":"布隆过滤器 (Bloom Filter) 是1970年由布隆提出的。 它实际上是一个很长的二进制向量和一系列随机映射函数。 布隆过滤器可以用于检索一个元素是否在一个集合中。 BloomFilterHash 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;?phpnamespace App\\Support\\BloomFilter;/** * Class BloomFilterHash * @package App\\Support\\BloomFilter */class BloomFilterHash&#123; /** * 由Justin Sobel编写的按位散列函数 * @param $string * @param null $len * @return int */ public function JSHash($string, $len = null) &#123; $hash = 1315423911; $len || $len = strlen($string); for ($i = 0; $i &lt; $len; $i++) &#123; $hash ^= (($hash &lt;&lt; 5) + ord($string[$i]) + ($hash &gt;&gt; 2)); &#125; return ($hash % 0x7FFFFFFF) &amp; 0x7FFFFFFF; &#125; /** * 该哈希算法基于AT＆T贝尔实验室的Peter J. Weinberger的工作。 * Aho Sethi和Ulman编写的“编译器（原理，技术和工具）”一书建议使用采用此特定算法中的散列方法的散列函数。 * @param $string * @param null $len * @return int */ public function PJWHash($string, $len = null) &#123; $bitsInUnsignedInt = 4 * 8; //（unsigned int）（sizeof（unsigned int）* 8）; $threeQuarters = ($bitsInUnsignedInt * 3) / 4; $oneEighth = $bitsInUnsignedInt / 8; $highBits = 0x7FFFFFFF &lt;&lt; (int) ($bitsInUnsignedInt - $oneEighth); $hash = 0; $test = 0; $len || $len = strlen($string); for ($i = 0; $i &lt; $len; $i++) &#123; $hash = ($hash &lt;&lt; (int) ($oneEighth)) + ord($string[$i]); &#125; $test = $hash &amp; $highBits; if ($test != 0) &#123; $hash = (($hash ^ ($test &gt;&gt; (int)($threeQuarters))) &amp; (~$highBits)); &#125; return ($hash % 0x7FFFFFFF) &amp; 0x7FFFFFFF; &#125; /** * 类似于PJW Hash功能，但针对32位处理器进行了调整。它是基于UNIX的系统上的widley使用哈希函数。 * @param $string * @param null $len * @return int */ public function ELFHash($string, $len = null) &#123; $hash = 0; $len || $len = strlen($string); for ($i = 0; $i &lt; $len; $i++) &#123; $hash = ($hash &lt;&lt; 4) + ord($string[$i]); $x = $hash &amp; 0xF0000000; if ($x != 0) &#123; $hash ^= ($x &gt;&gt; 24); &#125; $hash &amp;= ~$x; &#125; return ($hash % 0x7FFFFFFF) &amp; 0x7FFFFFFF; &#125; /** * 这个哈希函数来自Brian Kernighan和Dennis Ritchie的书“The C Programming Language”。 * 它是一个简单的哈希函数，使用一组奇怪的可能种子，它们都构成了31 .... 31 ... 31等模式，它似乎与DJB哈希函数非常相似。 * @param $string * @param null $len * @return int */ public function BKDRHash($string, $len = null) &#123; $seed = 131; # 31 131 1313 13131 131313 etc.. $hash = 0; $len || $len = strlen($string); for ($i=0; $i&lt;$len; $i++) &#123; $hash = (int) (($hash * $seed) + ord($string[$i])); &#125; return ($hash % 0x7FFFFFFF) &amp; 0x7FFFFFFF; &#125; /** * 这是在开源SDBM项目中使用的首选算法。 * 哈希函数似乎对许多不同的数据集具有良好的总体分布。它似乎适用于数据集中元素的MSB存在高差异的情况 * @param $string * @param null $len * @return int */ public function SDBMHash($string, $len = null) &#123; $hash = 0; $len || $len = strlen($string); for ($i = 0; $i &lt; $len; $i++) &#123; $hash = (int) (ord($string[$i]) + ($hash &lt;&lt; 6) + ($hash &lt;&lt; 16) - $hash); &#125; return ($hash % 0x7FFFFFFF) &amp; 0x7FFFFFFF; &#125; /** * 由Daniel J. Bernstein教授制作的算法，首先在usenet新闻组comp.lang.c上向世界展示。 * 它是有史以来发布的最有效的哈希函数之一。 * @param $string * @param null $len * @return int */ public function DJBHash($string, $len = null) &#123; $hash = 5381; $len || $len = strlen($string); for ($i = 0; $i &lt; $len; $i++) &#123; $hash = (int) (($hash &lt;&lt; 5) + $hash) + ord($string[$i]); &#125; return ($hash % 0x7FFFFFFF) &amp; 0x7FFFFFFF; &#125; /** * Donald E. Knuth在“计算机编程艺术第3卷”中提出的算法，主题是排序和搜索第6.4章。 * @param $string * @param null $len * @return int */ public function DEKHash($string, $len = null) &#123; $len || $len = strlen($string); $hash = $len; for ($i = 0; $i &lt; $len; $i++) &#123; $hash = (($hash &lt;&lt; 5) ^ ($hash &gt;&gt; 27)) ^ ord($string[$i]); &#125; return ($hash % 0x7FFFFFFF) &amp; 0x7FFFFFFF; &#125; /** * 参考 http://www.isthe.com/chongo/tech/comp/fnv/ * @param $string * @param null $len * @return int */ public function FNVHash($string, $len = null) &#123; $prime = 16777619; //32位的prime 2^24 + 2^8 + 0x93 = 16777619 $hash = 2166136261; //32位的offset $len || $len = strlen($string); for ($i = 0; $i &lt; $len; $i++) &#123; $hash = (int) ($hash * $prime) % 0x7FFFFFFF; $hash ^= ord($string[$i]); &#125; return ($hash % 0x7FFFFFFF) &amp; 0x7FFFFFFF; &#125;&#125; BloomFilterRedis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpnamespace App\\Support\\BloomFilter;use App\\Support\\RedisTool;abstract class BloomFilterRedis&#123; protected $redis; protected $hash; protected $bucket; protected $hashFunc; public function __construct() &#123; if (!$this-&gt;bucket || !$this-&gt;hashFunc) &#123; throw new \\Exception(\"需要定义bucket和hashFunction\", 4000); &#125; $this-&gt;hash = new BloomFilterHash(); $this-&gt;redis = RedisTool::getInstance(); &#125; /** * 添加到集合中 * @param $string * @return array */ public function add($string) &#123; $pipe = $this-&gt;redis-&gt;multi(); foreach ($this-&gt;hashFunc as $func) &#123; $hash = $this-&gt;hash-&gt;$func($string); $pipe-&gt;setBit($this-&gt;bucket, $hash, 1); &#125; return $pipe-&gt;exec(); &#125; /** * 查询是否存在, 存在的一定会存在, 不存在有一定几率会误判 * @param $string * @return bool */ public function exists($string) &#123; $pipe = $this-&gt;redis-&gt;multi(); $len = strlen($string); foreach ($this-&gt;hashFunc as $func) &#123; $hash = $this-&gt;hash-&gt;$func($string, $len); $pipe = $pipe-&gt;getBit($this-&gt;bucket, $hash); &#125; $res = $pipe-&gt;exec(); foreach ($res as $bit) &#123; if ($bit == 0) return false; &#125; return true; &#125;&#125; BloomFilter 1234567891011121314151617181920&lt;?phpnamespace App\\Support\\BloomFilter;/** * Class BloomFilter * @package App\\Support\\BloomFilter */class BloomFilter extends BloomFilterRedis&#123; /** * 表示判断重复内容的过滤器 * 该布隆过滤器总位数为2^32位, 判断条数为2^30条. hash函数最优为3个.(能够容忍最多的hash函数个数) * 注意, 在存储的数据量到2^30条时候, 误判率会急剧增加, 因此需要定时判断过滤器中的位为1的的数量是否超过50%, 超过则需要清空. * @var string */ protected $bucket = 'bfr'; protected $hashFunc = ['BKDRHash', 'SDBMHash', 'JSHAsh'];&#125; RedisController 1234567891011/** * Redis-布隆过滤器 * * @param BloomFilter $filter * @Post(\"/test_bloom\") */public function test_bloom(BloomFilter $filter)&#123; $filter-&gt;add('bloom'); dd($filter-&gt;exists('bloom'));&#125;","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"http://blog.caoxl.com/tags/布隆过滤器/"}]},{"title":"缓存 相关问题/解决方案","slug":"Caching-Related-Issues-And-Solutions","date":"2019-08-29T01:57:57.000Z","updated":"2019-08-29T08:12:46.000Z","comments":true,"path":"2019/08/29/Caching-Related-Issues-And-Solutions/","link":"","permalink":"http://blog.caoxl.com/2019/08/29/Caching-Related-Issues-And-Solutions/","excerpt":"缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题以及解决方案","text":"缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题以及解决方案 缓存雪崩 缓存设置同一过期时间, 引起的DB洪峰缓存雪崩我们可以简单的理解为：由于 原有缓存失效，新缓存未到 期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。 触发场景 流量激增: 比如异常流量、用户重试导致系统负载升高； 缓存刷新: 假设 A 为 Client 端，B 为 Server 端，假设 A 系统请求都流向 B 系统，请求超出了 B 系统的承载能力，就会造成 B 系统崩溃； 程序有Bug: 代码循环调用的逻辑问题，资源未释放引起的内存泄漏等问题； 硬件故障: 比如宕机，机房断电，光纤被挖断等。 数据库严重瓶颈: 比如长事务、sql 超时等。 线程同步等待: 系统间经常采用同步服务调用模式，核心服务和非核心服务共用一个线程池和消息队列。如果一个核心业务线程调用非核心线程，这个非核心线程交由第三方系统完成，当第三方系统本身出现问题，导致核心线程阻塞，一直处于等待状态，而进程间的调用是有超时限制的，最终这条线程将断掉，也可能引发雪崩； 解决方案 用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。 缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 缓存穿透 DB承受了没有必要的查询流量缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决方案有很多种方法可以有效地解决缓存穿透问题. 最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。 另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 缓存击穿(热点Key) 热点Key，大量并发读请求引起的小雪崩对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 解决方案 使用互斥锁(mutex key) 业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。 Redis SETNX (SET if Not Exist): 只在键 key 不存在的情况下， 将键 key 的值设置为 value 。 “提前”使用互斥锁(mutex key) 在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。 “永远不过期” 这里的“永远不过期”包含两层意思： 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期 缓存预热 缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决方案 可以通过缓存 reload 机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀 缓存更新 直接写个缓存刷新页面，上线时手工操作下； 数据量不大，可以在项目启动的时候自动进行加载； 定时刷新缓存； 解决方案缓存降级 当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"缓存雪崩","slug":"缓存雪崩","permalink":"http://blog.caoxl.com/tags/缓存雪崩/"},{"name":"缓存穿透","slug":"缓存穿透","permalink":"http://blog.caoxl.com/tags/缓存穿透/"}]},{"title":"消息队列之 Kafka","slug":"Message-Queue-Kafka","date":"2019-08-28T03:52:51.000Z","updated":"2019-08-29T08:06:32.000Z","comments":true,"path":"2019/08/28/Message-Queue-Kafka/","link":"","permalink":"http://blog.caoxl.com/2019/08/28/Message-Queue-Kafka/","excerpt":"简介 Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。","text":"简介 Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。 待续: http://kafka.apachecn.org/quickstart.html","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Queue","slug":"Queue","permalink":"http://blog.caoxl.com/tags/Queue/"},{"name":"Kafka","slug":"Kafka","permalink":"http://blog.caoxl.com/tags/Kafka/"}]},{"title":"DingMsg II","slug":"DingMsg-II","date":"2019-08-27T02:36:52.000Z","updated":"2019-08-27T02:45:33.000Z","comments":true,"path":"2019/08/27/DingMsg-II/","link":"","permalink":"http://blog.caoxl.com/2019/08/27/DingMsg-II/","excerpt":"","text":"完整版, DingMsg使用记录 DingRobot App\\Support\\DingRobot 12345678910111213141516171819202122232425&lt;?phpnamespace App\\Support;use Illuminate\\Support\\Facades\\Log;class DingRobot&#123; const DING_URL = 'https://oapi.dingtalk.com/robot/send?access_token=5187cd15497ab1f440cb92c49eaf29e6477ec8786251ab00133d8a89b0ee7450'; public static function textMessage(string $url, string $msg) &#123; try &#123; $curl = new Curl(); $curl-&gt;post_json($url, [ 'msgtype' =&gt; 'text', 'text' =&gt; [ 'content' =&gt; $msg, ], ]); &#125; catch (\\Error $e) &#123; Log::error($e-&gt;getMessage()); &#125; &#125;&#125; Curl App\\Support\\Curl 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254&lt;?phpnamespace App\\Support;use App\\Concerns\\Singleton;/** * Class Curl * @package App\\Support */class Curl&#123; use Singleton; const CONTENT_TYPE = 'Content-Type'; // 用于读取和写入请求的cookie文件 public $cookie_file; // 确定请求是否遵循重定向 public $follow_redirects = true; // 请求头 public $headers = array(); // 请求选项 public $options = array(); // referer 头 public $referer; public $user_agent; protected $error = ''; // CURL 请求资源句柄 protected $ch; /** * 初始化Curl对象 * Curl constructor. * @param array|null $args ['headers' =&gt; [...], 'options' =&gt; [...] ] */ public function __construct(array $args = null) &#123; if (!empty($args)) &#123; $this-&gt;headers = $args['headers'] ?? array(); $this-&gt;options = $args['options'] ?? array(); &#125; $this-&gt;cookie_file = dirname(__FILE__) . DIRECTORY_SEPARATOR . 'curl_cookie.txt'; $this-&gt;user_agent = isset($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : 'Curl/client'; &#125; /** * Curl HEAD * * @param $url * @param array $vars * @return mixed */ public function head($url, $vars = array()) &#123; return $this-&gt;request('HEAD', $url, $vars); &#125; /** * Curl GET * * @param $url * @param array $vars * @return mixed */ public function get($url, $vars = array()) &#123; if (!empty($vars)) &#123; $url .= (stripos($url, '?') !== false) ? '&amp;' : '?'; $url .= (is_string($vars)) ? $vars : http_build_query($vars, '', '&amp;'); &#125; return $this-&gt;request('GET', $url); &#125; /** * Curl POST * * @param $url * @param array $vars * @return mixed */ public function post($url, $vars = array()) &#123; return $this-&gt;request('POST', $url, $vars); &#125; /** * Curl PUT * * @param $url * @param array $vars * @return mixed */ public function put($url, $vars = array()) &#123; return $this-&gt;request('PUT', $url, $vars); &#125; /** * Curl DELETE * * @param $url * @param array $vars * @return mixed */ public function delete($url, $vars = array()) &#123; return $this-&gt;request('DELETE', $url, $vars); &#125; /** * 返回错误 * @return string */ public function error() &#123; return $this-&gt;error; &#125; /** * 将Post数据转成JSON * * @param $url * @param array $data * @return mixed */ public function post_json($url, $data = array()) &#123; $this-&gt;headers[static::CONTENT_TYPE] = 'application/json;charset=utf-8'; $vars = empty($data) ? null : json_encode($data); return $this-&gt;request('POST', $url, $vars); &#125; /** * 将Put数据转成JSON * @param $url * @param array $data * @return mixed */ public function put_json($url, $data = array()) &#123; $this-&gt;headers[static::CONTENT_TYPE] = 'application/json;charset=utf-8'; $vars = empty($data) ? null : json_encode($data); return $this-&gt;request('PUT', $url, $vars); &#125; /** * CURL 请求 * @param $method * @param $url * @param array $vars * @return CurlResponse|mixed */ public function request($method, $url, $vars = array()) &#123; $this-&gt;error = ''; $this-&gt;ch = curl_init(); if (is_array($vars)) $vars = http_build_query($vars, '', '&amp;'); $this-&gt;set_request_headers(); $this-&gt;set_request_method($method); $this-&gt;set_request_options($url, $vars); $response = curl_exec($this-&gt;ch); if ($response) &#123; $response = new CurlResponse($response); &#125; else &#123; $this-&gt;error = curl_errno($this-&gt;ch) . '-' . curl_error($this-&gt;ch); &#125; curl_close($this-&gt;ch); return $response; &#125; /** * 设置CURL请求头 */ protected function set_request_headers() &#123; $headers = array(); foreach ($this-&gt;headers as $key =&gt; $value) &#123; $headers[] = $key . ': ' . $value; &#125; curl_setopt($this-&gt;ch, CURLOPT_HTTPHEADER, $headers); &#125; /** * 为请求方法设置关联的CURL选项 * @param $method */ protected function set_request_method($method) &#123; switch (strtoupper($method)) &#123; case 'HEAD': curl_setopt($this-&gt;ch, CURLOPT_NOBODY, true); break; case 'GET': curl_setopt($this-&gt;ch, CURLOPT_HTTPGET, true); break; case 'POST': curl_setopt($this-&gt;ch, CURLOPT_POST, true); break; default: curl_setopt($this-&gt;ch, CURLOPT_CUSTOMREQUEST, $method); &#125; &#125; /** * 设置CURL选项 * @param $url * @param $vars */ protected function set_request_options($url, $vars) &#123; curl_setopt($this-&gt;ch, CURLOPT_URL, $url); if (!empty($vars)) curl_setopt($this-&gt;ch, CURLOPT_POSTFIELDS, $vars); // 设置一些默认CURL选项 curl_setopt($this-&gt;ch, CURLOPT_HEADER, true); curl_setopt($this-&gt;ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($this-&gt;ch, CURLOPT_USERAGENT, $this-&gt;user_agent); if ($this-&gt;cookie_file) &#123; curl_setopt($this-&gt;ch, CURLOPT_COOKIEFILE, $this-&gt;cookie_file); curl_setopt($this-&gt;ch, CURLOPT_COOKIEJAR, $this-&gt;cookie_file); &#125; if ($this-&gt;follow_redirects) curl_setopt($this-&gt;ch, CURLOPT_FOLLOWLOCATION, true); if ($this-&gt;referer) curl_setopt($this-&gt;ch, CURLOPT_REFERER, $this-&gt;referer); // 设置任何自定义CURL选项 foreach ($this-&gt;options as $option =&gt; $value) &#123; curl_setopt($this-&gt;ch, constant('CURLOPT_' . str_replace('CURLOPT_', '', strtoupper($option))), $value); &#125; &#125;&#125; Singleton App\\Concerns\\Singleton 1234567891011121314151617&lt;?phpnamespace App\\Concerns;trait Singleton&#123; public static function getInstance() &#123; static $instance = null; if (is_null($instance)) &#123; $instance = new static(); &#125; return $instance; &#125;&#125; 使用1DingRobot::textMessage(DingRobot::DING_URL, $msg); 123456789101112131415161718/** * add support of ding message on ERROR detected in logging. * * @param Logger $logger */public static function addDingHandler($logger)&#123; $handler = new class extends AbstractProcessingHandler &#123; public function write(array $record) &#123; if (config('logging.alert_ding', false) &amp;&amp; $record['level'] &gt;= 400)&#123; $msg = $record['channel'] . '.'. $record['level_name'] . ' ' . $record['message']; DingRobot::textMessage(DingRobot::DING_URL, $msg); &#125; &#125; &#125;; $logger-&gt;pushHandler($handler);&#125;","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"DingMsg","slug":"DingMsg","permalink":"http://blog.caoxl.com/tags/DingMsg/"}]},{"title":"Github PHP 开源项目","slug":"PHP-Github-Open-Source-Project","date":"2019-08-19T06:25:38.000Z","updated":"2019-08-19T09:18:20.000Z","comments":true,"path":"2019/08/19/PHP-Github-Open-Source-Project/","link":"","permalink":"http://blog.caoxl.com/2019/08/19/PHP-Github-Open-Source-Project/","excerpt":"分享 GitHub 上 有趣、入门级的开源项目https://github.com/521xueweihan/HelloGitHub","text":"分享 GitHub 上 有趣、入门级的开源项目https://github.com/521xueweihan/HelloGitHub CRMEB 开源微信公众号商城 小程序商城系统，带分销、拼团、秒杀、砍价、优惠券、积分等功能，前后端全部开源，更是一套方便二次开发的框架官网: http://www.crmeb.com/Github: https://github.com/crmeb/CRMEB FreshRSS 一个 PHP 写的免费自托管 RSS 阅读器（free and free），据说上万条订阅都不带卡顿。可分配多账户、支持第三方安卓、iOS 客户端、支持 FEVER API 协议，与 Rsshub 搭配使用，完美解决 RSS 重度用户的痛点。是 RSS 爱好者的福音和神器官网: https://freshrss.org/Github: https://github.com/FreshRSS/FreshRSS PHP-Interview-QA 《PHP 面试问答》结合实际 PHP 面试经验，系统地汇总面试中的各类的问题，并尝试提供简洁准确的答案，为你面试 PHP 相关岗位提供“秘籍”。包含：网络协议、数据结构与算法、PHP基础、Web、MySQL、Redis、自我介绍、离职原因、职业规划等部分Github: https://github.com/colinlet/PHP-Interview-QA wizard 一款基于 Laravel 开发框架的开源文档管理系统。目前已经在多家公司部署使用，支持：Markdown、Swagger 文档管理，公司内部的统一身份认证系统（LDAP）等功能官网: http://futureup.tech/wizard/Github: https://github.com/mylxsw/wizard php-console 使用简单，功能全面的 PHP 命令行应用库。提供控制台参数解析、命令运行、颜色风格输出、 用户信息交互等功能Github: https://github.com/inhere/php-console PasteMe PasteMe 是一个无需注册的文本分享平台，可以为文本设置密码和阅后即焚，支持二维码分享和各种一键复制，最大化释放你的双手，针对代码提供了额外的高亮功能。主站点已全站 CDN 以及 GZIP 传输，有着好看的前端和优秀的访问速度Github: https://github.com/LucienShui/PasteMe LaravelS 集成 LaravelS 之后无需使用 PHP FPM，直接基于 Swoole 开启 HTTP ServerGithub: https://github.com/hhxsv5/laravel-s MeEdu 开源免费的在线教育系统，支持在线点播、在线电子书、会员收费三大模块官网: https://meedu.vip/Github: 基于Laravel开发的在线点播系统 DzzOffice 一套开源办公套件，适用于企业、团队搭建自己的 类似 Google 企业应用套件、微软 Office365 的企业协同办公平台。Github: https://github.com/zyx0814/dzzoffice Biny 腾讯开源的一款高性能的超轻量级PHP框架，用于快速开发现代 Web 应用程序。代码简洁优雅，对应用层，数据层，模板渲染层的封装简单易懂，能够快速上手使用，文档齐全。高性能，框架响应时间在 1ms 以内，单机 qps 轻松上3000。Github: https://github.com/Tencent/Biny wooyun_public 乌云公开漏洞、知识库爬虫和搜索Github: https://github.com/hanc00l/wooyun_public nextcloud 开源云存储平台，功能齐全，可以用于搭建公司内部的云存储平台官网: https://nextcloud.comGithub: https://github.com/nextcloud/server typecho PHP 的一款博客程序官网: http://typecho.orgGithub: https://github.com/typecho/typecho pinyin 基于 CC-CEDICT 词典的中文转拼音工具，更准确的支持多音字的汉字转拼音解决方案官网: http://overtrue.me/pinyinGithub: https://github.com/overtrue/pinyin walle-web Walle（瓦力） 一个 Web 部署系统工具，可能也是个持续发布工具，配置简单、功能完善、界面流畅、开箱即用！支持 git、svn 版本管理，支持各种 Web 代码发布，静态的 HTML，动态 PHP，需要编译的 Java 等官网: https://walle-web.ioGithub: https://github.com/meolu/walle-web Hyperf Hyperf 是基于 Swoole 4.3+ 实现的高性能、高灵活性的 PHP 协程框架，内置协程服务器及大量常用的组件，性能较传统基于 PHP-FPM 的框架有质的提升，提供超高性能的同时，也保持着极其灵活的可扩展性，标准组件均均基于 PSR 标准 实现，基于强大的依赖注入设计，保证了绝大部分组件或类都是 可替换 与 可复用 的。文档: https://doc.hyperf.io/#/zh/READMEGithub: https://github.com/hyperf-cloud/hyperf/blob/master/doc/zh/README.md redis-cli PHP版本的 Redis命令行客户端,方便使用的Github: https://github.com/wizarot/redis-cli","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"开源项目","slug":"开源项目","permalink":"http://blog.caoxl.com/tags/开源项目/"}]},{"title":"PHP面试/笔试题杂记 IV","slug":"Interview-Questions-Notes-IV","date":"2019-08-15T01:32:09.000Z","updated":"2019-08-22T03:13:17.000Z","comments":true,"path":"2019/08/15/Interview-Questions-Notes-IV/","link":"","permalink":"http://blog.caoxl.com/2019/08/15/Interview-Questions-Notes-IV/","excerpt":"时不时看一些笔试面试题,发现自己的薄弱的地方","text":"时不时看一些笔试面试题,发现自己的薄弱的地方 PHP的垃圾回收机制PHP 可以自动进行内存管理，清除不需要的对象。 PHP 使用了引用计数 (reference counting) GC 机制。 每个对象都内含一个引用计数器 refcount，每个 reference 连接到对象，计数器加 1。当 reference 离开生存空间或被设为 NULL，计数器减 1。当某个对象的引用计数器为零时，PHP 知道你将不再需要使用这个对象，释放其所占的内存空间。 session 与 cookie 的区别 存放位置: Session保存在服务器; Cookie保存在客户端 存放的形式: Session是以对象的形式保存在服务器; Cookie以字符串的形式保存在客户端 用途: Cookie适合做保存用户的个人设置,爱好等; Session适合住客户的身体验证; 路径: Session 不能区分路径，同一个用户在访问一个网站期间，所有的 Session 在任何一个地方都可以访问到; 而 Cookie 中如果设置了路径参数，那么同一个网站中不同路径下的 Cookie 互相是访问不到的。 安全性: Cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，考虑到安全应当使用 session 大小以及数量限制: 每个域名所包含的 cookie 数：IE7/8,FireFox:50 个，Opera30 个； Cookie 总大小：Firefox 和 Safari 允许 cookie 多达 4097 个字节，Opera 允许 cookie 多达 4096 个字 节，InternetExplorer 允许 cookie 多达 4095 个字节；一般认为 Session 没有大小和数量限制。 如何修改Session的生存时间 设置浏览器保存的sessionid的失效时间 1setcookie (session_name (), session_id (), time () + $lifeTime, \"/\"); 可以使用session自带的session_set_cookie_params(86400)来设置session的生存期 通过修改 php.ini 中的 session.gc_maxlifetime 参数的值就可以改变 session 的生存时间 长连接、短连接的区别和使用 长连接: client 方与 server 方先建立连接，连接建立后不断开，然后再进行报文发送和接收。这种方式下由于通讯连接一直存在。此种方式常用于 P2P 通信。 短连接: Client 方与 server 每进行一次报文收发交易时才进行通讯连接，交易完毕后立即断开连接。此方式常用于一点对多点通讯。C/S 通信。 HTTP协议详解、应用 HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、短连接、灵活、应用层的协议，常基于 TCP 的连接方式。 HTTP 响应状态码 1xx: 指示信息 – 表示请求已接收，继续处理 2xx: 成功 – 表示请求已被成功接收、理解、接受 3xx: 重定向 – 要完成请求必须进行更进一步的操作 4xx: 客户端错误 – 请求有语法错误或请求无法实现 5xx: 服务器端错误 – 服务器未能实现合法的请求 常见状态代码、状态描述、说明： 200 OK: 客户端请求成功 304 Not Modifed: 自从上次请求后，请求的网页未修改过。 400 Bad Request: 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized: 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 403 Forbidden: 服务器收到请求，但是拒绝提供服务 404 Not Found: 请求资源不存在，eg：输入了错误的 URL 500 Internal Server Error: 服务器发生不可预期的错误 503 Server Unavailable: 服务器超时 Socket 连接步骤 Socket (套接字) 概念 套接字（socket）是通信的基石，是支持 TCP/IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。 Socket 连接过程 建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket 套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。 服务器监听: 是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。 客户端请求: 是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。 连接确认: 是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 TCP协议, 三次握手、四次挥手 TCP 协议 (Transmission Control Protocol) 是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接，四次挥手断开连接。 位码即 tcp 标志位，有 6 种标示: SYN(synchronous 建立联机同步) ACK(acknowledgement 确认) PSH(push 传送) FIN(finish 结束) RST(reset 重置) URG(urgent 紧急) MySQL Query 语句优化的基本思路和原则 优化需要的优化的Query 定位优化对象的性能瓶颈 明确优化目标 从Explaing 入手 多使用Profile 永远用小结果集推到大的结果集 尽可能在索引中完成排序 只取资金需要的Columns 仅仅使用最有效的过滤条件","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"PHP面试题","slug":"PHP面试题","permalink":"http://blog.caoxl.com/tags/PHP面试题/"},{"name":"PHP笔试题","slug":"PHP笔试题","permalink":"http://blog.caoxl.com/tags/PHP笔试题/"}]},{"title":"Redis 实现排行榜功能","slug":"Redis-Do-Rank-List","date":"2019-08-14T08:19:51.000Z","updated":"2019-08-22T06:35:21.000Z","comments":true,"path":"2019/08/14/Redis-Do-Rank-List/","link":"","permalink":"http://blog.caoxl.com/2019/08/14/Redis-Do-Rank-List/","excerpt":"这里以游戏中的排行榜举例: 游戏中存在各种各样的排行榜，比如玩家的等级排名、分数排名等","text":"这里以游戏中的排行榜举例: 游戏中存在各种各样的排行榜，比如玩家的等级排名、分数排名等 准备 一个典型的游戏排行榜包括以下常见功能: 能够记录每个玩家的分数 能够对玩家的分数进行更新 能够查询每个玩家的分数和名次 能够按名词查询排名前N名的玩家 能够查询排在指定玩家前后M名的玩家 由于一个玩家名次上升x位将会引起x+1位玩家的名次发生变化（包括该玩家），如果采用传统数据库（比如MySQL）来实现排行榜，当玩家人数较多时，将会导致对数据库的频繁修改，性能得不到满足，所以我们只能另想它法。 Redis Zset Redis 有序集合 下面介绍几个能用于排行榜的命令: zadd - 设置玩家分数 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。 1public function zAdd( $key, $score1, $value1, $score2 = null, $value2 = null, $scoreN = null, $valueN = null ) &#123;&#125; zscore - 查看玩家分数 返回有序集 key 中，成员 member 的 score 值。 1public function zScore( $key, $member ) &#123;&#125; zrevrange - 按名次查看排行榜 返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列。起始位置和结束位置都是以0开始的索引，且都包含在内。如果结束位置为-1则查看范围为整个排行榜。带上withscores则会返回玩家分数。 1public function zRevRange( $key, $start, $end, $withscore = null ) &#123;&#125; zrank/zrevrank - 查看玩家的排名 zrank: 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。zrevrank: 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。 12public function zRank( $key, $member ) &#123;&#125;public function zRevRank( $key, $member ) &#123;&#125; zincrby - 增减玩家分数 为有序集 key 的成员 member 的 score 值加上增量 increment 。可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。 1public function zIncrBy( $key, $value, $member ) &#123;&#125; zrem - 移除某个/多个玩家 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。 1public function zRem( $key, $member1, $member2 = null, $memberN = null ) &#123;&#125; del - 删除排行榜 删除给定的一个或多个 key 。 1public function del( $key1, $key2 = null, $key3 = null ) &#123;&#125;","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"Rank","slug":"Rank","permalink":"http://blog.caoxl.com/tags/Rank/"}]},{"title":"Redis 实战","slug":"Redis-Use-Notes","date":"2019-08-12T09:54:08.000Z","updated":"2019-09-06T01:48:42.000Z","comments":true,"path":"2019/08/12/Redis-Use-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/08/12/Redis-Use-Notes/","excerpt":"Redis的使用场景测试用例","text":"Redis的使用场景测试用例 准备 RedisController.php 123456789101112131415161718192021222324&lt;?phpnamespace App\\Api\\Controller;use App\\Api\\Controller as BaseController;use App\\Support\\RedisTool;use Collective\\Annotations\\Routing\\Annotations\\Annotations\\&#123; Controller, Post&#125;;/** * Class RedisController * @package App\\Api\\Controller * @Controller(prefix=\"/api/redis\") */class RedisController extends BaseController&#123; private $redis; public function __construct() &#123; $this-&gt;redis = RedisTool::getInstance(); &#125;&#125; RedisTool.php 1234567891011121314151617181920212223&lt;?phpnamespace App\\Support;use App\\Concerns\\Singleton;use Illuminate\\Support\\Facades\\Log;class RedisTool extends \\Redis&#123; use Singleton; public function __construct() &#123; parent::__construct(); $host = config('database.redis.default.host'); $port = config('database.redis.default.port'); if (! $this-&gt;connect($host, $port)) &#123; Log::error(\"redis fail to connect to $host:$port\"); &#125; &#125;&#125; Singleton.php 1234567891011121314151617&lt;?phpnamespace App\\Concerns;trait Singleton&#123; public static function getInstance() &#123; static $instance = null; if (is_null($instance)) &#123; $instance = new static(); &#125; return $instance; &#125;&#125; 基于 redis 字符串 string 类型的简单缓存123456789101112/** * @Post(\"/test_string\") */public function test_string()&#123; $this-&gt;redis-&gt;set('cache_key', json_encode([ 'data-list' =&gt; '这是个缓存数据' ]), JSON_UNESCAPED_UNICODE); $res = $this-&gt;redis-&gt;get('cache_key'); var_dump($res);&#125; 基于 redis 列表 list 类型的简单队列123456789101112131415161718192021222324252627282930/** * 实现队列 * @Post(\"/test_queue\") */public function test_queue()&#123; // 进队列 $user_id = mt_rand(100000, 999999); $this-&gt;redis-&gt;rPush('queue_name', json_encode(['user_id' =&gt; $user_id])); $user_id = mt_rand(100000, 999999); $this-&gt;redis-&gt;rPush('queue_name', json_encode(['user_id' =&gt; $user_id])); $user_id = mt_rand(100000, 999999); $this-&gt;redis-&gt;rPush('queue_name', json_encode(['user_id' =&gt; $user_id])); echo \"数据进队列成功 \\n\"; // 查看队列 $res = $this-&gt;redis-&gt;lRange('queue_name', 0, 100); echo \"当前队列数据为: \\n\"; print_r($res); // 出队列 $this-&gt;redis-&gt;lPop('queue_name'); echo \"数据出队列成功 \\n\"; // 查看队列 $res = $this-&gt;redis-&gt;lRange('queue_name', 0, 100); echo \"当前队列数据为: \\n\"; print_r($res);&#125; 基于 redis 字符串 setnx 的悲观锁1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 实现悲观锁机制 * @Post(\"/test_lock_pessimism\") */public function test_lock_pessimism()&#123; $timeout = 5000; do &#123; $microtime = microtime(true) * 1000; $microtimeout = $microtime + $timeout + 1; // 上锁 $isLock = $this-&gt;redis-&gt;setnx('lock.count', $microtimeout); if (!$isLock) &#123; $getTime = $this-&gt;redis-&gt;get('lock.count'); if ($getTime &gt; $microtime) &#123; // 睡眠, 降低抢锁频率 缓解redis压力 usleep(5000); // 未超时继续等待 continue; &#125; // 超时, 抢锁, 可能有几毫秒级时间差可忽略 $previousTime = $this-&gt;redis-&gt;getSet('lock.count', $microtimeout); if ((int)$previousTime &lt; $microtime) &#123; break; &#125; &#125; &#125; while (!$isLock); $count = $this-&gt;redis-&gt;get('count') ?: 0; // 业务逻辑 echo \"执行count加1操作~~\\n\\n\"; $this-&gt;redis-&gt;set('count', $count + 1); // 删除锁 $this-&gt;redis-&gt;del('lock.count'); // 打印count值 $count = $this-&gt;redis-&gt;get('count'); echo \"count值为: $count\\n\";&#125; 基于 redis 事务的乐观锁1234567891011121314151617181920212223242526272829303132/** * 实现悲观锁机制 * @Post(\"/test_lock_optimistic\") */public function test_lock_optimistic()&#123; // 监视count值 $this-&gt;redis-&gt;watch('count'); // 开启事务(Redis的事务和MySQL事务概念不一样) $this-&gt;redis-&gt;multi(); // 操作count $time = time(); $this-&gt;redis-&gt;set('count', $time); // 模拟并发下其他进程进行set count操作 请执行下面操作 // $this-&gt;redis-&gt;set('count', 'is simulate'); sleep(10); // 提交事务 $res = $this-&gt;redis-&gt;exec(); if ($res) &#123; // 成功 echo 'Success: ' . $time . \"\\n\"; return; &#125; // 失败 echo 'Fail: ' . $time . \"\\n\";&#125; 基于 redis 的发布订阅123456789101112131415161718192021222324252627/** * 发布 * @Post(\"/test_publish\") */public function test_publish()&#123; $this-&gt;redis-&gt;publish('msg', '来自MSG频道的推送'); echo \"MSG频道消息推送成功 \\n\"; $this-&gt;redis-&gt;close();&#125;/** * 订阅 * @Post(\"/test_subscribe\") */public function test_subscribe()&#123; // ini_set('default_socket_timeout', -1); echo \"订阅MSG频道, 等待消息推送...\\n\"; $callback = function ($msg) &#123; echo $msg; &#125;; $this-&gt;redis-&gt;subscribe(['msg'], $callback);&#125;","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"}]},{"title":"秒杀系统","slug":"Sec-Kill-System-Notes","date":"2019-08-12T03:37:52.000Z","updated":"2019-08-12T07:26:46.000Z","comments":true,"path":"2019/08/12/Sec-Kill-System-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/08/12/Sec-Kill-System-Notes/","excerpt":"在实际工作中，并没有真的做过秒杀系统，所以假想了一个简单的秒杀系统来 “解解馋”以下写的是一些关键点以及部分代码, 具体的表设计,表结构根据自己需要来定.","text":"在实际工作中，并没有真的做过秒杀系统，所以假想了一个简单的秒杀系统来 “解解馋”以下写的是一些关键点以及部分代码, 具体的表设计,表结构根据自己需要来定. 分析秒杀时大量的流量涌入，秒杀开始前频繁刷新查询，如果大量的流量瞬间冲击到数据库的话，非常容易造成数据库的崩溃。所以秒杀的主要工作就是对流量进行层层筛选最后让尽可能少且平缓的流量进入到数据库。 开始在后台将一个变体添加到秒杀促销，并设置秒杀的库存 / 秒杀折扣率 / 开始时间和结束时间等，我们能够得到类似这样的数据。 变体: 变体（又称父/子关系）是彼此关联的一组商品变体 (variant) 即 sku (Stock Keeping Unit 最小存货单位), 下文将统称为变体. 1234567891011121314151617// promotion_variant (促销和变体表「sku」的一个中间表)&#123; 'id': 1, 'variant_id': 1, 'promotion_id': 1, 'promotion_type': 'snap_up', 'discount_rate': 0.5, 'stock': 100, // 秒杀库存 'sold': 0, // 秒杀销量 'quantity_limit': 1, // 限购 'enabled': 1, 'product_id': 1, 'rest': &#123; variant_name: 'xxx', // 秒杀期间变体名称 image: 'xxx', // 秒杀期间变体图片 &#125;&#125; tab_promotions 12345678910111213141516171819Schema::create('tab_promotions', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('code'); $table-&gt;string('name')-&gt;nullable(); $table-&gt;string('description')-&gt;nullable(); $table-&gt;string('cover')-&gt;nullable()-&gt;comment('促销封面'); $table-&gt;string('asset_url')-&gt;nullable()-&gt;comment('促销详情链接') $table-&gt;integer('position')-&gt;default(0)-&gt;comment('权重'); $table-&gt;string('type')-&gt;comment('优惠卷/满减促销/品牌促销/秒杀/拼团/通用.'); $table-&gt;json('config')-&gt;nullable()-&gt;comment('配置'); $table-&gt;timestamp('began_at')-&gt;nullable()-&gt;comment('促销开始时间'); $table-&gt;timestamp('ended_at')-&gt;nullable()-&gt;comment('促销结束时间'); $table-&gt;timestamps(); $table-&gt;softDeletes();&#125;); tab_promotion_variants 12345678910111213141516171819Schema::create('tab_promotion_variants', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;unsignedInteger('variant_id')-&gt;index(); $table-&gt;unsignedInteger('promotion_id')-&gt;index(); $table-&gt;decimal('discount_rate')-&gt;nullable()-&gt;comment('折扣率, 值为0.3表示打7折'); $table-&gt;unsignedInteger('stock')-&gt;nullable()-&gt;comment('促销库存'); $table-&gt;unsignedInteger('sold')-&gt;default(0)-&gt;comment('销售数量'); $table-&gt;unsignedInteger('quantity_limit')-&gt;nullable()-&gt;comment('购买数量限制'); $table-&gt;boolean('enabled')-&gt;default(1)-&gt;comment('启用'); // 冗余 $table-&gt;unsignedInteger('product_id'); $table-&gt;string('promotion_type')-&gt;comment('冗余promotion表type'); $table-&gt;json('rest')-&gt;nullable()-&gt;comment('冗余'); $table-&gt;timestamps();&#125;); 首先便是在秒杀促销创建成功后将促销的信息进行缓存 PromotionVariantObserver 123456789101112131415161718192021&lt;?phpnamespace App\\Observers;use Illuminate\\Support\\Facades\\Cache;class PromotionVariantObserver&#123; public function saved(PromotionVariant $promotionVariant) &#123; if ($promotionVariant-&gt;promotion_type === PromotionType::SNAP_UP) &#123; $seconds = $promotionVariant-&gt;ended_at-&gt;getTimestamp() - time(); Cache::put( \"promotion_variants:$promotionVariant-&gt;id\", $promotionVariant, $seconds ); &#125; &#125;&#125; 下单下单通常分为两步 第一步是 「结账 (checkout)」 生成一个结账订单, 用户可以为结账订单选择地址、优惠券、支付方式等 第二步是 「确认 (confirm)」 , 此时订单变成确认状态, 对库存进行锁定, 且用户可以进行支付.通常如果在规定时间内没有支付,则取消该订单, 并解锁库存. 所以在第一步时就会对用户进行过滤和排队处理，防止后续的选择地址、优惠卷等操作对数据库进行冲击。 CheckoutController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpnamespace App\\Api\\Controller;use App\\Api\\Controller as BaseController;use App\\Jobs\\CheckoutOrderJob;use Collective\\Annotations\\Routing\\Annotations\\Annotations\\Controller;use Illuminate\\Contracts\\Cache\\LockTimeoutException;use Illuminate\\Support\\Facades\\&#123;Auth, Request, Cache&#125;;/** * Class CheckoutController * @package App\\Api\\Controller * @Controller(prefix=\"/api/checkout\") */class CheckoutController extends BaseController&#123; public function snapUpCheckout(Request $request) &#123; // 商品ID $variantId = $request-&gt;input('variant_id'); // 商品购买数量 $quantity = $request-&gt;input('quantity', 1); // 加锁防止超卖 $lock = Cache::lock('snap_up:' . $variantId); try &#123; // 未获取锁的消费者将阻塞在这里 $lock-&gt;block(10); // 商品库存量 $promotionVariant = Cache::get('promotion_variants' . $variantId); if ($promotionVariant-&gt;quantity &lt; $quantity) &#123; $lock-&gt;release(); throw new StockException('库存不足'); &#125; // 减少库存 $promotionVariant-&gt;quantity -= $quantity; // 缓存时间 $seconds = $promotionVariant-&gt;ended_at-&gt;getTimestamp() - time(); Cache::put( \"promotion_variants:$promotionVariant-&gt;id\", $promotionVariant, $seconds ); &#125; catch (LockTimeoutException $e) &#123; return response('库存不足'); &#125; finally &#123; optional($lock)-&gt;release(); &#125; // 派发任务 CheckoutOrderJob::dispatch([ 'user_id' =&gt; Auth::id(), 'variant_id' =&gt; $variantId, 'quantity' =&gt; $quantity ]); return response('结账订单创建中'); &#125;&#125; 可以看到在秒杀结账 api 中，并没有涉及到数据库的操作。并且通过 dispatch 将创建订单的任务分发到队列，用户按照进入队列的先后顺序进行对应时间的排队等待。 现在的问题是，订单创建成功后如何通知客户端呢？ 客户端通知这里的方案无非就是轮询或者 websocket, 这里选择对服务器性能消耗较小的 websocket ，且使用 laravel 提供的 laravel-echo (laravel-echo-server)。 当用户秒杀成功后，前端和后端建立 websocket 链接，后端结账订单创建成功后通知前端可以进行下一步操作。 后端 后端接下来要做的就是在 「CheckoutOrder」 Job 中的订单创建成功后，向 websocket 对应的频道中发送一个 「OrderChecked」 事件，来表明结账订单已经创建完成，用户可以进行下一步操作。 Job/CheckoutOrderJob 1php artisan make:job CheckoutOrderJob 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace App\\Jobs;use App\\Events\\OrderCheckedEvent;use Illuminate\\Bus\\Queueable;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;class CheckoutOrderJob implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; private $data; /** * Create a new job instance. * * @return void */ public function __construct($data) &#123; $this-&gt;data = $data; &#125; /** * Execute the job. * * @return void */ public function handle() &#123; // 创建结账订单 // 通知客户端 event(new OrderCheckedEvent($this-&gt;data-&gt;user_id)); &#125;&#125; Event/OrderCheckedEvent 1php artisan make:event OrderCheckedEvent 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpnamespace App\\Events;use Illuminate\\Broadcasting\\Channel;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Broadcasting\\PrivateChannel;use Illuminate\\Broadcasting\\PresenceChannel;use Illuminate\\Foundation\\Events\\Dispatchable;use Illuminate\\Broadcasting\\InteractsWithSockets;use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;class OrderCheckedEvent&#123; use Dispatchable, InteractsWithSockets, SerializesModels; private $user_id; /** * OrderCheckedEvent constructor. * @param $user_id */ public function __construct($user_id) &#123; $this-&gt;user_id = $user_id; &#125; /** * 获取事件应广播的频道。 * App.User.&#123;id&#125; 是 Laravel初始化时, 默认的私有频道, 直接使用即可 * @return \\Illuminate\\Broadcasting\\Channel|array */ public function broadcastOn() &#123; return new PrivateChannel('App.User.' . $this-&gt;user_id); &#125;&#125; 假设当前抢购的用户 id 是 1，总结一下上面的代码就是向 websocket 的私有频道「App.User.1」 推送一个 「OrderChecked」 事件。 前端下面的代码是使用 vue-cli 工具初始化的默认项目。 123456789101112131415161718192021222324252627282930313233343536// views/products/show.vue&lt;script&gt; import Echo from &apos;laravel-echo&apos; import io from &apos;socket.io-client&apos; window.io = io export default &#123; name: &apos;App&apos;, methods: &#123; async snapUpCheckout () &#123; try &#123; this.toCheckout() &#125; catch (error) &#123; // 秒杀失败 &#125; &#125;, toCheckout () &#123; // 建立websock连接 const echo = new Echo(&#123; broadcaster: &apos;socket.io&apos;, host: &apos;http://laravel8.test:6001&apos;, auth: &#123; headers: &#123; Authorization: &apos;Bearer &apos; + this.store.auth.token &#125; &#125; &#125;) // 监听私有频道 App.User.&#123;id&#125; 的OrderCheckedEvent事件 echo.private(&apos;App.User.&apos; + this.store.user.id).listen(&apos;OrderCheckedEvent&apos;, (e) =&gt; &#123; // rediect to checkout page &#125;) &#125; &#125; &#125;&lt;/script&gt; laravel-echo 使用时需要注意的一点，由于使用了私有频道，所以 laravel-echo 默认会向服务端 api /broadcasting/auth 发送一条 post 请求进行身份验证。 但是由于采用了前后端分离而不是 blade 模板，所以我们并不能方便的获取 csrf token 和 session 来进行一些必要的认证。 因此需要稍微修改一下 broadcast 和 laravel-echo-server 的配置 Providers/BroadcastServiceProvider 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Support\\Facades\\Broadcast;class BroadcastServiceProvider extends ServiceProvider&#123; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; // 将认证路由改为 /api/broadcasting/auth 从而避免csrf验证 // 添加中间件 auth:api (jwt 使用 api.auth) 进行身份验证, 避免访问session, 并使Auth::user()生效 Broadcast::routes([ 'prefix' =&gt; 'api', 'middleware' =&gt; ['auth:api'] ]); require base_path('routes/channels.php'); &#125;&#125; laravel-echo-server.json 12// 认证路由添加 api 前缀，与上面的修改对应\"authEndpoint\": \"/api/broadcasting/auth\" 库存解锁在已经为该订单锁定” 库存 “的情况下，用户如果断开 websocket 连接或者长时间离开时需要将库存解锁，防止库存无意义占用。 这里的库存指的是缓存库存，而非数据库库存。这是因为此时订单即使创建成功也是结账状态（未选择地址，支付方式等），在个人中心也是不可见的。只有当用户确认订单后，才会将数据库库存锁定。 所以此处的理想实现是，用户断开 websocket 连接后，将该订单锁定的库存归还。且结账订单创建后再创建一个延时队列对长时间未操作的订单进行库存归还。 但但但是，laravel-echo 是一个广播系统，并没有提供客户端断开连接事件的回调，有些方法可以实现 laravel 监听的客户端事件，比如在 laravel-echo-server 添加 hook 通知 laravel，但是需要修改 laravel-echo-server 的实现，这里就不细说了，重点还是提供秒杀思路。 总结 上图为秒杀系统的逻辑总结。从图中可以看出，整个流程中，只有在 queue 中才会和 mysql 交互，通过 queue 的限流从而最大限度的适应了 mysql 的承受能力。在 mysql 性能足够的情况下，通过大量的 queue 同时消费订单，用户是完全感知不到排队的过程的。 参考 Laravel-原子锁 E-commerce 中订单系统的设计 E-commerce 中促销系统的设计 秒杀系统的设计","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"锁","slug":"锁","permalink":"http://blog.caoxl.com/tags/锁/"},{"name":"Cache","slug":"Cache","permalink":"http://blog.caoxl.com/tags/Cache/"},{"name":"秒杀","slug":"秒杀","permalink":"http://blog.caoxl.com/tags/秒杀/"}]},{"title":"消息队列之 RabbitMQ","slug":"Message-Queue-RabbitMQ","date":"2019-08-07T10:22:08.000Z","updated":"2019-12-12T09:22:55.000Z","comments":true,"path":"2019/08/07/Message-Queue-RabbitMQ/","link":"","permalink":"http://blog.caoxl.com/2019/08/07/Message-Queue-RabbitMQ/","excerpt":"简介RabbitMQ RabbitMQ 是实现了高级消息队列协议(AMQP)的开源消息代理软件(亦称面向消息的中间件) RabbitMQ is the most widely deployed open source message broker. RabbitMQ Get Started","text":"简介RabbitMQ RabbitMQ 是实现了高级消息队列协议(AMQP)的开源消息代理软件(亦称面向消息的中间件) RabbitMQ is the most widely deployed open source message broker. RabbitMQ Get Started 基础特性 1) 可靠性 消息持久化、消息发送和投递确认机制、集群高可用方案 2) 灵活路由 消息通过exchange的方式路由到不同的queue中,提供了包括fanout,direct,topic等多种exchange实现,并且支持通过编写 exchange 3) 支持集群 同网段下的rabbitmq节点可以通过集群的方法,组成一个逻辑上的单一broker 4) Federation 通过Federation可以在跨网段节点间组建集群 5) 高可用消息队列 通过设置镜像队列的方式, 消息可以在镜像队列间进行复制, 使节点宕机或硬件损坏的情况下保证队列服务的高可用 6) 多客户端支持 JAVA, .NET, Ruby, Python, PHP, Node, Go…… 7) 可视化管理界面 RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。 基础概念 Broker 经纪人. 提供一种传输服务，维护一条从生产者到消费者的传输线路，保证消息数据能按照指定的方式传输。 Producer 消息生产者. 主要讲消息投递到对应的Exchange上面,一般是独立的程序 Consumer 消息消费者. 消息的接受者, 一般是独立的程序 Message 消息. 消息是不具名的, 它由消息头和消息体组成, 消息体是不透明的, 而消息头则由一系列的可选属性组成,这些属性包括 routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出该消息可能需要持久性存储)等 Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。对于操作系统来说，建立和关闭TCP连接是有代价的，频繁的建立关闭TCP连接对于系统的性能有很大的影响，而且TCP的连接数也有限制，这也限制了系统处理高并发的能力。但是，在TCP连接中建立Channel是没有上述代价的。对于Producer或者Consumer来说，可以并发的使用多个Channel进行Publish或者Receive Exchange 消息交换机. 指定消息按照什么规则路由到哪个队列QueueProducer将并不能直接将消息投递到Queue中。需要将消息发送到Exchange，由Exchange将消息路由到一个或多个Queue中（或者没有绑定Queue的情况下将消息丢弃）。 Queue 消息队列. 消息的载体, 每条消息都会被投送到一个或多个队列中RabbitMQ中的消息都只能存在在Queue中, Producer生产消息并通过Exchange投递到Queue, Comsumer可以通过Exchange从Queue中获取消息并消费多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。 Binding 绑定. 作用就是将Exchang和Queue按照某种路由规则绑定起来. 这样RabbitMQ就知道如何正确地将消息路由到指定的Queue Routing Key 路由键. 生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。 Binding Key 在绑定（Binding）Exchange与Queue的同时，一般会指定一个binding key; 消费者将消息发送给Exchange时，一般会指定一个routing key; 当binding key与routing key相匹配时，消息将会被路由到对应的Queue中. MQ 消息队列(Message Queue, 简称MQ), 从字面意思上看,本质是个队列, FIFO先入先出,只不过队列中存放的内容是Message而已.其主要用途: 不同进程Process/线程Thread之间通信 为什么会产生消息队列? 不同进程(process)之间传递消息时,两个进程之间耦合程度过高,改动一个进程,引发必须修改另一个进程, 为了隔离这两个进程,在两进程间抽离出汗一层(一个模块), 所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个; 不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列; AMQP AMQP，即Advanced Message Queuing Protocol, 高级消息队列协议一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。 搭建RabbitMQ环境 安装Erlang Erlang Download 安装RabbitMQ Downloading and Installing RabbitMQ 安装完成,启用管理工具 双击: RabbitMQ Command Prompt 输入: rabbitmq-plugin enable rabbitmq_management 这样就启动了管理工具, 试一下 停止: net stop RabbitMQ 启动: net start RabbitMQ windows下安装步骤打开 cmd，进入rabbitmq的sbin目录执行 rabbitmq-plugins.bat enable rabbitmq_management 在浏览器中输入地址查看: http://127.0.0.1:15672 使用默认账号登录: guest/guest 基础概念Connection 与 Channel : 连接与信道 connection 是指的物理的连接, 一个clinet与一个server之间有一个连接;一个连接上可以建立多个channel,可以理解为逻辑上的连接. 一般应用的情况下,有一个channel就够用了,不需要创建更多的channel 示例代码 12345678910// 创建连接和信道$connection = new AMQPStreamConnection( $host, $port, $user, $pass, $vhost);if (!$connection-&gt;isConnected()) &#123; dd('Connection failed');&#125;$channel = new AMQPChannel($connection); Exchange 与 RoutingKey : 交换机与路由键 为了将不同类型的message进行区分, 设置了Exchange交换机与Route路由两个概念. 比如A类型的message发送到名为C1的交换机,将类型为B的发送到C2的交换机.当客户端连接C1处理队列消息时取到的就只是A类型的message.进一步的，如果A类型message也非常多，需要进一步细化区分，比如某个客户端只处理A类型message中针对K用户的message，routingKey就是来做这个用途的。 示例代码: 12345678910111213// 交换机名$exchange_name = 'exchange_1';// 路由键$route_key = ['key_1', 'key_2'];// 创建交换机$exchange = new \\AMQPExchange($channel);$exchange-&gt;setName($exchange_name);// 交换机类型: direct类型$exchange-&gt;setType(AMQP_EX_TYPE_DIRECT);// 持久化$exchange-&gt;setFlags(AMQP_DURABLE);echo \"Exchange Status:\" . $exchange-&gt;declareExchange() . \"\\n\"; 由以上代码可以看到，发送消息时，只要有“交换机”就够了。至于交换机后面有没有对应的处理队列，发送方是不用管的。routingkey可以是空的字符串。在示例中，我使用了两个key交替发送消息，是为了下面更便于理解routingkey的作用。 对于交换机，有两个重要的概念： 交换机(Exchange): 可以理解为具有路由表的路由程序。每个消息都有一个路由键(routing key), 就是一个简单的字符串.交换机中有一系列的绑定(binding), 即路由规则.交换机可以有多个,多个队列可以和同一个交换机绑定,同时多个交换机也可以和同一个队列绑定(多对多关系) A. 类型 Fanout Exchange(不处理路由键): 一个发送到交换机上的消息都会被转发到与该交换机绑定的所有队列上.Fanout交换机发消息是最快的. Direct Exchange(处理路由键): 如果一个队列绑定到该交换机上, 并且当前要求路由键为X. 只有路由键是X的消息才会被这个队列转发. Topic Exchange(将路由键和某模式进行匹配, 可以理解为模糊处理): 路由键的词有 &#39;.&#39; 隔开, 符号&#39;#&#39;表示匹配0个或多个, 符号&#39;*&#39;表示匹配不多不少一个词 类型总结: Fanout类型最简单，这种模型忽略routingkey; Direct类型是使用最多的，使用确定的routingkey。这种模型下，接收消息时绑定key_1则只接收key_1的消息; 最后一种是Topic，这种模式与Direct类似，但是支持通配符进行匹配，比如：key_*，就会接受key_1和key_2。Topic貌似美好，但是有可能导致不严谨，所以还是推荐使用Direct。 B. 持久化 指定了持久化的交换机, 在重庆启动时才能重建, 否则需要客户端重新声明生成才行.需要特别明确的概念: 交换机的持久化, 并不等于消息的持久化.只有在持久化队列中的消息,才能持久化;如果没有队列,消息是没有地方存储的;消息贝恩施在投递时也有一个持久化标志的,PHP中默认投递到持久化交换机就是持久的信息,不用特别指定 Queue : 队列 队里仅是这很对接受方(consumer)的, 由接收方根据需求创建的。只有队列创建了，交换机才会将新接受到的消息送到队列中，交换机是不会在队列创建之前的消息放进来的。换句话说，在建立队列之前，发出的所有消息都被丢弃了。 接下来看一下创建队列及接收消息的示例: 12345678910111213141516171819202122232425262728293031323334// 交换机名$exchange_name = 'exchange_1';// 队列名$queue_name = 'queue_1';// 路由key$route_key = '';// 创建连接和信道$connection = new AMQPStreamConnection($connection_args);if (!$connection-&gt;isConnected()) &#123; dd('Connection failed');&#125;// 创建信道$channel = new AMQPChannel($connection);// 创建交换机$exchange = new \\AMQPExchange($channel);// 交换机名$exchange-&gt;setName($exchange_name);// 交换机类型: direct类型$exchange-&gt;setType(AMQP_EX_TYPE_DIRECT);// 持久化$exchange-&gt;setFlags(AMQP_DURABLE);echo \"Exchange Status: \" . $exchange-&gt;declareExchange() . \"\\n\";// 创建队列$queue = new \\AMQPQueue($channel);$queue-&gt;setName($queue_name);// 持久化$queue-&gt;setFlags(AMQP_DURABLE);// 绑定交换机与队列, 并指定路由键// 阻塞模式接受消息echo \"Queue Bind: \" . $queue-&gt;bind($exchange_name, $route_key) . \"\\n\";echo \"Message: \\n\";// 自动ACK应答 $connection-&gt;disconnect()$queue-&gt;consume('processMessage', AMQP_AUTOACK); 消息的处理，是有两种方式: 一次性: 用$queue-&gt;get([...]), 不管能不能拿到消息都会立即返回, 一般情况下使用轮询处理消息队列就用这种方法 阻塞: 用过$queue-&gt;consume(callback, [...]), 程序会进入持续侦听状态, 每收到一个消息就会调用callback指定函数一次, 直到某个callback函数返回false才结束 RabbitMQ应用(五种队列)环境 RabbitMQ V3.7.17 Erlang V22.0 PHP V7.2.1 Laravel 5.8 准备 安装php-amqplib/php-amqplib 1composer require php-amqplib/php-amqplib 创建RabbitMQController 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace App\\Api\\Controller;use App\\Api\\Controller as BaseController;use Collective\\Annotations\\Routing\\Annotations\\Annotations\\&#123; Controller, Post&#125;;use PhpAmqpLib\\Connection\\AMQPStreamConnection;use PhpAmqpLib\\Message\\AMQPMessage;/** * Class RabbitMQController * @package App\\Api\\Controller * @Controller(prefix=\"/api/mq\") */class RabbitMQController extends BaseController&#123; private $host; private $port; private $user; private $pass; private $vhost; private $connection; private $channel; public function __construct() &#123; $this-&gt;host = env('MQ_HOST'); $this-&gt;port = env('MQ_PORT'); $this-&gt;user = env('MQ_USERNAME'); $this-&gt;pass = env('MQ_PASSWORD'); $this-&gt;vhost = env('MQ_VHOST'); $this-&gt;connection = new AMQPStreamConnection( $this-&gt;host, $this-&gt;port, $this-&gt;user, $this-&gt;pass, $this-&gt;vhost ); $this-&gt;channel = $this-&gt;connection-&gt;channel(); &#125;&#125; “Hello World” 消息生产者/消息消费者模式 test_send 123456789101112131415161718192021222324252627282930313233343536373839/** * Send(发送消息) * @Post(\"/test_send\") * @throws \\Exception */public function test_send()&#123; /** * 声明队列 * queue: // 队列名称 * passive: // 如果设置true存在则返回OK，否则就报错。设置false存在返回OK，不存在则自动创建 * durable: // 是否持久化，设置false是存放到内存中的，RabbitMQ重启后会丢失 * exclusive: // 是否排他，指定该选项为true则队列只对当前连接有效，连接断开后自动删除 * auto_delete: // 是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除 */ $this-&gt;channel-&gt;queue_declare('hello', false, false, false, false); /** * 创建AMQP消息 * deliver_mode: 消息是否持久化 * AMQPMessage::DELIVERY_MODE_PERSISTENT 持久化 * AMQPMessage::DELIVERY_MODE_PERSISTENT 不持久化 */ $msg = new AMQPMessage('Hello RabbitMQ!'); /** * 向队列发送消息 * msg: // AMQP消息内容 * exchange: // 交换机名称 * routing_key: // 路由键(队列名称) */ $this-&gt;channel-&gt;basic_publish($msg, '', 'hello'); echo \" [x] Sent 'Hello RabbitMQ!'\\n\"; // 关闭信道,关闭连接 $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[x] Sent &#39;Hello RabbitMQ!&#39; test_receive 123456789101112131415161718192021222324252627282930313233343536/** * Receive(接收消息) * @Post(\"/test_receive\") * @throws \\ErrorException */public function test_receive()&#123; // 声明队列 $this-&gt;channel-&gt;queue_declare('hello', false, false, false, false); echo \" [*] Waiting for message. To exit press CTRL+C\\n\"; $callback = function ($msg) &#123; echo ' [x] Received ', $msg-&gt;body, \"\\n\"; &#125;; /** * 消费队列 * queue: // 被消费的队列名称 * consumer_tag: // 消费者客户端身份标识, 用于区分多个客户端 * no_local: // 这个功能属于AMQP的标准, 但是RabbitMQ并没有实现 * no_ack: // 收到消息会后, 是否不需要回复确认即被认为被消费 * exclusive: // 是否排他, 即张恒队列只能由一个消费者消费. 适用于任务不允许进行并发处理的情况下 * nowait: // 不返回执行结果, 但是如果排他开启的话,则必须等待结果,如果两个一起开则会报错 * callback: // 回调逻辑处理函数 */ $this-&gt;channel-&gt;basic_consume('hello', '', false, true, false, false, $callback); while ($this-&gt;channel-&gt;is_consuming()) &#123; $this-&gt;channel-&gt;wait(); &#125; // 关闭信道,关闭连接 $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[*] Waiting for message. To exit press CTRL+C[x] Received Hello RabbitMQ! Work queues 工作队里: 工厂任务安排者(生产者)/工人(消费者) test_task 123456789101112131415161718192021222324/** * @Post(\"/test_task\") * @throws \\Exception */public function test_task()&#123; $this-&gt;channel-&gt;queue_declare('task_queue', false, true, false, false); if (empty($data)) &#123; $data = \"Hello RabbitMQ!\"; &#125; $msg = new AMQPMessage( $data, ['deliver_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT] ); $this-&gt;channel-&gt;basic_publish($msg, '', 'task_queue'); echo ' [x] Sent ', $data, \"\\n\"; $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[x] Sent &#39;Hello RabbitMQ!&#39; test_work 123456789101112131415161718192021222324252627/** * @Post(\"/test_work\") * @throws \\ErrorException */public function test_work()&#123; $this-&gt;channel-&gt;queue_declare('task_queue', false, true, false, false); echo \" [*] Waiting for message. To exit press CTRL+C\\n\"; $callback = function ($msg) &#123; echo ' [x] Received ', $msg-&gt;body, \"\\n\"; sleep(substr_count($msg-&gt;body, '.')); echo \" [x] Done\\n\"; $msg-&gt;delivery_info['channel']-&gt;basic_ack($msg-&gt;delivery_info['delivery_tag']); &#125;; $this-&gt;channel-&gt;basic_qos(null, 1, null); $this-&gt;channel-&gt;basic_consume('task_queue', '', false, false, false, false, $callback); while($this-&gt;channel-&gt;is_consuming()) &#123; $this-&gt;channel-&gt;wait(); &#125; $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[*] Waiting for message. To exit press CTRL+C[x] Received Hello RabbitMQ![x] Done Publish/Subcribe 发布/订阅: 消息发布者/消息订阅者 test_receive_logs 1234567891011121314151617181920212223242526272829303132333435/** * @Post(\"/test_receive_logs\") * @throws \\Exception */public function test_receive_logs()&#123; /** * 声明交换机(Exchange) * exchange: 交换机名称 * type: 交换机类型，分别为direct/fanout/topic/headers * passive: 如果设置true存在则返回OK，否则就报错。设置false存在返回OK，不存在则自动创建 * durable: 是否持久化，设置false是存放到内存中的，RabbitMQ重启后会丢失 * auto_delete: 是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除 */ $this-&gt;channel-&gt;exchange_declare('logs', 'fanout', false, false, false); list($queue_name, ,) = $this-&gt;channel-&gt;queue_declare(\"\", false, false, true, false); $this-&gt;channel-&gt;queue_bind($queue_name, 'logs'); echo \" [*] Waiting for logs. To exit press CTRL+C\\n\"; $callback = function ($msg) &#123; echo ' [x] ', $msg-&gt;body, \"\\n\"; &#125;; $this-&gt;channel-&gt;basic_consume($queue_name, '', false, true, false, false, $callback); while ($this-&gt;channel-&gt;is_consuming()) &#123; $this-&gt;channel-&gt;wait(); &#125; $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[*] Waiting for logs. To exit press CTRL+C test_emit_log 12345678910111213141516171819202122/** * @Post(\"/test_emit_log\") * @throws \\Exception */public function test_emit_log()&#123; $this-&gt;channel-&gt;exchange_declare('logs', 'fanout', false, false, false); // $data = implode(' ', array_slice($argv, 1)); if (empty($data)) &#123; $data = \"info: Hello RabbitMQ!\"; &#125; $msg = new AMQPMessage($data); $this-&gt;channel-&gt;basic_publish($msg, 'logs'); echo ' [x] Sent ', $data, \"\\n\"; $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[x] Sent info: Hello RabbitMQ! Routing test_receive_logs_direct 123456789101112131415161718192021222324252627282930/** * @Post(\"/test_receive_logs_direct\") */public function test_receive_logs_direct()&#123; $this-&gt;channel-&gt;exchange_declare('direct_logs', 'direct', false, false, false); list($queue_name, ,) = $this-&gt;channel-&gt;queue_declare(\"\", false, false, true, false); $serverites = ['info', 'warning', 'error']; foreach ($serverites as $serverity) &#123; $this-&gt;channel-&gt;queue_bind($queue_name, 'direct_logs', $serverity); &#125; echo \" [*] Waiting for logs. To exit press CTRL+C\\n\"; $callback = function ($msg) &#123; echo ' [x] ', $msg-&gt;delivery_info['routing_key'], ':', $msg-&gt;body, \"\\n\"; &#125;; $this-&gt;channel-&gt;basic_consume($queue_name, '', false, true, false, false, $callback); while ($this-&gt;channel-&gt;is_consuming()) &#123; $this-&gt;channel-&gt;wait(); &#125; $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[*] Waiting for logs. To exit press CTRL+C test_emit_log_direct 12345678910111213141516171819202122/** * @Post(\"/test_emit_log_direct\") */public function test_emit_log_direct()&#123; $this-&gt;channel-&gt;exchange_declare('direct_logs', 'direct', false, false, false); $serverity = isset($argv[1]) &amp;&amp; !empty($argv[1]) ? $argv[1] : 'info'; if (empty($data)) &#123; $data = \"Hello RabbitMQ!\"; &#125; $msg = new AMQPMessage($data); $this-&gt;channel-&gt;basic_publish($msg, 'direct_logs', $serverity); echo ' [x] Sent ', $serverity, ':', $data, \"\\n\"; $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[x] Sent info:Hello RabbitMQ! Topics test_receive_logs_topic 123456789101112131415161718192021222324252627282930/** * @Post(\"/test_receive_logs_topic\") */public function test_receive_logs_topic()&#123; $this-&gt;channel-&gt;exchange_declare('topic_logs', 'topic', false, false, false); list($queue_name, ,) = $this-&gt;channel-&gt;queue_declare(\"\", false, false, true, false); $binding_keys = ['bingding_key']; foreach ($binding_keys as $binding_key) &#123; $this-&gt;channel-&gt;queue_bind($queue_name, 'topic_logs', $binding_key); &#125; echo \" [*] Waiting for logs. To exit press CTRL+C\\n\"; $callback = function ($msg) &#123; echo ' [x] ', $msg-&gt;deliver_info['routing_key'], ':', $msg-&gt;body, \"\\n\"; &#125;; $this-&gt;channel-&gt;basic_consume($queue_name, '', false, true, false, false, $callback); while ($this-&gt;channel-&gt;is_consuming()) &#123; $this-&gt;channel-&gt;wait(); &#125; $this-&gt;channel-&gt;close(); $this-&gt;connection-&gt;close();&#125; 运行结果:[*] Waiting for logs. To exit press CTRL+C test_emit_log_topic 12345678910111213141516171819202122/** * @Post(\"/test_emit_log_topic\") */public function test_emit_log_topic()&#123; $this-&gt;channel-&gt;exchange_declare('topic_logs', 'topic', false, false, false); $routing_key = isset($argv[1]) &amp;&amp; !empty($argv[1]) ? $argv[1] : 'anonymous.info'; if (empty($data)) &#123; $data = \"Hello RabbitMQ!\"; &#125; $msg = new AMQPMessage($data); $this-&gt;channel-&gt;basic_publish($msg, 'topic_logs', $routing_key); echo ' [x] Sent ', $routing_key, ':', $data, \"\\n\"; $this-&gt;channel-&gt;close(); $this-&gt;channel-&gt;close();&#125; 运行结果:[x] Sent anonymous.info:Hello RabbitMQ! 参数说明 详情查看: Channel 声明队列 12// 声明队列$this-&gt;channel-&gt;queue_declare('queue_name', false, false, false, false); queue_declare(): 不带参数方法,默认创建一个由RabbitMq命名的(amq.gen-_rV4_Be1b5pUjMbWXqNVsw)名称, 这种队列也称之为匿名队列, 排他的, 自动删除的, 非持久化的队列 queue: 队列名称; passive: 仅检测队列是否存在 durable: 是否持久化; true:表示持久化,会存盘,服务器重启仍然存在;false:非持久化; exclusive: 是否排他的; true:排他,如果一个队列声明为排他队列,该队列公对首次声明它的连接可见,并在连接断开时自动删除; auto_delete: 是否自动删除; true:自动删除;自动删除后的前提: 至少有一个消息者连接到这个队列, 之后所有与这个队列连接的消息都断开时,才会自动删除; no_wait: true 声明队列无需等待 arguments: 其他参数 ticket: int 票 arguments 参数说明 x-message-ttl: 队列中的所有消息的过期时间 x-expires: 超过设定时间没有消费者来访问队列，就删除队列的时间（毫秒） x-max-length: 队列的最新的消息数量，如果超过设定数量，前面的消息将从队列中移除掉 x-max-length-bytes: 队列的内容的最大空间，超过该阈值就删除之前的消息 x-dead-letter-exchange: 如果队列中的消息被拒绝或过期，则可以根据设置的交换机对消息进行转发，重新发布 x-dead-letter-routing-key: 将删除的消息推送到指定的交换机对应的路由键（路由密匙） x-max-priority: 队列支持的最大优先级数;如果未设置，队列将不支持消息优先级，优先级大的优先被消费 x-queue-mode: 将队列设置为延迟模式，队列中的消息保存在磁盘中，但不会主动持久化，RabbitMQ重启后消息还是会丢失 x-queue-master-locator: 将队列设置为主位置模式，确定在节点集群上声明时队列主机所在的规则 声明交换机 12// 声明交换机$this-&gt;channel-&gt;exchange_declare('exchange_name', 'type', false, false, false); exchange: 交换机名称 type: 交换机类型 direct: 处理路由键 fanout: 不处理路由键 topic: 将路由键和某模式进行匹配 headers: 此类型的exchange和以上三个都不一样，其路由的规则是根据header来判断 passive: 执行声明或只是检查它是否存在 durable: 是否持久化; true:表示持久化,会存盘,服务器重启仍然存在;false:非持久化; auto_delete: 是否自动删除; true:自动删除;自动删除后的前提: 至少有一个消息者连接到这个队列, 之后所有与这个队列连接的消息都断开时,才会自动删除; internal: 是否内置; true:表示内置的交换器,客户端程序无法直接发送消息到这个交换机中, 只能通过交换机路由到交换机的方式 no-wait: 声明队列无需等待 arguments: 其他参数 ticket: int 票 basic_publish: (basicPublish) 1$this-&gt;channel-&gt;basic_publish($msg, $exchange_name, $routing_key); basic_publish: 发布单条消息 msg: 需要发布的消息 exchange: 交换机名称 routing_key: 路由键 basic_qos: (basicQos) 1$this-&gt;channel-&gt;basic_qos(null, 1, null); basic_qos: Qos可以分配给当前的信道(channel)或者链接内的所有信道 prefetch_size: prefetch_count: 设置消费者（Consumer）客户端同时处理队列数量 a_global: basic_consume: (basicConsume) 1$this-&gt;channel-&gt;basic_consume('task_queue', '', false, false, false, false, $callback); basic_consume: 启动队列消费者 queue: 被消费队列名称 consumer_tag: 消费者客户端身份标识，用于区分多个客户端 no_local: 这个功能属于AMQP的标准，但是RabbitMQ并没有做实现 no_ack: 收到消息后，是否不需要回复确认即被认为被消费 exclusive: 是否排他，即这个队列只能由一个消费者消费。适用于任务不允许进行并发处理的情况下 nowait: 不返回执行结果，但是如果排他开启的话，则必须需要等待结果的，如果两个一起开就会报错 callback: 回调逻辑处理函数 queue_bind : (queueBind) 1$this-&gt;channel-&gt;queue_bind($queue_name, $exchange_name); queue_bind: 将队列绑定到交换机 queue: 队列名称 exchange: 交换机名称 参考 RabbitMQ Tutorials RabbitMQ教程 RabbitMQ 中文文档 RabbitMQ 官方文档 php-amqplib Github php-amqplib/php-amqplib demo PHP code for RabbitMQ tutorials RabbitMQ入门教程(十)：队列声明queueDeclare RabbitMQ 消息队列之 Exchange Types AMQP 0-9-1 快速参考指南 消息队列RabbitMQ（一）：介绍 消息队列RabbitMQ（三）：PHP的使用示例","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"消息队列","slug":"消息队列","permalink":"http://blog.caoxl.com/tags/消息队列/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://blog.caoxl.com/tags/RabbitMQ/"},{"name":"AMQP","slug":"AMQP","permalink":"http://blog.caoxl.com/tags/AMQP/"}]},{"title":"Redis 快速实现签到统计功能","slug":"Redis-Do-Sign-Count","date":"2019-08-06T07:43:02.000Z","updated":"2019-08-22T06:35:33.000Z","comments":true,"path":"2019/08/06/Redis-Do-Sign-Count/","link":"","permalink":"http://blog.caoxl.com/2019/08/06/Redis-Do-Sign-Count/","excerpt":"","text":"触发点 用 MySql 来实现的话虽然简单粗暴，但是也有弊端，比如我们想要做一些复杂的功能就不是太方便了，或者说不是太高性能了，比如，今天是连续签到的第几天，在一定时间内连续签到了多少天。另外一方面，如果按 100 万用户量级来计算，一个用户每年可以产生 365/366 条记录，100 万用户的所有签到记录那就有点恐怖了，查询计算速度也会越来越慢。 准备 Redis 的字符串数据都是以二进制的形式存放的，所以说 Redis 的 Bit 操作非常适合处理这个场景，因为 Bit 的值为 0 或 1，用户是否打卡也可以用 0 或 1 来表示，我们把签到的天数对应到每个字节上，打卡了就是 1，没打卡就是 0，那么一个用户一年下来的记录就是 365 位的长度，100 万用户一年只需要耗费大约 43 M 左右的存储空间就可以了，而且速度贼快 大伙可能会问，这个究竟是怎么计算来的，我们来看一下官方的解释： 在一台 2010MacBook Pro 上，offset 为 2^32-1（分配 512MB）需要～300ms，offset 为 2^30-1 (分配 128MB) 需要～80ms，offset 为 2^28-1（分配 32 MB）需要～30ms，offset 为 2^26-1（分配 8MB）需要 8ms。大概的空间占用计算公式是：(offset / 8 / 1024 / 1024) MB 实例 实例化一个Redis连接 1234567891011121314151617181920212223&lt;?phpnamespace App\\Support;use App\\Concerns\\Singleton;use Illuminate\\Support\\Facades\\Log;class RedisTool extends \\Redis&#123; use Singleton; public function __construct() &#123; parent::__construct(); $host = config('database.redis.default.host'); $port = config('database.redis.default.port'); if (! $this-&gt;connect($host, $port)) &#123; Log::error(\"redis fail to connect to $host:$port\"); &#125; &#125;&#125; 1$redis = RedisTool::getInstance(); 如何设计key? 1234$dayKey = 'login:' . \\now()-&gt;format('Ymd');// 普通写法$dayKey = 'login:' . \\date('Ymd', \\time()); 签到 http://redisdoc.com/bitmap/setbit.html setbit: 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。 1$redis-&gt;setBit($dayKey, $user_id, 1); 统计签到数据 http://redisdoc.com/bitmap/bitop.html setOp: 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上 AND: 对一个或多个key求逻辑并 OR: 对一个或多个key求逻辑或 XOR: 对一个或多个key求逻辑异或 NOT: 对给定的key求逻辑非 123456789101112$redis-&gt;bitOp('AND', 'threeAnd', 'login:20190804', 'login:20190805', 'login:20190806');echo \"连续三天都签到的用户数量: \" . $redis-&gt;bitCount('threeAnd') . \"&lt;br&gt;\";$redis-&gt;bitOp('OR', 'threeOr', 'login:20190804', 'login:20190805', 'login:20190806');echo \"连续三天中签到用户数量 (有一天也算签了) :\" . $redis-&gt;bitCount('threeOr') . \"&lt;br&gt;\";// 这里不建议使用keys,可以使用scan替代$redis-&gt;bitOp('AND', 'monthActivities', $redis-&gt;keys(\"login:201908*\"));echo \"连续一个月签到用户数量 :\" . $redis-&gt;bitCount('monthActivities') . \"&lt;br&gt;\";echo \"当前用户指定天数是否签到: \" . $redis-&gt;getBit('login:20190801', 1024) . \"&lt;br&gt;\";... 结果 1234连续三天都签到的用户数量: 1连续三天中签到用户数量 (有一天也算签了) :3连续一个月签到用户数量 :0当前用户指定天数是否签到: 0 总结 这里只针对用户签到统计, 如需用户签到具体信息,需要使用一个签到记录表 参考 如何利用 Redis 快速实现签到统计功能 Redis 中 Keys 与 Scan 的使用","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"}]},{"title":"PHP面试/笔试题杂记 III","slug":"Interview-Questions-Notes-III","date":"2019-07-29T03:15:37.000Z","updated":"2019-08-22T03:13:04.000Z","comments":true,"path":"2019/07/29/Interview-Questions-Notes-III/","link":"","permalink":"http://blog.caoxl.com/2019/07/29/Interview-Questions-Notes-III/","excerpt":"这里总结一些高级一点的题","text":"这里总结一些高级一点的题 算法 基本排序算法要会写,时间复杂度要会推算, 主要是冒泡排序, 快速排序, 选择排序.查找算法,要会写二分查找法, 实际场景要会应用. 实例算法思路要明白,基本算法看多了, 我觉得是几种思路的变换, 需要自己领悟. 猴子选大王 一群猴子排成一圈，按1,2,…,n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。用程序模拟该过程。 1234567891011121314151617181920212223&lt;?phpfunction mk($n, $m)&#123; // 构造一个数组 $arr = range(1, $n); // 从第一个开始循环 $i = 1; while (count($arr) &gt; 1) &#123; // 不被踢出则压入数组尾部 ($i % $m != 0) &amp;&amp; array_push($arr, $arr[$i - 1]); // 压入数组然后删除 unset($arr[$i - 1]); // 继续循环 $i++; &#125; // 直到剩下一个为大王 return $arr[$i - 1];&#125;// 第三只为大王print_r(mk(6, 8)); 1234567891011121314151617&lt;?phpfunction _mk($n, $m)&#123; $arr = range(1, $n); $i = 0; while (count($arr) &gt; 1) &#123; // 遍历数组, 判断当前猴子是否为出局序号,如果是则出局,否则放到数组最后 (($i + 1) % $m != 0) &amp;&amp; array_push($arr, $arr[$i]); unset($arr[$i]); $i++; &#125; return $arr[$i];&#125;print_r(_mk(6, 8)); 斗地主项目设计 https://github.com/jxy918/ddzpoker/blob/master/DdzPoker.php 实现单链表与双链表实现有权重的随机算法PHP知识说说php的魔术常量, 要能全部说出来1234567__LINE__ 文件中的当前行号。__FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名__DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。__FUNCTION__ 常量返回该函数被定义时的名字__CLASS__ 常量返回该类被定义时的名字（区分大小写）。__METHOD__ 类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。__NAMESPACE__ 当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。 php的设计模式, 要能清晰说出单例, 工厂, 注册模式的实际应用. 设计模式（45 种） 单例模式 使某个类的对象仅允许创建一个 工厂模式 工厂模式 是一种类，它具有为您创建对象的某些方法。您可以使用工厂类创建对象，而不直接使用 new。这样，如果您想要更改所创建的对象类型，只需更改该工厂即可。使用该工厂的所有代码会自动更改。 注册模式 主要用来解决全局共享和交换对象 session与cookie的区别及如何解决session的跨域共享. session sticky: 会话保存在单机上, 保证会话请求落在同一台服务器上 session replication: session 复制 每一台服务器上都保持一份相同的session （造成额外的存储开销和网络开销） session 集中存储: 存储在db、 存储在缓存服务器 （redis） 基于cookie (主流) 如何防止sql注入及数据安全问题php的生命周期, 启动流程, 多看TIPI. TIPI 深入理解PHP内核: Thinking In PHP Internals php的垃圾回收机制, php变量,数组 c源代码如何实现. PHP 5 的内存回收原理? 垃圾回收机制 PHP 7 的垃圾回收和 PHP 5 有什么区别? PHP5和PHP7的垃圾回收机制都属于引用计数,但是在复杂数据类型的算法处理上: 在 PHP7 中 zval 有了新的实现方式。最基础的变化就是 *zval 需要的内存不再是单独从堆上分配，不再自己存储引用计数。复杂数据类型（比如字符串、数组和对象）的引用计数由其自身来存储。这种实现方式有以下好处:简单数据类型不需要单独分配内存，也不需要计数不会再有两次计数的情况。在对象中，只有对象自身存储的计数是有效的;由于现在计数由数值自身存储，所以也就可以和非 zval 结构的数据共享，比如 zval 和 hashtable key 之间 PHP 7 中哪些变量类型在栈，哪些变量类型在堆? 在PHP5的Zend Engine的实现中,所有的值都是在堆上分配空间,并且通过引用计数和垃圾收集来管理. PHP5的Zend Engine主要使用指向zval结构的指针来操作值,在很多地方甚至通过zval的二级指针来操作. 而在PHP7的Zend Engine实现中,值是通过zval结构本身来操作(非指针). 新的zval结构直接被存放在VM[虚拟机?]的栈上,HashTable的桶里,以及属性槽里. 这样大大减少了在堆上分配和释放内存的操作,还避免了对简单值的引用计数和垃圾收集. 变量在栈会有什么优势？PHP 7是如何让变量新建在栈的? fastcgi 比 php-cgi 的优势在哪里? CGI/FastCGI/PHP-CGI/PHP-FPM 概念理解 CGI CGI 全称是“公共网关接口”(Common Gateway Interface)，HTTP 服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。 FastCGI FastCGI 像是一个常驻(long-live)型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次（这是 CGI 最为人诟病的 fork-and-execute 模式）。 它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。FastCGI 是语言无关的、可伸缩架构的 CGI 开放扩展，其主要行为是将 CGI 解释器进程保持在内存中并因此获得较高的性能。 PHP-CGI PHP-CGI 是 PHP 自带的 FastCGI 管理器。 PHP-FPM PHP-FPM 是一个 PHP FastCGI 管理器，是只用于 PHP 的，可以在 http://php-fpm.org/download 下载得到。 Spawn-FCGI Spawn-FCGI 是一个通用的 FastCGI 管理服务器，它是 Lighttpd 中的一部分，很多人都用 Lighttpd 的 Spawn-FCGI 进行 FastCGI 模式下的管理工作，不过有不少缺点。而 PHP-FPM 的出现多少缓解了一些问题，但 PHP-FPM 有个缺点就是要重新编译，这对于一些已经运行的环境可能有不小的风险，在 PHP 5.3.3 中可以直接使用 PHP-FPM了。Spawn-FCGI 目前已经独成为一个项目，更加稳定一些，也给很多 Web 站点的配置带来便利。 你用过那些框架, 各自有什么优缺点.php运行模式有几种,分别是什么.JIT 是做了哪些优化，从而对PHP的速度有不少提升? JIT 的思想很简单，即在程序运行时动态对程序进行编译，生成平台相关的机器码（比如运行它的机器 CPU 的本地代码），从而加快程序的运行速度。在 PHP 中，JIT 将为 Zend Vm 生成的指令作为中间表示，并发出依赖于体系结构的机器代码，这样代码的宿主就不再是 Zend Vm，而是直接由 CPU 发出。 「PHP的字符串是二进制安全的」，这句话怎么理解，为什么是二进制安全?PHP中创建多线程、多进程有哪些方式?PHP中使用多线程和多进程分别有哪些优缺点?Laravel的中间件的顺序执行，是如何实现的?使用cUrl下载大文件时，占用内存太大，有没比较优化的方式?PHP 上传大文件（比如：2 GiB的视频），需要修改php.ini的哪些配置以免受到上传的大小限制？或者你有其它更好的方式?网络http code 码含义 比如204, 304, 404apache与nginx对比,你觉得他们各自的优缺点.nginx与php数据通信原理是什么.http1.0与http1.1的区别, http与https的区别.描述http请求的三次握手/四次挥手如何实现跨域请求关于header的各种参数的作用.长连接的优势在哪里.详细描述IP协议、TCP协议，以及UDP协议与它们的区别。TCP协议中，最大传输单元MTU一般最大是多少，在TCP协议中，如果一个数据被分割成多个包，这些包结构中什么字段会被标记相同。服务器使用PHP时，客户端的IP能伪造吗？如果能，列出伪造方法；如果不能，说明原因？描述域名劫持的各种方法，为什么HTTPS不能被劫持？数据库你采用mysql的引擎是什么. mysql innodb与myisam 这两种引擎本质区别是什么, 要能够从底层数据实现来说.mysql 字段类型有那些, 它们在内存能够存储多少字节数据, 比如 datetime timestamp date.在正式服务器上, 如何操作一个存储大数据表上增加一个字段或添加索引或改变数据字段类型.索引最左原则的意思是什么.mysql分库分表策略, 如何解决增表,减表问题.redis与memcached对比,各自优缺点.redis与memcached如何实现分布式搭建.一致性hash原理是什么.mongodb与mysql对比,优势在什么地方.搭建MySQL分布式，有哪些方式？MySQL主从同步，和主主同步有哪些区别，以及优劣势？描述epoll和poll、select的区别，为什么epoll会具备性能优势？Linux如何查看服务器负载说说你常用的命令如何统计日志文件中访问次数最多的十个ip地址.源码编译过lamp 或 lnmp 软件吗在当前目录下,如何查找包含keyword文件.如何重启php 或 nginx.进程与线程的区别什么情况下会出现死锁, 如何解决死锁.综合说说你在工作中碰到的难题及如何解决的, 或讲讲你做过的项目中有难度的项目.你能说一下微博的架构流程是什么样的吗? (这个问题我也是醉了)说说你们现在服务器的架构是什么样子.高并发,高流量情况下,如何设计秒杀或抢红包架构.描述OAuth2的工作原理？列出几个中文分词工具？PHP百万级数据导出方案（多csv文件压缩）参考 高级PHP（初级架构师）面试题 PHP 高级工程面试题汇总 php 高级研发工程师面试题总结 记一次腾讯PHP后端开发提前批面试 PHP新的垃圾回收机制:Zend GC详解 PHP7内核分析-垃圾回收 php-fpm 与 Nginx优化总结 PHP成长记（三） —— SSO单点登录/登出 PHP百万级数据导出方案（多csv文件压缩） PHP经典面试题，猴子选大王！","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"PHP面试题","slug":"PHP面试题","permalink":"http://blog.caoxl.com/tags/PHP面试题/"},{"name":"PHP笔试题","slug":"PHP笔试题","permalink":"http://blog.caoxl.com/tags/PHP笔试题/"}]},{"title":"PHP面试/笔试题杂记 II","slug":"Interview-Questions-Notes-II","date":"2019-07-29T01:41:38.000Z","updated":"2019-08-22T03:13:00.000Z","comments":true,"path":"2019/07/29/Interview-Questions-Notes-II/","link":"","permalink":"http://blog.caoxl.com/2019/07/29/Interview-Questions-Notes-II/","excerpt":"这里记一些零碎的题目","text":"这里记一些零碎的题目 如何判断一个字符串中是否存在一个字符?1234strstr('abcdefgh', 'cd'); // strstr — 查找字符串的首次出现strrchr('abcdefgh', 'cd'); // strrchr — 查找指定字符在字符串中的最后一次出现strpos('abcdefgh', 'cd'); // strpos — 查找字符串首次出现的位置strrpos('abcdefgh', 'cd'); // strrpos — 计算指定字符串在目标字符串中最后一次出现的位置 如何判断一个字符串中一个字符出现的次数?1substr_count('abcdefg', 'cd'); // 计算字串出现的次数 如何去掉一个字符串的最后一个字符?12substr('abcdefg', 0, -1); // 返回字符串的子串mb_substr('abcdefg', 0, strlen('abcdefg') - 1); // 获取部分字符串 不用新变量直接交换现有两个变量的值?123list($a, $b) = array($b, $a);// 或a = a + b, b = a - b, a = a-b; echo(),print(),print_r()的区别? echo是语言结构，无返回值; print功能和echo基本相同，不同的是print是函数，有返回值; print_r是递归打印，用于输出数组或对象; 用PHP打印出前一天的时间，打印格式是2020年5月20日13:14:20?1echo date('Y-m-d H:i:s', strtotime('- day')); 用PHP打印出上个月初的时间，打印格式是2020年5月20日13:14:20?1echo date('Y-m-d H:i:s', strtotime('-1 month', strtotime(date('Y-m-01 00:00:00', time())))); 写出一个函数,尽可能的高效,从一个标准的URL里取出文件的扩展名?如:http://www.baidu.com/abc/de/fg.php/?id=1,需要取出 php 或者.php? 12345678public function get_extension()&#123; $url = 'http://www.baidu.com/abc/de/fg.php/?id=1'; $path = pathinfo($url, PATHINFO_DIRNAME); $ext = pathinfo($path, PATHINFO_EXTENSION); echo $ext;&#125; 多台web服务器如何共享SESSION? 一般是把session数据按照自己定义的加密规则，加密后后存在cookie中。 把session存到同一个数据库服务器或者缓存服务器上，如memcached/redis。 如何通过javascript判断一个窗口是否已经被屏蔽? 获取open()的返回值，如果是null，就是屏蔽了 为了避免多次包含同一文件，可以用语句什么来代替它们? require_once()/include_once() 实现中文字串截取无乱码方法?1mb_substr($str, 1, 1, “GB2312”); PHP的垃圾收集机制是怎样的? PHP可以自动进行内存管理，清除不再需要的对象。PHP使用了引用计数(reference counting)这种单纯的垃圾回收(garbage collection)机制。每个对象都内含一个引用计数器，每个reference连接到对象，计数器加1。当reference离开生存空间或被设为 NULL，计数器减1。当某个对象的引用计数器为零时，PHP知道你将不再需要使用这个对象，释放其所占的内存空间。 请写一段PHP代码，确保多个进程同时写入同一个文件成功?1234567891011121314&lt;?php$fp = fopen('lock.txt', 'w+');if (flock($fp, LOCK_EX)) &#123; // 获得写锁, 写数据 fwrite($fp, \"write something\"); // 解除锁定 flock($fp, LOCK_UN);&#125; else &#123; echo \"file is locking\";&#125;fclose($fp); 如何获取一个网页的内容?12345678// 方法一$fp = fopen('http://blog.caoxl.com', 'rb');$content = stream_get_contents($fp);fclose($fp);echo $content;// 方法二file_get_contents('http://blog.caoxl.com'); 请写一个函数验证电子邮件的格式是否正确（要求使用正则）?1preg_match('/^[\\w\\-\\.]+@[\\w\\-]+(\\.\\w+)+$/',$email); PHP中，如何获得一个数组的键值? 使用key()可以获得数组中当前元素的键名 使用current()则可以返回当前元素的值 使用array_keys()则可以得到数组中所有的键名。 使用foreach结构foreach($arr as key=&gt;value)可以通过key和value分别获取键名和值。 PHP单点登录哪个的解决方案比较好点? SSO Single Sign On 单点登录Session多端登录，其实可以拆解为Session共享+登录，不是什么高级的东西，无非是需要的Session值在让不同服务器不同域名的情况下都可以访问，让大家都读取同一个Session值，重要的是同一个session_id()值。这样的话，每台（服务器/项目）读取的都是同样的数据，既然都是读取同样的数据（尤其读取同样的session_id()值），那么我们不就可以凭借此标识符让不同用户显示不同的内容，多点登陆的问题不就解决了 session共享的关键技术点在于两点： 让客户端访问同一个sessionId, 让所有域名对应的服务器访问的Session的数据的位置必须一致 Session共享大概有四种情况: 同服务器同域名，同服务器不同域名，不同服务器同域名，不同服务器不同域名。 同服务器同域名（不同子域名）的实现： 123456789101112// 1. 在php页面的最开始(在任何输出之前,并且在session_start()之前的地方进行以下设置ini_set('session.cookie_path', '/');ini_set('session.cookie_domain', '.mydomain.com');ini_set('session.cookie_lifetime', '1800');// 2. 在php.ini里设置session.cookie_path = '/';session.cookie_domain = .mydomain.comsession.cookie_lifetime = 1800// 3. 在php页面最开始的地方调用函数session_set_cookie_params(1800, '/', '.mydomain.com'); 同服务器不同域名的实现： 不同域名的话就要先将cookie(‘PHPSESSID’)跨域，然后通过这个sessionid值从MySQL数据库或者Nosql中取得对应数据，这样就实现了同服务器不同域名的session共享。然后是Redis数据共享，key就是session_id，值就是需要共享的数据，使用到的就是Redis的集群技术 不同服务器同域名的实现： 此种情况与 &lt;同服务器不同域名的实现&gt; 差不多，但在此种情况下不需要考虑cookie跨域的问题了，那么着重实现数据共享即可，同上，key为sessio_id，值为具体的数据值. 不同服务器名不同域名的实现： 此种情况和 &lt;同服务器不同域名的实现&gt; 类似，也是要实现两个目标，同一个sessionId，同样的数据源。不同域名的话就要先将cookie(‘PHPSESSID’)跨域，然后通过这个sessionid值从MySQL数据库或者Nosql中取得对应数据，这样就实现了同服务器不同域名的session共享。 如何实现session共享?要解决session共享，就必须解决两个问题： 多台服务器用同一个session_id 这个比较容易解决，只要在php中设置存session_id的cookie域名为网站主域就可以了 打开PHP.ini， 设置session.cookie_domain = .caoxl.com, 当然也可以在php代码当中设置ini_set(“session.cookie_domain”,”caoxl.com”); 多台服务器用同一个session_id访问到相同的session内容 要实现这点，就必须把session内容存储到让所有服务器都能访问到的地方，php的session内容是默认存储到本服务器的文件中的，一般的解决方案是存入数据库，memcache或者redis这种缓存服务器，当然用默认的文件存储方式也可以，用NFS统一存储。 如何选择存储引擎 默认文件存储 这种方式的session销毁依托于php垃圾收集器，在高并发或销毁时间较长的情况下，在SESSION目录下产生大量文件，当然可以设置分级目录进行 SESSION 文件的保存。这会导致两个问题：第一、查找文件慢；第二，每个目录下可容纳的文件数是有限的，可能会导致新SESSION储存失败。 数据库存储 把Session存储在数据库里可以防止Session数据被垃圾收集器删除，可以固化存储session数据。但是用数据库来同步session，会加大数据库的IO，增加数据库的负担。而且数据库读写速度较慢，不利于session的适时同步 memcache存储 以这种方式来同步session，不会加大数据库的负担，并且安全性比较高，把session放到内存里面，比从文件中读取要快很多。 但是memcache把内存分成很多种规格的存储块，有块就有大小，这种方式也就决定了，memcache不能完全利用内存，会产生内存碎片，如果存储块不足，还会产生内存溢出 那些不需要“分布”的，不需要共享的，或者干脆规模小到只有一台服务器的应用，memcached不会带来任何好处，相反还会拖慢系统效率，因为网络连接同样需要资源。 redis存储 与memcache相比，redis访问稍稍慢一点点，好处是： redis支持的数据结构较多，可以存储数组或对象，而memcache只能存储字符串 在session机器重启的情况下，memcache所有用户都必须重新获得 session，而redis不会 在突然涌来大量用户产生了很多数据把存储 session 的机器内存占满了的情况下，memcache 会罢工，所有 key 都没过期的话就不停的覆盖最后写入的数据，而 redis 只是会变慢 ，不会影响程序的逻辑","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"PHP面试题","slug":"PHP面试题","permalink":"http://blog.caoxl.com/tags/PHP面试题/"},{"name":"PHP笔试题","slug":"PHP笔试题","permalink":"http://blog.caoxl.com/tags/PHP笔试题/"}]},{"title":"PHP标准库(SPL)","slug":"PHP-SPL","date":"2019-07-22T10:20:40.000Z","updated":"2019-07-23T02:39:29.000Z","comments":true,"path":"2019/07/22/PHP-SPL/","link":"","permalink":"http://blog.caoxl.com/2019/07/22/PHP-SPL/","excerpt":"SPL是用于解决典型问题(standard problems)的一组接口与类的集合。https://www.php.net/manual/zh/book.spl.php","text":"SPL是用于解决典型问题(standard problems)的一组接口与类的集合。https://www.php.net/manual/zh/book.spl.php 数据结构SplDoublyLinkedList SplDoublyLinkedList类提供双向链表的主要功能。 SplStack SplStack类通过使用一个双向链表来提供栈的主要功能 SplQueue SplQueue类通过使用一个双向链表来提供队列的主要功能 SplHeap SplHeap类提供堆的主要功能。 SplMaxHeap SplMaxHeap类提供堆的主要功能，保持最大值。 SplMinHeap SplMinHeap类提供堆的主要功能，保持最小值。 SplPriorityQueue SplPriorityQueue类提供了使用最大堆实现的优先级队列的主要功能。 SplFixedArray SplFixedArray类提供了数组的主要功能。SplFixedArray和普通PHP数组之间的主要区别在于SplFixedArray具有固定长度，并且仅允许范围内的整数作为索引。优点是它允许更快的阵列实现。 SplObjectStorage SplObjectStorage类提供从对象到数据的映射，或者通过忽略数据来提供对象集。在涉及唯一标识对象的需要的许多情况下，这种双重目的可能是有用的。 迭代器AppendIterator 这个迭代器能陆续遍历几个迭代器 ArrayIterator 这个迭代器允许在遍历数组和对象时删除和更新值与键。 CachingIterator 此对象支持对另一个迭代器的缓存迭代。 CallbackFilterIteratorDirectoryIterator DirectoryIterator类提供了一个用于查看文件系统目录内容的简单界面。 EmptyIterator 空迭代器的EmptyIterator类。 FilesystemIterator Filesystem迭代器 FilterIterator 这个抽象类的遍历并过滤出不想要的值.这个类应该被实现了迭代过滤器的类继承 FilterIterator::accept()方法必须被子类实现. GlobIterator 遍历一个文件系统行为类似于 glob(). InfiniteIterator 所述InfiniteIterator允许一个无限迭代的迭代器，而无需在达到其端手动倒带迭代器。 IteratorIterator 这个迭代器包装器允许将任何可遍历的东西转换为 迭代器。重要的是要理解大多数没有实现迭代器的类都有理由，因为它们很可能不允许完整的迭代器功能集。如果是这样，应提供技术以防止误用，否则会出现异常或致命错误。 LimitIterator LimitIterator类允许遍历一个 Iterator 的限定子集的元素. MultipleIterator 迭代遍历所有连接迭代器的迭代器 NoRewindIterator 这个迭代器忽略了倒带操作。这允许在多个部分foreach循环中处理迭代器。 ParentIterator 此扩展的FilterIterator允许使用RecursiveIteratorIterator进行递归迭代，该迭代仅显示具有子项的元素。 RecursiveArrayIterator 这个迭代器允许在以与ArrayIterator相同的方式迭代Arrays和Objects时取消设置和修改值和键。另外，可以迭代当前的迭代器条目。 RecursiveCachingIteratorRecursiveCallbackFilterIteratorRecursiveDirectoryIterator 该RecursiveDirectoryIterator提供一个接口，在文件系统的目录遍历递归。 RecursiveFilterIterator 此抽象迭代器过滤掉RecursiveIterator的不需要的值。应该扩展此类以实现自定义筛选器。该RecursiveFilterIterator::accept（）方法必须在子类实现。 RecursiveIteratorIterator 可用于迭代递归迭代器。 RecursiveRegexIterator 这个递归迭代器可以通过正则表达式过滤另一个递归迭代器。 RecursiveTreeIterator 允许迭代RecursiveIterator以生成ASCII图形树。 RegexIterator 此迭代器可用于基于正则表达式过滤另一个迭代器。 接口Countable 类实现 Countable 可被用于 count() 函数. OuterIterator 实现OuterIterator的类可用于迭代迭代器。 RecursiveIterator 实现RecursiveIterator的类可用于递归迭代迭代器。 SeekableIterator 可读的迭代器。 异常BadFunctionCallException 如果回调引用未定义的函数或者缺少某些参数，则抛出异常。 BadMethodCallException 当一个回调方法是一个未定义的方法或缺失一些参数时会抛出该异常。 DomainException 如果值不符合定义的有效数据域，则抛出异常。 InvalidArgumentException 如果参数不是预期类型，则抛出异常。 LengthException 如果长度无效，则抛出异常。 LogicException 表示程序逻辑错误的异常。这种异常应直接导致代码中的修复。 OutOfBoundException 如果值不是有效键，则抛出异常。这表示在编译时无法检测到的错误。 OutOfRangeException 请求非法索引时抛出异常。这表示应该在编译时检测到的错误。 OverflowException 将元素添加到完整容器时抛出异常。 RangeException 抛出异常以指示程序执行期间的范围错误。通常这意味着除了/溢出之外还有一个算术错误。这是DomainException的运行时版本 。 RuntimeException 如果发生只能在运行时发现的错误，则抛出异常。 UnderflowException 在空容器上执行无效操作（例如删除元素）时抛出异常。 UnexpectedValueException 如果值与一组值不匹配，则抛出异常。通常，当函数调用另一个函数并且期望返回值是某个类型或值（不包括算术或缓冲区相关的错误）时，会发生这种情况。 SPL函数class_implements class_implements — 返回指定的类实现的所有接口。 class_parents class_parents — 返回指定类的父类。 class_uses class_uses - 返回给定类使用的特征 iterator_apply iterator_apply — 为迭代器中每个元素调用一个用户自定义函数 iterator_count iterator_count — 计算迭代器中元素的个数 iterator_to_array iterator_to_array — 将迭代器中的元素拷贝到数组 spl_autoload_call spl_autoload_call — 尝试调用所有已注册的__autoload()函数来装载请求类 spl_autoload_extensions spl_autoload_extensions — 注册并返回spl_autoload函数使用的默认文件扩展名。 spl_autoload_functions spl_autoload_functions — 返回所有已注册的__autoload()函数。 spl_autoload_register spl_autoload_register — 注册给定的函数作为 __autoload 的实现 spl_autoload_unregister spl_autoload_unregister — 注销已注册的__autoload()函数 spl_autoload spl_autoload — __autoload()函数的默认实现 spl_classes spl_classes — 返回所有可用的SPL类 spl_object_hash spl_object_hash — 返回指定对象的hash id spl_object_id 此函数返回对象的唯一标识符。对象id在对象的生命周期中是唯一的。一旦对象被销毁，其id可以重用于其他对象。此行为类似于 spl_object_hash（）。 文件处理SplFileInfo SplFileInfo类为单个文件的信息提供高级面向对象的接口。 SplFileObject SplFileObject类为文件提供了一个面向对象接口. SplTempFileObject SplTempFileObject类为临时文件提供面向对象的接口。 各种类及接口ArrayObject 该类允许对象作为数组工作。 SplObserver 该SplObserver接口用于一起 SplSubject实现Observer设计模式。 SplSubject 该SplSubject接口用于一起 SplObserver实现Observer设计模式。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"SPL","slug":"SPL","permalink":"http://blog.caoxl.com/tags/SPL/"}]},{"title":"Be-PHP-Senior-Programmer","slug":"Be-PHP-Senior-Programmer","date":"2019-07-22T03:44:18.000Z","updated":"2019-07-26T07:32:41.000Z","comments":true,"path":"2019/07/22/Be-PHP-Senior-Programmer/","link":"","permalink":"http://blog.caoxl.com/2019/07/22/Be-PHP-Senior-Programmer/","excerpt":"做你想做的,做你不会做的,做需要你做的 - 怎么才能提高你自己?","text":"做你想做的,做你不会做的,做需要你做的 - 怎么才能提高你自己? !!! 超长预警 !!! 编码习惯优秀,符合PSR代码规范,熟悉PHP项目优化项目怎么优化? PHP 项目优化 PHP代码级别 PHP周边问题 PHP语言自身 少写代码，多尝试使用 php 本身的功能，例如内置函数，常量; 内置函数的效率也是有高低的， 要选择效率高的内置函数; 尽量避免使用 php 的魔术方法; 不要使用错误抑制符 @; 合理使用内存, 使用 unset() 释放未使用的内存; 尽量少使用正则表达式; 避免在循环中进行计算，因为这样每次循环都会计算一次; 不要使用 php 进行密集型的运算; 请务必使用带引号的字符串做键值; 哪些地方需要优化? 换句话说: 哪些是影响PHP性能的可能性 语法使用不当 使用 PHP 做了它不擅长的事情 通过 PHP 连接的服务有性能问题 PHP 语言本身的缺点或特点 语法不严谨 原生对多线程支持不好 原生不支持对象常驻内存 PHP 周边环境问题 网络问题 一些未知因素 如何发现需要优化的地方? 使用性能分析工具 AB : Apache Benchmark XHProf : XHProf vld : Vulcan Logic Dumper XDebug : XDebug 官方手册 熟练使用HTML/CSS/JavaScript/Ajax/JQuery/XML等技术进行WEB应用开发JSON和XML的区别? XML定义: 扩展标记语言 (Extensible Markup Language, XML) 优点: 格式统一，符合标准; 容易与其他系统进行远程交互，数据共享比较方便 缺点: XML文件庞大，文件格式复杂，传输占带宽; 服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护; 客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码 服务器端和客户端解析XML花费较多的资源和时间 JSON定义: JSON(JavaScript Object Notation)一种轻量级的数据交换格式 优点: 数据格式比较简单，易于读写，格式都是压缩的，占用带宽小; 易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取; 支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析; 在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取; 因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。 缺点: 没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性 JavaScript和Jquery的异同? 本质区别: JS是直译式脚本语言,是一种动态类型、弱类型、基于原型的语言，内置支持类型; jQuery是一个兼容浏览器的JS库 熟悉PHP7, 熟悉设计模式和算法, 深入了解PHP的性能最优化和安全最大化PHP7有哪些特性?比PHP5快的原因是什么? 新特性 官方手册 PHP7 新特性PHP7新特性整理介绍篇 熟悉哪些设计模式? 比如说? 应用场景? PHP 完整实战 23 种设计模式 - LearnKu 工厂模式 用工厂方法或类来生成对象，而不是在代码中直接 new Class()，替换new Class() 这种写法 好处是如果生成对象的方式发生改变，比如构造参数改变，直接修改工厂方法就行了 单例模式 使某个类的对象只允许创建一个 比如数据库类，数据库的连接只需要连接一次 注册模式 解决全局变量共享问题和交换对象 可以理解成用一个类来存放全局变量 适配器模式 可以将截然不同的函数接口封装成统一的 API 比如多种数据库的连接方法不同，通过这个模式封装成统一的 API 策略模式 将一组特定的行为和算法封装成类，以适应某些特定的上下文环境 数据对象映射模式 将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作 例子：ORM 迭代器模式 在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素 实现 Iterator 接口即可 如何使PHP性能最优化? 任何提及优化的都不是一两句能说清楚的,所以这里提供一些文章自行查看. 服务器做了两个优化 CPU 使用率减低 40% PHP 应用性能优化指南 十个 Laravel 5 程序优化技巧 安全最大化? 那有些什么安全问题? 如何解决? PHP 安全问题入门：10 个常见安全问题 + 实例讲解 PHP安全问题? SQL注入: 转义用户输入的数据 使用封装好的语句 XSS: 坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符 另外设置 Cookie 时，如果无需 JS 读取的话，请必须设置为 “HTTP ONLY”。这个设置可以令 JavaScript 无法读取 PHP 端种的 Cookie。 XSS 又叫 CSS (Cross Site Script) ，跨站脚本攻击 XSRF/CSRF 最常用的防御方法是生成一个 CSRF 令牌加密安全字符串，一般称其为 Token，并将 Token 存储于 Cookie 或者 Session 中。 CSRF 是跨站请求伪造的缩写，它是攻击者通过一些技术手段欺骗用户去访问曾经认证过的网站并运行一些操作。 LFI 要防御此类攻击，你必须仔细考虑允许用户输入的类型，并删除可能有害的字符，如输入字符中的 “.” “/” “\\”。 LFI （本地文件包含） 是一个用户未经验证从磁盘读取文件的漏洞。 不充分的密码哈希 为密码哈希加盐（Salt），加盐处理避免了两个同样的密码会产生同样哈希的问题 新版的 PHP 中也自带了安全的密码哈希函数 password_hash ，此函数已经包含了加盐处理。对应的密码验证函数为 password_verify 用来检测密码是否正确。password_verify 还可有效防止 时序攻击. 扎实的SQL知识，熟练使用MySQL，熟悉MySQL优化，熟悉Redis、MongoDB等NoSQL数据库什么是NoSQL? 对不同于传统的关系数据库的数据库管理系统的统称，泛指非关系型的数据库. NoSQL的四大种类 临时性键值存储 永久性键值存储 面向文档存储 面向列的存储 Memcached Tokyo Tyrant MongoDB Cassandra Redis Flare CouchDB Hbase Redis MySQL如何优化? 从哪些方面优化? MySQL 优化MySQL SQL优化MySQL 大表优化 Redis和Memcached的异同? 优劣势? Redis 优点: 读写性能优异 支持数据持久化，支持AOF和RDB两种持久化方式 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 数据结构丰富 缺点: Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis的主从复制采用全量复制，复制过程中主机会fork出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。 Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费 Memcached 优点: 部分容灾: memcache使用一致性哈希算法,处理”雪崩”问题 容量问题 均衡请求 缺点: 不能持久化存储 集群数据没有复制和同步机制 MongoDB的应用场景? MongoDB 是一个高性能，开源，无模式的文档型数据库，开发语言是C++。它在许多场景下可用于替代统的关系型数据库或键/值存储方式。什么场景应该用 MongoDB ？MongoDB 使用场景及运维管理问题交流探讨MongoDB、Hbase、Redis等NoSQL优劣势、应用场景 MongoDB 优点: 更高的写负载，MongoDB拥有更高的插入速度。 处理很大的规模的单表，当数据表太大的时候可以很容易的分割表。 高可用性，设置M-S不仅方便而且很快，MongoDB还可以快速、安全及自动化的实现节点 （数据中心）故障转移。 快速的查询，MongoDB支持二维空间索引，比如管道，因此可以快速及精确的从指定位置 获取数据。 非结构化数据的爆发增长，增加列在有些情况下可能锁定整个数据库，或者增加负载从而 导致性能下降，由于MongoDB的弱数据结构模式，添加1个新字段不会对旧表格有任何影响， 整个过程会非常快速。 缺点 不支持事务。 MongoDB占用空间过大 。 MongoDB没有成熟的维护工具。 记忆最深刻: 优化过什么SQL? 自由发挥… 熟悉B2B/B2C/O2O等网站性能优化，熟练掌握MySQL主从开发、索引优化、查询优化和存储优化，以及PHP缓存、静态化等技术什么是B2B/B2C/O2O ? B2B - 经济组织对经济组织 B2C - 经济组织对消费者 O2O - 网上与网下相结合 索引如何优化? 什么场景需要优化? MySQL 索引优化全攻略 常见的数据库集群架构如何？ 一主多从,主从同步,读写分离. 主从复制的原理是什么? 主服务器出问题 从如何保证业务正常? MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。深度探索MySQL主从复制原理 数据库主库和从库不一致，常见有这么几种优化方案： 业务可以接受，系统不优化 强制读主，高可用主库，用缓存提高读性能 在cache里记录哪些记录发生过写请求，来路由读主还是读从 查询如何优化? MySql查询性能优化 避免向数据库请求不需要的数据 避免使用SELECT *这种方式进行查询，应该只返回需要的列。 查询数据的方式 查询数据的方式有全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等。这些查询方式，速度从慢到快，扫描的行数也是从多到少。可以通过EXPLAIN语句中的type列反应查询采用的是哪种方式。 分解大的查询 可以将一个大查询切分成多个小查询执行，每个小查询只完成整个查询任务的一小部分，每次只返回一小部分结果 删除旧的数据是一个很好的例子。 优化MIN()和MAX() 添加索引可以优化MIN()和MAX()表达式。例如，要找到某一列的最小值，只需要查询对应B-Tree索引的最左端的记录即可。类似的，如果要查询列中的最大值，也只需要读取B-Tree索引的最后一条记录。 用IN()取代OR 在MySql中，IN()先将自己列表中的数据进行排序，然后通过二分查找的方式确定列的值是否在IN()的列表中，这个时间复杂度是O(logn)。如果换成OR操作，则时间复杂度是O(n)。 优化关联查询 优化关联查询，要确保ON或者USING子句中的列上有索引，并且在建立索引时需要考虑到关联的顺序。通常来说，只需要在关联顺序中的第二个表的相应列上创建索引此外，确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样才能使用索引来优化这个过程。 临时表的概念 当遇到子查询时，先执行子查询并将结果放到一个临时表中，然后再将这个临时表当做一个普通表对待。 MySql的临时表是没有任何索引的，在编写复杂的子查询和关联查询的时候需要注意这一点。 临时表也叫派生表。 排序优化 应该尽量让MySql使用索引进行排序。当不能使用索引生成排序结果的时候，MySql需要自己进行排序。 子查询优化 MySql的子查询实现的非常糟糕。最糟糕的一类查询是WHERE条件中包含IN()的子查询语句。 应该尽可能用关联替换子查询，可以提高查询效率。 优化COUNT()查询 当使用COUNT(*)时，统计的是行数，它会忽略所有的列而直接统计所有的行数。而在括号中指定了一个列的话，则统计的是这个列上值不为NULL的个数。 可以考虑使用索引覆盖扫描或增加汇总表对COUNT()进行优化。 熟悉Swoole，深入其原理，有Swoole实际项目研发经验swoole的优势? 实际应用过吗? PHP-FPM vs Swoole Swoole 加速的原理 由 Reactor（epoll 的 IO 复用方式）负责监听 Socket 句柄的事件变化，解决高并发问题 通过内存常驻的方式节省 PHP 代码初始化的时间，在使用笨重的框架时，用 swoole 加速效果是非常明显的。 PHP-FPM VS Swoole PHP-FPM Master 主进程 / Worker 多进程模式 启动 Master，通过 FastCGI 协议监听来自 Nginx 传输的请求。 每个 Worker 进程只对应一个连接，用于执行完整的 PHP 代码。 PHP 代码执行完毕，占用的内存会全部销毁，下一次请求需要重新再进行初始化等各种繁琐的操作。 只用于 HTTP Server。 Swoole Master 主进程（由多个 Reactor 线程组成）/ Worker 多进程（或多线程）模式 启动 Master，初始化 PHP 代码，由 Reactor 监听 Socket 句柄的事件变化。 Reactor 主线程负责子多线程的均衡问题，Manager 进程管理 Worker 多进程，包括 TaskWorker 的进程。 每个 Worker 接受来自 Reactor 的请求，只需要执行回调函数部分的 PHP 代码。 只在 Master 启动时执行一遍 PHP 初始化代码，Master 进入监听状态，并不会结束进程。 不仅可以用于 HTTP Server，还可以建立 TCP 连接、WebSocket 连接。 swoole的协程实现原理? 4.0 协程实现原理 LaravelS / Swift / 或者其他的Swoole实际开发经验? 熟悉ThinkPHP/Laravel/Lumen等框架Laravel 门面/自动注入/依赖反转 如何实现? 依赖注入,控制翻转,反射各个概念的理解和使用 框架的 CURD/中间件/Auth/Restful API 这几个框架的 JWT/Token/Passport 相关问题? 熟悉缓存技术（Redis,Memcached）、消息队列（Resque,RabbitMQ）等领域; Redis有哪些数据类型? 一般用哪种类型? 为什么? 时间复杂度? Redis做一个热门榜单? 伪代码如何实现? 你使用过哪些消息队列? 什么应用场景? 秒杀需要注意什么? 缓存穿透/缓存雪崩如何解决? 如何实现消息队列? 熟悉PHP常用的SPL库，并合理应用到日常开发中; https://www.php.net/manual/zh/book.spl.php 用过哪些PHP基本扩展? 用过哪些PHP SPL库? 优劣势是什么? 开发中用过哪些? 有大型分布式、高并发、高负载、高可用系统设计、开发和调优经验; 什么是分布式? 如何做到分布式? 高并发和高负载 怎么处理? 怎么优化? 处理过最多的qps是多少? 怎么设计的? 怎么处理库存过度的问题? 熟悉PHP的多进程模型(PCNTL)，熟悉PHP的协程模型,并合理应用到日常开发中; 进程/线程/协程的定义? 区别? PHP原生如何实现多进程? 缺点是什么? PHP协程模型怎么实现? 如何实现PHP的协程? 熟悉Linux系统工具的使用(如top,strace,perf,vmstat,sar,tcpdump)，能够快速找出系统瓶颈并调优; Linux 常用命令? 作用是? 熟悉Sed/Awk等Linux 文本工具的使用，结合shell构建复杂的系统工具; shell命令的使用? 完成一个自动发布的shell命令? 使用sed/awk 查询文本? 熟悉svn、git代码管理; svn/git 如何实现紧急发布? svn/git 如何实现多分支协同开发? 如何搭建git server ? 熟悉面向对象编程，熟悉常用设计模式，熟悉 S.O.L.I.D 原则; https://zh.wikipedia.org/wiki/SOLID_(%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1) 什么是S.O.L.I.D? 使用过哪些设计模式? 对分布式系统、微服务、高并发、高集群有了解; 什么是微服务? 优劣势? 如何搭建集群? 常见问题怎么解决? 如何搭建分布式系统? 熟悉MySQL建表、慢查询分析、SQL优化、索引调优、分表分库分区; 什么是慢查询? 如何开启? 怎么使用binlog日志恢复数据库? 从哪些进行SQL优化? 索引的类型有哪些? 具体应用场景? 如何优化索引? B Tree 和 B+Tree 的区别? 怎么分表分库分区? 何时需要? 优缺点是什么? MySQL的锁有哪些? 具体使用? MySQL 引擎的选择? 事务的处理? 大表查询如何优化? 有丰富的后台系统开发经验，有丰富的数据处理、统计相关经验; LaravelAdmin / FastAdmin ? 实现大表统计? 大数据导表? 熟悉微信公众号、支付宝服务窗的接口及平台特性，有相关经验; 实现微信登录/授权/支付? 实现支付宝支付? 实现一些其他第三方? 关键词PHP MySQL Linux NoSQL Redis Memcached MongoDb SQL Laravel Lumen ThinkPHP3 ThinkPHP5 FuelPHP Swoole Workerman Laravel admin FastAdmin HTML CSS JavaScript Ajax Pjax Jquery XML JSON Nginx Shell RabbitMQ SPL PSR MVC OOP top strace perf vmstat sar tcpdump Sed Awk svn git docker Vagrant dingo Restful API CORS JWT VueJs WVVM Github GitLab ShowDoc eoLinker dsp ssp Lua Symfony Yaf ElasticSearch IK Go-MySQL-Elasticsearch reliese annotations PHPUnit Composer Python Go Ruby Lua Node.js Rust React AB XHProf vld XDebug 参考 PHP 进阶之路 - 亿级 pv 网站架构实战之性能压榨 深入 Laravel 核心 Laravel Mix 中文文档 Laravel 之道 The 2018 Guide to Building Secure PHP Software MongoDB、Hbase、Redis等NoSQL优劣势、应用场景","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"PHPUnit","slug":"PHP-UNIT","date":"2019-07-19T03:23:27.000Z","updated":"2019-07-19T08:54:17.000Z","comments":true,"path":"2019/07/19/PHP-UNIT/","link":"","permalink":"http://blog.caoxl.com/2019/07/19/PHP-UNIT/","excerpt":"单元测试(Unit)是针对你的代码中非常少，而且相对独立的一部分代码来进行的测试。实际上，大部分单元测试都是针对单个方法进行的。功能测试(Feature)是针对大面积代码进行的测试，包括多个对象之间的交互，甚至是对 JSON 端点的完整 HTTP 请求。","text":"单元测试(Unit)是针对你的代码中非常少，而且相对独立的一部分代码来进行的测试。实际上，大部分单元测试都是针对单个方法进行的。功能测试(Feature)是针对大面积代码进行的测试，包括多个对象之间的交互，甚至是对 JSON 端点的完整 HTTP 请求。 快速入门环境 PHP 7.2 Laravel 5.8 定义并运行测试12345// 在 Feature 目录下创建一个测试类...php artisan make:test UserTest// 在 Unit 目录下创建一个测试类...php artisan make:test UserTest --unit Feature 12345678910111213141516171819202122&lt;?phpnamespace Tests\\Feature;use Tests\\TestCase;use Illuminate\\Foundation\\Testing\\WithFaker;use Illuminate\\Foundation\\Testing\\RefreshDatabase;class UserTest extends TestCase&#123; /** * A basic feature test example. * * @return void */ public function testExample() &#123; $response = $this-&gt;get('/'); $response-&gt;assertStatus(200); &#125;&#125; Unit 1234567891011121314151617181920&lt;?phpnamespace Tests\\Unit;use Tests\\TestCase;use Illuminate\\Foundation\\Testing\\WithFaker;use Illuminate\\Foundation\\Testing\\RefreshDatabase;class UserTest extends TestCase&#123; /** * A basic unit test example. * * @return void */ public function testExample() &#123; $this-&gt;assertTrue(true); &#125;&#125; 可用断言asseertCookie 断言响应中包含给定的 cookie： 1$response-&gt;assertCookie($cookieName, $value = null); asseertCookieExpired 断言响应中包含了给定的 cookie 且它已过期： 1$response-&gt;assertCookieNotExpired($cookieName); asseertCookieMissing 断言响应中不包含给定的 cookie： 1$response-&gt;assertCookieMissing($cookieName); asseertDontSee 断言响应中不包含给定的字符串： 1$response-&gt;assertDoneSee($Value); asseertDontSeeText 断言给定字符串不包含在响应文本中： 1$response-&gt;assertDontSeeText($value); asseertExactJson 断言响应中包含的数据与给定的 JSON 数据完全匹配： 1$response-&gt;assertExactJson(array $data); asseertForbidden 断言响应中有禁止状态码： 1$response-&gt;assertForbidden(); asseertHeader 断言响应中有给定的包头： 1$response-&gt;assertHeader($headerName, $value = null); asseertHeaderMissing 断言响应中没有给定的报头： 1$response-&gt;assertHeaderMissing($headerName); asseertJson 断言响应包含给定的 JSON 数据： 1$response-&gt;asserJson(array $data); asseertJsonCount 断言响应 JSON 中有一个数组，其中包含给定键的预期元素数量： 1$response-&gt;assertJsonCount($count, $key = null); asserJsonFragment 断言响应包含给定 JSON 片段： 1$response-&gt;assertJsonFragment(array $data); asseertJsonMissing 断言响应未包含给定的 JSON 片段： 1$response-&gt;assertJsonMissing(array $data); asseertJsonMissingExact 断言响应不包含确切的 JSON 片段： 1$response-&gt;assertJsonMissingExact(array $data); asseertJsonMissingValidationErrors 断言响应没有给定键的 JSON 验证错误： 1$response-&gt;assertJsonMissingValidationErrors($keys); asseertJsonStructure 断言响应具有给定的 JSON 结构： 1$response-&gt;assertJsonStructure(array $structure); asseertJsonValidationErrors 断言响应具有给定键的给定 JSON 验证错误： 1$response-&gt;assertJsonValidationErrors($keys); asseertLocation 断言响应在 Location 头部中具有给定的 URI 值： 1$response-&gt;assertLocation($uri); asseertNotFound 断言响应具有未找到状态码： 1$response-&gt;assertNotFound(); asseertOk 断言响应有 200 状态码： 1$response-&gt;assertOk(); asseertPlainCookie 断言响应包含给定的 cookie （未加密）: 1$response-&gt;assertPlainCookie($cookieName, $value = null); asseertRedirect 断言响应会重定向到给定的 URI： 1$response-&gt;assertRedirect($uri); asseertSee 断言给定的字符串包含在响应中： 1$response-&gt;assertSee($value); asseertSeeInOrder 断言响应中有序包含了给定的字符串： 1$response-&gt;assertSeeInOrder(array $values); assertSeeText 断言给定的字符串包含在响应文本中： 1$response-&gt;assertSeeText($value); asseertSeeTextInOrder 断言给定的字符串有序包含在响应文本中： 1$response-&gt;assertSeeTextInOrder(array $values); asseertSessionHas 断言 session 中包含给定的数据： 1$response-&gt;assertSessionHas($key, $value = null); asseertSessionHasAll 断言 session 中有给定值列表： 1$response-&gt;assertSessionHasAll(array $data); asseertSessionHasErrors 断言 session 中包含一个给定字段的错误： 1$response-&gt;assertSessionHasErrors(array $keys, $format = null, $errorBag = 'default'); asseertSessionHasErrorsIn 断言 session 中具有给定的错误： 1$response-&gt;assertSessionHasErrorsIn($errorBag, $keys = [], $format = null); asseertSessionHasNoErrors 断言 session 没有错误： 1$response-&gt;assertSessionHasNoErrors(); asseertSessionDoesntHaveErrors 断言 session 没有给定键错误： 1$response-&gt;assertSessionDoesntHaveErrors($keys = [], $format = null, $errorBag = 'default'); asseertSessionMissing 断言 session 中不包含给定键： 1$response-&gt;assertSessionMissing($key); asseertStatus 断言响应中具有给定的状态码： 1$response-&gt;assertStatus($code); asseertSuccessful 断言响应中有成功的状态码： 1$response-&gt;assertSuccessful(); asseertViewHas 断言响应视图是一段给定的数据： 1$response-&gt;assertViewHas($key, $value = null); asseertViewHasAll 断言响应视图具有给定的数据列表： 1$response-&gt;assertViewHasAll(array $data); asseertViewIs 断言路由返回给定的视图： 1$response-&gt;assertViewIs($value); asseertViewMissing 断言响应视图缺少一段绑定数据： 1$response-&gt;assertViewMissing($key); asseertAuthenticated 断言此用户已被认证。 1$this-&gt;assertAuthenticated($guard = null); asseertGuest 断言此用户未被认证。 1$this-&gt;assertGuest($guard = null); asseertAuthenticatedAs 断言给定的用户被认证。 1$this-&gt;assertAuthenticatedAs($user, $guard = null); asseertCreadentials 断言给定的凭证有效。 1$this-&gt;assertCredentials(array $credentials, $guard = null); asseertInvalidaCredentials 断言给定的凭证无效。 1$this-&gt;assertInvalidCredentials(array $credentials, $guard = null); asseertDatabaseHas 断言数据库表中包含给定的数据。 1$this-&gt;assertDatabaseHas($table, array $data); asseertDatabaseMissing 断言数据库表中不包含给定的数据。 1$this-&gt;assertDatabaseMissing($table, array $data); asseertSoftDeleted 断言数据库中的指定记录已软删除。 1$this-&gt;assertSoftDeleted($table, array $data); 参考 PHPUnit Manual Laravel 测试：入门指南","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"PHPUnit","slug":"PHPUnit","permalink":"http://blog.caoxl.com/tags/PHPUnit/"}]},{"title":"Laravel 中队列的应用 「redis」","slug":"Laravel-Queue-Redis","date":"2019-07-16T01:59:33.000Z","updated":"2019-08-22T06:32:12.000Z","comments":true,"path":"2019/07/16/Laravel-Queue-Redis/","link":"","permalink":"http://blog.caoxl.com/2019/07/16/Laravel-Queue-Redis/","excerpt":"Laravel Horizon Horizon 队列管理工具 (工欲善其事必先利其器)这里直接安装官方走即可: Laravel Horizon 安装失败请看文末的FAQ","text":"Laravel Horizon Horizon 队列管理工具 (工欲善其事必先利其器)这里直接安装官方走即可: Laravel Horizon 安装失败请看文末的FAQ Laravel Queue待续… FAQ laravel/horizon v1.1.0 requires ext-pcntl * -&gt; the requested PHP extension pcntl is missing from your system? 在composer.json中添加以下代码 123456\"config\": &#123; \"platform\": &#123; \"ext-pcntl\": \"7.2\", \"ext-posix\": \"7.2\" &#125;&#125; Call to undefined function Laravel\\Horizon\\Console\\pcntl_async_signals() 1composer require ext-pcntl ext-posix 这个模块没有非Unix平台可用的函数（即非Unix类系统不支持此模块）。(Windows 没戏)https://php.net/manual/zh/pcntl.installation.php 然后执行 composer install --ignore-platform-reqs, 即可继续composer require laravel/horizon 参考 laravel/horizon requires ext-pcntl","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"Queue","slug":"Queue","permalink":"http://blog.caoxl.com/tags/Queue/"}]},{"title":"ElasticSearch 查询","slug":"Laravel-Elasticsearch-Search","date":"2019-07-10T03:47:35.000Z","updated":"2019-08-22T03:35:52.000Z","comments":true,"path":"2019/07/10/Laravel-Elasticsearch-Search/","link":"","permalink":"http://blog.caoxl.com/2019/07/10/Laravel-Elasticsearch-Search/","excerpt":"为了搜索, For Search, 所以这里深入了解一下ES 中的Search","text":"为了搜索, For Search, 所以这里深入了解一下ES 中的Search 查询表达式 DSL 使用查询领域特定语言(Query Domain Specific Language)简称DSL, 需要使用JSON作为主体,请求头查询. query match: 模糊匹配, 类似于SQL中的like, 示例:[&#39;match&#39; =&gt; [&#39;field&#39; =&gt; &#39;keyword&#39;]] match_all: 简单的匹配所有文档, 示例:[&#39;match_all&#39; =&gt; new stdClass()] match_phrase: 对于短语或者段落镜像精确匹配 match_phrase_prefix: match_phrase_prefix与match_phrase是一样的，只是它允许在文本的最后一项中使用前缀匹配 multi_match: 匹配多个字段 bool: 用于表示复合语句,用于组合多个查询语言;将多查询组合成单一查询 must: 多个查询条件的完全匹配, 相当于and must_not: 多个查询条件的相反匹配, 相当于not should: 如果满足这些语句中的任意语句，将增加 _score ，否则无任何影响。它们主要用于修正每个文档的相关性得分 minimum_should_match: 控制需要匹配的 should 语句的数量， 它既可以是一个绝对的数字，又可以是个百分比, 如 minimum_should_match: 2 或者 &quot;minimum_should_match&quot;: &quot;75%&quot; filter: 必须匹配; 但它以不评分、过滤模式来进行. exists: 查找包含某个字段的文档 missing: 查找不包含某个字段的文档 range: 范围匹配;可以使用大于gt、大于等于gte、小于lt、小于等于lte作为查询条件，可用于数字、日期类型、字符串 term: 精确查询;对数值，日期，布尔，not_analyzed确切值字符串 terms: 指定多个匹配值, 如果字段包含其中的任何一个，都会返回文档，类似于SQL中的IN 操作 constant_score: 恒定分数, 将一个不变的常量评分应用于所有匹配的文档 wildcard: 通配符, ? 匹配任意字符, *匹配0或多个字符 fuzzy: 模糊查询 dis_max: 分离 最大化查询(Disjunction Max Query) nested: 用于操作嵌套类型 highlight: 高亮, 匹配的结果会被HTML字符包裹住,需要指定匹配的字段 aggs: 聚合操作, 类似SQL中的Group By sort: 排序 from: 偏移量, 类似于SQL中limit中的offset size: 返回数量, 类似于SQL中limit中的count,可以通过from,size来达到分页的效果 DSL查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 # DSL $params = [ # 文档索引 'index' =&gt; 'index_search', 'type' =&gt; '_doc', # 文档类型 'body' =&gt; [ 'query' =&gt; [ # 匹配查询 'match' =&gt; [ 'username' =&gt; 'caoxl', ], # 匹配所有文档 //'match_all' =&gt; new \\stdClass(), # 对于短语或者段落进行精确匹配，// 'match_phrase' =&gt; [// 'tag' =&gt; 'Laravel,ElasticSearch'// ], # match_phrase_prefix与match_phrase是一样的，只是它允许在文本的最后一项中使用前缀匹配 // slop:让相对词序位置不那么严格, 尽管词语的顺序不正确，查询仍然能匹配// 'match_phrase_prefix' =&gt; [// 'tag' =&gt; [// 'query' =&gt; 'ElasticSearch,Laravel',// 'slop' =&gt; 10// ]// ] # 多个字段上使用相同的值作为查询条件// 'multi_match' =&gt; [// 'query' =&gt; 'kevin',// 'fields' =&gt; ['username', 'nickname']// ], # 与上面效果相同// 'bool' =&gt; [// 'should' =&gt; [// ['term' =&gt; ['username' =&gt; 'kevin']],// ['term' =&gt; ['nickname' =&gt; 'kevin']],// ],// ], # Bool 查询// 'bool' =&gt; [// // 必须匹配, 才会返回文档// 'must' =&gt; [// 'match' =&gt; ['nickname' =&gt; 'kevin'],// ],// // 必须不匹配, 才会返回文档// 'must_not' =&gt; [// 'match' =&gt; ['username' =&gt; 'caoxl'],// ],// // 可能匹配也可能不匹配// 'should' =&gt; [// 'term' =&gt; ['sex' =&gt; '1']// ],// ], # 常量分数, 它将一个不变的常量评分应用于所有匹配的文档 // 查询置于 filter 语句内不进行评分或相关度的计算，所以所有的结果都会返回一个默认评分 1// 'constant_score' =&gt; [// 'filter' =&gt; [// 'term' =&gt; ['username' =&gt; 'caoxl'],// ],// ], # 通配符查询// 'wildcard' =&gt; [// 'username' =&gt; 'caoxl?',// ], # 正则查询// 'regexp' =&gt; [// 'password' =&gt; \"[0-9]&#123;6&#125;\",// ], # 范围查询 gt:大于 gte:大于等于 lt:小于 lte:小于等于// 'range' =&gt; [// 'age' =&gt; [// 'gte' =&gt; 24,// 'lt' =&gt; 30,// ],// 'created_at' =&gt; [// 'gt' =&gt; ['2019-07-09'],// ],// ] # exists 用于查找那些指定字段中是否有值 ， 相当于SQL中的IS NOT NULL// 'bool' =&gt; [// 'filter' =&gt; [// 'exists' =&gt; ['field' =&gt; 'username'],// ],// ], ], # 高亮 'highlight' =&gt; [ \"pre_tags\" =&gt; [\"&lt;font color='red'&gt;\"], \"post_tags\" =&gt; [\"&lt;/font&gt;\"], 'fields' =&gt; [ 'username' =&gt; new \\stdClass() ] ], # 排序，可以指定一个或者多个字段排序,多个字段使用数组 'sort' =&gt; [ 'id' =&gt; ['order' =&gt; 'desc'], '_score' =&gt; ['order' =&gt; 'desc'], ], # 偏移量，类似于SQL中limit中的offset 'from' =&gt; 0, # 返回数量，类似于SQL中limit中的count，可以通过from，size来达到分页的效果 'size' =&gt; 3 ], ]; $res_dsl = $client-&gt;search($params); dd($res_dsl); 返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445array:4 [ \"took\" =&gt; 1 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 1 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; null \"hits\" =&gt; array:1 [ 0 =&gt; array:7 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_1\" \"_score\" =&gt; 0.87546873 \"_source\" =&gt; array:9 [ \"id\" =&gt; 1 \"username\" =&gt; \"caoxl\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] \"highlight\" =&gt; array:1 [ \"username\" =&gt; array:1 [ 0 =&gt; \"&lt;font color='red'&gt;caoxl&lt;/font&gt;\" ] ] \"sort\" =&gt; array:2 [ 0 =&gt; 1 1 =&gt; 0.87546873 ] ] ] ]] 实例化客户端1234$client = ClientBuilder::create() -&gt;setHosts([\"localhost:9200\"]) -&gt;setRetries(0) -&gt;build(); 索引文档1234567891011121314151617181920// 索引一个文档: 写 document 到 ElasticSearch 中，如果不存在，就创建，如果存在，就用新的取代旧的。$index_doc = [ 'index' =&gt; 'index_search', 'type' =&gt; '_doc', 'id' =&gt; 'search_1', 'body' =&gt; [ 'id' =&gt; 1, 'username' =&gt; 'caoxl', 'nickname' =&gt; 'kevin', 'password' =&gt; '123456', 'age' =&gt; 24, 'sex' =&gt; 1, 'tag' =&gt; 'Laravel,ElasticSearch', 'signture' =&gt; '为了搜索, For Search', 'created_at' =&gt; '2019-07-10' ],];$response_index_doc = $client-&gt;index($index_doc);dd($response_index_doc); 返回结果 12345678910111213141516171819202122232425262728293031// 新建array:8 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_4\" \"_version\" =&gt; 1 \"result\" =&gt; \"created\" \"_shards\" =&gt; array:3 [ \"total\" =&gt; 2 \"successful\" =&gt; 1 \"failed\" =&gt; 0 ] \"_seq_no\" =&gt; 3 \"_primary_term\" =&gt; 1]// 更新array:8 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_1\" \"_version\" =&gt; 2 \"result\" =&gt; \"updated\" \"_shards\" =&gt; array:3 [ \"total\" =&gt; 2 \"successful\" =&gt; 1 \"failed\" =&gt; 0 ] \"_seq_no\" =&gt; 4 \"_primary_term\" =&gt; 1] Match 查询 match 查询: match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。 标准搜索1234567891011121314$params = [ 'index' =&gt; 'index_search', 'type' =&gt; '_doc', 'body' =&gt; [ 'query' =&gt; [ 'match' =&gt; [ 'username' =&gt; 'caoxl', ], ] ]];$res_match = $client-&gt;search($params);dd($res_match); 返回结果 123456789101112131415161718192021222324252627282930313233343536array:4 [ \"took\" =&gt; 2 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 1 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 0.87546873 \"hits\" =&gt; array:1 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_1\" \"_score\" =&gt; 0.87546873 \"_source\" =&gt; array:9 [ \"id\" =&gt; 1 \"username\" =&gt; \"caoxl\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] ] ]] 返回结果说明 took - 整个搜索请求花费的毫秒数。 timed_out - 查询超时与否。 一般的，搜索请求不会超时。如果响应速度比完整的结果更重要，你可以定义timeout参数为10或者10ms（10毫秒），或者1s（1秒） _shards total - 参与查询的分片数 successful - 有多少是成功的 skipped - 有多少是跳过的 failed - 有多少的是失败的 hits total - 匹配到的文档总数 value - 匹配到的文档总数 relation - 一般是eq相等 max_score - 所有文档匹配查询中_score的最大值。 hits - 命中的文档详情 _index - 文档索引 _type - 文档类型 _id - 文档id _score - 相关性得分 (默认按照_score降序排列) 模糊搜索1234567891011121314151617$params = [ 'index' =&gt; 'index_search', 'type' =&gt; '_doc', 'body' =&gt; [ 'query' =&gt; [ // 通配符查询 ? 'wildcard' =&gt; [ 'username' =&gt; 'caoxl?' ], ] ]];// match 查询: match查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它。$res_match = $client-&gt;search($params);dd($res_match); 返回结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970array:4 [ \"took\" =&gt; 1 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 3 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 1.0 \"hits\" =&gt; array:3 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_2\" \"_score\" =&gt; 1.0 \"_source\" =&gt; array:9 [ \"id\" =&gt; 2 \"username\" =&gt; \"caoxl2\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] 1 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_3\" \"_score\" =&gt; 1.0 \"_source\" =&gt; array:9 [ \"id\" =&gt; 3 \"username\" =&gt; \"caoxl3\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] 2 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_4\" \"_score\" =&gt; 1.0 \"_source\" =&gt; array:9 [ \"id\" =&gt; 4 \"username\" =&gt; \"caoxl4\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] ] ]] Match all 查询123456789101112$params = [ 'index' =&gt; 'index_search', 'type' =&gt; '_doc', 'body' =&gt; [ 'query' =&gt; [ 'match_all' =&gt; new \\stdClass() ] ],];$res_all = $client-&gt;search($params);dd($res_all); 返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687array:4 [ \"took\" =&gt; 1 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 4 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 1.0 \"hits\" =&gt; array:4 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_2\" \"_score\" =&gt; 1.0 \"_source\" =&gt; array:9 [ \"id\" =&gt; 2 \"username\" =&gt; \"caoxl2\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] 1 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_3\" \"_score\" =&gt; 1.0 \"_source\" =&gt; array:9 [ \"id\" =&gt; 3 \"username\" =&gt; \"caoxl3\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] 2 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_4\" \"_score\" =&gt; 1.0 \"_source\" =&gt; array:9 [ \"id\" =&gt; 4 \"username\" =&gt; \"caoxl4\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] 3 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_1\" \"_score\" =&gt; 1.0 \"_source\" =&gt; array:9 [ \"id\" =&gt; 1 \"username\" =&gt; \"caoxl\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] ] ]] Bool 查询1234567891011121314151617$params = [ 'index' =&gt; 'index_search', 'type' =&gt; '_doc', 'body' =&gt; [ 'query' =&gt; [ 'bool' =&gt; [ 'must' =&gt; [ ['match' =&gt; ['username' =&gt; 'caoxl']], ['match' =&gt; ['sex' =&gt; '1']], ] ] ] ]];$res_bool = $client-&gt;search($params);dd($res_bool); 返回结果 123456789101112131415161718192021222324252627282930313233343536array:4 [ \"took\" =&gt; 29 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 1 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 1.8754687 \"hits\" =&gt; array:1 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_1\" \"_score\" =&gt; 1.8754687 \"_source\" =&gt; array:9 [ \"id\" =&gt; 1 \"username\" =&gt; \"caoxl\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] ] ]] 更复杂的示例12345678910111213141516171819202122232425262728293031323334$params = [ 'index' =&gt; 'index_search', 'type' =&gt; '_doc', 'body' =&gt; [ 'query' =&gt; [ 'bool' =&gt; [ 'must' =&gt; [ // 多字段匹配, 此处匹配username和nickname两个字段 'multi_match' =&gt; [ 'query' =&gt; 'kevin', 'fields' =&gt; ['username', 'nickname'] ] ], 'filter' =&gt; [ 'term' =&gt; ['nickname' =&gt; 'kevin'], ], 'should' =&gt; [ 'match' =&gt; ['nickname' =&gt; 'kevin'] ], ], ], // 根据字段id, 倒序排列结果 'sort' =&gt; [ 'id' =&gt; [ 'order' =&gt; 'desc' ] ], 'from' =&gt; 0, // 从第几条开始, 开始是0 'size' =&gt; 10 // 每次搜索显示的数量 ]];$res_bool = $client-&gt;search($params);dd($res_bool); 返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899array:4 [ \"took\" =&gt; 153 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 4 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; null \"hits\" =&gt; array:4 [ 0 =&gt; array:6 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_4\" \"_score\" =&gt; null \"_source\" =&gt; array:9 [ \"id\" =&gt; 4 \"username\" =&gt; \"caoxl4\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] \"sort\" =&gt; array:1 [ 0 =&gt; 4 ] ] 1 =&gt; array:6 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_3\" \"_score\" =&gt; null \"_source\" =&gt; array:9 [ \"id\" =&gt; 3 \"username\" =&gt; \"caoxl3\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] \"sort\" =&gt; array:1 [ 0 =&gt; 3 ] ] 2 =&gt; array:6 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_2\" \"_score\" =&gt; null \"_source\" =&gt; array:9 [ \"id\" =&gt; 2 \"username\" =&gt; \"caoxl2\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] \"sort\" =&gt; array:1 [ 0 =&gt; 2 ] ] 3 =&gt; array:6 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_1\" \"_score\" =&gt; null \"_source\" =&gt; array:9 [ \"id\" =&gt; 1 \"username\" =&gt; \"caoxl\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] \"sort\" =&gt; array:1 [ 0 =&gt; 1 ] ] ] ]] bool过滤: bool 过滤可以用来合并多个过滤条件查询结果的布尔逻辑，它包含一下操作符： must: 多个查询条件的完全匹配, 相当于and must_not: 多个查询条件的相反匹配, 相当于not should: 至少有一个查询条件匹配, 相当于or 12345678910111213141516171819202122232425$params = [ 'index' =&gt; 'index_search', 'type' =&gt; '_doc', 'body' =&gt; [ 'query' =&gt; [ 'bool' =&gt; [ // 必须匹配, 才会返回文档 'must' =&gt; [ 'match' =&gt; ['nickname' =&gt; 'kevin'], ], // 必须不匹配, 才会返回文档 'must_not' =&gt; [ 'match' =&gt; ['username' =&gt; 'caoxl'], ], // 可能匹配也可能不匹配 'should' =&gt; [ 'term' =&gt; ['sex' =&gt; '1'] ], ], ] ],];$res_bool = $client-&gt;search($params);dd($res_bool); 返回结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970array:4 [ \"took\" =&gt; 1 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 3 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 1.0870113 \"hits\" =&gt; array:3 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_2\" \"_score\" =&gt; 1.0870113 \"_source\" =&gt; array:9 [ \"id\" =&gt; 2 \"username\" =&gt; \"caoxl2\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] 1 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_3\" \"_score\" =&gt; 1.0870113 \"_source\" =&gt; array:9 [ \"id\" =&gt; 3 \"username\" =&gt; \"caoxl3\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] 2 =&gt; array:5 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_4\" \"_score\" =&gt; 1.0870113 \"_source\" =&gt; array:9 [ \"id\" =&gt; 4 \"username\" =&gt; \"caoxl4\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] ] ] ]] Scrolling 查询12345678910111213141516171819202122232425262728293031323334$params = [ 'scroll' =&gt; '30s', 'size' =&gt; 2, 'index' =&gt; 'index_search', 'body' =&gt; [ 'query' =&gt; [ 'match_all' =&gt; new \\stdClass() ], // 根据id倒序排列 'sort' =&gt; [ 'id' =&gt; [ 'order' =&gt; 'desc' ], ] ]];// match_all 查询: 使用match_all 可以查询到所有文档，是没有查询条件下的默认语句。// 执行搜索,返回第一批数据,和一个scroll_id$res_scroll = $client-&gt;search($params);dd($res_scroll);// 将所有数据循环出来while (isset($res_scroll['hits']['hits']) &amp;&amp; count($res_scroll['hits']['hits']) &gt; 0) &#123; $scroll_id = $res_scroll['_scroll_id']; // 执行下一个游标请求 $res_scroll = $client-&gt;scroll([ 'scroll_id' =&gt; $scroll_id, 'scroll' =&gt; '30s' ]); //dd($res_scroll);&#125; 返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960array:5 [ \"_scroll_id\" =&gt; \"DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD8WUnFoQVBUUURUN3lFVWpQVW9FMHhXUQ==\" \"took\" =&gt; 0 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 4 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; null \"hits\" =&gt; array:2 [ 0 =&gt; array:6 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_4\" \"_score\" =&gt; null \"_source\" =&gt; array:9 [ \"id\" =&gt; 4 \"username\" =&gt; \"caoxl4\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] \"sort\" =&gt; array:1 [ 0 =&gt; 4 ] ] 1 =&gt; array:6 [ \"_index\" =&gt; \"index_search\" \"_type\" =&gt; \"_doc\" \"_id\" =&gt; \"search_3\" \"_score\" =&gt; null \"_source\" =&gt; array:9 [ \"id\" =&gt; 3 \"username\" =&gt; \"caoxl3\" \"nickname\" =&gt; \"kevin\" \"password\" =&gt; \"123456\" \"age\" =&gt; 24 \"sex\" =&gt; 1 \"tag\" =&gt; \"Laravel,ElasticSearch\" \"signture\" =&gt; \"为了搜索, For Search\" \"created_at\" =&gt; \"2019-07-10\" ] \"sort\" =&gt; array:1 [ 0 =&gt; 3 ] ] ] ]]","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://blog.caoxl.com/tags/ElasticSearch/"}]},{"title":"基于Laravel使用ElasticSearch","slug":"Laravel-ElasticSearch","date":"2019-07-09T08:54:33.000Z","updated":"2019-09-02T07:28:46.000Z","comments":true,"path":"2019/07/09/Laravel-ElasticSearch/","link":"","permalink":"http://blog.caoxl.com/2019/07/09/Laravel-ElasticSearch/","excerpt":"废话不多说,直接上代码 环境 PHP 7.2+ MySQL 5.7 ElasticSearch 6.7.2 Laravel 5.8","text":"废话不多说,直接上代码 环境 PHP 7.2+ MySQL 5.7 ElasticSearch 6.7.2 Laravel 5.8 Commands App\\Console\\Commands CreateIndex123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;use App\\Services\\Common\\ElasticSearchService;/** * Class CreateIndex * @package App\\Console\\Commands */class CreateIndex extends Command&#123; protected $es; /** * The name and signature of the console command. * * @var string */ protected $signature = 'es:create &#123;index_name : The name of index which will be created&#125;'; /** * The console command description. * * @var string */ protected $description = 'Create an ElasticSearch index'; /** * CreateIndex constructor. * @param ElasticSearchService $elastic */ public function __construct(ElasticSearchService $elastic) &#123; parent::__construct(); $this-&gt;es = $elastic; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; $index_name = $this-&gt;argument('index_name'); $this-&gt;info(\"trying to create index $index_name\"); $ret = $this-&gt;es-&gt;createIndex($index_name); if ($ret) &#123; $this-&gt;info('success'); &#125; else &#123; $this-&gt;error('failed'); &#125; &#125;&#125; 使用123$ php artisan es:create test_createtrying to create index test_createsuccess UpdateIndex12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;use App\\Services\\Common\\ElasticSearchService;class UpdateIndex extends Command&#123; protected $es; /** * The name and signature of the console command. * * @var string */ protected $signature = \"es:update &#123;--index=_ : The names of index to be updated&#125; &#123;--type=_ : The type of the index&#125; &#123;--all : Update all indices&#125;\"; /** * The console command description. * * @var string */ protected $description = 'Update the ElasticSearch index'; /** * UpdateIndex constructor. * @param ElasticSearchService $elastic */ public function __construct(ElasticSearchService $elastic) &#123; parent::__construct(); $this-&gt;es = $elastic; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; $index_name = $this-&gt;option('index'); $type_name = $this-&gt;option('type'); $update_all = $this-&gt;option('all'); if ($update_all) &#123; $this-&gt;info('try to update all indices'); $ret = $this-&gt;es-&gt;updateAllIndex(); if ($ret === true) &#123; $this-&gt;info('successfully updated'); &#125; else &#123; foreach ($ret as $item) &#123; $this-&gt;error(\"fail to update index $&#123;item['index']&#125;:$&#123;item['type']&#125;\"); &#125; &#125; &#125; else &#123; if (empty($index_name) || empty($type_name) || '_' == $index_name || '_' == $type_name ) &#123; $this-&gt;error('run with --all to update all indices, or run with --index_name and --type_name to update one index'); &#125; else &#123; $this-&gt;info(\"try to update ElasticSearch index $index_name:$type_name\"); $ret = $this-&gt;es-&gt;updateIndex($index_name, $type_name); if (!$ret) &#123; $this-&gt;error(\"fail to update ElasticSearch index $index_name:$type_name\"); &#125; else &#123; $this-&gt;info(\"$index_name:$type_name successful updated\"); &#125; &#125; &#125; &#125;&#125; 使用123$ php artisan es:update --alltry to update all indicessuccessfully updated ClearIndex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpnamespace App\\Console\\Commands;use App\\Services\\Common\\ElasticSearchService;use Illuminate\\Console\\Command;class ClearIndex extends Command&#123; protected $es; /** * The name and signature of the console command. * * @var string */ protected $signature = 'es:clear &#123;index_name : The name of index to be cleared&#125; &#123;--yes : Confirm to clear the index&#125;'; /** * The console command description. * * @var string */ protected $description = 'clear an ElasticSearch index'; /** * ClearIndex constructor. * @param ElasticSearchService $elastic */ public function __construct(ElasticSearchService $elastic) &#123; parent::__construct(); $this-&gt;es = $elastic; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; $index_name = $this-&gt;argument('index_name'); $yes = $this-&gt;option('yes'); if (!$yes) &#123; $yes = $this-&gt;confirm(\"are you sure to clear the index $index_name\"); &#125; if ($yes) &#123; $ret = $this-&gt;es-&gt;clearIndex($index_name); if ($ret) &#123; $this-&gt;info('success'); &#125; else &#123; $this-&gt;error('failed'); &#125; &#125; else &#123; $this-&gt;warn('aborted'); &#125; &#125;&#125; 使用12$ php artisan es:clear test_index --yessuccess DropIndex12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;use App\\Services\\Common\\ElasticSearchService;class DropIndex extends Command&#123; protected $es; /** * The name and signature of the console command. * * @var string */ protected $signature = \"es:drop &#123;index_name : The name of index to be dropped&#125; &#123;--yes : Confirm the drop&#125;\"; /** * The console command description. * * @var string */ protected $description = 'Drop/Delete an ElasticSearch index'; /** * DropIndex constructor. * @param ElasticSearchService $elastic */ public function __construct(ElasticSearchService $elastic) &#123; parent::__construct(); $this-&gt;es = $elastic; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; $index_name = $this-&gt;argument('index_name'); $yes = $this-&gt;option('yes'); if (!$yes) &#123; $yes = $this-&gt;confirm(\"Are you sure to drop the index $index_name ?\"); &#125; if ($yes) &#123; $ret = $this-&gt;es-&gt;dropIndex($index_name); if ($ret) &#123; $this-&gt;info('success'); &#125; else &#123; $this-&gt;error('failed'); &#125; &#125; else &#123; $this-&gt;warn('aborted'); &#125; &#125;&#125; 使用123456$ php artisan es:drop test_create Are you sure to drop the index test_create ? (yes/no) [no]: &gt; yessuccess ListIndex12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;use App\\Services\\Common\\ElasticSearchService;class ListIndex extends Command&#123; protected $es; /** * The name and signature of the console command. * * @var string */ protected $signature = 'es:list'; /** * The console command description. * * @var string */ protected $description = 'List all indices'; /** * ListIndex constructor. * @param ElasticSearchService $elastic */ public function __construct(ElasticSearchService $elastic) &#123; parent::__construct(); $this-&gt;es = $elastic; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; $ret = $this-&gt;es-&gt;listIndex(); $count = 0; print_r('#:&lt;index_name&gt;, &lt;last updated time&gt;' . PHP_EOL); if (isset($ret['hits'])) &#123; foreach ($ret['hits'] as $hit) &#123; $count++; $updated_time = strftime('%Y-%m-%d %H:%M:%S', $hit['_source']['last_updated']); print_r(\"$count : &#123;$hit['_source']['index_name']&#125;, $updated_time\\n\"); &#125; &#125; &#125;&#125; 使用1234$ php artisan es:list#:&lt;index_name&gt;, &lt;last updated time&gt;1 : help_center, 1970-01-01 08:00:002 : test_index_1, 1970-01-01 08:00:00 QueryIndex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace App\\Console\\Commands;use App\\Services\\Common\\ElasticSearchService;use Illuminate\\Console\\Command;class QueryIndex extends Command&#123; protected $es; /** * The name and signature of the console command. * * @var string */ protected $signature = \"es:query &#123;--index= : The index to query in&#125; &#123;--type= : The type of index to query&#125; &#123;--page=1 : The page of results&#125; &#123;query : The query to execute&#125;\"; /** * The console command description. * * @var string */ protected $description = 'Query something of the specified index'; /** * QueryIndex constructor. * @param ElasticSearchService $elastic */ public function __construct(ElasticSearchService $elastic) &#123; parent::__construct(); $this-&gt;es = $elastic; &#125; /** * Execute the console command. * * @return mixed */ public function handle() &#123; $index_name = $this-&gt;option('index'); $type_name = $this-&gt;option('type'); $page_no = intval($this-&gt;option('page')); $query = $this-&gt;argument('query'); $ret = $this-&gt;es-&gt;queryIndex($index_name, $type_name, $query, $page_no); print_r($ret); &#125;&#125; 使用123456789$ php artisan es:query --index=game_name --type=text title=聚宝盆Array( [total] =&gt; 0 [hits] =&gt; Array ( )) Service App\\Services\\Common\\ElasticSearchService 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764 &lt;?php namespace App\\Services\\Common; use Elasticsearch\\ClientBuilder; use App\\Concerns\\Singleton; use App\\Support\\LogTool; use Illuminate\\Support\\Facades\\DB; class ElasticSearchService &#123; use Singleton; const BGC_FUN_META = 'bgc_fun_meta'; const SEARCH_HOT_WORD = 'bgc_fun_hot_word'; const DEFAULT_PAGE_SIZE = 10; const DEFAULT_BULK_SIZE = 10000; protected $config; protected $client; protected static $internal_indices = [ self::BGC_FUN_META, ]; /** * ElasticSearchService constructor. * @param array|null $config */ public function __construct(array $config = null) &#123; // 获取ES主机信息 if (is_null($config)) &#123; $this-&gt;config = config('search-engine.elastic'); &#125; else &#123; $this-&gt;config = $config; &#125; // 构建ES客户端对象 $this-&gt;client = ClientBuilder::create() -&gt;setHosts($this-&gt;config['hosts']) -&gt;setRetries(3) -&gt;build(); &#125; /** * 创建索引 * @param string $index_name * @return bool */ public function createIndex(string $index_name) &#123; // 创建ES节点 $nodes = $this-&gt;client-&gt;nodes(); // 节点信息 $nodes_stat = $nodes-&gt;stats(); // 判断ES节点是否创建成功 if (!isset($nodes_stat['_nodes']) || ($num_nodes = $nodes_stat['_nodes']['successful']) &lt; 1) &#123; LogTool::error(\"try to create index $index_name without valid nodes.\"); return false; &#125; // 索引文档 $param = [ // 索引名称 'index' =&gt; $index_name, 'body' =&gt; [ // 包含有关索引（分片数量等）以及分析器的配置 'settings' =&gt; [ 'number_of_replicas' =&gt; ($num_nodes &gt; 1 ? 1 : 0), // 包含标记器，过滤器，字符过滤器和分析器 'analysis' =&gt; [ // 动态模板，应用于没有显式映射的所有字段 'default' =&gt; [ //'type' =&gt; 'ik_max_word', // 中文分词 'type' =&gt; 'standard', ], ], ], ], ]; $config = config(\"search-engine.elastic.db_mapping.&#123;$index_name&#125;\"); if (isset($config['mappings'])) &#123; $param['body']['mappings'] = $config['mappings']; &#125; // 创建一个索引 $resp = $this-&gt;client-&gt;indices()-&gt;create($param); // 判断索引创建是否确认 $success = $this-&gt;is_acknowledged($resp); if (!$success) &#123; LogTool::error(\"fail to create index $index_name\"); &#125; if (!in_array($index_name, static::$internal_indices)) &#123; // 更新索引文档 $success = $this-&gt;updateIndexDoc(static::BGC_FUN_META, '_doc', $index_name, [ 'index_name' =&gt; $index_name, 'last_updated' =&gt; 0, ]); &#125; return $success; &#125; /** * 删除索引 * @param string $index_name * @return bool */ public function dropIndex(string $index_name) &#123; $param = [ 'index' =&gt; $index_name, ]; $resp = $this-&gt;client-&gt;indices()-&gt;delete($param); $success = $this-&gt;is_acknowledged($resp); if (!$success) &#123; LogTool::error(\"fail to drop index $index_name\"); &#125; elseif (strcmp($index_name, static::BGC_FUN_META) != 0) &#123; LogTool::error(\"index $index_name dropped\"); $this-&gt;dropIndexDoc(static::BGC_FUN_META, '_doc', $index_name); &#125; return $success; &#125; /** * 清除索引并删除索引中所有条目 * @param string $index_name * @return bool */ public function clearIndex(string $index_name) &#123; $param = [ 'index' =&gt; $index_name, 'body' =&gt; [ 'query' =&gt; [ 'match_all' =&gt; new \\stdClass(), ], ], ]; $resp = $this-&gt;client-&gt;deleteByQuery($param); $success = isset($resp['deleted']); if (!$success) &#123; LogTool::error(\"fail to clear index $index_name\"); &#125; else &#123; LogTool::info(\"index $index_name cleared.\"); &#125; return $success; &#125; /** * 根据数据库记录更新索引 * @param string $index_name * @param string $type * @return bool */ public function updateIndex(string $index_name, string $type = 'text') &#123; $config = config(\"search-engine.elastic.db_mapping\"); if (is_null($config)) &#123; LogTool::warning(\"try to update unregistered index $index_name, please make sure the index is configured.\"); return false; &#125; // 获取数据库映射 list(, $sql) = $this-&gt;get_db_mapping($index_name); // 没有数据库映射,返回OK if (null === $sql) return true; // 获取索引的更新时间 $update_time = $this-&gt;update_time4index($index_name); if (false === $update_time) &#123; LogTool::info(\"try to update index $index_name, it is up to date.\"); return true; &#125; $page_no = 1; $page_size = static::DEFAULT_BULK_SIZE; $binding = [ 'count' =&gt; $page_size ]; $ret = true; $this-&gt;createIndex($index_name); do &#123; $binding['offset'] = ($page_no - 1) * $page_size; $data = DB::select($sql, $binding); if (count($data) &gt; 0) &#123; $ret = $this-&gt;bulk_update_index($index_name, $type, $data); &#125; $page_no++; &#125; while (count($data) &gt; 0 &amp;&amp; $ret); if ($ret) &#123; LogTool::info(\"index $index_name is updated.\"); $ret = $this-&gt;updateIndexDoc(static::BGC_FUN_META, '_doc', $index_name, [ 'index_name' =&gt; $index_name, 'last_updated' =&gt; $update_time, ]); &#125; else &#123; LogTool::error(\"fail to update $index_name\"); &#125; return $ret; &#125; /** * 更新所有索引 * @return array|bool */ public function updateAllIndex() &#123; $index_failed = []; $config = config(\"search-engine.elastic.db_mapping\"); foreach ($config as $index_name =&gt; $index_config) &#123; if (!isset($index_config['mappings'])) &#123; $mappings = ['_doc' =&gt; 0]; &#125; else &#123; $mappings = $index_config['mappings']; &#125; foreach ($mappings as $type_name =&gt; $type_config) &#123; if (!$this-&gt;updateIndex($index_name, $type_name)) &#123; $index_failed[] = ['index' =&gt; $index_name, 'type' =&gt; $type_name]; &#125; &#125; &#125; return count($index_failed) &gt; 0 ? $index_failed : true; &#125; /** * 查询索引中的内容 * @param string $index_name * @param string $type * @param string $query * @param int $page * @param int $page_size * @param bool $exact * @param bool $collect_source * @param callable|null $cb * @return array|mixed */ public function queryIndex( string $index_name, string $type, string $query, int $page = 1, int $page_size = self::DEFAULT_PAGE_SIZE, bool $exact = false, bool $collect_source = false, callable $cb = null ) &#123; if (strlen($query) &gt; 0) &#123; [$query_param, $query_words] = $this-&gt;parse_query($query, $exact); &#125; else &#123; [$query_param, $query_words] = [['match_all' =&gt; new \\stdClass()], ['']]; &#125; $query_body = ['query' =&gt; $query_param]; $config = config(\"search-query.&#123;$index_name&#125;\"); if (null !== $config) &#123; $query_body = array_merge($query_body, $config['body']); &#125; return $this-&gt;queryIndexWithClause( $index_name, $type, $query_body, $query_words, $page, $page_size, $collect_source, $cb ); &#125; /** * 列出所有指数 * @return mixed */ public function listIndex() &#123; $param = [ 'index' =&gt; static::BGC_FUN_META, 'type' =&gt; '_doc', 'from' =&gt; 0, 'size' =&gt; 100, 'body' =&gt; [], ]; $resp = $this-&gt;client-&gt;search($param); list($total, $hits) = $this-&gt;get_hits($resp); $ret = $this-&gt;search_result($total, $hits, $resp); return $ret; &#125; /** * 使用提供的内容更新索引/文档 * @param string $index_name * @param string $type * @param $id * @param array $content * @return mixed */ public function updateIndexDoc(string $index_name, string $type, $id, array $content) &#123; $param = [ 'index' =&gt; $index_name, 'type' =&gt; $type, 'id' =&gt; $id, 'body' =&gt; $content, ]; $resp = $this-&gt;client-&gt;index($param); $success = $this-&gt;shards_successful($resp); return $success; &#125; /** * 根据索引删除文档 * @param string $index_name * @param string $type * @param $id * @return bool */ public function dropIndexDoc(string $index_name, string $type, $id) &#123; $param = [ 'index' =&gt; $index_name, 'type' =&gt; $type, 'id' =&gt; $id, ]; $resp = $this-&gt;client-&gt;delete($param); $success = $this-&gt;shards_successful($resp); return $success; &#125; /** * 检查请求是否得到确认 * @param array $resp * @return bool */ protected function is_acknowledged(array &amp;$resp) &#123; return (isset($resp['acknowledged']) &amp;&amp; $resp['acknowledged']); &#125; /** * 检查插入/更新请求是否被接受 * @param array $resp * @return bool */ protected function shards_successful(array &amp;$resp) &#123; return (isset($resp['_shards']) &amp;&amp; $resp['_shards']['successful'] &gt; 0); &#125; /** * 获取提供的索引的数据库映射 * @param string $index_name * @return array */ protected function get_db_mapping(string $index_name) &#123; $config = config(\"search-engine.elastic.db_mapping.&#123;$index_name&#125;\"); if (is_null($config)) return [null, null]; if (!isset($config['db_table']) || !isset($config['db_sql'])) return [null, null]; $table_name = $config['db_table']; $sql = $config['db_sql']; $table_name = preg_replace('/\\s/', '', $table_name); return array($table_name, $sql); &#125; /** * 获取索引的更新时间 * @param string $index_name * @return bool|int */ protected function update_time4index(string $index_name) &#123; list($table_name) = $this-&gt;get_db_mapping($index_name); $db_update_name = intval($this-&gt;get_db_last_update_time($table_name)); $search_ret = $this-&gt;searchSimpleMatch(static::BGC_FUN_META, '_doc', 'index_name', $index_name); if (0 == count($search_ret['hits'])) &#123; LogTool::warning(\"try to check should_update_index of $index_name, no meta hits.\"); return false; &#125; $se_update_time = $search_ret['hits'][0]['_source']['last_updated']; if (0 === $se_update_time) return 0; return ($se_update_time &lt; $db_update_name ? $db_update_name : false); &#125; /** * 获取表的最后更新时间 * @param string $table_name * @return int|null */ protected function get_db_last_update_time(string $table_name) &#123; $db_default = config('database.default'); $db_name = config(\"database.connections.&#123;$db_default&#125;.database\"); $conditions = [ ['table_schema', '=', $db_name], ['table_name', '=', $table_name], ]; $data = DB::table('information_schema.tables') -&gt;where($conditions) -&gt;selectSub('UNIX_TIMESTAMP(update_time)', 'update_time') -&gt;get(); $ret = (isset($data[0]-&gt;update_time) ? intval($data[0]-&gt;update_time) : null); return $ret; &#125; /** * 检查搜索结果的命中总和和当前命中 * @param array $resp * @return array */ protected function get_hits(array &amp;$resp) &#123; // Laravel: $resp['hits']['total']['value'] |BUT| Lumen:$resp['hits']['total'] $total = isset($resp['hits']['total']) ? $resp['hits']['total']['value'] : 0; if (isset($resp['hits']['hits']) &amp;&amp; ($hit_count = count($resp['hits']['hits'])) &gt; 0) &#123; return array($total, $hit_count); &#125; return array($total, 0); &#125; /** * 返回搜索结果 * @param int $total * @param int $hits * @param array $resp * @return mixed */ protected function search_result(int $total, int $hits, array &amp;$resp) &#123; if ($hits &gt; 0) &#123; $ret = [ 'total' =&gt; $total, 'hits' =&gt; $resp['hits']['hits'], ]; &#125; else &#123; $ret = [ 'total' =&gt; $total, 'hits' =&gt; [], ]; &#125; return $ret; &#125; /** * 使用数据库的数据批量插入/更新索引 * @param string $index_name * @param string $type * @param iterable $data * @return bool */ protected function bulk_update_index(string $index_name, string $type, iterable &amp;$data) &#123; $param = []; foreach ($data as $datum) &#123; $index = [ '_index' =&gt; $index_name, '_type' =&gt; $type, ]; if (isset($datum-&gt;id)) &#123; $index['_id'] = $datum-&gt;id; &#125; $param['body'][] = [ 'index' =&gt; $index, ]; $d = (array)($datum); $param['body'][] = $d; &#125; $resp = $this-&gt;client-&gt;bulk($param); $success = $this-&gt;bulk_succeed($resp); return $success; &#125; /** * 检查批量插入是否成功 * @param array $resp * @return bool */ protected function bulk_succeed(array &amp;$resp) &#123; return (isset($resp['errors']) &amp;&amp; !$resp['errors']); &#125; /** * 解析查询字符串,返回ElasticSearch查询子句 * @param string $query * @param bool $exact * @return array */ protected function parse_query(string $query, bool $exact = false) &#123; // term:精准查询 match:模糊匹配 $method = $exact ? 'term' : 'match'; [$field, $value] = explode('=', $query); $param = [ $method =&gt; [ trim($field) =&gt; trim($value), ] ]; $words = [trim($value)]; return [$param, $words]; &#125; /** * 简单搜索具有精准匹配的字段 * @param string $index_name * @param string $type * @param string $field * @param string $needle * @param bool $exact * @return mixed */ public function searchSimpleMatch( string $index_name, string $type, string $field, string $needle, bool $exact = false ) &#123; $method = $exact ? 'term' : 'match'; $param = [ 'index' =&gt; $index_name, 'type' =&gt; $type, 'body' =&gt; [ 'query' =&gt; [ $method =&gt; [ $field =&gt; $needle, ], ], ], ]; $resp = $this-&gt;client-&gt;search($param); list($total, $hits) = $this-&gt;get_hits($resp); $ret = $this-&gt;search_result($total, $hits, $resp); return $ret; &#125; /** * 查询索引 * @param string $index_name * @param string $type * @param array $query_body * @param array $search_words * @param int $page * @param int $page_size * @param bool $collect_source * @param callable|null $cb * @return array|mixed */ public function queryIndexWithClause( string $index_name, string $type, array $query_body, array $search_words, int $page, int $page_size = self::DEFAULT_PAGE_SIZE, bool $collect_source = false, callable $cb = null ) &#123; if ($page &lt; 1) $page = 1; $param = [ 'index' =&gt; $index_name, 'type' =&gt; $type, 'body' =&gt; $query_body, 'from' =&gt; ($page - 1) * $page_size, 'size' =&gt; $page_size, ]; $resp = $this-&gt;client-&gt;search($param); list($total, $hits) = $this-&gt;get_hits($resp); $ret = $this-&gt;search_result($total, $hits, $resp); if (1 === $resp &amp;&amp; !in_array($index_name, [static::BGC_FUN_META, static::SEARCH_HOT_WORD]) &amp;&amp; $total &gt; 0 ) &#123; foreach ($search_words as $word) &#123; if (!empty($word)) &#123; $this-&gt;updateHotWord($index_name, $word); &#125; &#125; &#125; if ($collect_source) &#123; $ret = $this-&gt;collectSource($ret); &#125; if (is_callable($cb)) &#123; $ret = $cb($ret); &#125; return $ret; &#125; /** * 使用指定的模式查询索引 * @param int $pattern_no * @param string $needle * @param int $page * @param int $page_size * @param bool $collect_source * @param callable|null $cb * @return array|mixed|null */ public function queryWithPattern( int $pattern_no, string $needle, int $page, int $page_size = self::DEFAULT_PAGE_SIZE, bool $collect_source = false, callable $cb = null ) &#123; $config = config(\"search-query.&#123;$pattern_no&#125;\"); if (null === $config) &#123; return null; &#125; $config_txt = json_encode($config); $config_txt = str_replace('\"?\"', '\"' . $needle . '\"', $config_txt); $config = json_decode($config_txt, true); $type = $config['type'] ?? 'text'; $data = $this-&gt;queryIndexWithClause( $config['index'], $type, $config['body'], [$needle], $page, $page_size, $collect_source ); if (is_callable($cb)) &#123; $data = $cb($data); &#125; return $data; &#125; /** * 更新热词列表 * @param string $index_name * @param string $word */ public function updateHotWord(string $index_name, string $word) &#123; $entry = null; $id = \"$index_name:$word\"; try &#123; if (null === $entry) &#123; $this-&gt;updateIndexDoc(static::SEARCH_HOT_WORD, '_doc', $id, [ 'count' =&gt; 1, 'word' =&gt; $word, 'index_name' =&gt; $index_name, 'last_update' =&gt; time(), ]); &#125; else &#123; $this-&gt;client-&gt;update([ 'index' =&gt; static::SEARCH_HOT_WORD, 'type' =&gt; '_doc', 'id' =&gt; $id, 'body' =&gt; [ 'script' =&gt; [ 'lang' =&gt; 'painless', 'inline' =&gt; 'ctx._source.count = ctx._source.count + 1', ], 'last_update' =&gt; time(), ], ]); &#125; &#125; catch (\\Exception $e) &#123; LogTool::warning(\"fail to update hot word for $word\"); &#125; &#125; /** * 移除热词 * @param int $before * @return mixed */ public function removeOldHotWord(int $before) &#123; $timestamp = $before; $resp = $this-&gt;client-&gt;deleteByQuery([ 'index' =&gt; static::SEARCH_HOT_WORD, 'type' =&gt; '_doc', 'body' =&gt; [ 'query' =&gt; [ 'range' =&gt; [ 'last_update' =&gt; [ 'lt' =&gt; $timestamp, ], ], ], ], ]); return $this-&gt;count_deleted($resp); &#125; /** * 返回已删除数量 * @param array $resp * @return bool */ protected function count_deleted(array &amp;$resp) &#123; if (!isset($resp['deleted'])) return false; return $resp['deleted']; &#125; /** * 从搜索结果中收集所有源数据 * @param array $result * @return array */ public static function collectSource(array $result) &#123; $ret = []; $highlight = []; $hits = isset($result['hits']) ? $result['hits'] : $result; $count = 0; foreach ($hits as $hit) &#123; if (isset($hit['_source'])) &#123; $ret[$count] = $hit['_source']; if (isset($hit['highlight'])) &#123; $h = []; foreach ($hit['highlight'] as $key =&gt; $value) &#123; $h[$key] = str_replace('&lt;/em&gt;&lt;em&gt;', '', $value[0]); &#125; $highlight[$count] = $h; &#125; $count++; &#125; &#125; foreach ($ret as $key =&gt; $value) &#123; if (isset($highlight[$key])) &#123; $ret[$key] = array_merge($ret[$key], $highlight[$key]); &#125; &#125; return $ret; &#125; &#125;`","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://blog.caoxl.com/tags/ElasticSearch/"}]},{"title":"Elasticsearch 使用记录","slug":"Elasticsearch-Go-MySQL-IK-Kibana","date":"2019-07-03T07:17:40.000Z","updated":"2019-08-22T03:35:23.000Z","comments":true,"path":"2019/07/03/Elasticsearch-Go-MySQL-IK-Kibana/","link":"","permalink":"http://blog.caoxl.com/2019/07/03/Elasticsearch-Go-MySQL-IK-Kibana/","excerpt":"全文搜索分析引擎 Elasticsearch Elasticsearch 是一个分布式的搜索和分析引擎，可以用于全文检索、结构化检索和分析，并能将这三者结合起来。","text":"全文搜索分析引擎 Elasticsearch Elasticsearch 是一个分布式的搜索和分析引擎，可以用于全文检索、结构化检索和分析，并能将这三者结合起来。 安装环境 安装/使用ElasticSearch https://www.elastic.co/cn/downloads/elasticsearch 安装/使用Kibana https://www.elastic.co/cn/downloads/kibanaKibana: 可视化管理ElasticSearch工具 安装/使用IK中文分词 https://github.com/medcl/elasticsearch-analysis-ik 安装Go-MySQL-ElasticSearch https://github.com/siddontang/go-mysql-elasticsearch 快速上手安装客户端1composer \"elasticsearch/elasticsearch:^6.7\" # 这里以V6.7.1 实例化客户端1234$client = ClientBuilder::create() -&gt;setHosts([\"localhost:9200\"]) -&gt;setRetries(0) -&gt;build(); 索引一个文档 索引一个文档: 写 document 到 ElasticSearch 中，如果不存在，就创建，如果存在，就用新的取代旧的。 12345678910111213$params = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'id' =&gt; 'test_id_1', 'body' =&gt; [ 'testField' =&gt; 'abc', 'testField2' =&gt; 'caoxl', 'testField3' =&gt; 'caoxl_123' ],];$response = $client-&gt;index($params);dd($response); 返回结果 12345678910111213141516171819202122232425262728293031// 新增array:8 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_version\" =&gt; 1 \"result\" =&gt; \"created\" \"_shards\" =&gt; array:3 [ \"total\" =&gt; 2 \"successful\" =&gt; 1 \"failed\" =&gt; 0 ] \"_seq_no\" =&gt; 0 \"_primary_term\" =&gt; 1]// 更新array:8 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_version\" =&gt; 2 \"result\" =&gt; \"updated\" \"_shards\" =&gt; array:3 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"failed\" =&gt; 0 ] \"_seq_no\" =&gt; 1 \"_primary_term\" =&gt; 6] 获取一个文档 现在获取刚才索引的文档: 12345678$_params = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'id' =&gt; 'test_id_1',];$_response = $client-&gt;get($_params);dd($_response); 返回结果 1234567891011121314array:8 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_version\" =&gt; 2 \"_seq_no\" =&gt; 1 \"_primary_term\" =&gt; 6 \"found\" =&gt; true \"_source\" =&gt; array:3 [ \"testField\" =&gt; \"abc\" \"testField2\" =&gt; \"caoxl\" \"testField3\" =&gt; \"caoxl_123\" ]] 搜索一个文档1234567891011121314$_params_1 = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'body' =&gt; [ 'query' =&gt; [ 'match' =&gt; [ 'testField' =&gt; 'abc' ] ] ],];$_response_1 = $client-&gt;search($_params_1);dd($_response_1); 返回结果 123456789101112131415161718192021222324252627282930array:4 [ \"took\" =&gt; 25 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 2 \"successful\" =&gt; 2 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 1 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 0.2876821 \"hits\" =&gt; array:1 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_score\" =&gt; 0.2876821 \"_source\" =&gt; array:3 [ \"testField\" =&gt; \"abc\" \"testField2\" =&gt; \"caoxl\" \"testField3\" =&gt; \"caoxl_123\" ] ] ] ]] 参数说明 match_all - 表示取出所有documents，在与filter结合使用时，会经常使用match_all。 match - 一般在全文检索时使用，首先利用analyzer 对具体查询字符串进行分析，然后进行查询； term - 用于精确查找，可用于数值、date、boolean值或not_analyzed string，当使用term时，不会对查询字符串进行分析，进行的是精确查找。 terms - terms 和 term 类似，但是，terms 里可以指定多个值，只要doc满足terms 里的任意值，就是满足查询条件的。与term 相同，terms 也是用于精确查找。 range - 类比数据库查找的范围查找 exists - 用于查找字段含有一个或多个值的document missing - 用于查找某字段不存在值的document，可类比关系数据库里的 is not null (exists) 和 is null (missing). bool - ElasticSearch 使用bool 子句来将各种子查询关联起来，组成布尔表达式，bool 子句可以随意组合、嵌套。 删除一个文档 删除document。ElasticSearch 会标记删除document，然后，在Lucene 底层进行merge时，会删除标记删除的document。 12345678$_params_2 = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'id' =&gt; 'test_id_1'];$_response_2 = $client-&gt;delete($_params_2);dd($_response_2); 返回结果 1234567891011121314array:8 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_version\" =&gt; 3 \"result\" =&gt; \"deleted\" \"_shards\" =&gt; array:3 [ \"total\" =&gt; 1 \"successful\" =&gt; 1 \"failed\" =&gt; 0 ] \"_seq_no\" =&gt; 2 \"_primary_term\" =&gt; 6] 删除索引1234567// 删除索引$delete_index = [ 'index' =&gt; 'test_index_1'];$response_delete = $client-&gt;indices()-&gt;delete($delete_index);dd($response_delete); 返回结果 123array:1 [ \"acknowledged\" =&gt; true] 创建索引12345678910111213$create_index = [ 'index' =&gt; 'test_index_1', 'body' =&gt; [ 'settings' =&gt; [ 'number_of_shards' =&gt; 2, 'number_of_replicas' =&gt; 0 ] ],];// 写 document 到 ElasticSearch 中，与 index 不同的是，如果存在，就抛出异常DocumentAlreadyExistException。$_response_create = $client-&gt;indices()-&gt;create($create_index);dd($_response_create); 返回结果 12345array:3 [ \"acknowledged\" =&gt; true \"shards_acknowledged\" =&gt; true \"index\" =&gt; \"test_index_1\"] 管理索引设置API123456789101112$set_api = [ 'index' =&gt; 'test_index_1', 'body' =&gt; [ 'settings' =&gt; [ 'number_of_replicas' =&gt; 0, 'refresh_interval' =&gt; -1, ], ],];$response_api = $client-&gt;indices()-&gt;putSettings($set_api);dd($response_api); 返回结果 123array:1 [ \"acknowledged\" =&gt; true] 获取设置API123456789// 获取一个索引的配置信息$get_api = ['index' =&gt; 'test_index_1'];// 获取多个索引的配置信息$get_api_2 = [ 'index' =&gt; ['test_index_1', 'index_help']];$response_api = $client-&gt;indices()-&gt;getSettings($get_api_2);dd($response_api); 返回结果 12345678910111213141516171819202122232425262728293031array:2 [ \"index_help\" =&gt; array:1 [ \"settings\" =&gt; array:1 [ \"index\" =&gt; array:6 [ \"creation_date\" =&gt; \"1562135548539\" \"number_of_shards\" =&gt; \"1\" \"number_of_replicas\" =&gt; \"1\" \"uuid\" =&gt; \"eZ_xGOcOTCmqvozVLMUNDA\" \"version\" =&gt; array:1 [ \"created\" =&gt; \"7010199\" ] \"provided_name\" =&gt; \"index_help\" ] ] ] \"test_index_1\" =&gt; array:1 [ \"settings\" =&gt; array:1 [ \"index\" =&gt; array:7 [ \"refresh_interval\" =&gt; \"-1\" \"number_of_shards\" =&gt; \"2\" \"provided_name\" =&gt; \"test_index_1\" \"creation_date\" =&gt; \"1562643744343\" \"number_of_replicas\" =&gt; \"0\" \"uuid\" =&gt; \"HUyT8pFISH6n1yf9cSgbrQ\" \"version\" =&gt; array:1 [ \"created\" =&gt; \"7010199\" ] ] ] ]] 映射API12345678910111213141516171819202122232425262728293031// 设置索引和类型$mapping_params = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'body' =&gt; [ 'test_type_1' =&gt; [ '_source' =&gt; [ 'enabled' =&gt; true ], 'properties' =&gt; [ 'testField' =&gt; [ 'type' =&gt; 'text', //'analyzer' =&gt; 'standard' ], 'testField2' =&gt; [ 'type' =&gt; 'text' ], 'testField3' =&gt; [ 'type' =&gt; 'text' ] ] ] ], 'custom' =&gt; [ 'include_type_name' =&gt; true ]];// 更新索引映射$response_map = $client-&gt;indices()-&gt;putMapping($mapping_params);dd($response_map); 返回结果 123array:1 [ \"acknowledged\" =&gt; true] 获取映射API123456789101112131415161718192021222324252627282930313233// 获取所有索引和类型的映射$response_map = $client-&gt;indices()-&gt;getMapping();// 获取'test_index_1'中所有类型的映射$map_index = ['index' =&gt; 'test_index_1'];$response_map = $client-&gt;indices()-&gt;getMapping($map_index);// 获取所有'test_type_1'的类型映射,而不考虑索引$map_type = [ 'type' =&gt; 'test_type_1', 'custom' =&gt; [ 'include_type_name' =&gt; true ]];$response_map = $client-&gt;indices()-&gt;getMapping($map_type);// 获取 'test_index_1' 中的'test_type_1'的映射$map_params = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'custom' =&gt; [ 'include_type_name' =&gt; true ]];$response_map = $client-&gt;indices()-&gt;getMapping($map_params);// 获取两个索引的映射$map_2index = [ 'index' =&gt; ['test_index_1', 'index_help', 'index_app']];//$response_map = $client-&gt;indices()-&gt;getMapping($map_2index);//dd($response_map); 返回结果 12345678910111213141516171819202122232425262728293031323334353637array:1 [ \"test_index_1\" =&gt; array:1 [ \"mappings\" =&gt; array:1 [ \"test_type_1\" =&gt; array:1 [ \"properties\" =&gt; array:3 [ \"testField\" =&gt; array:2 [ \"type\" =&gt; \"text\" \"fields\" =&gt; array:1 [ \"keyword\" =&gt; array:2 [ \"type\" =&gt; \"keyword\" \"ignore_above\" =&gt; 256 ] ] ] \"testField2\" =&gt; array:2 [ \"type\" =&gt; \"text\" \"fields\" =&gt; array:1 [ \"keyword\" =&gt; array:2 [ \"type\" =&gt; \"keyword\" \"ignore_above\" =&gt; 256 ] ] ] \"testField3\" =&gt; array:2 [ \"type\" =&gt; \"text\" \"fields\" =&gt; array:1 [ \"keyword\" =&gt; array:2 [ \"type\" =&gt; \"keyword\" \"ignore_above\" =&gt; 256 ] ] ] ] ] ] ]] 执行搜索Match 查询1234567891011121314$search_params = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'body' =&gt; [ 'query' =&gt; [ 'match' =&gt; [ 'testField' =&gt; 'caoxl', ], ], ],];$response_search = $client-&gt;search($search_params);dd($response_search); 返回结果 123456789101112131415161718192021222324252627282930array:4 [ \"took\" =&gt; 79 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 2 \"successful\" =&gt; 2 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 1 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 0.2876821 \"hits\" =&gt; array:1 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_score\" =&gt; 0.2876821 \"_source\" =&gt; array:3 [ \"testField\" =&gt; \"caoxl\" \"testField2\" =&gt; \"caoxl2\" \"testField3\" =&gt; \"caoxl3\" ] ] ] ]] Bool查询1234567891011121314151617$search_params = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'body' =&gt; [ 'query' =&gt; [ 'bool' =&gt; [ 'must' =&gt; [ ['match' =&gt; ['testField' =&gt; 'caoxl']], ['match' =&gt; ['testField2' =&gt; 'caoxl2']], ], ], ], ],];$response_search = $client-&gt;search($search_params);dd($response_search); 返回结果 123456789101112131415161718192021222324252627282930array:4 [ \"took\" =&gt; 191 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 2 \"successful\" =&gt; 2 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 1 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 0.5753642 \"hits\" =&gt; array:1 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_score\" =&gt; 0.5753642 \"_source\" =&gt; array:3 [ \"testField\" =&gt; \"caoxl\" \"testField2\" =&gt; \"caoxl2\" \"testField3\" =&gt; \"caoxl3\" ] ] ] ]] 更复杂的示例 12345678910111213141516171819$search_params = [ 'index' =&gt; 'test_index_1', 'type' =&gt; 'test_type_1', 'body' =&gt; [ 'query' =&gt; [ 'bool' =&gt; [ 'filter' =&gt; [ 'term' =&gt; ['testField' =&gt; 'caoxl'] ], 'should' =&gt; [ 'match' =&gt; ['testField2' =&gt; 'caoxl2'] ], ] ], ],];$response_search = $client-&gt;search($search_params);dd($response_search); 返回结果 123456789101112131415161718192021222324252627282930array:4 [ \"took\" =&gt; 1 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 2 \"successful\" =&gt; 2 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 1 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 0.2876821 \"hits\" =&gt; array:1 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_score\" =&gt; 0.2876821 \"_source\" =&gt; array:3 [ \"testField\" =&gt; \"caoxl\" \"testField2\" =&gt; \"caoxl2\" \"testField3\" =&gt; \"caoxl3\" ] ] ] ]] Scrolling(游标) 查询1234567891011121314151617181920212223242526$search_params = [ 'scroll' =&gt; '30s', 'size' =&gt; 50, 'index' =&gt; 'test_index_1', 'body' =&gt; [ 'query' =&gt; [ 'match_all' =&gt; new \\stdClass() ], ],];$response_search = $client-&gt;search($search_params);dd($response_search);// 将所有数据循环出来while(isset($response_search['hits']['hits']) &amp;&amp; count($response_search['hits']['hits']) &gt; 0) &#123; $scroll_id = $response_search['_scroll_id']; // 执行下一个游标请求 $response_search = $client-&gt;scroll([ 'scroll_id' =&gt; $scroll_id, 'scroll' =&gt; '30s' ]);&#125; 返回结果 12345678910111213141516171819202122232425262728293031array:5 [ \"_scroll_id\" =&gt; \"DnF1ZXJ5VGhlbkZldGNoAgAAAAAAAAAVFlJxaEFQVFFEVDd5RVVqUFVvRTB4V1EAAAAAAAAAFhZScWhBUFRRRFQ3eUVValBVb0UweFdR\" \"took\" =&gt; 39 \"timed_out\" =&gt; false \"_shards\" =&gt; array:4 [ \"total\" =&gt; 2 \"successful\" =&gt; 2 \"skipped\" =&gt; 0 \"failed\" =&gt; 0 ] \"hits\" =&gt; array:3 [ \"total\" =&gt; array:2 [ \"value\" =&gt; 1 \"relation\" =&gt; \"eq\" ] \"max_score\" =&gt; 1.0 \"hits\" =&gt; array:1 [ 0 =&gt; array:5 [ \"_index\" =&gt; \"test_index_1\" \"_type\" =&gt; \"test_type_1\" \"_id\" =&gt; \"test_id_1\" \"_score\" =&gt; 1.0 \"_source\" =&gt; array:3 [ \"testField\" =&gt; \"caoxl\" \"testField2\" =&gt; \"caoxl2\" \"testField3\" =&gt; \"caoxl3\" ] ] ] ]] Go-MySQL-Elasticsearch 参考: 使用 go-mysql-elasticsearch 把 MySQL 中的业务日志导入 Elasticsearch 注意: 需要把binlog模式修改成ROW 其他操作 给现有索引添加别名 12345678910111213$alias_params['body'] = [ 'actions' =&gt; [ [ 'add' =&gt; [ 'index' =&gt; 'test_index_1', 'alias' =&gt; 'alias_index_1' ] ] ],];$response_alias = $client-&gt;indices()-&gt;updateAliases($alias_params);dd($response_alias); 返回结果 123array:1 [ \"acknowledged\" =&gt; true] 常见问题 Types cannot be provided in put mapping requests, unless the include_type_name parameter is set to true 参考上面映射API&amp;&amp;获取映射API中加入如下参数 123'custom' =&gt; [ 'include_type_name' =&gt; true] 参考 Elasticsearch-PHP 中文文档 Elasticsearch 权威指南(中文版) elasticsearch-analysis-ik go-mysql-elasticsearch Download Elasticsearch Download Kibana Elasticsearch入门教程(五)：Elasticsearch查询(一) Elasticsearch入门教程(六)：Elasticsearch查询(二)","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://blog.caoxl.com/tags/ElasticSearch/"},{"name":"Kibana","slug":"Kibana","permalink":"http://blog.caoxl.com/tags/Kibana/"},{"name":"IK","slug":"IK","permalink":"http://blog.caoxl.com/tags/IK/"},{"name":"Go-MySQL-ES","slug":"Go-MySQL-ES","permalink":"http://blog.caoxl.com/tags/Go-MySQL-ES/"}]},{"title":"Laravel 时间字段","slug":"Laravel-Eloquent-CreateAt-UpdateAt","date":"2019-06-25T07:07:13.000Z","updated":"2019-08-22T03:51:37.000Z","comments":true,"path":"2019/06/25/Laravel-Eloquent-CreateAt-UpdateAt/","link":"","permalink":"http://blog.caoxl.com/2019/06/25/Laravel-Eloquent-CreateAt-UpdateAt/","excerpt":"","text":"有时候我们在一个已有的数据库上使用 Laravel 进行开发，通常表的创建和更新时间的字段名并不是 created_at 和 updated_at，也有时候只有一个创建时间而没有更新时间，那么我们在数据模型定义的时候该怎么处理呢？ 时间字段名称修改成自己需要的第一种: 重写常量(推荐)1234567&lt;?phpclass Test extends Model&#123; const CREATED_AT = 'create_time'; const UPDATED_AT = 'update_time';&#125; 第二种: 模型事件12345678910111213141516171819&lt;?phpclass Test extends Model&#123; public $timestamps = false; public static function boot() &#123; parent::boot(); static::creating(function ($model) &#123; $model-&gt;created = $model-&gt;freshTimestampString(); &#125;); static::updating(function ($model) &#123; $model-&gt;updated = $model-&gt;freshTimestampString(); &#125;); &#125;&#125; 时间字段的类型是int而不是timestamps123456789101112131415161718192021222324252627&lt;?phpclass Test extends Model&#123; const CREATED_AT = 'create_time'; const UPDATED_AT = 'update_time'; public function setCreateTimeAttribute($value) &#123; $this-&gt;attributes['create_time'] = strtotime($value); &#125; public function setUpdateTimeAttribute($value) &#123; $this-&gt;attributes['update_time'] = strtotime($value); &#125; public function getCreateTimeAttribute() &#123; return date('Y-m-d H:i:s', $this-&gt;attributes['create_time']); &#125; public function getUpdateTimeAttribute() &#123; return date('Y-m-d H:i:s', $this-&gt;attributes['update_time']); &#125;&#125; 如果使用的是Laravel默认的created_at和updated_at,直接使用以下代码即可1protected $dateFormat = 'U';","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"created_at","slug":"created-at","permalink":"http://blog.caoxl.com/tags/created-at/"},{"name":"update_at","slug":"update-at","permalink":"http://blog.caoxl.com/tags/update-at/"}]},{"title":"Laravel 自动生成模型","slug":"Laravel-Reliese","date":"2019-06-21T03:36:14.000Z","updated":"2019-08-22T03:51:57.000Z","comments":true,"path":"2019/06/21/Laravel-Reliese/","link":"","permalink":"http://blog.caoxl.com/2019/06/21/Laravel-Reliese/","excerpt":"","text":"Reliese Laravel is a collection of Laravel Components which aim is to help the development process of Laravel applications by providing some convenient code-generation capabilities. 安装/使用 composer 安装 1composer require \"reliese/laravel:dev-master\" 修改 config/app.php 12345678// ...'providers' =&gt; [ /* * Package Service Providers... */ Reliese\\Coders\\CodersServiceProvider::class,],// ... 添加配置文件 php php artisan vendor:publish --tag=reliese-models php artisan config:clear 修改配置文件 config/models (根据个人喜好修改) 12'path' =&gt; app_path('Models/Base'),'namespace' =&gt; 'App\\Models\\Base', 执行命令 php artisan code:models 123Administrator@Caoxl MINGW64 /d/app/phpStudy/PHPTutorial/WWW/laravel8$ php artisan code:modelsCheck out your models for laravel8 查看app/Models/Base/,生成了数据表对应的Model 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php/** * Created by Reliese Model. */namespace App\\Models\\Base;use Carbon\\Carbon;use Reliese\\Database\\Eloquent\\Model;/** * Class User * * @property int $id * @property string $name * @property string $email * @property Carbon $email_verified_at * @property string $password * @property string $remember_token * @property Carbon $created_at * @property Carbon $updated_at * * @package App\\Models\\Base */class User extends Model&#123; protected $table = 'users'; protected $dates = [ 'email_verified_at' ]; protected $hidden = [ 'password', 'remember_token' ]; protected $fillable = [ 'name', 'email', 'email_verified_at', 'password', 'remember_token' ];&#125; 参考: reliese/laravel","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Reliese","slug":"Reliese","permalink":"http://blog.caoxl.com/tags/Reliese/"}]},{"title":"Laravel 注解路由","slug":"Laravel-Annotations","date":"2019-06-21T02:25:09.000Z","updated":"2019-08-22T03:52:02.000Z","comments":true,"path":"2019/06/21/Laravel-Annotations/","link":"","permalink":"http://blog.caoxl.com/2019/06/21/Laravel-Annotations/","excerpt":"Route and Event Annotations for the Laravel Framework","text":"Route and Event Annotations for the Laravel Framework 安装/使用 composer 安装 1composer require \"laravelcollective/annotations:5.8.*\" 创建app/Providers/AnnotationsServiceProvider.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpnamespace App\\Providers;use Collective\\Annotations\\AnnotationsServiceProvider as ServiceProvider;class AnnotationsServiceProvider extends ServiceProvider&#123; /** * The classes to scan for event annotations * @var array */ protected $scanEvents = []; /** * The classes to scan for route annotations * @var array */ protected $scanRoutes = []; /** * The classes to scan for model annotations * @var array */ protected $scanModels = []; /** * Determines if we will auto-scan in the local environment. * @var bool */ protected $scanWhenLocal = false; /** * Determines whether or not to automatically scan the controller * @var bool */ protected $scanControllers = false; /** * Determines whether or not to automatically scan all namespaced * @var bool */ protected $scanEverything = false; /** * 指定扫描的Controllers * @return array */ public function routeScans() &#123; static $app_path = [ 'Api', 'Http', ]; $classes = parent::routeScans(); foreach ($app_path as $path) &#123; $classes = array_merge( $classes, $this-&gt;getClassesFromPath(\"app/$path/Controllers\") ); &#125; return $classes; &#125; protected function getClassesFromPath(string $path) &#123; $directory = base_path($path); return $this-&gt;app-&gt;make('Collective\\Annotations\\Filesystem\\ClassFinder') -&gt;findClasses($directory); &#125;&#125; 修改config/app.php 12345'providers' =&gt; [ // ... App\\Providers\\AnnotationsServiceProvider::class // ...]; 创建app/api/Controllers/TestController.php 12345678910111213141516171819202122232425&lt;?phpnamespace App\\Api\\Controller;use App\\Api\\Controller as BaseController;use Collective\\Annotations\\Routing\\Annotations\\Annotations\\&#123; Controller, Get&#125;;/** * Class TestController * @package App\\Api\\Controller * * @Controller(prefix=\"/api/test\") */class TestController extends BaseController&#123; /** * @Get(\"/test_route\") */ public function test_route() &#123; dd('1024'); &#125;&#125; 执行 php artisan route:scan 生成了/storage/framework/routes.scanned.php 12345678&lt;?php $router-&gt;get('api/test/test_route', [ 'uses' =&gt; 'App\\Api\\Controller\\TestController@test_route', 'as' =&gt; NULL, 'middleware' =&gt; [], 'where' =&gt; [], 'domain' =&gt; NULL,]); 访问路由laravel8.test/api/test/test_route即可 其他命令参考: Laravel Annotations","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Annotations","slug":"Annotations","permalink":"http://blog.caoxl.com/tags/Annotations/"}]},{"title":"Linux 实战","slug":"Linux-Actual-Combat","date":"2019-05-24T02:39:44.000Z","updated":"2019-05-24T03:49:44.000Z","comments":true,"path":"2019/05/24/Linux-Actual-Combat/","link":"","permalink":"http://blog.caoxl.com/2019/05/24/Linux-Actual-Combat/","excerpt":"在Linux CentOs中遇到的一些实际情况","text":"在Linux CentOs中遇到的一些实际情况 磁盘占用100% df -Th - 查看磁盘空间使用情况 123456[root@caoxl /]# df -ThFilesystem Type Size Used Avail Use% Mounted on/dev/vda1 ext4 40G 11G 27G 30% /devtmpfs devtmpfs 1.9G 0 1.9G 0% /devtmpfs tmpfs 1.9G 536K 1.9G 1% /runtmpfs tmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup du -sh ./* - 查看目录所占空间大小 12345678910111213141516171819[root@caoxl www]# du -sh ./*18M ./barrage37M ./caoxl4.0K ./docker8.0K ./go54M ./laravel84M ./laravel_admin189M ./laravel_docker56M ./laravels49M ./lumen47M ./lumens1.5M ./php_msf64K ./python40M ./swoft304K ./swoole176K ./test6.7M ./tp32.1M ./tp54.0K ./yaf 查看哪个进程占用磁盘IO iotop -oP - 只显示有I/O行为的进程 123Total DISK READ : 0.00 B/s | Total DISK WRITE : 0.00 B/sActual DISK READ: 0.00 B/s | Actual DISK WRITE: 0.00 B/sPID PRIO USER DISK READ DISK WRITE SWAPIN IO&gt; COMMAND pidstat -d 1 - 展示I/O统计,每秒更新一次 12345678[root@caoxl /]# pidstat -d 1Linux 3.10.0-862.14.4.el7.x86_64 (caoxl) 05/24/2019 _x86_64_ (2 CPU)10:45:32 AM UID PID kB_rd/s kB_wr/s kB_ccwr/s Command10:45:33 AM UID PID kB_rd/s kB_wr/s kB_ccwr/s Command10:45:34 AM UID PID kB_rd/s kB_wr/s kB_ccwr/s Command iostat -x 1 10 - 查看磁盘IO,是否读写负载很高 12345678[root@caoxl /]# iostat -x 1 10Linux 3.10.0-862.14.4.el7.x86_64 (caoxl) 05/24/2019 _x86_64_ (2 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.47 0.01 0.44 1.21 0.00 97.87Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.16 0.85 45.39 20.22 544.48 95.77 19.52 0.15 2.24 2.38 1.92 0.46 3.02 如果 iostat 没有，要 yum install sysstat安装这个包如果%util接近100%,表明I/O请求太多,I/O系统已经满负荷，磁盘可能存在瓶颈,一般%util大于70%,I/O压力就比较大 查询目录大小,并排序显示 du -h --max-depth=1 | grep G | sort -n 1234567891011121314[root@caoxl www]# du -h --max-depth=1|grep M|sort -n1.5M ./php_msf2.1M ./tp56.7M ./tp318M ./barrage37M ./caoxl40M ./swoft47M ./lumens49M ./lumen54M ./laravel56M ./laravels84M ./laravel_admin189M ./laravel_docker583M . --max-depth=1: 表示只递归层数 grep M: 表示查询什么单位的M/G等等 sort -n: 表示依照数值的大小排序 查询已经删除的文件 lsof | grep deleted 1234[root@caoxl www]# lsof | grep deleted | grep phpphp-fpm 896 root 3u REG 253,1 0 393658 /tmp/.ZendSem.VOY7vA (deleted)php-fpm 902 www 3u REG 253,1 0 393658 /tmp/.ZendSem.VOY7vA (deleted)php-fpm 903 www 3u REG 253,1 0 393658 /tmp/.ZendSem.VOY7vA (deleted) 查看一个进程精确启动时间 ps -ef &amp;&amp; ps -eO lstart 123456789// 24小时内[root@caoxl /]# ps -ef | grep dockerroot 2179 1 0 10:36 ? 00:00:00 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockroot 4812 1121 0 11:14 pts/0 00:00:00 grep --color=auto docker// 超过24小时[root@caoxl /]# ps -eO lstart | grep docker 2179 Fri May 24 10:36:30 2019 S ? 00:00:00 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock 4850 Fri May 24 11:14:42 2019 S pts/0 00:00:00 grep --color=auto docker 查询Linux系统相关 cat /proc/version - 查看linux内核版本 12[root@caoxl /]# cat /proc/versionLinux version 3.10.0-862.14.4.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) ) #1 SMP Wed Sep 26 15:12:11 UTC 2018 uname -a - 查看内核/操作系统的信息 12[root@caoxl /]# uname -aLinux caoxl 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux lsb_release -a - 查看系统版本号 123456[root@caoxl /]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.5.1804 (Core) Release: 7.5.1804Codename: Core 查询进程相关 netstat -lp | grep mysql - 查看启动的mysql服务 123[root@caoxl /]# netstat -lp | grep mysqltcp6 0 0 [::]:mysql [::]:* LISTEN 2857/mysqld unix 2 [ ACC ] STREAM LISTENING 42225 2857/mysqld /tmp/mysql.sock netstat -nltp | grep 9001 - 查询9001端口是否监听 12[root@caoxl /]# netstat -nltp | grep 9001tcp 0 0 127.0.0.1:9001 0.0.0.0:* LISTEN 882/php-fpm: master ps -aux | grep php - 查询进程 12345[root@caoxl /]# ps -aux | grep phproot 882 0.0 0.1 217812 5012 ? Ss 10:21 0:00 php-fpm: master process (/usr/local/php/php56/etc/php-fpm.conf)www 891 0.0 0.1 217812 4552 ? S 10:21 0:00 php-fpm: pool wwwwww 892 0.0 0.1 217812 4552 ? S 10:21 0:00 php-fpm: pool wwwroot 5937 0.0 0.0 112708 972 pts/0 S+ 11:34 0:00 grep --color=auto php ps -ef | grep php - 查询进程 12345[root@caoxl /]# ps -ef | grep phproot 882 1 0 10:21 ? 00:00:00 php-fpm: master process (/usr/local/php/php56/etc/php-fpm.conf)www 891 882 0 10:21 ? 00:00:00 php-fpm: pool wwwwww 892 882 0 10:21 ? 00:00:00 php-fpm: pool wwwroot 5998 1121 0 11:35 pts/0 00:00:00 grep --color=auto php history | grep iotop - 列出最近使用iotop命令的记录 1234[root@caoxl /]# history | grep iotop 1035 iotop -oP 1049 iotop -oP 1142 history | grep iotop 查询硬件相关1234[root@caoxl /]# dmesg // 监测硬件和启动消息[root@caoxl /]# cat /proc/cpuinfo // CPU信息 [root@caoxl /]# cat /proc/meminfo // 硬件内存信息 [root@caoxl /]# free -m // 内存信息 查询统计相关123456[root@caoxl /]# top // 显示并不断更新最耗CPU的进程[root@caoxl /]# mpstat 1 // 显示CPU统计信息[root@caoxl /]# vmstat 2 // 显示虚拟内存统计信息 (2s采样间隔)[root@caoxl /]# iostat 2 // 显示IO统计信息[root@caoxl /]# tcpdump -i eth1 // 捕获eth1网络接口上的所有数据包[root@caoxl /]# tcpdump -i eth0 'port 80' // 监控80端口的网络流量","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Laravel 5.8 杂记","slug":"Laravel-58-Notes","date":"2019-05-20T08:02:45.000Z","updated":"2019-08-22T03:52:10.000Z","comments":true,"path":"2019/05/20/Laravel-58-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/05/20/Laravel-58-Notes/","excerpt":"","text":"Laravel 5.8 Laravel 5.8 在 Laravel 5.7 的基础上继续进行优化，包括引入新的 Eloquent 关联关系（has-one-through）、优化邮箱验证、基于约定的授权策略类自动注册、 DynamoDB 缓存及 Session 驱动、优化任务调度器的时区配置、支持分配多个认证 guard 到广播频道、PSR-16 缓存驱动规范、优化 artisan serve 命令、支持 PHPUnit 8.0、支持 Carbon 2.0 、支持 Pheanstalk 4.0 ，以及多个 bug 修复和可用性的提升。 5.8 发行说明 Laravel 必知Laravel的请求周期 ? Laravel应用的所有请求入口public/index.php 12345678910111213141516171819202122232425&lt;?phpdefine('LARAVEL_START', microtime(true));// Register The Auto Loader// 加载 Composer 生成的自动加载设置require __DIR__.'/../vendor/autoload.php';// Turn On The Lights// 然后从 bootstrap/app.php 脚本中检索 Laravel 应用程序的实例$app = require_once __DIR__.'/../bootstrap/app.php';// Run The Application// 根据进入应用程序的请求类型来将传入的请求发送到 HTTP 内核或控制台内核$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture());$response-&gt;send();// Perform any final actions for the request lifecycle// TTP 内核的 handle 方法签名相当简单：获取一个 Request ，返回一个 Response$kernel-&gt;terminate($request, $response); HTTP / Console 内核 app/Http/Kernel.php 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\\Console;use Illuminate\\Console\\Scheduling\\Schedule;use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel;class Kernel extends ConsoleKernel&#123; // The Artisan commands provided by your application. // Artisan CMD protected $commands = [ // ]; // Define the application's command schedule. // 定义应用程序的定时任务 protected function schedule(Schedule $schedule) &#123; // $schedule-&gt;command('inspire') // -&gt;hourly(); &#125; // Register the commands for the application. // 注册应用程序的命令 protected function commands() &#123; $this-&gt;load(__DIR__.'/Commands'); require base_path('routes/console.php'); &#125;&#125; 服务提供者 config/app.php 内核启动操作中最重要的便是你应用的 服务提供者 了。所有应用下的服务提供者均配置到了 config/app.php 配置文件中的 providers 数组中 123456789101112131415161718192021222324252627282930313233343536373839404142'providers' =&gt; [ /* * Laravel Framework Service Providers... */ Illuminate\\Auth\\AuthServiceProvider::class, Illuminate\\Broadcasting\\BroadcastServiceProvider::class, Illuminate\\Bus\\BusServiceProvider::class, Illuminate\\Cache\\CacheServiceProvider::class, Illuminate\\Foundation\\Providers\\ConsoleSupportServiceProvider::class, Illuminate\\Cookie\\CookieServiceProvider::class, Illuminate\\Database\\DatabaseServiceProvider::class, Illuminate\\Encryption\\EncryptionServiceProvider::class, Illuminate\\Filesystem\\FilesystemServiceProvider::class, Illuminate\\Foundation\\Providers\\FoundationServiceProvider::class, Illuminate\\Hashing\\HashServiceProvider::class, Illuminate\\Mail\\MailServiceProvider::class, Illuminate\\Notifications\\NotificationServiceProvider::class, Illuminate\\Pagination\\PaginationServiceProvider::class, Illuminate\\Pipeline\\PipelineServiceProvider::class, Illuminate\\Queue\\QueueServiceProvider::class, Illuminate\\Redis\\RedisServiceProvider::class, Illuminate\\Auth\\Passwords\\PasswordResetServiceProvider::class, Illuminate\\Session\\SessionServiceProvider::class, Illuminate\\Translation\\TranslationServiceProvider::class, Illuminate\\Validation\\ValidationServiceProvider::class, Illuminate\\View\\ViewServiceProvider::class, /* * Package Service Providers... */ /* * Application Service Providers... */ App\\Providers\\AppServiceProvider::class, App\\Providers\\AuthServiceProvider::class, // App\\Providers\\BroadcastServiceProvider::class, App\\Providers\\EventServiceProvider::class, App\\Providers\\RouteServiceProvider::class, ], 第一步，所有服务提供者的 register 方法会被调用，然后一旦所有服务提供者均注册后， boot 方法才被调用。 请求调度 routes/***.php 一旦启动且所有服务提供者被注册，Request 会被递送给路由。路由将会调度请求，交给绑定的路由或控制器，也当然包括路由绑定的中间件。 123Route::middleware('auth:api')-&gt;get('/user', function (Request $request) &#123; return $request-&gt;user();&#125;); 聚焦服务提供者 服务提供者是 Laravel 真正意义的生命周期中的关键。应用实例一旦创建，服务提供者就被注册，然后请求被启动的应用接管。默认的服务提供会存放在 app/Providers 下面。 什么是服务容器 ? Laravel 服务容器是一个用于来管理类的依赖和执行依赖注入的强大工具 服务绑定 简单绑定: $this-&gt;app-&gt;bind(); 绑定一个单例: $this-&gt;app-&gt;singleton(); 绑定实例: $this-&gt;app-&gt;instance(); 绑定基本值: $this-&gt;app-&gt;when()-&gt;needs()-&gt;give(); 绑定接口到实现: $this-&gt;app-&gt;bind(&#39;App\\Contracts\\EventPusher&#39;); 扩展绑定: $this-&gt;app-&gt;extend(); 解析实例 make方法: $this-&gt;app-&gt;make(); makeWith: $this-&gt;app-&gt;makeWith(); 自动注入 1234public function __construct(UserRepository $users)&#123; $this-&gt;users = $users;&#125; 容器事件 服务容器每次解析对象会触发一个事件，你可以使用 resolving 方法监听这个事件 : 123$this-&gt;app-&gt;resolving(function ($object, $app) &#123; // Called when container resolves object of any type...&#125;); 什么是依赖注入 ? 依赖注入这个花哨的名词实质上是指: 类的依赖通过构造函数,或者某些情况下通过”setter”方法 123456proteced $user;public function __construct(User $user)&#123; $this-&gt;user = $user;&#125; 什么是服务提供者 ? 服务提供者是所有 Laravel 应用程序的引导中心。你的应用程序，以及 通过服务器引导的 Laravel 核心服务都是通过服务提供器引导。 但是，「引导」是什么意思呢？ 通常，我们的可以理解为注册，比如注册服务容器绑定，事件监听器，中间件，甚至是路由。服务提供者是配置应用程序的中心. 编写服务提供者 1php artisan make:provider TestServiceProvider 注册服务提供者 123456// config/app.php'providers' =&gt; [ // 其他服务提供者 App\\Providers\\ComposerServiceProvider::class,], 什么是 Facades ? Facades 为应用的 服务容器 提供了一个「静态」 接口。Laravel Facades 实际是服务容器中底层类的 「静态代理」 ，相对于传统静态方法，在使用时能够提供更加灵活、更加易于测试、更加优雅的语法。 Facades 相较于依赖注入 依赖注入的主要好处之一是能交换注入类的实现。在测试的时候非常有用，因为你可以注入一个 `stub`，并断言 `stub` 上的各种方法。12345678910111213- Facades 相较于辅助函数&gt; `Facade` 和辅助函数之间没有实际的区别。当你使用辅助函数时，你可以像测试相应的 `Facade` 那样进行测试。- Facades 工作原理&gt; 在 `Laravel` 应用中，`Facade` 就是一个可以从容器访问对象的类。其中核心的部件就是 `Facade` 类。&gt; `Facade` 基类使用了 `__callStatic()` 魔术方法，直到对象从容器中被解析出来后，才会进行调用。- `__callStatic()````php 什么是 Contracts ? Contracts 契约Laravel 的契约是一组由框架提供，定义了核心服务的 interface 集合。 什么是控制反转 ? IoC (控制反转)，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。 实现控制反转的方式 依赖注入(Dependency Injection(DI)) 依赖查找 (Dependency Lookup) 什么是 Eloquent ORM ? Laravel 的 Eloquent ORM 提供了一个漂亮、简洁的 ActiveRecord 实现来和数据库交互。每个数据库表都有一个对应的「模型」用来与该表交互。","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Facades","slug":"Facades","permalink":"http://blog.caoxl.com/tags/Facades/"},{"name":"Contracts","slug":"Contracts","permalink":"http://blog.caoxl.com/tags/Contracts/"}]},{"title":"Docker DockerFile","slug":"Docker-DockerFile","date":"2019-05-16T02:46:42.000Z","updated":"2019-08-22T03:32:17.000Z","comments":true,"path":"2019/05/16/Docker-DockerFile/","link":"","permalink":"http://blog.caoxl.com/2019/05/16/Docker-DockerFile/","excerpt":"Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。","text":"Dockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 使用 Dockerfile 定制镜像 创建 Dockerfile 123mkdir testcd testtouch Dockerfile Dockerfile 写入内容 12FROM nginxRUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 构建镜像 在 Dockerfile 文件所在目录执行： 12345678910[root@caoxl test_nginx]# docker build -t nginx:v3 ./Sending build context to Docker daemon 2.048kBStep 1/2 : FROM nginx ---&gt; 53f3fd8007f7Step 2/2 : RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html ---&gt; Running in b4a1b636bff4Removing intermediate container b4a1b636bff4 ---&gt; 9ab56bb5f020Successfully built 9ab56bb5f020Successfully tagged nginx:v3 Dockerfile 指令详解FROM - 指定基础镜像所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。 RUN - 执行命令RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。 1RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html exec 格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]，这更像是函数调用中的格式 123456FROM debian:stretchRUN buildDeps='gcc libc6-dev make wget' \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ COPY - 复制文件 格式 COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt; COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] 1COPY package.json /usr/src/app/ ADD - 更高级的复制文件 ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 1ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / 在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰 CMD 容器启动命令 CMD 指令的格式和 RUN 相似，也是两种格式： shell 格式：CMD &lt;命令&gt; exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...] 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &quot;，而不要使用单引号。 如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如： 1CMD echo $HOME 在实际执行中，会将其变更为： 1CMD [ \"sh\", \"-c\", \"echo $HOME\" ] ENTRYPOINT - 入口点 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 12345FROM ubuntu:18.04RUN apt-get update \\ &amp;&amp; apt-get install -y curl \\ &amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [ \"curl\", \"-s\", \"https://ip.cn\" ] ENV - 设置环境变量 格式 ENV &lt;key&gt; &lt;value&gt; ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 12ENV VERSION=1.0 DEBUG=on \\ NAME=\"Happy Feet\" WORKDIR - 指定工作目录1234FROM node:slimRUN mkdir /appWORKDIR /appCMD [ \"npm\", \"start\" ] USER - 指定当前用户123RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ \"redis-server\" ] 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu。 12345678# 建立 redis 用户，并使用 gosu 换另一个用户执行命令RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64\" \\ &amp;&amp; chmod +x /usr/local/bin/gosu \\ &amp;&amp; gosu nobody true# 设置 CMD，并以另外的用户执行CMD [ \"exec\", \"gosu\", \"redis\", \"redis-server\" ] Dockerfile 多阶段构建实战多阶段构建 Laravel 镜像 待更新… 参考 Dockerfile 官方文档 Dockerfile 最佳实践文档 Docker 官方镜像 Dockerfile","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.caoxl.com/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://blog.caoxl.com/tags/Dockerfile/"}]},{"title":"Docker 深入","slug":"Docker","date":"2019-05-15T03:24:00.000Z","updated":"2019-08-22T03:32:05.000Z","comments":true,"path":"2019/05/15/Docker/","link":"","permalink":"http://blog.caoxl.com/2019/05/15/Docker/","excerpt":"什么是 Docker ? Enterprise Container Platform for High-Velocity Innovation高速创新的企业集装箱平台 Securely build, share and run any application, anywhere在任何地方安全地构建，共享和运行任何应用程序","text":"什么是 Docker ? Enterprise Container Platform for High-Velocity Innovation高速创新的企业集装箱平台 Securely build, share and run any application, anywhere在任何地方安全地构建，共享和运行任何应用程序 什么是容器 ? 容器是一个标准的软件单元，它将代码及其所有依赖关系打包，以便应用程序从一个计算环境快速可靠地运行到另一个计算环境。 Docker安装在原来的博客有讲到,这里就讲Docker的使用及实例 Docker使用Docker Hello World12345678910111213141516171819202122[root@caoxl ~]# docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ Docker 容器使用Docker 客户端12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879[root@caoxl ~]# dockerUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default \"/root/.docker\") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (\"debug\"|\"info\"|\"warn\"|\"error\"|\"fatal\") (default \"info\") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default \"/root/.docker/ca.pem\") --tlscert string Path to TLS certificate file (default \"/root/.docker/cert.pem\") --tlskey string Path to TLS key file (default \"/root/.docker/key.pem\") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: builder Manage builds config Manage Docker configs container Manage containers engine Manage the docker engine image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun 'docker COMMAND --help' for more information on a command. 可以通过命令 docker command --help 更深入的了解指定的 Docker 命令使用方法。 123456789101112131415[root@caoxl ~]# docker ps --helpUsage: docker ps [OPTIONS]List containersOptions: -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don't truncate output -q, --quiet Only display numeric IDs -s, --size Display total file sizes 运行一个Web应用接下来让我们尝试使用 docker 构建一个 web 应用程序。 我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。 1234567891011121314151617[root@caoxl ~]# docker pull training/webappUsing default tag: latestlatest: Pulling from training/webappe190868d63f8: Pull complete 909cd34c6fd7: Pull complete 0b9bfabab7c1: Pull complete a3ed95caeb02: Pull complete 10bbbc0fc0ff: Pull complete fca59b508e9f: Pull complete e7ae2541b15b: Pull complete 9dd97ef58ce9: Pull complete a4c1b0cb7af7: Pull complete Digest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11dStatus: Downloaded newer image for training/webapp:latest[root@caoxl ~]# docker run -d -P training/webapp python app.pyfc14b64cda1d2445bcea207ece36b9b274f3a422be26c92bd95cbe1af96d0d6e 参数说明 -d: 让容器在后台运行 -P: 将容器内部使用的网络端口映射到我们使用的手机上 查看WEB应用容器1234[root@caoxl ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfc14b64cda1d training/webapp \"python app.py\" About a minute ago Up About a minute 0.0.0.0:32768-&gt;5000/tcp hopeful_mendelc4d4afebb0d1 pinguo/php-msf-demo:newdev \"/run.sh /usr/sbin/s…\" 27 minutes ago Up 27 minutes 0.0.0.0:443-&gt;443/tcp, 80/tcp, 0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:2202-&gt;22/tcp pinguo_php-msf-demo_newdev 停止Web应用容器,使用NAMES12[root@caoxl ~]# docker stop hopeful_mendelhopeful_mendel 重启WEB应用容器12[root@caoxl ~]# docker start hopeful_mendelhopeful_mendel 移除WEB应用容器12[root@caoxl ~]# docker rm hopeful_mendelhopeful_mendel 删除容器时，容器必须是停止状态，否则会报错误 Docker 镜像使用列出镜像列表123456[root@caoxl ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest fce289e99eb9 4 months ago 1.84kBpinguo/php-msf-demo newdev 39995bac5087 18 months ago 1.54GBregistry.cn-hangzhou.aliyuncs.com/pinguo-ops/php-msf-docker latest 39995bac5087 18 months ago 1.54GBtraining/webapp latest 6fae60ef3446 4 years ago 349MB 各个选项说明 REPOSITORY: 表示镜像的仓库源 TAG: 镜像的标签 IMAGE ID: 镜像ID CREATED: 镜像创建时间 SIZE: 镜像大小 查找镜像123456789101112[root@caoxl ~]# docker pull skiychan/nginx-php7Using default tag: latestlatest: Pulling from skiychan/nginx-php78ba884070f61: Pull complete 3c273468b2f5: Pull complete d2c95013bbb4: Pull complete 4c3d9a8120f6: Pull complete f84b131a51d1: Pull complete 509155c099f5: Pull complete c24ed08ea428: Pull complete Digest: sha256:040a3047d85daa7b0f083479dffbc54a034e60e8da0edcc9570047da402c411bStatus: Downloaded newer image for skiychan/nginx-php7:latest 获取一个新的镜像12[root@caoxl ~]# docker pull skiychan/nginx-php7Using default tag: latest Docker 容器连接Docker实例Docker 安装Nginx123456[root@caoxl ~]# docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 11403 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1600 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 712 [OK]... 拉取官方的镜像 12345678[root@caoxl ~]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginx743f2d6c1f65: Pull complete 6bfc4ec4420a: Pull complete 688a776db95f: Pull complete Digest: sha256:23b4dcdf0d34d4a129755fc6f52e1c6e23bb34ea011b315d87e193033bcd1b68Status: Downloaded newer image for nginx:latest 以下命令使用 NGINX 默认的配置来启动一个 Nginx 容器实例： 12[root@caoxl ~]# docker run --name caoxl -p 8081:80 -d nginx1e13c99fa213152f2b5220a32254e658f72fd7fc8ce8e6d0a056fe87f74993a2 执行以上命令会生成一串字符串，类似 6dd4380ba70820bd2acc55ed2b326dd8c0ac7c93f68f0067daecad82aef5f938，这个表示容器的 ID，一般可作为日志的文件名。 --name 容器名称 -d 设置容器在后台一直运行 -p 端口进行映射,将本地8081端口映射到容器内部的80端口 123[root@caoxl ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1e13c99fa213 nginx \"nginx -g 'daemon of…\" 17 seconds ago Up 16 seconds 0.0.0.0:8081-&gt;80/tcp caoxl 相关命令 如果要重新载入 NGINX 可以使用以下命令发送 HUP 信号到容器： 1docker kill -s HUP nginx # container-name 容器名称,即docker ps 中的NAMES列 重启 Nginx 容器命令 1docker restart nginx 移除容器 123456789101112# 移除容器前,需要停止容器[root@caoxl ~]# docker stop 1e13c99fa2131e13c99fa213[root@caoxl ~]# docker rm 1e13c99fa2131e13c99fa213# ps 列出运行的容器列表[root@caoxl ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES# ps -a 列出所有容器列表[root@caoxl ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Docker 安装PHP123456789101112131415161718# 先查找php镜像[root@caoxl ~]# docker search php# 这里我们拉取官方的镜像,标签为7.2-fpm[root@caoxl ~]# docker pull php:7.2-fpm7.2-fpm: Pulling from library/php743f2d6c1f65: Already exists 6307e89982cc: Already exists 807218e72ce2: Already exists 5108df1d03f8: Already exists 82ffe3f78be2: Pull complete 17c66bee581c: Pull complete 03011f3bcf78: Pull complete 28b6a4179c3e: Pull complete b77fa38a9e9c: Pull complete 79928611774d: Pull complete Digest: sha256:c50c0cffd2af10291d8b8fe3dd410aed3eca302b8163e2ab34cd1bfc6feae495Status: Downloaded newer image for php:7.2-fpm Docker 安装MySQL1234[root@caoxl ~]# docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 8142 [OK] mariadb MariaDB is a community-developed fork of MyS… 2771 [OK] 这里我们拉取官方的镜像,标签为5.7 123456789101112131415[root@caoxl ~]# docker pull mysql:5.75.7: Pulling from library/mysql743f2d6c1f65: Already exists 3f0c413ee255: Pull complete aef1ef8f1aac: Pull complete f9ee573e34cb: Pull complete 3f237e01f153: Pull complete f9da32e8682a: Pull complete 4b8da52fb357: Pull complete 6f38e9cfd49b: Pull complete 9f4834b3f44f: Pull complete af631d92fdba: Pull complete 0e771ddab25c: Pull complete Digest: sha256:196fe3e00d68b2417a8cf13482bdab1fcc2b32cf7c7575d0906c700688b352b4Status: Downloaded newer image for mysql:5.7 等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为mysql,标签为5.6的镜像 12[root@caoxl ~]# docker images | grep mysqlmysql 5.7 7faa3c53e6d6 7 days ago 373MB Docker 安装Redis1234[root@caoxl ~]# docker search redisNAME DESCRIPTION STARS OFFICIAL AUTOMATEDredis Redis is an open source key-value store that… 6900 [OK] bitnami/redis Bitnami Redis Docker Image 112 [OK] 这里我们拉取官方的镜像,标签为5.0 12345678910[root@caoxl ~]# docker pull redis:5.05.0: Pulling from library/redis743f2d6c1f65: Already exists 171658c5966d: Pull complete fbef10bd7a65: Pull complete 98afd60e45e4: Pull complete 495c87fda859: Pull complete ed6767858416: Pull complete Digest: sha256:2dfa6432744659268d001d16c39f7be52ee73ef7e1001ff80643f0f7bdee117eStatus: Downloaded newer image for redis:5.0 Docker 命令大全容器生命周期管理 run - 创建一个新的容器并运行一个命令 12[root@caoxl ~]# docker run --name nginx -d nginx:latest2b077bf72f07ffa1e4e821f02bced02f9265900cc8c0b4dd663a3f90ebb2e8dc start/stop/restart - 启动/停止/重启一个或多个容器 1234567891011# 启动一个或多个容器[root@caoxl ~]# docker start caoxl-phpcaoxl-php# 停止一个运行中的容器[root@caoxl ~]# docker stop nginxnginx# 重启一个已经停止的容器[root@caoxl ~]# docker restart nginxnginx kill - 杀掉一个运行中的容器 123# 杀掉一个运行中的容器[root@caoxl ~]# docker kill -s KILL nginxnginx rm - 删除一个或多个容器(需先停止容器) 1234567# 删除一个或多个容器(需先停止容器)[root@caoxl ~]# docker rm ade302349866Error response from daemon: You cannot remove a running container ade30234986633c113e9b1e5828d6e6e1f8f74c47cdb878674cec1a2e4a7db3d. Stop the container before attempting removal or force remove# 强制删除[root@caoxl ~]# docker rm -f ade302349866ade302349866 参数说明: -f: 通过SIGKILL信号强制删除一个运行中的容器 -l: 移除容器间的网络连接,而非容器本身 -v: 删除与容器关联的卷 pasue/unpause - 暂停/恢复容器中的进程 123456789101112131415[root@caoxl ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9bf46c51c287 nginx \"nginx -g 'daemon of…\" 34 minutes ago Up 34 minutes 0.0.0.0:8081-&gt;80/tcp caoxl-nginx# 暂停容器中的进程[root@caoxl ~]# docker pause caoxl-nginxcaoxl-nginx[root@caoxl ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9bf46c51c287 nginx \"nginx -g 'daemon of…\" 36 minutes ago Up 36 minutes (Paused) 0.0.0.0:8081-&gt;80/tcp caoxl-nginx# 恢复容器中的进程[root@caoxl ~]# docker unpause caoxl-nginxcaoxl-nginx create - 创建一个新的容器但不启动 1234567891011121314151617181920[root@caoxl ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEredis 5.0 a4fe14ff1981 7 days ago 95MBphp 7.2-fpm 0be748e55df6 7 days ago 366MBnginx latest 53f3fd8007f7 7 days ago 109MBmysql 5.7 7faa3c53e6d6 7 days ago 373MB# 创建一个新的容器但不启动[root@caoxl ~]# docker create --name caoxl-mysql mysql:5.72af5be371c1586be55e6d80cbd1991c029fa44e2306fe2a22956c876fde5ee38[root@caoxl ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES9bf46c51c287 nginx \"nginx -g 'daemon of…\" 39 minutes ago Up 39 minutes 0.0.0.0:8081-&gt;80/tcp caoxl-nginx[root@caoxl ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2af5be371c15 mysql:5.7 \"docker-entrypoint.s…\" 10 seconds ago Created caoxl-mysql2b077bf72f07 nginx:latest \"nginx -g 'daemon of…\" 13 minutes ago Exited (137) 7 minutes ago nginx9bf46c51c287 nginx \"nginx -g 'daemon of…\" 39 minutes ago Up 39 minutes 0.0.0.0:8081-&gt;80/tcp caoxl-nginx exec - 在运行中的容器中执行命令 1234# 在运行中的容器中执行命令[root@caoxl ~]# docker exec -i -t nginx /bin/bashroot@2b077bf72f07:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 容器操作 ps - 列出容器 1234[root@caoxl ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2b077bf72f07 nginx:latest \"nginx -g 'daemon of…\" 18 minutes ago Up 2 minutes 80/tcp nginx9bf46c51c287 nginx \"nginx -g 'daemon of…\" 44 minutes ago Up 43 minutes 0.0.0.0:8081-&gt;80/tcp caoxl-nginx 参数说明: -a: 显示所有容器,包括未运行的 -f: 根据条件过滤显示的内容 -l: 显示最近创建的容器 -n: 显示最近创建的n个容器 -q: 静默模式,只显示容器编号 -s: 显示总的文件大小 inspect - 获取容器/镜像的元数据 123456[root@caoxl ~]# docker inspect nginx[ &#123; \"Id\": \"2b077bf72f07ffa1e4e821f02bced02f9265900cc8c0b4dd663a3f90ebb2e8dc\", \"Created\": \"2019-05-15T07:20:48.265101617Z\",... top - 查看容器中运行的进程信息 1234567[root@caoxl ~]# docker top nginxUID PID PPID C STIME TTY TIME CMDroot 27933 27916 0 15:36 ? 00:00:00 nginx: master process nginx -g daemon off;101 27965 27933 0 15:36 ? 00:00:00 nginx: worker process# 查看所有运行容器的进程信息for i in `docker ps |grep Up|awk '&#123;print $1&#125;'`;do echo \\ &amp;&amp;docker top $i; done attach - 连接到正在运行的容器 1[root@caoxl ~]# docker attach --sig-proxy=false nginx logs - 获取容器的日志 1234[root@caoxl ~]# docker logs -f nginx# 查看容器nginx从2019年5月15后的最新10条日志[root@caoxl ~]# docker logs --since=\"2019-05-15\" --tail=10 nginx port - 列出指定的容器的端口映射，或者查找将PRIVATE_PORT NAT到面向公众的端口。 12[root@caoxl ~]# docker port caoxl-nginx80/tcp -&gt; 0.0.0.0:8081 容器rootfs命令 commit - 从容器创建一个新的镜像 12345678# 从容器创建一个新的镜像[root@caoxl ~]# docker commit -a \"caoxl\" -m \"docker commit\" f1069837f3eb redis:commitsha256:2d77296f02fa8a37890e686a5bc07f4173229044bc53f811b4821244f5db3563[root@caoxl ~]# docker images | grep redisredis commit 2d77296f02fa 19 seconds ago 95MBredis 5.0 a4fe14ff1981 7 days ago 95MBredis latest a4fe14ff1981 7 days ago 95MB cp - 用于容器和主机直接的数据拷贝 12# 将主机/var/www目录拷贝到容器f1069837f3eb的/www目录下。[root@caoxl ~]# docker cp /var/www f1069837f3eb:/www/ 镜像仓库 login/logout - 登陆/退出一个Docker镜像仓库,默认为官方仓库 Docker Hub 前往Docker Hub,注册账号. 123456789101112# 登陆[root@caoxl ~]# docker login -u username -p passwordWARNING! Using --password via the CLI is insecure. Use --password-stdin.WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded# 登出[root@caoxl ~]# docker logoutRemoving login credentials for https://index.docker.io/v1/ pull - 从镜像仓库中拉取或者更新指定镜像 1[root@caoxl ~]# docker pull swoft/swoft push - 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库 12[root@caoxl ~]# docker push php:7.2-fpmThe push refers to repository [docker.io/library/php] search - 从Docker Hub查找镜像 123456root@caoxl ~]# docker search swooleNAME DESCRIPTION STARS OFFICIAL AUTOMATEDxlight/docker-php7-swoole php7-cli with swoole 28 [OK]twosee/swoole-coroutine Perfect Swoole Dockerfile for senior develop… 27 [OK]kong36088/nginx-php7-swoole nginx+php7+swoole拓展，另外自带redis和memcac… 14 ... 本地镜像管理 images - 列出本地镜像 1234567[root@caoxl ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEredis 5.0 a4fe14ff1981 7 days ago 95MBphp 7.2-fpm 0be748e55df6 7 days ago 366MBnginx latest 53f3fd8007f7 7 days ago 109MBmysql 5.7 7faa3c53e6d6 7 days ago 373MBswoft/swoft latest 493b8cc21299 3 months ago 447MB rmi - 删除本地一个或多个镜像 123[root@caoxl ~]# docker rmi 2d77296f02faUntagged: redis:commitDeleted: sha256:2d77296f02fa8a37890e686a5bc07f4173229044bc53f811b4821244f5db3563 参数说明: -f: 强制删除 --no-prune: 不移除该镜像的过程镜像,默认移除 tag - 标记本地镜像,将其归入某一个仓库 12345[root@caoxl ~]# docker tag swoft/swoft:latest swoft/swoft:swoft[root@caoxl ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEswoft/swoft latest 493b8cc21299 3 months ago 447MBswoft/swoft swoft 493b8cc21299 3 months ago 447MB history - 查看指定镜像的创建历史 12345678910111213# 查看本地镜像nginx的创建历史[root@caoxl ~]# docker history nginxIMAGE CREATED CREATED BY SIZE COMMENT53f3fd8007f7 7 days ago /bin/sh -c #(nop) CMD [\"nginx\" \"-g\" \"daemon… 0B &lt;missing&gt; 7 days ago /bin/sh -c #(nop) STOPSIGNAL SIGTERM 0B &lt;missing&gt; 7 days ago /bin/sh -c #(nop) EXPOSE 80 0B &lt;missing&gt; 7 days ago /bin/sh -c ln -sf /dev/stdout /var/log/nginx… 22B &lt;missing&gt; 7 days ago /bin/sh -c set -x &amp;&amp; apt-get update &amp;&amp; apt… 54.1MB &lt;missing&gt; 7 days ago /bin/sh -c #(nop) ENV NJS_VERSION=1.15.12.0… 0B &lt;missing&gt; 7 days ago /bin/sh -c #(nop) ENV NGINX_VERSION=1.15.12… 0B &lt;missing&gt; 7 days ago /bin/sh -c #(nop) LABEL maintainer=NGINX Do… 0B &lt;missing&gt; 7 days ago /bin/sh -c #(nop) CMD [\"bash\"] 0B &lt;missing&gt; 7 days ago /bin/sh -c #(nop) ADD file:fcb9328ea4c115670… 55.3MB info|version info - 显示Docker系统信息,包括镜像和容器数 12345678# 查看Docker系统信息[root@caoxl ~]# docker infoContainers: 5 Running: 4 Paused: 0 Stopped: 1Images: 5... version - 显示Docker版本信息 12345678910111213141516171819[root@caoxl ~]# docker versionClient: Version: 18.09.6 API version: 1.39 Go version: go1.10.8 Git commit: 481bc77156 Built: Sat May 4 02:34:58 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.6 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 02:02:43 2019 OS/Arch: linux/amd64 Experimental: false 常见问题image is referenced in multiple repositories 查看镜像 1234567[root@caoxl ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEphp 7.2-fpm 0be748e55df6 7 days ago 366MBnginx latest 53f3fd8007f7 7 days ago 109MBmysql 5.7 7faa3c53e6d6 7 days ago 373MBpinguo/php-msf-demo newdev 39995bac5087 18 months ago 1.54GBregistry.cn-hangzhou.aliyuncs.com/pinguo-ops/php-msf-docker latest 39995bac5087 18 months ago 1.54GB 删除镜像 12[root@caoxl ~]# docker rmi 39995bac5087Error response from daemon: conflict: unable to delete 39995bac5087 (must be forced) - image is referenced in multiple repositories 仔细观察，发现39995bac5087这个镜像id指向了两个repository，因此无法删除 删除时可以用repository和tag的方式来删除 1234[root@caoxl ~]# docker rmi pinguo/php-msf-demo:newdevUntagged: pinguo/php-msf-demo:newdevDeleted: sha256:39995bac5087fa922c2eed5f75ae55fce3b08a0d691cd200d5c1c2879660398f.... 再次查看镜像 12345[root@caoxl ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEphp 7.2-fpm 0be748e55df6 7 days ago 366MBnginx latest 53f3fd8007f7 7 days ago 109MBmysql 5.7 7faa3c53e6d6 7 days ago 373MB Docker 资源汇总Docker官方英文资源 Docker官网 Docker Windows 入门 Docker CE(社区版) CentOs Docker mac 入门 Docker 用户指引 Docker 官方博客 Docker Hub Docker开源 Docker国内镜像 阿里云官方镜像加速: https://help.aliyun.com/document_detail/60750.html 网易加速器: http://hub-mirror.c.163.com 参考 Docker Docker 教程","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.caoxl.com/tags/Docker/"},{"name":"CentOs","slug":"CentOs","permalink":"http://blog.caoxl.com/tags/CentOs/"}]},{"title":"CentOs 安装Docker","slug":"CentOs-Install-Docker","date":"2019-05-15T02:55:47.000Z","updated":"2019-05-16T02:45:57.000Z","comments":true,"path":"2019/05/15/CentOs-Install-Docker/","link":"","permalink":"http://blog.caoxl.com/2019/05/15/CentOs-Install-Docker/","excerpt":"Docker支持以下的CentOs版本 CentOs(64-bit) CentOS 6.5 (64-bit) 或更高的版本","text":"Docker支持以下的CentOs版本 CentOs(64-bit) CentOS 6.5 (64-bit) 或更高的版本 使用yum安装Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的 CentOS 版本是否支持 Docker 。 12[root@caoxl ~]# uname -r3.10.0-862.14.4.el7.x86_64 安装Docker 从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。本文介绍 Docker CE 的安装使用。 1234567891011121314151617181920212223242526272829303132333435# 清理镜像/容器sudo docker stop `sudo docker ps -aq`sudo docker rm `sudo docker ps -aq`sudo docker rmi -f `sudo docker images -aq`# 移除旧版本sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine# 如果`yum`删除不干净,可以使用rpm手动再检查一遍rpm -qa | grep dockerrpm -e docker # yum remove -y docker# 安装一些必要的系统工具sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 添加软件源信息sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 更新yum缓存sudo yum makecache fast# 安装 docker-cesudo yum -y install docker-ce# 启动docker后台服务sudo systemctl start docker 测试运行hello-world 123456789101112131415161718192021222324252627[root@caoxl ~]# docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world1b930d010525: Pull complete Digest: sha256:5f179596a7335398b805f036f7e8561b6f0e32cd30a32f5e19d17a3cda6cc33dStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。 使用脚本安装Docker 使用 sudo 或 root 权限登录 CentOs。 确保 yum 包更新到最新。 1sudo yum update 执行 Docker 安装脚本。 12curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh 执行这个脚本会添加 docker.repo 源并安装 Docker。 启动 Docker 进程。 1sudo systemctl start docker 验证 docker 是否安装成功并在容器中执行一个测试的镜像。 123456789101112131415161718192021sudo docker run hello-world[root@caoxl ~]# docker versionClient: Version: 18.09.6 API version: 1.39 Go version: go1.10.8 Git commit: 481bc77156 Built: Sat May 4 02:34:58 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.6 API version: 1.39 (minimum version 1.12) Go version: go1.10.8 Git commit: 481bc77 Built: Sat May 4 02:02:43 2019 OS/Arch: linux/amd64 Experimental: false 镜像加速鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：http://hub-mirror.c.163.com。 新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\\docker\\config\\daemon.json（Windows） 来配置 Daemon。 请在该配置文件中加入（没有该文件的话，请先建一个）： 123&#123; \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]&#125; 阿里云 镜像加速器 配置镜像加速器 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; \"registry-mirrors\": [\"https://cmfb75j3.mirror.aliyuncs.com\"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 删除Docker CE12sudo yum remove docker-cesudo rm -rf /var/lib/docker 文档 Docker-Get-Start","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.caoxl.com/tags/Docker/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"PHP 代码检测工具","slug":"PHP-Code-Detection-Tool","date":"2019-05-09T03:20:22.000Z","updated":"2019-05-14T06:20:26.000Z","comments":true,"path":"2019/05/09/PHP-Code-Detection-Tool/","link":"","permalink":"http://blog.caoxl.com/2019/05/09/PHP-Code-Detection-Tool/","excerpt":"CV大法好,好就好在TMDB接手一外包代码你就知道有多惨","text":"CV大法好,好就好在TMDB接手一外包代码你就知道有多惨 phpcpd - 用于PHP代码的复制/黏贴检测器 phpcpd - PHP Copy/Paste Detector 123456789# 安装composer require --dev sebastian/phpcpd# 使用 (使用vendor/bin/phpcpd可执行文件调用它, 也可以配置PATH)phpcpd --fuzzy /项目目录/# 直接导出phpcpd --fuzzy /项目目录/ &gt; /导出文件/phpcpd --fuzzy ./App &gt; ./app.txt phpdcd - PHP代码的死代码检测器 phpdcd - PHP Dead Code Detector 12# 安装composer global require 'sebastian/phpdcd=*' phpcs - PHP代码质量检测器 phpcs - PHP Code Sniffer 12# 安装composer global require \"squizlabs/php_codesniffer=*\" 安装完后就会在全局的 Vendor 目录下的 bin 中生成两个软链接： 12phpcbf -&gt; ../squizlabs/php_codesniffer/bin/phpcbfphpcs -&gt; ../squizlabs/php_codesniffer/bin/phpcs 格式化前 1234567891011121314&lt;?phpnamespace App\\Http\\Controllers;use App\\Traits\\Tool;class TestController extends Controller&#123; public function test_i18n()&#123; return Tool::sysMsg('SYS_MSG_TEST'); &#125; public function test_i18n2()&#123; return Tool::sysMsg('SYS_MSG_TEST', 'en'); &#125;&#125; phpcs 12345678910111213141516171819$ phpcs TestController.phpFILE: D:\\app\\phpStudy\\PHPTutorial\\WWW\\Lumen\\app\\Http\\Controllers\\TestController.php----------------------------------------------------------------------------------------------FOUND 8 ERRORS AFFECTING 4 LINES---------------------------------------------------------------------------------------------- 2 | ERROR | [ ] Missing file doc comment 4 | ERROR | [ ] Missing doc comment for class TestController 6 | ERROR | [ ] Missing doc comment for function test_i18n() 6 | ERROR | [ ] Public method name \"TestController::test_i18n\" is not in camel caps format 6 | ERROR | [x] Opening brace should be on a new line 10 | ERROR | [ ] Missing doc comment for function test_i18n2() 10 | ERROR | [ ] Public method name \"TestController::test_i18n2\" is not in camel caps format 10 | ERROR | [x] Opening brace should be on a new line----------------------------------------------------------------------------------------------PHPCBF CAN FIX THE 2 MARKED SNIFF VIOLATIONS AUTOMATICALLY----------------------------------------------------------------------------------------------Time: 75ms; Memory: 4MB phpcbf 123456789101112$ phpcbf TestController.phpPHPCBF RESULT SUMMARY--------------------------------------------------------------------------------------------------FILE FIXED REMAINING--------------------------------------------------------------------------------------------------D:\\app\\phpStudy\\PHPTutorial\\WWW\\Lumen\\app\\Http\\Controllers\\TestController.php 2 6--------------------------------------------------------------------------------------------------A TOTAL OF 2 ERRORS WERE FIXED IN 1 FILE--------------------------------------------------------------------------------------------------Time: 79ms; Memory: 4MB 格式化后 123456789101112131415161718&lt;?phpnamespace App\\Http\\Controllers;use App\\Traits\\Tool;class TestController extends Controller&#123; public function test_i18n() &#123; return Tool::sysMsg('SYS_MSG_TEST'); &#125; public function test_i18n2() &#123; return Tool::sysMsg('SYS_MSG_TEST', 'en'); &#125;&#125; 参考 phpcpd PHP Copy/Paste Detector phpdcd PHP Dead Code Detector phpcs PHP 系列：代码规范之 Code Sniffer PHP 系列：代码规范之 Mess Detector","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"phpcpd","slug":"phpcpd","permalink":"http://blog.caoxl.com/tags/phpcpd/"}]},{"title":"PHP面试/笔试题杂记 I","slug":"Interview-Questions-Notes","date":"2019-05-08T02:58:43.000Z","updated":"2019-08-22T03:12:22.000Z","comments":true,"path":"2019/05/08/Interview-Questions-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/05/08/Interview-Questions-Notes/","excerpt":"每次面试或者说每次看面试题笔试题总能发现一些自己不熟悉,或者说自己平时会忽略的点所以决定平时常看看笔试题有助于提高自己!","text":"每次面试或者说每次看面试题笔试题总能发现一些自己不熟悉,或者说自己平时会忽略的点所以决定平时常看看笔试题有助于提高自己! 问题无先后,看到什么或者想起什么就查询并且记录下. MySQL事务是什么 ? 什么是事务 ? 一个事务必须满足四个条件: 原子性,一致性,隔离性,持久性 原子性: 一个事务中的操作要么全部完成,要么全部不完成 一致性: 之物开始前后,数据库的完整性没有破坏 隔离性: 未提交读(RU),提交读(RC),可重复读(RR),串行话(Serializable) 持久性: 事务结束会后对书画家的修改是永久的 事务命令 begin 开始事务 rollback 回滚事务 commit 提交事务 MySQl中只有Innodb引擎支持事务 PHP代码解释过程 ?12345&lt;?phpecho \"Hello world\",$a = 1 + 1;echo $a; PHP执行代码有以下四个步骤 Scanning(Lexing), 将PHP代码转换为语言片段(Tokens) Parsing, 将Tokens转换成简单而有意义的表达式 Compilation, 将表达式编译成Opcodes Execution, 顺次执行Opcodes,每次一条,从而实现PHP脚本的功能 如何共享Session ? 为什么要共享session ? 假设某个网站是由多台服务器提供服务，nginx采用轮询机制做负载均衡，那么同一个IP访问该网站时，请求就可能会被分配到不同的服务器上,如果session没有实现共享,就回出现重复登陆授权的情况 共享session的几种方式 基于NFS的session共享: NFS(Net FileSystem,网络文件系统),即将session存储目录挂载到所有的服务器上，实现session的读写 基于Cookie的session共享 基于数据库的session共享 基于Memcache/Redis的session共享 git分支管理策略 答: master做主分支,dev做开发分支,bug_fix做bug分支 问: 有个临时bug需要改,而我们在dev上已经开发了很多内容了,怎么办? 答: bug_fix分支拉master,处理完再合并回master,问题是会和dev的相同模块冲突 解决: 使用git rebase变基实现 1git rebase --onto master server client 以上命令的意思是：“取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后把它们在 master 分支上重放一遍” Restful 设计 GET (SELECT): 从服务器取出资源(一项或多项) POST (CREATE): 从服务器新建一个资源 PUT (UPDATE): 在服务器更新资源 (客户端提供改变后的完整资源, 简单来说更新完整资源) PATCH (UPDATE): 在服务器更新资源 (客户端提供改变的属性, 简单来说更新部分资源) DELETE (DELETE): 从服务器删除资源 HEAD: 获取资源的元数据 OPTIONS: 获取信息, 关于资源的哪些属性是客户端可以改变的 了解哪些设计模式, 实际用例 ? 工厂模式: 定义一个标准, 用到的类可以按这个标准实现相应功能 单例模式: 防止重复实例化, 减少资源调用 数据映射模式: 数据库ORM应用 装饰器模式: 兼容老数据,多态的应用 怎么兼容老数据? Ajax跨域请求时，会出现什么问题 ？如何解决 ? Ajax跨域请求的问题 ? 因为浏览器同源策略导致请求跨域错误. 可能出现一下几种问题: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 404 解决方案: 后端运行options请求 No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且The response had HTTP status code 405 解决方案: 后端关闭对应的安全配置 No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource,并且status 200 解决方案: 后端增加对应的头部支持 heade contains multiple values &#39;*,*&#39; 解决方案: 建议删除代码中手动添加的, 只用项目配置中的即可;建议删除ISS下的配置,只用项目配置中的即可 ajax跨域，这应该是最全的解决方案了 如何解决? JSONP: 因为 &lt;script&gt; 脚本拥有跨域能力 CORS (Cross-Origin-Resource-Sharing, 跨域资源共享) 代理请求: node.js,代理请求 redis异步队列实现细节 ? redis提供了两种方式来做消息队列 生产者消费模式(PUSH/POP机制) 让一个或者多个客户端监听消息队列, 一旦消息到达,消费者马上消费,谁先抢到算谁的，如果队列里没有消息，则消费者继续监听. 发布订阅者模式(PUB/SUB机制) 一个或者多个客户端订阅消息频道,只要发布者发布消息,所有订阅者都能收到消息,订阅者是平等的. 如何实现 ? 以Laravel为例: 使用list,通过lpush入队列,rpop出队列处理任务 使用php artisan queue:work开启后台进程监视队列,并完成任务 通过dispatch()触发任务 redis中zest如何根据两个属性排序，比如id和age Redis中用于实现排序功能的是SORT命令 但是Redis并不擅长排序,可以将操作放到业务或者DB中处理,使Redis仅仅起一个缓存作用. 你对多进程和多线程还有协程的理解 ? 进程多与线程比较 线程是指进程内的一个执行单元,也是进程内的可调度实体, 区别: 地址空间: 多个线程共享进程的地址空间,进程有自己独立的地址空间 资源拥有: 进程是资源分配和拥有的单位,同一个进程内线程共享进程的资源 线程是处理器调度的基本单位,进程不是 二者均可以并发执行 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中 协程多与线程比较 一个线程可以多个协程,一个进程也可以单独拥有多个协程 线程进程都是同步机制,而协程则是异步 协程能保留上一次调用时的状态,每次过程重入时,就相当于进入上一次调用的状态. nginx负载均衡和反向代理 ? 什么是负载均衡 ? 负载均衡是高可用网络基础架构的关键组件，通常用于将工作负载分布到多个服务器来提高网站、应用、数据库或其他服务的性能和可靠性。 12345678910upstream myapp &#123; server 192.168.20.1:8080; # 应用服务器1 server 192.168.20.2:8080; # 应用服务器2&#125;server &#123; listen 80; location / &#123; proxy_pass http://myapp; &#125;&#125; 负载均衡算法: Round Robin (轮询): 为第一个请求选择列表中的第一个服务器，然后按顺序向下移动列表直到结尾，然后循环。 Least Connections (最小连接): 优先选择连接数最少的服务器，在普遍会话较长的情况下推荐使用。 Source: 根据请求源的 IP 的散列（hash）来选择要转发的服务器。这种方式可以一定程度上保证特定用户能连接到相同的服务器。 什么是反向代理 ? 反向代理是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器簇的存在 123456server &#123; listen 80; location / &#123; proxy_pass http://192.168.20.1:8080; # 应用服务器HTTP地址 &#125;&#125; php-fpm能代理其他端口吗? 除了默认9000. 什么是php-fpm ? PHP-FPM是PHP的一个FastCGI管理器 FastCGI，顾名思义就是更快的CGI程序，用来提高CGI程序性能，它允许在一个进程内处理多个请求，而不是一个请求处理完毕就直接结束进程，性能上有了很大的提高。 所以可以是任何一个没有被占用的端口 nginx配置php-fpm的时候走的是什么协议? 还可以走其他协议吗? CGI协议,FastCGI协议 当我们访问一个网站,如www.test.com的时候，处理流程是这样的： 12345678910111213141516171819 www.test.com | | Nginx | |路由到 www.test.com/index.php | |加载 nginx 的 fast-cgi 模块 | |fast-cgi 监听 127.0.0.1:9000 地址 | |www.test.com/index.php 请求到达 127.0.0.1:9000 | | 等待处理... BTree 和 B+tree ? BTree: B树是为了磁盘或者其他存储设备而设计的一种多叉平衡查找树,相对于二叉树，B树的每个内节点有多个分支，即多叉。 B+Tree: B+树是B树的变体,也是一种多路搜索树 三次握手,四次挥手, 为什么是三次握手四次挥手? 三次握手: 第一次握手:A与B建立TCP连接时,首先A向B发送SYN(同步请求) 第二次握手:然后B回复SYN+ACK(同步请求应答) 第三次握手:最后A回复ACK确认 四次挥手: TCP的连接的拆除需要发送四个包,因此称为4次挥手.客户端或服务器均可主动发起挥手动作 长连接和短连接 ? TCP短连接 client向server发起连接请求 server接到请求,双方建立连接 client向server发消息 server回应client 一次读写完成,此时双方任何一个都可以发起close操作一般都是client先发起close操作,因为一般的server不会回复完client就立即关闭连接 TCP长连接 client向server发起连接 server接到请求后,双方建立连接 client向server发送消息 server回应client 一次读写完成,连接不关闭 后续读写操作 长/短连接的优缺点 长连接可以省去较多的TCP建立和关闭操作，减少资源浪费，节省时间，对于比较频繁的请求资源的客户端比较适用于长连接 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段 从浏览器输入域名到展示页面都发送了什么 ? DNS域名解析 先找本地host文件,检查对呀域名ip的关系,有则向ip地址发送请求,没有再去找DNS服务器 建立TCP连接 拿到服务器IP后,向服务器发送请求,三次握手,建立TCP连接 简单理解三次握手: 客户端: 您好,在家不,有你快递 服务端: 在的,送来吧 客户端: 好滴,来了 发送HTTP请求 与服务器建立连接后,就可以向服务器发起请求了,具体请求内容可以再浏览器中查看 服务器处理请求 服务器收到请求后由web服务器（Apache，Nginx）处理请求,web服务器解析用户请求，知道了需要调用那些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库等，然后将结果通过web服务器返回给浏览器 返回响应结果 在响应结果中都会有一个HTTP状态码,诸如我们熟知的200、404、500等 状态码都是由三位熟知和原因短语组成的,大致分5类: 1XX 信息状态码,接受的请求正在处理 2XX 成功状态码,请求正常处理完毕 3XX 重定向状态码,需要附加操作以完成请求 4XX 客户端错误状态码,服务器也无法处理的请求 5XX 服务器错误状态码,服务器请求处理出错 关闭TCP连接 为了避免服务器与客户端双方资源占用和消耗，当双方没有请求或者响应传递时，任意一方都可以发起关闭请求，与创建TCP连接的三次握手类似，关闭TCP连接需要4次挥手 简单理解四次挥手: 客户端: 哥们,我这边没有数据要传了,咱们关闭连接吧 服务端: 好的,我看看我这边还有数据不 服务端: 兄弟, 我这边也没有数据要传给你了, 咱们可以关闭连接了 客户端: 好勒 浏览器解析HTML 浏览器布局渲染 队列和栈的区别 ? 什么是队列? 什么是栈? 队列(Queue): 是限定只能在表的一端进行插入和在另外一端删除操作的线性表 栈(Stack): 是限定只能在表的一端进行插入和删除操作的线性表 队列和栈的规则 队列: 先进先出 栈: 先进后出 队列和栈的遍历数据速度 队列: 基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快 栈: 只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同事需要微数据开辟临时空间，保持数据在遍历前的一致性。 GET和POST提交方式的区别 ? GET产生一个TCP数据包;POST产生两个TCP数据包 对于GET请求,浏览器会吧http header和data一并发送出去,服务器响应200 ok(返回数据) 对于POST请求,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器返回200 ok(返回数据) GET在浏览器回滚时是无害的,而POST会再次提交请求 GET请求会被浏览器主动cache,而POST不会,除非手动设置 GET请求参数会被完整保留在浏览器历史记录里,而POST中的参数不会被保留 GET请求只能进行url编码,而POST支持多种编码方式 GET比POST更不安全,因为参数直接暴露在URL上,所以不能用来传递敏感信息 请列举你熟悉的Linux命令(越多越好) ls ll pwd cd cp mv rm mkdir rmdir touch vim vi head tail diff cat echo useradd userdel chown chmod passwd top iotop vmstat df du find grep xargs wed wc whatis info man which whereis whoami who w hostname uname tar gzip gunzip kill pkill lsof sar free watch netstat route ping wget make ssh sftp scp 如何实现单点登录 ? 什么是单点登录 ? 单点登录(Single Sign On,简称SSO,在多个应用系统中,用户只需要登录一次就可以访问所有相互信任的应用系统) 如何实现单点登录 ? 实现session共享 用户权限如何而设计 ? user 用户表 role 角色表 permission 权限表 role-user 用户角色关联表 role-permission 角色权限关联表 后续待更…","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"PHP面试","slug":"PHP面试","permalink":"http://blog.caoxl.com/tags/PHP面试/"},{"name":"笔试","slug":"笔试","permalink":"http://blog.caoxl.com/tags/笔试/"}]},{"title":"Linux Tools Quick Tutorial","slug":"Linux-Tools-Quick-Tutorial","date":"2019-05-06T02:12:05.000Z","updated":"2019-05-06T08:49:36.000Z","comments":true,"path":"2019/05/06/Linux-Tools-Quick-Tutorial/","link":"","permalink":"http://blog.caoxl.com/2019/05/06/Linux-Tools-Quick-Tutorial/","excerpt":"Linux基础","text":"Linux基础 原文地址在上面,此处是我复习Linux 命令的. Linux 基础帮助命令123456789101112131415161718192021222324# 简要说明命令的作用[root@caoxl ~]# whatis lsls (1) - list directory contents# 详细的说明文档[root@caoxl ~]# info ls...# 查询命令的说明文档[root@caoxl ~]# man ls...# 显示命令的参数[root@caoxl ~]# ls --help...# 查看程序的binary文件所在路径:[root@caoxl ~]# which lsalias ls='ls --color=auto' /usr/bin/ls# 查看程序的搜索路径:[root@caoxl ~]# whereis lsls: /usr/bin/ls /usr/share/man/man1/ls.1.gz 总结whatis info man which whereis 文件及目录管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# 创建目录[root@caoxl ~]# mkdir dir# 删除目录[root@caoxl ~]# rm -rf dir/# 移动[root@caoxl dir]# mv 1.log ../11.log# 复制文件[root@caoxl ~]# cp 11.log ./dir/1.log# 复制目录[root@caoxl ~]# cp -r dir ./dir2# 显示当前路径[root@caoxl ~]# pwd/root# 创建空文件[root@caoxl ~]# touch 1.log[root@caoxl ~]# touch 2.log[root@caoxl ~]# touch 3.log[root@caoxl ~]# ls1.log 2.log 3.log# 删除日志[root@caoxl ~]# rm *logrm: remove regular empty file ‘1.log’? yrm: remove regular empty file ‘2.log’? yrm: remove regular empty file ‘3.log’? y[root@caoxl ~]# ls# 查看当前目录下文件个数[root@caoxl dir]# find ./ | wc -l4# 搜寻文件或目录[root@caoxl ~]# find ./ -name \"dir*\" | xargs file./dir2: directory./dir2/dir: directory./dir: directory# 查找目标文件夹中是否有.log文件[root@caoxl ~]# find ./ -name \"*.log\"./dir/2.log./dir/1.log./dir/3.log# 递归当前目录及子目录删除所有.log文件:[root@caoxl dir]# find ./ -name \"*.log\" -exec rm &#123;&#125; \\;# 显示内容同时显示行号[root@caoxl ~]# cat -n dir.txt# 按页显示列表内容 [root@caoxl ~]# ls -al | more# 显示前面几行(默认10行)[root@caoxl ~]# head dir.txt# 显示后面几行(默认10行)[root@caoxl ~]# tail dir.txt# 查看两个文件间的差别[root@caoxl ~]# diff dir.txt dir2.txt# 动态显示文本最新信息[root@caoxl ~]# tail -f caoxl.log# 文件与目录权限修改[root@caoxl ~]# lltotal 0-rw-r--r-- 1 root root 0 May 6 11:28 test.php[root@caoxl ~]# chown www:www test.php [root@caoxl ~]# lltotal 0-rw-r--r-- 1 www www 0 May 6 11:28 test.php# 增加脚本可执行权限[root@caoxl ~]# chmod a+x test.php [root@caoxl ~]# lltotal 0-rwxr-xr-x 1 www www 0 May 6 11:28 test.php# 修改脚本可执行权限[root@caoxl ~]# chmod -R 777 test.php [root@caoxl ~]# lltotal 0-rwxrwxrwx 1 www www 0 May 6 11:28 test.php# 批处理命令连接执行,使用 |[root@caoxl ~]# ls /var &amp;&amp; echo suss! || echo failed.adm crash empty gopher lib lock mail opt run tmp ypcache db games kerberos local log nis preserve spool wwwsuss!# 重定向[root@caoxl ~]# cat test.php&lt;?phpecho 1024;[root@caoxl ~]# echo hello &gt;&gt; test.php[root@caoxl ~]# cat test.php&lt;?phpecho 1024;hello# 查找test.php中包含1024,但不包含hello的记录的总数 [root@caoxl ~]# cat -v test.php | grep 1024 | grep -v hello | wc -l1 总结文件管理,目录的创建、删除、查询、管理: mkdir rm mv cp 文件的查询和检索: find locate 查看文件内容: cat vi head tail more diff 文件所有者、权限: chown chmod 管道和重定向: | &amp;&amp; &gt; 文本处理 find 文件查找 12# 查找txt和pdf文件[root@caoxl ~]# find . \\( -name \"*.txt\" -o -name \"*.pdf\" \\) -print grep 文本搜索 12[root@caoxl ~]# ps -ef | grep mysqlroot 1437 32022 0 14:44 pts/1 00:00:00 grep --color=auto mysql xargs 命令行参数转换 12[root@caoxl ~]# cat test.php | xargs&lt;?php echo 1024; hello sort 排序 uniq 消除重复行 1234567891011121314151617[root@caoxl ~]# cat test.php &lt;?phpecho 1024;hellohello# 消除重复行[root@caoxl ~]# sort test.php | uniqecho 1024;hello&lt;?php# 找出重复行[root@caoxl ~]# sort test.php | uniq -dhello wc 统计行和字符的工具 1234567891011# 统计行数[root@caoxl ~]# wc -l test.php5 test.php# 统计单词数[root@caoxl ~]# wc -w test.php5 test.php# 统计字符数[root@caoxl ~]# wc -c test.php30 test.php 总结find grep xargs sort uniq wc 磁盘管理 查看磁盘空间 12345678910111213141516171819202122# 查看磁盘空间利用大小[root@caoxl ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 7.7G 30G 21% /devtmpfs 1.9G 0 1.9G 0% /devtmpfs 1.9G 0 1.9G 0% /dev/shmtmpfs 1.9G 488K 1.9G 1% /runtmpfs 1.9G 0 1.9G 0% /sys/fs/cgrouptmpfs 379M 0 379M 0% /run/user/0[root@caoxl ~]# df -ThFilesystem Type Size Used Avail Use% Mounted on/dev/vda1 ext4 40G 7.7G 30G 21% /devtmpfs devtmpfs 1.9G 0 1.9G 0% /devtmpfs tmpfs 1.9G 0 1.9G 0% /dev/shmtmpfs tmpfs 1.9G 488K 1.9G 1% /runtmpfs tmpfs 1.9G 0 1.9G 0% /sys/fs/cgrouptmpfs tmpfs 379M 0 379M 0% /run/user/0# 查看当前目录所占空间大小[root@caoxl ~]# du -sh *8.0K test -h: human缩写，以易读的方式显示结果（即带单位：比如M/G，如果不加这个参数，显示的数字以B为单位）-s 递归整个目录的大小 打包/解包 &amp;&amp; 压缩/解压缩 1234567891011# 仅打包 不压缩[root@caoxl test]# tar -cvf test.tar ./*# 压缩[root@caoxl test]# gzip test.tar# 解包[root@caoxl test]# tar -xvf test.tar# 解压缩[root@caoxl test]# gunzip test.tar.gz 总结查看磁盘空间: df -Th 查看目录大小: du -sh 打包/解包&amp;&amp;压缩/解压缩: tar -cvf tar -xvf gzip gunzip bzip 进程管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$ 查询进程[root@caoxl ~]# ps -ef | grep phproot 900 1 0 Jan28 ? 00:05:12 php-fpm: master process (/usr/local/php/php56/etc/php-fpm.conf)www 903 900 0 Jan28 ? 00:00:00 php-fpm: pool wwwwww 904 900 0 Jan28 ? 00:00:00 php-fpm: pool wwwroot 2936 32022 0 15:14 pts/1 00:00:00 grep --color=auto php# 查看进程名中含有ssh的进程(适合只记得部分进程字段)[root@caoxl ~]# pgrep -l ssh2563 sshd19320 sshd32019 sshd# 以完整的格式显示所有的进程[root@caoxl ~]# ps -ajx PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 0 1 1 1 ? -1 Ss 0 7:30 /usr/lib/systemd/systemd --swit 0 2 0 0 ? -1 S 0 0:00 [kthreadd] 2 3 0 0 ? -1 S 0 0:05 [ksoftirqd/0] 2 5 0 0 ? -1 S&lt; 0 0:00 [kworker/0:0H] 2 7 0 0 ? -1 S 0 0:07 [migration/0]# 显示进程信息,并实时更新[root@caoxl ~]# toptop - 15:20:40 up 98 days, 4:24, 2 users, load average: 0.00, 0.01, 0.05Tasks: 81 total, 1 running, 80 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.2 us, 0.0 sy, 0.0 ni, 99.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 3880936 total, 2290276 free, 178560 used, 1412100 buff/cacheKiB Swap: 2097148 total, 2097148 free, 0 used. 3397572 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 51728 3484 2192 S 0.0 0.1 7:30.73 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.05 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:05.38 ksoftirqd/0 # 查看端口占用的进程状态[root@caoxl ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 3947 mysql 21u IPv6 2088379 0t0 TCP *:mysql (LISTEN)# 查看用户root的进程所打开的文件 [root@caoxl ~]# lsof -u root# 杀死进程[root@caoxl ~]# kill -9 3306# 分析线程堆栈[root@caoxl ~]# ps -ef | grep redisroot 4325 32022 0 15:37 pts/1 00:00:00 grep --color=auto redis[root@caoxl ~]# pmap 3202232022: -bash0000000000400000 884K r-x-- bash00000000006dd000 4K r---- bash00000000006de000 36K rw--- bash00000000006e7000 24K rw--- [ anon ]000000000110e000 2576K rw--- [ anon ]... 总结ps top lsof kill pmap 性能监控123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 查看CPU使用率[root@caoxl ~]# sar -uLinux 3.10.0-862.14.4.el7.x86_64 (caoxl) 05/06/2019 _x86_64_ (2 CPU)12:00:01 AM CPU %user %nice %system %iowait %steal %idle12:10:01 AM all 0.01 0.00 0.01 0.00 0.00 99.9712:20:01 AM all 0.01 0.02 0.01 0.00 0.00 99.9512:30:01 AM all 0.01 0.00 0.01 0.00 0.00 99.98# 查看CPU平均负载 (表示每秒采样一次，总共采样2次;)[root@caoxl ~]# sar -q 1 2Linux 3.10.0-862.14.4.el7.x86_64 (caoxl) 05/06/2019 _x86_64_ (2 CPU)03:40:06 PM runq-sz plist-sz ldavg-1 ldavg-5 ldavg-15 blocked03:40:07 PM 0 126 0.00 0.01 0.05 003:40:08 PM 0 126 0.00 0.01 0.05 0Average: 0 126 0.00 0.01 0.05 0# 查询内存[root@caoxl ~]# sar -r 1 2Linux 3.10.0-862.14.4.el7.x86_64 (caoxl) 05/06/2019 _x86_64_ (2 CPU)03:42:14 PM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty03:42:15 PM 2192724 1688212 43.50 334600 702232 1055296 17.65 726812 530364 003:42:16 PM 2192724 1688212 43.50 334600 702232 1055296 17.65 726812 530364 0Average: 2192724 1688212 43.50 334600 702232 1055296 17.65 726812 530364 0# 查看内存使用量[root@caoxl ~]# free -m total used free shared buff/cache availableMem: 3789 263 2141 0 1384 3228Swap: 2047 0 2047# 查询页面交换[root@caoxl ~]# sar -W 1 3Linux 3.10.0-862.14.4.el7.x86_64 (caoxl) 05/06/2019 _x86_64_ (2 CPU)03:44:38 PM pswpin/s pswpout/s03:44:39 PM 0.00 0.0003:44:40 PM 0.00 0.0003:44:41 PM 0.00 0.00Average: 0.00 0.00# 查询磁盘使用[root@caoxl ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 7.8G 30G 21% /devtmpfs 1.9G 0 1.9G 0% /devtmpfs 1.9G 0 1.9G 0% /dev/shmtmpfs 1.9G 488K 1.9G 1% /runtmpfs 1.9G 0 1.9G 0% /sys/fs/cgrouptmpfs 379M 0 379M 0% /run/user/0# 查看cpu、内存、使用情况： vmstat n m （n 为监控频率、m为监控次数）[root@caoxl ~]# vmstat 1 3procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 2192772 334600 1083488 0 0 0 4 2 1 2 1 98 0 0 0 0 0 2192748 334600 1083520 0 0 0 0 91 87 0 0 100 0 0 0 0 0 2192748 334600 1083520 0 0 0 0 88 90 0 0 100 0 0 # 操作redis时，监控内存变化：[root@caoxl ~]# watch -d -n 1 './redis-cli info | grep memory' 总结sar top free df -h watch 网络工具123456789101112131415161718192021222324252627282930313233343536# 列出所有端口(包括监听和未监听的)[root@caoxl ~]# netstat -aActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 localhos:x11-ssh-offset 0.0.0.0:* LISTEN ...# 使用netstat工具查询端口[root@caoxl ~]# netstat -antp | grep 3306tcp6 0 0 :::3306 :::* LISTEN 3947/mysqld# 查看路由状态[root@caoxl ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.18.63.253 0.0.0.0 UG 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 eth0172.18.48.0 0.0.0.0 255.255.240.0 U 0 0 0 eth0# 下载文件[root@caoxl ~]# wget http://caoxl.com/imgs/we-min.jpg--2019-05-06 15:56:44-- http://caoxl.com/imgs/we-min.jpgResolving caoxl.com (caoxl.com)... 47.107.169.233Connecting to caoxl.com (caoxl.com)|47.107.169.233|:80... connected.HTTP request sent, awaiting response... 200 OK...# ftp sftp lftp ssh# SSH登陆[root@caoxl ~]# ssh root@47.107.169.233# ftp/sftp文件传输[root@caoxl ~]# sftp root@47.107.169.233# 网络复制[root@caoxl ~]# scp localpath ID@host:path 总结netstat lsof route ping wget ssh sftp scp 用户管理工具 用户 12345678910111213141516# 添加用户[root@caoxl ~]# useradd -m caoxl# 设置密码[root@caoxl ~]# passwd caoxlChanging password for user caoxl.New password: Retype new password: passwd: all authentication tokens updated successfully.# 删除用户[root@caoxl ~]# userdel -r caoxl# 账号切换[root@caoxl ~]# su caoxlsu: user caoxl does not exist 用户的组 12345# 查看所有用户及权限[root@caoxl ~]# more /etc/passwd# 查看所有的用户组及权限[root@caoxl ~]# more /etc/group 更改读写权限 字母方式 1chmod userMark(+|-)PermissionsMark userMark取值: u: 用户 g: 组 o: 其它用户 a: 所有用户 PermissionsMark取值: r: 读 w: 写 x: 执行 12345678910[root@caoxl ~]# lltotal 0-rw-r--r-- 1 root root 0 May 6 16:07 test1.php-rw-r--r-- 1 root root 0 May 6 16:07 test2.php[root@caoxl ~]# chmod a+x test1.php # 对所有用户给文件test1.php增加可执行权限[root@caoxl ~]# chmod g+w test2.php # 对组用户给文件test2.php增加可写权限[root@caoxl ~]# lltotal 0-rwxr-xr-x 1 root root 0 May 6 16:07 test1.php-rw-rw-r-- 1 root root 0 May 6 16:07 test2.php 数字方式 使用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。 12345[root@caoxl ~]# chmod 777 test2.php[root@caoxl ~]# lltotal 0-rwxr-xr-x 1 root root 0 May 6 16:07 test1.php-rwxrwxrwx 1 root root 0 May 6 16:07 test2.php 更改文件或目录的拥有者 123456[root@caoxl ~]# chown www test1.php[root@caoxl ~]# chown -R www test2.php # 使用-R选项递归更改该目录下所有文件的拥有者[root@caoxl ~]# lltotal 0-rwxr-xr-x 1 www root 0 May 6 16:07 test1.php-rwxrwxrwx 1 www root 0 May 6 16:07 test2.php 总结useradd passwd userdel usermod chmod chown 系统管理及IPC资源管理1234567891011121314151617181920212223242526272829303132333435363738394041424344# 查看Linux系统版本[root@caoxl ~]# uname -aLinux caoxl 3.10.0-862.14.4.el7.x86_64 #1 SMP Wed Sep 26 15:12:11 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux[root@caoxl ~]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.5.1804 (Core) Release: 7.5.1804Codename: Core# 查看硬件信息 查询CPU信息[root@caoxl ~]# cat /proc/cpuinfo# 查询CPU是几核的 [root@caoxl ~]# cat /proc/cpuinfo | grep processor | wc -l2# 查看内存信息[root@caoxl ~]# cat /proc/meminfoMemTotal: 3880936 kBMemFree: 2194292 kBMemAvailable: 3311360 kB...# 显示架构[root@caoxl ~]# archx86_64# 显示系统时间[root@caoxl ~]# dateMon May 6 16:17:04 CST 2019# 查看系统使用的IPC资源[root@caoxl ~]# ipcs------ Message Queues --------key msqid owner perms used-bytes messages ------ Shared Memory Segments --------key shmid owner perms bytes nattch status ------ Semaphore Arrays --------key semid owner perms nsems 总结uname sar arch date ipcs Linux 工具进阶程序调试程序优化Linux 工具参考篇 gdb 调试利器 ldd 查看程序依赖库 lsof 一切皆文件 ps 进程查看其 pstack 跟踪进程栈 strace 跟踪进程中的系统调用 ipcs 查询进程间通信状态 top linux下的任务管理器 free 查询可用内存 vmstat 监视内存使用情况 iostat 监视I/O子系统 sar 找出系统瓶颈的利器 readelf elf 文件格式分析 objdump 二进制文件分析 nm 目标文件格式分析 size 查看程序内存映象大小 wget 文件下载 scp 跨机远程拷贝 crontab 定时任务","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"QUIC 初步认识","slug":"QUIC-Learn-Notes","date":"2019-04-19T07:15:01.000Z","updated":"2019-08-22T03:44:18.000Z","comments":true,"path":"2019/04/19/QUIC-Learn-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/04/19/QUIC-Learn-Notes/","excerpt":"QUIC (Quick UDP Internet Connections 快速UDP网络连接) (发音：quick) 由google开发的新一代网络传输协议。QUIC设计的初衷就是利用工程师几十年的经验来改进网络传输延迟。","text":"QUIC (Quick UDP Internet Connections 快速UDP网络连接) (发音：quick) 由google开发的新一代网络传输协议。QUIC设计的初衷就是利用工程师几十年的经验来改进网络传输延迟。 QUIC简介 据 IETF (Internet Engineering Task Force 意思是互联网工程任务小组) 透露，HTTP-over-QUIC 实验协议将被重命名为 HTTP/3，并成为 HTTP 协议的第三个正式版本。 说出来你可能不信，HTTP的发展被G家握在手里了，HTTP-over-SPDY被改名为HTTP/2，HTTP-over-QUIC被改名为HTTP/3。 QUIC基于UDP协议实现了类似TCP+TLS+HTTP2的功能组合。所以可以把QUIC和现有的协议理解成以下结构： 为什么需要QUIC?这个问题也可以理解为，HTTP/2 现在有什么硬伤是不能解决的吗？其实HTTP/2的硬伤就是TCP。 TCP 协议在70年代设计敲定，当时的网络丢包率高，网速差，链接的稳定和可靠对当时来说是最需要解决的事情。对比今天的网络现状，毫无疑问在网络的可靠性和速度上我们都得到了巨大的进步。 经过几十年的经验累积，网络工程师对怎么优化网络访问，降低延迟也有了新的认知，于是就想着更新 TCP 协议，但是 TCP 的更新非常困难，因为网络协议栈的实现本来就依赖系统内核更新，而不管是终端设备，中间设备的系统更新都极其缓慢，一个更新迭代可能需要5-15年的时间去普及，对于现在的互联网发展来说太慢了。 所以 TCP 的硬伤总结一下就是：TCP的更新优化需要依赖系统内核更新。 这是一个日益高速高速发展的应用层和缓慢进化的网络传输层的矛盾，于是 JIM（QUIC协议设计师） 决定在传输层抛弃TCP，拥抱UDP协议。UDP相对TCP协议来说，是一个不稳定的乐观协议，他不需要握手建立连接，至于什么防止IP攻击，怎么保证数据一致性，这些都是UDP之上的工作，这一点刚好契合我们的需求，把很多工作从传输层移动到了应用层（4层网络模型而言~），如此一来，以后QUIC协议的升级完全不依赖于底层操作系统，只需终端和服务器升级到指定版本即可。 这就是QUIC 的意义。 对比HTTP/2的优势所在HTTP/2 是个优秀的协议，其最大的特色就是多路复用，那么 QUIC 带了什么新的东西，对比 HTTP/2 有什么优势呢。 主要在以下几点有着巨大的优势： 建立连接的延迟 改进的拥塞控制 多路复用-无对头阻塞版 错误自动纠正 连接迁移 接下来我们就简洁说明一下为什么会有这些优势 建立连接的延迟首先明确一个概念是 RTT（round-trip time），顾名思义，就是服务器和终端一次交互需要的时间。RTT 一般用于衡量网络延迟。 传统的TCP协议，我们需要进行3次握手，也就是 1.5 RTT，才开始传输数据。 HTTP/2来说，虽然协议上支持不开启TLS，但是目前大家的实现都是绑定了TLS和HTTP，也就是我们不止要建立连接，还要确定好加密版本，加密密钥等信息，TCP+TLS需要3 RTT。 对于现阶段的QUIC来说，其设计了自己的加密协议和过程，实现了最好情况下0 RTT的效果。 0 RTT 的效果是因为QUIC的客户端会缓存服务器端发的令牌和证书，当有数据需要再次发送的时候，客户端可以直接使用旧的令牌和证书，这样子就实现了 0 RTT 了。对于没有缓存的情况，服务器端会直接拒绝请求，并且返回新生产的令牌和证书。 所以当令牌失效或者没有缓存的情况下，QUIC还是需要一次握手才能开始传输数据 当然这么玩还是有代价的，对于重放攻击（replay attack） 的防范就需要从应用层解决了。 需要注意的是：被接纳为HTTP/3之后，QUIC未来还是会采用 TLS 1.3，放弃现有加密算法~ TLS 1.3 是对于1.2、1.1版本的大跃迁，目前还没有正式版。TLS 1.3 只需要 2 RTT 就完成一次连接建立了。 改进的拥塞控制目前的 QUIC 的拥塞控制主要实现了 TCP 的慢启动，拥塞避免，快重传，快恢复。在这些拥塞控制算法的基础上，再进行改进。 比如单调递增的 Packet Number。TCP 使用了基于字节序号 Sequence Number 和 ACK 来保证消息的有序到达。但是 Sequence Number 在重传的时候有二义性。你不知道下一个 ACK 是上一次请求的响应还是这次重传的响应。而单调递增的 Packet Number 可以避免这个问题，保证采样 RTT 的准确。 QUIC 拥塞控制算法主要重新实现了一遍 TCP 的算法，毕竟 TCP 的算法是经过几十年的生产验证的。 多路复用——无队头阻塞版SPDY 和 HTTP/2 已经实现了多路复用。多路复用的指的是我们不需要在为每个资源重新建立一次 TCP 连接，多个资源的传输可以共用一个连接。 如此一来，在启用了 HTTP/2 的网站，我们再也不需要对资源进行合并了（：）压缩还是可以做一下的），毕竟一次性发出去多个资源和建立多个连接一个一个下载资源相比还是会快一下的。 然后 HTTP/2 的多路复用会有个很大的问题，那就是队头阻塞。原因还是因为 TCP 的 Sequence Number 机制，为了保证资源的有序到达，如果传输队列的队头某个资源丢失了，TCP 必须等到这个资源重传成功之后才会通知应用层处理后续资源。 由于 QUIC 避开了 TCP， 他设计 connection 和 stream 的概念，一个 connection 可以复用传输多个 stream，每个 stream 之间都是独立的，单一一个 stream 丢包并不会影响到其他资源处理。 错误自动纠正 这里的错误指的是某个包丢了。当某个 packet 丢失的时候，QUIC 能够通过已经接收到的其他包对资源进行修复。 这意味着，实际上每个 packet 都携带着多余的信息，通过这些信息，QUIC 能够重组对应资源，而无需进行重传。 目前大概每 10 个包能修复一个 packet。 连接迁移TCP 是按照 4-要素(客户端IP、端口, 服务器IP、端口) 要确定一个连接的，当这4个要素其中一个发生变化的时候，连接就需要重新建立。而在移动端，我们经常会切换 4G/wifi 使用，每一次切换，我们只能重新建立连接。 在 QUIC 中，连接是由其维护的。 于是 QUIC 通过生成客户端生成一个 Connection ID （64位）的东西来区别不同连接，只要生成的 UUID 不变， 连接就不需要重新建立，即便是客户端的网络发生变化。 QUIC 现状HTTP-over-QUIC 将被吸收改名为 HTTP/3。 未来的 web 传输不再依赖 TCP 协议，升级更新也不再需要依赖系统内核升级了，未来的 HTTP 可以跟其他产品一样月更、甚至周更。 目前，如果想体验 QUIC 可以使用 candy 服务器。candy 在 0.9 版本之后就支持 QUIC 了。 参考 快速UDP网络连接 QUIC 简明教程 QUIC","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"QUIC","slug":"QUIC","permalink":"http://blog.caoxl.com/tags/QUIC/"},{"name":"HTTP/3","slug":"HTTP-3","permalink":"http://blog.caoxl.com/tags/HTTP-3/"}]},{"title":"MySQL 脏读、不可重复读、幻读","slug":"MySQL-Dirty-NoRepeatable-Phantom-Read","date":"2019-03-26T06:13:45.000Z","updated":"2019-08-22T06:26:39.000Z","comments":true,"path":"2019/03/26/MySQL-Dirty-NoRepeatable-Phantom-Read/","link":"","permalink":"http://blog.caoxl.com/2019/03/26/MySQL-Dirty-NoRepeatable-Phantom-Read/","excerpt":"起因事务隔离性问题","text":"起因事务隔离性问题 脏读: 指一个线程中的事务读取到了另外一个线程中未提交的数据。 不可重复读(虚读): 指一个线程中的事务读取到了另外一个线程中提交的update的数据 幻读: 指一个线程中的事务读取到了另外一个线程中提交的insert的数据 隔离级别 隔离级别 脏读(Dirty Read) 不可重复读(NoRepeatable Read) 幻读(Phantom Read) 未提交读(Read uncommitted) 可能 可能 可能 已提交读(Read committed) 不可能 可能 可能 可重复读(Repeatable read) 不可能 不可能 可能 可串行化(Serizlizable) 不可能 不可能 不可能 我们可以通过以下命令 查看/设置 全局/会话 的事务隔离级别 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950mysql&gt; SELECT @@global.tx_isolation, @@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in set (0.02 sec)// 查看当前session的事务隔离级别：mysql&gt; show variables like '%tx_isolation%';+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| tx_isolation | REPEATABLE-READ |+---------------+-----------------+1 row in set (0.04 sec)// 查看全局的事务隔离级别。mysql&gt; show global variables like '%tx_isolation%';+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| tx_isolation | REPEATABLE-READ |+---------------+-----------------+1 row in set (0.03 sec)# 设定全局的隔离级别 设定会话 global 替换为 session 即可 把set语法温习一下# SET [GLOABL] config_name = 'foobar';# SET @@[session|global].config_name = 'foobar';# SELECT @@[global.]config_name;# RUSET @@global.tx_isolation = 0;SET @@global.tx_isolation = 'READ-UNCOMMITTED';SET @@session.tx_isolation = 'READ-UNCOMMITTED';# RCSET @@global.tx_isolation = 1;SET @@global.tx_isolation = 'READ-COMMITTED';SET @@session.tx_isolation = 'READ-COMMITTED';# RRSET @@global.tx_isolation = 2;SET @@global.tx_isolation = 'REPEATABLE-READ';SET @@session.tx_isolation = 'REPEATABLE-READ';# SerializableSET @@global.tx_isolation = 3;SET @@global.tx_isolation = 'SERIALIZABLE';SET @@session.tx_isolation = 'SERIALIZABLE'; 从上面可看到默认的隔离等级: 可重复读 REPEATABLE-READ | 2：解决脏读，不可重复读的问题，存在幻读的问题，使用 MMVC机制 实现可重复读 脏读 脏读：（同时操作都没提交的读取）脏读又称无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。 事务T1 123456789101112131415161718192021222324252627282930313233343536373839404142mysql&gt; use test;Database changedmysql&gt; SET @@global.tx_isolation = 'READ-UNCOMMITTED'; SET @@session.tx_isolation = 'READ-UNCOMMITTED';Query OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @@global.tx_isolation, @@tx_isolation;+-----------------------+------------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+------------------+| READ-UNCOMMITTED | READ-UNCOMMITTED |+-----------------------+------------------+1 row in set (0.01 sec)mysql&gt; select * from test;Empty setmysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test values (1, 'caox1', '111111');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 111111 |+----+----------+----------+1 row in set (0.02 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 111111 || 2 | caox2 | 222222 |+----+----------+----------+2 rows in set (0.03 sec) 事务T2 12345678910111213141516171819202122232425262728293031323334353637383940414243mysql&gt; use test;Database changed# 将隔离等级设置为RUmysql&gt; SET @@global.tx_isolation = 'READ-UNCOMMITTED'; SET @@session.tx_isolation = 'READ-UNCOMMITTED';Query OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @@global.tx_isolation, @@tx_isolation;+-----------------------+------------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+------------------+| READ-UNCOMMITTED | READ-UNCOMMITTED |+-----------------------+------------------+1 row in set (0.01 sec)mysql&gt; select * from test;Empty setmysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 111111 |+----+----------+----------+1 row in set (0.02 sec)mysql&gt; insert into test values (2, 'caox2', '222222');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 111111 || 2 | caox2 | 222222 |+----+----------+----------+2 rows in set (0.03 sec) 当前MySQL默认隔离等级为RR 事务T1 123456789101112131415161718192021222324252627282930mysql&gt; select @@global.tx_isolation, @@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in set (0.01 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caoxl | 123456 |+----+----------+----------+1 row in set (0.02 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; update test set password = 654321 where id = 1;Query OK, 1 row affected (0.02 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caoxl | 654321 |+----+----------+----------+1 row in set (0.03 sec) 事务T2 123456789101112131415161718192021222324252627282930313233343536373839mysql&gt; SELECT @@global.tx_isolation, @@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in set (0.01 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)// T1 commit之前mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caoxl | 123456 |+----+----------+----------+1 row in set (0.01 sec)// T1 commit之后mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caoxl | 123456 |+----+----------+----------+1 row in set (0.02 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caoxl | 654321 |+----+----------+----------+1 row in set (0.04 sec) 不可重复读(虚读) 同一个事务执行过程中，另外一个事务提交了新数据，因此本事务先后两次读到的数据结果会不一致不可重复读的侧重点在于更新修改数据 事务T1 1234567891011121314151617181920212223242526272829303132333435363738394041424344mysql&gt; use test;Database changedmysql&gt; SET @@global.tx_isolation = 'READ-COMMITTED'; SET @@session.tx_isolation = 'READ-COMMITTED';Query OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @@global.tx_isolation, @@tx_isolation;+-----------------------+----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+----------------+| READ-COMMITTED | READ-COMMITTED |+-----------------------+----------------+1 row in set (0.01 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 111111 || 2 | caox2 | 222222 |+----+----------+----------+2 rows in set (0.02 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; update test set password = 999999 where id = 1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 999999 || 2 | caox2 | 222222 |+----+----------+----------+2 rows in set (0.02 sec)mysql&gt; commit;Query OK, 0 rows affected (0.03 sec) 事务T2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748mysql&gt; use test;Database changedmysql&gt; SET @@global.tx_isolation = 'READ-COMMITTED'; SET @@session.tx_isolation = 'READ-COMMITTED';Query OK, 0 rows affected (0.00 sec)Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT @@global.tx_isolation, @@tx_isolation;+-----------------------+----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+----------------+| READ-COMMITTED | READ-COMMITTED |+-----------------------+----------------+1 row in set (0.01 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 111111 || 2 | caox2 | 222222 |+----+----------+----------+2 rows in set (0.02 sec)// T1事务提交前mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 111111 || 2 | caox2 | 222222 |+----+----------+----------+2 rows in set (0.02 sec)// T1事务提交后mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caox1 | 999999 || 2 | caox2 | 222222 |+----+----------+----------+2 rows in set (0.03 sec) 幻读 幻读问题是指一个事务的两次不同时间的相同查询返回了不同的的结果集。例如:一个 select 语句执行了两次，但是在第二次返回了第一次没有返回的行,那么这些行就是“phantom” row.幻读的侧重点在于新增和删除 幻读会在 RU / RC / RR 级别下出现，SERIALIZABLE 则杜绝了幻读，但 RU / RC 下还会存在脏读，不可重复读，故我们就以 RR 级别来研究幻读，排除其他干扰。 注意：RR 级别下存在幻读的可能，但也是可以使用对记录手动加 X锁 的方法消除幻读。SERIALIZABLE 正是对所有事务都加 X锁 才杜绝了幻读，但很多场景下我们的业务sql并不会存在幻读的风险。SERIALIZABLE 的一刀切虽然事务绝对安全，但性能会有很多不必要的损失。故可以在 RR 下根据业务需求决定是否加锁，存在幻读风险我们加锁，不存在就不加锁，事务安全与性能兼备，这也是 RR 作为mysql默认隔离级别的原因，所以需要正确的理解幻读。 幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。 事务T1 12345678910111213141516171819202122232425262728293031323334353637mysql&gt; SELECT @@global.tx_isolation, @@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in set (0.01 sec)mysql&gt; desc test;+----------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || username | varchar(255) | NO | UNI | NULL | || password | varchar(255) | NO | | NULL | |+----------+------------------+------+-----+---------+----------------+3 rows in set (0.02 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test where id = 1;Empty set// 事务T2 commit之前mysql&gt; insert into test values (1, 'caoxl', '123456');1205 - Lock wait timeout exceeded; try restarting transactionmysql&gt; select * from test where id = 1;Empty set// 事务T2 commit之后mysql&gt; insert into test values (1, 'caoxl', '123456');1062 - Duplicate entry '1' for key 'PRIMARY'mysql&gt; select * from test where id = 1;Empty set 事务T2 12345678910111213141516171819202122232425262728293031323334353637mysql&gt; SELECT @@global.tx_isolation, @@tx_isolation;+-----------------------+-----------------+| @@global.tx_isolation | @@tx_isolation |+-----------------------+-----------------+| REPEATABLE-READ | REPEATABLE-READ |+-----------------------+-----------------+1 row in set (0.01 sec)mysql&gt; desc test;+----------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || username | varchar(255) | NO | UNI | NULL | || password | varchar(255) | NO | | NULL | |+----------+------------------+------+-----+---------+----------------+3 rows in set (0.02 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test where id = 1;Empty setmysql&gt; insert into test values (1,'caoxl','123456');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test where id = 1;+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | caoxl | 123456 |+----+----------+----------+1 row in set (0.02 sec)mysql&gt; commit;Query OK, 0 rows affected (0.03 sec) Update 幻读 事务T1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 2 | caox2 | 111222 || 3 | caox3 | 333333 || 4 | caox4 | 444444 |+----+----------+----------+3 rows in set (0.03 sec)// 事务T2提交前,更新失败,提示被锁mysql&gt; update test set password = 123456;1205 - Lock wait timeout exceeded; try restarting transaction// 事务T2提交前,查询显示只有3条数据mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 2 | caox2 | 111222 || 3 | caox3 | 333333 || 4 | caox4 | 444444 |+----+----------+----------+3 rows in set (0.03 sec)// 事务T2提交后,查询显示只有3条数据mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 2 | caox2 | 111222 || 3 | caox3 | 333333 || 4 | caox4 | 444444 |+----+----------+----------+3 rows in set (0.03 sec)// 执行更新,提示 \"4 rows affected\" 也就是有4条数据受影响mysql&gt; update test set password = 123456;Query OK, 4 rows affected (0.00 sec)Rows matched: 4 Changed: 4 Warnings: 0mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 2 | caox2 | 123456 || 3 | caox3 | 123456 || 4 | caox4 | 123456 || 5 | caox5 | 123456 |+----+----------+----------+4 rows in set (0.03 sec) 事务T2 1234567891011121314151617181920212223242526272829mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 2 | caox2 | 222222 || 3 | caox3 | 333333 || 4 | caox4 | 444444 |+----+----------+----------+3 rows in set (0.01 sec)mysql&gt; insert into test values (5, 'caox5', '555555');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test;+----+----------+----------+| id | username | password |+----+----------+----------+| 2 | caox2 | 222222 || 3 | caox3 | 333333 || 4 | caox4 | 444444 || 5 | caox5 | 555555 |+----+----------+----------+4 rows in set (0.02 sec)mysql&gt; commit;Query OK, 0 rows affected (0.03 sec) MyISAM不存在幻读现象,InnoDB存在幻读现象 step1 T1: select * from test where id = 1; step2 T2: insert into test values (1, &#39;caoxl&#39;, &#39;123456&#39;); step3 T1: insert into test values (1, &#39;caoxl&#39;, &#39;123456&#39;); step4 T1: select * from test where id = 1; T1 ：主事务，检测表中是否有 id 为 1 的记录，没有则插入，这是我们期望的正常业务逻辑。 T2 ：干扰事务，目的在于扰乱 T1 的正常的事务执行。 这里有个注意点，关于幻读，在数据库规范里，RR 级别会导致幻读，但是，由于 Mysql 的优化，MySql 的 RR 级别不会导致幻读：在使用默认的 select 时，MySql 使用 MVCC 机制保证不会幻读；你也可以使用锁，在使用锁时，例如 for update（X 锁），lock in share mode（S 锁），MySql 会使用 Next-Key Lock 来保证不会发生幻读。前者称为快照读，后者称为当前读。 其他InnoDB通过Nextkey lock解决了当前读时的幻读问题 InnoDB行锁分为: 类型 说明 Record Lock 在索引上对单行记录加锁 Gap Lock 锁定一个范围的记录,但不包括记录本身.锁加在未使用的空闲空间上,可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间. Next-Key Lock 行锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。 MySQL 如何实现避免幻读 ？ 在快照读情况下，mysql通过mvcc来避免幻读 在当前读情况下，mysql通过next-key来避免幻读 什么是快照读和当前读 ? 快照读(snapshot read)：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析) 快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁 1select * from table where ?; 当前读(current read): 特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。 当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。 12345select * from table where ? lock in share mode;select * from table where ? for update;insert into table values (…);update table set ? where ?;delete from table where ?; 什么是mvcc ? mvcc全称是multi version concurrent control（多版本并发控制）mysql把每个操作都定义成一个事务，每开启一个事务，系统的事务版本号自动递增。每行记录都有两个隐藏列：创建版本号和删除版本号 select: 事务每次只能读到创建版本号小于等于此次系统版本号的记录，同时行的删除版本号不存在或者大于当前事务的版本号。 update: 插入一条新记录，并把当前系统版本号作为行记录的版本号，同时保存当前系统版本号到原有的行作为删除版本号。 delete: 把当前系统版本号作为行记录的删除版本号 insert: 把当前系统版本号作为行记录的版本号 什么是next-key锁 ? 可以简单的理解为: record locks + gap locks","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"脏读","slug":"脏读","permalink":"http://blog.caoxl.com/tags/脏读/"},{"name":"不可重复读","slug":"不可重复读","permalink":"http://blog.caoxl.com/tags/不可重复读/"},{"name":"幻读","slug":"幻读","permalink":"http://blog.caoxl.com/tags/幻读/"}]},{"title":"MySQL 索引、锁、事务","slug":"MySQL-Index-Lock-Transaction","date":"2019-03-25T03:43:31.000Z","updated":"2019-08-22T06:26:41.000Z","comments":true,"path":"2019/03/25/MySQL-Index-Lock-Transaction/","link":"","permalink":"http://blog.caoxl.com/2019/03/25/MySQL-Index-Lock-Transaction/","excerpt":"原文地址: MySql 三大知识点——索引、锁、事务！","text":"原文地址: MySql 三大知识点——索引、锁、事务！ 索引 索引，类似书籍的目录，可以根据目录的某个页码立即找到对应的内容。 索引的优点: 1. 天生排序。2. 快速查找。 索引的缺点: 1. 占用空间。2. 降低更新表的速度。 注意点：小表使用全表扫描更快，中大表才使用索引。超级大表索引基本无效。 索引种类 从实现上说: 聚焦索引 辅助索引(也叫二级索引或者非聚集索引) 从功能上说: 普通索引 唯一索引 主键索引 复合索引 外键索引 全文索引 详细说说 6 种索引： 普通索引: 最基本的索引, 没有任何约束. 唯一索引: 与普通索引类似, 但具有唯一约束 主键索引: 特殊的唯一索引, 不允许有空值 复合索引: 将多个列组合在一起创建索引, 可以覆盖多个列 外键索引: 只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。 全文索引: MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎（ES，Solr） 注意：主键就是唯一索引，但是唯一索引不一定是主键，唯一索引可以为空，但是空值只能有一个，主键不能为空。 另外，InnoDB 通过主键聚簇数据，如果没有定义主键且没有定义聚集索引， MySql 会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个 6 字节的主键作为聚簇索引，用户不能查看或访问。 简单点说： 设置主键时，会自动生成一个唯一索引，如果之前没有聚集索引，那么主键就是聚集索引。 没有设置主键时，会选择一个不为空的唯一索引作为聚集索引，如果还没有，那就生成一个隐式的 6 字节的索引。 MySql 将数据按照页来存储，默认一页为 16kb，当你在查询时，不会只加载某一条数据，而是将这个数据所在的页都加载到 pageCache 中，这个其实和 OS 的就近访问原理类似。 MySql 的索引使用 B+ 树结构。在说 B+ 树之前，先说说 B 树，B 树是一个多路平衡查找树，相较于普通的二叉树，不会发生极度不平衡的状况，同时也是多路的。 B 树的特点是：他会将数据也保存在非页子节点。 看图可知 而这个特点会导致非页子节点不能存储大量的索引。 而 B+ Tree 就是针对这个对 B tree 做了优化。如下图所示： 我们看到，B+ Tree 将所有的 data 数据都保存到了叶子节点中，非叶子节点只保存索引和指针。 我们假设一个非页子节点是 16kb，每个索引，即主键是 bigint，即 8b，指针为 8b。那么每页能存储大约 1000 个索引（16kb/ 8b + 8b）. 而一颗 3 层的 B+树能够存储多少索引呢？如下图： 大约能够存储 10 亿个索引。通常 B+ 树的高度在 2-4 层，由于 MySql 在运行时，根节点是常驻内存的，因此每次查找只需要大约 2 -3 次 IO。可以说，B+ 树的设计，就是根据机械磁盘的特性来进行设计的。 知道了索引的设计，我们能够知道另外一些信息： MySQL 的主键不能太大,如果使用 UUID 这种，将会浪费 B+ 树的非叶子节点。 MySQL 的主键最好是自增的，如果使用 UUID 这种，每次插入都会调整 B+树，从而导致页分裂，严重影响性能。 那么，如果项目中使用了分库分表，我们通常都会需要一个主键进行 sharding(分片)，那怎么办呢？在实现上，我们可以保留自增主键，而逻辑主键用来作为唯一索引即可。 锁 关于 MySQL 的锁，各种概念就会喷涌而出，事实上，锁有好几种维度，我们来解释一下。 类型纬度 共享锁(读锁 / S锁) 排它锁(写锁 / X锁)类型细分: 意向共享锁 意向排他(互斥)锁 悲观锁(使用锁, 即 for update) 乐观锁(使用版本号字段，类似 CAS 机制，即用户自己控制。缺点：并发很高的时候，多了很多无用的重试) 锁的粒度 (粒度纬度) 表锁 页锁 (MySQL BerkeleyDB引擎) 行锁 (InnoDB) 锁的算法 (算法纬度) Record Lock (单行记录) Gap Lock(间隙锁, 锁定一个范围,但不包含锁定记录) Next-Key Lock(Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现) 幻读：在同一个事务内，前后两次查询 同一范围 的时候，后一次查询看到了前一次查询没有看到的行幻读专指 新插入的行 默认的读操作，上锁吗？ 默认是 MVCC 机制（“一致性非锁定读”）保证 RR 级别的隔离正确性，是不上锁的。 可以选择手动上锁：select xxxx for update (排他锁); select xxxx lock in share mode(共享锁)，称之为“一致性锁定读”。 使用锁之后，就能在 RR 级别下，避免幻读。当然，默认的 MVCC 读，也能避免幻读。 既然 RR 能够防止幻读，那么，SERIALIZABLE 有啥用呢？ 防止丢失更新。例如下图： 这个时候，我们必须使用 SERIALIZABLE 级别进行串行读取。 最后，行锁的实现原理就是锁住聚集索引，如果你查询的时候，没有正确地击中索引，MySql 优化器将会抛弃行锁，使用表锁。 事务事务是数据库永恒不变的话题， ACID：原子性，一致性，隔离性，持久性。 四个特性，最重要的就是一致性。而一致性由原子性，隔离性，持久性来保证。 原子性: 由 Undo log 保证。Undo Log 会保存每次变更之前的记录，从而在发生错误时进行回滚。 隔离性: 由 MVCC 和 Lock 保证。这个后面说。 持久性: 由 Redo Log 保证。每次真正修改数据之前，都会将记录写到 Redo Log 中，只有 Redo Log 写入成功，才会真正的写入到 B+ 树中，如果提交之前断电，就可以通过 Redo Log 恢复记录。 然后再说隔离性。 隔离级别: 未提交读(RU) 已提交读(RC) 可重复读(RR) 串行化(serializable) 每个级别都会解决不同的问题，通常是3 个问题：脏读，不可重复读，幻读。一张经典的图： 这里有个注意点，关于幻读，在数据库规范里，RR 级别会导致幻读，但是，由于 Mysql 的优化，MySql 的 RR 级别不会导致幻读：在使用默认的 select 时，MySql 使用 MVCC 机制保证不会幻读；你也可以使用锁，在使用锁时，例如 for update（X 锁），lock in share mode（S 锁），MySql 会使用 Next-Key Lock 来保证不会发生幻读。前者称为快照读，后者称为当前读。 远离剖析: RU 发生脏读的原因：RU 原理是对每个更新语句的行记录进行加锁，而不是对整个事务进行加锁，所以会发生脏读。而 RC 和 RR 会对整个事务加锁。 RC 不能重复读的原因：RC 每次执行 SQL 语句都会生成一个新的 Read View，每次读到的都是不同的。而 RR 的事务从始至终都是使用同一个 Read View RR 不会发生幻读的原因： 上面说过了。 那 RR 和 Serializble 有什么区别呢？答：丢失更新。本文关于锁的部分已经提到。 MVCC 介绍：全称多版本并发控制。innoDB 每个聚集索引都有 4 个隐藏字段，分别是:主键（RowID），最近更改的事务 ID（MVCC 核心），Undo Log 的指针（隔离核心），索引删除标记（当删除时，不会立即删除，而是打标记，然后异步删除）； 本质上，MVCC 就是用 Undo Log 链表实现。 MVCC 的实现方式：事务以排它锁的方式修改原始数据，把修改前的数据存放于 Undo Log，通过回滚指针与数据关联，如果修改成功，什么都不做，如果修改失败，则恢复 Undo Log 中的数据。 多说一句，通常我们认为 MVCC 是类似乐观锁的方式，即使用版本号，而实际上，innoDB 不是这么实现的。当然，这不影响我们使用 MySql。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"锁","slug":"锁","permalink":"http://blog.caoxl.com/tags/锁/"},{"name":"索引","slug":"索引","permalink":"http://blog.caoxl.com/tags/索引/"},{"name":"事务","slug":"事务","permalink":"http://blog.caoxl.com/tags/事务/"}]},{"title":"JWT 简单封装","slug":"PHP-Simple-JWT","date":"2019-03-20T08:10:04.000Z","updated":"2019-03-20T08:14:26.000Z","comments":true,"path":"2019/03/20/PHP-Simple-JWT/","link":"","permalink":"http://blog.caoxl.com/2019/03/20/PHP-Simple-JWT/","excerpt":"","text":"这里就是一个JWT的简单使用JSON Web Token 入门教程 直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;?phpclass Jwt&#123; private $alg = 'sha256'; private $secret = '123456'; /** * alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256） * typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT * @return mixed */ public function getHeader() &#123; $header = [ 'alg' =&gt; $this-&gt;alg, 'typ' =&gt; 'JWT' ]; return $this-&gt;base64urlEncode(json_encode($header, JSON_UNESCAPED_UNICODE)); &#125; /** * Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用，这里可以存放私有信息，比如uid * @param $uid * @return mixed */ public function getPayload($uid) &#123; $payload = [ 'iss' =&gt; 'admin', // 签发人 (issuer) 'exp' =&gt; time() + 600, // 过期时间 (expiration time) 'sub' =&gt; 'test', // 主题 (subject) 'aud' =&gt; 'every', // 受众 (audience) 'nbf' =&gt; time(), // 生效时间 (not before) 'iat' =&gt; time(), // 签发时间 (issued at) 'jti' =&gt; 10001, // 编号 (jwt id) 'uid' =&gt; $uid, // 私有信息,uid ]; return $this-&gt;base64urlEncode(json_encode($payload, JSON_UNESCAPED_UNICODE)); &#125; /** * 生成token,假设现在payload里面只存一个uid * @param $uid * @return string */ public function genToken($uid) &#123; $header = $this-&gt;getHeader(); $payload = $this-&gt;getPayload($uid); $raw = $header . '.' . $payload; $token = $raw . '.' . hash_hmac($this-&gt;alg, $raw, $this-&gt;secret); return $token; &#125; /** * 解密校验token,成功的话返回uid * @param $token * @return bool */ public function verifyToken($token) &#123; if (!$token) &#123; return false; &#125; $tokenArr = explode('.', $token); if (count($tokenArr) != 3) &#123; return false; &#125; list($header, $payload, $signature) = $tokenArr; $payloadArr = json_decode($this-&gt;base64urlDecode($payload), true); if (!$payloadArr) &#123; return false; &#125; // 已过期 if (isset($payloadArr['exp']) &amp;&amp; $payloadArr['exp'] &lt; time()) &#123; return false; &#125; $expected = hash_hmac($this-&gt;alg, $header . '.' . $payload, $this-&gt;secret); // 签名不对 if ($expected !== $signature) &#123; return false; &#125; return $payloadArr['uid']; &#125; /** * 安全的base64 url编码 * @param $data * @return string */ private function base64urlEncode($data) &#123; return rtrim(strtr(base64_encode($data), '+/', '-_'), '='); &#125; /** * 安全的base64 url解码 * @param $data * @return bool|string */ private function base64urlDecode($data) &#123; return base64_decode(str_pad(strtr($data, '-_', '+/'), strlen($data) % 4, '=', STR_PAD_RIGHT)); &#125;&#125;$jwt = new Jwt();// 获取token$token = $jwt-&gt;genToken(10000);var_dump($token);// 解密token$uid = $jwt-&gt;verifyToken($token);var_dump($uid); 结果 12string(260) \"eyJhbGciOiJzaGEyNTYiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJhZG1pbiIsImV4cCI6MTU1MzA2OTQ3OSwic3ViIjoidGVzdCIsImF1ZCI6ImV2ZXJ5IiwibmJmIjoxNTUzMDY4ODc5LCJpYXQiOjE1NTMwNjg4NzksImp0aSI6MTAwMDEsInVpZCI6MTAwMDB9.69b6e7d00a1c1c080b14ba1a614580fed8f1fa1b235557ed5158d7154442edb8\"int(10000)","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://blog.caoxl.com/tags/JWT/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"jwt","slug":"jwt","permalink":"http://blog.caoxl.com/tags/jwt/"}]},{"title":"不要在循环体中使用 array_merge()","slug":"PHP-Do-Not-ArrayMerge-In-For","date":"2019-03-20T06:54:40.000Z","updated":"2019-03-20T07:21:10.000Z","comments":true,"path":"2019/03/20/PHP-Do-Not-ArrayMerge-In-For/","link":"","permalink":"http://blog.caoxl.com/2019/03/20/PHP-Do-Not-ArrayMerge-In-For/","excerpt":"标题是不要在循环体中使用 array_merge()，其实这只是本篇文章的结论之一 下面我们一起研究一下 php 语言中数组的合并（这里先不考虑递归合并） 原文链接 &amp;&amp; 掘金看到的链接","text":"标题是不要在循环体中使用 array_merge()，其实这只是本篇文章的结论之一 下面我们一起研究一下 php 语言中数组的合并（这里先不考虑递归合并） 原文链接 &amp;&amp; 掘金看到的链接 四种合并数组的方式对比创建一个类 ArrayMerge() eachOne() 循环体使用 array_merge() 合并 eachTwo() 循环体结束后使用 array_merge() 合并 eachThree() 循环体嵌套实现数组合并 eachFour() 循环体使用 运算符 + 拼接合并 getNiceFileSize() 将内存占用转化成人类可读的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?phpclass ArrayMerge&#123; /** * @param int $times * @return array */ public static function eachOne(int $times): array &#123; $a = []; $b = [0,1,2,3,4,5,6,7,8,9]; for ($i = 0; $i &lt; $times; $i++) &#123; $a = array_merge($a, $b); &#125; return $a; &#125; /** * @param int $times * @return array */ public static function eachTwo(int $times): array &#123; $a = [[]]; $b = [0,1,2,3,4,5,6,7,8,9]; for ($i = 0; $i &lt; $times; $i++) &#123; $a[] = $b; &#125; return array_merge(...$a); &#125; /** * @param int $times * @return array */ public static function eachThree(int $times): array &#123; $a = []; $b = [0,1,2,3,4,5,6,7,8,9]; for ($i = 0; $i &lt; $times; $i++) &#123; foreach ($b as $item) &#123; $a[] = $item; &#125; &#125; return $a; &#125; /** * @param int $times * @return array */ public static function eachFour(int $times): array &#123; $a = []; $b = [0,1,2,3,4,5,6,7,8,9]; for ($i = 0; $i &lt; $times; $i++) &#123; $a = $b + $a; &#125; return $a; &#125; /** * 转化内存信息 * @param int $bytes * @param bool $binaryPrefix * @return null|string */ public static function getNiceFileSize(int $bytes, $binaryPrefix = true): ?string &#123; if ($binaryPrefix) &#123; $unit = array('B','KiB','MiB','GiB','TiB','PiB'); if ($bytes === 0) &#123; return '0 ' . $unit[0]; &#125; return @round($bytes / (1024 ** ($i = floor(log($bytes, 1024)))), 2) . '' . ($unit[(int)$i] ?? 'B'); &#125; $unit = array('B', 'KB', 'MB', 'GB', 'TB', 'PB'); if ($bytes === 0) &#123; return '0 ' . $unit[0]; &#125; return @round($bytes / (1000 ** ($i = floor(log($bytes, 1000)))), 2) . '' . ($unit[(int)$i] ?? 'B'); &#125;&#125; 使用 先分配多点内存输出内存占用，合并后的数组长度，并记录每一步的用时 1234567891011121314151617181920212223242526272829ini_set('memory_limit', '4000M');$timeOne = microtime(true);$a = ArrayMerge::eachOne(10000);echo 'count eachOne Result | ' . count($a) . PHP_EOL;echo 'memory eachOne Result | ' . ArrayMerge::getNiceFileSize(memory_get_usage(true)) . PHP_EOL;$timeTwo = microtime(true);$b = ArrayMerge::eachTwo(10000);echo 'count eachTwo Result | ' . count($b) . PHP_EOL;echo 'memory eachTwo Result | ' . ArrayMerge::getNiceFileSize(memory_get_usage(true)) . PHP_EOL;$timeThree = microtime(true);$c = ArrayMerge::eachThree(10000);echo 'count eachThree Result | ' . count($c) . PHP_EOL;echo 'memory eachThree Result | ' . ArrayMerge::getNiceFileSize(memory_get_usage(true)) . PHP_EOL;$timeFour = microtime(true);$d = ArrayMerge::eachFour(10000);echo 'count eachFour Result | ' . count($d) . PHP_EOL;echo 'memory eachFour Result | ' . ArrayMerge::getNiceFileSize(memory_get_usage(true)) . PHP_EOL;$timeFive = microtime(true);echo PHP_EOL;echo 'eachOne | ' . ($timeTwo - $timeOne) . PHP_EOL;echo 'eachTwo | ' . ($timeThree - $timeTwo) . PHP_EOL;echo 'eachThree | ' . ($timeFour - $timeThree) . PHP_EOL;echo 'eachFour | ' . ($timeFive - $timeFour) . PHP_EOL;echo PHP_EOL 结果12345678910111213141516count eachOne Result | 100000memory eachOne Result | 8MiBcount eachTwo Result | 100000memory eachTwo Result | 12MiBcount eachThree Result | 100000memory eachThree Result | 16MiBcount eachFour Result | 10memory eachFour Result | 16MiBeachOne | 3.4798429012299eachTwo | 0.00077700614929199eachThree | 0.0030550956726074eachFour | 0.00097990036010742 循环体使用array_merge()最慢,而且耗费内存 循环体结束后使用array_merge()最快 循环体嵌套循比环体结束后使用array_merge()慢三倍 看似也很快,但是合并的结果有问题 合并数组的坑 我们注意到刚刚的 eachFour 的结果长度只有 10 下面探究为什么会出现这样的结果 这里拿递归合并一起做下对比 代码1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass ArrayMerge&#123; public static function test(): void &#123; $testA = [ '111' =&gt; 'testA1', 'abc' =&gt; 'testA1', '222' =&gt; 'testA2', ]; $testB = [ '111' =&gt; 'testB1', 'abc' =&gt; 'testB1', '222' =&gt; 'testB2', 'www' =&gt; 'testB1', ]; echo 'array_merge($testA, $testB) | ' . PHP_EOL; print_r(array_merge($testA, $testB)); echo '$testA + $testB | ' . PHP_EOL; print_r($testA + $testB); echo '$testB + $testA | ' . PHP_EOL; print_r($testB + $testA); echo 'array_merge_recursive($testA, $testB) | ' . PHP_EOL; print_r(array_merge_recursive($testA, $testB)); &#125;&#125;$array_merge = new ArrayMerge();$array_merge-&gt;test(); 结果1234567891011121314151617181920212223242526272829303132333435363738394041array_merge($testA, $testB) | # 数字索引强制从0开始了 字符key相同的以后者为准Array( [0] =&gt; testA1 [abc] =&gt; testB1 [1] =&gt; testA2 [2] =&gt; testB1 [3] =&gt; testB2 [www] =&gt; testB1)$testA + $testB | # testA得到保留，testB补充了testA中没有的key，数字索引得到保留Array( [111] =&gt; testA1 [abc] =&gt; testA1 [222] =&gt; testA2 [www] =&gt; testB1)$testB + $testA | # testB得到保留，testA补充了testB中没有的key，数字索引得到保留Array( [111] =&gt; testB1 [abc] =&gt; testB1 [222] =&gt; testB2 [www] =&gt; testB1)array_merge_recursive($testA, $testB) | # 数字索引从0开始连续了，但数组的顺序没有被破坏，相同的字符串 `key` 合并为一个数组Array( [0] =&gt; testA1 [abc] =&gt; Array ( [0] =&gt; testA1 [1] =&gt; testB1 ) [1] =&gt; testA2 [2] =&gt; testB1 [3] =&gt; testB2 [www] =&gt; testB1) 分析看到这里，你一定非常疑惑，没想到 array_merge() 还有这样的坑 我们先来看一看官方的手册 array_merge() 将一个或多个数组的单元合并起来，一个数组中的值附加在前一个数组的后面。返回作为结果的数组。 如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。然而，如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。 如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。 只有相同的字符串键名，后边的值才会覆盖前面的值。（但是手册中没有解释为什么数字键名的索引被重置了） 那么我们来看一下源码 1234567891011121314151617181920212223242526272829303132333435363738PHPAPI int php_array_merge(HashTable *dest, HashTable *src)&#123; zval *src_entry; zend_string *string_key; if ((dest-&gt;u.flags &amp; HASH_FLAG_PACKED) &amp;&amp; (src-&gt;u.flags &amp; HASH_FLAG_PACKED)) &#123; // 自然数组的合并，HASH_FLAG_PACKED表示数组是自然数组（[0,1,2]） 参考http://ju.outofmemory.cn/entry/197064 zend_hash_extend(dest, zend_hash_num_elements(dest) + zend_hash_num_elements(src), 1); ZEND_HASH_FILL_PACKED(dest) &#123; ZEND_HASH_FOREACH_VAL(src, src_entry) &#123; if (UNEXPECTED(Z_ISREF_P(src_entry)) &amp;&amp; UNEXPECTED(Z_REFCOUNT_P(src_entry) == 1)) &#123; ZVAL_UNREF(src_entry); &#125; Z_TRY_ADDREF_P(src_entry); ZEND_HASH_FILL_ADD(src_entry); &#125; ZEND_HASH_FOREACH_END(); &#125; ZEND_HASH_FILL_END(); &#125; else &#123; //遍历获取key和vaule ZEND_HASH_FOREACH_STR_KEY_VAL(src, string_key, src_entry) &#123; if (UNEXPECTED(Z_ISREF_P(src_entry) &amp;&amp; Z_REFCOUNT_P(src_entry) == 1)) &#123; ZVAL_UNREF(src_entry); &#125; Z_TRY_ADDREF_P(src_entry); // 参考https://github.com/pangudashu/php7-internal/blob/master/7/var.md if (string_key) &#123; // 字符串key（zend_string） 插入或者更新元素，会增加key的计数 zend_hash_update(dest, string_key, src_entry); &#125; else &#123; //插入新元素，使用自动的索引值(破案了，索引被重置的原因在此) zend_hash_next_index_insert_new(dest, src_entry); &#125; &#125; ZEND_HASH_FOREACH_END(); &#125; return 1;&#125; 总结综上所述，合并数组的不同方式都存在一定的缺陷，但是通过我们上面的探究，我们了解到 循环体中使用 array_merge() 合并数组不可取，速度差距达百倍 array_merge() 合并数组要慎用，如果重视 key ，且 key 可能为数字，不能使用 array_merge() 来合并，我们可以采用循环体嵌套的方式（注意内层循环使用 key 进行赋值操作） 如果重视 key ，且 key 可能为数字，简单合并数组可以使用运算符 + ，但是一定不要在循环体中使用，因为每次运算的的结果都是生成了一个新的数组","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"array_merge","slug":"array-merge","permalink":"http://blog.caoxl.com/tags/array-merge/"}]},{"title":"PHP 缓存技术","slug":"PHP-Cache-Notes","date":"2019-03-20T02:23:37.000Z","updated":"2019-03-20T04:01:23.000Z","comments":true,"path":"2019/03/20/PHP-Cache-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/03/20/PHP-Cache-Notes/","excerpt":"本文在掘金第一次看到,不过也是转载文原文链接：mp.weixin.qq.com","text":"本文在掘金第一次看到,不过也是转载文原文链接：mp.weixin.qq.com 概述缓存已经成了项目中是必不可少的一部分，它是提高性能最好的方式，例如减少网络I/O、减少磁盘I/O 等，使项目加载速度变的更快。 缓存可以是CPU缓存、内存缓存、硬盘缓存，不同的缓存查询速度也不一样（CPU缓存 优于 内存缓存 优于 硬盘缓存）。 接下来，给大家逐一进行介绍。 浏览器缓存 浏览器将请求过的页面存储在客户端缓存中，当访问者再次访问这个页面时，浏览器就可以直接从客户端缓存中读取数据，减少了对服务器的访问，加快了网页的加载速度。 强缓存用户发送的请求，直接从客户端缓存中获取，不请求服务器。 根据 Expires 和 Cache-Control 判断是否命中强缓存。 代码如下: 123header('Expires: '. gmdate('D, d M Y H:i:s', time() + 3600). ' GMT');header(\"Cache-Control: max-age=3600\"); //有效期3600秒 Cache-Control 还可以设置以下参数： public: 可以被所有的用户缓存（终端用户的浏览器/CDN服务器） private: 只能被终端用户的浏览器缓存 no-cache: 不使用本地缓存 no-store: 禁止缓存数据 协商缓存用户发送的请求，发送给服务器，由服务器判定是否使用客户端缓存。 代码如下： 12345678910111213$last_modify = strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE']);if (time() - $last_modify &lt; 3600) &#123; header('Last-Modified: '. gmdate('D, d M Y H:i:s', $last_modify).' GMT'); header('HTTP/1.1 304'); //Not Modified exit;&#125;header('Last-Modified: '. gmdate('D, d M Y H:i:s').' GMT'); 用户操作行为对缓存的影响 操作行为 Expires Last-Modified 地址栏回车 有效 有效 页面跳转 有效 有效 新开窗口 有效 有效 前进/后退 有效 有效 F5刷新 无效 有效 Ctrl+F5 无效 无效 文件缓存数据文件缓存将更新频率低，读取频率高的数据，缓存成文件。 比如，项目中多个地方用到城市数据做三级联动，我们就可以将城市数据缓存成一个文件（city_data.json），JS 可以直接读取这个文件，无需请求后端服务器。 全站静态化CMS（内容管理系统），也许大家都比较熟悉，比如早期的 DEDE、PHPCMS，后台都可以设置静态化HTML，用户在访问网站的时候读取的都是静态HTML，不用请求后端的数据库，也不用Ajax请求数据接口，加快了网站的加载速度。 静态化HTML有以下优点: 有利于搜索引擎的收录(SEO) 页面打开速度快 减少服务器负担 CDN CDN（Content Delivery Network）内容分发网络。 用户访问网站时，自动选择就近的CDN节点内容，不需要请求源服务器，加快了网站的打开速度。 缓存主要包括 HTML、图片、CSS、JS、XML 等静态资源。 NoSQL缓存Memcached Memcached 是高性能的分布式内存缓存服务器。 一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。 它也能够用来存储各种格式的数据，包括图像、视频、文件等。 Memcached 仅支持K/V类型的数据，不支持持久化存储。 Memcache 与 Memcached 的区别 区别 Memcached Memcache PHP版本 &gt;=5.2.0 &gt;=4.3 发布时间 2018-12-24 2013-04-07 基于 libmemcached PECL 可以将 Memcached 看作是 Memcache 的升级版。 PHP Memcached 使用手册 Memcached 经常拿来与 Redis 做对比，接下来介绍下 Redis 缓存。 Redis Redis 是一个高性能的 K/V 数据库。 Redis 很大程度补偿了 Memcached K/V存储的不足，比如 List（链表）、Set（集合）、Zset（有序集合）、Hash（散列），既可以将数据存储在内存中，也可以将数据持久化到磁盘上，支持主从同步。 总的来说，可以将 Redis 看作是 Memcached 的扩展版，更加重量级，功能更强大。 Redis 在日常工作中使用的居多。 Redis 学习网址 &amp;&amp; Redis 命令参考 MongoDB MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 **MongoDB 学习网址 WEB服务器缓存Apache缓存利用 mod_expires ，指定缓存的过期时间，可以缓存HTML、图片、JS、CSS 等。 打开 http.conf，开启模块： 1LoadModule expires_module modules / mod_expires.so 指定缓存的过期时间： 1234567891011121314151617181920&lt;IfModule expires_module&gt; #打开缓存 ExpiresActive on #css缓存(8640000秒=10天) ExpiresByType text/css A8640000 #js缓存 ExpiresByType application/x-javascript A8640000 ExpiresByType application/javascript A8640000 #html缓存 ExpiresByType text/html A8640000 #图片缓存 ExpiresByType image/jpeg A8640000 ExpiresByType image/gif A8640000 ExpiresByType image/png A8640000 ExpiresByType image/x-icon A8640000 &lt;/IfModule&gt; Nginx缓存利用 expire 参数，指定缓存的过期时间，可以缓存HTML、图片、JS、CSS 等。 打开 nginx.conf ： 12345//以图片为例：location ~\\.(gif|jpg|jepg|png|bmp|ico)$ &#123; #加入新的location root html; expires 1d; #指定缓存时间&#125; 大家也可以了解下：proxycachepath 和 proxy_cache，进行缓存的设置。 Opcode缓存 Opcode（Operate Code）操作码。 PHP程序运行完后，马上释放所有内存，所有程序中的变量都销毁，每次请求都要重新翻译、执行，导致速度可能会偏慢。 当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码。 操作码 的目地是避免重复编译，减少CPU和内存开销。 APC APC（Alternative PHP Cache）可选 PHP 缓存。 APC 的目标是提供一个自由、 开放，和健全的框架，用于缓存、优化 PHP 中间代码。 APC 可以去掉 php 动态解析以及编译的时间，使php脚本可以执行的更快。 APC 扩展最后的发布时间为 2012-09-03。 感兴趣可以了解下，官方介绍：http://php.net/manual/zh/book.apc.php eAccelerator eAccelerator：A PHP opcode cache。 感兴趣可以了解下，官方介绍：http://eaccelerator.net/ XCache XCache 是一个又快又稳定的 PHP opcode 缓存器。 感兴趣可以了解下，官方介绍：http://xcache.lighttpd.net/ 小结文章主要简单的介绍了 浏览器缓存、文件缓存、NoSQL缓存、WEB服务器缓存、Opcode缓存。 每一种缓存都可以深入研究，从介绍 -&gt; 安装 -&gt; 使用 -&gt; 总结应用场景。 大家可以思考下，通过上面的介绍，工作中我们使用了哪些缓存？ 还可以再使用哪些缓存，可以对我们的项目有帮助？ 关于缓存的常见问题用过缓存，大家肯定遇到过比较头痛的问题，比如数据一致性，雪崩，热点数据缓存，缓存监控等等。 给大家列出几个问题，纯属抛转引玉。 当项目中使用到缓存，我们是选择 Redis 还是 Memcached ，为什么？举一些场景： 比如实现一个简单的日志收集功能或发送大量短信、邮件的功能，实现方式是先将数据收集到队列中，然后有一个定时任务去消耗队列，处理该做的事情。 直接使用 Redis 的 lpush，rpop 或 rpush，lpop。 12345//进队列$redis-&gt;lpush(key, value);//出队列$redis-&gt;rpop(key); Memcached 没有这种数据结构。 比如我们要存储用户信息，ID、姓名、电话、年龄、身高 ，怎么存储？ 方案一：key =&gt; value 123key = userdata(用户ID) value = json_encode(用户数据) 查询时，先取出key，然后进行json_decode解析。 方案二：hash 123456789key = userdata(用户ID)hashKey = 姓名，value = xxhashKey = 电话，value = xxhashKey = 年龄，value = xxhashKey = 身高，value = xx 查询时，取出key即可。 1234567891011//新增$redis-&gt;hSet(key, hashKey, value);$redis-&gt;hSet(key, hashKey, value);$redis-&gt;hSet(key, hashKey, value);//编辑$redis-&gt;hSet(key, hashKey, value);//查询$redis-&gt;hGetAll(key); //查询所有属性$redis-&gt;hGet(key, hashKey); //查询某个属性 方案二 优于 方案一。 比如社交项目类似于新浪微博，个人中心的关注列表和粉丝列表，双向关注列表，还有热门微博，还有消息订阅 等等。 以上都用 Redis 提供的相关数据结构即可。 Memcached 只存储在内存中，而 Redis 既可以存储在内存中，也可以持久化到磁盘上。 如果需求中的数据需要持久化，请选择 Redis 。 Memcached 默认使用 Slab Allocation 机制管理内存，按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。 如何保证，缓存与数据库的数据一致性？ 新增数据：先新增到数据库，再新增到缓存。 编辑数据：先删除缓存数据，再修改数据库中数据，再新增到缓存。 删除数据：先删除缓存数据，再删除数据库中数据。 查询数据：先查询缓存数据，没有，再查询数据库，再新增到缓存。 强一致性是很难保证的，比如事务一致性，时间点一致性，最终一致性等。 缓存穿透怎么办？ 缓存穿透: 用户请求缓存中不存在的数据，导致请求直接落在数据库上。 设置有规则的Key值，先验证Key是否符合规范。 接口限流、降级、熔断，请研究 istio：https://istio.io/ 布隆过滤器。(没有打错字就是这个布隆过滤器) 为不存在的key值，设置空缓存和过期时间，如果存储层创建了数据，及时更新缓存。 雪崩怎么办? 互斥锁，只允许一个请求去重建索引，其他请求等待缓存重建执行完，重新从缓存获取数据。 双缓存策略，原始缓存和拷贝缓存，当原始缓存失效请求拷贝缓存，原始缓存失效时间设置为短期，拷贝缓存设置为长期。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"缓存","slug":"缓存","permalink":"http://blog.caoxl.com/tags/缓存/"}]},{"title":"Monolog - Logging for PHP","slug":"Monolog","date":"2019-03-15T03:10:25.000Z","updated":"2019-03-15T03:57:56.000Z","comments":true,"path":"2019/03/15/Monolog/","link":"","permalink":"http://blog.caoxl.com/2019/03/15/Monolog/","excerpt":"Monolog sends your logs to files, sockets, inboxes, databases and various web services. See the complete list of handlers below. Special handlers allow you to build advanced logging strategies.","text":"Monolog sends your logs to files, sockets, inboxes, databases and various web services. See the complete list of handlers below. Special handlers allow you to build advanced logging strategies. 先看使用Lumen重写日志 首先在bootstrap\\app.php中修改: 123$app = new App\\Application( realpath(__DIR__.'/../')); 然后再修改Application 123456789101112131415161718192021222324252627&lt;?php// Custom default or hard-coded behavior of lumen// @caoxlnamespace App;use Laravel\\Lumen\\Application as LumenBase;use Monolog\\Formatter\\LineFormatter;use Monolog\\Handler\\StreamHandler;use Monolog\\Logger;class Application extends LumenBase&#123; // Rewrite log handler protected function getMonologHandler() &#123; return ( new StreamHandler(storage_path(env( 'APP_LOG_PATH', 'logs/' . date('Y-m-d') . '.log' )), Logger::DEBUG )) -&gt;setFormatter(new LineFormatter(null, null, true, true)); &#125;&#125; TP重写日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpnamespace App\\Http\\Controllers\\Common;use Monolog\\Handler\\BrowserConsoleHandler;use Monolog\\Handler\\RotatingFileHandler;use Monolog\\Handler\\SocketHandler;use Monolog\\Logger;use Monolog\\Formatter\\LineFormatter;class BGCLogger&#123; /** * 一个简便的日志 * @author caoxl * @param $name * @param int $log_level * @param string $file_name * @return Logger */ public static function getLogger($name, $log_level = Logger::INFO, $file_name = 'bgc.log') &#123; $log_socket = C('LOGGING_SOCKET'); $log_debug = intval(C('LOGGING_DEBUG')); $log_browser = intval(C('LOGGING_BROWSER')); if (0 != $log_debug) &#123; $log_level = Logger::DEBUG; &#125; $log_path = LOG_PATH . $file_name; $logger = new Logger($name); $handler = new RotatingFileHandler($log_path, 10, $log_level); $module_name = defined('BIND_MODULE') ? BIND_MODULE : 'UNKNOWN'; $formatter = new LineFormatter(\"%datetime% \" . $module_name . \".%channel%.%level_name%: %message%\\n\", 'Y-m-d H:i:s'); $handler-&gt;setFormatter($formatter); $logger-&gt;pushHandler($handler, $log_level); if (!empty($log_socket)) &#123; $sock = new SocketHandler($log_socket, $log_level); if ($sock) &#123; $sock-&gt;setFormatter($formatter); $sock-&gt;setLevel($log_level); $logger-&gt;pushHandler($sock, $log_level); &#125; &#125; if (0 != $log_browser) &#123; $browser = new BrowserConsoleHandler($log_level); $browser-&gt;setFormatter($formatter); $browser-&gt;setLevel($log_level); $logger-&gt;pushHandler($browser, $log_level); &#125; return $logger; &#125;&#125; 安装1composer require monolog/monolog 日志等级 DEBUG (100) INFO (200) NOTICE (250) WARNING (300) ERROR (400) CRITICAL (500) ALERT (550) EMERGENCY (600) 基础使用1234567891011121314151617181920212223use Monolog\\Logger;use Monolog\\Handler\\StreamHandler;use Mongolog\\Handler\\FirePHPHandler;// Create some handlers$stream = new StreamHandler(__DIR__ . '/my_app.log', Logger::DEBUG);$firephp = new FirePHPHandler();// Create the main logger of the app$logger = new Logger('my_logger');$logger-&gt;pushHandler($stream);$logger-&gt;pushHandler($firephp);// Create a logger for the security-related stuff with a different channel$securityLogger = new Logger('security');$securityLogger-&gt;pushHandler($stream);$securityLogger-&gt;pushHandler($firephp);// Or clone the first one to only change the channel$securityLogger = $logger-&gt;withName('security');// you can use your logger$logger-&gt;info('My logger is now ready'); 自定义日志格式12345678910111213// the default date format is \"Y-m-d H:i:s\"$dateFormate = \"Y n j, g:i a\";// the default output format is \"[%datetime%] %channel%.%level_name%: %message% %context% %extra%\\n\"$output = \"%datetime% &gt; $level_name% &gt; %message% %content% %extra%\\n\";// finally, create a formatter$formatter = new LineFormatter($output, $dateFormat);// Create a handler$stream = new StreamHandler(__DIR__ . '/my_app.log', Logger::DEBUG);$stream-&gt;setFormatter($formatter);// bind it to a logger object$securityLogger = new Logger('sucurity');$securityLogger-&gt;pushHandler($stream);","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Monolog","slug":"Monolog","permalink":"http://blog.caoxl.com/tags/Monolog/"}]},{"title":"DingMsg","slug":"DingMsg","date":"2019-03-15T02:48:41.000Z","updated":"2019-08-22T06:44:05.000Z","comments":true,"path":"2019/03/15/DingMsg/","link":"","permalink":"http://blog.caoxl.com/2019/03/15/DingMsg/","excerpt":"","text":"运维小工具: 使用钉钉给自己发邮件 直接看源码1234567891011public static function dingMsg(string $msg)&#123; static $url = 'https://oapi.dingtalk.com/robot/send?access_token=xxx'; $curl = new Curl(); $curl-&gt;post_json($url, [ 'msgtype' =&gt; 'text', 'text' =&gt; [ 'content' =&gt; $msg, ] ]);&#125; 操作 使用钉钉创建一个群聊,然后加入一个自定义机器人,复制webhook链接 使用curl访问链接,发生消息 使用 在系统发出警报的时候通过钉钉给自己发生报警消息","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"DingMsg","slug":"DingMsg","permalink":"http://blog.caoxl.com/tags/DingMsg/"}]},{"title":"QueryList 数据采集","slug":"QueryList-Notes","date":"2019-03-08T03:04:50.000Z","updated":"2019-08-22T06:10:29.000Z","comments":true,"path":"2019/03/08/QueryList-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/03/08/QueryList-Notes/","excerpt":"QueryList是一套用于内容采集的PHP工具，它使用更加现代化的开发思想，语法简洁、优雅，可扩展性强。相比传统的使用晦涩的正则表达式来做采集，QueryList使用了更加强大而优雅的CSS选择器来做采集，大大降低了PHP做采集的门槛，同时也让采集代码易读易维护","text":"QueryList是一套用于内容采集的PHP工具，它使用更加现代化的开发思想，语法简洁、优雅，可扩展性强。相比传统的使用晦涩的正则表达式来做采集，QueryList使用了更加强大而优雅的CSS选择器来做采集，大大降低了PHP做采集的门槛，同时也让采集代码易读易维护 示例代码先来感受一下使用 QueryList 来做采集是什么样子。 采集百度搜索结果列表的标题和链接。 采集代码 123456789$data = QueryList::get('https://www.baidu.com/s?wd=QueryList') // 设置采集规则 -&gt;rules([ 'title' =&gt; array('h3', 'text'), 'link' =&gt; array('h3&gt;a', 'href') ]) -&gt;queryData();print_r($data); 采集结果 12345678910111213141516171819Array( [0] =&gt; Array ( [title] =&gt; QueryList|基于phpQuery的无比强大的PHP采集工具 [link] =&gt; http://www.baidu.com/link?url=GU_YbDT2IHk4ns1tjG2I8_vjmH0SCJEAPuuZN ) [1] =&gt; Array ( [title] =&gt; PHP 用QueryList抓取网页内容 - wb145230 - 博客园 [link] =&gt; http://www.baidu.com/link?url=zn0DXBnrvIF2ibRVW34KcRVFG1_bCdZvqvwIhUqiXaS ) [2] =&gt; Array ( [title] =&gt; 介绍- QueryList指导文档 [link] =&gt; http://www.baidu.com/link?url=pSypvMovqS4v2sWeQo5fDBJ4EoYhXYi0Lxx ) //...) 分别采集百度搜索结果列表的标题和链接。 采集代码 1234567$ql = QueryList::get('https://www.baidu.com/s?wd=QueryList');// 获取搜索结果标题列表$titles = $ql-&gt;find('h3&gt;a')-&gt;texts();// 获取搜索结果链接标题$links = $ql-&gt;find('h3&gt;a')-&gt;attrs('href');print_r($titles);print_r($links); 采集结果 1234567891011121314151617181920212223242526Array( [0] =&gt; QueryList|简洁、优雅的PHP采集工具 [1] =&gt; phpQuery选择器 - QueryList 4.0 指导文档 [2] =&gt; php写爬虫进行采集 QueryList的使用 - CSDN博客 [3] =&gt; QueryList采集在线测试 [4] =&gt; 介绍- QueryList 4.0 指导文档 [5] =&gt; QueryList交流社区|基于phpQuery的无比强大的采集工具 [6] =&gt; 介绍- QueryList 3.0 指导文档 [7] =&gt; thinkphp5使用QueryList实现采集功能 - 坚持一点点 - 博客园 [8] =&gt; QueryList一个基于phpQuery的无比强大的采集工具 - ThinkPHP框架 [9] =&gt; php使用QueryList轻松采集JavaScript动态渲染页面 - QueryList - ...)Array( [0] =&gt; http://www.baidu.com/link?url=CNKBNz0t9t6YLmIfXjKYnIkcQ-JzNOpAyiAHPDSnlkmrEqMq5q9o44ElplTf7nON [1] =&gt; http://www.baidu.com/link?url=VKDqdL3WXxuy0xV3uHMDXRrqQlWGhh4qMQ5h4UCBw0sRJvE9uLlMbr5fE_gsURX8oehsAyzi9_QxVuC1CBjoTa [2] =&gt; http://www.baidu.com/link?url=rjDcaEbicrZjIG-iFJdkHJTWxoxYA2EBatxh-EyvMDdPMPxtOi8nDUi7UiuIgmW9X7o6CvcFUqPqCrqJp7M4FmRKpJ52-ceBowE0ek_jb5O [3] =&gt; http://www.baidu.com/link?url=9FAlKAB_4xCVP1hv_RlpPN8ROxsTSTDHpnvvxYn4j_veTkhxHfaPHUFAtc8BctDmN9ZVigMS7ggaVy778zAMzK [4] =&gt; http://www.baidu.com/link?url=CFOkrOHOFsWPddZC1fuRv8ZqwhbF7P6vH1Pg1covRawG6wsmszFW1qnxHf7mWKPM [5] =&gt; http://www.baidu.com/link?url=7kCwV_WRMZjWAeyOWP3zfX4Jx21tPeZhmyuENciN86BBd_g8znMD3JgEEfvGRbNc [6] =&gt; http://www.baidu.com/link?url=p3JenyGg7qtP7lSKXkbLM8_eGTzxzjJGch7__-8fmuIsZOdEQbCquS6P_NdR4LoG [7] =&gt; http://www.baidu.com/link?url=_EJBv9sxVtGT1paHERifcDHEaG8twDHk-Av2JD5DlkJUvipLAdNqovTdXAxijcI3LTaC3F_jYuMkHuTOJ0ic7_ [8] =&gt; http://www.baidu.com/link?url=ad9pwRrrkyTVOB7ZMKN29XyLX1MsXRIFPbA0ldPLTQQ58Dnw_YpZFKJZwxZ-jfaL [9] =&gt; http://www.baidu.com/link?url=mEjYM95SeHFYCnfITubUoTOj7XWR1NparEcb3hCGqPGv_uChSvVFat6xcvyCz_9mLogw5ol5gU_isHqYRTJj2q) 安装QueryList1composer require jaeger/querylist 开发必备 会使用Composer 非常熟悉jQuery选择器或CSS选择器 QueryList的核心思想就是使用jQuery选择器来做采集，所以选择器语法会贯穿全文 使用QueryList无框架依赖，可以灵活的嵌入到任何项目中去。 123456789101112131415161718&lt;?phpnamespace App\\Http\\Controllers;use QL\\QueryList;class TestQueryList&#123; public function index() &#123; // 采集某页面所有的图片 $data = QueryList::get('http://cms.querylist.cc/bizhi/453.html') -&gt;find('img') -&gt;attrs('src'); print_r($data-&gt;all()); &#125;&#125; 基础HTTP客户端 HTTP客户端用于抓取网页HTML源码。 QueryList推荐使用GuzzleHttp来作为HTTP客户端，它功能强大、使用简单、支持异步和并发请求，GuzzleHttp使用文档：http://guzzle-cn.readthedocs.io/zh_CN/latest/。默认安装好QueryList之后就可以直接使用GuzzleHttp了： 123456$client = new GuzzleHttp\\Client();$res = $client-&gt;request('GET', 'https://www.baidu.com/s', [ 'wd' =&gt; 'QueryList']);$html = (string)$res-&gt;getBody();$data = QueryList::html($html)-&gt;find('h3')-&gt;texts(); QueryList内置的HTTP客户端 为方便使用，QueryList基于GuzzleHttp封装了一些HTTP请求接口，并进行了简化，请求参数与GuzzleHttp一致，在请求参数上有什么不明白的地方可以直接查看GuzzleHttp文档。 目前封装的HTTP接口有: get(): GET请求 post(): POST请求 postJson(): POST JSON请求 multiGet(): 并发GET请求 multiPost(): 并发POST请求 用法get()方法和post()方法用法和参数完全一致，且共享cookie。 123456789101112$ql = QueryList::get('http://httpbin.org/get?param1=testvalue&amp;params2=somevalue');// 等价于$ql-&gt;get('http://httpbin.org/get',[ 'param1' =&gt; 'testvalue', 'params2' =&gt; 'somevalue']);// 发送post请求$ql = QueryList::post('http://httpbin.org/post',[ 'param1' =&gt; 'testvalue', 'params2' =&gt; 'somevalue']); 自定义HTTP Header12345678910111213$ql = QueryList::get('http://httpbin.org/get',[ 'param1' =&gt; 'testvalue', 'params2' =&gt; 'somevalue'],[ 'headers' =&gt; [ 'Referer' =&gt; 'https://querylist.cc/', 'User-Agent' =&gt; 'testing/1.0', 'Accept' =&gt; 'application/json', 'X-Foo' =&gt; ['Bar', 'Baz'], // 携带cookie 'Cookie' =&gt; 'abc=111;xxx=222' ]]); 更高级参数 还可以携带更多高级参数，如：设置超时时间、设置代理等 12345678910111213141516171819202122232425262728293031$ql = QueryList::get('http://httpbin.org/get',[ 'param1' =&gt; 'testvalue', 'params2' =&gt; 'somevalue'],[ // 设置代理 'proxy' =&gt; 'http://222.141.11.17:8118', //设置超时时间，单位：秒 'timeout' =&gt; 30, 'headers' =&gt; [ 'Referer' =&gt; 'https://querylist.cc/', 'User-Agent' =&gt; 'testing/1.0', 'Accept' =&gt; 'application/json', 'X-Foo' =&gt; ['Bar', 'Baz'], 'Cookie' =&gt; 'abc=111;xxx=222' ]]);$ql-&gt;post('http://httpbin.org/post',[ 'param1' =&gt; 'testvalue', 'params2' =&gt; 'somevalue'],[ 'proxy' =&gt; 'http://222.141.11.17:8118', 'timeout' =&gt; 30, 'headers' =&gt; [ 'Referer' =&gt; 'https://querylist.cc/', 'User-Agent' =&gt; 'testing/1.0', 'Accept' =&gt; 'application/json', 'X-Foo' =&gt; ['Bar', 'Baz'], 'Cookie' =&gt; 'abc=111;xxx=222' ]]); 并发请求(多线程请求) 简单用法，默认并发数为5 123456789101112131415use GuzzleHttp\\Psr7\\Response;use QL\\QueryList;$urls = [ 'https://github.com/trending/go?since=daily', 'https://github.com/trending/html?since=daily', 'https://github.com/trending/java?since=daily'];QueryList::multiGet($urls) -&gt;success(function(QueryList $sql, Response $response, $index) use ($urls) &#123; echo 'Current url: '.$urls[$index].\"\\r\\n\"; $data = $ql-&gt;find('h3&gt;a')-&gt;texts(); print_r($data-&gt;all()); &#125;)-&gt;send(); 更高级的用法 12345678910111213141516171819202122232425262728293031323334353637se GuzzleHttp\\Psr7\\Response;use QL\\QueryList;$urls = [ 'https://github.com/trending/go?since=daily', 'https://github.com/trending/html?since=daily', 'https://github.com/trending/java?since=daily'];$rules = [ 'name' =&gt; ['h3&gt;a','text'], 'desc' =&gt; ['.py-1','text']];$range = '.repo-list&gt;li';QueryList::rules($rules) -&gt;range($range) -&gt;multiGet($urls) // 设置并发数为2 -&gt;concurrency(2) // 设置GuzzleHttp的一些其他选项 -&gt;withOptions([ 'timeout' =&gt; 60 ]) // 设置HTTP Header -&gt;withHeaders([ 'User-Agent' =&gt; 'QueryList' ]) // HTTP success回调函数 -&gt;success(function (QueryList $ql, Response $response, $index)&#123; $data = $ql-&gt;queryData(); print_r($data); &#125;) // HTTP error回调函数 -&gt;error(function (QueryList $ql, $reason, $index)&#123; // ... &#125;) -&gt;send(); 连贯操作 post操作和get操作是cookie共享的,意味着你可以先调用post()方法登录，然后get()方法就可以采集所有登录后的页面。 123456$ql = QueryList::post('http://xxxx.com/login',[ 'username' =&gt; 'admin', 'password' =&gt; '123456'])-&gt;get('http://xxx.com/admin');$ql-&gt;get('http://xxx.com/admin/page'); 获取抓取到的HTML 使用getHtml()方法可以获取到get()或post()方法返回的HTML内容，通常用于调试打印验证抓取结果等场景 12$ql = QueryList::get('http://httpbin.org/get?param1=testvalue');echo $ql-&gt;getHtml(); 获取HTTP响应头等信息 如果你想获取HTTP响应头，如响应状态码，QueryList内置的HTTP客户端屏蔽了这部分功能，请直接使用GuzzleHttp来实现。 12345678use GuzzleHttp\\Client;$client = new Client();$response = $client-&gt;get('http://httpbin.org/get');// 获取响应头部信息$headers = $response-&gt;getHeaders();print_r($headers); 自定义HTTP客户端 GuzzleHttp是一款功能非常强大的HTTP客户端，你想要的功能它几乎都有；但如果你还是想使用自己熟悉的HTTP客户端如:curl，那也是可以的： 123456789101112131415161718public function getHtml($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); curl_setopt($ch, CURLOPT_AUTOREFERER, true); curl_setopt($ch, CURLOPT_REFERER, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $result = curl_exec($ch); curl_close($ch); return $result;&#125;$html = getHtml('http://httpbin.org/get?param1=testvalue');// 这种情况下允许你对HTML做一些额外的处理后，然后再把HTML传给QueryList对象$html = str_replace('xxx','yyy',$html);$ql = QueryList::html($html);echo $ql-&gt;getHtml(); 通过其他HTTP客户端获取源码，然后使用html()方法来设置html，html()方法除了可以接收一个完整的HTML网页外，还支持接收HTML片段: 123456789101112$html = &lt;&lt;&lt;STR&lt;div id=\"one\"&gt; &lt;div class=\"two\"&gt; &lt;a href=\"http://querylist.cc\"&gt;QueryList官网&lt;/a&gt; &lt;img src=\"http://querylist.com/1.jpg\" alt=\"这是图片\"&gt; &lt;img src=\"http://querylist.com/2.jpg\" alt=\"这是图片2\"&gt; &lt;/div&gt; &lt;span&gt;其它的&lt;b&gt;一些&lt;/b&gt;文本&lt;/span&gt;&lt;/div&gt; STR;$ql = QueryList::html($html); phpQuery有个bug，那就是当HTML中有它无法识别的特殊字符时，HTML就会被截断，导致最终的采集结果不正确，此时可以尝试使用正则或其它方式获取到要采集的内容的HTML片段，把这个HTML片段传给QueryList，从而可以解决这种场景下的问题。 采集单元素 QueryList有个find()方法，用于采集单个元素，它通过jQuery选择器选择DOM元素，用法同jQuery的find()方法。 实战 - 采集IT之家文章页 如图采集IT之家文章页的：文章标题、作者和正文内容。 采集代码 12345678910111213141516use QL\\QueryList;public function test_query()&#123; $ql = QueryList::get('https://www.ithome.com/html/discovery/358585.htm'); $data = []; // 采集文章标题 $data['title'] = $ql-&gt;find('h1')-&gt;text(); // 采集文章作者 $data['author'] = $ql-&gt;find('#author_baidu&gt;strong')-&gt;text(); // 采集文章内容 $data['content'] = $ql-&gt;find('.post_content')-&gt;html(); print_r($data);&#125; 采集结果 12345678910Array( [title] =&gt; 巴基斯坦一城镇温度达50.2度：创下全球4月历史温度新高 [author] =&gt; 白猫 [content] =&gt; &lt;p&gt;&lt;a class=\"s_tag\" href=\"https://www.ithome.com/\" target=\"_blank\"&gt;IT之家&lt;/a&gt;5月6日消息 4月份就遇到超过50度的极端天气显然是不可想象的，不过这的的确确发生在我们的周围，目前在巴基斯坦的一个城镇，有气象观测站显示该地的温度最高达到50.2度，打破了全球有记录以来的四月最高温。&lt;/p&gt;&lt;p&gt;&lt;img src=\"//img.ithome.com/images/v2/t.png\" w=\"600\" h=\"400\" class=\"lazy\" title=\"巴基斯坦一城镇温度达50.2度：创下全球4月历史温度新高\" data-original=\"https://img.ithome.com/newsuploadfiles/2018/3/20180323_103720_572.png\" width=\"600\" height=\"400\"&gt;&lt;/p&gt;&lt;p&gt;根据天空新闻的报道，在位于巴基斯坦南部的纳瓦布沙在周一（4月30日）的时候出现了高达50.2度的气温，气象学家表示这或许是人类有史以来遇到的四月份最高的温度。&lt;/p&gt;&lt;p&gt;法国气象局的气象学家卡比奇安在推特上表示，巴基斯坦的这个小城镇不但是有史以来亚洲遇到的最高的四月气温，更有可能是全球四月的最高温，而也有网友表示由于过于炎热的天气，当地已经有不少人因为中暑而丧命。&lt;/p&gt;&lt;p&gt;全球极端天气专家克里斯托弗伯特也表示，四月份就达到50摄氏度极其罕见，纳瓦布沙的温度或将是人类有史以来遇到的温度最高的四月。农业学家表示巴基斯坦过高的温度会严重影响未来粮食的收割。&lt;/p&gt;) 采集列表 学习如何批量采集数据。列表采集才是QueryList的核心功能，这里主要涉及到两个函数的用法:rules()和range() 。 采集代码(进一步优化采集单元素的代码) 1234567891011121314151617public function test_rule()&#123; $url = 'https://www.ithome.com/html/discovery/358585.htm'; // 定义采集规则 $rules = [ // 采集文章标题 'title' =&gt; ['h1', 'text'], // 采集文章作者 'author' =&gt; ['#author_baidu&gt;strong', 'text'], // 采集文章内容 'content' =&gt; ['.post_content', 'html'] ]; $data = QueryList::get($url)-&gt;rules($rules)-&gt;query()-&gt;getData(); print_r($data-&gt;all());&#125; 采集结果 1234567891011121314Array( [0] =&gt; Array ( [title] =&gt; 巴基斯坦一城镇温度达50.2度：创下全球4月历史温度新高 [author] =&gt; 白猫 [content] =&gt; &lt;p&gt;&lt;a class=\"s_tag\" href=\"https://www.ithome.com/\" target=\"_blank\"&gt;IT之家&lt;/a&gt;5月6日消息 4月份就遇到超过50度的极端天气显然是不可想象的，不过这的的确确发生在我们的周围，目前在巴基斯坦的一个城镇，有气象观测站显示该地的温度最高达到50.2度，打破了全球有记录以来的四月最高温。&lt;/p&gt;&lt;p&gt;&lt;img src=\"//img.ithome.com/images/v2/t.png\" w=\"600\" h=\"400\" class=\"lazy\" title=\"巴基斯坦一城镇温度达50.2度：创下全球4月历史温度新高\" data-original=\"https://img.ithome.com/newsuploadfiles/2018/3/20180323_103720_572.png\" width=\"600\" height=\"400\"&gt;&lt;/p&gt;&lt;p&gt;根据天空新闻的报道，在位于巴基斯坦南部的纳瓦布沙在周一（4月30日）的时候出现了高达50.2度的气温，气象学家表示这或许是人类有史以来遇到的四月份最高的温度。&lt;/p&gt;&lt;p&gt;法国气象局的气象学家卡比奇安在推特上表示，巴基斯坦的这个小城镇不但是有史以来亚洲遇到的最高的四月气温，更有可能是全球四月的最高温，而也有网友表示由于过于炎热的天气，当地已经有不少人因为中暑而丧命。&lt;/p&gt;&lt;p&gt;全球极端天气专家克里斯托弗伯特也表示，四月份就达到50摄氏度极其罕见，纳瓦布沙的温度或将是人类有史以来遇到的温度最高的四月。农业学家表示巴基斯坦过高的温度会严重影响未来粮食的收割。&lt;/p&gt; )) $rules规则解释如下: 12345$rules = [ '规则名1' =&gt; ['选择器1','元素属性'], '规则名2' =&gt; ['选择器2','元素属性'], // ...]; 采集结果与前面的代码完全相同，注意这里的采集结果是一个二维数组。 queryData()语法糖可能你会觉的列表采集的语法有一点点繁琐，如: 12$rt = QueryList::get($url)-&gt;rules($rules)-&gt;query()-&gt;getData();print_r($rt-&gt;all()); QueryList V4.0.4版本新增了一个queryData()语法糖来简化这种操作: 12$rt = QueryList::get($url)-&gt;rules($rules)-&gt;queryData();print_r($rt); queryData()方法等同于query()-&gt;getData()-&gt;all()。 列表采集前面只说到采集文章页内容，通常情况下我们会先采集列表页，然后再循环采集列表中的每篇文章，采集列表需要用到range()函数来配合rules()函数。 采集代码 123456789101112131415161718192021222324public function test_list()&#123; $url = 'https://it.ithome.com/ityejie/'; // 元数据采集规则 $rules = [ // 采集文章标题 'title' =&gt; ['h2&gt;a', 'text'], // 采集链接 'link' =&gt; ['h2&gt;a', 'href'], // 采集缩略图 'img' =&gt; ['.list_thumbnail&gt;img', 'src'], // 采集文档简介 'desc' =&gt; ['.memo', 'text'] ]; // 切片选择器 $range = '.ulcl'; $data = QueryList::get($url)-&gt;rules($rules) -&gt;range($range) -&gt;query() -&gt;getData(); print_r($data-&gt;all());&#125; 采集结果 1234567891011Array( [0] =&gt; Array ( [title] =&gt; 正式进军县镇市场，飞利浦“入座”苏宁零售云头等舱三星S10首销上演王者归来，苏宁门店被挤爆！苏宁维达战略签约，定下2019年销售翻番目标辱华风波代价大，D&amp;amp;G创始人双双跌出福布斯榜单12家中国驻外使领馆开通支付宝，网友点名其他国家地区“赶紧跟上！”斯坦·李推特“死而复生”给《惊奇队长》打广告，粉丝怒喷运营团队熊猫直播官方宣布停服：主站“流浪计划”开启万事网联公司成立：注册资本10亿元，万事达持股51%董明珠：偷手机、捡手机不归还应受到更严厉的惩罚Valve承认裁员13人：主要为VR部门，公司不会有重大变化天猫上的女性创业者：涉足市场更纵深、初创者年轻化PHP 7.1.27/7.2.16/7.3.3发布商家网售伪造微信朋友圈照片视频素材包，3万多张卖一块一【更新】链家左晖被限制消费？官方回应：无实质关系，正向法院沟通TCL展示Alcatel 7手机：后置4800万像素，支持5G人民日报刊文：App收集使用个人信息必须有法律依据传罗永浩出售锤子空气净化器业务：原荣耀总裁刘江峰将接手消息：特斯拉将取消中国一线销售人员提成，并关闭线下门店小米9 “无闪尊享版”版后续：官方紧急调换，补偿一个保护套宣布起诉美国现场，华为“趁机”给Mate X打了个广告 [link] =&gt; https://www.ithome.com/0/413/173.htm [img] =&gt; //img.ithome.com/images/v2/grey.gif [desc] =&gt; )) 数据是采集回来了，但我们发现有一点瑕疵，结果里面有一条结果是空的，且文章缩略图链接不正确。 采集代码 123456789101112131415161718192021222324public function test_list()&#123; $url = 'https://it.ithome.com/ityejie/'; // 元数据采集规则 $rules = [ // 采集文章标题 'title' =&gt; ['h2&gt;a', 'text'], // 采集链接 'link' =&gt; ['h2&gt;a', 'href'], // 采集缩略图,真正的图片链接在data-original属性上 'img' =&gt; ['.list_thumbnail&gt;img', 'data-original'], // 采集文档简介 'desc' =&gt; ['.memo', 'text'] ]; // 切片选择器, 跳过第一条广告 $range = '.ulcl&gt;li:gt(0)'; $data = QueryList::get($url)-&gt;rules($rules) -&gt;range($range) -&gt;query() -&gt;getData(); print_r($data-&gt;all());&#125; 采集结果 123456789101112131415161718192021222324252627Array( [0] =&gt; Array ( [title] =&gt; 正式进军县镇市场，飞利浦“入座”苏宁零售云头等舱 [link] =&gt; https://www.ithome.com/0/413/173.htm [img] =&gt; //img.ithome.com/newsuploadfiles/thumbnail/2019/3/413173_240.jpg [desc] =&gt; ) [1] =&gt; Array ( [title] =&gt; 三星S10首销上演王者归来，苏宁门店被挤爆！ [link] =&gt; https://www.ithome.com/0/413/171.htm [img] =&gt; //img.ithome.com/newsuploadfiles/thumbnail/2019/3/413171_240.jpg [desc] =&gt; ) [2] =&gt; Array ( [title] =&gt; 苏宁维达战略签约，定下2019年销售翻番目标 [link] =&gt; https://www.ithome.com/0/413/170.htm [img] =&gt; //img.ithome.com/newsuploadfiles/thumbnail/2019/3/413170_240.jpg [desc] =&gt; ) // ...) 就这样我们利用QueryList很轻松就采集到了IT之家的文章列表以及文章内容 关于方法的调用顺序get()、rules()和range() 这几个方法都属于QueryList属性设置方法，所以调用顺序可以随意，所以下面这几种写法都是等价的： 123QueryList::get($url)-&gt;rules($rules)-&gt;range($range)-&gt;query()-&gt;getData();QueryList::rules($rules)-&gt;get($url)-&gt;range($range)-&gt;query()-&gt;getData();QueryList::range($range)-&gt;rules($rules)-&gt;get($url)-&gt;query()-&gt;getData(); 根据此特性，这里有些使用的小技巧： 复用采集规则：针对同一个网站的多个结构相同的页面的采集 123456789101112131415// 待采集的同一个网站的网页集合$urls = [ 'http://xxx.com/1.html', 'http://xxx.com/2.html', 'http://xxx.com/3.html', // ...];// 由于采集的都是同一个网站的网页，所以采集规则是可以复用的$ql = QueryList::rules([...])-&gt;range('...');foreach ($urls as $url) &#123; $data = $ql-&gt;get($url)-&gt;query()-&gt;getData(); // ...&#125; 复用网页：针对同一个页面应用多套采集规则，避免重复抓取页面 12345678910$url = 'http://xxx.com/1.html';// 抓取网页$ql = QueryList::get($url);// 应用第一种采集规则$data1 = $ql-&gt;rules([...])-&gt;range('...')-&gt;query()-&gt;getData();// 应用第二种采集规则$data2 = $ql-&gt;rules([...])-&gt;range('...')-&gt;query()-&gt;getData(); 内容过滤 从采集内容中移除掉多余无用内容。 很多时候我们采集回来的内容中会包含一些”杂质”，如果只是想要移除或替换内容中的某些关键词，直接用字符串替换函数就可以轻松解决，但往往实际情况没这么简单，下面就是一个典型的例子： 123456789101112131415$html =&lt;&lt;&lt;STR &lt;div id=\"content\"&gt; &lt;span class=\"tt\"&gt;作者：xxx&lt;/span&gt; 这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; &lt;p&gt;这是正文内容段落3......&lt;/p&gt; &lt;span&gt;这是广告&lt;/span&gt; &lt;p&gt;这是版权声明！&lt;/p&gt; &lt;/div&gt;STR; 如上，正文内容中包含了作者信息、广告、版权声明等这些无用信息，我们需要从正文内容中过滤掉这些内容，这些内容是变化的，每篇文章都不一样，所以是无法直接用字符串替换函数去除的，QueryList提供了非常简单的去除方式，通过CSS选择器定位需要去除的内容，下面分别通过单元素采集和列表采集两种场景来讲解内容过滤 单元素采集场景前面的单元素采集篇章中有讲解到find()方法，这个方法返回的是一个Elements对象，这个对象拥有几乎所有与jQuery操作DOM完全相同的API，如果你对jQuery熟悉的话，就知道jQuery有一个remove()方法，用于移除元素，同样Elements对象也拥有这个方法，利用这个方法可以很容易的移除我们不需要的内容： 1234567891011121314151617181920212223242526 public function test_remove() &#123; $html = &lt;&lt;&lt;STR &lt;div id=\"content\"&gt; &lt;span class=\"tt\"&gt;作者：xxx&lt;/span&gt; 这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; &lt;p&gt;这是正文内容段落3......&lt;/p&gt; &lt;span&gt;这是广告&lt;/span&gt; &lt;p&gt;这是版权声明！&lt;/p&gt; &lt;/div&gt;STR; // 采集正文内容 $eles = QueryList::html($html)-&gt;find('#content'); // 选择正文内容中要移除的元素，并移除 $eles-&gt;find('.tt,span:last,p:last')-&gt;remove(); // 获取纯净的正文内容 $content = $eles-&gt;html(); print_r($content); &#125; 采集结果 12345这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; &lt;p&gt;这是正文内容段落3......&lt;/p&gt; 列表采集场景在前面的列表采集篇章中有讲解到rules()这个方法，它的参数是接收一个二维数组的采集规则，我们前面学到的采集规则形态是下面这样的: 12345$rules = [ '规则名1' =&gt; ['选择器1','元素属性'], '规则名2' =&gt; ['选择器2','元素属性'], // ...]; 下面是它的另一种形态: 12345$rules = [ '规则名1' =&gt; ['选择器1','元素属性','内容过滤选择器'], '规则名2' =&gt; ['选择器2','元素属性','内容过滤选择器'], // ...]; 内容过滤选择器参数就是用来过滤内容的，同时这种场景下也可以结合find()方法的remove()方法来过滤内容，下面来分别讲解。 第一种方法：使用内容过滤选择器参数内容过滤选择器参数不光可以定义要移除的内容还可以定义要保留的内容，多个值之间用空格隔开，有如下2条规则: 内容移除规则：选择器名前面添加减号(-)，表示移除该标签以及标签内容。 内容保留规则：选择器名前面没有减号(-)（此时选择器只能为HTML标签名，不支持其他选择器），当要采集的[元素属性] 值为text时表示需要保留的HTML标签以及内容，为html时表示要过滤掉的HTML标签但保留内容。 采集代码 12345678910111213141516171819202122232425262728 public function test_list_remove1() &#123; $html =&lt;&lt;&lt;STR &lt;div id=\"content\"&gt; &lt;span class=\"tt\"&gt;作者：xxx&lt;/span&gt; 这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; &lt;p&gt;这是正文内容段落3......&lt;/p&gt; &lt;span&gt;这是广告&lt;/span&gt; &lt;p&gt;这是版权声明！&lt;/p&gt; &lt;/div&gt;STR; // 采集规则 $rules = [ //设置了内容过滤选择器 'content' =&gt; ['#content','html','-.tt -span:last -p:last'], ]; $data = QueryList::rules($rules)-&gt;html($html)-&gt;query()-&gt;getData(); print_r($data-&gt;all()); &#125; 采集结果 123456789101112Array( [0] =&gt; Array ( [content] =&gt; 这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; &lt;p&gt;这是正文内容段落3......&lt;/p&gt; )) 采集结果与前面代码完全相同。 下面顺便演示一下内容保留规则的使用，请仔细观察采集结果来加深理解： 采集代码 12345678910111213141516171819202122232425262728293031 public function test_list_remove2() &#123; $html =&lt;&lt;&lt;STR &lt;div id=\"content\"&gt; &lt;span class=\"tt\"&gt;作者：xxx&lt;/span&gt; 这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; &lt;p&gt;这是正文内容段落3......&lt;/p&gt; &lt;a href=\"http://querylist.cc\"&gt;QueryList官网&lt;/a&gt; &lt;span&gt;这是广告&lt;/span&gt; &lt;p&gt;这是版权声明！&lt;/p&gt; &lt;/div&gt;STR; $rules = [ // 移除内容中所有的超链接，但保留超链接的内容，并移除内容中所有p标签，但保留p标签的内容 'content_html' =&gt; ['#content','html','a p'], // 保留内容中的超链接，以及保留p标签及内容 'content_text' =&gt; ['#content','text','a p'], ]; $data = QueryList::rules($rules)-&gt;html($html)-&gt;query()-&gt;getData(); print_r($data-&gt;all()); &#125; 采集结果 1234567891011121314151617181920212223242526272829303132Array( [0] =&gt; Array ( [content_html] =&gt; &lt;span class=\"tt\"&gt;作者：xxx&lt;/span&gt; 这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; 这是正文内容段落3...... QueryList官网 &lt;span&gt;这是广告&lt;/span&gt; 这是版权声明！ [content_text] =&gt; 作者：xxx 这是正文内容段落1..... 这是正文内容段落2 &lt;p&gt;这是正文内容段落3......&lt;/p&gt; &lt;a href=\"http://querylist.cc\"&gt;QueryList官网&lt;/a&gt; 这是广告 &lt;p&gt;这是版权声明！&lt;/p&gt; )) 第二种方式：结合remove()方法QueryList的getData()方法接收一个回调函数作为参数，这个回调函数用于遍历采集结果，并对结果进行处理，我们可以利用这个回调函数来过滤内容。 采集代码 12345678910111213141516171819202122232425262728293031323334 public function test_list_remove() &#123; $html =&lt;&lt;&lt;STR &lt;div id=\"content\"&gt; &lt;span class=\"tt\"&gt;作者：xxx&lt;/span&gt; 这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; &lt;p&gt;这是正文内容段落3......&lt;/p&gt; &lt;span&gt;这是广告&lt;/span&gt; &lt;p&gt;这是版权声明！&lt;/p&gt; &lt;/div&gt;STR; $rules = [ 'content' =&gt; ['#content','html'] ]; $data = QueryList::rules($rules) -&gt;html($html) -&gt;query() -&gt;getData(function($item)&#123; $ql = QueryList::html($item['content']); $ql-&gt;find('.tt,span:last,p:last')-&gt;remove(); $item['content'] = $ql-&gt;find('')-&gt;html(); return $item; &#125;); print_r($data-&gt;all()); &#125; 1 采集结果 123456789101112Array( [0] =&gt; Array ( [content] =&gt; 这是正文内容段落1..... &lt;span&gt;这是正文内容段落2&lt;/span&gt; &lt;p&gt;这是正文内容段落3......&lt;/p&gt; )) 处理乱码 内容乱码是采集过程中很常见的问题。 一.使用QueryList内置的乱码解决方案1.使用编码转换插件，设置输入输出编码 123456789101112 $html =&lt;&lt;&lt;STR &lt;div&gt; &lt;p&gt;这是内容&lt;/p&gt; &lt;/div&gt;STR; $rule = [ 'content' =&gt; ['div&gt;p:last','text'] ]; $data = QueryList::html($html)-&gt;rules($rule) -&gt;encoding('UTF-8','GB2312') -&gt;query() -&gt;getData(); 设置输入输出编码,并移除html头部 如果设置输入输出参数仍然无法解决乱码，那就使用 removeHead()方法移除html头部 12345678910111213141516$html =&lt;&lt;&lt;STR&lt;div&gt; &lt;p&gt;这是内容&lt;/p&gt;&lt;/div&gt;STR;$rule = [ &apos;content&apos; =&gt; [&apos;div&gt;p:last&apos;,&apos;text&apos;]];$data = QueryList::html($html)-&gt;rules($rule) -&gt;removeHead()-&gt;query()-&gt;getData();// 或者$data = QueryList::html($html)-&gt;rules($rule) -&gt;encoding(&apos;UTF-8&apos;,&apos;GB2312&apos;) -&gt;removeHead() -&gt;query() -&gt;getData(); 二.自己手动转码页面，然后再把页面传给QueryList1234567$url = 'http://top.etao.com/level3.php?spm=0.0.0.0.Ql86zl&amp;cat=16&amp;show=focus&amp;up=true&amp;ad_id=&amp;am_id=&amp;cm_id=&amp;pm_id=';//手动转码$html = iconv('GBK','UTF-8',file_get_contents($url));$data = QueryList::html($html)-&gt;rules([ \"text\" =&gt; [\".title a\",\"text\"] ])-&gt;query()-&gt;getData();print_r($data); 处理采集结果 QueryList返回的集合数据均为Collection集合对象而非普通数组，目的就是为了方便处理采集结果数据。 QueryList引入了Laravel中Collection集合对象，它提供了一个更具可读性的、更便于处理数组数据的封装。下面通过几个例子来说明它的用法，更多用法可以去查看Laravel文档。 Collection文档：https://d.laravel-china.org/docs/5.4/collections 例子采集所有图片链接，采集目标： 1234567891011$html =&lt;&lt;&lt;STR &lt;div class=\"xx\"&gt; &lt;img data-src=\"/path/to/1.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"xx\"&gt; &lt;img data-src=\"/path/to/2.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"xx\"&gt; &lt;img data-src=\"/path/to/3.jpg\" alt=\"\"&gt; &lt;/div&gt;STR; 采集代码 123456789101112131415161718192021 public function test_handle() &#123; $html =&lt;&lt;&lt;STR &lt;div class=\"xx\"&gt; &lt;img data-src=\"/path/to/1.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"xx\"&gt; &lt;img data-src=\"/path/to/2.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"xx\"&gt; &lt;img data-src=\"/path/to/3.jpg\" alt=\"\"&gt; &lt;/div&gt;STR; $data = QueryList::html($html)-&gt;rules([ 'image' =&gt; ['.xx&gt;img','data-src'] ])-&gt;query()-&gt;getData(function($item)&#123; return $item; &#125;); print_r($data-&gt;all()); &#125; 采集结果 123456789101112131415Array( [0] =&gt; Array ( [image] =&gt; /path/to/1.jpg ) [1] =&gt; Array ( [image] =&gt; /path/to/2.jpg ) [2] =&gt; Array ( [image] =&gt; /path/to/3.jpg )) 简化数据如果我们想要的结果是一位数组，而非二位数组，那该怎么做呢？ 可以使用flatten()方法将多维集合转为一维的，对上面的采集结果data进行处理: 1print_r($data-&gt;flatten()-&gt;all()); 输出结果 123456Array( [0] =&gt; /path/to/1.jpg [1] =&gt; /path/to/2.jpg [2] =&gt; /path/to/3.jpg) 截取数据如果我们只想要前2条数据，其它数据都是多余的，那该怎么做呢？ take() 方法返回给定数量项目的新集合，对最初的采集结果data进行处理: 1print_r($data-&gt;flatten()-&gt;take(2)-&gt;all()); 输出结果 12345Array( [0] =&gt; /path/to/1.jpg [1] =&gt; /path/to/2.jpg) 你也可以传入负整数从集合末尾开始获取指定数量的项目，下面获取data数据中最后2条数据： 1print_r($data-&gt;flatten()-&gt;take(-2)-&gt;all()); 输出结果 12345Array( [1] =&gt; /path/to/2.jpg [2] =&gt; /path/to/3.jpg) 翻转数据顺序某些情况下我们需要翻转数据顺序，比如：采集论坛的帖子列表，帖子默认是按照发布日期由新到旧排序的，但我们把这些数据存入数据库的时候，想要按照发布日期由旧到新存入 reverse() 方法用来倒转集合中项目的顺序: 1print_r($data-&gt;flatten()-&gt;reverse()-&gt;all()); 输出结果 123456Array( [2] =&gt; /path/to/3.jpg [1] =&gt; /path/to/2.jpg [0] =&gt; /path/to/1.jpg) 过滤数据filter()方法用于按条件过滤数据，只保留满足条件的数据。 下面例子过滤掉图片路径为/path/to/2.jpg的值。 采集代码 12345$dat = $data-&gt;filter(function ($item) &#123; return $item['image'] != '/path/to/2.jpg';&#125;)-&gt;flatten()-&gt;all();print_r($dat); 采集结果 12345Array( [0] =&gt; /path/to/1.jpg [1] =&gt; /path/to/3.jpg) 遍历数据,依次处理每一项数据map() 方法遍历集合并将每一个值传入给定的回调。该回调可以任意修改项目并返回，从而形成新的被修改过项目的集合。下面遍历data并补全图片链接地址： 采集代码 123456$ret = $data-&gt;map(function($item) &#123; $item['image'] = 'http://xxx.com' . $item['image']; return $item;&#125;)-&gt;flatten()-&gt;all();print_r($ret); 采集结果 123456Array( [0] =&gt; http://xxx.com/path/to/1.jpg [1] =&gt; http://xxx.com/path/to/2.jpg [2] =&gt; http://xxx.com/path/to/3.jpg) 连贯操作Collection对象的所有方法都是可以连贯操作的，比如下面操作,先翻转数数据顺序，然后补全图片链接，最后截取前2条数据: 采集代码 123456$res = $data-&gt;reverse()-&gt;map(function ($item) &#123; $item['image'] = 'http://xxx.com' . $item['image']; return $item;&#125;)-&gt;flatten()-&gt;take(2)-&gt;all();print_r($res); 采集结果 12345Array( [0] =&gt; http://xxx.com/path/to/3.jpg [1] =&gt; http://xxx.com/path/to/2.jpg) 进阶元素操作 QueryList不仅可以读取DOM元素的属性值，还可以操作DOM元素。 替换元素属性值attr()方法除了可以取DOM元素属性值外，还有第二个参数，用于设置元素属性值。 text()方法默认无参调用表示获取元素的纯文本内容，加个参数调用就表示设置元素的内容。 使用场景：比如采集文章时，下载文章中的图片，并替换文章中的图片路径为本地路径 采集代码 1234567891011121314151617181920212223 public function test_attr() &#123; $html =&lt;&lt;&lt;STR &lt;div&gt; &lt;a href=\"https://querylist.cc\" alt=\"abc\"&gt;QueryList&lt;/a&gt; &lt;/div&gt;STR; $ql = QueryList::html($html); // 获取a元素对象 $link = $ql-&gt;find('a:eq(0)'); // 设置元素属性值 $link-&gt;attr('href', 'https://baidu.com'); $link-&gt;attr('alt', '百度'); // 设置元素内容 $link-&gt;text('百度一下'); // html()方法用法与text()方法相同，唯一区别是可以用于设置元素的内容为HTML内容。 //$link-&gt;html('&lt;p&gt;百度一下&lt;/p&gt;'); $data = $ql-&gt;find('div')-&gt;html(); print_r($data); &#125; 采集结果 1&lt;a href=\"https://baidu.com\" alt=\"百度\"&gt;百度一下&lt;/a&gt; 追加元素append()方法用于追加元素。 采集代码 12345678910111213141516171819 public function test_append() &#123; $html =&lt;&lt;&lt;STR &lt;div&gt; &lt;a href=\"https://querylist.cc\" alt=\"abc\"&gt;QueryList&lt;/a&gt; &lt;/div&gt;STR; $ql = QueryList::html($html); // 获取div元素对象 $div = $ql-&gt;find('div:eq(0)'); // 向div元素中追加一个img元素 $div-&gt;append('&lt;img src=\"1.jpg\" /&gt;'); $data = []; $data[] = $div-&gt;find('img')-&gt;attr('src'); $data[] = $ql-&gt;find('div')-&gt;html(); print_r($data); &#125; 采集结果 123456Array( [0] =&gt; 1.jpg [1] =&gt; &lt;a href=\"https://querylist.cc\" alt=\"abc\"&gt;QueryList&lt;/a&gt; &lt;img src=\"1.jpg\"&gt;) 移除元素remove()方法用于移除元素，常用于移除采集内容中的无关内容，在内容过滤章节有详细讲解到。 1$ql-&gt;find('div')-&gt;remove('img'); 替换元素replaceWith()方法用于替换元素。 下面例子替换所有链接为文本。 1234567891011121314151617181920 public function test_replaceWith() &#123; $html =&lt;&lt;&lt;STR &lt;div&gt; &lt;a href=\"https://qq.com\"&gt;QQ&lt;/a&gt; &lt;a class=\"ql\" href=\"https://querylist.cc\" alt=\"abc\"&gt;QueryList&lt;/a&gt; &lt;a href=\"https://baidu.com\"&gt;百度一下&lt;/a&gt; &lt;/div&gt;STR; $ql = QueryList::html($html); $ql-&gt;find('a')-&gt;map(function ($a) &#123; $text = $a-&gt;text(); $a-&gt;replaceWith('&lt;span&gt;'.$text.'&lt;/span&gt;'); &#125;); $data = $ql-&gt;find('div')-&gt;html(); print_r($data); &#125; 采集结果 123&lt;span&gt;QQ&lt;/span&gt; &lt;span&gt;QueryList&lt;/span&gt; &lt;span&gt;百度一下&lt;/span&gt; 移除元素属性removeAttr()方法可用来移除元素属性。 采集代码 123456789101112131415161718 public function test_replaceWith() &#123; $html =&lt;&lt;&lt;STR &lt;div&gt; &lt;a href=\"https://qq.com\"&gt;QQ&lt;/a&gt; &lt;a class=\"ql\" href=\"https://querylist.cc\" alt=\"abc\"&gt;QueryList&lt;/a&gt; &lt;a href=\"https://baidu.com\"&gt;百度一下&lt;/a&gt; &lt;/div&gt;STR; $ql = QueryList::html($html); // 移除元素属性 $ql-&gt;find('a')-&gt;removeAttr('alt'); $data = $ql-&gt;find('div')-&gt;html(); print_r($data); &#125; 采集结果 123&lt;a href=\"https://qq.com\"&gt;QQ&lt;/a&gt; &lt;a class=\"ql\" href=\"https://querylist.cc\"&gt;QueryList&lt;/a&gt; &lt;a href=\"https://baidu.com\"&gt;百度一下&lt;/a&gt; 获取父元素、临近元素parent()方法用于获取当前元素的父元素。 next()和prev()方法用于获取当前元素临近的下一个元素和上一个元素。 使用场景：当你想选择的元素没有明显的特征，如：class、id等，此时就可以选择与之相关联的元素，通过关联元素选择到你想要选择的元素 采集代码 12345678910111213141516171819202122 public function test_replaceWith() &#123; $html =&lt;&lt;&lt;STR &lt;div&gt; &lt;a href=\"https://qq.com\"&gt;QQ&lt;/a&gt; &lt;a class=\"ql\" href=\"https://querylist.cc\" alt=\"abc\"&gt;QueryList&lt;/a&gt; &lt;a href=\"https://baidu.com\"&gt;百度一下&lt;/a&gt; &lt;/div&gt;STR; $ql = QueryList::html($html) $link = $ql-&gt;find('.ql'); $data = []; // 获取父元素的内容 $data['parent'] = $link-&gt;parent()-&gt;html(); // 获取临近的下一个元素的内容 $data['next'] = $link-&gt;next()-&gt;text(); // 获取临近的前一根元素的属性 $data['prev'] = $link-&gt;prev()-&gt;attr('href'); print_r($data); &#125; 采集结果 12345678Array( [parent] =&gt; &lt;a href=\"https://qq.com\"&gt;QQ&lt;/a&gt; &lt;a class=\"ql\" href=\"https://querylist.cc\" alt=\"abc\"&gt;QueryList&lt;/a&gt; &lt;a href=\"https://baidu.com\"&gt;百度一下&lt;/a&gt; [next] =&gt; 百度一下 [prev] =&gt; https://qq.com) 功能扩展 QueryList是完全模块化的设计，拥有强大的可扩展性。 例子 注册一个自定义的http网络操作方法到QueryList对象。 采集代码 12345678910111213141516171819202122public function test_bind()&#123; // 采集开发者头条 $ql = QueryList::getInstance(); // 注册一个myHttp方法到QueryList对象 $data = $ql-&gt;bind('myHttp', function ($url) &#123; $html = file_get_contents($url); $this-&gt;setHtml($html); return $this; &#125;); // 然后就可以通过注册的名字来调用 $data = $ql-&gt;myHttp('https://toutiao.io')-&gt;find('h3 a')-&gt;texts(); print_r($data-&gt;all()); // 或者 $data = $ql-&gt;rules([ 'title' =&gt; ['h3 a', 'text'], 'link' =&gt; ['h3 a', 'href'] ])-&gt;myHttp('https://toutiao.io')-&gt;query()-&gt;getData(); print_r($data-&gt;all());&#125; 采集结果 1234567891011121314151617181920212223242526272829303132Array( [0] =&gt; 用 500 行 Golang 代码实现高性能的消息回调中间件 [1] =&gt; 腾讯大神教你如何解决 Android 内存泄露 [2] =&gt; [译] 普通码农入门机器学习，必须掌握这些数据技能 [3] =&gt; 教你用 Carthage + RXSwift + MVVM + Moya + Router 写一个小说阅读 App //...)Array( [0] =&gt; Array ( [title] =&gt; 用 500 行 Golang 代码实现高性能的消息回调中间件 [link] =&gt; /k/u6hhfn ) [1] =&gt; Array ( [title] =&gt; 腾讯大神教你如何解决 Android 内存泄露 [link] =&gt; /k/abg526 ) [2] =&gt; Array ( [title] =&gt; [译] 普通码农入门机器学习，必须掌握这些数据技能 [link] =&gt; /k/cnbt4o ) [3] =&gt; Array ( [title] =&gt; 教你用 Carthage + RXSwift + MVVM + Moya + Router 写一个小说阅读 App [link] =&gt; /k/1aaumb ) //....) 自定义一个简单的图片下载功能。 采集代码 12345678910111213141516171819202122232425262728293031public function test_download()&#123; // 采集并下载ZOL桌面壁纸 // 扩展一个图片下载功能 // 参数:$path 为图片本地保存路径 $query_list = QueryList::getInstance(); $ql = $query_list-&gt;bind('downloadImage', function ($path) &#123; $data = $this-&gt;getData()-&gt;map(function ($item) use ($path) &#123; // 获取图片 $img = file_get_contents($item['image']); $localPath = $path . '/' . md5($img) . '.jpg'; // 保存图片到本地路径 file_put_contents($localPath, $img); // data数组中新增一个自定义的本地路径字段 $item['local_path'] = $localPath; return $item; &#125;); // 更新data属性 $this-&gt;setData($data); return $this; &#125;); $img_path = base_path() . '/public/download'; $data = $ql-&gt;get('http://desk.zol.com.cn')-&gt;rules([ 'image' =&gt; ['#newPicList img', 'src'] ])-&gt;query()-&gt;downloadImage($img_path)-&gt;getData(); print_r($data-&gt;all());&#125; 采集结果 12345678910111213141516171819Array( [0] =&gt; Array ( [image] =&gt; http://desk.fd.zol-img.com.cn/t_s208x130c5/g5/M00/0C/01/ChMkJ1nDaCOIatt0AAStbpl0q7sAAgrLABXih4ABK2G911.jpg [local_path] =&gt; img/59561f7b8c122d529b9709fdc93283cd.jpg ) [1] =&gt; Array ( [image] =&gt; http://desk.fd.zol-img.com.cn/t_s208x130c5/g5/M00/04/0D/ChMkJ1mvUQ2IRSccAAIWHljxrrYAAgONAMJtn8AAhY2932.jpg [local_path] =&gt; img/00bfaf54c930247815b6d906827600a9.jpg ) [2] =&gt; Array ( [image] =&gt; http://desk.fd.zol-img.com.cn/t_s208x130c5/g5/M00/04/00/ChMkJ1mtG--IPy-5AAOcpLiVZyQAAgLHwB3T3gAA5y8026.jpg [local_path] =&gt; img/60ca7c8575da1f7746cb3e69918a7d68.jpg ) // ...) 全局配置使用QueryList全局配置，避免重复操作。QueryList的config()方法可用于全局配置QueryList。 示例在项目的启动文件中全局注册一些QueryList插件和扩展一些功能,以Laravel框架为例，在AppServiceProvider.php文件的boot()方法中全局配置QueryList： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\ServiceProvider;use QL\\QueryList;class AppServiceProvider extends ServiceProvider&#123; /** * Bootstrap any application services. */ public function boot() &#123; // 全局注册插件 QueryList::config()-&gt;use(My\\MyPlugin::class, $arg1, $arg2, $arg3) -&gt;use([ My\\MyPlugin1::class, My\\MyPlugin2::class, Other\\OtherPlugin::class ]); // 全局注册一个自定义的编码转换方法 QueryList::config()-&gt;bind('myEncode', function($outputEncoding, $inputEncoding) &#123; $html = iconv($inputEncoding,$outputEncoding. '//IGNORE', $this-&gt;getHtml()); $this-&gt;setHtml($html); return $this; &#125;); &#125; /** * Register any application services. * * @return void */ public function register() &#123; // &#125;&#125; 使用插件 123456public function test_plugin()&#123; $data = QueryList::get('...')-&gt;myPlugin1('...')-&gt;rules('...')-&gt;queryData(); $data = QueryList::get('https://top.etao.com')-&gt;myEncode('UTF-8','GBK')-&gt;find('a')-&gt;texts();&#125; 技巧插件推荐","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"QueryList","slug":"QueryList","permalink":"http://blog.caoxl.com/tags/QueryList/"}]},{"title":"LTV","slug":"LTV-Life-Time-Value","date":"2019-03-06T09:26:41.000Z","updated":"2019-08-22T03:16:08.000Z","comments":true,"path":"2019/03/06/LTV-Life-Time-Value/","link":"","permalink":"http://blog.caoxl.com/2019/03/06/LTV-Life-Time-Value/","excerpt":"LTV - Life Time Value - 生命周期总价值","text":"LTV - Life Time Value - 生命周期总价值 在承接APP推广项目中，手游价值变现最直接，核心是获取更多的充值，其中LTV(Lifetime-Value生命周期价值)是一个重要参考指标，可以理解为玩家在其生命周期内对游戏的平均贡献值 LTV的用途计算投入产出1ROI = LTV / CP* ROI: 投资回报率 LTV: 代表产出(收入) CP*(CPM, CPC, CPD, CPA等广告投入): 代表投入(成本) 优化广告投放配置计算各个渠道导入用户的LTV、CP*、ROI，筛选出优质渠道优化投放，统计边际效益数据。 LTV相关的手游运营数据指标 DNU(Daily-New-Users): 每日新增用户数量 AU(Active-Users): 活跃用户 DAU:日活跃用户 WAU:周活跃用户 MAU:月活跃用户 PU(Paying-User): 付费用户 APA(Active-Payment-Account): 活跃付费用户数 PUR(Pay-User-Rate): 付费比率, 计算公式: APA/AU ARPU(Average-Revenue-Per-User): 平均每用户收入, 计算公式: 总收入/AU ARPPU(Average-Revence-Per-Paying-User): 平均每付费用户收入, 计算公式: 总收入/APA LTV(Life-Time-Value): 生命周期价值,即平均一个用户在首次登录游戏到最后一次登录游戏内，为该游戏创造的收入总计 用户留存率(Retention): 用户在某段时间内开始使用游戏，经过一段时间后，仍然继续使用游戏的被认作是留存用户，这部分用户占当日新增用户的比例即是用户留存率,统计周期包括: 日留存(1Day Retention) 周留存(7Day Retention) 月留存(30Day Retention) LTV计算公式LTV = LT * ARPU 如果用户LT（平均生命周期）是3个月，ARPU（平均用户收入）是10元/月，那么LTV = 3 * 10 = 30元 LTV = N天流水 / N天新增 (N&gt;=30) 如何不想计算用户生命周期？咱们不如就自己定义吧，建议可以定义的长一些，30天、60天、90天，这个可以通过观察用户留存率来看，正常60日留存是1%以内，差不多用户生命周期。","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/tags/计算机专业必备/"},{"name":"LTV","slug":"LTV","permalink":"http://blog.caoxl.com/tags/LTV/"},{"name":"ARPU","slug":"ARPU","permalink":"http://blog.caoxl.com/tags/ARPU/"}]},{"title":"基于 Swoole 的框架","slug":"Framework-Based-On-Swoole","date":"2019-02-27T03:23:47.000Z","updated":"2019-10-12T02:58:53.000Z","comments":true,"path":"2019/02/27/Framework-Based-On-Swoole/","link":"","permalink":"http://blog.caoxl.com/2019/02/27/Framework-Based-On-Swoole/","excerpt":"这里列举一些基于Swoole的框架及文档","text":"这里列举一些基于Swoole的框架及文档 Swoole Swoole：面向生产环境的 PHP 异步网络通信引擎 LaravelS - 基于 Swoole 加速 Laravel/Lumen Swoft - 基于 Swoole 原生协程，新时代PHP高性能协程框架 EasySwoole - 基于 Swoole 的常驻内存型的分布式PHP框架 MixPHP - 基于 Swoole 的FPM、常驻内存、协程三模 PHP 高性能框架 Swoolefy - 基于swoole扩展实现的轻量级高性能的常驻内存型的API和Web应用服务框架 CabalPHP - 基于Swoole的轻量、高效、全异步开源框架。 Swoole 衍生开源项目 Hyperf - 基于 Swoole 4.4+ 实现的高性能、高灵活性的 PHP 协程框架","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"},{"name":"Swoft","slug":"Swoft","permalink":"http://blog.caoxl.com/tags/Swoft/"},{"name":"LaravelS","slug":"LaravelS","permalink":"http://blog.caoxl.com/tags/LaravelS/"}]},{"title":"Swoft 基于Swoole","slug":"Swoft-Swoole","date":"2019-02-27T03:21:53.000Z","updated":"2019-08-22T06:39:00.000Z","comments":true,"path":"2019/02/27/Swoft-Swoole/","link":"","permalink":"http://blog.caoxl.com/2019/02/27/Swoft-Swoole/","excerpt":"Swoft: 首个基于 Swoole 原生协程的新时代 PHP 高性能协程全栈框架","text":"Swoft: 首个基于 Swoole 原生协程的新时代 PHP 高性能协程全栈框架 首个基于 Swoole 原生协程的新时代 PHP 高性能协程全栈框架，内置协程网络服务器及常用的协程客户端，常驻内存，不依赖传统的 PHP-FPM，全异步非阻塞 IO 实现，以类似于同步客户端的写法实现异步客户端的使用，没有复杂的异步回调，没有繁琐的 yield, 有类似 Go 语言的协程、灵活的注解、强大的全局依赖注入容器、完善的服务治理、灵活强大的 AOP、标准的 PSR 规范实现等等，可以用于构建高性能的Web系统、API、中间件、基础服务等等。 特性 基于 Swoole扩展 内置协程网络服务器 WebSocket服务器 MVC分层设计 高性能路由 强大的AOP(面向切面编程) 灵活的注解功能 全局的依赖注入容器 基于 PSR-7 的 HTTP 消息实现 基于 PSR-11 的容器规范实现 基于 PSR-14 的事件管理器 基于 PSR-15 的中间件 基于 PSR-16 的缓存设计 可扩展的高性能 RPC RESTful 支持 国际化(i18n)支持 快速灵活的参数验证器 完善的服务治理，熔断、降级、负载、注册与发现 通用连接池 Mysql、Redis、RPC 数据库 ORM 协程、异步任务投递 自定义用户进程 协程和同步阻塞客户端无缝自动切换 别名机制 跨平台热更新自动 Reload 强大的日志系统 基础信息环境要求必须安装的 PHP &gt; 7.0, 推荐7.1+ Composer Redis的异步客户端 hiredis 连接迭代器依赖 pcre 库 Swoole扩展, 版本&gt;=2.1 Swoole开启协程和异步Redis PDO扩展 有冲突的下面列出一些已知的和swoole有冲突的php扩展，请使用swoft时不要安装或禁用它们： xdebug xhprof blackfire zend trace uopz 推荐环境配置 可以查看 swoft 下 Dockerfile 文件 安装SwoftComposer安装1composer create-project swoft/swoft swoft 手动安装12345git clone https://github.com/swoft-cloud/swoftcd swoftcomposer install --no-dev # 不安装 dev 依赖会更快一些cp .env.example .envvim .env # 根据需要调整启动参数 Docker安装1docker run -p 80:80 swoft/swoft Docker-Compose 安装123git clone https://github.com/swoft-cloud/swoftcd swoftdocker-compose up 开发准备 安装PHP7.1, autoconf, openssl, redis 下载安装Hiredis 下载安装`Swoole 快速起步服务启动与管理帮助命令1234567891011121314151617181920212223[root@caoxl swoft]# php bin/swoft -h ____ __ _/ ___|_ _____ / _| |_\\___ \\ \\ /\\ / / _ \\| |_| __| ___) \\ V V / (_) | _| |_|____/ \\_/\\_/ \\___/|_| \\__|Usage: php bin/swoft -h &#123;command&#125; [arguments] [options]Commands: app There are some help command for application[built-in] dev Some commands for application dev[built-in] entity The group command list of database entity gen Generate some common application template classes[built-in] rpc The group command list of rpc server server The group command list of HTTP-Server test Test command ws There are some commands for manage the webSocket serverOptions: -h, --help Display help information -v, --version Display version information HTTP服务器 是否同时启动RPC服务器取决于 .env 文件配置 1234567891011121314// 启动服务，根据 .env 配置决定是否是守护进程php bin/swoft start// 守护进程启动，覆盖 .env 守护进程(DAEMONIZE)的配置php bin/swoft start -d// 重启php bin/swoft restart// 重新加载php bin/swoft reload// 关闭服务php bin/swoft stop WebSocket服务器1234567891011121314// 启动服务，根据 .env 配置决定是否是守护进程php bin/swoft ws:start// 守护进程启动，覆盖 .env 守护进程(DAEMONIZE)的配置php bin/swoft ws:start -d// 重启php bin/swoft ws:restart// 重新加载php bin/swoft ws:reload// 关闭服务php bin/swoft ws:stop RPC服务器 使用独立的RPC服务器 1234567891011121314// 启动服务，根据 .env 配置决定是否是守护进程php bin/swoft rpc:start// 守护进程启动，覆盖 .env 守护进程(DAEMONIZE)的配置php bin/swoft rpc:start -d// 重启php bin/swoft rpc:restart// 重新加载php bin/swoft rpc:reload// 关闭服务php bin/swoft rpc:stop env环境配置在执行 composer install 的时候程序会自动复制环境变量配置文件。 若没有，可手动复制项目根目录的 .env.example 并命名为 .env 可用配置项下面是官方的 .env 文件支持的env配置项, 你也可以按需添加自己需要的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119# ApplicationTIME_ZONE=Asia/ShanghaiLOG_ENABLE=falseAPP_DEBUG=false# Server# pid 文件，要同时在一台机器上运行多个server时，注意要更改pid文件PFILE=/tmp/swoft.pid# 项目名，要同时在一台机器上运行多个server时，注意要更改名称以方便区分PNAME=php-swoft# 是否同时启动 RPCTCPABLE=true# 是否同时启动 定时任务CRONABLE=false# 是否启用热重载。仅推荐在开发时启用AUTO_RELOAD=trueAUTO_REGISTER=false# HTTP 服务器设置HTTP_HOST=0.0.0.0HTTP_PORT=80HTTP_MODE=SWOOLE_PROCESSHTTP_TYPE=SWOOLE_SOCK_TCP# WebSocket 服务器设置(它是继承自http服务器的，跟http有相同的配置项，更多请查看对应组件文档)WS_ENABLE_HTTP=true# TCPTCP_HOST=0.0.0.0TCP_PORT=8099TCP_MODE=SWOOLE_PROCESSTCP_TYPE=SWOOLE_SOCK_TCPTCP_PACKAGE_MAX_LENGTH=2048TCP_OPEN_EOF_CHECK=false# CrontabCRONTAB_TASK_COUNT=1024CRONTAB_TASK_QUEUE=2048# Swoole SettingsWORKER_NUM=1MAX_REQUEST=100000DAEMONIZE=0DISPATCH_MODE=2TASK_IPC_MODE=1MESSAGE_QUEUE_KEY=1879052289TASK_TMPDIR=/tmp/LOG_FILE=@runtime/logs/swoole.logTASK_WORKER_NUM=1PACKAGE_MAX_LENGTH=2048OPEN_HTTP2_PROTOCOL=falseSSL_CERT_FILE=/path/to/ssl_cert_fileSSL_KEY_FILE=/path/to/ssl_key_file# Database Master nodesDB_NAME=dbMasterDB_URI=127.0.0.1:3306/test?user=root&amp;password=123456&amp;charset=utf8,127.0.0.1:3306/test?user=root&amp;password=123456&amp;charset=utf8DB_MIN_ACTIVE=5DB_MAX_ACTIVE=10DB_MAX_WAIT=20DB_MAX_WAIT_TIME=3DB_MAX_IDLE_TIME=60DB_TIMEOUT=2# Database Slave nodesDB_SLAVE_NAME=dbSlaveDB_SLAVE_URI=127.0.0.1:3306/test?user=root&amp;password=123456&amp;charset=utf8,127.0.0.1:3306/test?user=root&amp;password=123456&amp;charset=utf8DB_SLAVE_MIN_ACTIVE=5DB_SLAVE_MAX_ACTIVE=10DB_SLAVE_MAX_WAIT=20DB_SLAVE_MAX_WAIT_TIME=3DB_SLAVE_MAX_IDLE_TIME=60DB_SLAVE_TIMEOUT=3# RedisREDIS_NAME=redisREDIS_DB=2REDIS_URI=127.0.0.1:6379,127.0.0.1:6379REDIS_MIN_ACTIVE=5REDIS_MAX_ACTIVE=10REDIS_MAX_WAIT=20REDIS_MAX_WAIT_TIME=3REDIS_MAX_IDLE_TIME=60REDIS_TIMEOUT=3REDIS_SERIALIZE=1# other redis nodeREDIS_DEMO_REDIS_DB=6REDIS_DEMO_REDIS_PREFIX=demo_redis_# User service (demo service)USER_POOL_NAME=userUSER_POOL_URI=127.0.0.1:8099,127.0.0.1:8099USER_POOL_MIN_ACTIVE=5USER_POOL_MAX_ACTIVE=10USER_POOL_MAX_WAIT=20USER_POOL_TIMEOUT=200USER_POOL_MAX_WAIT_TIME=3USER_POOL_MAX_IDLE_TIME=60USER_POOL_USE_PROVIDER=falseUSER_POOL_BALANCER=randomUSER_POOL_PROVIDER=consul# User service breaker (demo service)USER_BREAKER_FAIL_COUNT = 3USER_BREAKER_SUCCESS_COUNT = 6USER_BREAKER_DELAY_TIME = 5000# ConsulCONSUL_ADDRESS=http://127.0.0.1CONSUL_PORT=8500CONSUL_REGISTER_NAME=userCONSUL_REGISTER_ETO=falseCONSUL_REGISTER_SERVICE_ADDRESS=127.0.0.1CONSUL_REGISTER_SERVICE_PORT=8099CONSUL_REGISTER_CHECK_NAME=userCONSUL_REGISTER_CHECK_TCP=127.0.0.1:8099CONSUL_REGISTER_CHECK_INTERVAL=10CONSUL_REGISTER_CHECK_TIMEOUT=1 应用结构简介一个完整的swoft应用可以包含： HTTP服务(跟传统的框架差不多) WebSocket服务 Rpc服务 swoft-cloud/swoft 即是一个完整应用的demo。当然，如果你只想使用一部分功能也是可以的 框架核心生命周期框架生命周期Swoft 的一切都是建立在 Swoole 扩展之上运行的，想要了解整个生命周期就必须要了解 Swoole 的生命周期，此部分可查阅 Swoole文档 获得更多的资料。 在 Swoft 服务启动阶段，我们主要关注 OnWorkerStart 事件，此事件会在 Worker 启动的时候触发，这个过程也是 Swoft 众多机制实现的关键，这时 Swoft 会 扫描目录 读取配置文件 收集注解信息 收集事件监听器 … 然后根据扫描到的注解信息执行对应的功能逻辑，并储存在与注解相对应的 Collector 容器内，包括但不限于注册路由信息，注册事件监听器，注册中间件，注册过滤器等等。 请求生命周期每一个请求的开始到结束，都是由 Swoole 本身的 onRequest() 或 onReceive() 事件监听并委托给 Dispatcher 来处理并响应的，而 Dispatcher 的主要职责是负责调度请求生命周期内的各个参与者(组件)。 HTTP Server在 HTTP Server 的情况下，将由 ServerDispatcher来负责调度，参与者主要包括 RequestContext, ExceptionHandler, RequestHandler 。 RequestionContext(请求上下文): 作为当前的请求信息的容器将贯穿整个请求生命周期，负责信息的储存和传递； ExceptionHandler(异常处理器): 则是在遇到异常的情况下出来收拾场面的，确保在各种异常情况下依旧能给客户端返回一个预期内的结果 RequestHandler(请求处理器): 则是整个请求生命周期的核心组件，其实也就是 Middleware(中间件) ，该组件实现了 PSR-15 协议 负责将 Request -&gt; Router -&gt; Controller -&gt; Action -&gt; Renderer -&gt; Response 这整个请求流程贯穿起来，其实也就是从 Request 到 Response 的过程 只要在任意一个环节返回一个有效的 Response 对象便能对该请求做出响应并返回。 RPC Server在 RPC Server 的情况下，由 ServiceDispatcher 来负责调度，与 HTTP Server 类似，区别在于参与者只有 RequestContext 和 RequestHandler，而 RequestHandler 内的 Middleware 也和 HTTP Server 的类似 比较明显的区别在于 RPC Server 下会有一个 ServicePacker(数据打包器) 来负责将服务方法或异常返回的数据打包成一个统一的数据格式，并返回给客户端。 配置swoft 的配置与其他框架稍微有一些区别，有几份： config/server.php: swoft 服务器配置，主要是对swoole的配置 config/beans/*: swoft beans 配置，用于配置一些通过数组方式创建的bean，关于bean的创建方式请查看相关章节。 config/properties/*: 这里面就是通常的 应用配置 数据了 只会加载里面的 app.php 文件，其他文件都是在 app.php 内部 include进来的 config/define.php:定义了一些通用的常量和路径别名 12345! defined('DS') &amp;&amp; define('DS', DIRECTORY_SEPARATOR);// App name! defined('APP_NAME') &amp;&amp; define('APP_NAME', 'swoft');// Project base path! defined('BASE_PATH') &amp;&amp; define('BASE_PATH', dirname(__DIR__, 1)); 配置的使用 应用配置对象是 Swoft\\Core\\Config 的实例。 获取配置对象; \\Swoft::getProperties() OR \\Swoft\\App::getProperties() \\Swoft::getBean(&#39;config&#39;) OR \\Swoft\\App::getBean(&#39;config&#39;) 获取配置 1234567891011121314// 通过全局函数使用$value = \\config('key', 'default value');// 通过 \".\" 符号获取子级配置$value = \\config('section.subkey', 'default value');// 通过获取config对象来使用$config = \\Swoft::getBean('config');$value = $config-&gt;get('key', 'default value');$value = $config-&gt;get('section.subkey', 'default value');// 设置值$config-&gt;set('my-name', 'tom');echo $config-&gt;get('my-name'); // tom 路径别名路径别名 主要是配置了一些常用的路径，给他们取了一些别名以方便使用。 已有别名123456789101112131415161718// config/define.php// Register alias$aliases = [ '@root' =&gt; BASE_PATH, // 项目所在路径 '@env' =&gt; '@root', '@app' =&gt; '@root/app', '@res' =&gt; '@root/resources', '@runtime' =&gt; '@root/runtime', '@configs' =&gt; '@root/config', '@resources' =&gt; '@root/resources', '@beans' =&gt; '@configs/beans', '@properties' =&gt; '@configs/properties', '@console' =&gt; '@beans/console.php', '@commands' =&gt; '@app/command', '@vendor' =&gt; '@root/vendor',]; \\Swoft\\App::setAliases($aliases); 别名使用1234567// 通过全局函数使用$path = \\alias('@app');$path = \\alias('@app/Controllers');// 通过顶级类 \\Swoft 使用$path = \\Swoft::getAlias('@app');$path = \\Swoft::getAlias('@app/Controllers'); 获取全部的别名: 1$aliaes = \\Swoft::getAliases(); Bean容器Swoft 中一个 Bean 就是一个类的一个对象实例。 容器就是一个巨大的工厂，用于存放和管理 Bean 生命周期。 注解@Bean 命名空间：\\Swoft\\Bean\\Annotation\\Bean name定义Bean别名,缺省默认类名 scope注入Bean类型,默认单例, Scope::SINGLETON/Scope::PROTOTYPE(每次创建) ref指定引入Bean,用于定义在接口上面,指定使用哪个接口实现. @Inject 命名空间：\\Swoft\\Bean\\Annotation\\Inject name定义属性注入的bean名称，缺省属性自动类型名称 定义Beanbean有两种方式定义，注解和数组配置 数组定义12345678910// 配置创建$beanConfig = [ 'class' =&gt; MyBean::class, 'pro1' =&gt; 'v1', 'pro2' =&gt; 'v2', [ // 构造函数参数 'arg1', '$&#123;beanName&#125;' ]]; 数组中必须要有class字段定义 pro1/pro1和类面的成员变量名称是一一对应的 属性值和构造函数参数值,都可以通过 ${xxx} 和 ${config.xx}, 注入Bean和引用properties配置信息 注解定义注解定义使用PHP文档注解，在类上做一些标记，通过解析类注解，实现不同的功能。 1234567/** * @\\Swoft\\Bean\\Annotation\\Bean(\"userData\") */class XxxBean&#123; &#125; 操作Bean1234App::getBean(\"name\");ApplicationContext::getBean('name');BeanFactory::getBean('name');BeanFactory::hasBean(\"name\"); App/AppplicaionContext/BeanFactory都可从容器中得到Bean hasBean某个bean是否存在 实例别名定义123456789101112131415161718192021222324252627/** * @\\Swoft\\Bean\\Annotation\\Bean(\"userData\") */class UserData&#123; public function getData() &#123; return []; &#125;&#125;/** * @\\Swoft\\Bean\\Annotation\\Bean() */class UserLogic&#123; /** * @\\Swoft\\Bean\\Annotation\\Inject(\"userData\") * @var \\UserData */ private $userData; private function getUser() &#123; return $this-&gt;userData-&gt;getData(); &#125;&#125; 缺省定义123456789101112131415161718192021222324252627/** * @\\Swoft\\Bean\\Annotation\\Bean(\"userData\") */class UserData&#123; public function getData() &#123; return []; &#125;&#125;/** * @\\Swoft\\Bean\\Annotation\\Bean() */class UserLogic&#123; /** * @\\Swoft\\Bean\\Annotation\\Inject() * @var \\UserData */ private $userData; private function getUser() &#123; return $this-&gt;userData-&gt;getData(); &#125;&#125; 接口引用 接口上面指定了使用的实现bean别名 接口使用处，无需指定使用那个别名，会根据接口上面的引用注入不同的实例bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*** @\\Swoft\\Bean\\Annotation\\Bean(ref=\"boy\")*/interface UserInterface&#123; public function getData();&#125;/*** @\\Swoft\\Bean\\Annotation\\Bean(\"boy\")*/class UserBoy implements \\UserInterface&#123; public function getData() &#123; return 'boy'; &#125;&#125;/*** @\\Swoft\\Bean\\Annotation\\Bean(\"girl\")*/class UserGirl implements \\UserInterface&#123; public function getData() &#123; return 'girl'; &#125;&#125;/*** @\\Swoft\\Bean\\Annotation\\Bean()*/class UserLogic&#123; /** * @\\Swoft\\Bean\\Annotation\\Inject() * @var \\UserInterface */ private $userData; private function getUser() &#123; return $this-&gt;userData-&gt;getData(); &#125;&#125; 组件swoft 应用由一个个组件构成，核心为 swoft-framework 组件。 组件注册内部组件app/ 目录和 vendor/swoft 会被自动的扫描，收集注解信息。 自定义组件在配置文件 config/properties/app.php 添加如下配置 123456'components' =&gt; [ 'custom' =&gt; [ // Your package namespace. 'Package\\\\Namespace', ],], 之后，swoft启动时就会到对应的包里去扫描，收集信息 事件管理在swoft我们将事件分为三大类： swoole server 的回调事件 swoft server的事件,基于swoole的回调处理,扩展了一些可用事件以增强自定义性 应用内的自定义事件管理和使用, 也是我们通常了解和使用的事件管理了 swoole和server级别的事件监听器，应当放置在boot阶段。(即通常应放置于 App\\Boot 空间下) Swoole Server事件 TAG: @SwooleListener(&quot;event name&quot;) 用注解tag @SwooleListener(&quot;event name&quot;) 来注册swoole的回调事件监听, 支持所有swoole官网列出来的事件回调名具体请查看 SwooleEvent::class 以及 swoole 官网。 请谨慎使用@SwooleListener。 它是直接注册到 swoole server上的(监听相同事件将会被覆盖)，操作不当可能导致出现问题。 Swoft Server 事件 TAG: @ServerListener(&quot;event name&quot;) 用注解tag @ServerListener(&quot;event name&quot;) 来注册服务器级别的事件监听。 它是对 @SwooleListener 的补充扩展，除了支持 swoole 的事件以外，还增加了一些额外的可用事件监听。 两者的区别是: SwooleListener 中一个事件的监听器只允许一个，并且是直接注册到 swoole server 上的(监听相同事件将会被覆盖) ServerListener 允许对swoole事件添加多个监听器, 会逐个通知 ServerListener 不影响基础swoole事件的监听 Examples12345678910111213141516171819202122&lt;?phpnamespace App\\Boot\\Listener;use Swoft\\Bootstrap\\Listeners\\Interfaces\\StartInterface;use Swoft\\Bean\\Annotation\\ServerListener;use Swoft\\Bootstrap\\SwooleEvent;use Swoole\\Server;/** * Class MyServerListener * @package App\\Boot\\Listener * @ServerListener(event=SwooleEvent::ON_START) */class MyServerListener implements StartInterface&#123; public function onStart(Server $server) &#123; \\output()-&gt;writeln('TestStartListener'); var_dump('TestStartListener'); &#125;&#125; 自定义事件基本的事件注册与触发管理 implement the Psr 14 - Event dispatcher 支持设置事件优先级 支持快速的事件组注册 支持通配符事件的监听 作为核心服务组件，事件管理会自动启用 123'eventManager' =&gt; [ 'class' =&gt; \\Swoft\\Event\\EventManager::class,], 注册事件监听用注解tag @Listener(&quot;event name&quot;) 来注册用户自定义的事件监听 123456789101112131415/** * 应用加载事件 * * @Listener(AppEvent::APPLICATION_LOADER) */class ApplicationLoaderListener implements EventHandlerInterface&#123; /** * @param EventInterface $event 事件对象 */ public function handle(EventInterface $event) &#123; // do something .... &#125;&#125; 事件名称管理推荐放置在一个单独类的常量里面，方便管理和维护 触发事件 12\\Swoft::trigger('event name', null, $arg0, $arg1);// OR use \\Swoft\\App::tigger(); 连接池基础属性 name连接池节点名称,用于服务发现 uri连接地址信息 maxActive最大活跃连接 maxWait最大等待连接 minActive最小活跃链接数 maxIdleTime连接最大空闲时间,单位秒 maxWaitTime连接最大等待时间,单位秒 timeout超时时间,单位秒 具体使用 db连接池 redis连接池 AOP切面编程 AOP 为Aspect Oriented Programming的缩写,意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP用途利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发的效率 日志记录 性能统计 安全控制 事务处理 异常处理 组成部分AOP 由 切面、通知、连接点、切入点，四部分组成。 切面 (Aspect)其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通PHP类(切面类)，之所以能被AOP容器识别成切面，是在配置中指定的。 通知 (Advice)是切面的具体实现。以 目标方法 （要被代理的方法）为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是指向切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。 连接点 (Joinpoint)就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Swoft只支持方法级的连接点。 切入点 (Pointcut)用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。 注解Tag定义切面类@Aspect()定义一个类为切面类 @PointBean()定义bean切入点 - 这个bean类里的方法执行都会经过此切面类的代理 include 定义需要切入的实体名称集合 exclude 定义需要排除的实体名称集合 @PointAnnotation()定义注解切入点 - 所有包含使用了对应注解的方法都会经过此切面类的代理 include定义需要切入的注解名称集合 exclude定义需要排除的注解集合 @PointExecution()定义匹配切入点 - 指明要代理目标类的哪些方法 include 定义需要切入的匹配集合, 匹配的类方法,支持正则表达式 exclude 定义需要排序的匹配集合, 匹配的类方法,支持正则表达式 定义通知点上面的几个tag，标明了切面类的作用范围。下面的几个tag则是进一步限制(或者说标记)要在那些点上进行切入 @Before() 标记方法为前置通知 - 在目标方法执行前先执行此方法 @After() 标记方法为后置通知 - 在目标方法执行后执行此方法 @AfterReturning() 标记方法为最终返回通知 @AfterThrowing() 标记方法为异常通知 - 在目标方法执行抛出异常时执行此方法 @Around() 标记方法为环绕通知 - 在目标方法执行前、后都执行此方法 如上所述，@Before() @After() 就跟我们平常使用的 beforeAction afterAction 功能类似。 :) 说明 定义切面后，框架会自动在对应的切入点，查询方法 @PointBean、@PointAnnotation、@PointExecution 三种定义的关系是并集，三种里面定义的排除也是并集后在排除 提示： 为了便于理解和使用，一个切面类尽量只使用上面三个中的一个。 使用实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * the test of aspcet * * @Aspect() * * @PointBean( * include=&#123;AopBean::class&#125;, * ) * @PointAnnotation( * include=&#123; * Cacheable::class, * CachePut::class * &#125; * ) * @PointExecution( * include=&#123; * \"Swoft\\Testing\\Aop\\RegBean::reg.*\", * &#125; * ) */class AllPointAspect&#123; /** * @Before() */ public function before() &#123; var_dump(' before1 '); &#125; /** * @After() */ public function after() &#123; var_dump(' after1 '); &#125; /** * @AfterReturning() */ public function afterReturn(JoinPoint $joinPoint) &#123; $result = $joinPoint-&gt;getReturn(); return $result.' afterReturn1 '; &#125; /** * @Around() * @param ProceedingJoinPoint $proceedingJoinPoint * @return mixed */ public function around(ProceedingJoinPoint $proceedingJoinPoint) &#123; $this-&gt;test .= ' around-before1 '; $result = $proceedingJoinPoint-&gt;proceed(); $this-&gt;test .= ' around-after1 '; return $result.$this-&gt;test; &#125; /** * @AfterThrowing() */ public function afterThrowing() &#123; echo \"aop=1 afterThrowing !\\n\"; &#125;&#125; AOP实现原理AOP 框架底层是通过动态代理模式实现。代理是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。 静态代理: 由程序员创建代理类或特定工具自动生成源代码再对其编译 动态代理: 在程序运行时运用反射机制动态创建而成。 动态代理Swoft 动态代理定义，继承Swoft\\Proxy\\Handler\\HandlerInterface接口，实现invoke方法。 123456789101112131415161718192021class TestHandler implements HandlerInterface&#123; /** * @var object */ private $target; public function __construct($target) &#123; $this-&gt;target = $target; &#125; public function invoke($method, $parameters) &#123; $before = 'before'; $result = $this-&gt;target-&gt;$method(...$parameters); $after = 'after'; $result .= $before.$after; return $result; &#125;&#125; 使用12345$object = new ProxyTest(1, 2);$handler = new TestHandler($object);/* @var ProxyTest $proxy 这个代理类具有ProxyTest所有功能，可以直接当ProxyTest实例使用，没有任何区别*/$proxy = Proxy::newProxyInstance(ProxyTest::class, $handler); 异常处理1. 编写的代码首先我们在 app 目录下创建一个 Exception 目录，建立一个异常捕获的处理控制器 SwoftExceptionHandler 用到的注解:@ExceptionHandler() class注解，声明当前类是异常处理类 @Handler() method注解，需要捕获的异常类; 例如Exception::class为php自带或者自己定义的异常处理类 1234567891011121314151617181920212223242526/** * @ExceptionHandler() * @package App\\Exception */class SwoftExceptionHandler&#123; /** * @Handler(Exception::class) * * @param Response $response * @param \\Throwable $throwable * * @return Response */ public function handlerException(Response $response, \\Throwable $throwable) &#123; $file = $throwable-&gt;getFile(); $line = $throwable-&gt;getLine(); $code = $throwable-&gt;getCode(); $exception = $throwable-&gt;getMessage(); $data = ['msg' =&gt; $exception, 'file' =&gt; $file, 'line' =&gt; $line, 'code' =&gt; $code]; App::error(json_encode($data)); return $response-&gt;json($data); &#125;&#125; 2.配置能被Swoft扫描到在config/properties/app.php中 的beanScan中增加App\\Exception, 配置如下 12345678910111213141516return [ 'version' =&gt; '1.0', 'autoInitBean' =&gt; true, 'bootScan' =&gt; [ 'App\\Commands', ], 'beanScan' =&gt; [ 'App\\Controllers', 'App\\Models', 'App\\Middlewares', 'App\\Exception', ], 'env' =&gt; 'Base', 'db' =&gt; require __DIR__ . DS . 'db.php', 'cache' =&gt; require __DIR__ . DS . 'cache.php',]; 修改完成后，重新启动swoft即可。 组件列表认证管理权限控制现在支持: BasicAuth BearerToken(JWT) ACL 安装1composer require swoft/auth 使用本组件目前实现了 BasicAuth 和 BearerToken 的验证,以及简单的 ACL，使用方法简单，在 config/beans/base.php 中的 serverDispatcher.middlewares 里 添加 \\Swoft\\Auth\\Middleware\\AuthMiddleware::class 中间件，如下 12345'serverDispatcher' =&gt; [ 'middlewares' =&gt; [ \\Swoft\\Auth\\Middleware\\AuthMiddleware::class, ]], 然后在配置文件 config/properties/app.php 中添加 123456'auth' =&gt; [ 'jwt' =&gt; [ 'algorithm' =&gt; 'HS256', 'secret' =&gt; '1231231' ],], 注意 secret 不要使用上述值，修改为你自己的值 配置验证管理 AuthManagerInterfaceAuthManager 是登录验证的核心，本类实现了 Token 的验证及缓存，你可以继承这个类实现多种方式登录(配合accountType实现)，下面就是一个 basicAuth 的 Demo 首先实现一个 Swoft\\Auth\\Mapping\\AccountTypeInterface 作为我们登录的通道 12345678910111213141516171819202122232425262728293031323334353637383940use Swoft\\Auth\\Mapping\\AccountTypeInterface;use Swoft\\Auth\\Bean\\AuthResult;/** * @Bean() */class AdminNormalAccount implements AccountTypeInterface&#123; /** * @Inject() * @var AdminUserDAO */ protected $dao; const ROLE = 'role'; /** * @throws \\Swoft\\Db\\Exception\\DbException */ public function login(array $data) : AuthResult &#123; $identity = $data['identity']; $credential = $data['credential']; $user = $this-&gt;dao::findOneByUsername($identity); $result = new AuthResult(); if($user instanceof AdminUserBean &amp;&amp; $user-&gt;verify($credential))&#123; $result-&gt;setExtendedData([self::ROLE =&gt; $user-&gt;getIsAdministrator()]); $result-&gt;setIdentity($user-&gt;getId()); &#125; return $result; &#125; /** * @throws \\Swoft\\Db\\Exception\\DbException */ public function authenticate(string $identity) : bool &#123; return $this-&gt;dao::issetUserById($identity); &#125;&#125; 然后在我们自己的 AuthManagerService 实现这个登录 123456789101112131415161718192021222324252627se Swoft\\Auth\\AuthManager;use Swoft\\Auth\\Mapping\\AuthManagerInterface;use Swoft\\Auth\\Bean\\AuthSession;/** * @Bean() */class AuthManagerService extends AuthManager implements AuthManagerInterface&#123; /** * @var string */ protected $cacheClass = Redis::class; /** * @var bool 开启缓存 */ protected $cacheEnable = true; public function adminBasicLogin(string $identity, string $credential) : AuthSession &#123; return $this-&gt;login(AdminNormalAccount::class, [ 'identity' =&gt; $identity, 'credential' =&gt; $credential ]); &#125;&#125; 然后在 config/beans/base.php 中把系统默认的 AuthManager Bean 替换为我们自己的 AuthManagerService，添加如下代码进行替换 123\\Swoft\\Auth\\Mapping\\AuthManagerInterface::class =&gt; [ 'class'=&gt;App\\Domain\\User\\Service\\AuthManagerService::class], 现在我们就可以在一个 Controller 中使用刚才实现的登录方式了 123456789101112131415161718192021222324252627282930313233343536use Swoft\\Auth\\Constants\\AuthConstants;use Swoft\\Http\\Message\\Server\\Request;use Swoft\\Http\\Server\\Bean\\Annotation\\Controller;use Swoft\\Http\\Server\\Bean\\Annotation\\RequestMapping;use Swoft\\Http\\Server\\Bean\\Annotation\\RequestMethod;use Swoft\\Auth\\Mapping\\AuthManagerInterface;/** * @Controller(prefix=\"/oauth\") */class AuthorizationsResource&#123; /** * @RequestMapping(route=\"token\", method=&#123;RequestMethod::POST&#125;) */ public function oauth(Request $request) : array &#123; $identity = $request-&gt;getAttribute(AuthConstants::BASIC_USER_NAME) ?? ''; $credential = $request-&gt;getAttribute(AuthConstants::BASIC_PASSWORD) ?? ''; if(!$identity || !$credential)&#123; return [ \"code\" =&gt; 400, \"message\" =&gt; \"Identity and Credential are required.\" ]; &#125; /** @var AuthManagerService $manager */ $manager = App::getBean(AuthManagerInterface::class); /** @var AuthSession $session */ $session = $manager-&gt;adminBasicLogin($identity, $credential); $data = [ 'token' =&gt; $session-&gt;getToken(), 'expire' =&gt; $session-&gt;getExpirationTime() ]; return $data; &#125;&#125; 现在可以通过 Postman 或 其它请求方式 请求我们的登录接口了 // 待续… 命令行HTTP服务WebSocket服务RPC服务缓存数据库视图Session会话RPC客户端HTTP客户端任务进程国际化日志内存操作服务治理开发者工具","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"},{"name":"Swoft","slug":"Swoft","permalink":"http://blog.caoxl.com/tags/Swoft/"}]},{"title":"LaravelS 基于Swoole","slug":"LaravelS-Swoole","date":"2019-02-27T03:18:31.000Z","updated":"2019-08-22T06:39:08.000Z","comments":true,"path":"2019/02/27/LaravelS-Swoole/","link":"","permalink":"http://blog.caoxl.com/2019/02/27/LaravelS-Swoole/","excerpt":"LaravelS - 基于 Swoole 加速 Laravel/Lumen","text":"LaravelS - 基于 Swoole 加速 Laravel/Lumen LaravelS是一个胶水项目，用于快速集成Swoole到Laravel或Lumen，然后赋予它们更好的性能、更多可能性。Githubhttps://learnku.com/articles/8050/laravels-accelerate-laravellumen-based-on-swoole-take-you-fly 特性 内置Http/WebSocket服务器 多端口混合协议 协程 自定义进程 常驻内存 异步的事件监听 异步的任务队列 毫秒级定时任务 平滑Reload 修改代码后自动Reload 同时支持Laravel/Lumen,兼容主流版本 简单,开箱即用 要求 依赖 说明 PHP &gt;=5.5.9 推荐PHP7+ Swoole &gt;=1.7.19 从2.0.12开始不再支持PHP5 推荐4.2.3+ Laravel/Lumen &gt;= 5.1 推荐5.6+ 安装 通过Composer安装(packagist) 1composer require \"hhxsv5/laravel-s:~3.3\" -vvv 注册Service Provider（以下两步二选一）。 Laravel: 修改文件config/app.php，Laravel 5.5+支持包自动发现，你应该跳过这步 1234'providers' =&gt; [ //... Hhxsv5\\LaravelS\\Illuminate\\LaravelSServiceProvider::class,], Lumen: 修改文件bootstrap/app.php 1$app-&gt;register(Hhxsv5\\LaravelS\\Illuminate\\LaravelSServiceProvider::class); 发布配置和二进制文件 每次升级LaravelS后，需重新发布 123php artisan laravels publish# 配置文件: config/laravels.php# 二进制文件: bin/laravels bin/fswatch 使用Lumen时的特别说明: 你不需要手动加载配置laravels.php，LaravelS底层已自动加载。 12// 不必手动加载，但加载了也不会有问题$app-&gt;configure('laravels'); 修改配置config/laravels.php：监听的IP、端口等，请参考配置项。 运行1php bin/laravels &#123;start|stop|restart|reload|info|help&#125; 1234567891011121314151617[root@caoxl laravels]# php bin/laravels info _ _ _____ | | | |/ ____|| | __ _ _ __ __ ___ _____| | (___ | | / _` | '__/ _` \\ \\ / / _ \\ |\\___ \\ | |___| (_| | | | (_| |\\ V / __/ |____) ||______\\__,_|_| \\__,_| \\_/ \\___|_|_____/ Speed up your Laravel/Lumen+---------------------------+---------+| Component | Version |+---------------------------+---------+| PHP | 7.2.7 || Swoole | 4.2.7 || LaravelS | 3.3.10 || Laravel Framework [local] | 5.7.13 |+---------------------------+---------+ 部署与Nginx配合使用(推荐)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849gzip on;gzip_min_length 1024;gzip_comp_level 2;gzip_types text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;gzip_vary on;gzip_disable \"msie6\";upstream laravels &#123; # 通过 IP:Port 连接 server 127.0.0.1:5200 weight=5 max_fails=3 fail_timeout=30s; # 通过 UnixSocket Stream 连接，小诀窍：将socket文件放在/dev/shm目录下，可获得更好的性能 #server unix:/xxxpath/laravel-s-test/storage/laravels.sock weight=5 max_fails=3 fail_timeout=30s; #server 192.168.1.1:5200 weight=3 max_fails=3 fail_timeout=30s; #server 192.168.1.2:5200 backup; keepalive 16;&#125;server &#123; listen 80; # 别忘了绑Host哟 server_name laravels.com; root /xxxpath/laravel-s-test/public; access_log /yyypath/log/nginx/$server_name.access.log main; autoindex off; index index.html index.htm; # Nginx处理静态资源(建议开启gzip)，LaravelS处理动态资源。 location / &#123; try_files $uri @laravels; &#125; # 当请求PHP文件时直接响应404，防止暴露public/*.php #location ~* \\.php$ &#123; # return 404; #&#125; location @laravels &#123; # proxy_connect_timeout 60s; # proxy_send_timeout 60s; # proxy_read_timeout 120s; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-PORT $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header Scheme $scheme; proxy_set_header Server-Protocol $server_protocol; proxy_set_header Server-Name $server_name; proxy_set_header Server-Addr $server_addr; proxy_set_header Server-Port $server_port; proxy_pass http://laravels; &#125;&#125; 与Apache配合使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546LoadModule proxy_module /yyypath/modules/mod_deflate.so&lt;IfModule deflate_module&gt; SetOutputFilter DEFLATE DeflateCompressionLevel 2 AddOutputFilterByType DEFLATE text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml&lt;/IfModule&gt;&lt;VirtualHost *:80&gt; # 别忘了绑Host哟 ServerName www.laravels.com ServerAdmin hhxsv5@sina.com DocumentRoot /xxxpath/laravel-s-test/public; DirectoryIndex index.html index.htm &lt;Directory \"/\"&gt; AllowOverride None Require all granted &lt;/Directory&gt; LoadModule proxy_module /yyypath/modules/mod_proxy.so LoadModule proxy_module /yyypath/modules/mod_proxy_balancer.so LoadModule proxy_module /yyypath/modules/mod_lbmethod_byrequests.so.so LoadModule proxy_module /yyypath/modules/mod_proxy_http.so.so LoadModule proxy_module /yyypath/modules/mod_slotmem_shm.so LoadModule proxy_module /yyypath/modules/mod_rewrite.so ProxyRequests Off ProxyPreserveHost On &lt;Proxy balancer://laravels&gt; BalancerMember http://192.168.1.1:8011 loadfactor=7 #BalancerMember http://192.168.1.2:8011 loadfactor=3 #BalancerMember http://192.168.1.3:8011 loadfactor=1 status=+H ProxySet lbmethod=byrequests &lt;/Proxy&gt; #ProxyPass / balancer://laravels/ #ProxyPassReverse / balancer://laravels/ # Apache处理静态资源，LaravelS处理动态资源。 RewriteEngine On RewriteCond %&#123;DOCUMENT_ROOT&#125;%&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;DOCUMENT_ROOT&#125;%&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^/(.*)$ balancer://laravels/%&#123;REQUEST_URI&#125; [P,L] ErrorLog $&#123;APACHE_LOG_DIR&#125;/www.laravels.com.error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/www.laravels.com.access.log combined&lt;/VirtualHost&gt; 启用WebSocket服务器 WebSocket服务器监听的IP和端口与Http服务器相同。 创建WebSocket Handler类,并实现接口WebSocketHandlerInterface。start时会自动实例化，不需要手动创建示例。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\Services;use Hhxsv5\\LaravelS\\Swoole\\WebSocketHandlerInterface;// @see https://wiki.swoole.com/wiki/page/400.htmlclass WebSocketService implements WebSocketHandlerInterface&#123; /** * 声明没有参数的构造函数 * WebSocketService constructor. */ public function __construct() &#123; &#125; public function onOpen(\\swoole_websocket_server $server, \\swoole_http_request $request) &#123; // 在触发onOpen事件之前Laravel的生命周期已经完结，所以Laravel的Request是可读的，Session是可读写的 \\Log::info('New WebSocket connection', [ $request-&gt;fd, request()-&gt;all(), session()-&gt;getId(), session('xxx'), session(['yyy' =&gt; time()]) ]); $server-&gt;push($request-&gt;fd, 'Welcome to LaravelS'); // throw new \\Exception('an exception');// 此时抛出的异常上层会忽略，并记录到Swoole日志，需要开发者try/catch捕获处理 &#125; public function onMessage(\\swoole_websocket_server $server, \\swoole_websocket_frame $frame) &#123; \\Log::info('Received message', [ $frame-&gt;fd, $frame-&gt;data, $frame-&gt;opcode, $frame-&gt;finish ]); $server-&gt;push($frame-&gt;fd, date('Y-m-d H:i:s')); // throw new \\Exception('an exception');// 此时抛出的异常上层会忽略，并记录到Swoole日志，需要开发者try/catch捕获处理 &#125; public function onClose(\\swoole_websocket_server $server, $fd, $reactorId) &#123; // throw new \\Exception('an exception');// 此时抛出的异常上层会忽略，并记录到Swoole日志，需要开发者try/catch捕获处理 &#125;&#125; 更改配置 config/laravels.php 123456789101112// ...'websocket' =&gt; [ 'enable' =&gt; true, // 看清楚，这里是true 'handler' =&gt; \\App\\Services\\WebSocketService::class,],'swoole' =&gt; [ //... // dispatch_mode只能设置为2、4、5，https://wiki.swoole.com/wiki/page/277.html 'dispatch_mode' =&gt; 2, //...],// ... 使用swoole_table绑定FD与UserId，可选的,Swoole Table示例也可以用其他全局存储服务，例如Redis/Memcached/MySQL，但需要注意多个Swoole Server实例时FD可能冲突。 与Nginx配合使用（推荐） 参考 WebSocket代理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869map $http_upgrade $connection_upgrade &#123; default upgrade; '' close;&#125;upstream laravels &#123; # 通过 IP:Port 连接 server 127.0.0.1:5200 weight=5 max_fails=3 fail_timeout=30s; # 通过 UnixSocket Stream 连接，小诀窍：将socket文件放在/dev/shm目录下，可获得更好的性能 #server unix:/xxxpath/laravel-s-test/storage/laravels.sock weight=5 max_fails=3 fail_timeout=30s; #server 192.168.1.1:5200 weight=3 max_fails=3 fail_timeout=30s; #server 192.168.1.2:5200 backup; keepalive 16;&#125;server &#123; listen 80; # 别忘了绑Host哟 server_name laravels.com; root /xxxpath/laravel-s-test/public; access_log /yyypath/log/nginx/$server_name.access.log main; autoindex off; index index.html index.htm; # Nginx处理静态资源(建议开启gzip)，LaravelS处理动态资源。 location / &#123; try_files $uri @laravels; &#125; # 当请求PHP文件时直接响应404，防止暴露public/*.php #location ~* \\.php$ &#123; # return 404; #&#125; # Http和WebSocket共存，Nginx通过location区分 # !!! WebSocket连接时路径为/ws # Javascript: var ws = new WebSocket(\"ws://laravels.com/ws\"); location =/ws &#123; # proxy_connect_timeout 60s; # proxy_send_timeout 60s; # proxy_read_timeout：如果60秒内被代理的服务器没有响应数据给Nginx，那么Nginx会关闭当前连接；同时，Swoole的心跳设置也会影响连接的关闭 # proxy_read_timeout 60s; proxy_http_version 1.1; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-PORT $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header Scheme $scheme; proxy_set_header Server-Protocol $server_protocol; proxy_set_header Server-Name $server_name; proxy_set_header Server-Addr $server_addr; proxy_set_header Server-Port $server_port; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_pass http://laravels; &#125; location @laravels &#123; # proxy_connect_timeout 60s; # proxy_send_timeout 60s; # proxy_read_timeout 60s; proxy_http_version 1.1; proxy_set_header Connection \"\"; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Real-PORT $remote_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header Scheme $scheme; proxy_set_header Server-Protocol $server_protocol; proxy_set_header Server-Name $server_name; proxy_set_header Server-Addr $server_addr; proxy_set_header Server-Port $server_port; proxy_pass http://laravels; &#125;&#125; 心跳配置 Swoole的心跳配置 12345678// config/laravels.php'swoole' =&gt; [ //... // 表示每60秒遍历一次，一个连接如果600秒内未向服务器发送任何数据，此连接将被强制关闭 'heartbeat_idle_time' =&gt; 600, 'heartbeat_check_interval' =&gt; 60, //...], Nginx读取代理服务器超时的配置 12# 如果60秒内被代理的服务器没有响应数据给Nginx，那么Nginx会关闭当前连接proxy_read_timeout 60s; 监听事件系统事件 通常，你可以在这些事件中重置或销毁一些全局或静态的变量，也可以修改当前的请求和响应。 laravels.received_request 将 swoole_http_request 转成 Illuminate\\Http\\Request后，在Laravel内核处理请求前。 12345// 如果变量$events不存在，你也可以通过Facade调用\\Event::listen()。Event::listen('laravels.received_request', function (\\Illuminate\\Http\\Request $req, $app) &#123; $req-&gt;query-&gt;set('get_key', 'hhxsv5'); // 修改query string $req-&gt;request-&gt;set('post_key', 'hhxsv5'); // 修改post body&#125;); laravels.generated_response 在Laravel内核处理完请求后，将Illuminate\\Http\\Response转成swoole_http_response之前(下一步将响应给客户端)。 12345Event::listen('laravels.generated_response', function ( \\Illuminate\\Http\\Request $req, \\Symfony\\Component\\HttpFoundation\\Response $rsp, $app) &#123; $rsp-&gt;headers-&gt;set('header-key', 'hhxsv5'); // 修改header&#125;); 完整如下: 123456789101112131415161718192021/** * Register any events for your application. * * @return void */public function boot()&#123; parent::boot(); // 如果变量$events不存在，你也可以通过Facade调用\\Event::listen()。 Event::listen('laravels.received_request', function (\\Illuminate\\Http\\Request $req, $app) &#123; $req-&gt;query-&gt;set('get_key', 'hhxsv5'); // 修改query string $req-&gt;request-&gt;set('post_key', 'hhxsv5'); // 修改post body &#125;); Event::listen('laravels.generated_response', function ( \\Illuminate\\Http\\Request $req, \\Symfony\\Component\\HttpFoundation\\Response $rsp, $app ) &#123; $rsp-&gt;headers-&gt;set('header-key', 'hhxsv5'); // 修改header &#125;);&#125; 自定义的异步事件 此特性依赖Swoole的AsyncTask，必须先设置config/laravels.php的swoole.task_worker_num。异步事件的处理能力受Task进程数影响，需合理设置task_worker_num。 创建事件类 1234567891011121314151617181920&lt;?phpnamespace App\\Tasks;use Hhxsv5\\LaravelS\\Swoole\\Task\\Event;class TestEvent extends Event&#123; private $data; public function __construct($data) &#123; $this-&gt;data = $data; &#125; public function getData() &#123; return $this-&gt;data; &#125;&#125; 创建监听器类 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\Tasks;use Hhxsv5\\LaravelS\\Swoole\\Task\\Task;use Hhxsv5\\LaravelS\\Swoole\\Task\\Event;use Hhxsv5\\LaravelS\\Swoole\\Task\\Listener;class TestListener1 extends Listener&#123; /** * TestListener1 constructor. * 声明没有参数的构造函数 */ public function __construct() &#123; &#125; public function handle(Event $event) &#123; \\Log::info(__CLASS__ . ':handle start', [$event-&gt;getData()]); sleep(2); // 模拟一些慢速的事件处理 // 监听器中也可以投递Task,但不支持Task的finish()回调 // 注意: // 1.参数2需要传true // 2.config/laravels.php中修改配置task_ipc_mode为1或2,参考 https://wiki.swoole.com/wiki/page/296.html $ret = Task::deliver(new TestTask('task data'), true); var_dump($ret); // throw new \\Exception('an exception');// handle时抛出的异常上层会忽略，并记录到Swoole日志，需要开发者try/catch捕获处理 &#125;&#125; 绑定事件与监听器 1234567891011// 在\"config/laravels.php\"中绑定事件与监听器，一个事件可以有多个监听器，多个监听器按顺序执行[ // ... 'events' =&gt; [ \\App\\Tasks\\TestEvent::class =&gt; [ \\App\\Tasks\\TestListener::class, //\\App\\Tasks\\TestListener2::class, ], ], // ...]; 触发事件 123456// 实例化TestEvent并通过fire触发，此操作是异步的，触发后立即返回，由Task进程继续处理监听器中的handle逻辑use Hhxsv5\\LaravelS\\Swoole\\Task\\Event;$success = Event::fire(new TestEvent('event data'));var_dump($success);//判断是否触发成功 异步的任务队列 此特性依赖Swoole的AsyncTask，必须先设置config/laravels.php的swoole.task_worker_num。异步事件的处理能力受Task进程数影响，需合理设置task_worker_num。 创建任务类 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\Tasks;use Hhxsv5\\LaravelS\\Swoole\\Task\\Task;use Illuminate\\Support\\Facades\\Log;class TestTask extends Task&#123; private $data; private $result; public function __construct($data) &#123; $this-&gt;data = $data; &#125; // 处理任务的逻辑,运行在Task进程中,不能投递任务 public function handle() &#123; \\Log::info(__CLASS__ . ':handle start', [$this-&gt;data]); sleep(2); // 模拟一些慢速的事件处理 // throw new \\Exception('an exception');// handle时抛出的异常上层会忽略，并记录到Swoole日志，需要开发者try/catch捕获处理 $this-&gt;result = 'the result of' . $this-&gt;data; &#125; // 可选的，完成事件，任务处理完后的逻辑，运行在Worker进程中，可以投递任务 public function finish() &#123; \\Log::info(__CLASS__ . ':finish start', [$this-&gt;result]); Task::deliver(new TestTask2('task2')); // 投递其他任务 &#125;&#125; 投递任务 12345678// 实例化TestTask并通过deliver投递，此操作是异步的，投递后立即返回，由Task进程继续处理TestTask中的handle逻辑use Hhxsv5\\LaravelS\\Swoole\\Task\\Task;$task = new TestTask('task data');// $task-&gt;delay(3);// 延迟3秒投放任务$ret = Task::deliver($task);var_dump($ret);//判断是否投递成功 毫秒级定时任务 基于Swoole的毫秒定时器，封装的定时任务，取代Linux的Crontab。 创建定时任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace App\\Jobs\\Timer;use App\\Tasks\\TestTask;use Hhxsv5\\LaravelS\\Swoole\\Timer\\CronJob;use Hhxsv5\\LaravelS\\Swoole\\Task\\Task;class TestCronJob extends CronJob&#123; protected $i = 0; // !!! 定时任务的`interval`和`isImmediate`有两种配置方式（二选一）： // 一是重载对应的方法，二是注册定时任务时传入参数。 // --- 重载对应的方法来返回配置：开始 public function interval() &#123; //return parent::interval(); // TODO: Change the autogenerated stub return 1000; // 每秒运行一次 &#125; public function isImmediate() &#123; //return parent::isImmediate(); // TODO: Change the autogenerated stub return false; // 是否立即执行第一次，false则等待间隔时间后执行第一次 &#125; // --- 重载对应的方法来返回配置：结束 public function run() &#123; \\Log::info(__METHOD__, ['start', $this-&gt;i, microtime(true)]); // do something $this-&gt;i++; \\Log::info(__METHOD__, 'end', $this-&gt;i, microtime(true)); if ($this-&gt;i &gt;= 10) &#123; // 运行10次后 \\Log::info(__METHOD__, ['stop', $this-&gt;i, microtime(true)]); $this-&gt;stop(); // 终止此任务 // CronJob中也可以投递Task，但不支持Task的finish()回调。 // 注意： // 1.参数2需传true // 2.config/laravels.php中修改配置task_ipc_mode为1或2，参考 https://wiki.swoole.com/wiki/page/296.html $ret = Task::deliver(new TestTask('task data'), true); var_dump($ret); &#125; // throw new \\Exception('an exception');// 此时抛出的异常上层会忽略，并记录到Swoole日志，需要开发者try/catch捕获处理 &#125;&#125; 注册定时任务类 123456789101112131415// 在\"config/laravels.php\"注册定时任务类[ // ... 'timer' =&gt; [ 'enable' =&gt; true, // 启用Timer 'jobs' =&gt; [ // 注册的定时任务类列表 // 启用LaravelScheduleJob来执行`php artisan schedule:run`，每分钟一次，替代Linux Crontab // \\Hhxsv5\\LaravelS\\Illuminate\\LaravelScheduleJob::class, // 两种配置参数的方式： // [\\App\\Jobs\\Timer\\TestCronJob::class, [1000, true]], // 注册时传入参数 \\App\\Jobs\\Timer\\TestCronJob::class, // 重载对应的方法来返回参数 ], ], // ...]; 注意在构建服务器集群时，会启动多个定时器，要确保只启动一个定期器，避免重复执行定时任务 修改代码后自动Reload 基于inotify,仅支持Linux 安装inotify扩展 开启配置项 注意：inotify只有在Linux内修改文件才能收到文件变更事件，建议使用最新版Docker，Vagrant解决方案。 基于fswatch,支持OS X、Linux、Windows。 安装fswatch 在项目根目录下运行命令。 12// 监听当前目录./bin/fswatch CentOS下安装fawatch12345// 这里注意 最新的fswatch-1.14.0 需要GCC4.9版本以上wget https://github.com/emcrisostomo/fswatch/releases/download/1.13.0/fswatch-1.13.0.tar.gzcd fswatch-1.13.0./configuremake &amp;&amp; make install 在项目中使用swoole_server实例123456/** * 如果启用WebSocket server，$swoole是`swoole_websocket_server`的实例，否则是是`\\swoole_http_server`的实例 * @var \\swoole_http_server|\\swoole_websocket_server $swoole */$swoole = app('swoole');var_dump($swoole-&gt;stats());// 单例 使用swoole_table 定义swoole_table, 支持定义多个Table Swoole启动之前会创建定义的所有Table。 12345678910111213141516// ...'swoole_tables' =&gt; [ // 场景：WebSocket中UserId与FD绑定 'ws' =&gt; [ // Key为Table名称，使用时会自动添加Table后缀，避免重名。这里定义名为wsTable的Table 'size' =&gt; 102400, //Table的最大行数 'column' =&gt; [ [ 'name' =&gt; 'value', 'type' =&gt; \\swoole_table::TYPE_INT, 'size' =&gt; 8, ], ], ], // ...继续定义其他Table],// ... 2.访问swoole_table：所有的Table实例均绑定在swoole_server上，通过app(&#39;swoole&#39;)-&gt;xxxTable访问。 1234567891011121314151617181920212223242526// 场景：WebSocket中UserId与FD绑定public function onOpen(\\swoole_websocket_server $server, \\swoole_http_request $request)&#123; // var_dump(app('swoole') === $server);// 同一实例 $userId = mt_rand(1000, 10000); app('swoole')-&gt;wsTable-&gt;set('uid:' . $userId, ['value' =&gt; $request-&gt;fd]);// 绑定uid到fd的映射 app('swoole')-&gt;wsTable-&gt;set('fd:' . $request-&gt;fd, ['value' =&gt; $userId]);// 绑定fd到uid的映射 $server-&gt;push($request-&gt;fd, 'Welcome to LaravelS');&#125;public function onMessage(\\swoole_websocket_server $server, \\swoole_websocket_frame $frame)&#123; foreach (app('swoole')-&gt;wsTable as $key =&gt; $row) &#123; if (strpos($key, 'uid:') === 0 &amp;&amp; $server-&gt;exist($row['value'])) &#123; $server-&gt;push($row['value'], 'Broadcast: ' . date('Y-m-d H:i:s'));// 广播 &#125; &#125;&#125;public function onClose(\\swoole_websocket_server $server, $fd, $reactorId)&#123; $uid = app('swoole')-&gt;wsTable-&gt;get('fd:' . $fd); if ($uid !== false) &#123; app('swoole')-&gt;wsTable-&gt;del('uid:' . $uid['value']);// 解绑uid映射 &#125; app('swoole')-&gt;wsTable-&gt;del('fd:' . $fd);// 解绑fd映射 $server-&gt;push($fd, 'Goodbye');&#125; 多端口混合协议 更多的信息，请参考Swoole增加监听的端口与多端口混合协议 为了使我们的主服务器能支持除HTTP和WebSocket外的更多协议，我们引入了Swoole的多端口混合协议特性，在LaravelS中称为Socket。现在，可以很方便地在Laravel上被构建TCP/UDP应用。 创建Socket处理类，继承Hhxsv5\\LaravelS\\Swoole\\Socket\\{TcpSocket|UdpSocket|Http|WebSocket} 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App\\Sockets;use Hhxsv5\\LaravelS\\Swoole\\Socket\\TcpSocket;class TestTcpSocket extends TcpSocket&#123; public function onConnect(\\swoole_server $server, $fd, $reactorId) &#123; \\Log::info('New TCP connection', [$fd]); $server-&gt;send($fd, 'Welcome to LaravelS'); &#125; public function onReceive(\\swoole_server $server, $fd, $reactorId, $data) &#123; \\Log::info('Received data', [$fd, $data]); $server-&gt;send($fd, 'LaravelS:' . $data); if ($data === \"quit\\r\\n\") &#123; $server-&gt;send($fd, 'LaravelS: bye' . PHP_EOL); $server-&gt;close($fd); &#125; &#125; public function onClose(\\swoole_server $server, $fd, $reactorId) &#123; \\Log::info('Close TCP connection', [$fd]); $server-&gt;send($fd, 'GoodBye'); &#125;&#125; 这些连接和主服务器上的HTTP/WebSocket连接共享Worker进程，因此可以在这些事件操作中使用LaravelS提供的异步任务投递、swoole_table、Laravel提供的组件如DB、Eloquent等。同时，如果需要使用该协议端口的swoole_server_port对象，只需要像如下代码一样访问Socket类的成员swoolePort即可。 1234public function onReceive(\\swoole_server $server, $fd, $reactorId, $data)&#123; $port = $this-&gt;swoolePort; //获得`swoole_server_port`对象&#125; 注册套接字 1234567891011121314// 修改文件 config/laravels.php// ...'sockets' =&gt; [ [ 'host' =&gt; '127.0.0.1', 'port' =&gt; 5291, 'type' =&gt; SWOOLE_SOCK_TCP,// 支持的嵌套字类型：https://wiki.swoole.com/wiki/page/16.html#entry_h2_0 'settings' =&gt; [// Swoole可用的配置项：https://wiki.swoole.com/wiki/page/526.html 'open_eof_check' =&gt; true, 'package_eof' =&gt; \"\\r\\n\", ], 'handler' =&gt; \\App\\Sockets\\TestTcpSocket::class, ],], 关于心跳配置，只能设置在主服务器上，不能配置在套接字上，但套接字会继承主服务器的心跳配置。 对于TCP协议，dispatch_mode选项设为1/3时，底层会屏蔽onConnect/onClose事件，原因是这两种模式下无法保证onConnect/onClose/onReceive的顺序。如果需要用到这两个事件，请将dispatch_mode改为2/4/5，参考。 12345'swoole' =&gt; [ //... 'dispatch_mode' =&gt; 2, //...]; 测试 TCP: telnet 127.0.0.1 5291 UDP: Linux下 echo &quot;Hello LaravelS&quot; &gt; /dev/udp/127.0.0.1/5292 其他协议的注册示例 UDP123456789101112'sockets' =&gt; [ [ 'host' =&gt; '0.0.0.0', 'port' =&gt; 5292, 'type' =&gt; SWOOLE_SOCK_UDP, 'settings' =&gt; [ 'open_eof_check' =&gt; true, 'package_eof' =&gt; \"\\r\\n\", ], 'handler' =&gt; \\App\\Sockets\\TestUdpSocket::class, ],], HTTP1234567891011'sockets' =&gt; [ [ 'host' =&gt; '0.0.0.0', 'port' =&gt; 5293, 'type' =&gt; SWOOLE_SOCK_TCP, 'settings' =&gt; [ 'open_http_protocol' =&gt; true, ], 'handler' =&gt; \\App\\Sockets\\TestHttp::class, ],], WebSocket123456789101112'sockets' =&gt; [ [ 'host' =&gt; '0.0.0.0', 'port' =&gt; 5294, 'type' =&gt; SWOOLE_SOCK_TCP, 'settings' =&gt; [ 'open_http_protocol' =&gt; true, 'open_websocket_protocol' =&gt; true, ], 'handler' =&gt; \\App\\Sockets\\TestWebSocket::class, ],], 协程 Swoole - 协程(Coroutine) 警告：Laravel/Lumen中存在大量单例和静态属性，在协程下是不安全的，不建议打开协程。 启用协程,默认是关闭的 12345678// 修改文件 `config/laravels.php`[ //... 'swoole' =&gt; [ //... 'enable_coroutine' =&gt; true ],] 协程客户端: 需Swoole &gt;= 2.0 运行时协程: 需Swoole&gt;=4.1.0，同时启用下面的配置。 12345// 修改文件 `config/laravels.php`[ //... 'enable_coroutine_runtime' =&gt; true] 自定义进程 支持开发者创建一些特殊的工作进程，用于监控、上报或者其他特殊的任务，参考addProcess。 创建Process类,实现CustomProcessInterface接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace App\\Processes;use Hhxsv5\\LaravelS\\Swoole\\Process\\CustomProcessInterface;use App\\Tasks\\TestTask;use Hhxsv5\\LaravelS\\Swoole\\Task\\Task;class TestProcess implements CustomProcessInterface&#123; public static function getName() &#123; // 进程名称 return 'test'; &#125; public static function isRedirectStdinStdout() &#123; // 是否重定向输入输出 return false; &#125; public static function getPipeType() &#123; // 管道类型：0:不创建管道，1:创建SOCK_STREAM类型管道，2:创建SOCK_DGRAM类型管道 return 0; &#125; public static function callback(\\swoole_server $swoole) &#123; // 进程运行的代码，不能退出，一旦退出Manager进程会自动再次创建该进程。 \\Log::info(__METHOD__, [posix_getpid(), $swoole-&gt;stats()]); while (true) &#123; \\Log::info('Do something'); sleep(1); // 自定义进程中也可以投递Task，但不支持Task的finish()回调。 // 注意： // 1.参数2需传true // 2.config/laravels.php中修改配置task_ipc_mode为1或2，参考 https://wiki.swoole.com/wiki/page/296.html $ret = Task::deliver(new TestTask('task data'), true); var_dump($ret); // 上层会捕获callback中抛出的异常，并记录到Swoole日志，如果异常数达到10次，此进程会退出，Manager进程会重新创建进程，所以建议开发者自行try/catch捕获，避免创建进程过于频繁。 // throw new \\Exception('an exception'); &#125; &#125;&#125; 注册TestProcess 12345// 修改文件 config/laravels.php// ...'processes' =&gt; [ \\App\\Processes\\TestProcess::class,], 注意: TestProcess::callback()方法不能退出, 如果退出次数达到10次,Manager进程将会重新创建进程 其他特性配置Swoole的事件回调函数支持的事件列表： 事件 需实现的接口 发生时机 WorkerStart Hhxsv5\\LaravelS\\Swoole\\Events\\WorkerStartInterface 发生在Worker进程/Task进程启动时，并且已经完成Laravel初始化 创建事件处理类,实现相应的接口 1234567891011121314151617181920&lt;?phpnamespace App\\Events;use Hhxsv5\\LaravelS\\Swoole\\Events\\WorkerStartInterface;class WorkerStartEvent implements WorkerStartInterface&#123; public function __construct() &#123; &#125; public function handle(\\swoole_http_server $server, $workerId) &#123; // 例如：初始化一个连接池对象，绑定到Swoole Server对象上，其他地方可通过app('swoole')-&gt;connectionPool访问 if (!isset($server-&gt;connectionPool)) &#123; $server-&gt;connectionPool = new ConnectionPool(); &#125; &#125;&#125; 配置 1234// 修改文件 config/laravels.php'event_handlers' =&gt; [ 'WorkerStart' =&gt; \\App\\Events\\WorkerStartEvent::class,], 注意事项单例问题 传统FPM下，单例模式的对象的生命周期仅在每次请求中，请求开始=&gt;实例化单例=&gt;请求结束后=&gt;单例对象资源回收。 Swoole Server下，所有单例对象会常驻于内存，这个时候单例对象的生命周期与FPM不同，请求开始=&gt;实例化单例=&gt;请求结束=&gt;单例对象依旧保留，需要开发者自己维护单例的状态。 常见的解决方案： 用一个中间件来重置单例对象的状态。 如果是以ServiceProvider注册的单例对象，可添加该ServiceProvider到laravels.php的register_providers中，这样每次请求会重新注册该ServiceProvider，重新实例化单例对象。 常见问题 应通过Illuminate\\Http\\Request对象来获取请求信息，$_ENV是可读取的，$_SERVER是部分可读的，不能使用$_GET、$_POST、$_FILES、$_COOKIE、$_REQUEST、$_SESSION、$GLOBALS。 12345678910use Illuminate\\Http\\Request;public function test_form(Request $request)&#123; $name = $request-&gt;input('name'); $all = $request-&gt;all(); $sessionId = $request-&gt;cookie('sessionId'); $photo = $request-&gt;file('photo'); // 调用getContent()来获取原始的POST body，而不能用file_get_contents('php://input') $rawContent = $request-&gt;getContent();&#125; 推荐通过返回Illuminate\\Http\\Response对象来响应请求，兼容echo、var_dump()、print_r()，不能使用函数像 dd()、exit()、die()、header()、setcookie()、http_response_code()。 12345678public function json()&#123; return response()-&gt;json([ 'time' =&gt; time() ]) -&gt;header('header1', 'value1') -&gt;withCookie('c1', 'v1');&#125; 各种单例的连接将被常驻内存，建议开启持久连接。 数据库连接，连接断开后会自动重连12345678910111213141516171819// config/database.php'connections' =&gt; ['my_conn' =&gt; [ 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_MY_CONN_HOST', 'localhost'), 'port' =&gt; env('DB_MY_CONN_PORT', 3306), 'database' =&gt; env('DB_MY_CONN_DATABASE', 'forge'), 'username' =&gt; env('DB_MY_CONN_USERNAME', 'forge'), 'password' =&gt; env('DB_MY_CONN_PASSWORD', ''), 'charset' =&gt; 'utf8mb4', 'collation' =&gt; 'utf8mb4_unicode_ci', 'prefix' =&gt; '', 'strict' =&gt; false, 'options' =&gt; [ // 开启持久连接 \\PDO::ATTR_PERSISTENT =&gt; true, ],],//... Redis连接,连接断开后不会立即自动重连，会抛出一个关于连接断开的异常，下次会自动重连。需确保每次操作Redis前正确的SELECT DB。123456789101112131415161718192021// config/database.php'redis' =&gt; [ 'client' =&gt; 'predis', 'default' =&gt; [ 'host' =&gt; env('REDIS_HOST', '127.0.0.1'), 'password' =&gt; env('REDIS_PASSWORD', null), 'port' =&gt; env('REDIS_PORT', 6379), 'database' =&gt; env('REDIS_DB', 0), 'persistent' =&gt; true, // 开启持久连接 ], 'cache' =&gt; [ 'host' =&gt; env('REDIS_HOST', '127.0.0.1'), 'password' =&gt; env('REDIS_PASSWORD', null), 'port' =&gt; env('REDIS_PORT', 6379), 'database' =&gt; env('REDIS_CACHE_DB', 1), ],], 你声明的全局、静态变量必须手动清理或重置。 无限追加元素到静态或全局变量中，将导致内存爆满。 1234567891011121314// 某类class Test&#123; public static $array = []; public static $string = '';&#125;// 某控制器public function test(Request $req)&#123; // 内存爆满 Test::$array[] = $req-&gt;input('param1'); Test::$string .= $req-&gt;input('param2');&#125; Linux内核参数调整 压力测试","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"}]},{"title":"SMProxy 数据库连接池","slug":"SMProxy-Swoole-MySQL-Proxy","date":"2019-02-27T02:12:28.000Z","updated":"2019-08-22T06:26:59.000Z","comments":true,"path":"2019/02/27/SMProxy-Swoole-MySQL-Proxy/","link":"","permalink":"http://blog.caoxl.com/2019/02/27/SMProxy-Swoole-MySQL-Proxy/","excerpt":"Swoole MySQL Proxy一个基于MySQL协议,Swoole开发的MySQL数据库连接池","text":"Swoole MySQL Proxy一个基于MySQL协议,Swoole开发的MySQL数据库连接池 原理将数据库连接作为对象存储在内存中，当用户需要访问数据库时，首次会建立连接，后面并非建立一个新的连接，而是从连接池中取出一个已建立的空闲连接对象。 使用完毕后，用户也并非将连接关闭，而是将连接放回连接池中，以供下一个请求访问使用。而连接的建立、断开都由连接池自身来管理。 同时，还可以通过设置连接池的参数来控制连接池中的初始连接数、连接的上下限数以及每个连接的最大使用次数、最大空闲时间等等。 也可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。超出最大连接数会采用协程挂起，等到有连接关闭再恢复协程继续操作。 特性 支持读写分离 支持数据库连接池,能够有效解决PHP带来的数据库连接瓶颈 支持SQL92标准 支持协程调度 支持多个数据库连接,多个数据库,多个用户,灵活搭配 遵守MySQL原生协议,跨语言,跨平台的通用中间件代理 支持MySQL事务 支持HandshakeV10协议版本 完美兼容MySQL4.1-8.0 兼容各大框架,无缝提升性能 设计初衷PHP 没有连接池，所以高并发时数据库会出现连接打满的情况，Mycat 等数据库中间件会出现部分 SQL 无法使用，例如不支持批量添加等，而且过于臃肿。 所以就自己编写了这个仅支持连接池和读写分离的轻量级中间件，使用Swoole 协程调度 HandshakeV10 协议转发使程序更加稳定，不用像 Mycat 一样解析所有 SQL 包体，增加复杂度。 环境要求 Swoole &gt;= 2.1.3 PHP &gt;= 7.0 安装（推荐）直接下载最新发行版的 PHAR 文件，解压即用： https://github.com/louislivi/SMProxy/releases/latest 或者使用 Git 切换任意版本： 12git clone https://github.com/louislivi/SMProxy.gitcomposer install --no-dev # 如果你想贡献你的代码，请不要使用 --no-dev 参数。 运行需要给予 bin/SMProxy 执行权限。 123SMProxy [ start | stop | restart | status | reload ] [ -c | --config &lt;configuration_path&gt; | --console ]SMProxy -h | --helpSMProxy -v | --version Options start/stop/restart/status/reload - 运行/停止/重启/查询状态/平滑重启服务 -h 帮助 -v 查看当前服务版本 -c 设置好配置项目录 --console 前台运行(SMProxy&gt;=1.2.5) 配置配置文件位于 smproxy/conf 目录中，其中大写 ROOT 代表当前 SMProxy 根目录。 database.json123456789101112131415161718192021222324252627282930313233343536373839&#123; \"database\": &#123; \"account\": &#123; \"自定义用户名\": &#123; \"user\": \"必选，数据库账户\", \"password\": \"必选，数据库密码\" &#125;, \"...\": \"必选1个，自定义用户名 与serverInfo中的account相对应\" &#125;, \"serverInfo\": &#123; \"自定义数据库连接信息\": &#123; \"write\": &#123; \"host\": \"必选，写库地址 多个用[]表示\", \"port\": \"必选，写库端口\", \"timeout\": \"必选，写库连接超时时间（秒）\", \"account\": \"必选，自定义用户名 与 account中的自定义用户名相对应\" &#125;, \"read\": &#123; \"host\": \"可选，读库地址 多个用[]表示\", \"port\": \"可选，读库端口\", \"timeout\": \"可选，读库连接超时时间（秒）\", \"account\": \"可选，自定义用户名 与 account中的自定义用户名相对应\" &#125; &#125;, \"...\": \"必选1个，自定义数据库连接信息 与databases中的serverInfo相对应,read读库可不配置\" &#125;, \"databases\": &#123; \"数据库名称\": &#123; \"serverInfo\": \"必选，自定义数据库连接信息 与serverInfo中的自定义数据库连接信息相对应\", \"maxConns\": \"必选，该库服务最大连接数，支持计算\", \"maxSpareConns\": \"必选，该库服务最大空闲连接数，支持计算\", \"startConns\": \"可选，该库服务默认启动连接数，支持计算\", \"maxSpareExp\": \"可选，该库服务空闲连接数最大空闲时间（秒），默认为0，支持计算\", \"charset\": \"可选，该库编码格式\" &#125;, \"...\": \"必选1个，数据库名称 多个数据库配置多个\" &#125; &#125;&#125; maxConns,amxSpareConns,startConns 推荐设置为server.json中配置的worker_num的倍数swoole_cpu_num()*N 多个读库,写库 目前采取的是随机获取连接，推荐将maxConns, startConns, startConns至少设置为max(读库,写库)*worker_num 的1倍以上 timeout 设置2-5秒最佳 server.json12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; \"server\": &#123; \"user\": \"必选，SMProxy服务用户\", \"password\": \"必选，SMProxy服务密码\", \"charset\": \"可选，SMProxy编码，默认utf8mb4\", \"host\": \"可选，SMProxy地址，默认0.0.0.0\", \"port\": \"可选，SMProxy端口，默认3366 如需多个以`,`隔开\", \"mode\": \"可选，SMProxy运行模式，SWOOLE_PROCESS多进程模式（默认），SWOOLE_BASE基本模式\", \"sock_type\": \"可选，sock类型，SWOOLE_SOCK_TCP tcp\", \"logs\": &#123; \"open\":\"必选，日志开关，true 开 false 关\", \"config\": &#123; \"system\": &#123; \"log_path\": \"必选，SMProxy系统日志目录\", \"log_file\": \"必选，SMProxy系统日志文件名\", \"format\": \"必选，SMProxy系统日志目录日期格式\" &#125;, \"mysql\": &#123; \"log_path\": \"必选，SMProxyMySQL日志目录\", \"log_file\": \"必选，SMProxyMySQL日志文件名\", \"format\": \"必选，SMProxyMySQL日志目录日期格式\" &#125; &#125; &#125;, \"swoole\": &#123; \"worker_num\": \"必选，SWOOLE worker进程数，支持计算\", \"max_coro_num\": \"必选，SWOOLE 协程数，推荐不低于3000\", \"pid_file\": \"必选，worker进程和manager进程pid目录\", \"open_tcp_nodelay\": \"可选，关闭Nagle合并算法\", \"daemonize\": \"可选，守护进程化，true 为守护进程 false 关闭守护进程\", \"heartbeat_check_interval\": \"可选，心跳检测\", \"heartbeat_idle_time\": \"可选，心跳检测最大空闲时间\", \"reload_async\": \"可选，异步重启，true 开启异步重启 false 关闭异步重启\", \"log_file\": \"可选，SWOOLE日志目录\" &#125;, \"swoole_client_setting\": &#123; \"package_max_length\": \"可选，SWOOLE Client 最大包长，默认16777216MySQL最大支持包长\" &#125;, \"swoole_client_sock_setting\": &#123; \"sock_type\": \"可选，SWOOLE Client sock 类型，默认tcp 仅支持tcp\" &#125; &#125;&#125; user, ‘password’, ‘port’, ‘host’ 为SMProxy的账户|密码|端口|地址(非Mysql数据库账户|密码|端口|地址) 可随意设置用于SMProxy登录验证 例如默认配置登录为 mysql -uroot -p123456 -P 3366 -h 127.0.0.1 SMProxy登录成功MySQL COMMIT会提示Server version: 5.6.0-SMProxy worker_num 推荐使用swoole_cpu_num() 或 swoole_cpu_num()*N 在项目中如何进行配置Laravel .env 123456DB_CONNECTION=mysqlDB_HOST=server.json中配置的hostDB_PORT=server.json中配置的portDB_DATABASE=databse.json中配置的数据库名称DB_USERNAME=server.json中配置的userDB_PASSWORD=server.json中配置的password ThinkPHP database.php 1234567891011'type' =&gt; 'mysql',// 服务器地址'hostname' =&gt; 'server.json中配置的host',// 数据库名'database' =&gt; 'databse.json中配置的数据库名称',// 用户名'username' =&gt; 'server.json中配置的user',// 密码'password' =&gt; 'server.json中配置的password',// 端口'hostport' =&gt; 'server.json中配置的port', 其他框架以此类推，只需要配置代码中连接数据库的host，port，user，password与 SMProxy中server.json中一致即可。 路由注解 smproxy:db_type=[read | write] 强制使用读库1/** smproxy:db_type=read */select * from `user` limit 1 强制使用写库1/** smproxy:db_type=write */select * from `user` limit 1 MySQL8.0 SMProxy1.2.4及以上可直接使用 SMProxy1.2.4以下需要做如下兼容处理： MySQL-8.0默认使用了安全性更强的caching_sha2_password插件，其他版本如果是从5.x升级上来的,可以直接使用所有MySQL功能, 如是新建的MySQL, 需要进入MySQL命令行执行以下操作来兼容:12ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password';flush privileges; 将语句中的 &#39;root&#39;@&#39;%&#39; 替换成你所使用的用户, password 替换成其密码.如仍无法使用, 应在my.cnf中设置 default_authentication_plugin = mysql_native_password 常见问题 SMProxy@access denied for user 请检查serve.json中的账号密码与业务代码中配置的是否一致。 数据库 host请勿配置localhost。 SMProxy@Database config dbname write is not exists! 请将 database.json 中的dbname项改为你的业务数据库名。 Config serverInfo-&gt;*-&gt;account is not exists! 请仔细比对database.json中databse-&gt;serverInfo-&gt;*-&gt;*-&gt;account是否在database-&gt;account下含有相对于的键值对。 Reach max connections! Cann&#39;t pending fetch! 适当增加maxSpareConns或增加database.json中的timeout项。 Must be connected before sending data! 检查MySQL是否有外网访问权限。 检查MySQL验证插件是否为mysql_native_password或caching_sha2_password 排查是否有服务冲突，推荐使用 Docker 进行运行排查环境问题。 Connection * waiting timeout 检查 MySQL 是否有外网访问权限。 启动出现数据库连接超时请检查数据库配置，若正常请降低 startConns 或增加 database.json 中的timeout项。 The server is not running 查看SMProxy下的日志mysql.log和system.log。查看SMProxy下的日志mysql.log和system.log。 Supervisor || docker 使用Supervisor和docker时需要使用前台运行模式(v1.2.5+使用--console,否则使用daemonize参数)否则无法正常启动。 502 Bad Gateway MySQL异常崩溃后连接出现502或连接超时，请不要开启长连接模式。 SQL语句过大不要使用连接池，会导致连接阻塞，程序异常。 启动SMProxy后CPU占用过高 因Swoole4.2.12及以下未开启协程Client读写分离所以CPU占比会比较大。 升级Swoole版本到4.2.13及以上并升级SMProxy版本到1.2.8及以上。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"},{"name":"SMProxy","slug":"SMProxy","permalink":"http://blog.caoxl.com/tags/SMProxy/"}]},{"title":"SVN 命令行","slug":"Svn-Cmd-Notes","date":"2019-02-25T03:21:19.000Z","updated":"2019-08-22T03:43:03.000Z","comments":true,"path":"2019/02/25/Svn-Cmd-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/02/25/Svn-Cmd-Notes/","excerpt":"因为公司使用SVN,一般都是可视化操作,突然想玩一下SVN的命令行","text":"因为公司使用SVN,一般都是可视化操作,突然想玩一下SVN的命令行 安装 直接点击下载Subversion SVN可用子命令12345678910111213141516171819202122232425262728293031323334353637svn help add blame (praise, annotate, ann) cat changelist (cl) checkout (co) cleanup commit (ci) copy (cp) delete (del, remove, rm) diff (di) export help (?, h) import info list (ls) lock log merge mergeinfo mkdir move (mv, rename, ren) patch propdel (pdel, pd) propedit (pedit, pe) propget (pget, pg) proplist (plist, pl) propset (pset, ps) relocate resolve resolved revert status (stat, st) switch (sw) unlock update (up) upgrade 常用SVN命令行import - 上传项目到SVN服务器1svn import project_dir (本地项目全路径) https://caoxl.com/svn/remote_dir (SVN项目全路径) -m \"必填,不填此命令执行不会成功\" 注: 服务器上remote_dir若不存在, 会自动创建;只会上传project_dir目录下的文件到remote_dir的目录下import之后, project_dir并没有自动转化为工作目录, 需要重新checkout(后面会用到) checkout - 检出svn项目到本地12svn checkout https://caoxl.com/svn/remote_dir (SVN项目全路径) project_dir (本地项目全路径) --username 用户名 --password 密码svn checkout / 简写: svn co add - 添加新文件12svn add filenamesvn add *.php (添加当前目录下所以的PHP文件) update 简写(up) - 更新文件1234svn update / svn upsvn update -r 修正版本 文件名svn update 文件名svn update / 简写: svn up commit (简写:ci) - 提交到版本库123svn commit -m \"LogMessage\" [-N] [--no-unlock] PATH (如果选择了保持锁，就使用--no-unlock开关)svn commit -m \"提交当前目录下的全部在版本控制下的文件\" * (*表示全部文件)svn commit / 简写 svn ci status - 查看文件或者目录状态1234567svn status path (目录下的文件和子目录的状态，正常状态不显示)// ?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定svn status -v path (显示文件和子目录状态)// 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人svn status / 简写 svn st 注: svn status、svn diff、svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。 delete - 删除文件12345svn delete path -m 'delele test filesvn delete test.phpsvn ci -m 'delete test file'svn delete / 简写 svn del/remove/rm log - 查看日志12svn log path // 显示文件的所有修改记录,及其版本号的变化svn log -l 3 // 查看最新的三条记录 info - 查看文件详细信息1svn info path diff - 比较差异123svn diff pathsvn diff -r m:n path (比较版本m和版本n比较差异)svn diff / 简写 svn di merge - 合并文件1svn merge -r m:n path (将两个版本之间的差异合并到当前文件) mkdir - 创建纳入版本控制下的新目录1svn mkdir newdir revert - 回滚123svn revert filenamesvn revert PATHsvn revert a.php resolved - 解决冲突1svn resolved PATH branchs - 新建分支12svn mkdir branchessvn copy 项目地址 -m '创建新分支' tag - 建立标签12svn mkdir tagssvn copy 项目地址 -m 'V1.0 tag' lock - 加锁/解锁123svn lock -m 'LockMessage\" [--force] filename svn lock -m \"lock test file\" filenamesvn unlock filename 常见问题不小心提交了一些动态改变根本不需要的文件到svn服务器上1234svn resolved filename // 放弃对文件的修改svn ci -m 'resolved' // 提交所有文件svn rm filename // 删除掉这个文件svn ci -m 'update' // 再次提交","categories":[{"name":"Git / Svn","slug":"Git-Svn","permalink":"http://blog.caoxl.com/categories/Git-Svn/"}],"tags":[{"name":"SVN","slug":"SVN","permalink":"http://blog.caoxl.com/tags/SVN/"}]},{"title":"Don't Stop Your Step","slug":"Dont-Stop-Your-Step","date":"2019-02-14T08:11:53.000Z","updated":"2019-02-14T08:16:08.000Z","comments":true,"path":"2019/02/14/Dont-Stop-Your-Step/","link":"","permalink":"http://blog.caoxl.com/2019/02/14/Dont-Stop-Your-Step/","excerpt":"比你强的人仍在不停进步, 你怎么能停下脚步?","text":"比你强的人仍在不停进步, 你怎么能停下脚步? Okami’s Debris Notes Okami’s Reading Notes","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/tags/Caoxl/"}]},{"title":"Linux 虚拟内存的使用","slug":"Linux-Swap-On-Off","date":"2019-01-28T02:29:49.000Z","updated":"2019-01-28T03:55:55.000Z","comments":true,"path":"2019/01/28/Linux-Swap-On-Off/","link":"","permalink":"http://blog.caoxl.com/2019/01/28/Linux-Swap-On-Off/","excerpt":"使用阿里云服务器经常遇到内存不足造成服务器挂掉的问题,没办法改变物理内存太小，那就弄虚拟内存吧。","text":"使用阿里云服务器经常遇到内存不足造成服务器挂掉的问题,没办法改变物理内存太小，那就弄虚拟内存吧。 Linux系统实现虚拟内存有两种方法：交换分区（swap分区）和交换文件交换文件 查看内存 (-m显示单位为MB,-g显示单位为GB) 123456789[root@caoxl /]# free -m total used free shared buff/cache availableMem: 3789 111 3079 9 599 3435Swap: 0 0 0[root@caoxl /]# free -g total used free shared buff/cache availableMem: 3 0 3 0 0 3Swap: 0 0 0 创建一个文件 1234[root@caoxl /]# touch swap[root@caoxl /]# lsbin data download home lib64 media opt root sbin swap tmp varboot dev etc lib lost+found mnt proc run srv sys usr 使用dd命令,创建大小为2G的文件swap 1234[root@caoxl /]# dd if=/dev/zero of=/swap bs=1M count=20482048+0 records in2048+0 records out2147483648 bytes (2.1 GB) copied, 11.7135 s, 183 MB/s if - input_file 输入文件 of - output_file 输出文件 bs - block_size 块大小 count 表示计数 格式化交换文件 123[root@caoxl /]# mkswap swapSetting up swapspace version 1, size = 2097148 KiBno label, UUID=f77dd6aa-0625-47e9-9eb9-bf26050a8508 启用交换文件 12[root@caoxl /]# swapon swapswapon: /swap: insecure permissions 0644, 0600 suggested. 开机自动加载虚拟内存,在/etc/fstab文件中加入如下命令 12[root@caoxl etc]# vim fstab /swap swap swap defults 0 0 重启后生效reboot 1234[root@caoxl /]# free -m total used free shared buff/cache availableMem: 3789 110 1309 4 2369 3424Swap: 2047 0 2047 删除交换分区和交换文件 先删除/etc/fstab文件中添加的交换文件行 停用交换文件 1[root@caoxl /]# swapoff /swap 删除交换文件 1[root@caoxl /]# rm -rf ./swap 1234[root@caoxl /]# free -m total used free shared buff/cache availableMem: 3789 109 3416 4 264 3454Swap: 0 0 0 交换分区 查看硬盘信息 1234567891011[root@caoxl ~]# fdisk -lDisk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0008d73a Device Boot Start End Blocks Id System/dev/vda1 * 2048 83884031 41940992 83 Linux 查看挂载信息 12345678[root@caoxl ~]# df -ThFilesystem Type Size Used Avail Use% Mounted on/dev/vda1 ext4 40G 13G 26G 33% /devtmpfs devtmpfs 1.9G 0 1.9G 0% /devtmpfs tmpfs 1.9G 0 1.9G 0% /dev/shmtmpfs tmpfs 1.9G 484K 1.9G 1% /runtmpfs tmpfs 1.9G 0 1.9G 0% /sys/fs/cgrouptmpfs tmpfs 379M 0 379M 0% /run/user/0 以root身份创建分区 hdb1 fdisk /dev/vda1 然后 w 保存退出 1234567891011121314151617181920212223242526272829[root@caoxl /]# sudo fdisk /dev/vda1Welcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Device does not contain a recognized partition tableBuilding a new DOS disklabel with disk identifier 0xc5d30913.Command (m for help): n // 新增分区Partition type: p primary (0 primary, 0 extended, 4 free) // 主分区 e extended // 扩展分区Select (default p): e // 选择要创建的分区类型Partition number (1-4, default 1): 1 // 分区编号 First sector (2048-83881983, default 2048): // 柱面起始值,直接回车默认Using default value 2048Last sector, +sectors or +size&#123;K,M,G&#125; (2048-83881983, default 83881983): +1GPartition 1 of type Extended and of size 1 GiB is setCommand (m for help): w // 保存分区表The partition table has been altered!Calling ioctl() to re-read partition table.WARNING: Re-reading the partition table failed with error 22: Invalid argument.The kernel still uses the old table. The new table will be used atthe next reboot or after you run partprobe(8) or kpartx(8)Syncing disks. 查看分区 123456789101112Command (m for help): pDisk /dev/vda1: 42.9 GB, 42947575808 bytes, 83881984 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0xc5d30913 Device Boot Start End Blocks Id System/dev/vda1p1 2048 2099199 1048576 5 Extended/dev/vda1p2 2099200 3147775 524288 83 Linux 设置交换分区 1[root@caoxl /]# mkswap /dev/vda1 启用交换分区 1[root@caoxl /]# swapon /dev/vda1 开机自动加载虚拟内存,在/etc/fstab文件中加入如下命令 1/dev/vda1 swap swap defults 0 0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Swap","slug":"Swap","permalink":"http://blog.caoxl.com/tags/Swap/"}]},{"title":"ThinkPHP 5.2 初体验","slug":"ThinkPHP52-First-Experience","date":"2019-01-23T02:41:27.000Z","updated":"2019-08-22T06:43:16.000Z","comments":true,"path":"2019/01/23/ThinkPHP52-First-Experience/","link":"","permalink":"http://blog.caoxl.com/2019/01/23/ThinkPHP52-First-Experience/","excerpt":"5.2版本目前属于测试版本，存在不稳定性，请勿轻易用于正式项目。","text":"5.2版本目前属于测试版本，存在不稳定性，请勿轻易用于正式项目。 安装及入口文件安装由于5.2版本完全依赖Composer，因此只能通过composer安装才能使用，不同于5.0和5.1版本，下载或者Git安装都可以使用。 由于只是测试阶段，所以必须安装dev版本 1composer create-project topthink/think thinkphp52 5.2.*-dev 启动服务12cd thinkphp52php think run 入口文件新版的入口文件还是位于public目录下面，由于直接使用composer的自动加载机制，因此框架核心已经不再使用Loader类了而是改为加载composer的autoload文件。 123456789101112131415161718&lt;?php// +----------------------------------------------------------------------// | ThinkPHP [ WE CAN DO IT JUST THINK ]// +----------------------------------------------------------------------// | Copyright (c) 2006-2018 http://thinkphp.cn All rights reserved.// +----------------------------------------------------------------------// | Licensed ( http://www.apache.org/licenses/LICENSE-2.0 )// +----------------------------------------------------------------------// | Author: liu21st &lt;liu21st@gmail.com&gt;// +----------------------------------------------------------------------// [ 应用入口文件 ]namespace think;require __DIR__ . '/../vendor/autoload.php';// 执行应用并响应(new App())-&gt;run()-&gt;send(); autoload.php 1234567&lt;?php// autoload.php @generated by Composerrequire_once __DIR__ . '/composer/autoload_real.php';return ComposerAutoloaderInit902a9936ccdb3d6e9ddc6502fd4f4a61::getLoader(); 注意每一个入口文件在新版里面总是对应一个应用，有意思的是，不同的应用入口文件除了文件名不同外代码可能完全一样（会自动绑定到文件名对应的应用）。 如果你的文件名和应用名不一致，那么可能需要略微调整如下： 1234567891011&lt;?php// [ 应用入口文件 ]namespace think;require __DIR__ . '/../vendor/autoload.php';// 执行应用并响应(new App())-&gt;name('app_name') -&gt;run() -&gt;send(); think\\App类还提供了很多的设置方法，都可以在run之前调用。这个有兴趣深入了解的可以通过源码查看。 源码: thinkphp52/vendor/topthink/framework/src/think/App.php App.php 这里展示一些方法和作用, 源码自己去看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace think;class App extends Container&#123; // 自动多应用访问 public function autoMulti(array $map = []) &#123;&#125; // 是否为自动多应用模式 public function isAutoMulti(): bool &#123;&#125; // 设置应用模式 public function multi(bool $multi) &#123;&#125; // 是否为多应用模式 public function isMulti(): bool &#123;&#125; // 设置应用路径 public function path(string $path) &#123;&#125; // 开启应用调试模式 public function debug(bool $debug = true) &#123;&#125; // 设置应用名称 public function name(string $name) &#123;&#125; // 设置控制器层名称 public function controllerLayer(string $layer) &#123;&#125; // 设置空控制器名称 public function emptyController(string $empty) &#123;&#125; // 设置应用命名空间 public function setNamespace(string $namespace) &#123;&#125; // 设置应用根命名空间 public function setRootNamespace(string $rootNamespace) &#123;&#125; // 设置是否启用应用类库后缀 public function useClassSuffix(bool $suffix = true) &#123;&#125; // 是否调试模式 public function isDebug(): bool &#123;&#125; // 是否启用类库后缀 public function hasClassSuffix(): bool &#123;&#125;&#125; 由于新版本一个入口文件对应一个应用，如果你希望保持5.1版本的URL形式不变，直接访问不同的应用，一个最简单的办法就是设置Apache的.htaccess文件。 12345678&lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^([a-z]+)/(.*)$ $1.php/$2 [QSA,PT,L]&lt;/IfModule&gt; 应用目录及命名空间调整新版的目录结构其实看起来和5.1并无多大的差异，除了thinkphp框架目录已经纳入vendor之外。另外应用目录从原来的application更改为app，之所以做这个调整是为了让新手更容易理解应用的命名空间对应，不至于产生不必要的困惑。 初始目录 : 12345678910www├─app│ └─controller├─config├─extend├─public│ └─static├─route├─runtime└─vendor 应用命名空间类似于 1namespace app\\controller; 如果你需要更改根命名空间为top，有两种办法。 一种是修改composer.json文件的autoload，这样可以不改变目录名。 123\"psr-4\": &#123; \"top\\\\\": \"app\"&#125;, 第二种办法是直接修改你的app目录为top。 无论使用哪一种方法，最后在入口文件中设置根命名空间名称。 12345678910&lt;?phpnamespace think;require __DIR__ . '/../vendor/autoload.php';// 执行应用并响应(new App())-&gt;setRootNamespace('top') -&gt;run() -&gt;send(); 如果你的 admin 应用不在 app 目录下面，有完全独立的命名空间例如 1\\think\\admin; 就可以在入口文件admin.php中进行指定 12345678910&lt;?phpnamespace think;require __DIR__ . '/../vendor/autoload.php';// 设置当前应用的命名空间(new App())-&gt;setNamespace('\\think\\admin') -&gt;run() -&gt;send(); 这个应用放在什么位置取决于你的命名空间自动加载路径，这一设计让你的应用可以通过composer来加载。 多应用模式多应用模式下面，除了应用目录的区别外，runtime目录下面会自动创建各个应用的子目录（注意，这个目录同样适用于composer加载的应用），但你只需要通过App::getRuntimePath()方法获取当前应用的runtime目录。 12runtime/home/runtime/admin/ 多个应用的路由定义文件都是独立的，在route目录下面创建对应目录的子目录存放每个应用的路由定义。 12route/home/route/admin/ 多个应用允许加载统一的公共文件。 123app/common.phpapp/admin/common.phpapp/home/common.php 对于配置文件而言，config目录下为应用公共配置，config下子目录则为单个应用的独立配置。 123config/config/admin/config/home/ 可能有人认为现在不同的应用是独立的入口文件，每个应用之间没法互通了，其实这个理解是错误的。不同的应用仍然是可以相互调用的，毕竟类库都是基于命名空间的。 单应用模式上面的目录结构其实是多应用设计，和之前版本一样同样支持单应用模式（之前版本其实是单一模块模式）如果你使用的是单应用的话，目录结构其实就变成了下面的结构。 123456www ├─app 应用目录│ ├─controller 控制器目录│ ├─model 模型目录│ ├─view 视图目录│ └─ ... 更多类库目录 系统的一个默认判断单应用的规则是app目录下面如果存在controller目录，则判断当前为单应用模式。如果你更改了默认的访问控制器层的名称（或者刚好有一个应用名称也叫controller），那么可以在入口文件里面调用 multi(false)来设置为单应用模式。 12345678910&lt;?phpnamespace think;require __DIR__ . '/../vendor/autoload.php';// 执行应用并响应(new App())-&gt;multi(false) -&gt;run() -&gt;send(); 单应用模式下，如果需要更改命名空间，setNamespace和 setRootNamespace 方法是等效的。 数据库和模型的变化总体来说，在数据库和模型层面，5.2的改动并不大，只是因为强类型变量的约束会导致一些用法的差异，以及一些统一和废弃的方法会导致查询代码的调整。 5.2版本目前尚未正式发布，在正式发布之前可能仍然会存在变化。 新特性强类型严格模式新版核心全面启用了严格模式，避免因为方法参数类型模糊而导致的规范不一或者潜在问题。 Db使用门面对象新版的Db类不再是静态类，需要使用 think\\facade\\Db 门面进行静态代理。 1\\think\\facade\\Db::name('user')-&gt;find(); 重构的fetchSql方法查询类的fetchSql方法返回了一个新的think\\db\\Fetch类，获取查询SQL的操作和查询操作完全隔离。另外一个副作用是可以使得查询方法的返回值更加规范。Fetch类目前已经支持动态查询方法。 12Db::name('user')-&gt;where('id', 1); // 返回\\think\\db\\Query对象实例Db::name('user')-&gt;where('id', 1)-&gt;fetchSql(); // 返回\\think\\db\\Fetch对象实例 增加乐观锁功能和软删除一样，增加了一个 think\\model\\concern\\OptimLockTrait用于方便引入扩展模型的乐观锁功能。 12345678910111213&lt;?phpnamespace app\\index\\model;use think\\model\\conern\\OptimiLock;use think\\Model;class User extends Model&#123; use OptimiLock; protected $optimLock = 'lock_version'; &#125; 增加fetchArray方法模型的查询可以通过显式调用fetchArray方法使得查询结果返回数组而不是模型对象和数据集，适用于一些图表控件的数据输出。 1234// 返回模型对象User::find(1);// 返回数组User::fetchArray()-&gt;find(1); 模型增加Schema定义 模型类增加schema属性，用于完整定义模型对应数据表的字段信息，可以避免查询的时候获取数据表字段信息而无需生成Schema缓存。并且该属性中定义字段类型支持使用php类型定义。需要注意和field/type属性的区别，field属性仅用于定义当前模型允许写入的字段，而type属性则仅用于定义数据字段的类型强制转换。 1234567891011121314151617&lt;?phpnamespace app\\index\\model;use think\\Model;class User extends Model&#123; protected $schema = [ 'id' =&gt; 'int', 'name' =&gt; 'string', 'score' =&gt; 'float', 'create_time' =&gt; 'datetime', 'update_time' =&gt; 'datetime', 'delete_time' =&gt; 'datetime', ];&#125; 模型延迟保存机制模型增加延迟保存方法lazySave，调用该方法后不会马上保存数据，仅仅是保存在内存中，当前模型对象销毁的时候或者下次显式调用save方法的时候都会自动保存到数据库。 123456$user = User::find(1);$user-&gt;name = 'thinkphp';$user-&gt;lazySave();...$user-&gt;score = 100;$user-&gt;save(); join系列方法增加参数绑定支持join方法（包括leftJoin/rightJoin/fullJoin方法）支持手动参数绑定。 增加tableRaw方法增加tableRaw方法使用表达式方法定义当前查询的数据表。 查询缓存支持闭包情况改进查询缓存方法支持使用闭包查询的情况。 增加 withAttrs 方法由于参数强制类型的关系，withAttr方法不支持传入数组，必须使用withAttrs方法传入数组批量设置字段获取器。 废弃功能和方法废弃了一些目前已经很少用到或者不建议使用的功能，以及对容易混淆的一个功能多个用法进行了统一。 取消数据分表功能取消了数据库分表功能，建议直接使用数据库的分区功能替代，更灵活和性能更好，同时取消了Query类的getPartitionTableName和partition方法。 取消了get/all方法无论使用Db类还是模型类查询，全部统一使用find/select方法，取消了之前模型类额外提供的get/all方法。 取消findOrEmpty方法取消了Query类的findOrEmpty方法，当模型使用find方法查询的时候，数据不存在自动返回一个空模型对象，无需再使用findOrEmpty方法了。 取消relation方法取消了Query类的relation方法，模型的关联获取直接使用关联属性方式惰性获取。 取消了readMaster方法取消了Query类和模型类的readMater方法，由于该方法使用了静态属性容易导致Swoole等常驻内存的环境下读取错乱。需要的时候可以用master方法手动切换主库读取。 取消fetchPdo方法取消了Query类的fetchPdo方法，需要的时候直接使用getPdo方法替代。 取消查询方法传入Query对象取消Query类的CURD查询方法传入当前对象，如果需要请使用闭包替代。 取消全局查询范围base方法取消模型类的全局查询范围base方法，改由使用globalScope属性定义（数组）需要全局查询的查询范围方法。或者在db($scope)方法中传入全局查询范围。如果是静态查询，可以使用useGlobalScope($scope)。 取消 db 和 model 助手函数这两个助手函数5.1版本已经不再建议使用了，新版直接废弃掉这两个助手函数，请指教使用\\think\\facade\\Db类和实际的模型类调用。 取消 setInc/setDec方法取消Query类的setInc/setDec方法，统一使用inc/dec方法替代，同时改进了inc/dec方法支持延时更新。 取消setField方法取消Query类的setField方法，请直接使用data方法或者update方法。 取消__TABLE_NAME__支持table方法取消__TABLE_NAME__支持，必须明确调用完整表名或者使用name方法。 取消whereOr等方法传入Query对象除了where方法本身可以传入Query对象外，其它的所有where查询方法（例如whereOr/whereExp等）都不再支持传入Query对象。 取消resultset_type配置参数数据集查询结果不再受resultset_type配置参数影响，默认情况下，Db查询统一返回数组，模型查询统一返回模型对象和模型数据集对象。如果Db查询的时候也需要返回数据集的话，可以显式调用fetchCollection方法。 with方法和withJoin独立无需在模型关联方法中定义是否使用JOIN查询，只有在明确调用withJoin的时候才会使用JOIN查询。 路由的调整和改进ThinkPHP5.2的路由部分，也和其它组件一样，做了精简和优化，主要包括如下方面： 取消路由定义的返回数组形式 因为不利于路由缓存生成，路由定义文件取消了返回数组的方式定义路由，必须采用路由方法注册路由。 例如: 123return [ 'hello/:name' =&gt; 'index/hello',]; 必须改成： 1Route::get('hello/:name', 'index/hello'); 多应用的路由定义文件位置单应用模式下，路由定义文件和之前一样就在route目录下面，如果你的项目是采用了多应用的话，每个应用的路由定义和匹配都是独立的，也没有模块的概念，路由定义文件的位置应该是在route/应用子目录下面，例如： 123route/index/route.php // index应用的路由定义文件route/index/web.php // index应用的第二个路由定义文件route/admin/route.php // admin应用的路由定义文件 默认的URL规则变成了: 1http://域名/入口文件（或者应用名）/控制器名/操作名 应用的路由规则其实是定义的入口文件（或者应用名）后面的URL部分，而不包含应用。 自动多应用最新的5.2版本可以支持在同一个入口文件中访问多个不同的应用（之前必须每个应用添加一个对应的入口文件）。 例如在index.php入口文件中使用： 123(new App())-&gt;autoMulti() -&gt;run() -&gt;send(); 就可以不必创建入口文件自动通过URL访问多个应用 1http://serverName/index.php/admin 如果你的默认应用不是index（默认为入口文件名），那么可以通过name方法指定默认应用。 1234(new App())-&gt;autoMulti() -&gt;name('admin') -&gt;run() -&gt;send(); 支持应用名的别名映射，例如： 123(new App())-&gt;autoMulti([ 'think' =&gt; 'admin', // 把admin应用映射为think])-&gt;run()-&gt;send(); 如果需要对某个应用进行自定义，可以使用 12345(new App())-&gt;autoMulti([ 'admin' =&gt; function($app) &#123; $app-&gt;debug(true)-&gt;useClassSuffix(); &#125;])-&gt;run()-&gt;send(); 取消别名路由因为使用场景有限和性能开销问题，取消原来的别名路由功能，建议使用资源路由或者单独的路由替代。 取消快捷路由因为使用场景有限和不太符合规范，取消了原来的控制器快捷路由功能。 取消空控制器和空操作原来的空控制器和空操作功能已经取消，请使用MISS路由功能替代，而且可以支持给不同的路由分组设置MISS路由。同时废弃empty_controller配置。 取消控制器自动搜索由于性能原因，取消了路由的多级控制器自动搜索功能，请在路由规则定义中明确指定要路由的多级控制器。 路由功能独立设计路由功能不再固定执行，而且设计成为AppInit事件的响应监听，并且可以在项目的事件定义里面配置，系统默认的定义配置如下： app\\event.php 123456789101112131415161718192021return [ 'bind' =&gt; [ ], 'listen' =&gt; [ 'AppInit' =&gt; [ 'think\\listener\\LoadLangPack', 'think\\listener\\RouteCheck', ], 'AppBegin' =&gt; [ 'think\\listener\\CheckRequestCache', ], 'ActionBegin' =&gt; [], 'AppEnd' =&gt; [], 'LogLevel' =&gt; [], 'LogWrite' =&gt; [], 'ResponseSend' =&gt; [], 'ResponseEnd' =&gt; [], ], 'subscribe' =&gt; [ ],]; 在AppInit事件中会执行think\\listener\\RouteCheck类，如果你的应用完全不需要使用任何的路由功能，可以在配置文件中取消定义即可，系统会执行默认的URL调度（也即是控制器/操作）。 取消注册方法的 option 和 pattern 参数取消路由注册方法（包括rule/get/post/put/delete/patch/miss/group等方法）的option和pattern参数，全部改成方法调用形式，例如原来的： 1Route::get('hello/:name', 'index/hello', [ 'ext' =&gt; 'html'], [ 'name' =&gt; '\\w+']); 需要改成 123Route::get('hello/:name', 'index/hello') -&gt;ext('html') -&gt;pattern([ 'name' =&gt; '\\w+']); 路由分组定义不再支持数组因为不利于分组的嵌套功能，路由分组定义不再支持数组，只能使用闭包方式定义，例如： 1234Route::group('blog', [ ':id' =&gt; 'Blog/read', ':name' =&gt; 'Blog/read',])-&gt;ext('html')-&gt;pattern(['id' =&gt; '\\d+']); 必须改成 1234Route::group('blog', function() &#123; Route::get(':id', 'Blog/read'); Route::get(':name', 'Blog/read');&#125;)-&gt;ext('html')-&gt;pattern(['id' =&gt; '\\d+']); 如果你需要注册一个虚拟的路由分组，可以直接在第一个参数使用闭包 1234Route::group(function() &#123; Route::get('blog/:id', 'Blog/read'); Route::get('user/:name', 'User/read');&#125;)-&gt;ext('html')-&gt;pattern(['id' =&gt; '\\d+']); 取消了url_controller_layer配置改为在入口文件中使用controllerLayer方法设置。 123(new App())-&gt;controllerLayer('Action') -&gt;run() -&gt;send(); 取消class_suffix配置改为在入口文件中使用useClassSuffix方法设置。 123(new App())-&gt;useClassSuffix(true) -&gt;run() -&gt;send(); 同时取消controller_suffix和class_suffix配置参数。 取消 mergeExtraVars 方法和对应参数改为在路由规则中明确指定变量规则。 header方法参数类型调整由于强类型约束的原因，header方法改为仅支持数组参数传入。 使用强类型参数由于全面启用强类型参数，并且使用严格模式，所以一定要注意参数的类型。 参考 ThinkPHP官方博客 5.2发布Beta2版本——统一和精简大量用法 ThinkPHP5.2安装及入口文件 5.2版本的设计规范指导 5.2数据库和模型的变化（摘要） 5.2路由的调整和改进","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"ThinkPHP 5.2","slug":"ThinkPHP-5-2","permalink":"http://blog.caoxl.com/tags/ThinkPHP-5-2/"}]},{"title":"PHP 魔术方法详解","slug":"PHP-Magic-Methods","date":"2019-01-22T06:48:25.000Z","updated":"2019-01-22T09:36:30.000Z","comments":true,"path":"2019/01/22/PHP-Magic-Methods/","link":"","permalink":"http://blog.caoxl.com/2019/01/22/PHP-Magic-Methods/","excerpt":"PHP 将所有以 （两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 为前缀。 越简单的东西,越容易被忽视","text":"PHP 将所有以 （两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 为前缀。 越简单的东西,越容易被忽视 魔术方法 __construct(): 类的构造函数 __destruct(): 类的析构函数 __call(): 在对象中调用一个不可访问方法时调用 __get(): 获取一个类的成员变量时调用 __set(): 设置一个类的成员变量时调用 __isset(): 当对不可访问属性调用isset()或empty()时被调用 __unset(): 当对不可访问属性调用unset()时被调用 __sleep(): 执行serialize()时, 先会调用这个函数 __wakeup(): 执行unserialize()时,先会调用这个函数 __toString(): 类被当成字符串时的回应方法 __invoke(): 调用函数的方式调用一个对象时的回应方法 __set_state(): 调用var_export()导出类时, 此静态方法会被调用 __clone(): 当对象复制完成时调用 __autoload(): 尝试加载未定义的类 __debugInfo(): 打印所需调试信息 __construct()PHP中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。 12345function __constrct([参数列表])&#123; // 方法体 通常用来对成员属性进行初始化赋值&#125; 123456789101112131415161718192021222324252627&lt;?phpclass Person&#123; public $name; public $age; public $sex; /** * 显示声明一个构造方法且带参数 */ public function __construct($name = \"\", $sex = \"男\", $age = 22) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; /** * say 方法 */ public function say() &#123; echo \"我叫：\" . $this-&gt;name . \"，性别：\" . $this-&gt;sex . \"，年龄：\" . $this-&gt;age; &#125; &#125; 在同一个类中只能声明一个构造方法，原因是: PHP不支持构造函数重载。 __destruct()1234function __destruct()&#123; //方法体&#125; 析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Person&#123; public $name; public $age; public $sex; public function __construct($name=\"\", $sex=\"男\", $age=22) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; /** * say 说话方法 */ public function say() &#123; echo \"我叫：\".$this-&gt;name.\"，性别：\".$this-&gt;sex.\"，年龄：\".$this-&gt;age; &#125; /** * 声明一个析构方法 */ public function __destruct() &#123; echo \"我觉得我还可以再抢救一下，我的名字叫\".$this-&gt;name; &#125;&#125;$Person = new Person(\"小明\");unset($Person); //销毁上面创建的对象$Person __call()该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。 1234function __call(string $function_name, array $arguments)&#123; // 方法体&#125; 为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。 该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。 1234567891011121314151617181920212223&lt;?phpclass Person&#123; function say() &#123; echo \"Hello, world!&lt;br&gt;\"; &#125; /** * 声明此方法用来处理调用对象中不存在的方法 */ function __call($funcName, $arguments) &#123; echo \"你所调用的函数：\" . $funcName . \"(参数：\" ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo \")不存在！&lt;br&gt;\\n\"; // 结束换行 &#125; &#125;$Person = new Person(); $Person-&gt;run(\"teacher\"); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person-&gt;eat(\"小明\", \"苹果\"); $Person-&gt;say(); __callStatic()此方法与上面所说的 __call() 功能除了 __callStatic() 是为静态方法准备的之外，其它都是一样的。 123456789101112131415161718192021222324&lt;?phpclass Person&#123; function say() &#123; echo \"Hello, world!&lt;br&gt;\"; &#125; /** * 声明此方法用来处理调用对象中不存在的方法 */ public static function __callStatic($funcName, $arguments) &#123; echo \"你所调用的静态方法：\" . $funcName . \"(参数：\" ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo \")不存在！&lt;br&gt;\\n\"; // 结束换行 &#125;&#125;$Person = new Person();$Person::run(\"teacher\"); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person::eat(\"小明\", \"苹果\");$Person-&gt;say(); __get() 在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。 在 PHP面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。 1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Person&#123; private $name; private $age; function __construct($name = \"\", $age = 1) &#123; $this-&gt;name = $name; $this-&gt;age = $age; &#125; /** * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理 * @param $propertyName * * @return int */ public function __get($propertyName) &#123; if ($propertyName == \"age\") &#123; if ($this-&gt;age &gt; 30) &#123; return $this-&gt;age - 10; &#125; else &#123; return $this-&gt;$propertyName; &#125; &#125; else &#123; return $this-&gt;$propertyName; &#125; &#125;&#125;$Person = new Person(\"小明\", 60); // 通过Person类实例化的对象，并通过构造方法为属性赋初值echo \"姓名：\" . $Person-&gt;name . \"&lt;br&gt;\"; // 直接访问私有属性name，自动调用了__get()方法可以间接获取echo \"年龄：\" . $Person-&gt;age . \"&lt;br&gt;\"; // 自动调用了__get()方法，根据对象本身的情况会返回不同的值 __set() __set( $property, $value ) 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpclass Person&#123; private $name; private $age; public function __construct($name = \"\", $age = 25) &#123; $this-&gt;name = $name; $this-&gt;age = $age; &#125; /** * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值 * @param $property * @param $value */ public function __set($property, $value) &#123; if ($property == \"age\") &#123; if ($value &gt; 150 || $value &lt; 0) &#123; return; &#125; &#125; $this-&gt;$property = $value; &#125; /** * 在类中声明说话的方法，将所有的私有属性说出 */ public function say() &#123; echo \"我叫\".$this-&gt;name.\"，今年\".$this-&gt;age.\"岁了\"; &#125;&#125;$Person=new Person(\"小明\", 25); //注意，初始值将被下面所改变//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数$Person-&gt;name = \"小红\"; //赋值成功。如果没有__set()，则出错。//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数$Person-&gt;age = 16; //赋值成功$Person-&gt;age = 160; //160是一个非法值，赋值失效$Person-&gt;say(); //输出：我叫小红，今年16岁了 __isset() __isset() 的作用：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。 12345678910111213141516171819202122232425262728293031&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name = \"\", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @param $content * * @return bool */ public function __isset($content) &#123; echo \"当在类外部使用isset()函数测定私有成员&#123;$content&#125;时，自动调用&lt;br&gt;\"; echo isset($this-&gt;$content); &#125;&#125;$person = new Person(\"小明\", 25); // 初始赋值echo isset($person-&gt;sex),\"&lt;br&gt;\";echo isset($person-&gt;name),\"&lt;br&gt;\";echo isset($person-&gt;age),\"&lt;br&gt;\"; __unset() 当对不可访问属性调用unset()时被调用。 123456789101112131415161718192021222324252627282930&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name = \"\", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @param $content * * @return bool */ public function __unset($content) &#123; echo \"当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;\"; echo isset($this-&gt;$content); &#125;&#125;$person = new Person(\"小明\", 25); // 初始赋值unset($person-&gt;sex);unset($person-&gt;name);unset($person-&gt;age); __sleep() 执行 serialize()时，先会调用这个函数serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 注意 __sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 12345678910111213141516171819202122232425262728&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name = \"\", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @return array */ public function __sleep() &#123; echo \"当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;\"; $this-&gt;name = base64_encode($this-&gt;name); return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称 &#125;&#125;$person = new Person('小明'); // 初始赋值echo serialize($person);echo '&lt;br/&gt;'; __wakeup() 执行unserialize()时，先会调用这个函数__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name = \"\", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * __sleep * @return array */ public function __sleep() &#123; echo \"当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;\"; $this-&gt;name = base64_encode($this-&gt;name); return array('name', 'age'); // 这里必须返回一个数值，里边的元素表示返回的属性名称 &#125; /** * __wakeup */ public function __wakeup() &#123; echo \"当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;\"; $this-&gt;name = 2; $this-&gt;sex = '男'; // 这里不需要返回数组 &#125;&#125;$person = new Person('小明'); // 初始赋值var_dump(serialize($person));var_dump(unserialize(serialize($person))); __toString() 类被当成字符串时的回应方法__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。 注意 此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 1234567891011121314151617181920212223&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name = \"\", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __toString() &#123; return 'go go go'; &#125;&#125;$person = new Person('小明'); // 初始赋值echo $person; __invoke() 调用函数的方式调用一个对象时的回应方法当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 123456789101112131415161718192021222324&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name = \"\", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __invoke() &#123; echo '这可是一个对象哦'; &#125;&#125;$person = new Person('小明'); // 初始赋值$person(); __set_state() 调用var_export()导出类时，此静态方法会被调用。自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。 123456789101112131415161718192021222324252627&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name = \"\", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public static function __set_state($an_array) &#123; $a = new Person(); $a-&gt;name = $an_array['name']; return $a; &#125;&#125;$person = new Person('小明'); // 初始赋值$person-&gt;name = '小红';var_export($person); __clone() 当对象复制完成时调用对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。 123456789101112131415161718192021222324252627282930&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name = \"\", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __clone() &#123; echo __METHOD__.\"你正在克隆对象&lt;br&gt;\"; &#125;&#125;$person = new Person('小明'); // 初始赋值$person2 = clone $person;var_dump('persion1:');var_dump($person);echo '&lt;br&gt;';var_dump('persion2:');var_dump($person2); __autoload() 尝试加载未定义的类 123456789101112131415161718192021/** * 文件autoload_demo.php */ function __autoload($className)&#123; $filePath = \"project/class/&#123;$className&#125;.php\"; if (is_readable($filePath)) &#123; require($filePath); &#125; &#125; if (条件A) &#123; $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 &#125; else if (条件B) &#123; $a = newA(); $b = new B(); // … 业务逻辑 &#125; __debugInfo() 打印所需调试信息该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。 12345678910111213141516171819202122&lt;?phpclass C &#123; private $prop; public function __construct($val) &#123; $this-&gt;prop = $val; &#125; /** * @return array */ public function __debugInfo() &#123; return [ 'propSquared' =&gt; $this-&gt;prop ** 2, ]; &#125;&#125;var_dump(new C(42));","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"魔术方法","slug":"魔术方法","permalink":"http://blog.caoxl.com/tags/魔术方法/"}]},{"title":"Laravel 5.7 复习笔记","slug":"Laravel-V57-Notes","date":"2019-01-21T02:29:18.000Z","updated":"2019-08-22T03:52:19.000Z","comments":true,"path":"2019/01/21/Laravel-V57-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/01/21/Laravel-V57-Notes/","excerpt":"看官请绕道: Laravel 5.7 中文文档,此篇博客是本人复习+学习笔记。","text":"看官请绕道: Laravel 5.7 中文文档,此篇博客是本人复习+学习笔记。 这是我自己对于Laravel文档的一次地毯式学习,时常看文档,都能从文档中学习到或多或少的知识点. 入门指南安装 LaravelLaravel 使用 Composer 来管理项目依赖。因此，在使用 Laravel 之前，请确保你的机器已经安装了 Composer。 12345// 通过 Laravel 安装器composer global require \"laravel/installer\"// 通过 Composer 创建项目composer create-project --prefer-dist laravel/laravel blog 配置文件 应用密钥 1php artisan key:generate 这个字符串长度为 32 个字符。密钥可以在 .env 环境文件中设置。前提是你要将 .env.example 文件重命名为 .env Web 服务器配置Apache如果 Laravel 附带的 .htaccess 文件不起作用，尝试下面的方法替代: 123456Options +FollowSymLinks -IndexesRewriteEngine OnRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^ index.php [L] Nginx123location / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 配置信息配置缓存为了给你的应用程序提升速度，你应该使用 Artisan 命令 config:cache 将所有的配置文件缓存到单个文件中。这会把你的应用程序中所有的配置选项合并成一个单一的文件，然后框架会快速加载这个文件。 1php artisan config:cache 这个命令不应在本地开发环境下运行，因为配置选项在应用程序开发过程中是经常需要被更改的. 如果在部署过程中执行 config:cache 命令，那你应该确保只从配置文件内部调用 env 函数。一旦配置被缓存，.env 文件将不再被加载，所有对 env 函数的调用都将返回 null。 维护模式当应用程序处于维护模式时，所有对应用程序的请求都显示为一个自定义视图。这样可以在更新或执行维护时轻松地「关闭」你的应用程序。 维护模式检查包含在应用程序的默认中间件栈中。如果应用程序处于维护模式，则将抛出一个状态码为 503 的 MaintenanceModeException 异常。 1php artisan down 你还可以向 down 命令提供 message 和 retry 选项。其中 message 选项的值可用于显示或记录自定义消息，而 retry 值可用于设置 HTTP 请求头中 Retry-After 的值： 1php artisan down --message=\"Upgrading Databse\" --retry=60 即使在维护模式下，也可以使用命令 allow 选项允许特定的 IP 地址或网络访问应用程序： 1php artisan down --allow=127.0.0.1 --allow=192.168.0.0/16 要关闭维护模式，请使用 up 命令： 1php artisan up 文件夹结构 app 目录 app 目录包含应用程序的核心代码 Broadcasting 目录 Broadcasting 目录包含应用程序的所有广播频道类。 这些类可以通过使用 make:channel 命令来创建。 Console 目录 Console 目录包含了所有自定义的 Artisan 命令。这些命令可以通过 make:command 来生成。这个目录还包含了控制台内核，控制台内核可以用来注册你的自定义 Artisan 命令和你定义的 计划任务 的地方 Events 目录 Events 目录默认是不存在的，它会在你运行 Artisan 命令 event:generate 或 make:event 时生成。Events 目录存放了 事件类。可以使用事件来提醒应用其他部分发生了特定的操作，使应用程序更加的灵活和解耦。 Exceptions 目录 Exceptions 目录包含了应用的异常处理器，也是应用抛出异常的好地方。如果想自定义记录或者渲染异常的方式，你就要修改此目录下的 Handler 类。 Http 目录 Http 目录包含了控制器、中间件和表单请求。几乎所有的进入应用的请求的处理逻辑都被放在这里。 Jobs 目录 Jobs 目录默认是不存在的，它会在你运行 Artisan 命令 make:job 时生成。这个目录存放了应用中的 队列任务 。 Listeners 目录 Listeners 目录默认是不存在的，它会在你运行 Artisan 命令 event:generate 或 make:listener 时生成。Listeners 目录包含了用来处理 事件 的类。事件监听器接收事件实例并执行响应该事件被触发的逻辑 Mail 目录 Mail 目录默认不存在，它会在你运行 Artisan 命令 make:mail 时生成。 Mail 目录包含应用所有的邮件发送类。 Notifications 目录 Notifications 目录默认不存在，它会在你运行 Artisan 命令 make:notification 时生成。Notifications 目录包含应用发送的所有「业务性」通知，比如关于在应用中发生的事件的简单通知 Policies 目录 Policies 目录默认不存在，它会通过运行 Artisan 命令 make:policy 来创建。Policies 目录包含了应用的授权策略类。策略可以用来决定一个用户是否有权限去操作指定资源 Providers 目录 Providers 目录包含了应用的所有 服务提供者 。服务提供者通过在服务容器中绑定服务、注册事件、以及执行其他任务来为即将到来的请求做准备来启动应用。 Rules 目录 Rules 目录默认不存在，它会在运行 Artisan 命令 make:rule 命令时被创建。Rules 目录包含应用自定义验证规则对象 bootstrap 目录 bootstrap 目录包含启动框架的 app.php 文件. 该目录还包含了一个 cache 目录，cache 目录下存放着框架生成的用来提升性能的文件，比如路由和服务缓存文件 config 目录 config 目录，顾名思义，包含应用程序所有的配置文件 database 目录 database 目录包含数据填充和迁移文件以及模型工厂类。你还可以把它作为 SQLite 数据库存放目录。 public 目录 public 目录包含了入口文件index.php，它是进入应用程序的所有请求的入口点。此目录还包含了一些你的资源文件（如图片、JavaScript 和 CSS）。 resources 目录 resources 目录包含了视图和未编译的资源文件（如 LESS、SASS 或 JavaScript）。此目录还包含你所有的语言文件。 routes 目录 routes 目录包含了应用的所有路由定义，Laravel 默认包含了几个路由文件：web.php、api.php、 console.php 和 channels.php。 storage 目录 storage 目录包含编译后的 Blade 模板、session 会话生成的文件、缓存文件以及框架生成的其他文件。这个目录被细分成 app 、 framework 和 logs 三个子目录 app目录 app 目录可以用来存储应用生成的任何文件。 framework 目录 framework 目录用来存储框架生成的文件和缓存 logs 目录 logs 目录包含应用的日志文件 tests 目录 tests 目录包含自动化测试文件。在 PHPUnit 有现成的范例供你参考. 每个测试类都应该以 Test 作为后缀。你可以使用 phpunit 或者 php vendor/bin/phpunit 命令来运行测试。 vendor 目录 vendor 目录包含你所有的 Composer 依赖包。 部署优化优化自动加载部署项目到生产环境时，请确保你优化了 Composer 类的自动加载映射，以便 Composer 可以快速找到正确文件为给定类加载： 1composer install --optimize-autoloader --no-dev 除了优化自动加载之外，还应该确保项目的源代码管理库中包含了 composer.lock 文件。因为当 composer.lock 文件存在时，项目的依赖项可以被更快地安装。 优化配置加载当你将应用部署到生产环境时，请确保在部署过程中运行 Artisan 命令： 1php artisan config:cache 这个命令可以将所有 Laravel 的配置文件合并到单个文件中缓存，此举能大大减少框架在加载配置值时必须执行的系统文件的数量。 优化路由加载如果你构建的是具有许多路由的大型应用程序，那你应该在部署过程中运行 Artisan 命令 route:cache ： 1php artisan route:cache 核心架构请求周期第一件事 Laravel 应用的所有请求入口都是 public/index.php 文件。而所有的请求都是经由你的 Web 服务器（Apache/Nginx）通过配置引导到这个文件。index.php 文件代码并不多，但是，这里是加载框架其它部分的起点。 index.php 文件加载 Composer 生成的自动加载设置，然后从 bootstrap/app.php 脚本中检索 Laravel 应用程序的实例 Laravel 本身采取的第一个动作是创建一个应用程序 / 服务容器。 HTTP / Console内核接下来， 根据进入应用程序的请求类型来将传入的请求发送到 HTTP 内核或控制台内核。而这两个内核是用来作为所有请求都要通过的中心位置。 现在，我们先看看位于 app/Http/Kernel.php 中的 HTTP 内核。 HTTP 内核继承了 Illuminate\\Foundation\\Http\\Kernel 类，该类定义了一个 bootstrappers 数组。 这个数组中的类在请求被执行前运行，这些 bootstrappers 配置了错误处理， 日志， 检测应用环境，以及其它在请求被处理前需要执行的任务。 HTTP 内核还定义了所有请求被应用程序处理之前必须经过的 HTTP 中间件 ，这些中间件处理 HTTP 会话 读写、判断应用是否处于维护模式、 验证 CSRF 令牌 等等。 HTTP 内核的 handle 方法签名相当简单：获取一个 Request ，返回一个 Response。以把该内核想象作一个代表整个应用的大黑盒子，输入 HTTP 请求，返回 HTTP 响应。 服务提供者内核启动操作中最重要的便是你应用的 服务提供者 了。所有应用下的服务提供者均配置到了 config/app.php 配置文件中的 providers 数组中。第一步，所有服务提供者的 register 方法会被调用，然后一旦所有服务提供者均注册后， boot 方法才被调用。 请求调度一旦启动且所有服务提供者被注册，Request 会被递送给路由。路由将会调度请求，交给绑定的路由或控制器，也当然包括路由绑定的中间件。 服务容器绑定绑定基础几乎所有的服务容器绑定都是在 服务提供器, 所以文档中大多数例子都是使用了在服务提供器中绑定的容器。 简单绑定在服务提供器中，你总是可以通过 $this-&gt;app 属性访问容器。我们可以通过容器的 bind 方法注册绑定，bind 方法的第一个参数为要绑定的类/接口名，第二个参数是一个返回类实例的 Closure ： 123$this-&gt;app-&gt;bind('HelpSpot\\API', function ($app) &#123; return new HelpSpot\\API($app-&gt;make('HttpClient'));&#125;); 绑定一个单例singleton 方法将类或接口绑定到只解析一次的容器中。一旦单例绑定被解析，相同的对象实例会在随后的调用中返回到容器中： 123$this-&gt;app-&gt;singleton('HelpSpot\\API', function ($app) &#123; return new HelpSpot\\API($app-&gt;make('HttpClient'));&#125;); 绑定实例你也可以使用 instance 方法将现有对象实例绑定到容器中。给定的实例会始终在随后的调用中返回到容器中： 123$api = new HelpSpot\\API(new HttpClient);$this-&gt;app-&gt;instance('HelpSpot\\API', $api); 绑定基本值当你有一个类不仅需要接受一个注入类，还需要注入一个基本值（比如整数）。你可以使用上下文绑定来轻松注入你的类需要的任何值 123$this-&gt;app-&gt;when('App\\Http\\Controllers\\UserController') -&gt;needs('$variableName') -&gt;give($value); 绑定接口到实现服务容器有一个很强大的功能，就是支持绑定接口到给定的实现 例如，如果我们有个 EventPusher 接口 和一个 RedisEventPusher 实现。一旦我们写完了 EventPusher 接口的 RedisEventPusher 实现，我们就可以在服务容器中注册它，像这样： 1234$this-&gt;app-&gt;bind( 'App\\Contracts\\EventPusher', 'App\\Services\\RedisEventPusher'); 这么做相当于告诉容器：当一个类需要实现 EventPusher 时，应该注入 RedisEventPusher。现在我们就可以在构造函数或者任何其他通过服务容器注入依赖项的地方使用类型提示注入 EventPusher 接口： 123456789101112use App\\Contracts\\EventPusher;/** * 创建新的类实例 * * @param EventPusher $pusher * @return void */public function __construct(EventPusher $pusher)&#123; $this-&gt;pusher = $pusher;&#125; 上下文绑定有时你可能有两个类使用了相同的接口，但你希望各自注入不同的实现。 12345678910111213141516use Illuminate\\Support\\Facades\\Storage;use App\\Http\\Controllers\\PhotoController;use App\\Http\\Controllers\\VideoController;use Illuminate\\Contracts\\Filesystem\\Filesystem;$this-&gt;app-&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('local'); &#125;);$this-&gt;app-&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('s3'); &#125;); 扩展绑定extend 方法可以修改已解析的服务。例如，当一个服务被解析后，你可以添加额外的代码去修饰或配置这个服务。extend 方法接受一个闭包，该闭包唯一参数就是这个服务，并返回修改过的服务： 123$this-&gt;app-&gt;extend(Service::class, function($service) &#123; return new DecoratedService($service);&#125;); 解析实例make 方法你可以使用 make 方法从容器中解析出类实例。make 方法接受一个你想要解析的类名或接口名： 1$api = $this-&gt;app-&gt;make('HelpSpot\\API'); 如果你的代码处于无法访问 $app 变量的位置，则可用全局辅助函数 resolve 来解析： 1$api = resolve('HelpSpot\\API'); 如果你的类依赖不能通过容器来解析，你可以通过将它们作为关联数组传递到 makeWith 方法来注入它们： 1$api = $this-&gt;app-&gt;makeWith('HelpSpot\\API', ['id' =&gt; 1]); 自动注入1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\\Http\\Controllers;use App\\Users\\Repository as UserRepository;class UserController extends Controller&#123; /** * user repository 实例 */ protected $users; /** * 创建一个新的控制器实例 * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125; /** * 显示给定ID的user * * @param int $id * @return Response */ public function show($id) &#123; // &#125;&#125; 容器事件服务容器每次解析对象时会触发一个事件，你可以使用 resolving 方法监听这个事件： 1234567$this-&gt;app-&gt;resolving(function ($object, $app) &#123; // Called when container resolves object of any type...&#125;);$this-&gt;app-&gt;resolving(HelpSpot\\API::class, function ($api, $app) &#123; // Called when container resolves objects of type \"HelpSpot\\API\"...&#125;); 基础功能路由这里拿Lumen的路由组展示,因为我一般用Lumen做接口开发. 123456789101112131415161718192021222324&lt;?php$app-&gt;group([ 'prefix' =&gt; 'test', // 路由前缀 'namespace' =&gt; 'Test', // 命名空间 'middleware' =&gt; [ // 中间件 'TestMiddleware1', 'TestMiddleware2' ],], function () use ($app) &#123; $app-&gt;get('/', function () &#123; return response()-&gt;json([ 'error' =&gt; '403' ], 403); &#125;); // 可用的路由方法 $app-&gt;get($uri, $callback); $app-&gt;post($uri, $callback); $app-&gt;put($uri, $callback); $app-&gt;patch($uri, $callback); $app-&gt;delete($uri, $callback); $app-&gt;options($uri, $callback);&#125;); 中间件定义中间件通过运行 make:middleware Artisan 命令来创建新的中间件： 1php artisan make:middleware CheckAge 该命令会在 app/Http/Middleware 目录下创建一个新的CheckAge 类，在这个中间件中，我们仅允许 age 参数大于 200 的请求对此路由进行访问，否则，将重定向到 home。 123456789101112131415161718192021222324&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckAge&#123; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; if ($request-&gt;age &lt;= 200) &#123; return redirect('home'); &#125; return $next($request); &#125;&#125; 注册中间件全局中间件如果你希望中间件在应用处理每个 HTTP 请求期间运行。只需要在 app/Http/Kernel.php 中的 $middleware 属性中列出这个中间件。 为路由分配中间件假设你想为指定的路由分配中间件，首先应该在 app/Http/Kernel.php 文件内为该中间件分配一个键。 12345678910111213// 在 App\\Http\\Kernel 类中...protected $routeMiddleware = [ 'auth' =&gt; \\App\\Http\\Middleware\\Authenticate::class, 'auth.basic' =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, 'bindings' =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 'cache.headers' =&gt; \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, 'can' =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class, 'guest' =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, 'signed' =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, 'throttle' =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, 'verified' =&gt; \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,]; 一旦在 HTTP 内核中定义好了中间件，就可以通过 middleware 方法将为路由分配中间件： 12345678Route::get('admin/profile', function () &#123; //&#125;)-&gt;middleware('auth');// 你也可以为路由分配多个中间件：Route::get('/', function () &#123; //&#125;)-&gt;middleware('first', 'second'); 分配中间件时，你还可以传递完整的类名 12345use App\\Http\\Middleware\\CheckAge;Route::get('admin/profile', function () &#123; //&#125;)-&gt;middleware(CheckAge::class); Terminable 中间件有时中间件可能需要在 HTTP 响应构建完毕之后处理一些工作。比如，Laravel 内置的「session」中间件会在响应构建完毕之后将会话数据写入存储器中。如果你在中间件中定义了一个 terminate 方法，则会在响应构建完毕后，准备发往浏览器之前自动调用： 123456789101112131415161718&lt;?phpnamespace Illuminate\\Session\\Middleware;use Closure;class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125; public function terminate($request, $response) &#123; // 储存 session 数据... &#125;&#125; 控制器资源控制器Laravel 资源路由将典型的「CRUD」路由分配给具有单行代码的控制器。比如，你希望创建一个控制器来处理应用保存的「照片」的所有 HTTP 请求。使用 Artisan 命令 make:controller，我们可以快速创建这样一个控制器： 1php artisan make:controller PhotoController --resouce 这个命令会生成一个控制器 app/Http/Controllers/PhotoController.php。 其中包含了每个可用资源操作的方法。接下来，你可以给控制器注册一个资源路由： 1Route::resource('photos', PhotoController'); 依赖注入 &amp; 控制器构造函数注入1234public function __construct(UserRepository $users)&#123; $this-&gt;users = $users;&#125; 方法注入12345678use Illuminate\\Http\\Request;public function store(Request $request)&#123; $name = $request-&gt;name; //&#125; 路由缓存如果你的应用只使用了基于控制器的路由，那么你应该利用路由缓存。 使用路由缓存将极大地减少注册所有应用路由所需的时间。 1php artisan route:cache 你可以使用 route:clear 命令清除路由缓存： 1php artisan route:clear 请求获取请求12345678use Illuminate\\Http\\Request;public function store(Request $request)&#123; $name = $request-&gt;input('name'); //&#125; 通过路由闭包获取请求12345use Illuminate\\Http\\Request;Route::get('/', function (Request $request) &#123; //&#125;); 获取输入123456789101112131415161718192021222324// 获取所有输入数据$input = $request-&gt;all();// 获取指定输入值$name = $request-&gt;input('name');// 给 input 方法的第二个参数传入一个默认值。如果请求的输入值不存在请求上，就返回默认值：$name = $request-&gt;input('name', 'Sally');// 从查询字符串获取输入$name = $request-&gt;query('name');$name = $request-&gt;query('name', 'Helen');// 通过动态属性获取输入$name = $request-&gt;name;// 获取 JSON 输入信息// 只要请求的 Content-Type 标头正确设置为 application/json，就可以通过 input 方法访问 JSON 数据$name = $request-&gt;input('user.name');// 获取部分输入数据$input = $request-&gt;only(['username', 'password']);$input = $request-&gt;only('username', 'password');$input = $request-&gt;except(['credit_card']);$input = $request-&gt;except('credit_card'); 旧输入12345678910111213// 将输入闪存至 Session$request-&gt;flash();$request-&gt;flashOnly(['username', 'email']);$request-&gt;flashExcept('password');// 闪存输入后重定向return redirect('form')-&gt;withInput();return redirect('form')-&gt;withInput( $request-&gt;except('password'));// 获取旧输入$username = $request-&gt;old('username'); 文件获取上传文件1234567$file = $request-&gt;file('photo');$file = $request-&gt;photo;// 使用 hasFile 方法确认请求中是否存在文件：if ($request-&gt;hasFile('photo')) &#123; //&#125; 验证成功上传123if ($request-&gt;file('photo')-&gt;isValid()) &#123; //&#125; 文件路径 &amp; 扩展名12$path = $request-&gt;photo-&gt;path();$extension = $request-&gt;photo-&gt;extension(); 响应创建响应1234567891011121314151617181920212223242526272829303132333435363738394041424344// 字符串 &amp; 数组Route::get('/', function () &#123; return 'Hello World';&#125;);Route::get('/', function () &#123; return [1, 2, 3];&#125;);// 响应对象Route::get('home', function () &#123; return response('Hello World', 200) -&gt;header('Content-Type', 'text/plain');&#125;);// 为响应增加头信息return response($content) -&gt;header('Content-Type', $type) -&gt;header('X-Header-One', 'Header Value') -&gt;header('X-Header-Two', 'Header Value');// 或者return response($content) -&gt;withHeaders([ 'Content-Type' =&gt; $type, 'X-Header-One' =&gt; 'Header Value', 'X-Header-Two' =&gt; 'Header Value', ]);// 为响应增加 Cookiereturn response($content) -&gt;header('Content-Type', $type) -&gt;cookie('name', 'value', $minutes); // 重定向至命名路由return redirect()-&gt;route('login');return redirect()-&gt;route('profile', ['id' =&gt; 1]); // 重定向至控制器行为return redirect()-&gt;action('HomeController@index'); // 重定向到外部域return redirect()-&gt;away('https://www.google.com');// 重定向并使用闪存的 Session 数据return redirect('dashboard')-&gt;with('status', 'Profile updated!'); 视图响应123return response() -&gt;view('hello', $data, 200) -&gt;header('Content-Type', $type); JSON 响应123456789return response()-&gt;json([ 'name' =&gt; 'Abigail', 'state' =&gt; 'CA']);// JSONP 响应return response() -&gt;json(['name' =&gt; 'Abigail', 'state' =&gt; 'CA']) -&gt;withCallback($request-&gt;input('callback')); 文件下载download 方法可以用来生成强制用户浏览器下载指定路径文件的响应。download 方法的第二个参数接受一个文件名，它将作为用户下载的时所看见的文件名。最后，你可以传递一个 HTTP 响应头数组作为该方法的第三个参数： 123return response()-&gt;download($pathToFile);return response()-&gt;download($pathToFile, $name, $headers);return response()-&gt;download($pathToFile)-&gt;deleteFileAfterSend(true); 流式下载有时，你可能希望将给定操作的字符串响应转换为可下载的响应，而无需将操作的内容写入磁盘。 你可以在这个场景中使用 streamDownload 方法。 此方法接受回调，文件名和可选的标题数组作为其参数： 12345return response()-&gt;streamDownload(function () &#123; echo GitHub::api('repo') -&gt;contents() -&gt;readme('laravel', 'laravel')['contents'];&#125;, 'laravel-readme.md'); File 响应file 方法可以直接在用户浏览器中显示文件（不是发起下载），例如图像或者 PDF。此方法接受文件的路径作为其第一个参数和头信息数组作为其第二个参数： 12return response()-&gt;file($pathToFile);return response()-&gt;file($pathToFile, $headers); 响应宏如果要定义可以在各种路由和控制器中重复使用的自定义响应，可以在 Response Facade 上使用 macro 方法。例如，你可以在 服务提供器 的 boot 方法中这样写： 123456789101112131415161718192021&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Support\\Facades\\Response;class ResponseMacroServiceProvider extends ServiceProvider&#123; /** * 注册应用程序的响应宏 * * @return void */ public function boot() &#123; Response::macro('caps', function ($value) &#123; return Response::make(strtoupper($value)); &#125;); &#125;&#125; macro 函数接受一个名称作为其第一个参数，闭包作为第二个参数。当宏名称从 ResponseFactory 实现或者辅助函数 response 调用时，其闭包函数才会被执行： 1return response()-&gt;caps('foo'); Session配置Session driver 的配置预设了每个请求存储 Session 数据的位置。Laravel 自带了几个不错而且开箱即用的驱动： file - 将 Session 存储在 storage/framework/sessions 中。 cookie - Sessions 被存储在安全加密的 cookie 中。 database - Sessions 被存储在关系型数据库中。 memcached / redis - Sessions 被存储在基于高速缓存的存储系统中。 array - Sessions 存储在 PHP 数组中，但不会被持久化。 使用Session123456789101112131415161718192021222324252627282930313233// 获取数据$value = $request-&gt;session()-&gt;get('key');// 全局辅助函数 Session// 获取 session 中的一条数据...$value = session('key')// 指定一个默认值...$value = session('key', 'default');// 在 Session 中存储一条数据...session(['key' =&gt; 'value']);// 获取所有的 Session 数据$data = $request-&gt;session()-&gt;all();// 判断 Session 中是否存在某个值if ($request-&gt;session()-&gt;has('users')) &#123; //&#125;// 检索 &amp; 删除一条数据$value = $request-&gt;session()-&gt;pull('key', 'default');// 闪存数据$request-&gt;session()-&gt;flash('status', 'Task was successful!');// 删除数据$request-&gt;session()-&gt;forget('key');$request-&gt;session()-&gt;flush();// 重新生成 Session ID$request-&gt;session()-&gt;regenerate(); 表单验证编写验证器逻辑。为此，我们将使用 Illuminate\\Http\\Request 对象提供的 validate 方法 。如果验证通过，代码就可以正常的运行。如果验证失败，则会抛出异常，并自动将对应的错误响应返回给用户。 12345678910111213141516public function store(Request $request)&#123; $validatedData = $request-&gt;validate([ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ]); // 博客文章验证通过&#125;// 首次验证失败后停止运行// 希望在某个属性第一次验证失败后停止运行验证规则，你需要附加 bail 规则到该属性：$request-&gt;validate([ 'title' =&gt; 'bail|required|unique:posts|max:255', 'body' =&gt; 'required',]); 验证表单请求创建表单请求验证1php artisan make:request StoreBlogPost 新生成的类保存在 app/Http/Requests 目录下。如果这个目录不存在，运行 make:request 命令时它会被创建出来。让我们添加一些验证规则到 rules 方法中： 123456789101112/** * 获取适用于请求的验证规则。 * * @return array */public function rules()&#123; return [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ];&#125; 你可以向 rules 方法传入所需的任何依赖项。他们会自动被 Laravel 提供的 服务容器 自动解析。 12345678910111213/** * 存储传入的博客文章。 * * @param StoreBlogPost $request * @return Response */public function store(StoreBlogPost $request)&#123; // 传入的请求通过验证... // 获取通过验证的数据... $validated = $request-&gt;validated();&#125; 如果验证失败，就会生成一个让用户返回到先前的位置的重定向响应。这些错误也会被闪存到 session 中，以便这些错误都可以在页面中显示出来。如果传入的请求是 AJAX，会向用户返回具有 422 状态代码和验证错误信息的 JSON 数据的 HTTP 响应。 添加表单请求后钩子如果你想在表单请求「之后」添加钩子，可以使用 withValidator 方法 123456789101112131415/** * 配置验证器实例。 * * @param \\Illuminate\\Validation\\Validator $validator * @return void */public function withValidator($validator)&#123; // 验证后钩子 $validator-&gt;after(function ($validator) &#123; if ($this-&gt;somethingElseIsInvalid()) &#123; $validator-&gt;errors()-&gt;add('field', 'Something is wrong with this field!'); &#125; &#125;);&#125; 表单请求授权验证表单请求类内也包含了 authorize 方法。在这个方法中，你可以检查经过身份验证的用户确定其是否具有更新给定资源的权限。比方说，你可以判断用户是否拥有更新文章评论的权限： 1234567891011/** * 判断用户是否有权限做出此请求。 * * @return bool */public function authorize()&#123; $comment = Comment::find($this-&gt;route('comment')); return $comment &amp;&amp; $this-&gt;user()-&gt;can('update', $comment);&#125; 如果 authorize 方法返回 false，则会自动返回一个包含 403 状态码的 HTTP 响应，也不会运行控制器的方法。 如果你打算在应用程序的其它部分处理授权逻辑，只需从 authorize 方法返回 true ： 123456789/** * 判断用户是否有权限进行此请求。 * * @return bool */public function authorize()&#123; return true;&#125; 自定义错误消息123456789101112/** * Get the error messages for the defined validation rules. * * @return array */public function messages()&#123; return [ 'title.required' =&gt; 'A title is required', 'body.required' =&gt; 'A message is required', ];&#125; 手动创建验证器如果你不想在请求上使用 validate 方法，你可以通过 Validator facade 手动创建一个验证器示例。用 Validator facade 上的 make 方法创建一个验证器示例： 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\\Http\\Controllers;use Validator;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;class PostController extends Controller&#123; /** * Store a new blog post. * * @param Request $request * @return Response */ public function store(Request $request) &#123; $validator = Validator::make($request-&gt;all(), [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ]); if ($validator-&gt;fails()) &#123; return redirect('post/create') -&gt;withErrors($validator) -&gt;withInput(); &#125; // Store the blog post... &#125;&#125; 错误Report 辅助函数有时你可能需要报告异常，但又不希望终止当前请求的处理。report 辅助函数允许你使用异常处理器的 report 方法在不显示错误页面的情况下快速报告异常： 12345678910public function isValid($value)&#123; try &#123; // 验证值... &#125; catch (Exception $e) &#123; report($e); return false; &#125;&#125; Render 方法123456789101112131415/** * 将异常l转换为 HTTP 响应。 * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $exception * @return \\Illuminate\\Http\\Response */public function render($request, Exception $exception)&#123; if ($exception instanceof CustomException) &#123; return response()-&gt;view('errors.custom', [], 500); &#125; return parent::render($request, $exception);&#125; Reportable &amp; Renderable 异常1234567891011121314151617181920212223242526272829&lt;?phpnamespace App\\Exceptions;use Exception;class RenderException extends Exception&#123; /** * 报告异常 * * @return void */ public function report() &#123; // &#125; /** * 转换异常为 HTTP 响应 * * @param \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function render($request) &#123; return response(...); &#125;&#125; HTTP 异常12abort(404);abort(403, 'Unauthorized action.'); 日志记录日志消息12345678910use Illuminate\\Support\\Facades\\Log;Log::emergency($message);Log::alert($message);Log::critical($message);Log::error($message);Log::warning($message);Log::notice($message);Log::info($message);Log::debug($message); 记录日志到指定通道你可以使用 Log Facade 中的 channel 方法，将日志记录到应用配置中存在的任何渠道： 1Log::channel('slack')-&gt;info('Something happened!'); 如果你想按需创建多个渠道的日志堆栈，你可以使用 stack 方法： 1Log::stack(['single', 'slack'])-&gt;info('Something happened!'); 安全相关综合话题数据库Eloquent ORM测试相关官方扩展包","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel 5.7","slug":"Laravel-5-7","permalink":"http://blog.caoxl.com/tags/Laravel-5-7/"}]},{"title":"Lumen 5.7 复习笔记","slug":"Lumen-V57-Notes","date":"2019-01-09T01:52:16.000Z","updated":"2019-08-22T06:12:28.000Z","comments":true,"path":"2019/01/09/Lumen-V57-Notes/","link":"","permalink":"http://blog.caoxl.com/2019/01/09/Lumen-V57-Notes/","excerpt":"Lumen 利用 Composer 来管理它的代码依赖，所以在使用 Lumen 之前，请先确认你的电脑上安装了 Composer。","text":"Lumen 利用 Composer 来管理它的代码依赖，所以在使用 Lumen 之前，请先确认你的电脑上安装了 Composer。 看官请绕道: Lumen 中文文档 5.7 ,此篇博客是本人复习+学习笔记。 安装环境要求 PHP &gt;= 7.1.3 OpenSSL PHP Extension PDO PHP Extension Mbstring PHP Extension 安装Lumen123456// 通过 Lumen 安装器composer global require \"laravel/lumen-installer\"lumen new site// 通过 Composer Create-Project 命令安装composer create-project --prefer-dist laravel/lumen site 运行1php -S localhost:8000 -t public 应用程序密钥 安装完 Lumen 后，首先需要做的事情是设置一个随机字符串到应用程序密钥。通常这个密钥会有 32 字符长。Laravel 有自动生成的命令: php artisan key:generate 如果应用程序密钥没有被设置的话，你的用户 Session 和其它的加密数据都是不安全的！ 配置获取/设置配置123456// 读取$value = config('app.locale');// 设置config(['app.locale' =&gt; 'en']);// 使用前加载 在'boostrap/app.php'$app-&gt;configure('app'); 环境配置Lumen 利用 Vance Lucas 的 PHP 库 DotEnv 使得此项功能的实现变得非常简单。 12345try &#123; (new Dotenv\\Dotenv(dirname(__DIR__)))-&gt;load();&#125; catch (Dotenv\\Exception\\InvalidPathException $e) &#123; //&#125; 创建应用时应该将 .env.example 文件重命名为 .env .env 文件中列出的所有变量都会被加载到 PHP 的超全局变量 $ _ENV 中。 env 函数可以用来获取环境变量中的值 1$debug = env('APP_DEBUG', true); 判定当前运行环境12345678910$environment = app()-&gt;environment();// 判断环境if (app()-&gt;environment('local')) &#123; // 当前环境是 local&#125;if (app()-&gt;environment('local', 'staging')) &#123; // 当前环境是 local 或者 staging...&#125; 路由基本路由123$router-&gt;get('foo', function () &#123; return 'Hello World';&#125;); 可供使用的路由方法123456$router-&gt;get($uri, $callback);$router-&gt;post($uri, $callback);$router-&gt;put($uri, $callback);$router-&gt;patch($uri, $callback);$router-&gt;delete($uri, $callback);$router-&gt;options($uri, $callback); 路由参数必填参数1234567$router-&gt;get('user/&#123;id&#125;', function ($id) &#123; return 'User ' . $id;&#125;);$router-&gt;get('posts/&#123;postId&#125;/comments/&#123;commentId&#125;', function ($postId, $commentId) &#123; //&#125;); 可选参数123$router-&gt;get('user[/&#123;name&#125;]', function ($name = null) &#123; return $name;&#125;) 命名路由12345678$router-&gt;get('profile', ['as' =&gt; 'profile', function () &#123; //&#125;);$router-&gt;get('profile', [ 'as' =&gt; 'profile', 'uses' =&gt; 'UserController@showProfile']); 中间件/命名空间/路由前缀123456789$router-&gt;group([ 'middleware' =&gt; 'auth', 'namespace' =&gt; 'Admin', 'prefix' =&gt; 'admin'], function () use ($router) &#123; $router-&gt;get('/', function () &#123; // 使用Auth中间件 &#125;);&#125;); 中间件 HTTP 中间件提供了一个方便的机制来过滤进入应用程序的 HTTP 请求。例如，Lumen 内置了一个中间件来验证用户的身份认证。如果用户未通过身份验证，中间件将会把用户导向登录页面，反之，当用户通过了身份验证，中间件将会通过此请求并接着往下执行。 当然，除了身份验证之外，中间件也可以被用来运行各式各样的任务，如：CORS 中间件负责替所有即将离开程序的响应加入适当的标头；而日志中间件则可以记录所有传入应用程序的请求。 定义中间件可以通过复制 Lumen 内置的示例文件 ExampleMiddleware 来创建一个中间件。 1234567891011121314151617181920212223&lt;?phpnamespace App\\Http\\Middleware;use Closure;class OldMiddleware&#123; /** * 运行请求过滤器 * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; if ($request-&gt;input('age') &lt;= 200) &#123; return redirect('home'); &#125; return $next($request); &#125;&#125; 前置/后置中间件123456789101112131415&lt;?phpnamespace App\\Http\\Middleware;use Closure;class BeforeMiddleware&#123; public function handle($request, Closure $next) &#123; // 执行操作 return $next($request); &#125;&#125; 1234567891011121314151617&lt;?phpnamespace App\\Http\\Middleware;use Closure;class AfterMiddleware&#123; public function handle($request, Closure $next) &#123; $response = $next($request); // 执行操作 return $response; &#125;&#125; 注册中间件全局中间件只需要在 bootstrap/app.php 文件中的 $app-&gt;middleware() 方法中列出这个中间件： 123$app-&gt;middleware([ App\\Http\\Middleware\\OldMiddleware::class]); 为路由分配中间件首先需要在 bootstrap/app.php 文件中调用 $app-&gt;routeMiddleware() 方法时为中间件分配一个简短的键： 123$app-&gt;routeMiddleware([ 'auth' =&gt; App\\Http\\Middleware\\Authenticate::class,]); 一旦在 HTTP 内核中定义好了中间件，就可以在路由选项内使用 middleware 键： 123456789$router-&gt;get('admin/profile', ['middleware' =&gt; 'auth'], function () &#123; //&#125;); // 可以使用数组为路由指定多个中间件：$router-&gt;get('/', ['middleware' =&gt; ['first', 'second'], function () &#123; //&#125;]); 中间件参数中间件也可以接收自定义传参，例如，要在运行特定操作前检查已验证用户是否具备该操作的 “ 角色 “ ，可以创建 RoleMiddleware 来接收角色名称作为额外的传参。 附加的中间件参数将会在 $next 参数之后被传入中间件： 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Http\\Middleware;use Closure;class RoleMiddleware&#123; /** * 运行请求过滤 * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next, $role) &#123; if (! $request-&gt;user()-&gt;hasRole($role)) &#123; // 重定向... &#125; return $next($request); &#125;&#125; 在路由中可使用冒号 : 来区隔中间件名称与指派参数，多个参数可使用逗号作为分隔： 123$router-&gt;put('post/&#123;id&#125;', ['middleware' =&gt; 'role:editor'], function ($id) &#123; //&#125;); Terminable 中间件有时中间件可能需要在 HTTP 响应发送到浏览器之后处理一些工作。例如， &quot;session&quot; 中间件会在响应发送到浏览器之后将会话数据写入存储器中。想要做到这一点，你需要定义一个名为 &quot;terminable&quot; 的中间并添加一个 terminate 方法： 123456789101112131415161718&lt;?phpnamespace Illuminate\\Session\\Middleware;use Closure;class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125; public function terminate($request, $response) &#123; // 存储 session 数据... &#125;&#125; terminate 方法应该同时接收和响应。一旦定义了这个中间件，你应该将它添加到路由列表或 bootstrap/app.php 文件的全局中间件中。 控制器基础控制器123456789101112131415161718&lt;?phpnamespace App\\Http\\Controllers;use App\\User;class UserController extends Controller&#123; /** * 获取指定 ID 的用户 * @param int $id * @return Response */ public function show($id) &#123; return User::findOrFail($id); &#125;&#125; 然后像下面这样将路由指向控制器的方法： 1$router-&gt;get('user/&#123;id&#125;', 'UserController@show'); 控制器中间件中间件 可通过如下方式分配到路由中： 1234$router-&gt;get('profile', [ 'middleware' =&gt; 'auth', 'uses' =&gt; 'UserController@showProfile']); 更方便的方式是在控制器的构造方法里面使用 middleware 方法指定中间件。 1234567891011121314public function __construct()&#123; $this-&gt;middleware('auth'); $this-&gt;middleware('log', ['only' =&gt; [ 'fooAction', 'barAction', ]]); $this-&gt;middleware('subscribed', ['except' =&gt; [ 'fooAction', 'barAction', ]]);&#125; 依赖注入构造器注入Lumen 使用 「 服务容器 」 来解析所有的控制器的依赖注入。因此，你可以在控制器的构造函数中使用类型提示需要的任何依赖。这些依赖将会自动的解析并注入到控制器实例中： 123456use App\\Repositories\\UserRepository;public function __construct(UserRepository $ur)&#123; $this-&gt;users = $ur;&#125; 方法注入除了构造器注入以外，你也可以在你的控制器方法中使用类型提示依赖项。例如，在某个方法中添加 Illuminate\\Http\\Request 实例的类型提示： 12345678910111213use Illuminate\\Http\\Request;public function store(Request $request)&#123; $name = $request-&gt;input('name');&#125;// 用类型提示注入 Illuminate\\Http\\Request 类和你的路由参数 id // $router-&gt;put('user/&#123;id&#125;', 'UserController@update');public function update(Request $request, $id)&#123; //&#125; 请求获取请求实例要通过依赖注入的方式获取当前HTTP请求的实例，你应该在控制器构造函数或方法中使用 Illuminate\\Http\\Request 类，当前请求实例将自动被 服务容器 注入： 同方法注入. 获取请求的URI123456789101112$uri = $request-&gt;path();// is 方法可以校验接收到的请求 URI 是否与指定规则匹配，你可以使用 * 符号作为通配符：if ($request-&gt;is('admin/*')) &#123; //&#125;// 如果要获取完整的 URL 而不是 URI，可以使用 url 或者 fullUrl 方法:// 不包含请求参数$url = $request-&gt;url();//抱会请求参数$url = $request-&gt;fullUrl(); 获取请求的方法123456$method = $request-&gt;method();// 使用 isMethod 方法校验 HTTP 动作是否与指定字符串匹配：if ($request-&gt;isMethod('post')) &#123; //&#125; PSR-7 请求PSR-7 标准规定了 HTTP 消息接口包含了请求及响应，如果你想获得 PSR-7 的请求实例，就需要先安装几个库，Laravel 使用 Symfony 的 HTTP 消息桥接组件，将原 Laravel 的请求及响应转换至 PSR-7 所支持的实现： 12composer require symfony/psr-http-message-bridgecomposer require zendframework/zend=diactoros 安装完这些库后，你就可以在路由或控制器中，简单的对请求类型使用类型提示来获取 PSR-7 请求： 1234user Psr\\Http\\Message\\ServerRequestInterface;$router-&gt;get('/', function (ServerRequestInterface $request) &#123; //&#125;); 获取输入数据 获取指定输入值 12345678$name = $request-&gt;input('name');// 你可以在 input 方法的第二个参数中传入一个默认值，当请求参数不存在时，就会返回默认值：$name = $request-&gt;input('name', 'Caoxl');// 当数据是以数组形式输入时，你可以使用 \" 点 \" 符号来获取数组：$name = $request-&gt;input('array.0.name');$name = $request-&gt;input('array.*.name'); 确定输入值是否存在 12345678910111213if ($request-&gt;has('name')) &#123; //&#125;// 当给定一个数组时， has 方法将确定是否所有指定值都存在：if ($request-&gt;has(['name', 'email'])) &#123; //&#125;// 如果你想确定请求中是否存在值并且不为空，可以使用 filled 方法:if ($request-&gt;filled('name')) &#123; //&#125; 获取所有输入数据 1$input = $reuest-&gt;all(); 获取部分输入数据 1234$input = $request-&gt;only(['username', 'password']);$input = $request-&gt;only('username', 'password');$input = $request-&gt;except(['credit_card']);$input = $request-&gt;except('credit_card'); 文件上传 获取上传文件 123456$file = $request-&gt;file('photo');// 可以使用 hasFile 方法确认上传的文件是否存在:if ($request-&gt;hasFile('photo')) &#123; //&#125; 验证上传是否成功 123if ($request-&gt;file('photo')-&gt;isValid()) &#123; //&#125; 移动上传文件 12$request-&gt;file('photo')-&gt;move($destinationPath);$request-&gt;file('photo')-&gt;move($destinationPath, $fileName); 响应基本响应123$router-&gt;get('/', function () &#123; return 'Hello World';&#125;); 响应对象123456789101112use Illuminate\\Http\\Response;$router-&gt;get('home', function () &#123; return (new Response($content, $status)) -&gt;header('Content-Type', $value);&#125;);// 为了方便起见，你可以使用 response 辅助函数：$router-&gt;get('home', function () &#123; return response($content, $ststus) -&gt;header('Content-Type', $value);&#125;); 附加标头至响应123456789101112return response($content) -&gt;header('Content-Type', $type) -&gt;header('X-header-One', 'Header Value') -&gt;header('X-header-Two', 'Header Value') // 或者你可以使用 withHeaders 方法来设置数组标头：return response($content) -&gt;withHeaders([ 'Content-Type' =&gt; $type, 'X-Header-One' =&gt; 'Header Value', 'X-Header-Two' =&gt; 'Header Value', ]); JSON响应json 方法会自动将标头的 Content-Type 设置为 application/json，并通过 PHP 的 json_encode 函数将指定的数组转换为 JSON： 12345678910111213return response()-&gt;json(['name' =&gt; 'Abigail', 'state' =&gt; 'CA']);// 你可以选择提供一个状态码和一个额外的标题数组：return response()-&gt;json( ['error' =&gt; 'Unauthorized'], 401, ['X-Header-One' =&gt; 'Header Value']);// 如果你想创建一个 JSONP 响应，则可以使用 json 方法并加上 setCallback 方法：return response() -&gt;json(['name' =&gt; 'Abigail', 'state' =&gt; 'CA']) -&gt;setCallback($reqeust-&gt;input('callback')); 文件下载12return response()-&gt;download($pathToFile);return response()-&gt;download($pathToFile, $name, $headers); 重定向123456789101112$router-&gt;get('dashboard', function () &#123; return redirect('home/dashboard');&#125;);// 重定向至命名路由return redirect()-&gt;route('login');// 如果你的路由有参数，则可以将参数放进 route 方法的第二个参数，如下：return redirect()-&gt;route('profile', ['id' =&gt; 1]);// 如果你要重定向至路由且路由的参数为 Eloquent 模型的「ID」，则可以直接将模型传入， ID 将会自动被提取：return redirect()-&gt;route('profile', [$user]); 用户认证认证服务提供者 注意： 在使用 Lumen 的认证功能前，请取消 bootstrap/app.php 文件中的 AuthServiceProvider 调用代码的注释。 123$this-&gt;app['auth']-&gt;viaRequest('api',function ($request) &#123; // 返回User 或 null&#125;); 获取已认证的用户信息就像 Laravel 框架一样，你可以使用 Auth::user() 方法获取当前用户，或者，你可以在 Illuminate\\Http\\Request 实例上使用 $request-&gt;user() 方法： 1234567use Illuminate\\Http\\Request;$router-&gt;get('/post/&#123;id&#125;', ['middleware' =&gt; 'auth'], function (Request $request, $id) &#123; $user = Auth::user(); $user = $request-&gt;user();&#125;) 注意： 如果你想使用 Auth::user() 来获取当前的认证用户，你需要去掉 bootstrap/app.php 文件中 $app-&gt;withFacades() 方法调用的注释。 当然，所有你想要认证的路由，都可以分配给 auth 中间件 ，但需要你去掉 bootstrap/app.php 文件中对 $app-&gt;routeMiddleware() 调用的注释： 123$app-&gt;routeMiddleware([ 'auth' =&gt; App\\Http\\Middleware\\Authenticate::class,]); 用户授权与 Laravel 的差异定义权限在 Lumen 中，你可以很方便的在你的 AuthServiceProvider 文件中使用 Gate facade 来定义你的权限 123Gate::define('update-post', function ($user. $post) &#123; return $user-&gt;id === $post-&gt;user_id;&#125;); 定义授权策略和 Laravel 不一样的是，Lumen 的 AuthServiceProvider 中没有 $policies 数组。但是你可以在 AuthServiceProvider 的 boot 方法里使用 Gate facade 来调用 policy 方法： 1Gate::policy(Post::class, PostPolicy::class); 检查权限你可以像 Laravel 一样使用 Gate facade 来检查权限，首先你要确保你的 bootstrap/app.php 文件开启了 facade。 12345678910111213141516171819 if (Gate::allows('update-post', $post)) &#123; // &#125; if (Gate::denies('update-post', $post)) &#123; abort(403); &#125;``` 当然你也可以传递 `User` 实例来检查他的权限：```php if ($request-&gt;user()-&gt;can('update-post', $post)) &#123; // 用户拥有更新内容的权限 &#125; if ($request-&gt;user()-&gt;cannot('update-post', $post)) &#123; abort(403); &#125; 数据库基本用法 注意: 如果你想使用 DB Facade，你应该去掉在 bootstrap/app.php 文件中 $app-&gt;withFacades() 的调用的注释。 例如，在不启用 Facades 时，你可以通过 app 辅助函数连接数据库： 1$results = app('db')-&gt;select(\"SELECT * FROM users\"); 或者，在启用 Facades 后，你可以通过 DB Facade 来连接数据库： 1$results = DB::select(\"SELECT * FROM users\"); 加密与解密配置在使用 Lumen 的加解密前，你应该先把 .env 文件中的 APP_KEY 选项设置为 32 位随机字符串。如果没有适当地设置这个值，所有被 Lumen 加密的值都将是不安全的。 加密你可以使用 Crypt 门面来加密一个值。所有的加密值都使用 OpenSSL 和 AES-256-CBC 来进行加密。此外， 所有加密过的值都会使用消息认证码 (MAC)来进行签名，以检测加密字符串是否被篡改过 ： 1234567891011121314151617&lt;?phpnamespace App\\Http\\Controllers;use App\\User;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Crypt;class UserController extends Controller&#123; public function storeSecret(Request $request, $id) &#123; $user = User::findOrFail($id); $user-&gt;fill(['secret' =&gt; Crypt::encrypt($request-&gt;secret)])-&gt;save(); &#125;&#125; 解密当然，你可以使用 Crypt 门面的 decrypt 方法来解密值。如果该值不能够被正确的解密，例如当 MAC（消息认证码）无效时，就会抛出异常 Illuminate\\Contracts\\Encryption\\DecryptException ： 1234567use Illuminate\\Contracts\\Encryption\\DescryptException;try &#123; $decrypted = Crypt::decrypt($encryptedValue);&#125; catch (DecryptException $e) &#123; //&#125; 错误日志重写日志首先在bootstrap\\app.php中修改: 123$app = new App\\Application( realpath(__DIR__.'/../')); 然后再修改Application 123456789101112131415161718192021222324252627&lt;?php// Custom default or hard-coded behavior of lumen// @caoxlnamespace App;use Laravel\\Lumen\\Application as LumenBase;use Monolog\\Formatter\\LineFormatter;use Monolog\\Handler\\StreamHandler;use Monolog\\Logger;class Application extends LumenBase&#123; // Rewrite log handler protected function getMonologHandler() &#123; return ( new StreamHandler(storage_path(env( 'APP_LOG_PATH', 'logs/' . date('Y-m-d') . '.log' )), Logger::DEBUG )) -&gt;setFormatter(new LineFormatter(null, null, true, true)); &#125;&#125; 事件生成器Lumen 中没有可以用来生成事件和监听器的命令，你可以通过简单复制 ExampleEvent 或者 ExampleListener 文件来定义你自己的事件和监听器，这两个示例文件提供了每个事件和监听器的基础类结构。 注册事件或监听器像 Laravel 框架一样，Lumen 应用内置的 EventServiceProvider 提供了一个注册所有事件监听器的地方。 listen 属性是一个数组，它包含了所有的事件（键）和监听器（值）。所以，你可以根据应用程序的需要添加事件到这个数组： 12345protect $listen = [ 'App\\Events\\ExampleEvent' =&gt; [ 'App\\Listeners\\ExampleListener', ],]; 触发事件你可以使用 event 辅助函数或者 Event 门面在 Lumen 应用程序中触发事件。同样，这些函数的行为与 Laravel 框架一致： 123event(new ExampleEvent);Event::dispatch(new ExampleEvent); 队列Lumen 不包括用于自动创建新 Job 类的生成器。因此你需要复制框架所带的 ExampleJob 类。这个类提供了每个 Job 类共享的基本结构。 ExampleJob 所继承的 Job 基类已包含所需的 InteractsWithQueue、Queueable 和 SerializesModels trait： 123456789101112131415&lt;?phpnamespace App\\Jobs;class ExampleJob extends Job&#123; public function __construct() &#123; &#125; public function handle() &#123; &#125;&#125; 调度作业1dispatch(new ExampleJob); 当然，你也可以使用 Queue facade。如果你选择使用 facade，请务必在 bootstrap/app.php 文件中取消对 $app-&gt;withFacades() 调用的注释： 1Queue::push(new ExampleJob); 服务容器Laravel 的服务容器是一个管理类依赖和执行依赖注入的强力工具。依赖注入是个花俏的名词，事实上是指：类的依赖通过构造器或在某些情况下通过「setter」方法「注入」。 获取服务容器Laravel\\Lumen\\Application 实例是 Illuminate\\Container\\Container 的扩展，所以你可以当做服务容器来使用。 通常我们会在 服务提供者 注册我们的容器解析规则。 解析实例1$instance = app(Something::class); 服务提供者 服务提供者是所有 Lumen 应用程序启动的中心所在。包括你自己的应用程序，以及所有的 Lumen 核心服务，都是通过服务提供者启动的。 编写服务提供者所有的服务提供者都继承了 Illuminate\\Support\\ServiceProvider 这个类。这个抽象类要求你在你的提供者上定义至少一个方法：register。在 register 方法内，你应该 只需要将事物绑定到服务容器中。永远不要试图在 register 方法中注册任何事件侦听器、路由或任何其它功能。 注册方法12345678910111213141516&lt;?phpnamespace App\\Providers;use Tiak\\Connection;use Illuminate\\Support\\ServiceProvider;class RiakServiceProvider extends ServiceProvider&#123; public function register() &#123; $this-&gt;app-&gt;singelton(Connection::class, function ($app) &#123; return new Connection(config('riak')); &#125;); &#125;&#125; 启动方法此方法在所有其他服务提供者都注册之后才能调用，也就意味着可以访问已经被框架注册的所有服务： 12345678910111213141516&lt;?phpnamespace App\\Providers;use Queue;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider&#123; public function boot() &#123; Queue::failing(function ($event) &#123; &#125;); &#125; &#125; 注册服务提供者所有的服务提供者在 bootstrap/app.php 文件中被注册。这个文件中包含对 $app-&gt;register() 方法调用。你也可以额外的调用 $app-&gt;register() 来注册你的服务提供者。 测试测试环境在运行测试时，Lumen 自动配置讲缓存驱动配置为 array ，意味着在测试的时候不会保存任何的缓存数据。 你可以随意创建其他必要的测试配置环境。 testing 的环境变量可以在 phpunit.xml 文件中进行修改 定义和运行测试要创建一个测试用例，直接将新的测试文件创建到 tests 文件夹下即可。测试文件必须继承 TestCase 123456789&lt;?phpclass FooTest extends TestCase&#123; public function testSomethingIsTrue() &#123; $this-&gt;assertTrue(true); &#125;&#125; 数据验证表单请求Lumen 不支持表单请求。 如果想使用表单请求，则应使用完整的 Laravel 框架。 $this-&gt;validate 方法 12345678910use Illuminate\\Http\\Request;$router-&gt;post('/user', function (Request $request) &#123; $this-&gt;validate($request, [ 'name' =&gt; 'required', 'email' =&gt; 'required|email|unique:users' ]); // 存储用户...&#125;); exists 和 unique 规则 如果想要使用 exists 或 unique 验证规则，则应该在 bootstrap/app.php 文件中取消对 $app-&gt;withEloquent() 方法调用的注释。 视图变量 $errors","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Lumen 5.7","slug":"Lumen-5-7","permalink":"http://blog.caoxl.com/tags/Lumen-5-7/"}]},{"title":"PHP5.5 升级到 PHP7.2日志","slug":"Update-PHP5-5-To-PHP7-2-Notes","date":"2018-12-27T03:47:20.000Z","updated":"2018-12-27T10:11:18.000Z","comments":true,"path":"2018/12/27/Update-PHP5-5-To-PHP7-2-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/12/27/Update-PHP5-5-To-PHP7-2-Notes/","excerpt":"公司项目将从PHP5.5升级到PHP7.2, 正好抽空做下深入的学习.","text":"公司项目将从PHP5.5升级到PHP7.2, 正好抽空做下深入的学习. 升级到7.2后可用的主要新特性 支持使用表达式定义常量。如：const TWO = ONE * 2;【5.6+】 新增语法糖：使用 ... 运算符定义变长参数函数。如：function fn($a, $b = null, ...$params) {}【5.6+】 新增语法糖：使用 ... 运算符进行参数展开。类似 Ruby 中的连接运算符特性。【5.6+】 新增使用 ** 进行幂运算。如：printf(&quot;2 ** 3 == %d\\n&quot;, 2 ** 3);【5.6+】 扩展 use 运算符用以支持在类中导入外部的函数和常量。【5.6+】 SAPI 模块中实现了一个交互式调试器phpdbg。【5.6+】 支持 php://input 可以多次打开并读取。【5.6+】 支持大文件（大于 2GB）上传。【5.6+】 GMP 支持运算符重载。【5.6+】 新加 hash_equals() 比较字符串函数可避免时序攻击。【5.6+】 新增加 __debugInfo()，当使用 var_dump() 输出对象的时候， 可以用来控制要输出的属性和值。【5.6+】 新增 gost-crypto 散列算法。【5.6+】 对 SSL/TLS 的支持进行了大幅度的提升。【5.6+】 支持通过 define() 定义常量数组 【7.0+】 支持通过 new class 来实例化一个匿名类，这可以用来替代一些“用后即焚”的完整类定义。【7.0+】 新增的函数 intdiv() 用来进行整数的除法运算。 【7.0+】 支持标量类型声明（有两种模式: 强制 (默认) 和 严格模式）。如 function fn(int $a){}【7.0+】 支持返回值类型声明。如声明返回类型为array： function fn(int $a): array【7.0+】 新增null合并运算符语法糖。如：$username = $_GET[&#39;user&#39;] ?? &#39;nobody&#39;; 【7.0+】 新增太空船操作符（组合比较符）。如：echo 1 &lt;=&gt; 1; // 0【7.0+】 生成器可以返回表达式。【7.0+】 session_start() 可以接受一个 array 作为参数， 用来覆盖 php.ini 文件中设置的 会话配置选项。 【7.0+】 新增可使代码更简洁的 preg_replace_callback_array() 函数【7.0+】 允许在克隆表达式上访问对象成员，例如： (clone $foo)-&gt;bar()【7.0+】 新加入两个跨平台的函数：random_bytes() 和 random_int() 用来产生高安全级别的随机字符串和随机整数。【7.0+】 新增 IntlChar 类用于暴露出更多的 ICU 功能。这个类自身定义了许多静态方法用于操作多字符集的 unicode 字符。【7.0+】 放宽了保留词限制，允许全局保留词用于类/接口/Trait 中的属性、常量和方法名。 在引入新关键词时，此变更减少了对向后兼容的破坏，避免了 API 命名的限制。如：Project::new(&#39;Project Name&#39;)-&gt;private()-&gt;for(&#39;purpose here&#39;)-&gt;with(&#39;username here&#39;);// 之前是不可以的【7.0+】 可为空（Nullable）类型，参数以及返回值的类型现在可以通过在类型前加上一个问号使之允许为空。如：function fn(?string $name): ?string{}【7.1+】 新增返回值类型void。如：function swap(&amp;$left, &amp;$right) : void{}【7.1+】 短数组语法“[]”现在作为list()语法的一个备选项，可以用于将数组的值赋给一些变量（包括在foreach中）。如：[$id1, $name1] = $data[0]; foreach ($data as list($id, $name)) {}【7.1+】 新增支持设置类常量的可见性。如：public const A = 1;protected const B = 2;private const C = 3;【7.1+】 新引入 iterable 伪类 (与callable类似)。【7.1+】 新增多异常捕获处理语法糖。如：catch (FirstException | SecondException $e)【7.1+】 新增 list() 支持键名。如：list(&quot;id&quot; =&gt; $id1, &quot;name&quot; =&gt; $name1) = $data[0];【7.1+】 新增支持为负的字符串偏移量。如：&quot;abcdef&quot;[-2];strpos(&quot;aabbcc&quot;, &quot;b&quot;, -3);【7.1+】 新增 openssl 扩展支持 AEAD【7.1+】 新增 pcntl_async_signals() 信号处理函数。【7.1+】 新增 HTTP/2 server push support in ext/curl。【7.1+】 新增对象类型 object, 引进了可用于逆变（contravariant）参数输入和协变（covariant）返回任何对象类型。如：function fn(object $obj) : object{}【7.2+】 新增可通过名称加载扩展。【7.2+】 新增允许重写抽象方法(Abstract method) 【7.2+】 新增使用Argon2算法生成密码散列。【7.2+】 新增 PDO 扩展字符串扩展类型。【7.2+】 新增 LDAP 扩展支持新的操作方式。【7.2+】 sockets 扩展添加了地址信息。【7.2+】 支持允许分组命名空间的尾部逗号。如：use Foo\\Bar\\{Foo,Bar,Baz,};【7.2+】 主要不兼容函数列表 函数名 备注 ldap_sort() 7.0.0+已移除 xml_set_object() 7.0.0+为了避免内存泄露，该函数在执行结束时需要手动清除 $parse shmop_open() 7.0.0+现在返回一个资源而非一个int exec() &amp; system() &amp; passthru() 7.0.0+对 NULL 增加了保护 setlocale() 7.0.0+不再接受 category 传入字符串。 应当使用 LC_* 常量 preg_replace() 7.0.0+不再支持 “e” (PREG_REPLACE_EVAL). 应当使用 preg_replace_callback() 替代 mktime() &amp; gmmktime() 7.0.0+不再接受 is_dst 参数 imagepsbbox() 7.0.0+已移除 imagepsencodefont() 7.0.0+已移除 imagepsextendfont() 7.0.0+已移除 imagepsfreefont() 7.0.0+已移除 imagepsloadfont() 7.0.0+已移除 imagepsslantfont() 7.0.0+已移除 imagepstext() 7.0.0+已移除 dl() 7.0.0+在PHP-FPM模式下已移除 set_magic_quotes_runtime() 7.0.0+已移除 magic_quotes_runtime() 7.0.0+已移除 set_socket_blocking() 7.0.0+已移除 mcrypt_generic_end() 7.0.0+已移除 mcrypt_ecb() 7.0.0+已移除 mcrypt_cbc() 7.0.0+已移除 mcrypt_cfb() 7.0.0+已移除 mcrypt_ofb() 7.0.0+已移除 call_user_method() 7.0.0+已移除 call_user_method_array() 7.0.0+已移除 ereg* 系列函数 7.0.0+已移除，建议使用PCRE系列函数代替 __autoload() 7.2.0+已移除 assert() 7.2.0+废弃了字符串的 assert()，最好提供 bool 的表达式 png2wbmp() 和 jpeg2wbmp() 7.2.0+已移除 create_function() 7.2.0+已移除 parse_str() 7.2.0+需要加第二个参数成为必选项 each() 7.2.0+已移除 gmp_random() 7.2.0+已移除 read_exif_data() 7.2.0+已移除，使用 exif_read_data() 代替 其他主要不兼容点 【5.6.x+】cURL 文件上传 必须先设置 CURLOPT_SAFE_UPLOAD 为 FALSE 才能够使用 @file 语法来上传文件。 建议使用 CURLFile 类来上传文件。 【5.6.x+】更严格的 json_decode() 对于 JSON 字面量 true，false 和 null，如果不采用小写格式，将会被 json_decode() 函数拒绝， 同时相应的设置 json_last_error()。在之前的版本中，json_decode() 函数可以接受这些字面量的 全部大写或者大小写混写的格式。 此变更仅会影响传入到 json_decode() 中的 JSON 格式无效的情况， 有效的 JSON 输入不会受到影响并且能够正确解析。 【5.6.x+】使用数组标识符为类定义数组类型的属性时，数组的键不会被覆盖 在 PHP 5.6 之前的版本中，为类定义数组类型的属性时，如果数组中同时使用了显式数组键和隐式数组键，并且显式的键和隐式的序列键相同，那么数组的键将被覆盖。如： 1234567891011&lt;?phpclass C &#123; const ONE = 1; public $array = [ self::ONE =&gt; 'foo', 'bar', 'foobar', ];&#125;var_dump((new C)-&gt;array); 【5.6.x+】从不兼容的上下文调用方法 已废止从不兼容的上下文调用方法，并且产生 E_DEPRECATED 错误 （以前是 E_STRICT）。在 PHP 的后续版本中可能彻底移除对此特性的支持。 【5.6.x+】$HTTP_RAW_POST_DATA 和 always_populate_raw_post_data 使用 always_populate_raw_post_data 会导致在填充 $HTTP_RAW_POST_DATA 时产生 E_DEPRECATED 错误请使用 php://input 替代 $HTTP_RAW_POST_DATA， 因为它可能在后续的 PHP 版本中被移除。设置 always_populate_raw_post_data 为 -1 （这样会强制 $HTTP_RAW_POST_DATA 未定义，所以也不会导致 E_DEPRECATED 的错误） 来体验新的行为。 【5.6.x+】iconv 和 mbstring 编码设置 iconv 和 mbstring 配置选项中 和编码相关的选项都已废弃， 请使用 default_charset。 废弃的选项有： 123456iconv.input_encodingiconv.output_encodingiconv.internal_encodingmbstring.http_inputmbstring.http_outputmbstring.internal_encoding 【7.0.x+】错误和异常处理相关的变更 在 PHP 7 中，很多致命错误以及可恢复的致命错误，都被转换为异常来处理了。 这些异常继承自 Error 类，此类实现了 Throwable 接口 （所有异常都实现了这个基础接口）。 这也意味着，当发生错误的时候，以前代码中的一些错误处理的代码将无法被触发。 因为在 PHP 7 版本中，已经使用抛出异常的错误处理机制了。 （如果代码中没有捕获 Error 异常，那么会引发致命错误）。 1) set_exception_handler() 不再保证收到的一定是 Exception 对象： 抛出 Error 对象时，如果 set_exception_handler() 里的异常处理代码声明了类型 Exception ，将会导致 fatal error。 想要异常处理器同时支持 PHP5 和 PHP7，应该删掉异常处理器里的类型声明。如果代码仅仅是升级到 PHP7，则可以把类型 Exception 替换成 Throwable。 12345678910&lt;?php// PHP 5 时代的代码将会出现问题function handler(Exception $e) &#123; ... &#125;set_exception_handler('handler');// 兼容 PHP 5 和 7function handler($e) &#123; ... &#125;// 仅支持 PHP 7function handler(Throwable $e) &#123; ... &#125; 2) 当内部构造器失败的时候，总是抛出异常： 在之前版本中，如果内部类的构造器出错，会返回 NULL 或者一个不可用的对象。 从 PHP 7 开始，如果内部类构造器发生错误， 那么会抛出异常。 3) 解析错误会抛出 ParseError 异常： 解析错误会抛出 ParseError 异常。 对于 eval() 函数，需要将其包含到一个 catch 代码块中来处理解析错误。 4) E_STRICT 警告级别变更： 原有的 E_STRICT 警告都被迁移到其他级别。 E_STRICT 常量会被保留，所以调用 error_reporting(E_ALL|E_STRICT) 不会引发错误。 场景 新的级别/行为 将资源类型的变量用作键来进行索引 E_NOTICE 抽象静态方法 不再警告，会引发错误 重复定义构造器函数 不再警告，会引发错误 在继承的时候，方法签名不匹配 E_WARNING 在两个 trait 中包含相同的（兼容的）属性 不再警告，会引发错误 以非静态调用的方式访问静态属性 E_NOTICE 变量应该以引用的方式赋值 E_NOTICE 变量应该以引用的方式传递（到函数参数中） E_NOTICE 以静态方式调用实例方法 E_DEPRECATED 【7.0.x+】关于变量处理的变化 PHP 7 现在使用了抽象语法树来解析源代码。这为语言带来了许多改进，由于之前的 PHP 的解释器的限制所不可能实现的但出于一致性的原因导致了一些特殊例子的变动，而这些变动打破了向后兼容。 1) 关于间接使用变量、属性和方法的变化： 对变量、属性和方法的间接调用现在将严格遵循从左到右的顺序来解析，而不是之前的混杂着几个特殊案例的情况。 下面这张表说明了这个解析顺序的变化。 表达式 PHP5的解析方式 PHP7的解析方式 $$foo&#39;bar&#39; ${$foo&#39;bar&#39;} ($$foo)&#39;bar&#39; $foo-&gt;$bar[&#39;baz&#39;] $foo-&gt;{$bar[&#39;baz&#39;]} ($foo-&gt;$bar)[&#39;baz&#39;] $foo-&gt;$bar[&#39;baz&#39;]() $foo-&gt;{$bar[&#39;baz&#39;]}() ($foo-&gt;$bar)[&#39;baz&#39;]() Foo::$bar[&#39;baz&#39;]() Foo::{$bar[&#39;baz&#39;]}() (Foo::$bar)[&#39;baz&#39;]() 2) list() 不再以反向的顺序来进行赋值： list() 现在会按照变量定义的顺序来给他们进行赋值，而非反过来的顺序。 通常来说，这只会影响list() 与数组的[]操作符一起使用的案例，如下所示： 12345&lt;?phplist($a[], $a[], $a[]) = [1, 2, 3];var_dump($a);// php5 -&gt; [3, 2, 1]// php7 -&gt; [1, 2, 3] 3) 空的list()赋值支持已经被移除： list() 结构现在不再能是空的。如下的例子不再被允许： 1234&lt;?phplist() = $a;list(,,) = $a;list($x, list(), $y) = $a; 4) list()不再能解开string： list() 不再能解开字符串（string）变量。可以使用str_split()来代替。 5) global 只接受简单变量： 可变变量不再能够与 global 关键字一起使用。 如果需要的话可以使用圆括号来模拟之前的行为。 12345678&lt;?phpfunction f() &#123; // Valid in PHP 5 only. global $$foo-&gt;bar; // Valid in PHP 5 and 7. global $&#123;$foo-&gt;bar&#125;;&#125; 作为一个通用的准则，global 一个除了裸的变量以外的任何东西都是不被推荐的。 【7.0.x+】foreach的变化 【7.0.x+】foreach发生了细微的变化，控制结构， 主要围绕阵列的内部数组指针和迭代处理的修改。 1) foreach不再改变内部数组指针： 在PHP7之前，当数组通过 foreach 迭代时，数组指针会移动。现在开始，不再如此，如： 123456$array = [0, 1, 2];foreach ($array as &amp;$val) &#123; var_dump(current($array));&#125;// php7 下会打印3次：int(0)，而 php5 会打印：int(0), int(1), int(2) 2) foreach 通过值遍历时，操作的值为数组的副本： 当默认使用通过值遍历数组时，foreach 实际操作的是数组的迭代副本，而非数组本身。这就意味着，foreach 中的操作不会修改原数组的值。 3) foreach通过引用遍历时，有更好的迭代特性： 当使用引用遍历数组时，现在 foreach 在迭代中能更好的跟踪变化。例如，在迭代中添加一个迭代值到数组中，如： 1234567&lt;?php$array = [0];foreach ($array as &amp;$val) &#123; var_dump($val); $array[1] = 1;&#125;// php5 输出 int(0)，php7 输出：int(0), int(1) 4) 非Traversable 对象的遍历： 迭代一个非Traversable对象将会与迭代一个引用数组的行为相同。 这将导致在对象添加或删除属性时，foreach通过引用遍历时，有更好的迭代特性也能被应用 【7.0.x+】new 操作符创建的对象不能以引用方式赋值给变量 new 语句创建的对象不能 以引用的方式赋值给变量。 12345&lt;?phpclass C &#123;&#125;$c =&amp; new C;// php5: Deprecated: Assigning the return value of new by reference is deprecated in /tmp/test.php on line 3// php7: Parse error: syntax error, unexpected 'new' (T_NEW) in /tmp/test.php on line 3 【7.0.x+】无效的类、接口以及 trait 命名 不能以下列名字来命名类、接口以及 trait： 1234567boolintfloatstringNULLTRUEFALSE 此外，也不要使用下列的名字来命名类、接口以及 trait。虽然在 PHP 7.0 中， 这并不会引发错误， 但是这些名字是保留给将来使用的。 1234resourceobjectmixednumeric 【7.0.x+】移除了 ASP 和 script PHP 标签 使用类似 ASP 的标签，以及 script 标签来区分 PHP 代码的方式被移除。受到影响的标签有： 123&lt;% %&gt;&lt;%= %&gt;&lt;script language=\"php\"&gt; &lt;/script&gt; 【7.0.x+】string处理上的调整 十六进制字符串不再被认为是数字。如：is_numeric(&quot;0x123&quot;); // false 【7.0.x+】yield 变更为右联接运算符 在使用 yield 关键字的时候，不再需要括号， 并且它变更为右联接操作符，其运算符优先级介于 print 和 =&gt; 之间。 这可能导致现有代码的行为发生改变： 123456789101112&lt;?phpecho yield -1;// 在之前版本中会被解释为：echo (yield) - 1;// 现在，它将被解释为：echo yield (-1);yield $foo or die;// 在之前版本中会被解释为：yield ($foo or die);// 现在，它将被解释为：(yield $foo) or die; 可以通过使用括号来消除歧义 【7.0.x+】函数定义不可以包含多个同名参数 在函数定义中，不可以包含两个或多个同名的参数。 例如，下面代码中的函数定义会触发 E_COMPILE_ERROR 错误： 1234&lt;?phpfunction foo($a, $b, $unused, $unused) &#123; //&#125; 【7.0.x+】Switch 语句不可以包含多个 default 块 在 switch 语句中，两个或者多个 default 块的代码已经不再被支持。 例如，下面代码中的 switch 语句会触发 E_COMPILE_ERROR 错误： 1234567&lt;?phpswitch (1) &#123; default: break; default: break;&#125; 【7.0.x+】在函数中检视参数值会返回当前的值 当在函数代码中使用 func_get_arg() 或 func_get_args() 函数来检视参数值， 或者使用 debug_backtrace() 函数查看回溯跟踪， 以及在异常回溯中所报告的参数值是指参数当前的值（有可能是已经被函数内的代码改变过的值）， 而不再是参数被传入函数时候的原始值了。 1234567&lt;?phpfunction foo($x) &#123; $x++; var_dump(func_get_arg(0));&#125;foo(1);?&gt;// php5 -&gt; 1; php7 -&gt; 2 【7.0.x+】$HTTP_RAW_POST_DATA 被移除 不再提供 $HTTP_RAW_POST_DATA 变量。 使用 php://input 作为替代。 【7.0.x+】INI 文件中 # 注释格式被移除 在 INI 文件中，不再支持以 # 开始的注释行，使用 ;（分号）来表示注释。此变更适用于 php.ini 以及用 parse_ini_file() 和 parse_ini_string() 函数来处理的文件。 【7.0.x+】JSON 扩展已经被 JSOND 取代 JSON 扩展已经被 JSOND 扩展取代。 对于数值的处理，有以下两点需要注意的：第一，数值不能以点号（.）结束 （例如，数值 34. 必须写作 34.0 或 34）。第二，如果使用科学计数法表示数值，e 前面必须不是点号（.） （例如，3.e3 必须写作 3.0e3 或 3e3）。另外，空字符串不再被视作有效的 JSON 字符串。 【7.0.x+】在数值溢出的时候，内部函数将会失败 将浮点数转换为整数的时候，如果浮点数值太大，导致无法以整数表达的情况下，在之前的版本中，内部函数会直接将整数截断，并不会引发错误。在 PHP 7.0 中，如果发生这种情况，会引发 E_WARNING 错误，并且返回 NULL。 【7.0.x+】自定义会话处理器的返回值修复 在自定义会话处理器中，如果函数的返回值不是 FALSE，也不是 -1， 会引发致命错误。现在，如果这些函数的返回值不是布尔值，也不是 -1 或者 0，函数调用结果将被视为失败，并且引发 E_WARNING 错误。 【7.0.x+】相等的元素在排序时的顺序问题 由于内部排序算法进行了提升， 可能会导致对比时被视为相等的多个元素之间的顺序不稳定。 在对比时被视为相等的多个元素之间的排序顺序是不可信赖的，即使是相等的两个元素， 他们的位置也可能被排序算法所改变。 【7.0.x+】PHP4 风格的构造函数 PHP4 风格的构造函数（方法名和类名一样）将被弃用，并在将来移除。 如果在类中仅使用了 PHP4 风格的构造函数，PHP7 会产生 E_DEPRECATED 警告。 如果还定义了 __construct() 方法则不受影响。 【7.0.x+】静态调用非静态的方法 废弃了静态（Static）调用未声明成 static 的方法，未来可能会彻底移除该功能。 【7.0.x+】password_hash() 盐值选项 废弃了 password_hash() 函数中的盐值选项，阻止开发者生成自己的盐值（通常更不安全）。开发者不传该值时，该函数自己会生成密码学安全的盐值。因此再无必要传入自己自定义的盐值。 【7.0.x+】capture_session_meta SSL 上下文选项 废弃了 capture_session_meta 内的 SSL 上下文选项。 现在可以通过 stream_get_meta_data() 获取 SSL 元数据（metadata）。 【7.1.x+】当传递参数过少时将抛出错误 在过去如果我们调用一个用户定义的函数时，提供的参数不足，那么将会产生一个警告(warning)。现在，这个警告被提升为一个错误异常(Error exception)。这个变更仅对用户定义的函数生效， 并不包含内置函数。 【7.1.x+】call_user_func()不再支持对传址的函数的调用 call_user_func() 现在在调用一个以引用作为参数的函数时将始终失败。 【7.1.x+】ini选项移除 移除了以下ini选项： 1234session.entropy_filesession.entropy_lengthsession.hash_functionsession.hash_bits_per_character 【7.1.x+】mcrypt扩展 mcrypt 扩展已经过时了大约10年，并且用起来很复杂。因此它被废弃并且被 OpenSSL 所取代。 从PHP 7.2起它将被从核心代码中移除并且移到PECL中。 【7.1.x+】mb_ereg_replace()和mb_eregi_replace()的Eval选项 对于mb_ereg_replace()和mb_eregi_replace()的 e模式修饰符现在已被废弃。 【7.1.x+】不带引号的字符串 不带引号的字符串是不存在的全局常量，转化成他们自身的字符串。 在以前，该行为会产生 E_NOTICE，但现在会产生 E_WARNING。在下一个 PHP 主版本中，将抛出 Error 异常。 【7.1.x+】禁止对自我检查范围的函数进行动态调用 涉及的函数有： 123456789assert() - with a string as the first argumentcompact()extract()func_get_args()func_get_arg()func_num_args()get_defined_vars()mb_parse_str() - with one argparse_str() - with one arg 1234&lt;?php(function () &#123; 'func_num_args'(); // Warning: Cannot call func_num_args() dynamically in %s on line %d&#125;)(); 兼容性检测工具 PHP7 兼容性检测工具 php7cc： 参考 php5.5 升级到 php7.2","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP5.5","slug":"PHP5-5","permalink":"http://blog.caoxl.com/tags/PHP5-5/"},{"name":"PHP7.2","slug":"PHP7-2","permalink":"http://blog.caoxl.com/tags/PHP7-2/"}]},{"title":"Yaf 学习日志","slug":"Yaf-Notes","date":"2018-12-14T03:09:58.000Z","updated":"2019-08-22T03:38:28.000Z","comments":true,"path":"2018/12/14/Yaf-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/12/14/Yaf-Notes/","excerpt":"Yaf: Yet Another Framework","text":"Yaf: Yet Another Framework PHP.net: Yet Another Framework鸟哥中文文档: Yaf(Yet Another Framework)用户手册 Yaf的优点 天下武功无坚不破，唯快不破 安装/使用 它是通过一个扩展的方式来实现的，我们可以去pecl.php.net去搜索Yaf这个扩展，我们也可以直接到&quot;http://pecl.php.net/package/yaf&quot;这里进行访问. 对应自己的系统安装即可: 带beta的是测试版, 带stable版的是稳定版.跟着这个走即可 安装教程 代码生成工具 Yaf Codes Generator 12345678// 1.下载源码包git clone https://github.com/laruence/yaf.git php-yaf// 2.执行代码生成工具./php-yaf/tools/cg/yaf_cg yaf-sample// 3.拷贝生成的代码到自己项目cd ./php-yaf/tools/cg/output/yaf-sample 快速入门12345678910111213141516171819/----public 公共目录 | |-------index.php 入口文件 | |-------css 样式目录 | |-------img 图片目录 | |-------js 脚本目录 | |----conf 配置目录 | |-------app.ini/application.ini 应用程序配置 | |----app/application 应用程序目录 | |------controllers 控制器目录 | |------views 视图目录 | |------models 模型目录 | |------modules 模块目录 | |------library 类库目录 | |------plugins 插件目录 | |------Bootstrap.php 引导文件 | |----.htaccess 重写文件 #Apache环境下需要, Nginx不需要 入口文件 index.php 12345678910&lt;?php//定义应用目录define(\"APP_PATH\", realpath(dirname(__FILE__).'/../'));//导入配置文件$app = new Yaf_Application(APP_PATH . \"/conf/app.ini\");//运行程序echo $app-&gt;bootstrap()-&gt;run(); 改进版入口文件 123456789101112131415161718192021&lt;?php// 应用入口文件date_default_timezone_set(\"Asia/Shanghai\");if (!defined('__ROOT__')) &#123; $_root = rtrim(dirname(rtrim($_SERVER['SCRIPT_NAME'], '/')), '/'); define('__ROOT__', (('/' == $_root || '\\\\' == $_root) ? '' : $_root));&#125;//定义应用目录define(\"APP_PATH\", realpath(dirname(__FILE__).'/../'));//开发环境 product:线上环境；dev:线下开发环境 test:测试环境define('APP_ENV', 'dev');//导入配置文件$app = new Yaf_Application(APP_PATH . \"/conf/app.ini\", APP_ENV);//启动应用echo $app-&gt;bootstrap()-&gt;run(); 配置文件 app.ini 或者application.ini, 基于你的入口文件 1234567[common];支持直接写PHP中的已定义变量application.directory = APP_PATH \"/app\"application.dispatcher.catchException = true[dev : common];yaf.environ = dev #区分本地、测试和线上的（dev、test、product） 控制器 文件名为Index.php，它的首字母是需要大写的，而且该文件中的控制器的类名必须有Controller后缀，而且去掉后缀后的部分要和文件名保持一直，而且这个类必须继承自Yaf_Controller_Abstract，而且它里面的所有的动作都必须使用Action后缀。 123456789101112131415161718192021222324252627282930&lt;?php/** * @name IndexController * @author Administrator * @desc 默认控制器 * @see http://www.php.net/manual/en/class.yaf-controller-abstract.php */class IndexController extends Yaf_Controller_Abstract&#123; /** * 默认动作 * Yaf支持直接把Yaf_Request_Abstract::getParam()得到的同名参数作为Action的形参 * 对于如下的例子, 当访问http://yaf.test/index/index/index/name/Administrator 的时候, 你就会发现不同 */ public function indexAction($name = \"caoxl\") &#123; //1. fetch query $get = $this-&gt;getRequest()-&gt;getQuery(\"get\", \"default value\"); //2. fetch model $model = new SampleModel(); //3. assign $this-&gt;getView()-&gt;assign(\"content\", $model-&gt;selectSample()); $this-&gt;getView()-&gt;assign(\"name\", $name); //4. render by Yaf, 如果这里返回FALSE, Yaf将不会调用自动视图引擎Render模板 return TRUE; &#125;&#125; 控制器须知 每个控制器都需要继承自Yaf_Controller_Abstract这个类，它是所有控制器的父类。 控制器中的动作都需要加Action后缀，比如indexAction，比如readAction等等。 需要特殊说明的是，控制器是默认渲染模板的，我们可以通过如下语句来暂时屏蔽这一功能: 1Yaf_Dispatcher::getInstance()-&gt;disableView(); 例如: 1234567891011&lt;?phpclass StarController extends Yaf_Controller_Abstract&#123; // http://yaf.test/star/star public function starAction() &#123; Yaf_Dispatcher::getInstance()-&gt;disableView(); echo \"当学习成为一种习惯，进步就是一种必然;\"; &#125;&#125; 访问: http://yaf.test/star/star输出: 当学习成为一种习惯，进步就是一种必然; 还可以在控制器中定义init()方法，它会在每个动作执行之前执行 1234567891011121314151617&lt;?phpclass GoController extends Yaf_Controller_Abstract&#123; public function init() &#123; // 禁止渲染视图 Yaf_Dispatcher::getInstance()-&gt;disableView(); echo \"来自init()方法&lt;br&gt;\"; &#125; // http://yaf.test/go/show public function showAction() &#123; echo \"当学习成为一种习惯，进步就是一种必然;\"; &#125;&#125; 在url中使用”控制器/动作名/参数名1/参数值1/参数名2/参数值2…”的格式来请求即可传递参数 123456789101112131415161718192021222324252627282930&lt;?phpclass ParamsController extends Yaf_Controller_Abstract&#123; public function init() &#123; // 禁止渲染视图 Yaf_Dispatcher::getInstance()-&gt;disableView(); &#125; // http://yaf.test/params/testParams/name/caoxl/aim/No.1 public function testParamsAction($name, $aim) &#123; //输出名字 echo \"您的名字是:\".$name.\"&lt;br/&gt;\"; //输出目标 echo \"您的目标是:\".$aim; &#125; // http://yaf.test/params/ask/ask/who/answer/me public function askAction() &#123; // 获取参数 $ask = $this-&gt;getRequest()-&gt;getParam('ask'); $answer = $this-&gt;getRequest()-&gt;getParam('answer'); echo \"您问的问题是:\".$ask.\"&lt;br/&gt;\"; echo \"您给的答案是:\".$answer.\"&lt;br/&gt;\"; &#125;&#125; 视图 我们在views目录下新建一个index目录，这个目录中对应的是我们的IndexController，该目录下的所有视图文件都是和这个控制器有关系的。然后在index目录中新建一个index.phtml文件，它对应的是indexAction。需要说明的是，这个后缀默认应该是phtml 123&lt;?phpecho $content, \" I am \", $name; 视图须知 控制器赋值 123456789101112131415&lt;?phpclass TestController extends Yaf_Controller_Abstract&#123; public function indexAction() &#123; $msg = array( 'wife' =&gt; '梁超', 'job' =&gt; 'PHP' ); $view = $this-&gt;getView(); $view-&gt;assign('name', '曹贤亮'); $view-&gt;assign('msg', $msg); &#125;&#125; 视图渲染 我们在views目录下新建一个test目录，然后在里面创建一个index.phtml文件，然后我们写入如下内容: 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;?php echo $name;?&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;您的姓名是:&lt;?=$name?&gt;&lt;/p&gt;&lt;p&gt;您喜欢的人:&lt;?=$msg[\"wife\"]?&gt;&lt;/p&gt;&lt;p&gt;您的职位是:&lt;?=$msg[\"job\"]?&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 模型123456789101112131415161718192021222324&lt;?php/** * @name SampleModel * @desc sample数据获取类, 可以访问数据库，文件，其它系统等 * @author caoxl */class SampleModel&#123; public function __construct() &#123; &#125; public function selectSample() &#123; return \"Hello Yaf!\"; &#125; public function insertSample($arr) &#123; return true; &#125;&#125; 访问: http://yaf.test/index/index输出: Hello Yaf! I am caoxl 引导文件 Bootstrap.php 我们在app目录下，可以加一个Bootstrap.php文件，该文件会在执行控制器之前执行，而且通常我们在该文件中创建一个Bootstrap类，继承自Yaf_Bootstrap_Abstract类，而且该类中带有”_init”前缀的方法都会被自动执行。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** * @name Bootstrap * @author caoxl * @desc 所有在Bootstrap类中, 以_init开头的方法, 都会被Yaf调用, * @see http://www.php.net/manual/en/class.yaf-bootstrap-abstract.php * 这些方法, 都接受一个参数:Yaf_Dispatcher $dispatcher * 调用的次序, 和申明的次序相同 */class Bootstrap extends Yaf_Bootstrap_Abstract&#123; public function _initConfig() &#123; //禁用视图 //Yaf_Dispatcher::getInstance()-&gt;disableView(); //保存配置 $arrConfig = Yaf_Application::app()-&gt;getConfig(); Yaf_Registry::set('config', $arrConfig); &#125; public function _initPlugin(Yaf_Dispatcher $dispatcher) &#123; // 注册插件 $objSamplePlugin = new SamplePlugin(); $dispatcher-&gt;registerPlugin($objSamplePlugin); &#125; public function _initRoute(Yaf_Dispatcher $dispatcher) &#123; // TODO 注册路由协议 &#125; public function _initView(Yaf_Dispatcher $dispatcher) &#123; // TODO 注册View &#125;&#125; 不过想让它真正的发挥作用，我们还需要在入口文件中调用bootstrap()方法，即我们的入口文件的代码这么写: 12345678910&lt;?php//定义应用目录define(\"APP_PATH\", realpath(dirname(__FILE__).'/../'));//导入配置文件$app = new Yaf_Application(APP_PATH . \"/conf/app.ini\");//运行程序echo $app-&gt;bootstrap()-&gt;run(); 配置 我们必须在Yaf_Application初始化的时候给出配置文件中的配置，其中Yaf的必不可少的配置项只有一个，那就是application.directory，它表示当前应用程序的绝对路径。 12345[common]application.directory = APP_PATH \"/app\"[dev : common];yaf.environ = dev #区分本地、测试和线上的（dev、test、product） 其实这个配置项也可以没有，至少从框架层面上做到了”零配置”，但是鸟哥认为，如果一个配置项都没有，就显得太寒酸了，于是就加了这么一个配置项。 除了那个必选的配置项之外，我们还有若干的可选配置项，这些配置项我们都可以在conf目录下的app.ini文件中进行定义。 application.ext是php脚本的扩展名，它的值默认为php，之所以会有这个配置项，是因为很早很早之前，我们也使用”php3”和”php4”作为后缀名，但是现在的文件我们一般都是使用”php”作为后缀名的，因此这个配置项可以忽略 application.bootstrap是bootstrap文件的绝对路径，也就是我们上面介绍的引导文件，它通常是在Yaf_Application实例化之后，我们调用它的bootstrap()方法来进行初始化设置。 application.library是本地类库的绝对路径地址，它的默认值为应用程序目录下的library目录，该目录下的类库会被自动加载。 application.baseUri是我们在路由中，需要忽略的路径前缀，默认值为空，一般不需要设置，Yaf会自动判断。 application.dispatcher.defaultModule是默认的模块名，默认为index。 application.dispatcher.throwException是在出错的时候是否抛出异常，默认值为True，表示抛出异常。 application.dispatcher.catchException是捕获异常用的，我们一般使用ErrorController的errorAction()来处理这个异常，我们可以通过$request-&gt;getException()来获取异常对象。 application.dispatcher.defaultController是默认的控制器，默认为index。 application.dispatcher.defaultAction是默认的动作，默认为index。 application.view.ext是视图模板扩展名，默认为phtml。 application.modules是存在的模块名，如果我们要定义这个值的话，一定要定义Index模块，默认为Index。 读取配置1234567891011121314&lt;?phpclass ConfController extends Yaf_Controller_Abstract&#123; public function showAction() &#123; $path = APP_PATH . \"/conf/test.ini\"; $config = new Yaf_Config_ini($path); //输出信息 这里test ==&gt; test.ini/[test] echo \"您的姓名是:\".$config-&gt;test-&gt;name.\"&lt;br/&gt;\"; echo \"您喜欢的是:\".$config-&gt;test-&gt;love; &#125;&#125; 其他配置 app.ini 1234567891011121314151617181920212223#公共配置[common]application.directory = APP_PATH \"/app\"application.library.directory = APP_PATH \"/library\"application.dispatcher.throwException = TRUEapplication.dispatcher.catchException = TRUE#多个模块，使用逗号分隔application.modules = Index,Api,Adminapplication.view.ext = \"phtml\"#日志目录log_path = APP_PATH \"/runtime/logs\";yaf.environ = dev #区分本地、测试和线上的（dev、test、product）;开发配置[dev : common];测试配置[test : common];线上配置[product : common] db.ini 1234567891011121314151617181920212223242526272829303132333435363738394041[common];数据库配置db.type = \"mysql\"db.dsn = \"\"db.hostport = \"3306\"db.charset = \"utf8\";数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)db.deploy = 0;数据库读写是否分类 主从式有效db.rw_separate = false;读写分离后主服务器数量db.master_num = 1;指定从服务器序号db.slave_no = \"\";是否严格检查字段是否存在db.fields_strict = true;数据集返回类型db.resultset_type = 'array';自动写入时间戳字段db.auto_timestamp = false;时间字段取出后的默认时间格式db.datetime_format = 'Y-m-d H:i:s'db.sql_explain = false;线上配置[product : common];是否需要进行SQL性能分析db.sql_explain = falsedb.debug = false;开发配置[dev : common]db.hostname = \"127.0.0.1\"db.database = \"yaf\"db.username = \"root\"db.password = \"root\";是否需要进行SQL性能分析db.sql_explain = truedb.debug = truedb.prefix = \"yaf_\" rest.ini 12345678910111213141516171819202122[common];CORS 跨域设置 Access-Control-Allow-Origin设置;['']空，不允许跨站请求;['*']允许所有域名不限制来源;;['http://www.xx.com']允许www.xx.com的跨域请求;允许多个域名用[,]隔开;开发环境和生产环境可以用不同配置cors.Access-Control-Allow-Origin = '*';cors.Access-Control-Allow-Credentials = 'false' ;是否允许跨域使用cookie,'true'允许,false禁止cors.Access-Control-Allow-Headers = 'x-requested-with,accept,content-type,session-id,token,sessionId,Origin'cors.Access-Control-Allow-Methods = 'GET,POST,PUT,DELETE,OPTIONS'cors.Access-Control-Max-Age = 2592000;REST 响应设置rest.param = 'id' ;id形默认绑定参数 如 /User/123 =&gt;绑定参数$id值为123rest.action = 'info' ;默认绑定控制器如 /User/123 =&gt;绑定到 infoActionrest.none = '_404' ;请求action不存在时调用控制器默认_404Actionrest.status = 'err' ;返回数据的状态码字段rest.data = 'dat' ;返回数据的数据字段rest.msg = 'msg' ;返回数据的提示信息rest.error = -1 ;错误状态码rest.json = JSON_NUMERIC_CHECK|JSON_UNESCAPED_UNICODE|JSON_UNESCAPED_SLASHES; 类库加载 默认来说，类库的目录是app目录下的library目录 比如我们在app目录下新建一个library目录，然后我们在改目录中新建一个Tool.php文件，然后我们在里面书写如下代码: 123456789&lt;?phpclass Tool&#123; public function run() &#123; echo \"运行Tool类的run方法\"; &#125;&#125; 那么我们在我们的控制器中就可以这么写: 12345678910&lt;?phpclass ToolController extends Yaf_Controller_Abstract&#123; public function indexAction() &#123; $tool = new Tool(); $tool-&gt;run(); &#125;&#125; 插件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php/** * @name SamplePlugin * @desc Yaf定义了如下的6个Hook,插件之间的执行顺序是先进先Call * @see http://www.php.net/manual/en/class.yaf-plugin-abstract.php * @author caoxl */class SamplePlugin extends Yaf_Plugin_Abstract&#123; // 在路由之前触发 public function routerStartup(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) &#123; &#125; // 路由结束之后触发 public function routerShutdown(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) &#123; &#125; // 分发循环开始之前被触发 public function dispatchLoopStartup(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) &#123; &#125; // 分发之前触发 public function preDispatch(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) &#123; &#125; // 分发结束之后触发 public function postDispatch(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) &#123; &#125; // 分发循环结束之后触发 public function dispatchLoopShutdown(Yaf_Request_Abstract $request, Yaf_Response_Abstract $response) &#123; &#125;&#125; 数据库 这里可以参考thinkyaf 参考 Yaf教程","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Yaf","slug":"Yaf","permalink":"http://blog.caoxl.com/tags/Yaf/"}]},{"title":"Python3 入门笔记","slug":"Python-Learning-Notes","date":"2018-12-06T03:26:00.000Z","updated":"2019-08-22T06:31:33.000Z","comments":true,"path":"2018/12/06/Python-Learning-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/12/06/Python-Learning-Notes/","excerpt":"Python: https://www.python.org/没有别的原因, 就是想系统的学习一下Python. 该分类持续更新.","text":"Python: https://www.python.org/没有别的原因, 就是想系统的学习一下Python. 该分类持续更新. 安装Python当我们编写Python代码时，我们得到的是一个包含Python代码的以.py为扩展名的文本文件。要运行代码，就需要Python解释器去执行.py文件。 CPython 当我们从Python官方网站下载并安装好Python 3.x后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行python就是启动CPython解释器。 安装步骤: 12345wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgztar -zxvf Python-3.7.1.tgzcd Python-3.7.1./configure --prefix=/usr/local/python3make &amp;&amp; make install 搭建开发环境12[root@caoxl python]# python3 --versionPython 3.7.1 用pip安装开发Web App需要的第三方库： 异步框架aiohttp： 1[root@caoxl python]# pip3 install aiohttp 前端模板引擎jinja2： 1[root@caoxl python]# pip3 install jinja2 MySQL的Python异步驱动程序aiomysql： 1 Python3 基础语法代码结构:123#!/usr/bin/python3#coding: UTF-8print('Hello World') 编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码： 1# -*- coding: cp-1252 -*- python保留字1234567[root@caoxl python]# python3Python 3.7.1 (default, Dec 6 2018, 12:39:22) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType \"help\", \"copyright\", \"credits\" or \"license\" for more information.&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 如何注释?1234567891011121314#!/usr/bin/python3#coding: UTF-8# 第一个注释print('Hello World') # 第二个注释''' 第三个注释'''\"\"\" 第四个注释\"\"\" 行与缩进python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。 缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下： 123456if True: print (\"Answer\") print (\"True\")else: print (\"Answer\") print (\"False\") # 缩进不一致，会导致运行错误 字符串1234567891011121314151617#!/usr/bin/python3#coding: UTF-8str='Python'print (str) # 输出字符串print (str[0:-1]) # 输出第一个到倒数第二个的所有字符print (str[0]) # 输出字符串第一个字符print (str[2:5]) # 输出从第三个开始到第五个的字符print (str[2:]) # 输出从第三个开始的后面所有字符print (str * 2) # 输出字符串两次print (str + '你好') # 连接字符串print('------------------------------')print('hello\\npython') # 使用反斜杠(\\)+n转义特殊字符print(r'hello\\npython') # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入1234#!/usr/bin/python3#coding: UTF-8input(\"\\n\\n按下 enter 键后退出\") 如何输出? Print输出 12345678910111213#!/usr/bin/python3 x=\"a\"y=\"b\"# 换行输出print( x )print( y ) print('---------')# 不换行输出print( x, end=\" \" )print( y, end=\" \" )print() import 与 from…import在 python 用 import 或者 from...import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 标准数据类型Python3 中有六个标准的数据类型： Number（数字） int、float、boo、complex(复数) String（字符串） List（列表） Tuple（元组） Set（集合）Dictionary（字典） 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 Python3 面向对象面向对象技术简介 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 类123456789101112131415161718192021#!/usr/bin/python3#coding: UTF-8# 类定义class people: # 定义基本属性 name = '' age = 0 # 定义私有属性, 私有属性在类外部无法直接进行访问 __weight = 0 # 定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print (\"%s 说: 我 %d 岁\" %(self.name, self.age))# 实例化类p = people('Python',24,30)p.speak()","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.caoxl.com/tags/Python/"}]},{"title":"Laravel Admin 更换图标库","slug":"Hexo-Change-Icons-Library","date":"2018-12-03T09:01:47.000Z","updated":"2019-08-22T03:53:54.000Z","comments":true,"path":"2018/12/03/Hexo-Change-Icons-Library/","link":"","permalink":"http://blog.caoxl.com/2018/12/03/Hexo-Change-Icons-Library/","excerpt":"LaravelAdmin 自带的 Fontawesome 图标库不够用,这里给出更换的方法","text":"LaravelAdmin 自带的 Fontawesome 图标库不够用,这里给出更换的方法 Google Material IconsMaterial Design Icons 重写内置视图如果有需要自己修改view，但是不方便直接修改laravel-admin的情况，可以用下面的办法解决 复制vendor/encore/laravel-admin/views到项目的resources/views/admin，然后在app/Admin/bootstrap.php文件中加入代码： 1app('view')-&gt;prependNamespace('admin', resource_path('views/admin')); 引入CSS文件 resources/views/admin/index.blade.php 1&lt;link rel=\"stylesheet\" href=\"//cdn.materialdesignicons.com/3.2.89/css/materialdesignicons.min.css\"&gt; 修改Menu文件 resources/views/admin/partials/menu.blade.php 1修改 fa ==&gt; mdi 魔改JS文件 public/vendor/laravel-admin/fontawesome-iconpicker/dist/js 搜索defaultOptions.icons, 修改最后那个数组 点击查看JS 菜单列表处的图标还需要修改一个地方 效果图","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"LaravelAdmin","slug":"LaravelAdmin","permalink":"http://blog.caoxl.com/tags/LaravelAdmin/"},{"name":"Icon","slug":"Icon","permalink":"http://blog.caoxl.com/tags/Icon/"},{"name":"Fontawesome","slug":"Fontawesome","permalink":"http://blog.caoxl.com/tags/Fontawesome/"}]},{"title":"Redis 常用命令及其时间复杂度","slug":"Redis-Time-Complexity","date":"2018-11-28T03:23:41.000Z","updated":"2019-08-22T06:35:48.000Z","comments":true,"path":"2018/11/28/Redis-Time-Complexity/","link":"","permalink":"http://blog.caoxl.com/2018/11/28/Redis-Time-Complexity/","excerpt":"使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。(例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用)","text":"使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。(例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用) 附:Redis 命令参考 以下O都是大写字母O,不是数字0 时间复杂度 O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(n³) &lt; O(n!) &lt; O($n^n$) Key Redis采用Key-Value型的基本数据结构，任何二进制序列都可以作为Redis的Key使用（例如普通的字符串或一张JPEG图片） 关于Key的一些注意事项： 不要使用过长的Key。例如使用一个1024字节的key就不是一个好主意，不仅会消耗更多的内存，还会导致查找的效率降低 Key短到缺失了可读性也是不好的，例如&quot;u1000flw&quot;比起&quot;user:1000:followers&quot;来说，节省了寥寥的存储空间，却引发了可读性和可维护性上的麻烦 最好使用统一的规范来设计Key，比如&quot;object-type:id:attr&quot;，以这一规范设计出的Key可能是&quot;user:1000&quot;或&quot;comment:1234:reply-to&quot; Redis允许的最大Key长度是512MB（对Value的长度限制也是512MB） String String是Redis的基础数据类型，Redis没有Int、Float、Boolean等数据类型的概念，所有的基本类型在Redis中都以String体现。 与String相关的常用命令： SET：为一个key设置value，可以配合EX/PX参数指定key的有效期，通过NX/XX参数针对key是否存在的情况进行区别操作，时间复杂度O(1) GET：获取某个key对应的value，时间复杂度O(1) GETSET：为一个key设置value，并返回该key的原value，时间复杂度O(1) MSET：为多个key设置value，时间复杂度O(N) MSETNX：同MSET，如果指定的key中有任意一个已存在，则不进行任何操作，时间复杂度O(N) MGET：获取多个key对应的value，时间复杂度O(N) 上文提到过，Redis的基本数据类型只有String，但Redis可以把String作为整型或浮点型数字来使用，主要体现在INCR、DECR类的命令上： INCR：将key对应的value值自增1，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1) INCRBY：将key对应的value值自增指定的整型数值，并返回自增后的值。只对可以转换为整型的String数据起作用。时间复杂度O(1) DECR/DECRBY：同INCR/INCRBY，自增改为自减。 List Redis的List是链表型的数据结构，可以使用LPUSH/RPUSH/LPOP/RPOP等命令在List的两端执行插入元素和弹出元素的操作。虽然List也支持在特定index上插入和读取元素的功能，但其时间复杂度较高（O(N)），应小心使用。 与List相关的常用命令： LPUSH：向指定List的左侧（即头部）插入1个或多个元素，返回插入后的List长度。时间复杂度O(N)，N为插入元素的数量 RPUSH：同LPUSH，向指定List的右侧（即尾部）插入1或多个元素 LPOP：从指定List的左侧（即头部）移除一个元素并返回，时间复杂度O(1) RPOP：同LPOP，从指定List的右侧（即尾部）移除1个元素并返回 LPUSHX/RPUSHX：与LPUSH/RPUSH类似，区别在于，LPUSHX/RPUSHX操作的key如果不存在，则不会进行任何操作 LLEN：返回指定List的长度，时间复杂度O(1) LRANGE：返回指定List中指定范围的元素（双端包含，即LRANGE key 0 10会返回11个元素），时间复杂度O(N)。应尽可能控制一次获取的元素数量，一次获取过大范围的List元素会导致延迟，同时对长度不可预知的List，避免使用LRANGE key 0 -1这样的完整遍历操作。 应谨慎使用的List相关命令： LINDEX：返回指定List指定index上的元素，如果index越界，返回nil。index数值是回环的，即-1代表List最后一个位置，-2代表List倒数第二个位置。时间复杂度O(N) LSET：将指定List指定index上的元素设置为value，如果index越界则返回错误，时间复杂度O(N)，如果操作的是头/尾部的元素，则时间复杂度为O(1) LINSERT：向指定List中指定元素之前/之后插入一个新元素，并返回操作后的List长度。如果指定的元素不存在，返回-1。如果指定key不存在，不会进行任何操作，时间复杂度O(N) 由于Redis的List是链表结构的，上述的三个命令的算法效率较低，需要对List进行遍历，命令的耗时无法预估，在List长度大的情况下耗时会明显增加，应谨慎使用。 Hash Hash即哈希表，Redis的Hash和传统的哈希表一样，是一种field-value型的数据结构，可以理解成将HashMap搬入Redis。Hash非常适合用于表现对象类型的数据，用Hash中的field对应对象的field即可。 与Hash相关的常用命令： HSET：将key对应的Hash中的field设置为value。如果该Hash不存在，会自动创建一个。时间复杂度O(1) HGET：返回指定Hash中field字段的值，时间复杂度O(1) HMSET/HMGET：同HSET和HGET，可以批量操作同一个key下的多个field，时间复杂度：O(N)，N为一次操作的field数量 HSETNX：同HSET，但如field已经存在，HSETNX不会进行任何操作，时间复杂度O(1) HEXISTS：判断指定Hash中field是否存在，存在返回1，不存在返回0，时间复杂度O(1) HDEL：删除指定Hash中的field（1个或多个），时间复杂度：O(N)，N为操作的field数量 HINCRBY：同INCRBY命令，对指定Hash中的一个field进行INCRBY，时间复杂度O(1) 应谨慎使用的Hash相关命令： HGETALL：返回指定Hash中所有的field-value对。返回结果为数组，数组中field和value交替出现。时间复杂度O(N) HKEYS/HVALS：返回指定Hash中所有的field/value，时间复杂度O(N) 上述三个命令都会对Hash进行完整遍历，Hash中的field数量与命令的耗时线性相关，对于尺寸不可预知的Hash，应严格避免使用上面三个命令，而改为使用HSCAN命令进行游标式的遍历, 具体请见: https://redis.io/commands/scan Set Redis Set是无序的，不可重复的String集合。 与Set相关的常用命令： SADD：向指定Set中添加1个或多个member，如果指定Set不存在，会自动创建一个。时间复杂度O(N)，N为添加的member个数 SREM：从指定Set中移除1个或多个member，时间复杂度O(N)，N为移除的member个数 SRANDMEMBER：从指定Set中随机返回1个或多个member，时间复杂度O(N)，N为返回的member个数 SPOP：从指定Set中随机移除并返回count个member，时间复杂度O(N)，N为移除的member个数 SCARD：返回指定Set中的member个数，时间复杂度O(1) SISMEMBER：判断指定的value是否存在于指定Set中，时间复杂度O(1) SMOVE：将指定member从一个Set移至另一个Set 慎用的Set相关命令： SMEMBERS：返回指定Hash中所有的member，时间复杂度O(N) SUNION/SUNIONSTORE：计算多个Set的并集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 SINTER/SINTERSTORE：计算多个Set的交集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 SDIFF/SDIFFSTORE：计算1个Set与1或多个Set的差集并返回/存储至另一个Set中，时间复杂度O(N)，N为参与计算的所有集合的总member数 上述几个命令涉及的计算量大，应谨慎使用，特别是在参与计算的Set尺寸不可知的情况下，应严格避免使用。可以考虑通过SSCAN命令遍历获取相关Set的全部member（具体请见 https://redis.io/commands/scan ） Sorted Set Redis Sorted Set是有序的、不可重复的String集合。Sorted Set中的每个元素都需要指派一个分数(score)，Sorted Set会根据score对元素进行升序排序。如果多个member拥有相同的score，则以字典序进行升序排序。Sorted Set非常适合用于实现排名。 Sorted Set的主要命令： ZADD：向指定Sorted Set中添加1个或多个member，时间复杂度O(Mlog(N))，M为添加的member数量，N为Sorted Set中的member数量 ZREM：从指定Sorted Set中删除1个或多个member，时间复杂度O(Mlog(N))，M为删除的member数量，N为Sorted Set中的member数量 ZCOUNT：返回指定Sorted Set中指定score范围内的member数量，时间复杂度：O(log(N)) ZCARD：返回指定Sorted Set中的member数量，时间复杂度O(1) ZSCORE：返回指定Sorted Set中指定member的score，时间复杂度O(1) ZRANK/ZREVRANK：返回指定member在Sorted Set中的排名，ZRANK返回按升序排序的排名，ZREVRANK则返回按降序排序的排名。时间复杂度O(log(N)) ZINCRBY：同INCRBY，对指定Sorted Set中的指定member的score进行自增，时间复杂度O(log(N)) 慎用的Sorted Set相关命令： ZRANGE/ZREVRANGE：返回指定Sorted Set中指定排名范围内的所有member，ZRANGE为按score升序排序，ZREVRANGE为按score降序排序，时间复杂度O(log(N)+M)，M为本次返回的member数 ZRANGEBYSCORE/ZREVRANGEBYSCORE：返回指定Sorted Set中指定score范围内的所有member，返回结果以升序/降序排序，min和max可以指定为-inf和+inf，代表返回所有的member。时间复杂度O(log(N)+M) ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除Sorted Set中指定排名范围/指定score范围内的所有member。时间复杂度O(log(N)+M) 上述几个命令，应尽量避免传递[0 -1]或[-inf +inf]这样的参数，来对Sorted Set做一次性的完整遍历，特别是在Sorted Set的尺寸不可预知的情况下。可以通过ZSCAN命令来进行游标式的遍历（具体请见 https://redis.io/commands/scan ） 其他常用命令 EXISTS：判断指定的key是否存在，返回1代表存在，0代表不存在，时间复杂度O(1) DEL：删除指定的key及其对应的value，时间复杂度O(N)，N为删除的key数量 EXPIRE/PEXPIRE：为一个key设置有效期，单位为秒或毫秒，时间复杂度O(1) TTL/PTTL：返回一个key剩余的有效时间，单位为秒或毫秒，时间复杂度O(1) RENAME/RENAMENX：将key重命名为newkey。使用RENAME时，如果newkey已经存在，其值会被覆盖；使用RENAMENX时，如果newkey已经存在，则不会进行任何操作，时间复杂度O(1) TYPE：返回指定key的类型，string, list, set, zset, hash。时间复杂度O(1) CONFIG GET：获得Redis某配置项的当前值，可以使用*通配符，时间复杂度O(1) CONFIG SET：为Redis某个配置项设置新值，时间复杂度O(1) CONFIG REWRITE：让Redis重新加载redis.conf中的配置","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"时间复杂度","slug":"时间复杂度","permalink":"http://blog.caoxl.com/tags/时间复杂度/"}]},{"title":"CentOS 关闭和清除阿里云盾","slug":"Linux-CentOS-Uninstall-Aliyundun","date":"2018-11-19T02:12:06.000Z","updated":"2018-11-19T02:38:21.000Z","comments":true,"path":"2018/11/19/Linux-CentOS-Uninstall-Aliyundun/","link":"","permalink":"http://blog.caoxl.com/2018/11/19/Linux-CentOS-Uninstall-Aliyundun/","excerpt":"新服务器自带阿里云盾,查了半天不知道这货有啥作用,于是卸载.","text":"新服务器自带阿里云盾,查了半天不知道这货有啥作用,于是卸载. 卸载前123456789101112[root@caoxl ~]# top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1090 root 20 0 129592 11276 9220 S 0.3 0.3 14:08.23 AliYunDun 1 root 20 0 43284 3680 2500 S 0.0 0.1 0:03.06 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:00.02 ksoftirqd/0 5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 6 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kworker/u4:0 7 root rt 0 0 0 0 S 0.0 0.0 0:00.03 migration/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh 9 root 20 0 0 0 0 S 0.0 0.0 0:23.12 rcu_sched 10 root rt 0 0 0 0 S 0.0 0.0 0:01.04 watchdog/0 方法一 卸载云盾监控屏蔽 IP 卸载阿里云盾监控 1234567891011[root@caoxl download]# wget http://update.aegis.aliyun.com/download/uninstall.sh[root@caoxl download]# sh uninstall.sh Stopping aegis [ OK ]umount: /usr/local/aegis/aegis_debug: mountpoint not foundUninstalling aegis [ OK ][root@caoxl download]# wget http://update.aegis.aliyun.com/download/quartz_uninstall.sh[root@caoxl download]# sh quartz_uninstall.sh Stopping aegis [ OK ]Stopping quartz [ OK ]Uninstalling aegis_quartz [ OK ] 删除残留 123[root@caoxl download]# pkill aliyun-service[root@caoxl download]# rm -rf /etc/init.d/agentwatch /usr/sbin/aliyun-service[root@caoxl download]# rm -rf /usr/local/aegis* 屏蔽云盾 IP 1234567891011[root@caoxl download]# iptables -I INPUT -s 140.205.201.0/28 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.201.16/29 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.201.32/28 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.225.192/29 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.225.200/30 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.225.184/29 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.225.183/32 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.225.206/32 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.225.205/32 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.225.205/32 -j DROP[root@caoxl download]# iptables -I INPUT -s 140.205.225.204/32 -j DROP 方法二 CentOS 关闭 AliYunDun 使用 chkconfig --list 查看开机启动里面这个软件的服务名是什么，然后替换掉 xxx 然后执行就可以了。如果想开机不启动的话，chkconfig --del xxx 这个 xxx 就是你找出来的 aliyundun 的后台服务。 12345678[root@caoxl /]# chkconfig --listaegis 0:off 1:off 2:on 3:on 4:on 5:on 6:offnetconsole 0:off 1:off 2:off 3:off 4:off 5:off 6:offnetwork 0:off 1:off 2:on 3:on 4:on 5:on 6:offnginx 0:off 1:off 2:on 3:on 4:on 5:on 6:offphp-fpm-56 0:off 1:off 2:on 3:on 4:on 5:on 6:offphp-fpm-72 0:off 1:off 2:on 3:on 4:on 5:on 6:offshadowsocks 0:off 1:off 2:on 3:on 4:on 5:on 6:off 12service aegis stop # 停止服务chkconfig --del aegis # 删除服务 方法三 阿里云服务器关闭云盾阿里云服务器查杀关闭云盾进程 123456789101112[root@caoxl ~]# top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1090 root 20 0 129592 11276 9220 S 0.3 0.3 14:08.23 AliYunDun 1 root 20 0 43284 3680 2500 S 0.0 0.1 0:03.06 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:00.02 ksoftirqd/0 5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 6 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kworker/u4:0 7 root rt 0 0 0 0 S 0.0 0.0 0:00.03 migration/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh 9 root 20 0 0 0 0 S 0.0 0.0 0:23.12 rcu_sched 10 root rt 0 0 0 0 S 0.0 0.0 0:01.04 watchdog/0 查杀关闭云盾进程处理过程如下： 123[root@caoxl /]# ps -ef | grep -v grep | grep -i aliyundun[root@caoxl /]# ps -ef | grep -v grep | grep -i aliyundun | awk '&#123;print $2&#125;'[root@caoxl /]# ps -ef | grep -v grep | grep -i aliyundun | awk '&#123;print $2&#125;' | xargs kill -9 卸载后1234567891011 [root@caoxl /]# top PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 43284 3680 2500 S 0.0 0.1 0:03.07 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:00.02 ksoftirqd/0 5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 6 root 20 0 0 0 0 S 0.0 0.0 0:00.00 kworker/u4:0 7 root rt 0 0 0 0 S 0.0 0.0 0:00.03 migration/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh 9 root 20 0 0 0 0 S 0.0 0.0 0:23.16 rcu_sched 10 root rt 0 0 0 0 S 0.0 0.0 0:01.04 watchdog/0 删除阿里云登录界面欢迎信息 Welcome to Alibaba Cloud Elastic Compute Service ! 1vim /etc/motd # 就可以自己编辑欢迎信息了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://blog.caoxl.com/tags/CentOS/"},{"name":"Aliyundun","slug":"Aliyundun","permalink":"http://blog.caoxl.com/tags/Aliyundun/"}]},{"title":"Linux CentOS编译安装MariaDB","slug":"Linux-Install-MariaDB","date":"2018-11-15T03:36:36.000Z","updated":"2018-11-15T06:38:24.000Z","comments":true,"path":"2018/11/15/Linux-Install-MariaDB/","link":"","permalink":"http://blog.caoxl.com/2018/11/15/Linux-Install-MariaDB/","excerpt":"原文地址: https://segmentfault.com/a/1190000009909776整理自用.","text":"原文地址: https://segmentfault.com/a/1190000009909776整理自用. 删除CentOS默认数据库配置文件 查看默认数据库配置文件 123456[root@caoxl ~]# find -H /etc/ | grep my.c/etc/pki/tls/certs/make-dummy-cert/etc/pki/tls/certs/renew-dummy-cert/etc/my.cnf.d/etc/my.cnf.d/mysql-clients.cnf/etc/my.cnf 删除默认数据库配置文件 1[root@caoxl ~]# rm -rf /etc/my.cnf /etc/my.cnf.d/ 再次查看默认数据库配置文件 123[root@caoxl ~]# find -H /etc/ | grep my.c/etc/pki/tls/certs/make-dummy-cert/etc/pki/tls/certs/renew-dummy-cert 到目前为止, 系统最小化安装自带的数据库配置文件已经删除干净了! 卸载系统自带mariadb-libs 查询 12[root@caoxl ~]# rpm -qa|grep mariadb-libsmariadb-libs-5.5.52-1.el7.x86_64 卸载 1[root@caoxl ~]# rpm -e mariadb-libs-5.5.52-1.el7.x86_64 --nodeps 安装相关包123[root@caoxl ~]# yum -y install libaio libaio-devel bison bison-devel zlib-devel openssl openssl-devel ncursesncurses-devel libcurl-devel libarchive-devel boost boost-devel lsof wget gcc gcc-c++ make cmake perlkernel-headers kernel-devel pcre-devel MariaDB官网复制源码包链接地址并下载解压1234567[root@caoxl ~]# mkdir /download[root@caoxl ~]# cd /download[root@caoxl download]# wget https://downloads.mariadb.org/interstitial/mariadb-10.2.6/source/mariadb-10.2.6.tar.gz[root@caoxl download]# tar -zxvf mariadb-10.2.6.tar.gz 创建MariaDB安装目录、数据库存放目录、建立用户和目录 这里提前预定MariaDB的安装目录为/usr/local/mysql并且数据库目录为/data/mysql，这里要建立系统用户及组和数据库存放目录，并且将数据库存放目录赋予mysql用户及组权限，操作如下:请注意特别说明一下：这里说的数据库目录是指的具体数据库存储文件, 而不是安装文件! 创建mysql系统用户组 1groupadd -r mysql 创建系统用户mysql并加入到mysql系统用户组 1useradd -r -g mysql -s /sbin/nologin -d /usr/local/mysql -M mysql 创建mariadb安装目录 1mkdir -p /usr/local/mysql 创建数据库存放目录 1mkdir -p /data/mysql 改变数据库存放目录所属用户及组为 mysql:mysql 1chown -R mysql:mysql /data/mysql 执行编译安装1234567891011121314cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ -DMYSQL_DATADIR=/data/mysql \\ -DSYSCONFDIR=/etc \\ -DWITHOUT_TOKUDB=1 \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_ARCHIVE_STPRAGE_ENGINE=1 \\ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\ -DWIYH_READLINE=1 \\ -DWIYH_SSL=system \\ -DVITH_ZLIB=system \\ -DWITH_LOBWRAP=0 \\ -DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\ -DDEFAULT_CHARSET=utf8 \\ -DDEFAULT_COLLATION=utf8_general_ci 配置MariaDB123456789101112131415161718192021222324252627282930313233343536373839cd /usr/local/mysql/scripts/mysql_install_db --user=mysql --datadir=/data/mysql&gt; 输出以下信息:Installing MariaDB/MySQL system tables in '/data/mysql' ...OKTo start mysqld at boot time you have to copysupport-files/mysql.server to the right place for your systemPLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !To do so, start the server, then issue the following commands:'./bin/mysqladmin' -u root password 'new-password''./bin/mysqladmin' -u root -h localhost.localdomain password 'new-password'Alternatively you can run:'./bin/mysql_secure_installation'which will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers.See the MariaDB Knowledgebase at http://mariadb.com/kb or theMySQL manual for more instructions.You can start the MariaDB daemon with:cd '.' ; ./bin/mysqld_safe --datadir='/data/maria'You can test the MariaDB daemon with mysql-test-run.plcd './mysql-test' ; perl mysql-test-run.plPlease report any problems at http://mariadb.org/jiraThe latest information about MariaDB is available at http://mariadb.org/.You can find additional information about the MySQL part at:http://dev.mysql.comConsider joining MariaDB's strong and vibrant community:https://mariadb.org/get-involved/ 复制MariaDB配置文件到/etc目录12cd /usr/local/mysql/cp support-files/my-large.cnf /etc/my.cnf 创建启动脚本1cp support-files/mysql.server /etc/rc.d/init.d/mysqld 启动mysqld服务1cp support-files/mysql.server /etc/rc.d/init.d/mysqld 启动mysqld服务1/etc/rc.d/init.d/mysqld start 12345678[root@caoxl www]# service mysqld statusMariaDB is not running [FAILED][root@caoxl www]# service mysqld startStarting MariaDB.181115 14:26:03 mysqld_safe Logging to '/data/mysql/caoxl.err'.181115 14:26:03 mysqld_safe Starting mysqld daemon with databases from /data/mysql [ OK ][root@caoxl www]# service mysqld statusMariaDB running (31114) [ OK ] 配置环境变量, 以便在任何目录下输入mysql12345678910vim /etc/profile.d/mysql.sh# 输入以下内容export PATH=$PATH:/usr/local/mysql/bin/# 为脚本赋于可执行权限chmod 0777 /etc/profile.d/mysql.sh# 进行mysql.sh脚本所在目录, 并执行脚本, 以立即生效环境变量source /etc/profile.d/mysql.sh 初始化MariaDB123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657./bin/mysql_secure_installation&gt; 以下提示：Enter current password for root (enter for none): 输入当前root密码(没有输入)Set root password? [Y/n] 设置root密码?(是/否)New password: 输入新root密码Re-enter new password: 确认输入root密码Password updated successfully! 密码更新成功By default, a MariaDB installation has an anonymous user, allowing anyoneto log into MariaDB without having to have a user account created forthem. This is intended only for testing, and to make the installationgo a bit smoother. You should remove them before moving into aproduction environment.默认情况下,MariaDB安装有一个匿名用户,允许任何人登录MariaDB而他们无需创建用户帐户。这个目的是只用于测试,安装去更平缓一些。你应该进入前删除它们生产环境。Remove anonymous users? [Y/n] 删除匿名用户?(是/否)Normally, root should only be allowed to connect from 'localhost'. Thisensures that someone cannot guess at the root password from the network.通常情况下，root只应允许从localhost连接。这确保其他用户无法从网络猜测root密码。Disallow root login remotely? [Y/n] 不允许root登录远程?(是/否)By default, MariaDB comes with a database named 'test' that anyone canaccess. This is also intended only for testing, and should be removedbefore moving into a production environment.默认情况下，MariaDB提供了一个名为“测试”的数据库，任何人都可以访问。这也只用于测试，在进入生产环境之前应该被删除。Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.重新加载权限表将确保所有到目前为止所做的更改将立即生效。Reload privilege tables now? [Y/n] 现在重新加载权限表(是/否)All done! If you've completed all of the above steps, your MariaDBinstallation should now be secure.全部完成!如果你已经完成了以上步骤,MariaDB安装现在应该安全。Thanks for using MariaDB!感谢使用MariaDB! 进入MariaDB终端1mysql -u username -p password 参考 CentOS7.3编译安装MariaDB10.2.6","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://blog.caoxl.com/tags/MariaDB/"},{"name":"编译安装","slug":"编译安装","permalink":"http://blog.caoxl.com/tags/编译安装/"}]},{"title":"CentOS 下更新GCC版本至GCC 8.0.2","slug":"Gcc-Update-To-Latest","date":"2018-11-13T06:46:16.000Z","updated":"2018-11-15T04:50:33.000Z","comments":true,"path":"2018/11/13/Gcc-Update-To-Latest/","link":"","permalink":"http://blog.caoxl.com/2018/11/13/Gcc-Update-To-Latest/","excerpt":"新买的服务器, GCC的版本还是4.8.5, 而GCC已经出到了8.2版本,这怎么能忍? 千万别更新!!! 血的教训!!! 折腾一天后我重装系统了!!!","text":"新买的服务器, GCC的版本还是4.8.5, 而GCC已经出到了8.2版本,这怎么能忍? 千万别更新!!! 血的教训!!! 折腾一天后我重装系统了!!! 更新前 12345[root@caoxl /]# gcc --versiongcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-28)Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 更新后 12345[root@caoxl build]# gcc --versiongcc (GCC) 8.2.0Copyright (C) 2018 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 编译安装 GCC https://ftp.gnu.org/gnu/gcc/ 1234567891011121314151617// 下载wget https://ftp.gnu.org/gnu/gcc/gcc-8.2.0/gcc-8.2.0.tar.gz// 解压tar -zxvg gcc-8.2.0.tar.gzcd gcc-8.2.0// 安装依赖./contrib/download_prerequisites// 创建一个文件用来存放编译的文件，进入该文件mkdir build &amp;&amp; cd build../configure -enable-checking=release -enable-languages=c,c++ -disable-multilib// 编译安装make -j4 &amp;&amp; make install 注意 动态库需要更新，因为GCC升级了，动态库也需要升级。 gdb版本也需要升级的，否则无法调试 升级GDB版本 https://ftp.gnu.org/gnu/gdb/ 这里选择和GCC相同版本: https://ftp.gnu.org/gnu/gdb/gdb-8.2.tar.gz 123456wget https://ftp.gnu.org/gnu/gdb/gdb-8.2.tar.gztar zxvf gdb-8.2.tar.gzcd gdb-8.2./configuremakemake install 123456[root@caoxl /]# gdb -vGNU gdb (GDB) 8.2Copyright (C) 2018 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. FAQtar (child): lbzip2: Cannot exec: No such file or directory1234tar (child): lbzip2: Cannot exec: No such file or directory tar (child): Error is not recoverable: exiting now tar: Child returned status 2 tar: Error is not recoverable: exiting now 解决方法很简单，只要安装bzip2就行了，yum安装的命令如下： 1yum -y install bzip2","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://blog.caoxl.com/tags/CentOS/"},{"name":"GCC","slug":"GCC","permalink":"http://blog.caoxl.com/tags/GCC/"}]},{"title":"MySQL 复习笔记","slug":"MySQL-cmd-Summary","date":"2018-11-12T03:29:38.000Z","updated":"2019-08-22T06:27:17.000Z","comments":true,"path":"2018/11/12/MySQL-cmd-Summary/","link":"","permalink":"http://blog.caoxl.com/2018/11/12/MySQL-cmd-Summary/","excerpt":"MySQL的基本操作可以包括两个方面：MySQL常用语句如高频率使用的增删改查（CRUD）语句和MySQL高级功能，如存储过程，触发器，事务处理等","text":"MySQL的基本操作可以包括两个方面：MySQL常用语句如高频率使用的增删改查（CRUD）语句和MySQL高级功能，如存储过程，触发器，事务处理等 MySQL常用语句 表（或者数据库）的CRUD 表数据的CRUD，其中表数据查询使用最多，也更复杂。查询可以按照单表还是多表可以分为：单表SELECT查询和多表的联结查询（INNER JOIN, LEFT JOIN, RIGHT JOIN和FULL JOIN）以及组合查询UNION和UNION ALL SQL语句中各个关键字的执行顺序 MySQL的高级功能 存储过程 事务处理 触发器 表(或数据库)操作语句查询表（或数据库） 获取所有可用的数据库：SHOW DATABASES; 选择数据库：USE customers; 用于显示数据库服务器的状态信息：SHOW STATUS; 用来显示授权用户的安全权限：SHOW GRANTS; 用来显示数据库服务器或警告信息：SHOW ERRORS 或者 SHOW WARNINGS; 用于显示创建数据库时的创建语句：SHOW CREATE DATABASE customers； 用于显示创建表时的创建语句：SHOW CREATE TABLE customers； 获取当前所选的数据库中所有可用的表：SHOW TABLES； 获取表中所有列的信息：SHOW COLUMNS FROM tableName；同时DESCRIBE语句有相同的效果：DESCRIBE tableName； 新建表（或数据库） 新建数据库：CREATE DATABASE customers; 创建表可以使用CREATE TABLE语句: 123456CREATE TABLE customers( cust_id INT NOT NULL AUTO_INCREMENT, cust_name CHAR(50) NOT NULL, cust_age INT NULL DEFAULT 18, PRIMARY KEY(cust_id))ENGINE=INNODB; 有这样一些细节： 允许NULL值，则说明在插入行数据时允许不给出该列的值，而NOT NULL则表示在插入或者更新该列数据，必须明确给出该列的值； DEFAULT表示该列的默认值，在插入行数据时，若没有给出该列的值就会使用其指定的默认值； PRIMARY KEY用于指定主键，主键可以指定一列数据，而可以由多列数据组合构成，如PRIMARY KEY(cust_id,cust_name)； ENGINE用于指定引擎类型。常见的引擎类型有这些：（1）InnoDB是一个支持可靠的事务处理的引擎，但是不支持全文本搜索；（2）MyISAM是一个性能极高的引擎，它支持全文本搜索，但是不支持事务处理；（3）MEMORY在功能上等同于MyISAM，但由于数据存储在内存中，速度很快（特别适合于临时表）； 在创建表的时候可以使用FOREIGN KEY来创建外键，即一个表中的FOREIGN KEY指向另一个表中PRIMARY KEY。外键FOREIGN KEY用于约束破坏表的联结动作，保证两个表的数据完整性。同时也能防止非法数据插入外键列，因为该列值必须指向另一个表的主键。 12345678REATE TABLE Orders ( Id_O int NOT NULL, OrderNo int NOT NULL, Id_P int, PRIMARY KEY (Id_O), FOREIGN KEY (Id_P) REFERENCES Persons(Id_P) ) 删除表（或数据库） 删除数据库：DROP DATABASE customers； 删除表，使用DROP TABLE子句：DROP TABLE customers; 更新表 更新表结构信息可以使用ALTER TABLE子句，如为表增加一列：ALTER TABLE vendors ADD vend_name CHAR(20)；另外经常用于定义外键，如： 123ALTER TABLE customers ADD CONSTRAINT fk_custormer_ordersFOREIGN KEY(cust_id) REFERENCES orders (order_cust) 重命名表，使用RENAME子句。 1RENAME TABLE backup_customers TO customers, backup_vendors TO vendors; 更改多个表名，之间用逗号间隔 表数据操作语句查询表数据基本查询 根据过滤条件查询表中的单列或者多列或者全部列的信息SELECT FROM WEHERE 1SELECT cust_id,cust_name FROM customers WHERE cust_id=10086; 其中过滤条件操作符有：=，&lt;&gt;,!=,&lt;,&lt;=,&gt;,&gt;=,BETWEEN AND,IS NULL； 为查询出的某一列信息去重DISTINCT： 1SELECT DISTINCT cust_name FROM customers; 限制单列查询结果的行数： 12SELECT cust_name FROM customers LIMIT 5; // 表示从第0行开始取，共取5行数据；SELECT cust_name FROM customers LIMIT 5,5; // 表示从第5行（数据库中实际第6行记录）开始取，共取5行数据 ORDER BY子句取一个或者多个列，据此对输出进行排序 1SELECT cust_id,cust_name FROM customers ORDER BY cust_id DESC, cust_name; IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配 1SELECT cust_id, cust_name FROM customers WHERE cust_id IN (1000,2000) LIKE操作符用来表明模糊查询，与之配合使用的通配符有 %，%表示任何字符出现任何次数；_，_表示只能匹配一个字符 1SELECT cust_id,cust_name FROM customers WHERE cust_name LIKE '%happy%'; 使用分组查询并可以满足一定的分组过滤条件GROUP BY HAVING。如检索总计订单金额大于等于50的订单号和订单总金额，并按总金额进行排序 1SELECT order_num,SUM(quantity*item_price) AS order_total FROM orderitems GROUP BY order_num HAVING SUM(quantity*item_price)&gt;=50 ORDER BY order_total; WHERE和HAVING的比较。 WHERE是行级过滤，而HAVING是组级过滤。被WHERE过滤掉的数据不会出现在分组中。WHERE中通配符以及多个WHERE子句的连接同样适用于HAVING子句； GROUP BY的使用注意事项： （1）GROUP BY子句中可以嵌套分组（即通过多个列进行分组GROUP BY cust_id, cust_name），但是进行数据汇总时，是在最后规定的分组上进行；（2）GROUP BY子句中列出的每个列都必须是检索列或者是有效的表达式。（3）如果有NULL值，将值NULL作为一个分组进行返回，如果有多行NULL值，它们将分为一组 嵌套其他查询中的查询，称之为子查询。执行过程由里向外，里层查询结果作为外层查询的条件： 12SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = 'happy'); 联结查询 内联结用又称之为内部联结，是基于两个表 之间的的相等测试。如果不加过滤条件，会造成“笛卡尔积” 1SELECT vend_name,prod_name,prod_price FROM vendors INNER JOIN products ON vendors.vend_id=products.vend_id; 同样可以使用WHERE进行多表联结查询，但是更推荐使用INNER JOIN等联结方式； 外部联结包括左外联结LEFT JOIN和右外联结RIGHT JOIN和全连接FULL JOIN。例如查询每个客户的订单数： 12SELECT customers.cust_id,orders.orders_num FROM customers LEFT JOIN orders ON orders.cust_id =customers.cust_id; LEFT JOIN 会全部返回左表数据，RIGHT JOIN会全部返回右表数据，FULL JOIN会将左右两个表的数据全部返回 联结查询与聚集函数一起使用。如查询每个客户的订单数： 12SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ord FROM customers INNER JOIN orders ON customers.cust_id=orders.cust_id GROUP BY customers.cust_id； 组合查询 多个查询（SELECT）可以使用UNION将多个查询结果进行合并成一个结果集返回，UNION必须包含两个及两个以上的SELECT查询，并且每个传必须包含相同的列、表达式或聚集函数，数据类型不必完全相同，MySQL会进行隐式的类型转换。 12SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price&gt;5 UINON SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002); UNION返回的是去重后的结果，如果不需要去重则可以使用UNION ALL； 可以多组合查询使用ORDER BY进行排序，但是是针对的最终的结果集进行排序，而不是其中单个SELECT查询进行排序，因此对于组合查询来说ORDER BY子句只有一个 12SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price&gt;5 UINON SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id IN (1001,1002) ORDER BY vend_id; 使用函数对数据进行处理 拼接列名 1SELECT Concat (vendName,'(',vendCountry,')') FROM vendors ORDER BY vendName; 执行算术表达式计算 1SELECT prodId, quantity,price, quantity*price AS expandedPrice FROM orderItems; 文本处理函数如Upper(),LTrim(),RTrim()等函数。比如使用Upper函数将文本转换成大写 1SELECT vendName, Upper(vendName) FROM vendors ORDER BY vendName; 时间和日期处理函数，如Date(),Day()等 1SELECT custId, orderNum FROM orders WHERE Date(orderDate)='2015-09-01'; 数值处理函数，如Abs(),Cos()等； 常用的聚集函数。如AVG(),COUNT(),MAX(),MIN()以及SUM() 1SELECT COUNT(*) AS numbers, MIN(prod_price) AS price_min, MAX(prod_price) AS price_max,AVG(prod_price) AS price_avg FROM products; 插入表数据 向表中插入行数据可以使用INSERT INTO子句，更安全的方式是指定列名。 1INSERT INTO customers (cust_name, cust_email) VALUES('happy','happy@gmail.com'); 在INSERT INTO子句中能够省略列名的前提条件是：该列可以允许定义为NULL值或者在定义该列时给出去了默认值； 如果插入多行数据可以将多组值用逗号进行分隔即可 1INSERT INTO customers (cust_name, cust_email) VALUES('happy','happy@gmail.com'),('smart','smart@gmail.com'); 将查询出来的数据插入表中，可以使用INSERT SELECT语句 1INSERT INTO customers(cust_id,cust_contact) SELECT cust_id, cust_contact FROM customers WHERE cust_id&gt;5; 其中SELECT中可以带WHERE过滤条件；INSERT SELECT通常被用于复制表数据 更新表数据 如果要更新表数据的话，使用UPDATE子句 1UPDATE customers SET cust_name ='happy',cust_email='happy@gmail.com' WHERE cust_id = 1001; 注意：如果不加WHERE条件指定到某一行的话，会更新表中某一列全部的数据。 删除表数据 如果从表中删除数据的话，可以使用DELETE子句 1DELETE FROM customers WHERE cust_id = 10086; 删除的数据必定是表中行数据，而不是某一列。因此，与UPDATE子句相比，DELETE子句并不需要指定是哪一列，而仅仅只需要指定具体的表名即可; 注意：如果不添加WHERE指定条件的话，会将整个表中所有行数据全部删除。另外，DELETE只是删除表中的数据，而不会删除表结构信息； 如果想删除表中全部的数据，可以使用TRUNCATE，比DELETE删除效率更高； 1TRUNCATE table_name; SQL中关键字执行顺序在SQL语句中每个关键字都会按照顺序往下执行，而每一步操作，会生成一个虚拟表，最后产生的虚拟表会作为执行的最终结果返回。下面的是常用的关键字的执行顺序： 12345678910(8)SELECT (9)DISTINCT&lt;select_list&gt;(1)FROM &lt;left_table&gt;(3)&lt;join_type&gt; JOIN &lt;right_table&gt;(2)ON &lt;join_condition&gt;(4)WHERE &lt;where_condition&gt;(5)GROUP BY&lt;group_by_list&gt;(6)WITH&#123;CUBE|ROLLUP&#125;(7)HAVING&lt;having_condition&gt;(10)ORDER BY&lt;order_by_list&gt;(11)LIMIT&lt;limit_number&gt; FROM：对FROM左边的表和右边的表计算笛卡尔积，产生虚表VT1； ON：对虚拟表VT1进行ON筛选，只有那些符合&lt;join_condition&gt;条件的行才会被记录在虚拟表VT2中； JOIN：如果是OUT JOIN，那么将保留表中（如左表或者右表）未匹配的行作为外部行添加到虚拟表VT2中，从而产生虚拟表VT3； WHERE:对虚拟表VT3进行WHERE条件过滤，只有符合&lt;where_condition&gt;的记录才会被放入到虚拟表VT4； GROUP BY：根据GROUP BY子句中的列，对虚拟表VT4进行分组操作，产生虚拟表VT5； CUBE|ROLLUP：对虚拟表VT5进行CUBE或者ROLLUP操作，产生虚拟表VT6； HAVING：对虚拟表VT6进行HAVING条件过滤，只有符合&lt;having_condition&gt;的记录才会被插入到虚拟表VT7中； SELECT：执行SELECT操作，选择指定的列，插入到虚拟表VT8中； DISTINCT：对虚拟表VT8中的记录进行去重，产生虚拟表VT9； ORDER BY：将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10； LIMIT：取出指定行的记录，产生虚拟表VT11，并将结果返回。 索引MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 索引分单列索引和组合索引:单列索引，即一个索引只包含单个列，而组合索引，即一个索引包含多个列。 创建索引创建索引有两种方式，一种是直接利用CREATE INDEX进行创建，另外一种则是通过修改表结构来进行添加，则是利用ALTER TABLE语句。 使用CREATE INDEX123CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name[USING index_type]ON table_name (index_col_name,...) 其中对应的语法变量信息如下： [UNIQUE|FULLTEXT|SPATIAL] 其中括号中的这三个关键字表示创建的索引类型，它们分别表示唯一索引、全文索引、空间索引三种不同的索引类型。如果我们不指定任何关键字，则默认为普通索引。 index_name index_name表示索引的名称，由用户自行定义，以便于以后对该索引进行修改等管理操作。 index_type index_type表示索引的具体实现方式，在MySQL中，有两种不同形式的索引——BTREE索引和HASH索引在存储引擎为MyISAM和InnoDB的表中只能使用BTREE，其默认值就是BTREE；在存储引擎为MEMORY或者HEAP的表中可以使用HASH和BTREE两种类型的索引，其默认值为HASH。 index_col_name index_col_name表示需要创建索引的字段名称，我们还可以针对多个字段创建复合索引，只需要在多个字段名称之间以英文逗号隔开即可此外，对于CHAR或VARCHAR类型的字段，我们还可以只使用字段内容前面的一部分来创建索引，只需要在对应的字段名称后面加上形如(length)的指令即可，表示只需要使用字段内容前面的length个字符来创建索引。在这里，我们以customers表的cust_name字段(类型为VARCHAR(50))为例，使用cust_name字段的6个字符前缀来创建索引。 1CREATE INDEX idx_cust_name ON user (cust_name(6)); 使用ALTER TABLE123ALTER TABLE table_nameADD [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name (index_col_name,...) [USING index_type] 删除索引删除指定表中指定名称的索引，语法为： 12ALTER TABLE table_nameDROP INDEX index_name; 例如删除名称为idx_cust_name的索引，其SQL语句为： 12ALTER TABLE customersDROP INDEX idx_cust_name; 修改索引在MySQL中并没有提供修改索引的直接指令，一般情况下，我们需要先删除掉原索引，再根据需要创建一个同名的索引，从而变相地实现修改索引操作。 12345// 先删除ALTER TABLE userDROP INDEX idx_user_username;// 再以修改后的内容创建同名索引CREATE INDEX idx_cust_name ON customers (cust_name(8)); 查看索引在MySQL中，要查看某个数据库表中的索引也非常简单，只需要使用以下两个命令中的任意一种即可。 1234// 如果查看索引前，没有使用user db_name等命令指定具体的数据库，则必须加上FROM db_nameSHOW INDEX FROM table_name [FROM db_name]// 如果查看索引前，没有使用user db_name等命令指定具体的数据库，则必须加上db_name.前缀SHOW INDEX FROM [db_name.]table_name 存储过程 什么是存储过程？ 存储过程简单来说，就是为了复用性或者实现复杂的业务功能，而保存的一条或多条MySQL语句的集合，可将其视为批文件； 为什么使用存储过程？ （1）通过把处理封装在容易使用的单元中，简化复杂的操作；（2）由于不要求反复建立一系列处理步骤，这保证了数据的完整性，如果所有的开发人员和应用程序都使用同一存储过程，则所使用的代码都是相同的；（3）简化对变动的管理。如果表名、列名或业务逻辑有变化，只需要更改存储过程的代码，使用它的开发人员甚至不需要知道这些变化，也就是具备了安全性；（4）提高了性能，因为使用存储过程比单独使用SQL语句要快；（5）存储过程可用来编写功能更灵活的代码。 因此，存储过程的具备三个特性:简单可复用、安全以及高性能； 存储过程的缺点？ （1）存储过程编写比基本的SQL语句更加复杂，需要更高的技能；（2）可能没有创建存储过程的权限，数据库管理员可能会限制创建存储过程的权限，允许用户使用存储过程，而不允许用户自由创建存储过程； 创建存储过程 创建存储过程。如需要统计用户订单总金额，如果该用户需要交税的话，订单总金额则需要再加上税费 123456789101112131415161718192021222324252627DELIMITER //CREATE PROCEDURE ordertotal(IN custid INT,IN taxable BOOLEAN,OUT ototal DECIMAL(8,2))COMMENT 'obtain total order price'BEGIN/*declare variable for total*/DECLARE total DECIMAL(8,2);DECLARE taxrate INT DEFAULT 6;/*get the order total*/SELECT SUM(item_price*item_quantity) INTO totalFROM customersWHERE cust_id = custid;/*is this taxable?*/IF taxable THEN SELECT total+(total/100*taxrate) INTO total;END IF;SELECT total INTO ototal;END // 有这样一些细节: 使用CREATE PROCEDURE语句进行创建，()圆括号中为存储过程的参数，其中参数类型有： IN类型，表示传递给存储过程 OUT类型，表示存储过程返回的结果，在调用存储过程时需要传入@开始的变量 INOUT类型，表示在存储过程中可以传入和传出 DECLARE用来声明一个变量，如这里的total，taxrate。注意MySQL中定义变量时都是变量名在前，数据类型在后 存储过程具体逻辑写在BEGIN END之间 将值赋给变量使用INTO关键字 由于存储过程中每个SQL语句中用；作为分隔符，会和单个SQL造成冲突，因此可使用DELIMITER重新定义分类符，如该例子中定义//为分隔符，自然存储过程结尾就用END //结尾，而不再是END。同时，分隔符//成对出现后，恢复到默认的”;”作为分隔符 执行存储过程 使用CALL子句执行存储过程，CALL子句接受存储过程的名称以及需要传递的参数。 12CALL ordertotal(1,TRUE,@total);SELECT @total; 如果存储过程中定义了OUT类型的输入参数，那么在执行存储过程时需要传入变量，如这里@total，并且变量都是用 @ 开始的。如果存储过程中没有参数的话，就用空圆括号表示即可，CALL ordertotal()； 删除存储过程 删除存储过程，可以使用DROP PROCEDURE子句。如DROP PROCEDURE ordertotal； 查询存储过程 显示创建一个存储过程的语句，可以使用SHOW CREATE PROCEDURE。如SHOW CREATE PROCEDURE ordertotal； 查询所有存储过程的状态，如果在定义存储过程中使用COMMENT添加注释，可以查看。同时可以LIKE进行过滤结果。如SHOW PROCEDURE STATUS LIKE &#39;%order%&#39;; 事务处理 什么是事务？ 事务处理是用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。事务处理是一种机制，用来管理必须成批执行的MySQL操作，它们要么时作为整体执行或者完全不执行。 关键概念： 事务：是指一组SQL语句； 回退：是指撤销指定的SQL语句的过程； 提交：指将未存储的SQL语句的结果写入数据库表中 保留点：指事务处理中设置的临时占位符，可以对它发布回退； 如何创建执行事务？ 123456START TRANSACTION;INSERT INTO customers (cust_name,item_price,item_quantity) VALUES ('1',5,18);SELECT * FROM customers;SAVEPOINT insertinto;INSERT INTO customers (cust_name,item_price,item_quantity) VALUES ('2',5,18);ROLLBACK TO insertinto; 执行结果为：插入数据(‘1’,5,18)有效，因为，只会从保留点SAFEPOINT之后开始回退，也就是说保留点SAFEPOINT之前的SQL语句执行的结果仍然有效。 有这样一些细节： STAET TRANSACTION用来表示下面的SQL语句集为一段事务 SAFEPOINT 用于指定保留点insertinto ROLLBACK TO表示从指定保留点开始回退，也就是说保留点之前的SQL语句执行结果依然有效。如果仅仅使用ROLLBACK进行回退的话就表示从STAET TRANSACTION之后所有的SQL语句执行效果都会撤销 MySQL提交（写或保存）操作是自动进行的，这称之为隐含提交。但是在事务处理块中，提交不会隐含进行，要使用COMMIT子句进行提交。如： 1234START TRANSACTION;INSERT INTO customers (cust_name,item_price,item_quantity) VALUES ('1',5,18);INSERT INTO customers (cust_name,item_price,item_quantity) VALUES ('2',5,18);COMMIT; 采用COMMIT提交事务，如果两条SQL语句都执行成功，才会将数据都写入表中。 触发器什么是触发器? 当某条SQL语句发生时，自动执行某些其他的SQL语句的时候就需要使用到触发器。触发器只能响应：DELETE, INSERT, UPDATE这三个特定操作。 创建触发器?创建触发器时需要给出最重要的四条信息： 1.全局唯一的触发器名；2.触发器关联的表；3.触发器在何时执行（操作执行之前或者之后）4.触发器应该响应的活动（DELETE, INSERT或者UPDATE）; 由于触发器只能响应特定的三种类型的操作，因此可创建的触发器也就三种类型: INSERT触发器，DELETE触发器以及UPDATE触发器。 INSERT触发器在执行INSERT触发器时，也这样几点需要注意: 在INSERT触发器代码内，可以引用一个名为NEW的虚拟表，可以用NEW来访问刚插入的行数据 在BEFORE INSERT触发器中，NEW中的值可以被更新 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自定生成值。 创建一个INSERT触发器，每次插入一行数据，每次会返回当前插入的行数据的id。 1234567/*创建触发器*/CREATE TRIGGER insertcustomers AFTER INSERT ON customersFOR EACH ROW SELECT NEW.cust_id INTO @newinsertid;/*执行触发器*/INSERT INTO customers (cust_name,item_price,item_quantity) VALUES ('2',5,18);SELECT @newinsertid; 有这样一些细节： 使用CREATE TRIGGER来创建触发器; AFTER INSERT表明在插入行数据之后，触发器才会执行特征操作; FOR EACH ROW 表示对插入的每一行数据，触发器都起作用; 针对INSERT触发器，可以使用虚拟表NEW，来使用刚插入的行数据。比如例子中，SELECT NEW.cust_id INTO @newinsertid表示将新插入的行数据的id赋值给变量@newinsertid； DELETE触发器DELETE触发器在DELETE语句执行之前或者之后，需要知道以下两点： 在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，来访问被删除的行； OLD表中的数据只能读，不能被更新，而在INSERT触发器中，就可以通过NEW来更新被插入的行数据； 例如，针对customers表，当删除一行数据时，返回被删除数据的cust_id以及cust_name: 1234567891011121314/*创建DELETE触发器*/ DELIMITER //CREATE TRIGGER insertcustomers AFTER DELETE ON customersFOR EACH ROW BEGIN SELECT OLD.cust_name INTO @deletecustname; SELECT OLD.cust_id INTO @deletecustid;END ///*调用DELETE触发器*/DELETE FROM customers WHERE cust_id = 3;SELECT @deletecustname;SELECT @deletecustid; 基本上与创建INSERT触发器一样，只不过在DELETE触发器中只能使用OLD来访问被删除的行数据。 UPDATE触发器UPDATE触发器在UPDATE语句执行之前或者之后执行，需要知道一下几点： 在BEFORE UPDATE触发器中可以使用NEW和OLD来访问数据，而在AFTER UPDATE触发器中使用NEW来访问数据会报错，只能使用OLD来访问数据； 在BEFORE UPDATE触发器中，NEW中的值可以被改变，即允许更改将用于UPDATE的数据； OLD中的行数据只能读，不能被更新； 一个UPDATE触发器示例如下： 12345678910111213141516/*创建UPDATE触发器*/DELIMITER //CREATE TRIGGER insertcustomers BEFORE UPDATE ON customersFOR EACH ROW BEGIN SELECT NEW.cust_name INTO @beforeupdate;SET NEW.cust_name = 'reset_name';SELECT OLD.cust_name INTO @afterupdate;END ///*调用UPDATE触发器*/UPDATE customers SET cust_name = 'happy' WHERE cust_id = 5;SELECT @beforeupdate;SELECT @afterupdate; 输出为@beforeupdate为‘happay’，而@afterupdate为&#39;reset_name&#39;。有这样一些细节： NEW虚拟表中的数据可以更改，如这里采用 SET NEW.cust_name = &#39;reset_name&#39;;，将待更新的cust_name由“happy”变成了“reset_name”； 在BEFORE UPDATE触发器中可以使用NEW和OLD来访问数据，而在AFTER UPDATE触发器中使用NEW来访问数据会报错； 删除触发器?删除触发器，可以使用 DROP TRIGGER 语句，比如DROP TRIGGER insertcustomers;。触发器不能更新或者覆盖，如果要修改触发器，必须删除这个触发器。 参考 MySQL命令，一篇文章替你全部搞定","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"事务","slug":"事务","permalink":"http://blog.caoxl.com/tags/事务/"},{"name":"触发器","slug":"触发器","permalink":"http://blog.caoxl.com/tags/触发器/"}]},{"title":"PHP 生成动态GIF验证码","slug":"PHP-Qrcode-Gif","date":"2018-11-08T06:54:56.000Z","updated":"2018-11-08T08:05:32.000Z","comments":true,"path":"2018/11/08/PHP-Qrcode-Gif/","link":"","permalink":"http://blog.caoxl.com/2018/11/08/PHP-Qrcode-Gif/","excerpt":"生成一个有意思的动态gif验证码, 来自阿鸡的博客PHP动态gif验证码","text":"生成一个有意思的动态gif验证码, 来自阿鸡的博客PHP动态gif验证码 效果 源码主函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?phpfunction ImageCode( $string = '', $frames = 60, $time = 1, $width = 75, $height = 25, $font = 6, $loops = 0) &#123; $auth_str = $string ?: (time() % 2 == 0) ? mt_rand(1000, 9999) : mt_rand(10000, 99999); $board_width = $width; $board_height = $height; $delay = $time * 1000 / $frames; // 生成一个N帧的GIF动画 for ($i = 0; $i &lt; $frames; $i++) &#123; ob_start(); $image = imagecreate($board_width, $board_height); imagecolorallocate($image, 0, 0, 0); // 设定文字颜色数组 $colorList[] = imagecolorallocate($image,15,73,210); $colorList[] = imagecolorallocate($image,0,64,0); $colorList[] = imagecolorallocate($image,0,0,64); $colorList[] = imagecolorallocate($image,0,128,128); $colorList[] = imagecolorallocate($image,27,52,47); $colorList[] = imagecolorallocate($image,51,0,102); $colorList[] = imagecolorallocate($image,0,0,145); $colorList[] = imagecolorallocate($image,0,0,113); $colorList[] = imagecolorallocate($image,0,51,51); $colorList[] = imagecolorallocate($image,158,180,35); $colorList[] = imagecolorallocate($image,59,59,59); $colorList[] = imagecolorallocate($image,0,0,0); $colorList[] = imagecolorallocate($image,1,128,180); $colorList[] = imagecolorallocate($image,0,153,51); $colorList[] = imagecolorallocate($image,60,131,1); $colorList[] = imagecolorallocate($image,0,0,0); $gray = imagecolorallocate($image, 245, 245, 245); imagefill($image, 0, 0, $gray); $space = $font * 0.65; // 字符间距 $len = strlen($auth_str); for ($k = 0; $k &lt; $len; $k++) &#123; $colorRandom = mt_rand(0, sizeof($colorList) - 1); $float_top = rand(0, 4); $float_left = rand(1, 4); imagettftext( $image, $font, 0, $space*$k + $float_left, $font + $float_top, $colorList[$colorRandom], './fonts/comic.ttf', substr($auth_str, $k, 1) ); &#125; for ($k = 0; $k &lt; 20; $k++) &#123; $colorRandom = mt_rand(0, sizeof($colorList) - 1); imagesetpixel($image, rand() % 70, rand() % 15, $colorList[$colorRandom]); &#125; // 添加干扰线 for ($k = 0; $k &lt; 3; $k++) &#123; $colorRandom = mt_rand(0, sizeof($colorList) - 1); $to_draw_line = 1; if ($to_draw_line) &#123; imageline($image, mt_rand(0, $board_width), mt_rand(0, $board_height), mt_rand(0, $board_width), mt_rand(0, $board_height), $colorList[$colorRandom]); &#125; else &#123; $w = mt_rand(0, $board_width); $h = mt_rand(0, $board_height); imagearc($image, $board_width - floor($w / 2), floor($h / 2), $w, $h, rand(90, 180), rand(180, 270), $colorList[$colorRandom]); &#125; &#125; imagegif($image); imagedestroy($image); $imageData[] = ob_get_contents(); $delays[] = $delay; ob_clean(); &#125; return new AnimatedGif($imageData, $delays, $loops);&#125; AnimatedGif类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234&lt;?phpclass AnimatedGif&#123; /** * The built gif image * @var resource */ private $image = ''; /** * The array of images to stack * @var array */ private $buffer = Array(); /** * How many times to loop? 0 = infinite * @var int */ private $number_of_loops = 0; /** * * @var int */ private $DIS = 2; /** * Which colour is transparent * @var int */ private $transparent_colour = -1; /** * Is this the first frame * @var int */ private $first_frame = TRUE; /** * Encode an animated gif * AnimatedGif constructor. * @param array $source_images * @param array $image_delays * @param $number_of_loops */ function __construct( array $source_images, array $image_delays, $number_of_loops ) &#123; /** * I have no idea what these even do, they appear to do nothing to the image so far */ $transparent_colour_red = 0; $transparent_colour_green = 0; $transparent_colour_blue = 0; $this-&gt;number_of_loops = ( $number_of_loops &gt; -1 ) ? $number_of_loops : 0; $this-&gt;set_transparent_colour($transparent_colour_red, $transparent_colour_green, $transparent_colour_blue); $this-&gt;buffer_images($source_images); $this-&gt;addHeader(); for ($i = 0; $i &lt; count($this-&gt;buffer); $i++) &#123; $this-&gt;addFrame($i, $image_delays [$i]); &#125; &#125; /** * Set the transparent colour * @param int $red * @param int $green * @param int $blue */ private function set_transparent_colour($red, $green, $blue)&#123; $this-&gt;transparent_colour = ( $red &gt; -1 &amp;&amp; $green &gt; -1 &amp;&amp; $blue &gt; -1 ) ? ( $red | ( $green &lt;&lt; 8 ) | ( $blue &lt;&lt; 16 ) ) : -1; &#125; /** * Buffer the images and check to make sure they are vaild * @param $source_images */ private function buffer_images($source_images) &#123; for ($i = 0; $i &lt; count($source_images); $i++) &#123; $this-&gt;buffer [] = $source_images [$i]; if (substr($this-&gt;buffer [$i], 0, 6) != \"GIF87a\" &amp;&amp; substr($this-&gt;buffer [$i], 0, 6) != \"GIF89a\") &#123; throw new Exception('Image at position ' . $i. ' is not a gif'); &#125; for ($j = ( 13 + 3 * ( 2 &lt;&lt; ( ord($this-&gt;buffer [$i] &#123; 10 &#125;) &amp; 0x07 ) ) ), $k = TRUE; $k; $j++) &#123; switch ($this-&gt;buffer [$i] &#123; $j &#125;) &#123; case \"!\": if (( substr($this-&gt;buffer [$i], ( $j + 3), 8) ) == \"NETSCAPE\") &#123; throw new Exception('You cannot make an animation from an animated gif.'); &#125; break; case \";\": $k = FALSE; break; &#125; &#125; &#125; &#125; /** * Add the gif header to the image */ private function addHeader() &#123; $cmap = 0; $this-&gt;image = 'GIF89a'; if (ord($this-&gt;buffer [0] &#123; 10 &#125;) &amp; 0x80) &#123; $cmap = 3 * ( 2 &lt;&lt; ( ord($this-&gt;buffer [0] &#123; 10 &#125;) &amp; 0x07 ) ); $this-&gt;image .= substr($this-&gt;buffer [0], 6, 7); $this-&gt;image .= substr($this-&gt;buffer [0], 13, $cmap); $this-&gt;image .= \"!\\377\\13NETSCAPE2.0\\3\\1\" . $this-&gt;word($this-&gt;number_of_loops) . \"\\0\"; &#125; &#125; /** * Add a frame to the animation * @param int $frame The frame to be added * @param int $delay The delay associated with the frame */ private function addFrame($frame, $delay) &#123; $Locals_str = 13 + 3 * ( 2 &lt;&lt; ( ord($this-&gt;buffer [$frame] &#123; 10 &#125;) &amp; 0x07 ) ); $Locals_end = strlen($this-&gt;buffer [$frame]) - $Locals_str - 1; $Locals_tmp = substr($this-&gt;buffer [$frame], $Locals_str, $Locals_end); $Global_len = 2 &lt;&lt; ( ord($this-&gt;buffer [0] &#123; 10 &#125;) &amp; 0x07 ); $Locals_len = 2 &lt;&lt; ( ord($this-&gt;buffer [$frame] &#123; 10 &#125;) &amp; 0x07 ); $Global_rgb = substr($this-&gt;buffer [0], 13, 3 * ( 2 &lt;&lt; ( ord($this-&gt;buffer [0] &#123; 10 &#125;) &amp; 0x07 ) )); $Locals_rgb = substr($this-&gt;buffer [$frame], 13, 3 * ( 2 &lt;&lt; ( ord($this-&gt;buffer [$frame] &#123; 10 &#125;) &amp; 0x07 ) )); $Locals_ext = \"!\\xF9\\x04\" . chr(( $this-&gt;DIS &lt;&lt; 2 ) + 0) . chr(( $delay &gt;&gt; 0 ) &amp; 0xFF) . chr(( $delay &gt;&gt; 8 ) &amp; 0xFF) . \"\\x0\\x0\"; if ($this-&gt;transparent_colour &gt; -1 &amp;&amp; ord($this-&gt;buffer [$frame] &#123; 10 &#125;) &amp; 0x80) &#123; for ($j = 0; $j &lt; ( 2 &lt;&lt; ( ord($this-&gt;buffer [$frame] &#123; 10 &#125;) &amp; 0x07 ) ); $j++) &#123; if ( ord($Locals_rgb &#123; 3 * $j + 0 &#125;) == ( ( $this-&gt;transparent_colour &gt;&gt; 16 ) &amp; 0xFF ) &amp;&amp; ord($Locals_rgb &#123; 3 * $j + 1 &#125;) == ( ( $this-&gt;transparent_colour &gt;&gt; 8 ) &amp; 0xFF ) &amp;&amp; ord($Locals_rgb &#123; 3 * $j + 2 &#125;) == ( ( $this-&gt;transparent_colour &gt;&gt; 0 ) &amp; 0xFF ) ) &#123; $Locals_ext = \"!\\xF9\\x04\" . chr(( $this-&gt;DIS &lt;&lt; 2 ) + 1) . chr(( $delay &gt;&gt; 0 ) &amp; 0xFF) . chr(( $delay &gt;&gt; 8 ) &amp; 0xFF) . chr($j) . \"\\x0\"; break; &#125; &#125; &#125; switch ($Locals_tmp &#123; 0 &#125;) &#123; case \"!\": $Locals_img = substr($Locals_tmp, 8, 10); $Locals_tmp = substr($Locals_tmp, 18, strlen($Locals_tmp) - 18); break; case \",\": $Locals_img = substr($Locals_tmp, 0, 10); $Locals_tmp = substr($Locals_tmp, 10, strlen($Locals_tmp) - 10); break; &#125; if (ord($this-&gt;buffer [$frame] &#123; 10 &#125;) &amp; 0x80 &amp;&amp; $this-&gt;first_frame === FALSE) &#123; if ($Global_len == $Locals_len) &#123; if ($this-&gt;blockCompare($Global_rgb, $Locals_rgb, $Global_len)) &#123; $this-&gt;image .= ( $Locals_ext . $Locals_img . $Locals_tmp ); &#125; else &#123; $byte = ord($Locals_img &#123; 9 &#125;); $byte |= 0x80; $byte &amp;= 0xF8; $byte |= ( ord($this-&gt;buffer [0] &#123; 10 &#125;) &amp; 0x07 ); $Locals_img &#123; 9 &#125; = chr($byte); $this-&gt;image .= ( $Locals_ext . $Locals_img . $Locals_rgb . $Locals_tmp ); &#125; &#125; else &#123; $byte = ord($Locals_img &#123; 9 &#125;); $byte |= 0x80; $byte &amp;= 0xF8; $byte |= ( ord($this-&gt;buffer [$frame] &#123; 10 &#125;) &amp; 0x07 ); $Locals_img &#123; 9 &#125; = chr($byte); $this-&gt;image .= ( $Locals_ext . $Locals_img . $Locals_rgb . $Locals_tmp ); &#125; &#125; else &#123; $this-&gt;image .= ( $Locals_ext . $Locals_img . $Locals_tmp ); &#125; $this-&gt;first_frame = FALSE; &#125; /** * Add the gif footer */ private function addFooter() &#123; $this-&gt;image .= \";\"; &#125; /** * Compare gif blocks? What is a block? * @param $GlobalBlock * @param $LocalBlock * @param $Len * @return int */ private function blockCompare($GlobalBlock, $LocalBlock, $Len) &#123; for ($i = 0; $i &lt; $Len; $i++) &#123; if ( $GlobalBlock &#123; 3 * $i + 0 &#125; != $LocalBlock &#123; 3 * $i + 0 &#125; || $GlobalBlock &#123; 3 * $i + 1 &#125; != $LocalBlock &#123; 3 * $i + 1 &#125; || $GlobalBlock &#123; 3 * $i + 2 &#125; != $LocalBlock &#123; 3 * $i + 2 &#125; ) &#123; return ( 0 ); &#125; &#125; return ( 1 ); &#125; /** * No clue * @param int $int * @return string the char you meant? */ private function word($int) &#123; return ( chr($int &amp; 0xFF) . chr(( $int &gt;&gt; 8 ) &amp; 0xFF) ); &#125; /** * Return the animated gif * @return resource */ function getAnimation() &#123; return $this-&gt;image; &#125; /** * Return the animated gif * @echo image */ function display() &#123; //late footer add $this-&gt;addFooter(); header('Content-type:image/gif'); echo $this-&gt;image; &#125;&#125; 使用示例代码: 1234567891011$str = 'abcdefghijkmnpqrstuvwxy3456789';$len = strlen($str) - 1;$text = '';for ($i = 0; $i &lt; 6; $i++) &#123; $text .= $str[rand(0, $len)];&#125;$gif = ImageCode($text, 8, 1, 100, 35, 23);$gif-&gt;display(); 参考 PHP动态gif验证码","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"GIF","slug":"GIF","permalink":"http://blog.caoxl.com/tags/GIF/"},{"name":"验证码","slug":"验证码","permalink":"http://blog.caoxl.com/tags/验证码/"}]},{"title":"Linux 运维常用命令总结","slug":"Linux-operation-cmd","date":"2018-11-08T01:55:01.000Z","updated":"2018-11-08T02:53:55.000Z","comments":true,"path":"2018/11/08/Linux-operation-cmd/","link":"","permalink":"http://blog.caoxl.com/2018/11/08/Linux-operation-cmd/","excerpt":"网上收集的,实际运用的不多,毕竟我不是一个运维.","text":"网上收集的,实际运用的不多,毕竟我不是一个运维. 删除0字节文件 12find -type f -size 0 -exec rm -rf &#123;&#125; \\;// &#123;&#125; 和 \\ 中间有空格!!! 查看进程: 按内存从大到小排列 1ps -e -o \"%C : %p : %z : %a\"|sort -k5 -nr 按cpu利用率从大到小排列 1ps -e -o \"%C : %p : %z : %a\"|sort -nr 打印cache里的URL 1grep -r -a jpg /data/cache/* | strings | grep \"http:\" | awk -F'http:' '&#123;print \"http:\"$2;&#125;' 查看http的并发请求数及其TCP连接状态 12[root@caoxl ~]# netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'ESTABLISHED 10 如何杀掉mysql进程 1ps aux |grep mysql |grep -v grep |awk '&#123;print $2&#125;' |xargs kill -9 显示运行3级别开启的服务 1ls /etc/rc3.d/S* |cut -c 15- 取IP地址 12[root@caoxl ~]# ifconfig eth0 |grep \"inet\" |awk '&#123;print $2&#125;'|cut -c 1- 172.31.45.94 查看内存大小 1free -m |grep \"Mem\" | awk '&#123;print $2&#125;' 查看Apache的并发请求数及其TCP连接状态 1netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;' 统计一下服务器下面所有的jpg的文件的大小 12[root@caoxl ~]# find / -name *.jpg -exec wc -c &#123;&#125; \\;|awk '&#123;print $1&#125;'|awk '&#123;a+=$1&#125;END&#123;print a&#125;'25872544 CPU负载 123[root@caoxl ~]# cat /proc/loadavg0.07 0.08 0.07 2/171 2683// 检查前三个输出值是否超过了系统逻辑CPU的4倍。 12345678[root@caoxl ~]# mpstat 1 1Linux 3.10.0-862.9.1.el7.x86_64 (caoxl) 11/08/2018 _x86_64_ (1 CPU)10:18:06 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle10:18:07 AM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00Average: all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00// 检查%idle是否过低(比如小于5%) 内存空间 1234[root@caoxl ~]# free total used free shared buff/cache availableMem: 1015436 372240 75896 2660 567300 436428Swap: 0 0 0 检查free值是否过低 也可以用 # cat /proc/meminfo swap空间 // free 检查swap used值是否过高 如果swap used值过高，进一步检查swap动作是否频繁： 12345678[root@caoxl ~]# vmstat 1 5procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 4 0 0 75836 216256 351220 0 0 1 3 2 4 0 0 100 0 0 0 0 0 75492 216256 351256 0 0 0 0 306 362 1 0 99 0 0 0 0 0 75556 216256 351192 0 0 0 0 282 327 0 0 100 0 0 0 0 0 75560 216256 350996 0 0 0 0 326 347 0 0 100 0 0 0 0 0 76024 216256 351152 0 0 0 0 368 369 1 1 98 0 0 观察si和so值是否较大 磁盘空间 12345678[root@caoxl ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 8.3G 29G 23% /devtmpfs 486M 0 486M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 524K 496M 1% /runtmpfs 496M 0 496M 0% /sys/fs/cgrouptmpfs 100M 0 100M 0% /run/user/0 检查是否有分区使用率(Use%)过高(比如超过90%) 如发现某个分区空间接近用尽，可以进入该分区的挂载点，用以下命令找出占用空间最多的文件或目录 123456[root@caoxl ~]# du -cks * | sort -rn | head -n 1036644 total26428 letsencrypt9764 redis-4.0.2368 curl84 test 磁盘I/O负载 1234567891011121314[root@caoxl ~]# iostat -x 1 2Linux 3.10.0-862.9.1.el7.x86_64 (caoxl) 11/08/2018 _x86_64_ (1 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.22 0.01 0.15 0.02 0.00 99.60Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.22 0.04 0.40 0.71 3.25 17.90 0.00 3.92 5.24 3.79 0.52 0.02avg-cpu: %user %nice %system %iowait %steal %idle 0.00 0.00 0.00 2.00 0.00 98.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 1.00 0.00 8.00 0.00 16.00 0.01 15.00 15.00 0.00 15.00 1.50 网络负载 1234567891011121314151617181920[root@caoxl ~]# sar -n DEVLinux 3.10.0-862.9.1.el7.x86_64 (caoxl) 11/08/2018 _x86_64_ (1 CPU)12:00:02 AM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s12:10:01 AM eth0 100.37 46.98 86.98 83.42 0.00 0.00 0.0012:10:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0012:20:01 AM eth0 187.65 100.08 149.14 170.11 0.00 0.00 0.0012:20:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0012:30:01 AM eth0 85.36 49.59 66.09 78.49 0.00 0.00 0.0012:30:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0012:40:01 AM eth0 0.22 0.19 0.02 0.03 0.00 0.00 0.0012:40:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0012:50:01 AM eth0 0.27 0.28 0.02 0.05 0.00 0.00 0.0012:50:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:00:01 AM eth0 0.21 0.21 0.02 0.04 0.00 0.00 0.0001:00:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:10:01 AM eth0 0.21 0.18 0.01 0.02 0.00 0.00 0.0001:10:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0001:20:01 AM eth0 0.25 0.21 0.02 0.04 0.00 0.00 0.0001:20:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 检查网络流量(rxbyt/s, txbyt/s)是否过高 网络错误 12345[root@caoxl ~]# netstat -iKernel Interface tableIface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flgeth0 1500 34523059 0 0 0 22681911 0 0 0 BMRUlo 65536 39633 0 0 0 39633 0 0 0 LRU 检查是否有网络错误(drop fifo colls carrier) 也可以用命令: 12345[root@caoxl ~]# cat /proc/net/devInter-| Receive | Transmit face |bytes packets errs drop fifo frame compressed multicast|bytes packets errs drop fifo colls carrier compressed eth0: 25713047703 34537250 0 0 0 0 0 0 27008140200 22688234 0 0 0 0 0 0 lo: 19237141 39633 0 0 0 0 0 0 19237141 39633 0 0 0 0 0 0 网络连接数目 12345[root@caoxl ~]# netstat -an | grep -E \"^(tcp)\" | cut -c 68- | sort | uniq -c | sort -n 1 ESTABLISHED 1 TIME_WAIT 8 LISTEN 11 ESTABLISHED 进程总数 12[root@caoxl ~]# ps aux | wc -l91 检查进程个数是否正常 (比如超过250) 可运行进程数目 1234567procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 97868 91556 454388 0 0 1 3 2 4 0 0 100 0 0 0 0 0 97868 91556 454380 0 0 0 0 266 357 1 0 99 0 0 0 0 0 97744 91560 454376 0 0 12 0 276 375 0 1 97 2 0 0 0 0 97744 91560 454388 0 0 0 0 262 345 0 0 100 0 0 0 0 0 97728 91560 454388 0 0 0 0 259 337 1 0 99 0 0 进程:观察是否有异常进程出现 1top -id 1 用户: 检查登录用户是否过多 1234[root@caoxl ~]# who | wc -l1[root@caoxl ~]# uptime 10:40:42 up 97 days, 1:01, 1 user, load average: 0.00, 0.04, 0.05 系统日志 1cat /var/log/*errors 核心日志: 检查是否有异常错误记录 1dmesg 打开文件数目 12[root@caoxl log]# lsof | wc -l10902 查看80端口相关的进程 12345[root@caoxl log]# lsof -i :80COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 2277 root 8u IPv4 734951 0t0 TCP *:http (LISTEN)nginx 2278 www 8u IPv4 734951 0t0 TCP *:http (LISTEN)AliYunDun 4092 root 37u IPv4 2927506 0t0 TCP caoxl:47014-&gt;100.100.30.25:http (ESTABLISHED) 杀掉80端口相关的进程 1lsof -i :80|grep -v \"ID\"|awk '&#123;print \"kill -9\",$2&#125;'|sh 清除僵死进程 1ps -eal | awk '&#123; if ($2 == \"Z\") &#123;print $4&#125;&#125;' | kill -9 tcpdump 抓包 ，用来防止80端口被人攻击时可以分析数据 1tcpdump -c 10000 -i eth0 -n dst port 80 &gt; /root/pkts 然后检查IP的重复数 并从小到大排序 注意 “-t\\ +0” 中间是两个空格 1less pkts | awk &#123;'printf $3\"\\n\"'&#125; | cut -d. -f 1-4 | sort | uniq -c | awk &#123;'printf $1\" \"$2\"\\n\"'&#125; | sort -n -t\\ +0 查看有多少个活动的php-cgi进程 1netstat -anp | grep php-cgi | grep ^tcp | wc -l 查看系统自启动的服务 1234567891011121314151617[root@caoxl log]# chkconfig --list | awk '&#123;if ($5==\"3:on\") print $1&#125;'Note: This output shows SysV services only and does not include native systemd services. SysV configuration data might be overridden by native systemd configuration. If you want to list systemd services use 'systemctl list-unit-files'. To see services enabled on particular target use 'systemctl list-dependencies [target]'.aegisagentwatchmysqlnetworknginxphp-fpmshadowsocks","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"运维","slug":"运维","permalink":"http://blog.caoxl.com/tags/运维/"}]},{"title":"秒杀/抢购相关问题","slug":"PHP-Rush-to-Buy-And-Second-Kill","date":"2018-11-07T07:51:48.000Z","updated":"2019-08-22T07:02:22.000Z","comments":true,"path":"2018/11/07/PHP-Rush-to-Buy-And-Second-Kill/","link":"","permalink":"http://blog.caoxl.com/2018/11/07/PHP-Rush-to-Buy-And-Second-Kill/","excerpt":"秒杀/抢购是做商城不可避免要遇到的问题.","text":"秒杀/抢购是做商城不可避免要遇到的问题. 秒杀/抢购带来的问题抢购、秒杀、抽奖、抢票等一般都会出现以下问题 对现有网站业务造成冲击，秒杀活动只是网站营销的一个附加活动，这个活动具有时间短，并发访问量大的特点，如果和网站原有应用部署在一起，必然会对现有业务造成冲击，稍有不慎可能导致整个网站瘫痪。 解决方案：将秒杀系统独立部署，甚至使用独立域名，使其与网站完全隔离。 用户在秒杀开始前，通过不停刷新页面以保证不会错过秒杀，这些请求如果按照一般的网站应用架构，访问应用服务器、连接数据库，会对应用服务器和数据库服务器造成负载压力。 解决方案：重新设计秒杀商品页面，不使用网站原来的商品详细页面，商品相关数据使用缓存，商品页面内容静态化 假设商品页面大小200K（主要是商品图片大小），那么需要的网络和服务器带宽是2G（200K×10000），这些网络带宽是因为秒杀活动新增的，超过网站平时使用的带宽。 解决方案：因为秒杀新增的网络带宽，必须和运营商重新购买或者租借。为了减轻网站服务器的压力，需要将秒杀商品页面缓存在CDN，同样需要和CDN服务商临时租借新增的出口带宽。 超卖现象，库存数量是有限的，如果同时下单人数超过了库存数量，就会导致商品超卖问题 解决方案：要解决“超抢/超卖”的问题，核心在于保证检查库存时的操作是依次执行的，也就是串行的，即使有很多用户同时到达，也是一个个检查并给与抢购资格，一旦库存抢尽，后面的用户就无法继续了。 1234567891011121314151617//下面是伪代码//开抢前redis设置商品总库存list列表for($i = 0; $i &lt; $goods_store; $i++) \\Redis::lpush('goods_store',1);//开启秒杀$user_id = \\Session::get('user_id'); //当前抢购用户id$count = \\Redis::lpop('goods_store'); //移出并获取列表的第一个元素 相当于商品总库存减去1 这里是原子性操作 不存在并发问题if(!$count) return '已经抢光了哦';$result = \\Redis::lpush('order:1',$user_id);// 记录抢购成功信息if($result) 返回给前端 抢购成功 然后跳转另一个页面下单处理 秒杀业务分析 正常电子商务流程（1）查询商品；（2）创建订单；（3）扣减库存；（4）更新订单；（5）付款；（6）卖家发货 秒杀业务的特性（1）低廉价格；（2）大幅推广；（3）瞬时售空；（4）一般是定时上架；（5）时间短、瞬时并发量高； 秒杀架构原则 尽量将请求拦截在系统上游传统 秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小【一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0】 读多写少的常用多使用缓存 这是一个典型的读多写少的应用场景【一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%】，非常适合使用缓存。 秒杀架构设计前端层设计首先要有一个展示秒杀商品的页面， 在这个页面上做一个秒杀活动开始的倒计时， 在准备阶段内用户会陆续打开这个秒杀的页面， 并且可能不停的刷新页面。这里需要考虑两个问题： 第一个是秒杀页面的展示我们知道一个html页面还是比较大的，即使做了压缩，http头和内容的大小也可能高达数十K，加上其他的css， js，图片等资源，如果同时有几千万人参与一个商品的抢购，一般机房带宽也就只有1G~10G，网络带宽就极有可能成为瓶颈， 所以这个页面上各类静态资源首先应分开存放，然后放到cdn节点上分散压力，由于CDN节点遍布全国各地，能缓冲掉绝大部分的压力，而且还比机房带宽便宜~ 第二个是倒计时出于性能原因这个一般由js调用客户端本地时间，就有可能出现客户端时钟与服务器时钟不一致，另外服务器之间也是有可能出现时钟不一致 客户端与服务器时钟不一致可以采用客户端定时和服务器同步时间，这里考虑一下性能问题，用于同步时间的接口由于不涉及到后端逻辑，只需要将当前web服务器的时间发送给客户端就可以了，因此速度很快，就我以前测试的结果来看，一台标准的web服务器2W+QPS不会有问题，如果100W人同时刷，100W QPS也只需要50台web，一台硬件LB就可以了~，并且web服务器群是可以很容易的横向扩展的(LB+DNS轮询)，这个接口可以只返回一小段json格式的数据，而且可以优化一下减少不必要cookie和其他http头的信息，所以数据量不会很大，一般来说网络不会成为瓶颈，即使成为瓶颈也可以考虑多机房专线连通，加智能DNS的解决方案；web服务器之间时间不同步可以采用统一时间服务器的方式，比如每隔1分钟所有参与秒杀活动的web服务器就与时间服务器做一次时间同步。 浏览器层请求拦截 (1) 产品层面: 用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求; (2) JS层面: 限制用户在x秒之内只能提交一次请求; 站点层设计前端层的请求拦截，只能拦住小白用户（不过这是99%的用户哟），高端的程序员根本不吃这一套，写个for循环，直接调用你后端的http请求，怎么整？ (1) 同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面 (2) 同一个item的查询，例如手机车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面,如此限流，又有99%的流量会被拦截在站点层。 服务层设计站点层的请求拦截，只能拦住普通程序员，高级黑客，假设他控制了10w台肉鸡（并且假设买票不需要实名认证），这下uid的限制不行了吧？怎么整？ (1) 大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？ 对于写请求，做请求队列，每次只透过有限的写请求去数据层，如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”； (2) 对于读请求，还用说么？ cache来抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的； 如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。 模块设计 用户请求分发模块：使用Nginx或Apache将用户的请求分发到不同的机器上。 用户请求预处理模块：判断商品是不是还有剩余来决定是不是要处理该请求。 用户请求处理模块：把通过预处理的请求封装成事务提交给数据库，并返回是否成功。 数据库接口模块：该模块是数据库的唯一接口，负责与数据库交互，提供RPC接口供查询是否秒杀结束、剩余数量等信息。 重启与过载保护如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候，最好在入口层将流量拒绝，然后再将重启。如果是redis/memcache这种服务也挂了，重启的时候需要注意“预热”，并且很可能需要比较长的时间。 秒杀和抢购的场景，流量往往是超乎我们系统的准备和想象的。这个时候，过载保护是必要的。如果检测到系统满负载状态，拒绝请求也是一种保护措施。在前端设置过滤是最简单的方式，但是，这种做法是被用户“千夫所指”的行为。更合适一点的是，将过载保护设置在CGI入口层，快速将客户的直接请求返回。 高并发下的数据安全 我们知道在多线程写入同一个文件的时候，会存现“线程安全”的问题（多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一样的，结果和预期相同，就是线程安全的） 如果是MySQL数据库，可以使用它自带的锁机制很好的解决问题，但是，在大规模并发的场景中，是不推荐使用MySQL的。秒杀和抢购的场景中，还有另外一个问题，就是“超发”，如果在这方面控制不慎，会产生发送过多的情况。我们也曾经听说过，某些电商搞抢购活动，买家成功拍下后，商家却不承认订单有效，拒绝发货。这里的问题，也许并不一定是商家奸诈，而是系统技术层面存在超发风险导致的。 超发的原因假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。 悲观锁思路解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。 悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。 虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。 FIFO队列思路那好，那么我们稍微修改一下上面的场景，我们直接将请求放入队列中的，采用FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。 然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。 那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。 乐观锁思路 乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败 这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。 有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。 参考 秒杀系统架构分析与实战 redis实现高并发下的抢购/秒杀功能","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"高并发","slug":"高并发","permalink":"http://blog.caoxl.com/tags/高并发/"},{"name":"秒杀","slug":"秒杀","permalink":"http://blog.caoxl.com/tags/秒杀/"},{"name":"抢购","slug":"抢购","permalink":"http://blog.caoxl.com/tags/抢购/"}]},{"title":"Xdebug 断点调试","slug":"PHPStudy-PHPStorm-Xdebug-Notes","date":"2018-11-06T02:17:27.000Z","updated":"2019-08-22T03:24:59.000Z","comments":true,"path":"2018/11/06/PHPStudy-PHPStorm-Xdebug-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/11/06/PHPStudy-PHPStorm-Xdebug-Notes/","excerpt":"Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。","text":"Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。 简介 Xdebug是一个开放源代码的PHP程序调试器(即一个Debug工具)，可以用来跟踪，调试和分析PHP程序的运行状况。 下载Xdebug 如果使用的PHPStudy: 直接打开Xdebug扩展即可 别的直接下载即可: Xdebug官方网站: https://xdebug.org/download.php 配置php.ini将下载的xdebug.dll库拷贝到%PHP_HOME%/ext目录，然后打开php.ini文件添加如下配置： 123456789101112[XDebug]xdebug.profiler_append = 0xdebug.profiler_enable = 1xdebug.profiler_enable_trigger = 0xdebug.profiler_output_dir=\"D:\\app\\phpStudy\\PHPTutorial\\tmp\\xdebug\"xdebug.trace_output_dir=\"D:\\app\\phpStudy\\PHPTutorial\\tmp\\xdebug\"xdebug.remote_enable =1xdebug.remote_handler = \"dbgp\"xdebug.idekey = PHPSTORMxdebug.remote_host = \"127.0.0.1\"xdebug.remote_port = 8888zend_extension=\"D:\\app\\phpStudy\\PHPTutorial\\php\\php-5.5.38\\ext\\php_xdebug.dll\" 参数说明:123456789xdebug.profiler_append = 0xdebug.profiler_enable = 1 # 打开xdebug的性能分析器，以文件形式存储，这项配置是不能以ini_set()函数配置的，默认值为0 xdebug.profiler_output_dir =\"D:\\phpStudy\\tmp\\xdebug\" # 性能分析文件的存放位置，默认值为/tmpxdebug.trace_output_dir=\"D:\\app\\phpStudy\\PHPTutorial\\tmp\\xdebug\" # 函数调用跟踪信息输出文件目录，默认值为/tmpxdebug.remote_enable=1 # 启用远程调试xdebug.remote_handler = \"dbgp\" # 用于zend studio远程调试的应用层通信协议xdebug.idekey = PHPSTORM # IDE Keyxdebug.remote_host = \"127.0.0.1\" # Host 主机xdebug.remote_port = 8888 # 监听端口 上面下载的dll库放置位置不是固定，只要在php.ini配置文件中准确指定即可，即zend_extension配置项指向dll库文件。 Xdebug全部可用配置可参考官方的一个链接: https://xdebug.org/docs/all_settings PHPStorm设置服务器配置完成后，需要对PHPStorm作一些设置，使其能够监听到浏览器的请求。 进入File&gt;Settings&gt;PHP，设置本地的php解释器，解释器一般指的是php的二进制文件，windows下的php安装路径下的php.exe，类unix系统下就是bin/php文件 进入File&gt;Settings&gt;PHP&gt;Servers，这里要填写服务器端的相关信息 Host指的是http服务器上配置的项目的访问域名，我本地nginx/apache配置的是blackcore.test，用的是默认的80端口 进入File&gt;Settings&gt;PHP&gt;Debug，找到XDebug选项卡 Debug port 填写的是上文中，php.ini配置文件当中xdebug.remote_port那一项的值: 即端口需要设置一致. 进入File&gt;Settings&gt;PHP&gt;Debug&gt;DBGp Proxy IED key填写的值是php.ini文件中xdebug.idekey的值，Host、Port是File&gt;Settings&gt;PHP&gt;Servers中设定的Host、Port值IDE key: 查看phpinfo()中Xdebug一栏即可看到, 一般默认是PHPSTORM 点菜单栏的 Run&gt;Edit Configurations… 在弹出的窗口中添加一个调试配置： 这里有两种方式: 使用浏览器:选择PHP Web Page 或者叫 PHP Web Application 这种方式是会跳转到浏览器, 所以需要安装浏览器插件建议使用Chrome浏览器，安装 xdebug helper插件， 下载好之后点选项，IDE选PHPSTORM不过这种方式不可取, 和直接用Chrome浏览器F12调试没有什么区别. 安装浏览器插件 编辑: Run/Debug Configurations: Name: 随便起 Server: 选择上面设置中配置的Server Start URL: 可不填,默认’/‘ Browser: 选择默认Chrome 不使用浏览器:选择PHP Script 使用Xdebug","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Xdebug","slug":"Xdebug","permalink":"http://blog.caoxl.com/tags/Xdebug/"},{"name":"PHPStudy","slug":"PHPStudy","permalink":"http://blog.caoxl.com/tags/PHPStudy/"},{"name":"PHPStorm","slug":"PHPStorm","permalink":"http://blog.caoxl.com/tags/PHPStorm/"}]},{"title":"ThinkPHP3.2 前端模板相关","slug":"ThinkPHP32-Front-Template","date":"2018-11-01T02:26:41.000Z","updated":"2019-08-22T06:42:37.000Z","comments":true,"path":"2018/11/01/ThinkPHP32-Front-Template/","link":"","permalink":"http://blog.caoxl.com/2018/11/01/ThinkPHP32-Front-Template/","excerpt":"别问为啥,因为我是考古学家!公司后台是前后端不分离的.所以考古吧~","text":"别问为啥,因为我是考古学家!公司后台是前后端不分离的.所以考古吧~ 变量输出123$name = 'ThinkPHP';$this-&gt;assign('name',$name);$this-&gt;display(); 然后就可以在模板中使用： 1Hello,&#123;$name&#125;！ 普通标签默认开始标记是{，结束标记是 }。也可以通过设置TMPL_L_DELIM和TMPL_R_DELIM进行更改。例如，我们在项目配置 12'TMPL_L_DELIM'=&gt;'&lt;&#123;','TMPL_R_DELIM'=&gt;'&#125;&gt;', 模板标签的变量输出根据变量类型有所区别，刚才我们输出的是字符串变量，如果是数组变量， 123456Name：&#123;$data.name&#125;Email：&#123;$data.email&#125;// 或Name：&#123;$data['name']&#125;Email：&#123;$data['email']&#125; 如果data变量是一个对象（并且包含有name和email两个属性），那么可以用下面的方式输出： 123456Name：&#123;$data:name&#125;Email：&#123;$data:email&#125;// 或Name：&#123;$data-&gt;name&#125;Email：&#123;$data-&gt;email&#125; 系统变量系统变量输出普通的模板变量需要首先赋值后才能在模板中输出，但是系统变量则不需要，可以直接在模板中输出，系统变量的输出通常以 {$Think 打头，例如： 1234&#123;$Think.server.script_name&#125; // 输出$_SERVER['SCRIPT_NAME']变量&#123;$Think.session.user_id&#125; // 输出$_SESSION['user_id']变量&#123;$Think.get.pageNumber&#125; // 输出$_GET['pageNumber']变量&#123;$Think.cookie.name&#125; // 输出$_COOKIE['name']变量 支持输出 $_SERVER、$_ENV、 $_POST、 $_GET、 $_REQUEST、$_SESSION和 $_COOKIE变量。 常量输出123&#123;$Think.const.MODULE_NAME&#125;// 或者&#123;$Think.MODULE_NAME&#125; 配置输出12&#123;$Think.config.db_charset&#125;&#123;$Think.config.url_model&#125; 语言变量12&#123;$Think.lang.page_error&#125;&#123;$Think.lang.var_error&#125; 使用函数我们往往需要对模板输出变量使用函数，可以使用： 1&#123;$data.name|md5&#125; 如果函数有多个参数需要调用，则使用： 1&#123;$create_time|date=\"y-m-d\",###&#125; 还可以支持多个函数过滤，多个函数之间用“|”分割即可，例如： 1&#123;$name|md5|strtoupper|substr=0,3&#125; 函数会按照从左到右的顺序依次调用。如果你觉得这样写起来比较麻烦，也可以直接这样写： 1&#123;:substr(strtoupper(md5($name)),0,3)&#125; 默认值输出123&#123;$user.nickname|default=\"这家伙很懒，什么也没留下\"&#125;&#123;$Think.get.name|default=\"名称为空\"&#125;&#123;$Think.get.name|getName|default=\"名称为空\"&#125; 使用运算符我们可以对模板输出使用运算符，包括对“+”“ ” “*” “/”和“%”的支持。在使用运算符的时候，不再支持点语法和常规的函数用法，例如： 12345&#123;$user.score+10&#125; //错误的&#123;$user['score']+10&#125; //正确的&#123;$user['score']*$user['level']&#125; //正确的&#123;$user['score']|myFun*10&#125; //错误的&#123;$user['score']+myFun($user['level'])&#125; //正确的 修改定界符普通标签12TMPL_L_DELIM //模板引擎普通标签开始标记 TMPL_R_DELIM //模板引擎普通标签结束标记 例如在项目配置文件中增加下面的配置： 12'TMPL_L_DELIM' =&gt; '&lt;&#123;','TMPL_R_DELIM' =&gt; '&#125;&gt;' XML标签12TAGLIB_BEGIN //标签库标签开始标签 TAGLIB_END //标签库标签结束标记 例如在项目配置文件中增加下面的配置： 12'TAGLIB_BEGIN'=&gt;'[','TAGLIB_END'=&gt;']', 三元运算符12&#123;$status?'正常':'错误'&#125;&#123;$info['status']?$info['msg']:$info['error']&#125; 原样输出可以使用literal标签来防止模板标签被解析，例如： 123456&lt;literal&gt; &lt;if condition=\"$name eq 1 \"&gt; value1 &lt;elseif condition=\"$name eq 2\"/&gt;value2 &lt;else /&gt; value3 &lt;/if&gt;&lt;/literal&gt; 上面的if标签被literal标签包含，因此if标签里面的内容并不会被模板引擎解析，而是保持原样输出。 Literal标签还可以用于页面的JS代码外层，确保JS代码中的某些用法和模板引擎不产生混淆。 总之，所有可能和内置模板引擎的解析规则冲突的地方都可以使用literal标签处理。 模板注释单行注释12&#123;/* 注释内容 */ &#125; 或 &#123;// 注释内容 &#125; &#123;// 这是模板注释内容 &#125; 注意{和注释标记之间不能有空格。 多行注释12&#123;/* 这是模板注释内容*/ &#125; 模板替换在进行模板渲染之前，系统还会对读取的模板内容进行一些特殊字符串替换操作，也就是实现了模板输出的替换和过滤。该替换操作仅针对内置的模版引擎。 这个机制可以使得模板文件的定义更加方便，默认的替换规则有： 1234567__ROOT__： 会替换成当前网站的地址（不含域名） __APP__： 会替换成当前应用的URL地址 （不含域名）__MODULE__：会替换成当前模块的URL地址 （不含域名）__CONTROLLER__（__或者__URL__ 兼容考虑）： 会替换成当前控制器的URL地址（不含域名）__ACTION__：会替换成当前操作的URL地址 （不含域名）__SELF__： 会替换成当前的页面URL__PUBLIC__：会被替换成当前网站的公共目录 通常是 /Public 注意这些特殊的字符串是严格区别大小写的，并且这些特殊字符串的替换规则是可以更改或者增加的，我们只需要在应用或者模块的配置文件中配置TMPL_PARSE_STRING就可以完成。如果有相同的数组索引，就会更改系统的默认规则。例如： 12345'TMPL_PARSE_STRING' =&gt;array( '__PUBLIC__' =&gt; '/Common', // 更改默认的/Public 替换规则 '__JS__' =&gt; '/Public/JS/', // 增加新的JS类库路径替换规则 '__UPLOAD__' =&gt; '/Uploads', // 增加新的上传路径替换规则) 有了模板替换规则后，模板中的所有__PUBLIC__字符串都会被替换，那如果确实需要输出__PUBLIC__字符串到模板呢，我们可以通过增加替换规则的方式，例如： 123'TMPL_PARSE_STRING' =&gt;array( '--PUBLIC--' =&gt; '__PUBLIC__', // 采用新规则输出`__PUBLIC__`字符串) 这样增加替换规则后，如果我们要在模板中使用__PUBLIC__字符串，只需要在模板中添加--PUBLIC--，其他替换字符串的输出方式类似。","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.caoxl.com/tags/前端/"},{"name":"ThinkPHP3.2","slug":"ThinkPHP3-2","permalink":"http://blog.caoxl.com/tags/ThinkPHP3-2/"},{"name":"模板","slug":"模板","permalink":"http://blog.caoxl.com/tags/模板/"}]},{"title":"ThinkPHP3.2 单字母函数","slug":"ThinkPHP32-Single-Letter-Functions","date":"2018-10-25T08:33:36.000Z","updated":"2019-08-22T06:42:33.000Z","comments":true,"path":"2018/10/25/ThinkPHP32-Single-Letter-Functions/","link":"","permalink":"http://blog.caoxl.com/2018/10/25/ThinkPHP32-Single-Letter-Functions/","excerpt":"因为工作需要使用ThinkPHP3.2, 所以请叫我考古学家!","text":"因为工作需要使用ThinkPHP3.2, 所以请叫我考古学家! A方法 A方法用于在内部实例化控制器，调用格式：A(‘[项目://][分组/]模块’,’控制器层名称’) 1$User = A('User'); 源码123456789101112131415161718192021222324/** * 实例化多层控制器 格式：[资源://][模块/]控制器 * @param string $name 资源地址 * @param string $layer 控制层名称 * @param integer $level 控制器层次 * @return Think\\Controller|false */function A($name, $layer = '', $level = 0) &#123; static $_action = array(); $layer = $layer ?: C('DEFAULT_C_LAYER'); $level = $level ?: ($layer == C('DEFAULT_C_LAYER') ? C('CONTROLLER_LEVEL') : 1); if (isset($_action[$name.$layer])) return $_action[$name.$layer]; $class = parse_res_name($name, $layer, $level); if (class_exists($class)) &#123; $action = new $class(); $_action[$name.$layer] = $action; return $action; &#125; else &#123; return false; &#125;&#125; B方法这是随着行为应运而生的新生函数，可以执行某个行为，例如 1B('app_begin'); 就是在项目开始之前，执行这个行为定义的所有函数。支持2个参数，第二个参数支持需要接受一个数组，例如 1B('app_begin',array(\"name\"=&amp; gt;\"tdweb\",\"time\"=&gt;time())); 源码1234567891011121314/** * 执行某个行为 * @param string $name 行为名称 * @param string $tag 标签名称（行为类无需传入） * @param Mixed $params 传入的参数 * @return mixed */function B($name, $tag = '', &amp;$params = null) &#123; if ('' == $tag) &#123; $name .= 'Behavior'; &#125; return \\Think\\Hook::exec($name, $tag, $params);&#125; C方法C方法是Think用于设置、获取，以及保存配置参数的方法，使用频率较高。 设置参数 1C('DB_NAME','think'); 表示设置DB_NAME配置参数的值为think，由于配置参数不区分大小写，所以下面的写法也是一样： 1C('db_name','think'); 支持二级配置参数的设置，例如： 1C('USER.USER_ID',8); 如果要设置多个参数，可以使用批量设置，例如： 123$config['user_id'] = 1;$config['user_type'] = 1;C($config); 源码123456789101112131415161718192021222324252627282930313233343536373839404142/** * 获取和设置配置参数 支持批量定义 * @param string|array $name 配置变量 * @param mixed $value 配置值 * @param mixed $default 默认值 * @return array|mixed|null */function C($name = null, $value = null, $default = null) &#123; static $_config = array(); // 无参数时获取所有 if (empty($name)) &#123; return $_config; &#125; // 优先执行设置获取或赋值 if (is_string($name)) &#123; if (!strpos($name, '.')) &#123; $name = strtoupper($name); if (is_null($value)) return isset($_config[$name]) ? $_config[$name] : $default; $_config[$name] = $value; return null; &#125; // 二维数组设置和获取支持 $name = explode('.', $name); $name[0] = strtoupper($name[0]); if (is_null($value)) return isset($_config[$name[0]][$name[1]]) ? $_config[$name[0][$name[1]]] : $default; $_config[$name[0][$name[1]]] = $value; return null; &#125; // 批量设置 if (is_array($name)) &#123; $_config = array_merge($_config, array_change_key_case($name, CASE_UPPER)); return null; &#125; // 避免非法参数 return null;&#125; D方法 D方法应该是用的比较多的方法了，用于实例化自定义模型类，是Think框架对Model类实例化的一种封装，并实现了单例模式，支持跨项目和分组调用，调用格式如下： D(‘[项目://][分组/]模型’,’模型层名称’) 12// 实例化User模型$User = D('User'); D方法可以支持跨分组和项目实例化模型，例如： 12345//实例化Admin项目的User模型D('Admin://User')//实例化Admin分组的User模型D('Admin/User') 由于增加了分层模型的支持，所以D方法也可以实例化其他的模型，例如： 12345// 实例化UserService类$User = D('User','Service');// 实例化UserLogic类$User = D('User','Logic'); 源码12345678910111213141516171819202122232425262728293031/** * 实例化模型类 格式 [资源://][模块/]模型 * @param string $name 资源地址 * @param string $layer 模型层名称 * @return mixed|\\Think\\Model */function D($name = '', $layer = '') &#123; if (empty($name)) return new Think\\Model; static $_model = array(); $layer = $layer ?: C('DEFAULT_M_LAYER'); if (isset($_model[$name.$layer])) return $_model[$name.$layer]; $class = parse_res_name($name, $layer); if (class_exists($class)) &#123; $model = new $class(basename($name)); &#125; elseif (false === strpos($name, '/')) &#123; // 自动加载公共模块下面的模型 if (! C('APP_USE_NAMESPACE')) &#123; import('Common/' . $layer . '/' . $class); &#125; else &#123; $class = '\\\\Common\\\\' . $layer . '\\\\' . $name . $layer; &#125; $model = class_exists($class) ? new $class($name) : new Think\\Model($name); &#125; else &#123; Think\\Log::record('D方法实例化没找到模型类' . $class, Think\\Log::NOTICE); $model = new Think\\Model(basename($name)); &#125; $_model[$name.$layer] = $model; return $model;&#125; E方法抛出异常处理 1E($msg, $code=0) 源码12345678910/** * 抛出异常处理 * @param string $msg 异常消息 * @param integer $code 异常代码 默认为0 * @throws Think\\Exception * @return void */function E($msg, $code = 0) &#123; throw new Think\\Exception($msg, $code);&#125; F方法 F方法其实是S方法的一个子集功能，仅用于简单数据缓存，并且只能支持文件形式，不支持缓存有效期，因为采用的是返回方式，所以其效率较S方法较高，因此我们也称之为快速缓存方法。 写入和读取缓存 1F('data','test data'); 默认的保存起始路径是DATA_PATH（该常量在默认配置位于RUNTIME_PATH.&#39;Data/&#39;下面），也就是说会生成文件名为DATA_PATH.&#39;data.&#39;的缓存文件。 注意：确保你的缓存标识的唯一，避免数据覆盖和冲突。 下次读取缓存数据的时候，使用： 1$Data = F('data'); 我们可以采用子目录方式保存，例如： 12F('user/data',$data); // 缓存写入F('user/data'); // 读取缓存 删除缓存 12F('data',NULL); // 第二个参数传入NULL，则表示删除标识为data的数据缓存。 支持批量删除功能，尤其是针对子目录缓存的情况，假设我们要删除user子目录下面的所有缓存数据，可以使用： 1F('user/*',NULL); 又或者使用过滤条件删除，例如： 1F('user/[^a]*',NULL); 源码123456789101112131415161718192021222324252627282930313233343536373839/** * 快速文件数据读取和保存 针对简单类型数据 字符串、数组 * @param string $name 缓存名称 * @param mixed $value 缓存值 * @param string $path 缓存路径 * @return mixed */function F($name, $value = '', $path = DATA_PATH) &#123; static $_cache = array(); $filename = $path . $name . '.php'; if ('' !== $value) &#123; if (is_null($value)) &#123; // 删除缓存 if (false !== strpos($name, '*')) &#123; return false; &#125; else &#123; unset($_cache[$name]); return Think\\Storage::unlink($filename, 'F'); &#125; &#125; else &#123; Think\\Storage::put($filename, serialize($value), 'F'); // 缓存数据 $_cache[$name] = $value; return null; &#125; &#125; // 获取缓存数据 if (isset($_cache[$name])) &#123; return $_cache[$name]; &#125; if (Think\\Storage::has($filename, 'F')) &#123; $value = unserialize(Think\\Storage::read($filename, 'F')); $_cache[$name] = $value; &#125; else &#123; $value = false; &#125; return $value;&#125; G方法 G方法的作用包括标记位置和区间统计两个功能 标记位置 G方法的第一个用法就是标记位置，例如： 1G('begin'); 表示把当前位置标记为begin标签，并且记录当前位置的执行时间，如果环境支持的话，还能记录内存占用情况。可以在任何位置调用G方法标记。 运行时间统计标记位置后，我们就可以再次调用G方法进行区间统计了，例如： 123456G('begin');// ...其他代码段G('end');// ...也许这里还有其他代码// 进行统计区间echo G('begin','end').'s'; G(‘begin’,’end’) 表示统计begin位置到end位置的执行时间（单位是秒），begin必须是一个已经标记过的位置，如果这个时候end位置还没被标记过，则会自动把当前位置标记为end标签，输出的结果类似于： 10.0056s 默认的统计精度是小数点后4位，如果觉得这个统计精度不够，还可以设置例如： 1G('begin','end',6).'s'; 可能的输出会变成： 10.005587s 内存开销统计如果你的环境支持内存占用统计的话，还可以使用G方法进行区间内存开销统计（单位为kb） 1echo G('begin','end','m').'kb'; 源码12345678910111213141516171819202122232425262728293031323334353637383940414243// 记录内存初始使用define('MEMORY_LIMIT_ON',function_exists('memory_get_usage'));/** * 记录和统计时间（微秒）和内存使用情况 * 使用方法: * &lt;code&gt; * G('begin'); // 记录开始标记位 * // ... 区间运行代码 * G('end'); // 记录结束标签位 * echo G('begin','end',6); // 统计区间运行时间 精确到小数后6位 * echo G('begin','end','m'); // 统计区间内存使用情况 * 如果end标记位没有定义，则会自动以当前作为标记位 * 其中统计内存使用需要 MEMORY_LIMIT_ON 常量为true才有效 * &lt;/code&gt; * @param string $start 开始标签 * @param string $end 结束标签 * @param integer|string $dec 小数位或者m * @return null|string */function G($start, $end = '', $dec = 4) &#123; static $_info = array(); static $_mem = array(); if (is_float($end)) &#123; // 记录时间 $_info[$start] = $end; &#125; elseif (!empty($end)) &#123; // 统计时间和内存使用 if (!isset($_info[$end])) $_info[$end] = microtime(true); if (MEMORY_LIMIT_ON &amp;&amp; $dec == 'm') &#123; if (!isset($_mem[$end])) $_mem[$end] = memory_get_usage(); return number_format(($_mem[$end] - $_mem[$start]) / 1024); &#125; else &#123; return number_format(($_info[$end] - $_info[$start]), $dec); &#125; &#125; else &#123; // 记录时间和内存使用 $_info[$start] = microtime(true); if (MEMORY_LIMIT_ON) $_mem[$start] = memory_get_usage(); &#125; return null;&#125; I方法主要用于更加方便和安全的获取系统输入变量，可以用于任何地方，用法格式如下： I(‘变量类型.变量名’,[‘默认值’],[‘过滤方法’]) 我们以GET变量类型为例 12echo I('get.id'); // 相当于 $_GET['id']echo I('get.name'); // 相当于 $_GET['name'] 支持默认值： 12echo I('get.id',0); // 如果不存在$_GET['id'] 则返回0echo I('get.name',''); // 如果不存在$_GET['name'] 则返回空字符串 采用方法过滤： 12echo I('get.name','','htmlspecialchars'); // 采用htmlspecialchars方法对$_GET['name'] 进行过滤，如果不存在则返回空字符串 支持直接获取整个变量类型，例如： 1I('get.'); // 获取整个$_GET 数组 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/** * 获取输入参数 支持过滤和默认值 * 使用方法: * &lt;code&gt; * I('id',0); 获取id参数 自动判断get或者post * I('post.name','','htmlspecialchars'); 获取$_POST['name'] * I('get.'); 获取$_GET * &lt;/code&gt; * @param string $name 变量的名称 支持指定类型 * @param mixed $default 不存在的时候默认值 * @param mixed $filter 参数过滤方法 * @param mixed $datas 要获取的额外数据源 * @return mixed */function I($name, $default = '', $filter = null, $datas = null) &#123; static $_PUT = null; if (strpos($name, '/')) &#123; //指定修饰符 list($name, $type) = explode('/', $name, 2); &#125; elseif (C('VAR_AUTO_STRING')) &#123; // 默认强制转换为字符串 $type = 's'; &#125; if (strpos($name, '.')) &#123; // 指定参数来源 list($method, $name) = explode('.', $name, 2); &#125; else &#123; // 默认为自动判断 $method = 'param'; &#125; switch (strtolower($method)) &#123; case 'get': $input = &amp;$_GET; break; case 'post': $input = &amp;$_POST; break; case 'put': if (is_null($_PUT)) &#123; parse_str(file_get_contents('php://input'), $_PUT); &#125; $input = &amp;$_PUT; break; case 'param': switch ($_SERVER['REQUEST_METHOD']) &#123; case 'POST': $input = $_POST; break; case 'PUT': if (is_null($_PUT)) &#123; parse_str(file_get_contents('php://input'), $_PUT); &#125; $input = $_PUT; break; default: $input = $_GET; &#125; break; case 'path': $input = array(); if (!empty($_SERVER['PATH_INFO'])) &#123; $depr = C('URL_PATHINFO_DEPR'); $input = explode($depr, trim($_SERVER['PATH_INFO'], $depr)); &#125; break; case 'request': $input = &amp;$_REQUEST; break; case 'session' : $input =&amp; $_SESSION; break; case 'cookie' : $input =&amp; $_COOKIE; break; case 'server' : $input =&amp; $_SERVER; break; case 'globals' : $input =&amp; $GLOBALS; break; case 'data' : $input =&amp; $datas; break; default: return null; &#125; if ('' == $name) &#123; // 获取全部变量 $data = $input; $filters = isset($filter) ? $filter : C('DEFAULT_FILTER'); if ($filters) &#123; if (is_string($filters)) &#123; $filters = explode(',', $filters); &#125; foreach ($filters as $filter) &#123; $data = array_map_recursive($filter, $data); // 参数过滤 &#125; &#125; &#125; elseif (isset($input[$name])) &#123; //取值操作 $data = $input[$name]; $filters = isset($filter) ? $filter : C('DEFAULT_FILTER'); if ($filter) &#123; if (is_string($filters)) &#123; if (0 === strpos($filters, '/')) &#123; if (1 !== preg_match($filters, (string)$data)) &#123; // 支持正则验证 return isset($default) ? $default : null; &#125; &#125; else &#123; $filters = explode(',', $filters); &#125; &#125; elseif (is_int($filters)) &#123; $filters = array($filters); &#125; if (is_array($filters)) &#123; foreach ($filters as $filter) &#123; if (function_exists($filter)) &#123; $data = is_array($data) ? array_map_recursive($filter,$data) : $filter($data); // 参数过滤 &#125; else &#123; $data = filter_var($data, is_int($filter)) ? $filter : filter_id($filter); if (false === $data) &#123; return isset($default) ? $default : null; &#125; &#125; &#125; &#125; &#125; if (!empty($type)) &#123; switch (strtolower($type)) &#123; case 'a': // 数组 $data = (array)$data; break; case 'd': // 数字 $data = (int)$data; break; case 'f': // 浮点 $data = (float)$data; break; case 'b': // 布尔 $data = (boolean)$data; break; case 's': // 字符串 default: $data = (string)$data; &#125; &#125; &#125; else &#123; // 变量默认值 $data = isset($default) ? $default : null; &#125; is_array($data) &amp;&amp; array_walk_recursive($data, 'think_filter'); return $data;&#125;function array_map_recursive($filter, $data) &#123; $result = array(); foreach ($data as $key =&gt; $val) &#123; $result[$key] = is_array($val) ? array_map_recursive($filter, $val) : call_user_func($filter, $val); &#125; return $result;&#125; L方法L方法用于启用多语言的情况下，设置和获取当前的语言定义。 L(‘语言变量’,[‘语言值’]) 除了使用语言包定义语言变量之外，我们可以用L方法动态设置语言变量，例如： 1L('LANG_VAR','语言定义'); 获取语言变量 1$langVar = L('LANG_VAR'); 源码1234567891011121314151617181920212223242526272829303132333435/** * 获取和设置语言定义(不区分大小写) * @param string|array $name 语言变量 * @param null mixed $value 语言值或者变量 * @return array|mixed|null|string */function L($name = null, $value = null) &#123; static $_lang = array(); // 空参数返回所有定义 if (empty($name)) return $_lang; // 判断语言获取(或设置) // 若不存在,直接返回全大写$name if (is_string($name)) &#123; $name = strtoupper($name); if (is_null($value)) &#123; return isset($_lang[$name]) ? $_lang[$name] : $name; &#125; elseif (is_array($value)) &#123; // 支持变量 $replace = array_keys($value); foreach ($replace as &amp;$v) &#123; $v = '&#123;$'.$v.'&#125;'; &#125; return str_replace($replace, $value, isset($_lang[$name]) ? $_lang[$name] : $name); &#125; // 语言定义 $_lang[$name] = $value; return null; &#125; // 批量定义 if (is_array($name)) $_lang = array_merge($_lang, array_change_key_case($name, CASE_UPPER)); return null;&#125; M方法M方法用于实例化一个基础模型类，和D方法的区别在于： 不需要自定义模型类，减少IO加载，性能较好； 实例化后只能调用基础模型类（默认是Model类）中的方法； 可以在实例化的时候指定表前缀、数据库和数据库的连接信息； M(‘[基础模型名:]模型名’,’数据表前缀’,’数据库连接信息’) 12$User = M('User');$User = M('db2.User','think_'); 第三个连接信息参数可以使用DSN配置或者数组配置，甚至可以支持配置参数。 例如，在项目配置文件中配置了： 1'DB_CONFIG'=&gt;'mysql://user_a:1234@localhost:3306/think'; 则可以使用： 1$User = M('User','think_','DB_CONFIG'); 基础模型类和数据库可以一起使用，例如： 1$User = M('CommonModel:db2.User','think_'); 源码1234567891011121314151617181920/** * 实例化一个没有模型文件的Model * @param string $name Model名称 支持指定基础模型 例如 MongoModel:User * @param string $tablePrefix 表前缀 * @param mixed $connection 数据库连接信息 * @return mixed */function M($name = '', $tablePrefix = '', $connection = '') &#123; static $_model = array(); if (strpos($name, ':')) &#123; list($class, $name) = explode(':', $name); &#125; else &#123; $class = 'Think\\\\Model'; &#125; $guid = (is_array($connection) ? implode('', $connection) : $connection) . $tablePrefix . $name . '_' . $class; if (!isset($_model[$guid])) $_model[$guid] = new $class($name, $tablePrefix, $connection); return $_model[$guid];&#125; N方法用于核心的查询、缓存统计的计数和统计。也可用于其他计数引用。 格式：N(‘计数位置’[,’步进值’]) 123N('read',1);//统计页面的查询次数，表示每次执行到该位置都会引起计数器加1//N('score',5);//计数器每次增加5$count = N('read');//来统计当前页面执行的查询数目。 源码12345678910111213141516171819202122232425262728293031/** * 设置和获取统计数据 * 使用方法: * &lt;code&gt; * N('db',1); // 记录数据库操作次数 * N('read',1); // 记录读取次数 * echo N('db'); // 获取当前页面数据库的所有操作次数 * echo N('read'); // 获取当前页面读取次数 * &lt;/code&gt; * @param string $key 标识位置 * @param integer $step 步进值 * @param boolean $save 是否保存结果 * @return mixed */function N($key, $step = 0, $save = false) &#123; static $_num = array(); if (!isset($_num[$key])) &#123; $_num[$key] = (false !== $save) ? S('N_' . $key) :0; &#125; if (empty($step)) &#123; return $_num[$key]; &#125; else &#123; $_num[$key] = $_num[$key] + (int)$step; &#125; if (false !== $save) &#123; // 保存结果 S('N_' . $key, $_num[$key], $save); &#125; return null;&#125; R方法R方法用于调用某个控制器的操作方法，是A方法的进一步增强和补充。 R(‘[项目://][分组/]模块/操作’,’参数’,’控制器层名称’) 1$data = R('User/detail',array('5')); 源码12345678910111213141516171819202122/** * 远程调用控制器的操作方法 URL 参数格式 [资源://][模块/]控制器/操作 * @param string $url 调用地址 * @param string|array $vars 调用参数 支持字符串和数组 * @param string $layer 要调用的控制层名称 * @return bool|mixed */function R($url, $vars = array(), $layer = '') &#123; $info = pathinfo($url); $action = $info['basename']; $module = $info['dirname']; $class = A($module, $layer); if ($class) &#123; if (is_string($vars)) &#123; parse_str($vars, $vars); &#125; return call_user_func_array(array(&amp;$class, $action.C('ACTION_SUFFIX')), $vars); &#125; else &#123; return false; &#125;&#125; S方法S方法还支持对当前的缓存方式传入缓存参数，例如： 1S('data',$Data,3600,'File',array('length'=&gt;10,'temp'=&gt;RUNTIME_PATH.'temp/')); 经测试，这样使用 只有前三个参数有效，后面的均无效 1&#123; 'File',array('length'=&gt;10,'temp'=&gt;RUNTIME_PATH.'temp/')&#125; 最终这么用： 1S('data1',$list,array('prefix'=&gt;aaa','expire'=&gt;'3600','temp'=&gt;RUNTIME_PATH.'temp/1236')); 获取的时候： 1$sdata = S('data1','',array('prefix'=&gt;'aaa','temp'=&gt;RUNTIME_PATH.'temp/1236')); 源码12345678910111213141516171819202122232425262728293031323334353637/** * 缓存管理 * @param mixed $name 缓存名称，如果为数组表示进行缓存设置 * @param mixed $value 缓存值 * @param mixed $options 缓存参数 * @return mixed */function S($name, $value = '', $options = null) &#123; static $cache = ''; if (is_array($options)) &#123; // 缓存操作的同时初始化 $type = isset($options['type']) ? $options['type'] : ''; $cache = Think\\Cache::getInstance($type, $options); &#125; elseif (is_array($name)) &#123; // 缓存初始化 $type = isset($name['type']) ? $name['type'] : ''; $cache = Think\\Cache::getInstance($type, $name); &#125; elseif (empty($cache)) &#123; // 自动初始化 $cache = Think\\Cache::getInstance(); &#125; if ('' === $value) &#123; // 获取缓存 return $cache-&gt;get($name); &#125; elseif (is_null($value)) &#123; // 删除缓存 return $cache-&gt;rm($name); &#125; else &#123; // 缓存数据 if (is_array($options)) &#123; $expire = isset($options['expire']) ? $options['expire'] : null; &#125; else &#123; $expire = is_numeric($options) ? $options : null; &#125; return $cache-&gt;set($name, $value, $expire); &#125;&#125; T方法为了更方便的输出模板文件，新版封装了一个T函数用于生成模板文件名。 T([资源://][模块@][主题/][控制器/]操作,[视图分层]) T函数的返回值是一个完整的模板文件名，可以直接用于display和fetch方法进行渲染输出。 1234567891011121314T('Public/menu');// 返回 当前模块/View/Public/menu.htmlT('blue/Public/menu');// 返回 当前模块/View/blue/Public/menu.htmlT('Public/menu','Tpl');// 返回 当前模块/Tpl/Public/menu.htmlT('Public/menu');// 如果TMPL_FILE_DEPR 为 _ 返回 当前模块/Tpl/Public_menu.htmlT('Public/menu');// 如果TMPL_TEMPLATE_SUFFIX 为.tpl 返回 当前模块/Tpl/Public/menu.tplT('Admin@Public/menu');// 返回 Admin/View/Public/menu.htmlT('Extend://Admin@Public/menu');// 返回 Extend/Admin/View/Public/menu.html (Extend目录取决于AUTOLOAD_NAMESPACE中的配置） 在display方法中直接使用T函数： 12// 使用T函数输出模板$this-&gt;display(T('Admin@Public/menu')); 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 获取输入参数 支持过滤和默认值 * 使用方法: * &lt;code&gt; * I('id',0); 获取id参数 自动判断get或者post * I('post.name','','htmlspecialchars'); 获取$_POST['name'] * I('get.'); 获取$_GET * &lt;/code&gt; * @param string $name 变量的名称 支持指定类型 * @param mixed $default 不存在的时候默认值 * @param mixed $filter 参数过滤方法 * @param mixed $datas 要获取的额外数据源 * @return mixed */function T($template = '', $layer = '') &#123; // 解析模板资源地址 if (false === strpos($template, '://')) &#123; $template = 'http://' . str_replace(':', '/', $template); &#125; $info = parse_url($template); $file = $info['host'] . (isset($info['path']) ? $info['path'] : ''); $module = isset($info['user']) ? $info['user'] . '/' : MODULE_NAME . '/'; $extend = $info['scheme']; $layer = $layer ? $layer : C('DEFAULT_V_LAYER'); // 获取当前主题的模板路径 $auto = C('AUTOLOAD_NAMESPACE'); if ($auto &amp;&amp; isset($auto[$extend])) &#123; // 扩展资源 $baseUrl = $auto[$extend] . $module . $layer . '/'; &#125; elseif (C('VIEW_PATH')) &#123; // 改变模块视图目录 $baseUrl = C('VIEW_PATH'); &#125; elseif (defined('TMPL_PATH')) &#123; // 指定全局视图目录 $baseUrl = TMPL_PATH . $module; &#125; else &#123; $baseUrl = APP_PATH . $module . $layer . '/'; &#125; // 获取主题 $theme = substr_count($file, '/') &lt; 2 ? C('DEFAULT_THEME') : ''; // 分析模板文件规则 $depr = C('TMPL_FILE_DEPR'); if ('' == $file) &#123; // 如果模板文件名为空, 按照默认规则定位 $file = CONTROLLER_NAME . $depr . ACTION_NAME; &#125; elseif (false === strpos($file, '/')) &#123; $file = CONTROLLER_NAME . $depr . $file; &#125; elseif ('/' != $depr) &#123; $file = substr_count($file, '/') &gt; 1 ? substr_replace($file, $depr, strpos($file, '/'), 1) : str_replace('/', $depr, $file); &#125; return $baseUrl . ($theme ? $theme . '/' : '') . $file . C('TMPL_TEMPLATE_SUFFIX');&#125; U方法U方法用于完成对URL地址的组装，特点在于可以自动根据当前的URL模式和设置生成对应的URL地址，格式为： U(‘地址’,’参数’,’伪静态’,’是否跳转’,’显示域名’); 1234U('User/add') // 生成User模块的add操作地址U('Home/User/add') // 生成Home分组的User模块的add操作地址U('add') // 生成当前访问模块的add操作地址U('add') // 生成当前访问模块的add操作地址 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/** * URL组装 支持不同URL模式 * @param string $url URL表达式，格式：'[模块/控制器/操作#锚点@域名]?参数1=值1&amp;参数2=值2...' * @param string|array $vars 传入的参数，支持数组和字符串 * @param string|boolean $suffix 伪静态后缀，默认为true表示获取配置值 * @param boolean $domain 是否显示域名 * @return string */function U($url = '', $vars = '', $suffix = true, $domain = false) &#123; // 解析URL $info = parse_url($url); $url = !empty($info['path'])?$info['path']:ACTION_NAME; if (isset($info['fragment'])) &#123; // 解析锚点 $anchor = $info['fragment']; if (false !== strpos($anchor,'?')) &#123; // 解析参数 list($anchor,$info['query']) = explode('?',$anchor,2); &#125; if (false !== strpos($anchor,'@')) &#123; // 解析域名 list($anchor,$host) = explode('@',$anchor, 2); &#125; &#125; elseif (false !== strpos($url,'@')) &#123; // 解析域名 list($url,$host) = explode('@',$info['path'], 2); &#125; // 解析子域名 if (isset($host)) &#123; $domain = $host.(strpos($host,'.')?'':strstr($_SERVER['HTTP_HOST'],'.')); &#125; elseif ($domain === true)&#123; $domain = $_SERVER['HTTP_HOST']; if (C('APP_SUB_DOMAIN_DEPLOY')) &#123; // 开启子域名部署 $domain = $domain == 'localhost' ? 'localhost' : 'www' . strstr($_SERVER['HTTP_HOST'],'.'); // '子域名'=&gt;array('模块[/控制器]'); foreach (C('APP_SUB_DOMAIN_RULES') as $key =&gt; $rule) &#123; $rule = is_array($rule) ? $rule[0] : $rule; if(false === strpos($key,'*') &amp;&amp; 0=== strpos($url,$rule)) &#123; $domain = $key.strstr($domain,'.'); // 生成对应子域名 $url = substr_replace($url,'',0,strlen($rule)); break; &#125; &#125; &#125; &#125; // 解析参数 if (is_string($vars)) &#123; // aaa=1&amp;bbb=2 转换成数组 parse_str($vars,$vars); &#125; elseif (!is_array($vars)) &#123; $vars = array(); &#125; if (isset($info['query'])) &#123; // 解析地址里面参数 合并到vars parse_str($info['query'],$params); $vars = array_merge($params,$vars); &#125; // URL组装 $depr = C('URL_PATHINFO_DEPR'); $urlCase = C('URL_CASE_INSENSITIVE'); if ($url) &#123; if (0=== strpos($url,'/')) &#123;// 定义路由 $route = true; $url = substr($url,1); if('/' != $depr) &#123; $url = str_replace('/',$depr,$url); &#125; &#125; else &#123; if('/' != $depr) &#123; // 安全替换 $url = str_replace('/',$depr,$url); &#125; // 解析模块、控制器和操作 $url = trim($url,$depr); $path = explode($depr,$url); $var = array(); $varModule = C('VAR_MODULE'); $varController = C('VAR_CONTROLLER'); $varAction = C('VAR_ACTION'); $var[$varAction] = !empty($path) ? array_pop($path) : ACTION_NAME; $var[$varController] = !empty($path) ? array_pop($path) : CONTROLLER_NAME; if($maps = C('URL_ACTION_MAP')) &#123; if (isset($maps[strtolower($var[$varController])])) &#123; $maps = $maps[strtolower($var[$varController])]; if ($action = array_search(strtolower($var[$varAction]), $maps)) &#123; $var[$varAction] = $action; &#125; &#125; &#125; if ($maps = C('URL_CONTROLLER_MAP')) &#123; if ($controller = array_search(strtolower($var[$varController]),$maps)) &#123; $var[$varController] = $controller; &#125; &#125; if ($urlCase) &#123; $var[$varController] = parse_name($var[$varController]); &#125; $module = ''; if (!empty($path)) &#123; $var[$varModule] = implode($depr,$path); &#125; else &#123; if (C('MULTI_MODULE')) &#123; if(MODULE_NAME != C('DEFAULT_MODULE') || !C('MODULE_ALLOW_LIST')) &#123; $var[$varModule] = MODULE_NAME; &#125; &#125; &#125; if ($maps = C('URL_MODULE_MAP')) &#123; if ($_module = array_search(strtolower($var[$varModule]), $maps)) &#123; $var[$varModule] = $_module; &#125; &#125; if (isset($var[$varModule])) &#123; $module = $var[$varModule]; unset($var[$varModule]); &#125; &#125; &#125; if (C('URL_MODEL') == 0) &#123; // 普通模式URL转换 $url = __APP__.'?'.C('VAR_MODULE').\"=&#123;$module&#125;&amp;\".http_build_query(array_reverse($var)); if ($urlCase)&#123; $url = strtolower($url); &#125; if(!empty($vars)) &#123; $vars = http_build_query($vars); $url .= '&amp;'.$vars; &#125; &#125; else &#123; // PATHINFO模式或者兼容URL模式 if(isset($route)) &#123; $url = __APP__.'/'.rtrim($url,$depr); &#125;else&#123; $module = (defined('BIND_MODULE') &amp;&amp; BIND_MODULE==$module )? '' : $module; $url = __APP__.'/'.($module?$module.MODULE_PATHINFO_DEPR:'').implode($depr,array_reverse($var)); &#125; if($urlCase)&#123; $url = strtolower($url); &#125; if(!empty($vars)) &#123; // 添加参数 foreach ($vars as $var =&gt; $val)&#123; if('' !== trim($val)) $url .= $depr . $var . $depr . urlencode($val); &#125; &#125; if($suffix) &#123; $suffix = $suffix===true?C('URL_HTML_SUFFIX'):$suffix; if($pos = strpos($suffix, '|'))&#123; $suffix = substr($suffix, 0, $pos); &#125; if($suffix &amp;&amp; '/' != substr($url,-1))&#123; $url .= '.'.ltrim($suffix,'.'); &#125; &#125; &#125; if (isset($anchor)) &#123; $url .= '#'.$anchor; &#125; if ($domain) &#123; $url = (is_ssl() ? 'https://' : 'http://') . $domain.$url; &#125; return $url;&#125; 其他M和D方法的区别： 都用于实例化一个模型类，M方法用于高效实例化一个基础模型类，D方法用于实例化一个用于自定义模型类。 不需要自定义模型类，减少IO加载，性能较好； 实例化后只能调用基础模型类（默认是Model类）中的方法； 可以在实例化的时候指定表前缀、数据库和数据库的连接信息； 使用M方法如果是如下情况，请考虑使用 M方法： 对数据表进行简单的 CURD 操作而无复杂的业务逻辑时 只有个别的表有较为复杂的业务逻辑时，将 M方法 与实例化 CommonModel 类进行结合使用 M方法 甚至可以简单看着就是对参数表名对应的数据表的操作： 1$User = M('User'); 使用D方法如果是如下情况，请考虑使用 D方法： 需要使用 ThinkPHP 模型中一些高级功能如自动验证功能（create()方法中实现）、关联模型等 业务逻辑比较复杂，且涉及的表众多 将业务逻辑定义在了自定义的模型类里面（Lib/Model目录下），而想在操作中实现这些业务逻辑","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"ThinkPHP3.2","slug":"ThinkPHP3-2","permalink":"http://blog.caoxl.com/tags/ThinkPHP3-2/"},{"name":"单字母函数","slug":"单字母函数","permalink":"http://blog.caoxl.com/tags/单字母函数/"}]},{"title":"面试常问的Session相关问题.","slug":"Session-Related-Questions","date":"2018-10-25T08:19:26.000Z","updated":"2019-08-22T07:02:33.000Z","comments":true,"path":"2018/10/25/Session-Related-Questions/","link":"","permalink":"http://blog.caoxl.com/2018/10/25/Session-Related-Questions/","excerpt":"面试常问的Session相关问题.","text":"面试常问的Session相关问题. Session和Cookie的关系?Cookie是什么? Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息。如何识别特定的客户呢？cookie就可以做到。每次HTTP请求时，客户端都会发送相应的Cookie信息到服务端。它的过期时间可以任意设置，如果你不主动清除它，在很长一段时间里面都可以保留着，即便这之间你把电脑关机了。 Session是什么？ Session是在无状态的HTTP协议下，服务端记录用户状态时用于标识具体用户的机制。它是在服务端保存的用来跟踪用户的状态的数据结构，可以保存在文件、数据库或者集群中。在浏览器关闭后这次的Session就消失了，下次打开就不再拥有这个Session。其实并不是Session消失了，而是Session ID变了，服务器端可能还是存着你上次的Session ID及其Session 信息，只是他们是无主状态，也许一段时间后会被删除。 关系? Cookie 在客户端（浏览器），Session 在服务器端。 Cookie的安全性一般，他人可通过分析存放在本地的Cookie并进行Cookie欺骗。在安全性第一的前提下，选择Session更优。重要交互信息比如权限等就要放在Session中，一般的信息记录放Cookie就好了。 3.单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie Session 可以放在 文件、数据库或内存中，比如在使用Node时将Session保存在redis中。由于一定时间内它是保存在服务器上的，当访问增多时，会较大地占用服务器的性能。考虑到减轻服务器性能方面，应当适时使用Cookie。 Session 的运行依赖Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID） 用户验证这种场合一般会用 Session。因此，维持一个会话的核心就是客户端的唯一标识，即Session ID 禁用了Cookie还可以继续使用Session吗? 如何使用? 如果客户端的浏览器禁用了 Cookie 怎么办？建议使用URL重写技术进行会话跟踪，即每次HTTP交互，URL后面都被附加上诸如 sid=xxxxx 的参数，以便服务端依此识别用户。 面试的时候经常被问到Cookie禁用了，Session还能用吗？ 默认SESSION配置在默认的PHP配置中，SessionID是需要存储在Cookie中的，默认Cookie名为： PHPSESSIONID 以下以PHP为例： 1234567891011121314151. 你第一次访问网站时，2. 服务端脚本中开启了Session session_start();,3. 服务器会生成一个不重复的SESSIONID 的文件'session_id();'，比如在'/var/lib/php/session'目录4. 并将返回(Response)如下的HTTP头 'Set-Cookie:PHPSESSIONID=xxxxxxx'5. 客户端接收到'Set-Cookie'的头，将'PHPSESSIONID'写入cookie6. 当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端7. 服务器识别'PHPSESSIONID'这个cookie，然后去session目录查找对应session文件，8. 找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置 如果客户端禁用了Cookie，那PHPSESSIONID都无法写入客户端，Session还能用？ 答案显而易见：不能 并且服务端因为没有得到PHPSESSIONID的cookie，会不停的生成session_id文件 取巧传递session_id但是这难不倒服务端程序，聪明的程序员想到，如果一个Cookie都没接收到，基本上可以预判客户端禁用了Cookie，那将session_id附带在每个网址后面(包括POST)，比如： 12GET http://www.xx.com/index.php?session_id=xxxxxPOST http://www.xx.com/post.php?session_id=xxxxx 然后在每个页面的开头使用session_id($_GET[&#39;session_id&#39;])，来强制指定当前session_id 这样，答案就变成了：能 但是这样做的方式是不可取的。为什么?因为有风险! 聪明的你肯定想到，那将这个网站发送给别人，那么他将会以你的身份登录并做所有的事情（目前很多订阅公众号就将openid附带在网址后面，这是同样的漏洞）。 其实不仅仅如此，cookie也可以被盗用，比如XSS注入，通过XSS漏洞获取大量的Cookie，也就是控制了大量的用户，腾讯有专门的XSS漏洞扫描机制，因为大量的QQ盗用，发广告就是因为XSS漏洞 所以Laravel等框架中，内部实现了Session的所有逻辑，并将PHPSESSIONID设置为httponly并加密，这样，前端JS就无法读取和修改这些敏感信息，降低了被盗用的风险。 如何实现Session共享?为什么要session共享?现在稍微大一点的网站基本上都有好几个子域名，比如www.caoxl.com, search.caoxl.com, member.caoxl.com，这些网站如果需要共用用户登录信息，那么就需要做到session共享，当然前提是有相同的主域。 要解决session共享，就必须解决两个问题： 多台服务器用同一个session_id 这个比较容易解决，只要在php中设置存session_id的cookie域名为网站主域就可以了 打开PHP.ini， 设置session.cookie_domain = .caoxl.com, 当然也可以在php代码当中设置ini_set(&quot;session.cookie_domain&quot;,&quot;caoxl.com&quot;); 多台服务器用同一个session_id访问到相同的session内容 要实现这点，就必须把session内容存储到让所有服务器都能访问到的地方，php的session内容是默认存储到本服务器的文件中的，一般的解决方案是存入数据库，memcache或者redis这种缓存服务器，当然用默认的文件存储方式也可以，用NFS统一存储。","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"面试","slug":"面试","permalink":"http://blog.caoxl.com/tags/面试/"},{"name":"Session","slug":"Session","permalink":"http://blog.caoxl.com/tags/Session/"},{"name":"Cookie","slug":"Cookie","permalink":"http://blog.caoxl.com/tags/Cookie/"}]},{"title":"同一服务器下使用多版本PHP+Composer","slug":"Multi-Version-PHP-And-Composer","date":"2018-10-25T08:14:44.000Z","updated":"2018-10-25T08:18:19.000Z","comments":true,"path":"2018/10/25/Multi-Version-PHP-And-Composer/","link":"","permalink":"http://blog.caoxl.com/2018/10/25/Multi-Version-PHP-And-Composer/","excerpt":"多个项目同时需要使用Composer,但是PHP版本不一样.","text":"多个项目同时需要使用Composer,但是PHP版本不一样. 多个PHP php7 1D:\\app\\phpStudy\\PHPTutorial\\php\\php-7.2.1-nts 将这个目录下的php.exe复制修改成php7.exe,删除php.exe即可. 1234$ php7 -vPHP 7.2.1 (cli) (built: Jan 4 2018 04:28:54) ( NTS MSVC15 (Visual C++ 2017) x86 )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2017 Zend Technologies php5 1D:\\app\\phpStudy\\PHPTutorial\\php\\php-5.5.38 1234$ php -vPHP 5.5.38 (cli) (built: Jul 20 2016 11:16:06)Copyright (c) 1997-2015 The PHP GroupZend Engine v2.5.0, Copyright (c) 1998-2015 Zend Technologies 多个PHP的Composer配置 直接安装的对应一个全局的Composer 配置一个需求版本的Composer 例如: 我们需要安装的对应php7.1的composer 下载composer，https://getcomposer.org/download/，将下载的composer.phar移动到~/composer7目录下 配置composer7 123vim ~/.bash_profilealias composer7='php7 D:/composer7/composer.phar'source ~/.bash_profile 查看php7和composer7 12php7 -vcomposer7 -v","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Composer","slug":"Composer","permalink":"http://blog.caoxl.com/tags/Composer/"},{"name":"多版本PHP","slug":"多版本PHP","permalink":"http://blog.caoxl.com/tags/多版本PHP/"}]},{"title":"Postman Post请求参数的区别？","slug":"Postman-Notes","date":"2018-10-20T09:01:50.000Z","updated":"2019-08-22T06:32:47.000Z","comments":true,"path":"2018/10/20/Postman-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/10/20/Postman-Notes/","excerpt":"postman中form-data、x-www-form-urlencoded、raw、binary的区别?","text":"postman中form-data、x-www-form-urlencoded、raw、binary的区别? 1. form-data 就是http请求中的multipart/form-data,它会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件。当上传的字段是文件时，会有Content-Type来说明文件类型；content-disposition，用来说明字段的一些信息；由于有boundary隔离，所以multipart/form-data既可以上传文件，也可以上传键值对，它采用了键值对的方式，所以可以上传多个文件。 2. x-www-form-urlencoded 就是application/x-www-from-urlencoded,会将表单内的数据转换为键值对，比如:name=caoxl&amp;age=23 3. raw 可以上传任意格式的文本，可以上传text、json、xml、html等 4. binary 相当于Content-Type:application/octet-stream,从字面意思得知，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传一个文件。 multipart/form-data与x-www-form-urlencoded区别 multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息； x-www-form-urlencoded：只能上传键值对，并且键值对都是间隔分开的。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Postman","slug":"Postman","permalink":"http://blog.caoxl.com/tags/Postman/"}]},{"title":"消息队列深入解析","slug":"Learn-Message-Queue","date":"2018-10-20T09:00:05.000Z","updated":"2019-08-22T06:33:08.000Z","comments":true,"path":"2018/10/20/Learn-Message-Queue/","link":"","permalink":"http://blog.caoxl.com/2018/10/20/Learn-Message-Queue/","excerpt":"“消息队列”(Message queue)是在消息的传输过程中保存消息的容器","text":"“消息队列”(Message queue)是在消息的传输过程中保存消息的容器 消息队列深入解析消息队列和消息 “消息队列”(Message queue)是在消息的传输过程中保存消息的容器“消息” 是在两台计算机间传送的数据单位。消息可以非常简单，例如只包含文本字符串；也可以更复杂，可能包含嵌入对象。 常见的消息队列有那些?当前使用较多的消息队列有RabbitMQ、ActiveMQ、RocketMQ、Kafka等等，redis数据库也可以实现消息队列，不过不推荐，redis本身设计就不是用来做消息队列的。 使用消息队列的场景和好处通过异步处理提高系统性能 在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。 通过以上分析我们可以得出消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。 降低系统耦合性我们知道模块分布式部署以后聚合方式通常有两种：1.分布式消息队列和2.分布式服务。 分布式服务： 目前使用比较多的用来构建SOA（Service Oriented Architecture面向服务体系结构）的分布式服务框架是阿里巴巴开源的Dubbo.《高性能优秀的服务框架-dubbo介绍》 分布式消息队列： 我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。 我们最常见的事件驱动架构类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。 常见的消息队列介绍ActiveMQ 官网：activemq.apache.org/ 特点： 支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议 完全支持JMS客户端和Message Broker中的企业集成模式 支持许多高级功能，如消息组，虚拟目标，通配符和复合目标 完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息 Spring支持，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置 专为高性能集群，客户端 - 服务器，基于对等的通信而设计 CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递 可以用作内存JMS提供程序，非常适合单元测试JMS 支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输 使用JDBC和高性能日志支持非常快速的持久性 RabbitMQ 官网：www.rabbitmq.com/ 特点： 异步消息传递：支持多种消息协议，消息队列，传送确认，灵活的路由到队列，多种交换类型； 支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等； 可以部署为高可用性和吞吐量的集群; 跨多个可用区域和区域进行联合； 可插入的身份验证，授权，支持TLS和LDAP。 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面； 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 Kafka 官网：kafka.apache.org/ 特点： 同时为发布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。 可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。 分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。 消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。 支持online和offline的场景。 RocketMQ 官网：rocketmq.apache.org/ 特点： 支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递 支持拉（pull）和推（push）两种消息模式 单一队列百万消息的堆积能力 支持多种消息协议，如 JMS、MQTT 等 分布式高可用的部署架构,满足至少一次消息传递语义 提供 docker 镜像用于隔离测试和云集群部署 提供配置、指标和监控等功能丰富的 Dashboard","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"消息队列","slug":"消息队列","permalink":"http://blog.caoxl.com/tags/消息队列/"}]},{"title":"进程、线程、协程的区别","slug":"Process-Line-CoProcess-Diff","date":"2018-10-20T08:58:12.000Z","updated":"2019-08-22T07:02:47.000Z","comments":true,"path":"2018/10/20/Process-Line-CoProcess-Diff/","link":"","permalink":"http://blog.caoxl.com/2018/10/20/Process-Line-CoProcess-Diff/","excerpt":"进程、线程、协程的区别 ?","text":"进程、线程、协程的区别 ? 概念进程进程的出现是为了更好的利用CPU资源使到并发成为可能 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。 进程之间的通信 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。 有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。 套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。 线程线程的出现是为了降低上下文切换的消耗，提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内并发成为可能 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。 线程之间的通信 锁机制1.1 互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。1.2 读写锁：允许多个线程同时读共享数据，而对写操作互斥。1.3 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。 信号量机制：包括无名线程信号量与有名线程信号量 信号机制：类似于进程间的信号处理。 线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。 协程协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在IO上的性能瓶颈 协程是一种用户态的轻量级线程，协程的调度完全由用户控制 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 区别线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别: 进程与线程比较 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 线程是处理器调度的基本单位,但进程不是 二者均可并发执行 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 协程与线程进行比较 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。 线程进程都是同步机制，而协程则是异步 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://blog.caoxl.com/tags/进程/"},{"name":"线程","slug":"线程","permalink":"http://blog.caoxl.com/tags/线程/"},{"name":"协程","slug":"协程","permalink":"http://blog.caoxl.com/tags/协程/"}]},{"title":"Redis与Memcached的区别?","slug":"Memcache-And-Redis-Diff","date":"2018-10-20T08:55:59.000Z","updated":"2019-08-22T07:02:52.000Z","comments":true,"path":"2018/10/20/Memcache-And-Redis-Diff/","link":"","permalink":"http://blog.caoxl.com/2018/10/20/Memcache-And-Redis-Diff/","excerpt":"面试常问题：Redis与Memcached的区别 ?","text":"面试常问题：Redis与Memcached的区别 ? 网络IO模型 Memcached是多线程，非阻塞IO复用的网络模型，分为监听主线程和worker子线程，监听线程监听网络连接，接受请求后，将连接描述字pipe 传递给worker线程，进行读写IO,网络层使用libevent封装的事件库，多线程模型可以发挥多核作用，但是引入了cache coherency和锁的问题，比如，Memcached最常用的 stats 命令，实际Memcached所有操作都要对这个全局变量加锁，进行计数等工作，带来了性能损耗。 Redis使用单线程的IO复用模型，自己封装了一个简单的AeEvent事件处理框架，主要实现了epoll、kqueue和select，对于单纯只有IO操作来说，单线程可以将速度优势发挥到最大，但是Redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞住的。 内存管理方面 Memcached使用预分配的内存池的方式，使用slab和大小不同的chunk来管理内存，Item根据大小选择合适的chunk存储，内存池的方式可以省去申请/释放内存的开销，并且能减小内存碎片产生，但这种方式也会带来一定程度上的空间浪费，并且在内存仍然有很大空间时，新的数据也可能会被剔除 Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片，Redis跟据存储命令参数，会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致swap也不会剔除任何非临时数据(但会尝试剔除部分临时数据)，这点上Redis更适合作为存储而不是cache。 数据一致性问题 Memcached提供了cas 命令，可以保证多个并发访问操作同一份数据的一致性问题。 Redis没有提供 cas 命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串命令的原子性，中间不会被任何操作打断。 存储方式及其它方面 Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能 Redis除key/value之外，还支持list,set,sorted set,hash等众多数据结构，提供了KEYS进行枚举操作，但不能在线上使用，如果需要枚举线上数据，Redis提供了工具可以直接扫描其dump文件，枚举出所有数据，Redis还同时提供了持久化和复制等功能。","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"Memcache","slug":"Memcache","permalink":"http://blog.caoxl.com/tags/Memcache/"},{"name":"缓存","slug":"缓存","permalink":"http://blog.caoxl.com/tags/缓存/"}]},{"title":"MySQL SQL优化","slug":"MySQL-SQL-OPT","date":"2018-10-20T08:54:07.000Z","updated":"2019-08-22T06:27:29.000Z","comments":true,"path":"2018/10/20/MySQL-SQL-OPT/","link":"","permalink":"http://blog.caoxl.com/2018/10/20/MySQL-SQL-OPT/","excerpt":"数据库SQL优化？如何优化？","text":"数据库SQL优化？如何优化？ 数据库SQL优化大总结之 百万级数据库优化方案 对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： 1select id from where num is null; 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库. 不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： 1select id from test where num = 0; 应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描. in 和 not in 也要慎用，否则会导致全表扫描. 下面的查询也将导致全表扫描： 1select id from t where name like '%abc%' 若要提高效率，可以考虑全文检索。 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。 select count(*) from table; 这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。 新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免大事务操作，提高系统并发能力。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 运维角度浅谈MySQL数据库优化一个成熟的数据库架构并不是一开始设计就具备高可用、高伸缩等特性的，它是随着用户量的增加，基础架构才逐渐完善。暂且抛开前端应用不说，大致分为以下五个阶段： 1、数据库表设计项目立项后，开发部根据产品部需求开发项目，开发工程师工作其中一部分就是对表结构设计。对于数据库来说，这点很重要，如果设计不当，会直接影响访问速度和用户体验。影响的因素很多，比如慢查询、低效的查询语句、没有适当建立索引、数据库堵塞（死锁）等。 2、数据库部署该运维工程师出场了，项目初期访问量不会很大，所以单台部署足以应对在1500左右的QPS（每秒查询率）。考虑到高可用性，可采用MySQL主从复制+Keepalived做双击热备，常见集群软件有Keepalived、Heartbeat。 3、数据库性能优化如果将MySQL部署到普通的X86服务器上，在不经过任何优化情况下，MySQL理论值正常可以处理2000左右QPS，经过优化后，有可能会提升到2500左右QPS，否则，访问量当达到1500左右并发连接时，数据库处理性能就会变慢，而且硬件资源还很富裕，这时就该考虑软件问题了 那么怎样让数据库最大化发挥性能呢？一方面可以单台运行多个MySQL实例让服务器性能发挥到最大化，另一方面是对数据库进行优化，往往操作系统和数据库默认配置都比较保守，会对数据库发挥有一定限制，可对这些配置进行适当的调整，尽可能的处理更多连接数。 数据库配置优化MySQL常用有两种存储引擎:一个是MyISAM，不支持事务处理，读性能处理快，表级别锁。另一个是InnoDB，支持事务处理（ACID），设计目标是为处理大容量数据发挥最大化性能，行级别锁。 表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。 行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。 为什么会出现表锁和行锁呢？主要是为了保证数据的完整性，举个例子，一个用户在操作一张表，其他用户也想操作这张表，那么就要等第一个用户操作完，其他用户才能操作，表锁和行锁就是这个作用。否则多个用户同时操作一张表，肯定会数据产生冲突或者异常。 根据以上看来，使用InnoDB存储引擎是最好的选择，也是MySQL5.5以后版本中默认存储引擎。每个存储引擎相关联参数比较多，以下列出主要影响数据库性能的参数。 公共参数默认值： 123456789#同时处理最大连接数，推荐设置最大连接数是上限连接数的80%左右 max_connections = 151#查询排序时缓冲区大小，只对order by和group by起作用，可增大此值为16Msort_buffer_size = 2M#打开文件数限制，如果show global status like 'open_files'查看的值等于或者大于open_files_limit值时，\\#程序会无法连接数据库或卡死open_file_limit = 1024; MyISAM参数默认值： 1234567891011121314#索引缓存区大小，一般设置物理内存的30-40%key_buffer_size = 16M#读操作缓冲区大小，推荐设置16M或32Mread_buffer_size = 128K#打开查询缓存功能query_cache_type = ON#查询缓存限制，只有1M以下查询结果才会被缓存，以免结果数据较大把缓存池覆盖query_cache_limit = 1M#查看缓冲区大小，用于缓存SELECT查询结果，下一次有同样SELECT查询将直接从缓存池返回结果，可适当成倍增加此值query_cache_size = 16M InnoDB参数默认值： 123456789101112131415161718#索引和数据缓冲区大小，一般设置物理内存的60%-70%innodb_buffer_pool_size = 128M#缓冲池实例个数，推荐设置4个或8个innodb_buffer_pool_instances = 1#关键参数，// 0代表大约每秒写入到日志并同步到磁盘，数据库故障会丢失1秒左右事务数据。// 1为每执行一条SQL后写入到日志并同步到磁盘，I/O开销大，执行完SQL要等待日志读写，效率低。// 2代表只把日志写入到系统缓存区，再每秒同步到磁盘，效率很高，如果服务器故障，才会丢失事务数据。对数据安全性要求不是很高的推荐设置2，性能高，修改后效果明显。innodb_flush_log_at_trx_commit = 1#默认是共享表空间，共享表空间idbdata文件不断增大，影响一定的I/O性能。#推荐开启独立表空间模式，每个表的索引和数据都存在自己独立的表空间中，可以实现单表在不同数据库中移动。innodb_file_per_table = OFF#日志缓冲区大小，由于日志最长每秒钟刷新一次，所以一般不用超过16Minnodb_log_buffer_size = 8M 系统内核优化大多数MySQL都部署在linux系统上，所以操作系统的一些参数也会影响到MySQL性能，以下对linux内核进行适当优化。 1234567891011121314#TIME_WAIT超时时间，默认是60snet.ipv4.tcp_fin_timeout = 30#1表示开启复用，允许TIME_WAIT socket重新用于新的TCP连接，0表示关闭net.ipv4.tcp_tw_reuse = 1#1表示开启TIME_WAIT socket快速回收，0表示关闭net.ipv4.tcp_tw_recycle = 1#系统保持TIME_WAIT socket最大数量，如果超出这个数，系统将随机清除一些TIME_WAIT并打印警告信息net.ipv4.tcp_max_tw_buckets = 4096#进入SYN队列最大长度，加大队列长度可容纳更多的等待连接net.ipv4.tcp_max_syn_backlog = 4096 在linux系统中，如果进程打开的文件句柄数量超过系统默认值1024，就会提示“too many files open”信息，所以要调整打开文件句柄限制。 1234# vi /etc/security/limits.conf #加入以下配置，*代表所有用户，也可以指定用户，重启系统生效* soft nofile 65535* hard nofile 65535# ulimit -SHn 65535 #立刻生效 硬件配置加大物理内存，提高文件系统性能。linux内核会从内存中分配出缓存区（系统缓存和数据缓存）来存放热数据，通过文件系统延迟写入机制，等满足条件时（如缓存区大小到达一定百分比或者执行sync命令）才会同步到磁盘。也就是说物理内存越大，分配缓存区越大，缓存数据越多。当然，服务器故障会丢失一定的缓存数据。 SSD硬盘代替SAS硬盘，将RAID级别调整为RAID1+0，相对于RAID1和RAID5有更好的读写性能（IOPS），毕竟数据库的压力主要来自磁盘I/O方面 4、数据库架构扩展随着业务量越来越大，单台数据库服务器性能已无法满足业务需求，该考虑加机器了，该做集群了~~~。主要思想是分解单台数据库负载，突破磁盘I/O性能，热数据存放缓存中，降低磁盘I/O访问频率。 主从复制与读写分离因为生产环境中，数据库大多都是读操作，所以部署一主多从架构，主数据库负责写操作，并做双击热备，多台从数据库做负载均衡，负责读操作，主流的负载均衡器有LVS、HAProxy、Nginx。 增加缓存给数据库增加缓存系统，把热数据缓存到内存中，如果缓存中有要请求的数据就不再去数据库中返回结果，提高读性能。缓存实现有本地缓存和分布式缓存，本地缓存是将数据缓存到本地服务器内存中或者文件中。分布式缓存可以缓存海量数据，扩展性好，主流的分布式缓存系统有memcached、redis，memcached性能稳定，数据缓存在内存中，速度很快，QPS可达8w左右。如果想数据持久化就选择用redis，性能不低于memcached。 分库分库是根据业务不同把相关的表切分到不同的数据库中，比如web、bbs、blog等库。如果业务量很大，还可将切分后的库做主从架构，进一步避免单个库压力过大。 分表数据量的日剧增加，数据库中某个表有几百万条数据，导致查询和插入耗时太长，怎么能解决单表压力呢？你就该考虑是否把这个表拆分成多个小表，来减轻单个表的压力，提高处理效率，此方式称为分表。 分表技术比较麻烦，要修改程序代码里的SQL语句，还要手动去创建其他表，也可以用merge存储引擎实现分表，相对简单许多。分表后，程序是对一个总表进行操作，这个总表不存放数据，只有一些分表的关系，以及更新数据的方式，总表会根据不同的查询，将压力分到不同的小表上，因此提高并发能力和磁盘I/O性能。 分表分为垂直拆分和水平拆分： 垂直拆分：把原来的一个很多字段的表拆分多个表，解决表的宽度问题。你可以把不常用的字段单独放到一个表中，也可以把大字段独立放一个表中，或者把关联密切的字段放一个表中。 水平拆分：把原来一个表拆分成多个表，每个表的结构都一样，解决单表数据量大的问题。 分区分区就是把一张表的数据根据表结构中的字段（如range、list、hash等）分成多个区块，这些区块可以在一个磁盘上，也可以在不同的磁盘上，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，多块硬盘同时处理不同的请求，从而提高磁盘I/O读写性能，实现比较简单。 数据库维护数据库维护是运维工程师或者DBA主要工作，包括性能监控、性能分析、性能调优、数据库备份和恢复等。 性能状态关键指标 QPS, Queries Per Second：每秒查询数，一台数据库每秒能够处理的查询次数 TPS，Transactions Per Second：每秒处理事务数 通过show status查看运行状态，会有300多条状态信息记录，其中有几个值帮可以我们计算出QPS和TPS，如下： Uptime：服务器已经运行的实际，单位秒 Questions：已经发送给数据库查询数 Com_select：查询次数，实际操作数据库的 Com_insert：插入次数 Com_delete：删除次数 Com_update：更新次数 Com_commit：事务次数 Com_rollback：回滚次数 那么，计算方法来了，基于Questions计算出QPS： 12show global status like 'Questions';show global status like 'Uptime'; QPS = Questions / Uptime 基于Com_commit和Com_rollback计算出TPS： 123show global status like 'Com_commit';show global status like 'Com_rollback';show global status like 'Uptime'; TPS = (Com_commit + Com_rollback) / Uptime 另一计算方式：基于Com_select、Com_insert、Com_delete、Com_update计算出QPS 1show global status where Variable_name in('com_select','com_insert','com_delete','com_update'); 等待1秒再执行，获取间隔差值，第二次每个变量值减去第一次对应的变量值，就是QPS TPS计算方法： 1show global status where Variable_name in('com_insert','com_delete','com_update'); 计算TPS，就不算查询操作了，计算出插入、删除、更新四个值即可。 经网友对这两个计算方式的测试得出，当数据库中myisam表比较多时，使用Questions计算比较准确。当数据库中innodb表比较多时，则以Com_*计算比较准确。 开启慢查询日志MySQL开启慢查询日志，分析出哪条SQL语句比较慢，使用set设置变量，重启服务失效，可以在my.cnf添加参数永久生效。 1234567891011# 开启慢查询功能mysql&gt; set global slow-query-log=on# 指定慢查询日志文件位置mysql&gt; set global slow_query_log_file='/var/log/mysql/mysql-slow.log';# 记录没有使用索引的查询mysql&gt; set global log_queries_not_using_indexes=on;# 只记录处理时间1s以上的慢查询mysql&gt; set global long_query_time=1; 分析慢查询日志，可以使用MySQL自带的mysqldumpslow工具，分析的日志较为简单。 1mysqldumpslow -t 3 /var/log/mysql/mysql-slow.log #查看最慢的前三个查询 数据库备份备份数据库是最基本的工作，也是最重要的，否则后果很严重，你懂得！但由于数据库比较大，上百G，往往备份都很耗费时间，所以就该选择一个效率高的备份策略，对于数据量大的数据库，一般都采用增量备份。常用的备份工具有mysqldump、mysqlhotcopy、xtrabackup等，mysqldump比较适用于小的数据库，因为是逻辑备份，所以备份和恢复耗时都比较长。mysqlhotcopy和xtrabackup是物理备份，备份和恢复速度快，不影响数据库服务情况下进行热拷贝，建议使用xtrabackup，支持增量备份。 数据库修复有时候MySQL服务器突然断电、异常关闭，会导致表损坏，无法读取表数据。这时就可以用到MySQL自带的两个工具进行修复，myisamchk和mysqlcheck。 另外，查看CPU和I/O性能方法 查看CPU性能 1vmstat 1 参数-P是显示CPU数，ALL为所有，也可以只显示第几颗CPU 1mpstat -P ALL 1 查看I/O性能 1iostat -m -x 1 说明: 参数-m是以M单位显示，默认K 参考 MySQL/Oracle数据库优化总结（非常全面） Mysql主从复制 MySQL数据库优化的八种方式(经典必看)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"优化","slug":"优化","permalink":"http://blog.caoxl.com/tags/优化/"},{"name":"SQL","slug":"SQL","permalink":"http://blog.caoxl.com/tags/SQL/"}]},{"title":"MySQL 索引优化","slug":"MySQL-Index-OPT","date":"2018-10-20T08:51:58.000Z","updated":"2019-08-22T06:27:26.000Z","comments":true,"path":"2018/10/20/MySQL-Index-OPT/","link":"","permalink":"http://blog.caoxl.com/2018/10/20/MySQL-Index-OPT/","excerpt":"想要做MySQL索引优化首先得了解MySQL索引!","text":"想要做MySQL索引优化首先得了解MySQL索引! 索引的作用当一个数据表只有很少量的数据时,索引体现不了他的价值。但若是一个表有10w多的数据时,查找数据就要全表查找,最差要查找10w个数据,太慢了,若是用索引的话,就会大大减少时间,例如对 score字段做一个索引,索引会生成一个文件,查找数据就到索引文件中查找,又因为索引出来的数据是已经排好序的,所以查找时,数据库会用类似二分法的查找,这样会比不用索引快很多倍。 MySQL索引种类索引是帮助mysql获取数据的数据结构。最常见的索引是Btree索引和Hash索引。 不同的引擎对于索引有不同的支持：Innodb和MyISAM默认的索引是Btree索引;而Mermory默认的索引是Hash索引。 FULLTEXT 即为全文索引,目前只有MyISAM引擎支持。不过目前只有 CHAR、VARCHAR ,TEXT 列上可以创建全文索引。全文索引并不是和MyISAM一起诞生的,它的出现是为了解决WHERE name LIKE “%word%”这类针对文本的模糊查询效率较低的问题。 HASH 由于hash索引可以一次定位,不需要像树形索引那样逐层查找,因此具有极高的效率。但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端,主要有以下这些: Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询,不能使用范围查询。 Hash 索引无法被用来避免数据的排序操作。 Hash 索引不能利用部分索引键查询。 Hash 索引在任何时候都不能避免表扫描。 Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。 BTREE B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平衡（balance），而不是二叉（binary），因为B+树是从最早的平衡二叉树演化而来的。 BTREE索引就是一种将索引值按一定的算法,存入一个树形的数据结构中,如二叉树一样,每次查询都是从树的入口root开始,依次遍历node,获取子节点上的数据。 BTREE索引分两类,一个是单列索引 另一个是多列索引 单列索引 单列索引是给单个字段做索引,如给math字段。 建立索引12//给 test表 中的math字段加一个索引,索引名叫 math_indexalter table test add index math_index(math); 用命令 show index from test;可以查看是否建立了索引： 建立索引后,我们就要使用索引,索引一般是用于查找信息（用select语句） 注意：使用索引时,不能 select * ,这样的话,索引是无法使用的,select后面跟的应该包含索引所在的字段, 例如上面我设置了 math 字段的索引为 math_index 则就要写成 select math from test;（select math,english from test; 也可以,只要有math字段就行） 因为索引生成索引文件,里面放的是索引对应字段的数据。 使用 select math from test; 得出的结果：可以看出,数据是应该排好序的,因为只要是用到索引,被查找后的字段都会被排好序的。 删除索引12//删除test表中的名为 `math_index` 的索引alter table test drop index math_index; 多列索引 多列索引是一个索引对应多个字段的数据。 例如我们想查找 数学成绩&gt;60 且 英语成绩 &gt;60 的学生。可以用多列索引,当然你说用2个单列索引,分别是数学 和 英语的索引行不行？ 其实也是可以的,但也有区别,下面会讲解： 创建一个多列索引1234// 在test表中创建一个 为名 indexes 的多列索引,包含 math,english字段alter table test add indexs(math, english);// 用 show index from test; 查看是否有创建。 然后对test表：//在test表中找出数学和英语成绩都高于60的数据1select math, english from test where math&gt;60 and english&gt;60; 可以看出，数据也是排好序的。 删除多列索引跟删除单列索引一样。最左前缀：最左前缀的意思是，例如我创建的多列索引是 （math，english）这样表示的，则： 1234567select math from test;select math, english from test;//上面的写法都可以使用多列索引，第一行的写法相当于math的单列索引// 而selec english from test;// 则会使索引失效, 因为他不是math开头 RTREE RTREE在mysql很少使用,仅支持geometry数据类型,相对于BTREE,RTREE的优势在于范围查找。 BTREE和HASH的区别?B-Tree B-Tree 索引是 MySQL 数据库中使用最为频繁的索引类型，除了 Archive 存储引擎之外的其他所有的存储引擎都支持 B-Tree 索引。不仅仅在 MySQL 中是如此，实际上在其他的很多数据库管理系统中B-Tree 索引也同样是作为最主要的索引类型，这主要是因为B-Tree 索引的存储结构在数据库的数据检索中有非常优异的表现。 HASH Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 B-Tree索引中的最左匹配原则Btree是按照从左到右的顺序来建立搜索树的。比如索引是(name,age,sex),会先检查name字段,如果name字段相同再去检查后两个字段。 所以当传进来的是后两个字段的数据（age,sex）,因为建立搜索树的时候是按照第一个字段建立的,所以必须根据name字段才能知道下一个字段去哪里查询。 所以传进来的是（name,sex）时,首先会根据name指定搜索方向,但是第二个字段缺失,所以将name字段正确的都找到后,然后才会去匹配sex的数据。 建立索引的规则： 利用最左前缀：Mysql会一直向右查找直到遇到范围操作（&gt;,&lt;,like、between）就停止匹配。比如a=1 and b=2 and c&gt;3 and d=6;此时如果建立了（a,b,c,d）索引,那么后面的d索引是完全没有用到,当换成了（a,b,d,c）就可以用到。 不能过度索引：在修改表内容的时候,索引必须更新或者重构,所以索引过多时,会消耗更多的时间。 尽量扩展索引而不要新建索引 最适合的索引的列是出现在where子句中的列或连接子句中指定的列。 不同值较少的列不必要建立索引（性别）。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"优化","slug":"优化","permalink":"http://blog.caoxl.com/tags/优化/"},{"name":"索引","slug":"索引","permalink":"http://blog.caoxl.com/tags/索引/"}]},{"title":"远古框架 ThinkPHP3.2","slug":"Ancient-Frame-TP3-2-Notes","date":"2018-10-16T02:46:09.000Z","updated":"2019-08-22T06:42:12.000Z","comments":true,"path":"2018/10/16/Ancient-Frame-TP3-2-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/10/16/Ancient-Frame-TP3-2-Notes/","excerpt":"因为工作需要，要重新捡起远古框架ThinKPHP3.2","text":"因为工作需要，要重新捡起远古框架ThinKPHP3.2 https://www.kancloud.cn/manual/thinkphp/1679 基础安装ThinkPHP3.21composer create-project topthink/thinkphp ThinkPHP32 环境要求 PHP5.3+ 目录结构123456www WEB部署目录（或者子目录）├─index.php 入口文件├─README.md README文件├─Application 应用目录├─Public 资源文件目录└─ThinkPHP 框架目录 12345678910111213141516├─ThinkPHP 框架系统目录（可以部署在非web目录下面）│ ├─Common 核心公共函数目录│ ├─Conf 核心配置目录 │ ├─Lang 核心语言包目录│ ├─Library 框架类库目录│ │ ├─Think 核心Think类库包目录│ │ ├─Behavior 行为类库目录│ │ ├─Org Org类库包目录│ │ ├─Vendor 第三方类库目录│ │ ├─ ... 更多类库目录│ ├─Mode 框架应用模式目录│ ├─Tpl 系统模板目录│ ├─LICENSE.txt 框架授权协议文件│ ├─logo.png 框架LOGO文件│ ├─README.txt 框架README文件│ └─ThinkPHP.php 框架入口文件 控制器我们可以在自动生成的Application/Home/Controller目录下面找到一个 IndexController.class.php 文件，这就是默认的Index控制器文件。 控制器类的命名方式是：控制器名（驼峰法，首字母大写）+Controller 控制器文件的命名方式是：类名+class.php（类文件后缀） 开发规范使用ThinkPHP开发的过程中应该尽量遵循下列命名规范： 类文件都是以.class.php为后缀（这里是指的ThinkPHP内部使用的类库文件，不代表外部加载的类库文件），使用驼峰法命名，并且首字母大写，例如 DbMysql.class.php； 类的命名空间地址和所在的路径地址一致，例如 Home\\Controller\\UserController类所在的路径应该是 Application/Home/Controller/UserController.class.php； 函数、配置文件等其他类库文件之外的一般是以.php为后缀（第三方引入的不做要求）； 函数的命名使用小写字母和下划线的方式，例如 get_client_ip； 方法的命名使用驼峰法，并且首字母小写或者使用下划线“_”，例如 getUserName，_parseType，通常下划线开头的方法属于私有方法； 属性的命名使用驼峰法，并且首字母小写或者使用下划线“_”，例如 tableName、_instance，通常下划线开头的属性属于私有属性； 以双下划线“__”打头的函数或方法作为魔法方法，例如 __call 和 __autoload； 常量以大写字母和下划线命名，例如 HAS_ONE 和 MANY_TO_MANY； 配置参数以大写字母和下划线命名，例如 HTML_CACHE_ON； 语言变量以大写字母和下划线命名，例如MY_LANG，以下划线打头的语言变量通常用于系统语言变量，例如 _CLASS_NOT_EXIST_； 配置在ThinkPHP中，一般来说应用的配置文件是自动加载的，加载的顺序是： 惯例配置-&gt;应用配置-&gt;模式配置-&gt;调试配置-&gt;状态配置-&gt;模块配置-&gt;扩展配置-&gt;动态配置 惯例配置 惯例重于配置是系统遵循的一个重要思想，框架内置有一个惯例配置文件（位于ThinkPHP/Conf/convention.php），按照大多数的使用对常用参数进行了默认配置 应用配置 应用配置文件也就是调用所有模块之前都会首先加载的公共配置文件（默认位于Application/Common/Conf/config.php）。 模式配置（可选） 如果使用了普通应用模式之外的应用模式的话，还可以为应用模式（后面会有描述）单独定义配置文件，文件命名规范是： Application/Common/Conf/config_应用模式名称.php（仅在运行该模式下面才会加载）。 调试配置（可选） 如果开启调试模式的话，则会自动加载框架的调试配置文件（位于ThinkPHP/Conf/debug.php）和应用调试配置文件（位于Application/Common/Conf/debug.php） 状态配置（可选） 12345678// 在公司环境中define('APP_STATUS','office');// 那么就会自动加载该状态对应的配置文件（位于Application/Common/Conf/office.php）。// 回家后define('APP_STATUS','home');// 那么就会自动加载该状态对应的配置文件（位于Application/Common/Conf/home.php）。 读取配置无论何种配置文件，定义了配置文件之后，都统一使用系统提供的C方法（可以借助Config单词来帮助记忆）来读取已有的配置。 C(‘参数名称’) 例如，读取当前的URL模式配置参数： 123$model = C('URL_MODEL');// 由于配置参数不区分大小写，因此下面的写法是等效的// $model = C('url_model'); 动态配置 C(‘参数名称’,’新的参数值’) 12// 动态改变缓存有效期C('DATA_CACHE_TIME',60); 也可以支持二维数组的读取和设置，使用点语法进行操作，如下： 1234// 获取已经设置的参数值C('USER_CONFIG.USER_TYPE');// 设置新的值C('USER_CONFIG.USER_TYPE',1); 架构多层MVCThinkPHP基于MVC（Model-View-Controller，模型-视图-控制器）模式，并且均支持多层（multi-Layer）设计。 模型（Model）层例如在某个项目设计中需要区分数据层、逻辑层、服务层等不同的模型层，我们可以在模块目录下面创建Model、Logic和Service目录，把对用户表的所有模型操作分成三层： 数据层：Model/UserModel 用于定义数据相关的自动验证和自动完成和数据存取接口 逻辑层：Logic/UserLogic 用于定义用户相关的业务逻辑 服务层：Service/UserService 用于定义用户相关的服务接口等 视图（View）层视图层由模板和模板引擎组成，在模板中可以直接使用PHP代码，模板引擎的设计会在后面讲述，通过驱动也可以支持其他第三方的模板引擎 控制器（Controller）层ThinkPHP的控制器层由核心控制器和业务控制器组成，核心控制器由系统内部的App类完成，负责应用（包括模块、控制器和操作）的调度控制，包括HTTP请求拦截和转发、加载配置等 CBD模式ThinkPHP引入了全新的CBD（核心Core+行为Behavior+驱动Driver）架构模式。 Core（核心）ThinkPHP的核心部分包括核心函数库、惯例配置、核心类库（包括基础类和内置驱动及核心行为），这些是ThinkPHP必不可少的部分。 1234567891011121314151617181920ThinkPHP/Common/functions.php // 核心函数库ThinkPHP/Conf/convention.php // 惯例配置文件ThinkPHP/Conf/debug.php // 惯例调试配置文件ThinkPHP/Mode/common.php // 普通模式定义文件ThinkPHP/Library/Think // 核心类库包ThinkPHP/Library/Behavior // 系统行为类库ThinkPHP/Library/Think/App.class.php // 核心应用类ThinkPHP/Library/Think/Cache.class.php // 核心缓存类ThinkPHP/Library/Think/Controller.class.php // 基础控制器类ThinkPHP/Library/Think/Db.class.php // 数据库操作类ThinkPHP/Library/Think/Dispatcher.class.php // URL解析调度类ThinkPHP/Library/Think/Exception.class.php // 系统基础异常类ThinkPHP/Library/Think/Hook.class.php // 系统钩子类ThinkPHP/Library/Think/Log.class.php // 系统日志记录类ThinkPHP/Library/Think/Model.class.php // 系统基础模型类ThinkPHP/Library/Think/Route.class.php // 系统路由类ThinkPHP/Library/Think/Storage.class.php // 系统存储类ThinkPHP/Library/Think/Template.class.php // 内置模板引擎类ThinkPHP/Library/Think/Think.class.php // 系统引导类ThinkPHP/Library/Think/View.class.php // 系统视图类 Behavior (行为)Behavior目录下面是系统内置的一些行为类库，内置驱动则分布在各个不同的驱动目录下面（参考下面的驱动部分）。 行为（Behavior）是ThinkPHP扩展机制中比较关键的一项扩展，行为既可以独立调用，也可以绑定到某个标签（位）中进行侦听。 行为类的定义方式如下： 123456789101112namespace Home\\Behavior;class TestBehavior&#123; // 行为扩展的执行入口必须是run public function run(&amp;$params) &#123; if(C('TEST_PARAM')) &#123; echo 'RUNTEST BEHAVIOR '.$params; &#125; &#125;&#125; Driver（驱动）1234567ThinkPHP/Library/Think/Cache/Driver // 缓存驱动类库ThinkPHP/Library/Think/Db/Driver // 数据库驱动类库ThinkPHP/Library/Think/Log/Driver // 日志记录驱动类库ThinkPHP/Library/Think/Session/Driver // Session驱动类库ThinkPHP/Library/Think/Storage/Driver // 存储驱动类库ThinkPHP/Library/Think/Template/Driver // 第三方模板引擎驱动类库ThinkPHP/Library/Think/Template/TagLib // 内置模板引擎标签库扩展类库 自动加载自动加载的优先级在实际的应用类库加载过程中，往往会涉及到自动加载的优先级问题，以Test\\MyClass类为例，自动加载的优先顺序如下： 判断是否有注册了Test\\MyClass类库映射，如果有则自动加载类库映射定义的文件； 判断是否存在Library/Test目录，有则以该目录为初始目录加载； 判断是否有注册Test根命名空间，有则以注册的目录为初始目录加载； 如果以上都不成立，则以Test为模块目录进行初始目录加载； 手动加载第三方类库如果要加载第三方类库，包括不符合命名规范和后缀的类库，以及没有使用命名空间或者命名空间和路径不一致的类库，或者你就是想手动加载类库文件，我们都可以通过手动导入的方式加载。 我们可以使用import方法导入任何类库，用法如下： 12345678// 导入Org类库包 Library/Org/Util/Date.class.php类库import(\"Org.Util.Date\");// 导入Home模块下面的 Application/Home/Util/UserUtil.class.php类库import(\"Home.Util.UserUtil\");// 导入当前模块下面的类库 import(\"@.Util.Array\");// 导入Vendor类库包 Library/Vendor/Zend/Server.class.phpimport('Vendor.Zend.Server'); 系统流程ThinkPHP框架开发的应用的标准执行流程如下： 用户URL请求 调用应用入口文件（通常是网站的index.php） 载入框架入口文件（ThinkPHP.php） 记录初始运行时间和内存开销 系统常量判断及定义 载入框架引导类（Think\\Think）并执行Think::start方法进行应用初始化 设置错误处理机制和自动加载机制 调用Think\\Storage类进行存储初始化（由STORAGE_TYPE常量定义存储类型） 部署模式下如果存在应用编译缓存文件则直接加载（直接跳转到步骤22） 读取应用模式（由APP_MODE常量定义）的定义文件（以下以普通模式为例说明） 加载当前应用模式定义的核心文件（普通模式是 ThinkPHP/Mode/common.php） 加载惯例配置文件（普通模式是 ThinkPHP/Conf/convention.php） 加载应用配置文件（普通模式是 Application/Common/Conf/config.php） 加载系统别名定义 判断并读取应用别名定义文件（普通模式是 Application/Common/Conf/alias.php） 加载系统行为定义 判断并读取应用行为定义文件（普通模式是 Application/Common/Conf/tags.php） 加载框架底层语言包（普通模式是 ThinkPHP/Lang/zh-cn.php） 如果是部署模式则生成应用编译缓存文件 加载调试模式系统配置文件（ThinkPHP/Conf/debug.php） 判断并读取应用的调试配置文件（默认是 Application/Common/Conf/debug.php） 判断应用状态并读取状态配置文件（如果APP_STATUS常量定义不为空的话） 检测应用目录结构并自动生成（如果CHECK_APP_DIR配置开启并且RUNTIME_PATH目录不存在的情况下） 调用Think\\App类的run方法启动应用 应用初始化（app_init）标签位侦听并执行绑定行为 判断并加载动态配置和函数文件 调用Think\\Dispatcher::dispatch方法进行URL请求调度 自动识别兼容URL模式和命令行模式下面的$_SERVER[&#39;PATH_INFO&#39;]参数 检测域名部署以及完成模块和控制器的绑定操作（APP_SUB_DOMAIN_DEPLOY参数开启） 分析URL地址中的PATH_INFO信息 获取请求的模块信息 检测模块是否存在和允许访问 判断并加载模块配置文件、别名定义、行为定义及函数文件 判断并加载模块的动态配置和函数文件 模块的URL模式判断 模块的路由检测（URL_ROUTER_ON开启） PATH_INFO处理（path_info）标签位侦听并执行绑定行为 URL后缀检测（URL_DENY_SUFFIX以及URL_HTML_SUFFIX处理） 获取当前控制器和操作，以及URL其他参数 URL请求调度完成（url_dispatch）标签位侦听并执行绑定行为 应用开始（app_begin）标签位侦听并执行绑定行为 调用SESSION_OPTIONS配置参数进行Session初始化（如果不是命令行模式） 根据请求执行控制器方法 如果控制器不存在则检测空控制器是否存在 控制器开始（action_begin）标签位侦听并执行绑定行为 默认调用系统的ReadHtmlCache行为读取静态缓存（HTML_CACHE_ON参数开启） 判断并调用控制器的_initialize初始化方法 判断操作方法是否存在，如果不存在则检测是否定义空操作方法 判断前置操作方法是否定义，有的话执行 Action参数绑定检测，自动匹配操作方法的参数 如果有模版渲染（调用控制器display方法） 视图开始（view_begin）标签位侦听并执行绑定行为 调用Think\\View的fetch方法解析并获取模版内容 自动识别当前主题以及定位模版文件 视图解析（view_parse）标签位侦听并执行绑定行为 默认调用内置ParseTemplate行为解析模版（普通模式下面） 模版引擎解析模版内容后生成模版缓存 模版过滤替换（template_filter）标签位侦听并执行绑定行为 默认调用系统的ContentReplace行为进行模版替换 输出内容过滤（view_filter）标签位侦听并执行绑定行为 默认调用系统的WriteHtmlCache行为写入静态缓存（HTML_CACHE_ON参数开启） 调用Think\\View类的render方法输出渲染内容 视图结束（view_end）标签位侦听并执行绑定行为 判断后置操作方法是否定义，有的话执行 控制器结束（action_end）标签位侦听并执行绑定行为 应用结束（app_end）标签位侦听并执行绑定行为 执行系统的ShowPageTrace行为（SHOW_PAGE_TRACE参数开启并且不是AJAX请求） 日志信息存储写入 如果是部署模式下面的第二次请求的话，上面的流程中的步骤10~21是可以省略的。 路由规则路由规则表达式1234'my' =&gt; 'Member/myinfo', // 静态地址路由'blog/:id' =&gt; 'Blog/read', // 静态地址和动态地址结合'new/:year/:month/:day'=&gt;'News/read', // 静态地址和动态地址结合':user/:blog_id' =&gt;'Blog/read',// 全动态地址 实例说明假设我们定义了News控制器如下（代码实现仅供参考）： 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Home\\Controller;use Think\\Controller;class NewsController extends Controller&#123; public function read() &#123; $New = M('New'); if(isset($_GET['id'])) &#123; // 根据id查询结果 $data = $New-&gt;find($_GET['id']); &#125; elseif (isset($_GET['name']))&#123; // 根据name查询结果 $data = $New-&gt;getByName($_GET['name']); &#125; $this-&gt;data = $data; $this-&gt;display(); &#125; public function archive()&#123; $New = M('New'); $year = $_GET['year']; $month = $_GET['month']; $begin_time = strtotime($year . $month . \"01\"); $end_time = strtotime(\"+1 month\", $begin_time); $map['create_time'] = array(array('gt',$begin_time),array('lt',$end_time)); $map['status'] = 1; $list = $New-&gt;where($map)-&gt;select(); $this-&gt;list = $list; $this-&gt;display(); &#125;&#125; 定义路由规则如下： 123456'URL_ROUTER_ON' =&gt; true, //开启路由'URL_ROUTE_RULES' =&gt; array( //定义路由规则 'new/:id\\d' =&gt; 'News/read', 'new/:name' =&gt; 'News/read', 'new/:year\\d/:month\\d' =&gt; 'News/archive',), 控制器前置和后置操作12345678910111213141516171819202122232425&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller&#123; //前置操作方法 public function _before_index() &#123; echo 'before&lt;br/&gt;'; &#125; public function index() &#123; echo 'index&lt;br/&gt;'; &#125; //后置操作方法 public function _after_index() &#123; echo 'after&lt;br/&gt;'; &#125;&#125; 伪静态URL伪静态通常是为了满足更好的SEO效果，ThinkPHP支持伪静态URL设置，可以通过设置URL_HTML_SUFFIX参数随意在URL的最后增加你想要的静态后缀，而不会影响当前操作的正常执行。例如，我们设置: 1'URL_HTML_SUFFIX'=&gt;'shtml' 默认情况下，伪静态的设置为html，如果我们设置伪静态后缀为空， 1'URL_HTML_SUFFIX'=&gt;'' 则可以支持所有的静态后缀，并且会记录当前的伪静态后缀到常量 __EXT__ ，但不会影响正常的页面访问。 如果希望支持多个伪静态后缀，可以直接设置如下： 12// 多个伪静态后缀设置 用|分割'URL_HTML_SUFFIX' =&gt; 'html|shtml|xml' 可以设置禁止访问的URL后缀，例如： 1'URL_DENY_SUFFIX' =&gt; 'pdf|ico|png|gif|jpg', // URL禁止访问的后缀设置 注意：URL_DENY_SUFFIX的优先级比URL_HTML_SUFFIX要高。 URL生成为了配合所使用的URL模式，我们需要能够动态的根据当前的URL设置生成对应的URL地址，为此，ThinkPHP内置提供了U方法，用于URL的动态生成，可以确保项目在移植过程中不受环境的影响。 U(‘地址表达式’,[‘参数’],[‘伪静态后缀’],[‘显示域名’]) 123U('User/add') // 生成User控制器的add操作的URL地址U('Blog/read?id=1') // 生成Blog控制器的read操作 并且id为1的URL地址U('Admin/User/select') // 生成Admin模块的User控制器的select操作的URL地址 AJAX返回ThinkPHP可以很好的支持AJAX请求，系统的\\Think\\Controller类提供了ajaxReturn方法用于AJAX调用后返回数据给客户端。并且支持JSON、JSONP、XML和EVAL四种方式给客户端接受数据，并且支持配置其他方式的数据格式返回。 1234567$data = 'ok';$this-&gt;ajaxReturn($data);// 支持返回数组数据：$data['status'] = 1;$data['content'] = 'content';$this-&gt;ajaxReturn($data); 默认配置采用JSON格式返回数据（通过配置DEFAULT_AJAX_RETURN进行设置），我们可以指定格式返回，例如： 1234// 指定XML格式返回数据$data['status'] = 1;$data['content'] = 'content';$this-&gt;ajaxReturn($data,'xml'); 跳转和重定向页面跳转123456789$User = M('User'); //实例化User对象$result = $User-&gt;add($data); if($result)&#123; //设置成功后跳转页面的地址，默认的返回页面是$_SERVER['HTTP_REFERER'] $this-&gt;success('新增成功', '/User/index');&#125; else &#123; //错误页面的默认跳转页面是返回前一页，通常不需要设置 $this-&gt;error('新增失败');&#125; 跳转地址是可选的，success方法的默认跳转地址是$_SERVER[&quot;HTTP_REFERER&quot;]，error方法的默认跳转地址是javascript:history.back(-1);。 默认的等待时间success方法是1秒，error方法是3秒 重定向12//重定向到New模块的Category操作$this-&gt;redirect('New/category', array('cate_id' =&gt; 2), 5, '页面跳转中...'); 输入变量获取变量12345$id = $_GET['id']; // 获取get变量$name = $_POST['name']; // 获取post变量$value = $_SESSION['var']; // 获取session变量$name = $_COOKIE['name']; // 获取cookie变量$file = $_SERVER['PHP_SELF']; // 获取server变量 但是我们不建议直接使用传统方式获取，因为没有统一的安全处理机制，后期如果调整的话，改起来会比较麻烦。所以，更好的方式是在框架中统一使用I函数进行变量获取和过滤。 I(‘变量类型.变量名/修饰符’,[‘默认值’],[‘过滤方法或正则’],[‘额外数据源’]) 变量修饰符 I(‘变量类型.变量名/修饰符’) 123I('get.id/d'); // 强制变量转换为整型I('post.name/s'); // 强制转换变量为字符串类型I('post.ids/a'); // 强制变量转换为数组类型 请求类型 IS_GET：判断是否是GET方式提交 IS_POST：判断是否是POST方式提交 IS_PUT：判断是否是PUT方式提交 IS_DELETE：判断是否是DELETE方式提交 IS_AJAX：判断是否是AJAX提交 REQUEST_METHOD：当前提交类型 1234567891011121314 class UserController extends Controller &#123; public function update() &#123; if (IS_POST) &#123; $User = M('User'); $User-&gt;create(); $User-&gt;save(); $this-&gt;success('保存完成'); &#125; else &#123; $this-&gt;error('非法请求'); &#125; &#125;&#125; 空操作空操作是指系统在找不到请求的操作方法的时候，会定位到空操作（_empty）方法来执行，利用这个机制，我们可以实现错误页面和一些URL的优化。 123456789101112131415161718192021&lt;?phpnamespace Home\\Controller;use Think\\Controller;class CityController extends Controller&#123; public function _empty($name) &#123; //把所有城市的操作解析到city方法 $this-&gt;city($name); &#125; //注意 city方法 本身是 protected 方法 protected function city($name) &#123; //和$name这个城市相关的处理 echo '当前城市' . $name; &#125;&#125; 模型模型定义12345678910111213&lt;?phpnamespace Home\\Model;use Think\\Model;class CategoryModel extends Model&#123; protected $tableName = 'categories'; protected $tablePrefix = 'top_'; protected $trueTableName = 'top_categories'; protected $dbName = 'top';&#125; 模型实例化D方法实例化123456&lt;?php//实例化模型$User = D('User');// 相当于 $User = new \\Home\\Model\\UserModel();// 执行具体的数据操作$User-&gt;select(); 切换数据库如果我们已经在项目配置中定义了其他的数据库连接信息，例如： 1234567891011//数据库配置1'DB_CONFIG1' = array( 'db_type' =&gt; 'mysql', 'db_user' =&gt; 'root', 'db_pwd' =&gt; '1234', 'db_host' =&gt; 'localhost', 'db_port' =&gt; '3306', 'db_name' =&gt; 'thinkphp'),//数据库配置2'DB_CONFIG2' =&gt; 'mysql://root:1234@localhost:3306/thinkphp'; 我们就可以直接在db方法中调用配置进行连接了： 12$this-&gt;db(1,\"DB_CONFIG1\")-&gt;query(\"查询SQL\");$this-&gt;db(2,\"DB_CONFIG2\")-&gt;query(\"查询SQL\"); 如果切换数据库之后，数据表和当前不一致的话，可以使用table方法指定要操作的数据表： 1$this-&gt;db(1)-&gt;table(\"top_user\")-&gt;find(); 连贯操作lockLock方法是用于数据库的锁机制，如果在查询或者执行操作的时候使用： 1lock(true); fetchSqlfetchSql用于直接返回SQL而不是执行查询，适用于任何的CURD操作方法。 例如： 1$result = M('User')-&gt;fetchSql(true)-&gt;find(1); tokentoken方法可用于临时关闭令牌验证，例如： 1$model-&gt;token(false)-&gt;create(); strictstrict为3.2.3新增连贯操作，用于设置数据写入和查询是否严格检查是否存在字段。默认情况下不合法数据字段自动删除，如果设置了严格检查则会抛出异常。 例如: 1$model-&gt;strict(true)-&gt;add($data); indexindex方法用于数据集的强制索引操作，例如： 1$Model-&gt;index('user')-&gt;select(); 查询语言SQL查询QUERY方法12$Model = new \\Think\\Model() // 实例化一个model对象 没有对应任何数据表$Model-&gt;query(\"select * from think_user where status=1\"); EXECUTE方法12$Model = new \\Think\\Model() // 实例化一个model对象 没有对应任何数据表$Model-&gt;execute(\"update think_user set name='thinkPHP' where status=1\"); 动态查询getBy动态查询123$user = $User-&gt;getByName('liu21st');$user = $User-&gt;getByEmail('liu21st@gmail.com');$user = $User-&gt;getByAddress('中国深圳'); getFieldBy动态查询1$userId = $User-&gt;getFieldByName('liu21st','id'); 子查询1、使用select方法 当select方法的参数为false的时候，表示不进行查询只是返回构建SQL，例如： 12// 首先构造子查询SQL $subQuery = $model-&gt;field('id,name')-&gt;table('tablename')-&gt;group('field')-&gt;where($where)-&gt;order('status')-&gt;select(false); 当select方法传入false参数的时候，表示不执行当前查询，而只是生成查询SQL。 2、使用buildSql方法 1$subQuery = $model-&gt;field('id,name')-&gt;table('tablename')-&gt;group('field')-&gt;where($where)-&gt;order('status')-&gt;buildSql(); 调用buildSql方法后不会进行实际的查询操作，而只是生成该次查询的SQL语句（为了避免混淆，会在SQL两边加上括号），然后我们直接在后续的查询中直接调用。 12// 利用子查询进行查询 $model-&gt;table($subQuery.' a')-&gt;where()-&gt;order()-&gt;select() 自动验证动态验证123456789101112131415$rules = array( array('verify','require','验证码必须！'), //默认情况下用正则进行验证 array('name','','帐号名称已经存在！',0,'unique',1), // 在新增的时候验证name字段是否唯一 array('value',array(1,2,3),'值的范围不正确！',2,'in'), // 当值不为空的时候判断是否在一个范围内 array('repassword','password','确认密码不正确',0,'confirm'), // 验证确认密码是否和密码一致 array('password','checkPwd','密码格式不正确',0,'function'), // 自定义函数验证密码格式);$User = M(\"User\"); // 实例化User对象if (!$User-&gt;validate($rules)-&gt;create())&#123; // 如果创建失败 表示验证没有通过 输出错误提示信息 exit($User-&gt;getError());&#125; else &#123; // 验证通过 可以进行其他数据操作&#125; 参数绑定手动绑定123$Model = M('User');$where['name'] = ':name';$list = $Model-&gt;where($where)-&gt;bind(':name',I('name'))-&gt;select(); 目前不支持 ? 方式进行占位符，统一使用 :var 方式进行占位符，驱动内部会自动进行处理。 自动绑定1234$Model = M('User');$Model-&gt;name = 'thinkphp';$Model-&gt;email = 'thinkphp@qq.com';$Model-&gt;add(); 关联模型关联关系123一对一关联 ：ONE_TO_ONE，包括HAS_ONE 和 BELONGS_TO 一对多关联 ：ONE_TO_MANY，包括HAS_MANY 和 BELONGS_TO多对多关联 ：MANY_TO_MANY HAS_ONEHAS_ONE关联表示当前模型拥有一个子对象，例如，每个员工都有一个人事档案。我们可以建立一个用户模型UserModel，并且添加如下关联定义： 1234567namespace Home\\Model;use Think\\Model\\RelationModel;class UserModel extends RelationModel&#123; protected $_link = array( 'Profile'=&gt; self::HAS_ONE, );&#125; BELONGS_TOBelongs_to关联表示当前模型从属于另外一个父对象，例如每个用户都属于一个部门。我们可以做如下关联定义。 1'Dept' =&gt; self::BELONGS_TO HAS_MANYHAS_MANY 关联表示当前模型拥有多个子对象，例如每个用户有多篇文章，我们可以这样来定义： 1'Article' =&gt; self::HAS_MANY MANY_TO_MANYMANY_TO_MANY 关联表示当前模型可以属于多个对象，而父对象则可能包含有多个子对象，通常两者之间需要一个中间表类约束和关联。例如每个用户可以属于多个组，每个组可以有多个用户： 1'Group' =&gt; self::MANY_TO_MANY 关联删除1234//删除用户ID为3的记录的同时删除关联数据$result = $User-&gt;relation(true)-&gt;delete(\"3\");// 如果只需要关联删除部分数据，可以使用$result = $User-&gt;relation(\"Profile\")-&gt;delete(\"3\"); 高级模型字段过滤123protected $_filter = array( '过滤的字段'=&gt;array('写入过滤规则','读取过滤规则',是否传入整个数据对象),); 序列化字段123protected $serializeField = array( 'info' =&gt; array('name', 'email', 'address'),); 文本字段1Protected $blobFields = array('content'); 只读字段1protected $readonlyField = array('name', 'email'); 悲观锁（ Pessimistic Locking ） 悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。 通常是使用for update子句来实现悲观锁机制。 ThinkPHP支持悲观锁机制，默认情况下，是关闭悲观锁功能的，要在查询和更新的时候启用悲观锁功能，可以通过使用之前提到的查询锁定方法，例如： 1$User-&gt;lock(true)-&gt;save($data);// 使用悲观锁功能 乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 如一个金融系统，当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户帐户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对几百上千个并发，这样的情况将导致怎样的后果。乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。 ThinkPHP也可以支持乐观锁机制，要启用乐观锁，只需要继承高级模型类并定义模型的optimLock属性，并且在数据表字段里面增加相应的字段就可以自动启用乐观锁机制了。默认的optimLock属性是lock_version，也就是说如果要在User表里面启用乐观锁机制，只需要在User表里面增加lock_version字段，如果有已经存在的其它字段作为乐观锁用途，可以修改模型类的optimLock属性即可。如果存在optimLock属性对应的字段，但是需要临时关闭乐观锁机制，把optimLock属性设置为false就可以了。 数据分表对于大数据量的应用，经常会对数据进行分表，有些情况是可以利用数据库的分区功能，但并不是所有的数据库或者版本都支持，因此我们可以利用ThinkPHP内置的数据分表功能来实现。帮助我们更方便的进行数据的分表和读取操作。 和数据库分区功能不同，内置的数据分表功能需要根据分表规则手动创建相应的数据表。在需要分表的模型中定义partition属性即可。 123456protected $partition = array( 'field' =&gt; 'name',// 要分表的字段 通常数据会根据某个字段的值按照规则进行分表 'type' =&gt; 'md5',// 分表的规则 包括id year mod md5 函数 和首字母 'expr' =&gt; 'name',// 分表辅助表达式 可选 配合不同的分表规则 'num' =&gt; 'name',// 分表的数目 可选 实际分表的数量 ); 定义好了分表属性后，我们就可以来进行CURD操作了，唯一不同的是，获取当前的数据表不再使用getTableName方法，而是使用getPartitionTableName方法，而且必须传入当前的数据。然后根据数据分析应该实际操作哪个数据表。因此，分表的字段值必须存在于传入的数据中，否则会进行联合查询。 Mongo模型Mongo模型是专门为Mongo数据库驱动而支持的Model扩展，如果需要操作Mongo数据库的话，自定义的模型类必须继承Think\\Model\\MongoModel。 Mongo模型为操作Mongo数据库提供了更方便的实用功能和查询用法，包括： 对MongoId对象和非对象主键的全面支持； 保持了动态追加字段的特性； 数字自增字段的支持； 执行SQL日志的支持； 字段自动检测的支持； 查询语言的支持； MongoCode执行的支持； 视图模板赋值1234$array['name'] = 'thinkphp';$array['email'] = 'liu21st@gmail.com';$array['phone'] = '12335678';$this-&gt;assign($array); 模板渲染12// 不带任何参数 自动定位当前操作的模板文件$this-&gt;display(); 获取模板地址 T([资源://][模块@][主题/][控制器/]操作,[视图分层]) 1234567891011121314T('Public/menu');// 返回 当前模块/View/Public/menu.htmlT('blue/Public/menu');// 返回 当前模块/View/blue/Public/menu.htmlT('Public/menu','Tpl');// 返回 当前模块/Tpl/Public/menu.htmlT('Public/menu');// 如果TMPL_FILE_DEPR 为 _ 返回 当前模块/Tpl/Public_menu.htmlT('Public/menu');// 如果TMPL_TEMPLATE_SUFFIX 为.tpl 返回 当前模块/Tpl/Public/menu.tplT('Admin@Public/menu');// 返回 Admin/View/Public/menu.htmlT('Extend://Admin@Public/menu');// 返回 Extend/Admin/View/Public/menu.html (Extend目录取决于AUTOLOAD_NAMESPACE中的配置） 调试调试模式1234567&lt;?php// 开启调试模式define('APP_DEBUG', true);// 定义应用目录define('APP_PATH', './Application/');// 加载框架入口文件require './ThinkPHP/ThinkPHP.php'; 异常处理123E('新增失败');// 也可以支持异常代码（默认为0），例如：E('信息录入错误',25); 异常模板中可以使用的异常变量有： 1234$e['file']异常文件名$e['line'] 异常发生的文件行数$e['message'] 异常信息$e['trace'] 异常的详细Trace信息 日志记录默认情况下只是在调试模式记录日志，要在部署模式开启日志记录，必须在配置中开启LOG_RECORD参数，以及可以在应用配置文件中配置需要记录的日志级别，例如： 12'LOG_RECORD' =&gt; true, // 开启日志记录'LOG_LEVEL' =&gt;'EMERG,ALERT,CRIT,ERR', // 只记录EMERG ALERT CRIT ERR 错误 日志级别 EMERG 严重错误，导致系统崩溃无法使用 ALERT 警戒性错误， 必须被立即修改的错误 CRIT 临界值错误， 超过临界值的错误 ERR 一般性错误 WARN 警告性错误， 需要发出警告的错误 NOTICE 通知，程序可以运行但是还不够完美的错误 INFO 信息，程序输出信息 DEBUG 调试，用于调试信息 SQL SQL语句，该级别只在调试模式开启时有效 手动记录 Log::record() - 记录日志信息到内存 Log::save() - 把保存在内存中的日志信息（用指定的记录方式）写入 Log::write() - 实时写入一条日志信息 12Think\\Log::record('测试日志信息，这是警告级别','WARN',true);Think\\Log::write('测试日志信息，这是警告级别，并且实时写入','WARN'); 页面Trace12// 显示页面Trace信息'SHOW_PAGE_TRACE' =&gt;true, 页面Trace的选项卡是可以定制和扩展的，默认的配置为： 12345678'TRACE_PAGE_TABS'=&gt;array( 'base'=&gt;'基本', 'file'=&gt;'文件', 'think'=&gt;'流程', 'error'=&gt;'错误', 'sql'=&gt;'SQL', 'debug'=&gt;'调试') Trace方法页面Trace只能用于有页面输出的情况，但是trace方法可以用在任何情况，而且trace方法可以用于AJAX等操作。 1trace('变量','标签','级别','是否记录日志') 断点调试凭借强大的页面Trace信息功能支持，ThinkPHP可以支持断点调试功能。 我们只需要在不同的位置对某个变量进行trace输出即可，例如： 12345$blog = D(\"Blog\");$vo = $blog-&gt;create();trace($vo,'create vo');$vo = $blog-&gt;find();trace($vo,'find vo'); 性能调试开发过程中，有些时候为了测试性能，经常需要调试某段代码的运行时间或者内存占用开销，系统提供了G方法可以很方便的获取某个区间的运行时间和内存占用情况。 例如： 123456G('begin');// ...其他代码段G('end');// ...也许这里还有其他代码// 进行统计区间echo G('begin','end').'s'; 默认的统计精度是小数点后4位，如果觉得这个统计精度不够，还可以设置例如： 1G('begin','end',6).'s'; 如果你的环境支持内存占用统计的话，还可以使用G方法进行区间内存开销统计（单位为kb），例如： 1echo G('begin','end','m').'kb'; 错误调试如果需要我们可以使用E方法输出错误信息并中断执行，例如： 12//输出错误信息，并中止执行E($msg); 模型调试调试执行的SQL语句在模型操作中 ，为了更好的查明错误，经常需要查看下最近使用的SQL语句，我们可以用getLastsql方法来输出上次执行的sql语句。 12345$User = M(\"User\"); // 实例化User对象$User-&gt;find(1);echo $User-&gt;getLastSql();// 3.2版本中可以使用简化的方法echo $User-&gt;_sql(); 调试数据库错误信息12345$User = M(\"User\"); // 实例化User对象$result = $User-&gt;find(1);if(false === $result)&#123; echo $User-&gt;getDbError();&#125; 缓存数据缓存缓存初始化12// 缓存初始化S(array('type'=&gt;'xcache','expire'=&gt;60)); 缓存设置12// 设置缓存S('name',$value); 缓存读取12// 读取缓存$value = S('name'); 缓存删除12// 删除缓存S('name',null); 对象方式操作缓存1234$cache = S(array('type'=&gt;'xcache','prefix'=&gt;'think','expire'=&gt;600));$cache-&gt;name = 'value'; // 设置缓存$value = $cache-&gt;name; // 获取缓存unset($cache-&gt;name); // 删除缓存 缓存队列数据缓存可以支持缓存队列，简单的说就是可以限制缓存的数量，只需要在初始化的时候指定length参数： 1S(array('type'=&gt;'xcache','length'=&gt;100,'expire'=&gt;60)); 快速缓存如果你的存储数据没有有效期的需求，那么系统还提供了一个快速缓存方法F可以用来更快的操作。 F方法可以支持不同的存储类型，如果是文件类型的话，默认保存在DATA_PATH目录下面。 12345678910F('data',$Data);// 快速缓存Data数据，保存到指定的目录F('data',$Data,TEMP_PATH);// 获取缓存数据$Data = F('data');// 删除缓存数据F('data',NULL); F方法支持自动创建缓存子目录，在DATA_PATH目录下面缓存data数据，如果User子目录不存在，则自动创建： 1F('User/data',$Data); 查询缓存1234$Model-&gt;cache(true)-&gt;where('status=1')-&gt;select();// 指定Key$Model-&gt;cache('cache_name')-&gt;select(); 指定key的方式会让查询缓存更加高效。 静态缓存要使用静态缓存功能，需要开启HTML_CACHE_ON参数，并且使用HTML_CACHE_RULES配置参数设置静态缓存规则文件 。 静态规则定义123456789'HTML_CACHE_ON' =&gt; true, // 开启静态缓存'HTML_CACHE_TIME' =&gt; 60, // 全局静态缓存有效期（秒）'HTML_FILE_SUFFIX' =&gt; '.shtml', // 设置静态缓存文件后缀'HTML_CACHE_RULES' =&gt; array( // 定义静态缓存规则 // 定义格式1 数组方式 '静态地址' =&gt; array('静态规则', '有效期', '附加规则'), // 定义格式2 字符串方式 '静态地址' =&gt; '静态规则', ) 安全输入过滤使用I函数过滤使用系统内置的I函数是避免输入数据出现安全隐患的重要手段，I函数默认的过滤方法是htmlspecialchars，如果我们需要采用其他的方法进行安全过滤，有两种方式： 如果是全局的过滤方法，那么可以设置DEFAULT_FILTER，例如： 1'DEFAULT_FILTER' =&gt; 'strip_tags', 当然，我们也可以设置多个过滤方法，例如： 1'DEFAULT_FILTER' =&gt; 'strip_tags,stripslashes', 如果是仅需要对个别数据采用特殊的过滤方法，可以在调用I函数的时候传入过滤方法，例如： 12I('post.id', 0, 'intval'); // 用intval过滤$_POST['id']I('get.title', '', 'strip_tags'); // 用strip_tags过滤$_GET['title'] 写入数据过滤1$this-&gt;data($data)-&gt;filter('strip_tags')-&gt;add(); 表单合法性检测配置insertFields 和 updateFields属性123456789&lt;?phpnamespace Home\\Model;class UserModel extends \\Think\\Model &#123; protected $insertFields = array('account','password','nickname','email'); protected $updateFields = array('nickname','email'); &#125; 直接调用field方法1M('User')-&gt;field('account,password,nickname,email')-&gt;create(); 表单令牌要启用表单令牌功能，需要配置行为绑定，在应用或者模块的配置目录下面的行为定义文件tags.php中，添加： 123456return array( // 添加下面一行定义即可 'view_filter' =&gt; array('Behavior\\TokenBuild'), // 如果是3.2.1以上版本 需要改成 // 'view_filter' =&gt; array('Behavior\\TokenBuildBehavior'),); 表示在view_filter标签位置执行表单令牌检测行为。 表单令牌验证相关的配置参数有： 1234'TOKEN_ON' =&gt; true, // 是否开启令牌验证 默认关闭'TOKEN_NAME' =&gt; '__hash__', // 令牌验证的表单隐藏字段名称，默认为__hash__'TOKEN_TYPE' =&gt; 'md5', //令牌哈希验证规则 默认为MD5'TOKEN_RESET' =&gt; true, //令牌验证出错后是否重置令牌 默认为true 如果开启表单令牌验证功能，系统会自动在带有表单的模板文件里面自动生成以TOKEN_NAME为名称的隐藏域，其值则是TOKEN_TYPE方式生成的哈希字符串，用于实现表单的自动令牌验证。 如果个别页面输出不希望进行表单令牌验证，可以在控制器中的输出方法之前动态关闭表单令牌验证，例如： 12C('TOKEN_ON',false);$this-&gt;display(); 模型类在创建数据对象的同时会自动进行表单令牌验证操作，如果你没有使用create方法创建数据对象的话，则需要手动调用模型的autoCheckToken方法进行表单令牌验证。如果返回false，则表示表单令牌验证错误。例如： 12345$User = M(\"User\"); // 实例化User对象// 手动进行令牌验证if (!$User-&gt;autoCheckToken($_POST))&#123;// 令牌验证错误&#125; 防止SQL注入 要有效的防止SQL注入问题，我们建议： 查询条件尽量使用数组方式，这是更为安全的方式； 如果不得已必须使用字符串查询条件，使用预处理机制 使用自动验证和自动完成机制进行针对应用的自定义过滤； 如果环境允许，尽量使用PDO方式，并使用参数绑定。 查询条件预处理where方法使用字符串条件的时候，支持预处理（安全过滤），并支持两种方式传入预处理参数，例如： 123$Model-&gt;where(\"id=%d and username='%s' and xx='%f'\",array($id,$username,$xx))-&gt;select();// 或者$Model-&gt;where(\"id=%d and username='%s' and xx='%f'\",$id,$username,$xx)-&gt;select(); 目录安全文件为了避免某些服务器开启了目录浏览权限后可以直接在浏览器输入URL地址查看目录，系统默认开启了目录安全文件机制，会在自动生成目录的时候生成空白的index.html文件，当然安全文件的名称可以设置，例如你想给安全文件定义为default.html可以在入口文件中添加： 123define('DIR_SECURE_FILENAME', 'default.html');define('APP_PATH','./Application/');require './ThinkPHP/ThinkPHP.php'; 还可以支持多个安全文件写入，例如你想同时写入index.html和index.htm两个文件，以满足不同的服务器部署环境，可以这样定义： 1define('DIR_SECURE_FILENAME', 'index.html,index.htm'); 默认的安全文件只是写入一个空白字符串，如果需要写入其他内容，可以通过DIR_SECURE_CONTENT参数来指定，例如： 1define('DIR_SECURE_CONTENT', 'deny Access!'); 注意：目录安全文件仅在第一次生成模块目录的时候生成。如果是3.2.1版本以上，则可以调用代码生成，例如： 12// dirs变量是要生成安全文件的目录数组\\Think\\Build::buildDirSecure($dirs); 上传安全网站的上传功能也是一个非常容易被攻击的入口，所以对上传功能的安全检查是尤其必要的。 系统提供的上传类Think\\Upload提供了安全方面的支持，包括对文件后缀、文件类型、文件大小以及上传图片文件的合法性检查，确保你已经在上传操作中启用了这些合法性检查。 防止XSS攻击 XSS（跨站脚本攻击） 可以用于窃取其他用户的Cookie信息，要避免此类问题，可以采用如下解决方案： 直接过滤所有的JavaScript脚本； 转义Html元字符，使用htmlentities、htmlspecialchars等函数； 系统的扩展函数库提供了XSS安全过滤的remove_xss方法； 新版对URL访问的一些系统变量已经做了XSS处理。 部署PATH_INFO支持 如果发生在本地测试正常，但是一旦部署到服务器环境后会发生只能访问首页的情况，很有可能是你的服务器或者空间不支持PATH_INFO所致。 如果你的环境没有任何对应的系统变量，那么可以封装一个获取方法，例如： 1234function get_path_info()&#123; // 根据你的环境兼容获取PATH_INFO 具体代码略 return $path; // 直接返回获取到的PATH_INFO信息&#125; 然后我们修改下URL_PATHINFO_FETCH参数的配置值，改为： 1'URL_PATHINFO_FETCH' =&gt; ':get_path_info' URL重写[ Apache ] httpd.conf配置文件中加载了mod_rewrite.so模块 AllowOverride None 将None改为 All 把下面的内容保存为.htaccess文件放到应用入口文件的同级目录下 123456&lt;IfModule mod_rewrite.c&gt; RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt; [ Nginx ]在Nginx低版本中，是不支持PATHINFO的，但是可以通过在Nginx.conf中配置转发规则实现： 123456location / &#123; // …..省略部分代码 if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=$1 last; break; &#125;&#125; 如果你的ThinkPHP安装在二级目录，Nginx的伪静态方法设置如下，其中youdomain是所在的目录名称。 12345location /youdomain/ &#123; if (!-e $request_filename)&#123; rewrite ^/youdomain/(.*)$ /youdomain/index.php?s=$1 last; &#125;&#125; 替换入口 我们的建议是在生产环境中关闭调试模式后生成Lite文件。注意，目前SAE平台不支持直接生成Lite文件。 生成Lite文件要生成Lite文件，需要在入口文件中增加常量定义： 1define('BUILD_LITE_FILE',true); 默认情况下，再次运行后会在Runtime目录下面生成一个lite.php文件。 如果你需要修改Lite文件的位置或者名称，可以在应用配置文件中增加配置如下： 1'RUNTIME_LITE_FILE'=&gt; APP_PATH.'lite.php' 配置后，生成的Lite文件的位置为 APP_PATH.&#39;lite.php&#39; Lite文件的编译文件内容是系统默认的，如果希望改变或者增加其他的编译文件的话，可以在外部定义编译列表文件，例如： 我们在应用配置目录下面增加lite.php定义如下： 12345678910111213141516171819return array( THINK_PATH.'Common/functions.php', COMMON_PATH.'Common/function.php', CORE_PATH . 'Think'.EXT, CORE_PATH . 'Hook'.EXT, CORE_PATH . 'App'.EXT, CORE_PATH . 'Dispatcher'.EXT, CORE_PATH . 'Model'.EXT, CORE_PATH . 'Log'.EXT, CORE_PATH . 'Log/Driver/File'.EXT, CORE_PATH . 'Route'.EXT, CORE_PATH . 'Controller'.EXT, CORE_PATH . 'View'.EXT, CORE_PATH . 'Storage'.EXT, CORE_PATH . 'Storage/Driver/File'.EXT, CORE_PATH . 'Exception'.EXT, BEHAVIOR_PATH . 'ParseTemplateBehavior'.EXT, BEHAVIOR_PATH . 'ContentReplaceBehavior'.EXT,); 所有在lite.php文件中定义的文件都会纳入Lite文件的编译缓存中。你还可以对生成的lite文件进行修改。 如果你修改了框架文件和应用函数和配置文件的话，需要删除Lite文件重新生成。 替换入口Lite文件生成后，就可以把原来的应用入口文件中的框架入口文件修改如下： 123require './ThinkPHP/ThinkPHP.php';// 改成require './Runtime/lite.php'; 替换应用入口文件如果你的入口文件没有其他代码和逻辑的话，还可以直接把lite.php文件作为应用的入口文件访问。把lite.php文件复制到应用入口文件的相同目录，并直接改名为index.php即可和原来一样正常访问（原来的应用入口文件可以备份以备用于重新生成Lite文件的时候使用）。 注意：如果你的环境或者目录位置发生变化，以及更改了核心框架和应用函数、配置等文件后，则需要重新生成Lite文件。 专题session初始化设置1234567891011121314151617181920212223242526// session赋值session('name','value'); //设置sessionsession('user.user_id',10); //设置session// session取值$value = session('name');// 获取所有的session 3.2.2版本新增$value = session();$value = session('user.user_id');// session删除session('name',null); // 删除namesession('user.user_id',null); // 删除sessionsession(null); // 清空当前的session// session判断// 判断名称为name的session值是否已经设置session('?name');session('?user.user_id');// session管理session('[操作名]');session('[pause]'); // 暂停session写入session('[start]'); // 启动sessionsession('[destroy]'); // 销毁sessionsession('[regenerate]'); // 重新生成session id Cookie支持1234567891011121314151617// Cookie设置cookie('name','value'); //设置cookiecookie('name','value',3600); // 指定cookie保存时间cookie('name','value',array('expire'=&gt;3600,'prefix'=&gt;'think_'))cookie('name','value','expire=3600&amp;prefix=think_')// Cookie获取$value = cookie('name');$value = $_COOKIE['name'];$value = $_COOKIE['前缀+name'];$value = cookie();$value = $_COOKIE;// Cookie删除cookie('name',null);cookie(null); // 清空当前设定前缀的所有cookie值cookie(null,'think_'); // 清空指定前缀的所有cookie值 数据分页利用Page类和limit方法分页123456789$User = M('User'); // 实例化User对象$count = $User-&gt;where('status=1')-&gt;count();// 查询满足要求的总记录数$Page = new \\Think\\Page($count,25);// 实例化分页类 传入总记录数和每页显示的记录数(25)$show = $Page-&gt;show();// 分页显示输出// 进行分页数据查询 注意limit方法的参数要使用Page类的属性$list = $User-&gt;where('status=1')-&gt;order('create_time')-&gt;limit($Page-&gt;firstRow.','.$Page-&gt;listRows)-&gt;select();$this-&gt;assign('list',$list);// 赋值数据集$this-&gt;assign('page',$show);// 赋值分页输出$this-&gt;display(); // 输出模板 分页类和page方法的实现分页123456789$User = M('User'); // 实例化User对象// 进行分页数据查询 注意page方法的参数的前面部分是当前的页数使用 $_GET[p]获取$list = $User-&gt;where('status=1')-&gt;order('create_time')-&gt;page($_GET['p'].',25')-&gt;select();$this-&gt;assign('list',$list);// 赋值数据集$count = $User-&gt;where('status=1')-&gt;count();// 查询满足要求的总记录数$Page = new \\Think\\Page($count,25);// 实例化分页类 传入总记录数和每页显示的记录数$show = $Page-&gt;show();// 分页显示输出$this-&gt;assign('page',$show);// 赋值分页输出$this-&gt;display(); // 输出模板 常见问题 [Composer\\Downloader\\TransportException] Your configuration does not allow connections to http://packagi st.phpcomposer.com/packages.json. See https://getcomposer.org/d oc/06-config.md#secure-http for details. 解决：composer国内镜像不能使用","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"ThinkPHP3.2","slug":"ThinkPHP3-2","permalink":"http://blog.caoxl.com/tags/ThinkPHP3-2/"},{"name":"TP3.2","slug":"TP3-2","permalink":"http://blog.caoxl.com/tags/TP3-2/"}]},{"title":"PHP操作Redis","slug":"PHP-OPT-Redis","date":"2018-09-29T15:40:44.000Z","updated":"2019-08-22T06:35:54.000Z","comments":true,"path":"2018/09/29/PHP-OPT-Redis/","link":"","permalink":"http://blog.caoxl.com/2018/09/29/PHP-OPT-Redis/","excerpt":"这里主要是用的predis","text":"这里主要是用的predis 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?php$redis = new redis();$redis-&gt;connect('127.0.01', '6379') || die('Connect failed');$redis-&gt;auth('admin'); // 授权//**********************Key(键)******************************$redis-&gt;keys('*'); //返回所有key$redis-&gt;keys('s*'); //返回所有s开头的key$redis-&gt;exists('key'); //判断该key是否存在$redis-&gt;del('key'); //删除该key$redis-&gt;expire('key', 3600); //设置key 过期时间3600s$redis-&gt;ttl('key'); //查看过期剩余时间s$redis-&gt;select('db_index'); //选择数据库$redis-&gt;set('key', 'val'); //设置key=&gt;value$redis-&gt;get('key'); //根据key获取value$redis-&gt;move('key', 'db_index_2'); //把key移到另一个数据库$redis-&gt;persist('key'); //移除过期时间$redis-&gt;randomKey(); // 随机返回一个key$redis-&gt;type('key'); //获取key类型$redis-&gt;dbSize(); //获取数据库key个数$redis-&gt;info(); //获取redis服务信息$redis-&gt;echo('hello world'); //输出函数//**********************Key(键)******************************//**********************string类型***************************// String 是最简单的类型，一个Key对应一个Value，String类型是二进制安全的。Redis的String可以包含任何数据，比如jpg图片或者序列化的对象$redis-&gt;set('test', 1024); //赋值$redis-&gt;mset(array('key0'=&gt;'val0','key1'=&gt;'val1')); //批量赋值$redis-&gt;mget(array('key0', 'key1')); //批量获取值$redis-&gt;setnx('key', 'val'); //设置key对应的值为string类型的value,如果key已经存在，返回0,nx是not exist的意思$redis-&gt;msetnx(array('key0' =&gt; 'val0', 'key1' =&gt; 'val1')); //全部成功返回1，否则失败一个也返回0$redis-&gt;getSet('key', 'new_val'); //getSet设置key的值，并返回key的旧值$redis-&gt;setex('key', 10, 'val10'); //带生存时间的写入值单位s$redis-&gt;setRange('key', 0, 'hello'); //设置子字符串替换，key，开始位置，替换值$redis-&gt;getRange('key', 0, 2); //getRange获取子字符串，getRange key start end$redis-&gt;ttl('key'); //获取key的生存时间,没设置的为-1$redis-&gt;keys('*a*'); //获取所有key，也可获取具体key，模糊匹配key$redis-&gt;get('key'); //根据key获取value$redis-&gt;getMultiple(array('key1', 'key2', 'key3')); //批量根据key获取value$exits = $redis-&gt;exists('key'); //判断key是否存在。存在 true 不存在 false$redis-&gt;delete('key1', 'key2'); //删除,可删除多个$redis-&gt;delete(array('key3', 'key4', 'key5')); //删除多个$redis-&gt;delete($redis-&gt;keys('*')); //传数组，删除所有key$redis-&gt;incr('key'); //自增，默认值1$redis-&gt;incrBy('key', 10); //必须给定参数值$redis-&gt;decr('key'); //自减，默认值1$redis-&gt;decrBy('key', 10); //必须给定参数值$redis-&gt;append('key', 'append_val'); //给指定的key的字符串追加value,返回新字符串的长度$redis-&gt;strlen('key'); //获取指定key的字符串长度//**********************string类型***************************//**********************hash类型*****************************// Redis hash是一个string类型的field和value的映射表。它的添加删除都是0(1)// hash特别适合用于存储对象。相对于将对象的每个字段存成单个string类型。// 将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。$redis-&gt;flushAll(); //清空所有数据库$redis-&gt;flushDB(); //清空当前数据库$redis-&gt;hSet('key', 'hash_key', 'val'); //单个设置$redis-&gt;hGet('key','hash_key'); // 单个获取$redis-&gt;hSetNx('key', 'hash_key', 'val'); //设置hash field 为指定的值value,如果field已经存在，返回0,nx是not exist的意思$redis-&gt;hMset('key', array('a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3)); //批量设置$redis-&gt;hMGet('key', array('a','b','c')); //批量获取$redis-&gt;hIncrBy('key', 'hash_key', 'val'); //设置hash field 添加key和value$redis-&gt;hExists('key', 'hash_key'); //测试hash field 存在1，不存在0$redis-&gt;hLen('key'); //返回hash 里所有的 field 的数量$redis-&gt;hDel('key', 'hash_key'); //删除指定hash的field$redis-&gt;hKeys('key'); //返回hash 所有 field$redis-&gt;hVals('key'); //返回hash 所有 field values$redis-&gt;hGetAll('key'); //获取hash中全部的field和value//**********************hash类型***************************//**********************list链表***************************// 栈先进后出；队列先进先出；// List 是一个链表结构，主要功能是push,pop,获取一个范围的所有值等等，操作中key理解为链表的名字。// Redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push,pop操作从链表的头部或者尾部添加删除元素，这样LIST既可以作为栈，又可以作为队列。$redis-&gt;lRange('key', 'start', 'end'); //取链表list 从start位开始取到最后位置；start代表头 end代表尾$redis-&gt;lPush('key', 'val'); //在key对应的list的头部添加字符串元素$redis-&gt;rPush('key', 'val'); //在key对应的list的尾部添加字符串元素$redis-&gt;lPop('key'); //在key对应的list的头部删除字符串元素，并返回删除字符$redis-&gt;rPop('key'); //在key对应的list的尾部删除字符串元素，并返回删除字符$redis-&gt;lRem('key', 'val', 'n'); //在list中删除N个和value相同的元素(n&lt;0从尾删除,n=0全部删除),返回的值为删除的个数$redis-&gt;lSet('key', '-1', 'val'); //设置list中指定下标的元素值 lSet(list,位置，值)，位置可以从头或者从尾$redis-&gt;lIndex('key', 0); //返回list中index位置的元素$redis-&gt;lLen('key'); //返回list的长度$redis-&gt;lTrim('key', 'start_0', 'end_-1'); //保留指定key的值的范围内的数据 0为头 -1为尾$redis-&gt;lInsert('key', 'position', 'pivot', 'val'); //将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。$redis-&gt;rpoplpush('srcKey', 'dstKey'); //从第一个LIST的尾部移除元素并添加到第二个LIST的头部//**********************list链表***************************//**********************set集合****************************// Set是集合，它是string类型的无序集合。set是通过hash table实现的，添加，删除和查找的复杂程度都是0(1)// 对集合我们可以取并集，交集，差集。通过这些操作我们可以实现SNS中的好友推荐和blog的tag功能$redis-&gt;sAdd('key', 'val1', 'val2'); //向集合中添加元素$redis-&gt;sMembers('key'); //集合元素列表$redis-&gt;sRem('key', 'member1', 'member2'); //集合移除元素$redis-&gt;sPop('key'); //随机删除集合元素并返回删除的元素。删除最后一个元素时，则集合也被删除$redis-&gt;sDiff('key1', 'key2'); //取多个集合的差集，谁在前面已谁为标准（差集就是前面第一个集合有而后面所有集合都没有）$redis-&gt;sDiffStore('dstKey', 'key1', 'key2'); //返回多个集合的差集，存在第三个集合里面$redis-&gt;sInter('key1', 'key2'); //交集（所有集合都有的元素）$redis-&gt;sInterStore('dstKey', 'key1', 'key2'); //取多个集合的交集,存在第三个集合里面$redis-&gt;sUnion('key1', 'key2'); //并集（所有集合合并去重的元素）$redis-&gt;sUnionStore('dstKey', 'key1', 'key2'); //取多个集合的并集,存在第三个集合里面$redis-&gt;sMove('srcKey', 'dstKey', 'member'); //第一个集合元素剪切到第二个集合里面$redis-&gt;sCard('key'); //返回集合中元素的个数$redis-&gt;sIsMember('key', 'val'); //判断某个元素是否为集合的元素$redis-&gt;sRandMember('key', 'count_num'); //随机返回集合内的一个元素，不会删除元素//**********************set集合***************************//**********************set有序集合***************************//**********************set有序集合***************************//**********************其他***************************//string来存储用户的最大id,用来id的自增//hash 表来存储用户的详细信息//list链表结构来存储用户的id号$uid = $redis-&gt;incr('blog:id'); //自增长$res = $redis-&gt;hMset('blog:user:' . $uid, array('id' =&gt; $uid, 'username' =&gt;'admin'.time() . time(), 'password' =&gt; md5(time()))); //hash表插入一条记录$redis-&gt;rPush('blog:uid', $uid);$res = $redis-&gt;hGetAll('blog:user:' . $uid);$redis-&gt;del('blog:user:' . $uid); //删除用户$redis-&gt;lRem('blog:uid', $uid, 'count'); //删除链表中的id$count = $redis-&gt;lSize('blog:uid'); //返回名称为key的list有多少个元素$page_size = 3;$page_num = !empty($_GET['page']) ? $_GET['page'] : 1;$page_count = ceil($count / $page_size);$ids = $redis-&gt;lrange(\"blog:uid\", ($page_num - 1) * $page_size, (($page_num - 1) * $page_size + $page_size - 1));foreach ($ids as $v) &#123; $result[] = $redis-&gt;hgetall(\"blog:user:\" . $v); //获取记录&#125;echo\"&lt;pre&gt;\";print_r($result);","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"}]},{"title":"啊 有趣的Linux","slug":"How-Funny-Linux","date":"2018-09-12T12:18:58.000Z","updated":"2018-11-15T08:27:23.000Z","comments":true,"path":"2018/09/12/How-Funny-Linux/","link":"","permalink":"http://blog.caoxl.com/2018/09/12/How-Funny-Linux/","excerpt":"玩Linux其乐无穷…","text":"玩Linux其乐无穷… 命令：cmatrix安装12345brew install cmatrix# Oryum install cmatrix# Orapt-get install cmatrix 编译安装1234wget https://jaist.dl.sourceforge.net/project/cmatrix/cmatrix/1.2a/cmatrix-1.2a.tar.gztar -zxvf cmatrix-1.2a.tar.gzcd cmatrix-1.2a./configure &amp;&amp; make &amp;&amp; make install 输出1caoxl@cxllcdeMacBook-Pro % cmatrix 命令：sl （蒸汽机车）安装12345brew install sl# Oryum install sl# Orapt-get install sl 输出1caoxl@cxllcdeMacBook-Pro % sl 安装12345brew install oneko# Oryum install oneko# Orapt-get install oneko 命令：telnet 你可能很熟悉telnet。Telnet 是一个文本化的双向网络协议。这里不需要安装什么东西。你需要的就是一个Linux系统和一个连通的网络。 输出1telnet towel.blinkenlights.nl 命令：fortune/fortune-zh试试你未知的运气，终端里有时也有好玩的。 安装1234567brew install fortune# Oryum install fortune# Oryum -y install fortune-mod# Orapt-get install fortune 中文包12git clone git@github.com:ruanyf/fortunes.gitmv fortunes/data/* /usr/share/games/fortune/ 命令：rev（翻转） 它会把传递给它的的每个字符串都反过来 12345$ rev caoxllxoachello worlddlrow olleh 命令：Cowsay一个在终端用ASCII码组成的小牛，这个小牛会说出你想要它说的话。 安装12345brew install cowsay# Oryum install cowsay# Orapt-get install cowsay 输出12345678910╭─caoxl@cxllcdeMacBook-Pro in ~╰$ cowsay i love lc ___________&lt; i love lc &gt; ----------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || 如果用管道将‘fortune command’命令重定向到cowsay会怎样呢？ 1234567891011121314151617181920212223242526272829caoxl$ fortune | cowsay ________________________________________/ Talking Pinhead Blues: Oh, I LOST my \\| ``HELLO KITTY'' DOLL and I get BAD || reception on channel || || TWENTY-SIX!! || || Th'HOSTESS FACTORY is closin' down and || I just heard ZASU PITTS has been || || DEAD for YEARS.. (sniff) || || My PLATFORM SHOE collection was CHEWED || up by th' dog, ALEXANDER HAIG || || won't let me take a SHOWER 'til Easter || ... (snurf) || || So I went to the kitchen, but WALNUT || PANELING whup me upside mah HAID!! || |\\ (on no, no, no.. Heh, heh) / ---------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || 提示：‘|’是管道命令符。通常它是将一个命令的输出作为下一个命令的输入。在上面的例子中‘fortune’的输出作为‘cowsay’命令的输出。管道命令会经常用在脚本和程序编写中。 xcowsayxcowsay是一个图形界面程序。它与cowsay类似只是以一种图形的方式来表达，可以说是X版本的cowsay。 12345brew install xcowsay# Oryum install xcowsay# Orapt-get install xcowsay cowthink cowthink是另一个命令。运行“cowthink Linux is sooo funny ”看看它与cowsay的不同吧。 123456789caoxl$ cowthink linux is so funny ___________________( linux is so funny ) ------------------- o ^__^ o (oo)\\_______ (__)\\ )\\/\\ ||----w | || || 命令: toilet安装12345brew install toilet# Oryum install toilet# Orapt-get install toilet 输出1234567caoxl@cxllcdeMacBook-Pro: ~ $ toilet tecmint m \" m mm#mm mmm mmm mmmmm mmm m mm mm#mm # #\" # #\" \" # # # # #\" # # # #\"\"\"\" # # # # # # # # \"mm \"#mm\" \"#mm\" # # # mm#mm # # \"mm 更多 linux 20个有趣命令 动画演示10个有趣但毫无用处的Linux命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"FastAdmin 初次使用","slug":"Learn-FastAdmin-Notes","date":"2018-09-10T11:48:26.000Z","updated":"2019-08-22T03:39:16.000Z","comments":true,"path":"2018/09/10/Learn-FastAdmin-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/09/10/Learn-FastAdmin-Notes/","excerpt":"FastAdmin是一款基于ThinkPHP5+Bootstrap的极速后台开发框架。","text":"FastAdmin是一款基于ThinkPHP5+Bootstrap的极速后台开发框架。 安装命令行安装 克隆FastAdmin到你本地 1git clone https://gitee.com/karson/fastadmin.git 进入目录 1cd fastadmin 下载前端插件依赖包 1bower install 下载PHP依赖包 1composer install 一键创建数据库并导入数据 1php think install -u 数据库用户名 -p 数据库密码 添加虚拟主机并绑定到fastadmin/public目录 命令行一键生成CRUD1234567891011121314151617181920212223242526272829//生成fa_test表的CRUDphp think crud -t test//生成fa_test表的CRUD且一键生成菜单php think crud -t test -u 1//删除fa_test表生成的CRUDphp think crud -t test -d 1//生成fa_test表的CRUD且控制器生成在二级目录下php think crud -t test -c mydir/test//生成fa_test_log表的CRUD且生成对应的控制器为testlogphp think crud -t test_log -c testlog//生成fa_test表的CRUD且对应的模型名为testmodelphp think crud -t test -m testmodel//生成fa_test表的CRUD且生成关联模型category，外链为category_id，关联表主键为idphp think crud -t test -r category -k category_id -p id//生成fa_test表的CRUD且所有以list或data结尾的字段都生成复选框php think crud -t test --setcheckboxsuffix=list --setcheckboxsuffix=data//生成fa_test表的CRUD且所有以image和img结尾的字段都生成图片上传组件php think crud -t test --imagefield=image --setcheckboxsuffix=img//关联多个表,参数传递时请按顺序依次传递，支持以下几个参数relation/relationmodel/relationforeignkey/relationprimarykey/relationfields/relationmodephp think crud -t test --relation=category --relation=admin --relationforeignkey=category_id --relationforeignkey=admin_id 一键生成菜单1234567891011//一键生成test控制器的权限菜单php think menu -c test//一键生成mydir/test控制器的权限菜单php think menu -c mydir/test//删除test控制器生成的菜单php think menu -c test -d 1//一键全部重新所有控制器的权限菜单php think menu -c all-controller 一键压缩打包1234567891011//一键压缩打包前后台的JS和CSSphp think min -m all -r all//一键压缩打包后台的JS和CSSphp think min -m backend -r all//一键压缩打包前后台的JSphp think min -m all -r js//一键压缩打包后台的CSSphp think min -m backend -r css 一键生成API文档1234567891011121314151617//一键生成API文档php think api --force=true//指定https://www.example.com为API接口请求域名,默认为空php think api -u https://www.example.com --force=true//输出自定义文件为myapi.html,默认为api.htmlphp think api -o myapi.html --force=true//修改API模板为mytemplate.html，默认为index.htmlphp think api -e mytemplate.html --force=true//修改标题为FastAdmin,作者为作者php think api -t FastAdmin -a Karson --force=true//查看API接口命令行帮助php think api -h 一键管理插件1234567891011121314151617181920212223//创建一个myaddon本地插件，常用于开发自己的插件时使用php think addon -a myaddon -c create//刷新插件缓存，如果禁用启用了插件，部分文件需要刷新才会生效php think addon -a example -c refresh//远程安装example插件php think addon -a example -c install//卸载本地的example插件php think addon -a example -c uninstall//启用本地的example插件php think addon -a example -c enable//禁用本地的example插件php think addon -a example -c disable//升级本地的example插件php think addon -a example -c upgrade//将本地的example插件打包成zip文件php think addon -a example -c package 一键安装FastAdmin123456789101112//一键安装FastAdminphp think install//配置数据库连接地址为127.0.0.1php think install -a 127.0.0.1//配置数据库用户名密码php think install -u root -p 123456//配置数据库表名为dbnamephp think install -d dbname//配置数据库表前缀为ff_php think install -p ff_//强制重新安装FastAdminphp think install -f 1 插件插件市场 https://www.fastadmin.net/store.html 多语言在FastAdmin中可以在任何位置(控制器、视图、JS)使用__(&#39;语言标识&#39;);调用语言包，如果语言标识不存在，则直接输出该语言标识. 使用方法FastAdmin中的__函数和ThinkPHP中的lang函数在传参上有些许区别 比如: 1__('My name is %s', \"FastAdmin\"); 将会返回: 1My name is FastAdmin 而如果采用ThinkPHP中的lang中的写法则是 1lang('My name is %s', [\"FastAdmin\"]); 可以看到ThinkPHP中的第二个参数必须传入数组，而FastAdmin中的__则没有这个要求，其实在多个参数时FastAdmin会忽略掉第三个参数$lang 如果需要在HTML视图文件中使用多语言，则需要使用{:__(&#39;Home&#39;)}的方式调用，而在PHP和JS中均可以使用__(&#39;Home&#39;)的方式发起调用。 加载方式在FastAdmin当中，框架会自动按照当前请求的控制器进行加载对应的语言包。例如当前我们是中文环境，如果我们请求的是 1https://demo.fastadmin.net/admin/dashboard/index 则FastAdmin会自动加载 12application/admin/lang/zh-cn.phpapplication/admin/lang/zh-cn/Dashboard.php 这两个语言包。 如果我们请求的路径是 1https://demo.fastadmin.net/admin/general/config/index 则FastAdmin会自动加载 12application/admin/lang/zh-cn.phpapplication/admin/lang/zh-cn/general/Config.php 可以看到FastAdmin会默认加载zh-cn.php这个全局语言包。 如果我们需要跨模块引入其它模块的语言包，则可以在 控制器中使用loadlang方法来引入，如 1$this-&gt;loadlang('模块名'); 如果需要在JS中跨模块引入语言包，则需要修改Ajax.php中的lang这个方法。 数据库这里提供的是数据库表字段规则在你创建表时使用，当按如下的规则进行字段命名、类型设置和备注时使用php think crud -t 表名生成CRUD时会自动生成对应的HTML元素和组件 根据字段类型 类型: 备注 – 类型说明 int: 整形 – 自动生成type为number的文本框，步长为1 enum: 枚举型 – 自动生成单选下拉列表框 set: set型 – 自动生成多选下拉列表框 float: 浮点型 – 自动生成type为number的文本框，步长根据小数点位数生成 text: 文本型 – 自动生成textarea文本框 datetime: 日期时间 – 自动生成日期时间的组件 date: 日期型 – 自动生成日期型的组件 timestamp: 时间戳 – 自动生成日期时间的组件 控制器基类控制器123application/common/controller/Api.php //API接口基类控制器application/common/controller/Backend.php //后台基类控制器application/common/controller/Frontend.php //前台基类控制器 基础结构在后台中我们的控制器都必须继承自\\app\\common\\controller\\Backend这个基类，其中控制器的index/add/edit/del/multi/recyclebin/destroy/restore/import/selectpage全都是可选的方法，基类的这些方法使用traits进行引入，具体位置在application/admin/library/traits/Backend.php中，CRUD生成的标准控制器如下： 12345678910111213141516171819202122232425262728&lt;?phpnamespace app\\admin\\controller;/** * 文章管理 * * @icon fa fa-list * @remark 用于统一管理网站的所有文章 */class Article extends Backend&#123; protected $model = null; protected $noNeedLogin = []; protected $noNeedRight = ['selectpage']; public function _initialize() &#123; parent::_initialize(); &#125; /** * 默认生成的控制器所继承的父类中有index/add/edit/del/multi/destroy/restore/recyclebin八个方法 * 因此在当前控制器中可不用编写增删改查的代码,如果需要自己控制这部分逻辑 * 需要将application/admin/library/traits/Backend.php中对应的方法复制到当前控制器,然后进行修改 */&#125; 基类中所定义的方法如下，以下方法都是通过application/admin/library/traits/Backend.php引入的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Backend extends Controller&#123; /** * 查看 */ public function index()&#123;&#125; /** * 添加 */ public function add($ids = \"\")&#123;&#125; /** * 编辑 */ public function edit($ids = \"\")&#123;&#125; /** * 删除 */ public function del($ids = \"\")&#123;&#125; /** * 批量更新 */ public function multi($ids = \"\")&#123;&#125; /** * 回收站 */ public function recyclebin()&#123;&#125; /** * 真实删除 */ public function destroy($ids = \"\")&#123;&#125; /** * 还原 */ public function restore($ids = \"\")&#123;&#125; /** * 导入 */ protected function import()&#123;&#125; /** * 下拉筛选 */ public function selectpage() &#123; return parent::selectpage(); &#125;&#125; 属性和方法当我们的控制器继承自app\\common\\controller\\Backend以后，我们就可以使用以下属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 无需登录的方法,同时也就不需要鉴权了 * @var array */protected $noNeedLogin = [];/** * 无需鉴权的方法,但需要登录 * @var array */protected $noNeedRight = [];/** * 布局模板 * @var string */protected $layout = 'default';/** * 权限控制类 * @var Auth */protected $auth = null;/** * 快速搜索时执行查找的字段 */protected $searchFields = 'id';/** * 是否是关联查询 */protected $relationSearch = false;/** * 是否开启数据限制 * 支持auth/personal * 表示按权限判断/仅限个人 * 默认为禁用,若启用请务必保证表中存在admin_id字段 */protected $dataLimit = false;/** * 数据限制字段 */protected $dataLimitField = 'admin_id';/** * 是否开启Validate验证 */protected $modelValidate = false;/** * 是否开启模型场景验证 */protected $modelSceneValidate = false;/** * Multi方法可批量修改的字段 */protected $multiFields = 'status'; 我们可以直接在当前控制器使用$this-&gt;属性名来调用所支持的属性，也支持直接在当前控制器定义相关属性来覆盖父类的属性，同时TP5中\\think\\Controller所支持的属性也全部支持。 基类app\\common\\controller\\Backend中所支持的方法如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 加载语言文件 * @param string $name */protected function loadlang($name)&#123;&#125;/** * 渲染配置信息 * @param mixed $name 键名或数组 * @param mixed $value 值 */protected function assignconfig($name, $value = '')&#123; &#125;/** * 生成查询所需要的条件,排序方式 * @param mixed $searchfields 快速查询的字段 * @param boolean $relationSearch 是否关联查询 * @return array */protected function buildparams($searchfields = null, $relationSearch = null)&#123; &#125;/** * 获取数据限制的管理员ID * 禁用数据限制时返回的是null * @return mixed */protected function getDataLimitAdminIds()&#123; &#125;/** * Selectpage的实现方法 * * 当前方法只是一个比较通用的搜索匹配,请按需重载此方法来编写自己的搜索逻辑,$where按自己的需求写即可 * 这里示例了所有的参数，所以比较复杂，实现上自己实现只需简单的几行即可 * */protected function selectpage()&#123;&#125; 关联查询目前FastAdmin后台index方法支持一对一关联查询，比如我们一篇文章有归属分类，我们在列出数据时需要同时列表文章分类名称。 首先我们需要在当前控制器中添加以下属性 1protected $relationSearch = true; 然后我们修改控制器的index方法，代码如下： 12345678910111213141516171819202122public function index()&#123; if ($this-&gt;request-&gt;isAjax()) &#123; list($where, $sort, $order, $offset, $limit) = $this-&gt;buildparams(); $total = $this-&gt;model -&gt;with([\"category\"]) -&gt;where($where) -&gt;order($sort, $order) -&gt;count(); $list = $this-&gt;model -&gt;with([\"category\"]) -&gt;where($where) -&gt;order($sort, $order) -&gt;limit($offset, $limit) -&gt;select(); $result = array(\"total\" =&gt; $total, \"rows\" =&gt; $list); return json($result); &#125; return $this-&gt;view-&gt;fetch();&#125; 然后在控制器对应的model(非关联model)中添加以下代码： 1234public function category()&#123; return $this-&gt;belongsTo('Category', 'category_id')-&gt;setEagerlyType(0);&#125; 视图渲染12345678//渲染站点配置$this-&gt;assign('site', $site);//渲染配置信息$this-&gt;assign('config', $config);//渲染权限对象$this-&gt;assign('auth', $this-&gt;auth);//渲染管理员对象$this-&gt;assign('admin', Session::get('admin')); 模块前台基类控制器前台的所有功能模块的控制器都是继承于application/common/controller/Frontend.php这个基类控制器 1234567891011121314151617181920212223/** * 布局模板 * @var string */protected $layout = '';/** * 无需登录的方法,同时也就不需要鉴权了 * @var array */protected $noNeedLogin = [];/** * 无需鉴权的方法,但需要登录 * @var array */protected $noNeedRight = [];/** * 权限Auth * @var Auth */protected $auth = null; 其次我们来看下基类的方法 12345678910111213141516/** * 加载语言文件 * @param string $name */protected function loadlang($name)&#123;&#125;/** * 渲染配置信息 * @param mixed $name 键名或数组 * @param mixed $value 值 */protected function assignconfig($name, $value = '')&#123;&#125; API基类解析12345678910111213141516171819202122/** * @var array 前置操作方法列表 */protected $beforeActionList = [];/** * 无需登录的方法,同时也就不需要鉴权了 * @var array */protected $noNeedLogin = [];/** * 无需鉴权的方法,但需要登录 * @var array */protected $noNeedRight = [];/** * 权限Auth * @var Auth */protected $auth = null; 其次我们来看下基类的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 加载语言文件 * @param string $name */protected function loadlang($name)&#123;&#125;/** * 操作成功返回的数据 * @param string $msg 提示信息 * @param mixed $data 要返回的数据 * @param int $code 错误码，默认为1 * @param string $type 输出类型 * @param array $header 发送的 Header 信息 */protected function success($msg = '', $data = null, $code = 1, $type = null, array $header = [])&#123;&#125;/** * 操作失败返回的数据 * @param string $msg 提示信息 * @param mixed $data 要返回的数据 * @param int $code 错误码，默认为0 * @param string $type 输出类型 * @param array $header 发送的 Header 信息 */protected function error($msg = '', $data = null, $code = 0, $type = null, array $header = [])&#123;&#125;/** * 返回封装后的 API 数据到客户端 * @access protected * @param mixed $msg 提示信息 * @param mixed $data 要返回的数据 * @param int $code 错误码，默认为0 * @param string $type 输出类型，支持json/xml/jsonp * @param array $header 发送的 Header 信息 * @return void * @throws HttpResponseException */protected function result($msg, $data = null, $code = 0, $type = null, array $header = [])&#123;&#125;/** * 前置操作 * @access protected * @param string $method 前置操作方法名 * @param array $options 调用参数 ['only'=&gt;[...]] 或者 ['except'=&gt;[...]] * @return void */protected function beforeAction($method, $options = [])&#123;&#125;/** * 验证数据 * @access protected * @param array $data 数据 * @param string|array $validate 验证器名或者验证规则数组 * @param array $message 提示信息 * @param bool $batch 是否批量验证 * @param mixed $callback 回调方法（闭包） * @return array|string|true * @throws ValidateException */protected function validate($data, $validate, $message = [], $batch = false, $callback = null)&#123;&#125; 后台流程介绍首先需要知道FastAdmin的后台模块是 禁用了路由功能 的，因此后台的操作都是根据URL进行分段解析，例如我们请求的是 1https://demo.fastadmin.net/admin/ 则调用的是默认控制器Index.php中的默认方法index 如果我们请求的是 1https://demo.fastadmin.net/admin/dashboard/index 则调用的是Dashboard.php中的index方法 基类解析后台的所有功能模块的控制器都是继承于application/common/controller/Backend.php这个基类控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 无需登录的方法,同时也就不需要鉴权了 * @var array */protected $noNeedLogin = [];/** * 无需鉴权的方法,但需要登录 * @var array */protected $noNeedRight = [];/** * 布局模板 * @var string */protected $layout = 'default';/** * 权限控制类 * @var Auth */protected $auth = null;/** * 快速搜索时执行查找的字段 */protected $searchFields = 'id';/** * 是否是关联查询 */protected $relationSearch = false;/** * 是否开启数据限制 * 支持auth/personal * 表示按权限判断/仅限个人 * 默认为禁用,若启用请务必保证表中存在admin_id字段 */protected $dataLimit = false;/** * 数据限制字段 */protected $dataLimitField = 'admin_id';/** * 数据限制开启时自动填充限制字段值 */protected $dataLimitFieldAutoFill = true;/** * 是否开启Validate验证 */protected $modelValidate = false;/** * 是否开启模型场景验证 */protected $modelSceneValidate = false;/** * Multi方法可批量修改的字段 */protected $multiFields = 'status';/** * 导入文件首行类型 * 支持comment/name * 表示注释或字段名 */protected $importHeadType = 'comment'; 其次我们来看下通用的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 加载语言文件 * @param string $name */protected function loadlang($name)&#123;&#125;/** * 渲染配置信息 * @param mixed $name 键名或数组 * @param mixed $value 值 */protected function assignconfig($name, $value = '')&#123;&#125;/** * 生成查询所需要的条件,排序方式 * @param mixed $searchfields 快速查询的字段 * @param boolean $relationSearch 是否关联查询 * @return array */protected function buildparams($searchfields = null, $relationSearch = null)&#123;&#125;/** * 获取数据限制的管理员ID * 禁用数据限制时返回的是null * @return mixed */protected function getDataLimitAdminIds()&#123;&#125;/** * Selectpage的实现方法 * * 当前方法只是一个比较通用的搜索匹配,请按需重载此方法来编写自己的搜索逻辑,$where按自己的需求写即可 * 这里示例了所有的参数，所以比较复杂，实现上自己实现只需简单的几行即可 * */protected function selectpage()&#123;&#125; 公共Token验证 获取Token信息 1Token::get('c2259a37-5fee-4c4b-93b0-1d7313e1d1ac'); 设置会员的Token信息 1Token::set('c2259a37-5fee-4c4b-93b0-1d7313e1d1ac', 1, 3600); 判断会员Token是否可用 1Token::check('c2259a37-5fee-4c4b-93b0-1d7313e1d1ac', 1); 删除单个会员Token 1Token::delete('c2259a37-5fee-4c4b-93b0-1d7313e1d1ac'); 删除指定会员的所有Token 1Token::clear(1); 邮件发送 FastAdmin中的邮件发送采用phpmailer进行邮件发送，在使用邮件发送功能前请先在后台常规管理-&gt;系统配置中配置好邮件的相关信息。 使用示例 首先我们需要采用单例或实例化一个Email对象 1$email = new \\app\\common\\library\\Email; 其次我们可以设置邮件主题正文、接收者、标题等信息，比如 1$email-&gt;subject('这里是邮件标题')-&gt;to('youremail@163.com')-&gt;message('这里是邮件正文')-&gt;send(); 如果我们邮件发送失败，想获取错误的详情，可使用 1$email-&gt;getError(); 短信发送 在使用短信发送之前，务必在后台安装好我们短信服务商的插件，如果我们要使用的服务商未提供有FastAdmin的插件，我们则需要自己开发一个，或注册一个sms_send和sms_check的事件用于我们的发送和检测操作。 使用示例 首先最常用的是发送短信，比如我们发送一个注册验证码 1Sms::send('13888888888', '1234', 'register'); 发送以后我们有时需要检测验证码是否正确，则可以使用 1Sms::check('1388888888', '1234', 'register'); 当然有些时候我们还需要发送营销短信或通知，则可以使用 1Sms::notice('1388888888', '消息内容', 'SMS_10001'); 如果我们需要清空指定手机号的验证码，则可以使用 1Sms::flush('13888888888', 'register'); 辅助函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 获取语言变量值 * @param string $name 语言变量名 * @param array $vars 动态变量值 * @param string $lang 语言 * @return mixed */function __($name, $vars = [], $lang = '')&#123;&#125;/** * 将字节转换为可读文本 * @param int $size 大小 * @param string $delimiter 分隔符 * @return string */function format_bytes($size, $delimiter = '')&#123;&#125;/** * 将时间戳转换为日期时间 * @param int $time 时间戳 * @param string $format 日期时间格式 * @return string */function datetime($time, $format = 'Y-m-d H:i:s')&#123;&#125;/** * 获取语义化时间 * @param int $time 时间 * @param int $local 本地时间 * @return string */function human_date($time, $local = null)&#123;&#125;/** * 获取上传资源的CDN的地址 * @param string $url 资源相对地址 * @return string */function cdnurl($url)&#123;&#125;/** * 判断文件或文件夹是否可写 * @param string $file 文件或目录 * @return bool */function is_really_writable($file)&#123;&#125;/** * 删除文件夹 * @param string $dirname 目录 * @param bool $withself 是否删除自身 * @return boolean */function rmdirs($dirname, $withself = true)&#123;&#125;/** * 复制文件夹 * @param string $source 源文件夹 * @param string $dest 目标文件夹 */function copydirs($source, $dest)&#123;&#125;function mb_ucfirst($string)&#123;&#125;/** * 附加关联字段数据 * @param array $items 数据列表 * @param mixed $fields 渲染的来源字段 * @return array */function addtion($items, $fields)&#123;&#125;/** * 返回打印数组结构 * @param string $var 数组 * @param string $indent 缩进字符 * @return string */function var_export_short($var, $indent = \"\")&#123;&#125; 前端基础介绍FastAdmin的前端部分使用或涉及到主要是RequireJS,jQuery,AdminLTE,Bower,Less,CSS，其中 RequireJS主要是用于JS的模块化加载 Bower主要用于管理第三方插件。 Less主要是用于我们编写LESS和编译成CSS代码 在阅读接下来的文档之前最好先简单的了解下RequireJS和Bower，而jQuery是我们必须要掌握的工具库 FastAdmin中前端的最常用的第三方插件有Layer,Toastr，Layer用于弹窗，Toastr用于提示。 组件 FastAdmin默认集成了多个第三方组合，如表单验证、文件上传、下拉列表、时间选择、城市选择、Selectpage，所有的组件都必须使用Form.api.bindevent(&quot;form[role=form]&quot;)来进行初始化，如果不进行初始化是无法对相应组件进行渲染和事件绑定。 https://doc.fastadmin.net/docs/component.html 文件上传动态下拉列表富文本编辑器表单验证城市选择日期时间下拉列表","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"FastAdmin","slug":"FastAdmin","permalink":"http://blog.caoxl.com/tags/FastAdmin/"},{"name":"TP5","slug":"TP5","permalink":"http://blog.caoxl.com/tags/TP5/"}]},{"title":"使用MAMP Pro 搭建FastAdmin踩坑记","slug":"Mac-MAMPPRO-FastAdmin-Trample","date":"2018-09-08T14:36:48.000Z","updated":"2019-08-22T03:39:25.000Z","comments":true,"path":"2018/09/08/Mac-MAMPPRO-FastAdmin-Trample/","link":"","permalink":"http://blog.caoxl.com/2018/09/08/Mac-MAMPPRO-FastAdmin-Trample/","excerpt":"FastAdmin踩坑记, 搭建一个简单的后台居然花了我三个多小时！！！","text":"FastAdmin踩坑记, 搭建一个简单的后台居然花了我三个多小时！！！ 写在前面本地开发请尽量不用代理！！！ Mac下搭建开发环境，只能访问localhost，找了各种问题，最后发现是翻墙的原因！ MAMP PRO 配置伪静态这个大坑！！！使用MAMP PRO搭建好FastAdmin后只能访问首页，无法访问别的。 Apache 安装后只能访问首页，其它页均报no input file specified Nginx 安装后只能访问首页，其它页均报404 page not found 开始找解决办法首先找 Nginx(nginx.conf) /Applications/MAMP/conf/nginx/nginx.conf 哗哗的将这段代码复制到nginx.conf中，跑起来,尼玛，为啥还是404！ 看了下官网。。。 Use Nginx as a Reverse Proxy for Apache Check to use Nginx as a reverse proxy for Apache. When this option is checked the following will be added to your /Library/Application Support/appsolute/MAMP PRO/conf/nginx.conf file. Your requests will now be forwarded to your Apache server localhost. https://documentation.mamp.info/en/MAMP-PRO-Mac/Servers-and-Services/Nginx/ 哗哗的将这段代码复制到上面的nginx.conf中，跑起来,尼玛，为啥还是404！ 多次尝试无果,在一篇博客上看到 https://documentation.mamp.info/en/MAMP-PRO-Mac/Menu/File/MAMP PRO uses templates to create the necessary server config files. You can edit these templates from the menu item File &gt; Edit Template. Here, you have access to options which are not accessible from the MAMP PRO user interface. 可怕！ 打开File/Edit Template/Nginx(nginx.conf),加入以下代码: 12345678910location / &#123; index index.html index.htm index.php; #主要是这一段一定要确保存在 if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=/$1 last; break; &#125; #结束 #autoindex on;&#125; 这个大坑终于得到解决~","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"FastAdmin","slug":"FastAdmin","permalink":"http://blog.caoxl.com/tags/FastAdmin/"}]},{"title":"面试/笔试实战","slug":"Learning-From-Interview","date":"2018-08-28T10:20:11.000Z","updated":"2019-08-22T03:14:08.000Z","comments":true,"path":"2018/08/28/Learning-From-Interview/","link":"","permalink":"http://blog.caoxl.com/2018/08/28/Learning-From-Interview/","excerpt":"面试中可以学习到很多自己不太擅长的知识","text":"面试中可以学习到很多自己不太擅长的知识 2018-08-28 广州爱卡的米教育使用PHP做单点登录 https://github.com/evangui/ssohttps://segmentfault.com/q/1010000005811793 PHP原生获取POST传JSON数据 第一种：$_POST content-type为application/x-www-form-urlencoded，这是post默认的数据格式，在使用jquery的ajax来post数据的时候默认就是这种方式，这种方式传输的数据形式为：username=admin&amp;password=123456，在服务器接收的时候就是使用最常用的$_POST方式，获取username则采用$_POST[&#39;username&#39;]即可正常获取。 第二种：使用file_get_contents(&quot;php://input&quot;) 对于未指定 Content-Type 的POST数据，则可以使用file_get_contents(&quot;php://input&quot;);来获取原始数据。事实上，用PHP接收POST的任何数据均使用本方法。而不用考虑Content-Type，包括二进制文件流也是可行的。同$HTTP_RAW_POST_DATA比起来，它给内存带来的压力较小，并且不需要任何特殊的 php.ini 设置。php://input无法读取Content-Type为multipart/form-data的POST数据，需要设置php.ini中的always_populate_raw_post_data值为On才可以。php://input读取不到$_GET数据。是因为$_GET数据作为query_path写在http请求头部(header)的PATH字段，而不是写在http请求的body部分。 第三种：使用全局变量$GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;] 在$GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;]存放的是POST过来的原始数据。但$GLOBALS[&#39;HTTP_RAW_POST_DATA’]中是否保存POST过来的数据取决于centent-Type的设置，只有在PHP在无法识别的Content-Type的情况下，才会将POST过来的数据原样地填入变量$GLOBALS[&#39;HTTP_RAW_POST_DATA’]中，象Content-Type=application/x-www-form-urlencoded时，该变量是空的。另外，它同样无法读取Content-Type为multipart/form-data的POST数据，也需要设置php.ini中的always_populate_raw_post_data值为On，PHP才会总把POST数据填入变量$http_raw_post_data。 Linux下进程之间的交流方式 管道 : 管道（Pipe）及命名管道（named pipe）：管道（匿名管道）可用于具有亲缘关系进程间的通信，命名管道，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。 管道是进程间通信中最古老的方式，它包括无名管道和有名管道两种，前者用于父进程和子进程间的通信，后者用于运行于同一台机器上的任意两个进程间的通信。 消息队列 : 消息队列是消息的链表，包括Posix消息队列、SystemV消息队列。具有写权限的进程可以按照一定的规则向消息队列中添加新消息；对消息队列有读权限的进程则可以从消息队列中读取消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限(4096字节）等缺点 消息队列用于运行于同一台机器上的进程间通信，它和管道很相似，是一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表的形式出现。消息链表中节点的结构用msg声明。事实上，它是一种正逐渐被淘汰的通信方式，我们可以用流管道或者套接口的方式来取代它，所以，我们对此方式也不再解释，也建议读者忽略这种方式。 共享内存 : 共享内存使得多个进程可以访问同一块内存空间，是最快的IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥 共享内存是运行在同一台机器上的进程间通信最快的方式，因为数据不需要在不同的进程间复制。通常由一个进程创建一块共享内存区，其余进程对这块内存区进行 读写。得到共享内存有两种方式：映射/dev/mem设备和内存映像文件。前一种方式不给系统带来额外的开销，但在现实中并不常用，因为它控制存取的将是 实际的物理内存，在Linux系统下，这只有通过限制Linux系统存取的内存才可以做到，这当然不太实际。常用的方式是通过shmXXX函数族来实现利 用共享内存进行存储的。首先要用的函数是shmget，它获得一个共享存储标识符。 #include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/shm.h&gt; int shmget(key_t key, int size, int flag); 这个函数有点类似大家熟悉的malloc函数，系统按照请求分配size大小的内存用作共享内存。Linux系统内核中每个IPC结构都有的一个非负整数 的标识符，这样对一个消息队列发送消息时只要引用标识符就可以了。这个标识符是内核由IPC结构的关键字得到的，这个关键字，就是上面第一个函数的 key。数据类型key_t是在头文件sys/types.h中定义的，它是一个长整形的数据。在我们后面的章节中，还会碰到这个关键字。 当共享内存创建后，其余进程可以调用shmat（）将其连接到自身的地址空间中。 void *shmat(int shmid, void *addr, int flag); shmid为shmget函数返回的共享存储标识符，addr和flag参数决定了以什么方式来确定连接的地址，函数的返回值即是该进程数据段所连接的实际地址，进程可以对此进程进行读写操作。 使用共享存储来实现进程间通信的注意点是对数据存取的同步，必须确保当一个进程去读取数据时，它所想要的数据已经写好了。通常，信号量被要来实现对共享存 储数据存取的同步，另外，可以通过使用shmctl函数设置共享存储内存的某些标志位如SHM_LOCK、SHM_UNLOCK等来实现。 信号量 : 主要作为进程之间以及同一进程的不同线程之间的同步和互斥手段。 信号量又称为信号灯，它是用来协调不同进程间的数据对象的，而最主要的应用是前一节的共享内存方式的进程间通信。本质上，信号量是一个计数器，它用来记录对某个资源（如共享内存）的存取状况。一般说来，为了获得共享资源，进程需要执行下列操作： （1） 测试控制该资源的信号量。 （2） 若此信号量的值为正，则允许进行使用该资源。进程将信号量减1。 （3） 若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于0，进程被唤醒，转入步骤（1）。 （4） 当进程不再使用一个信号量控制的资源时，信号量值加1。如果此时有进程正在睡眠等待此信号量，则唤醒此进程。 维护信号量状态的是Linux内核操作系统而不是用户进程。我们可以从头文件/usr/src/linux/include /linux /sem.h 中看到内核用来维护信号量状态的各个结构的定义。信号量是一个数据集合，用户可以单独使用这一集合的每个元素。要调用的第一个函数是semget，用以获 得一个信号量ID。 套接口(Socket) : 这是一种更为一般的进程间通信机制，它既可用于同一台计算机上不同进程间通信，也可用于在不同计算机上的进程间建立基于网络的通信。通常，它主要用于网络中不同机器之间的进程间通信。 套接口（socket）编程是实现Linux系统和其他大多数操作系统中进程间通信的主要方式之一。我们熟知的WWW服务、FTP服务、TELNET服务 等都是基于套接口编程来实现的。除了在异地的计算机进程间以外，套接口同样适用于本地同一台计算机内部的进程间通信。关于套接口的经典教材同样是 Richard Stevens编著的《Unix网络编程：联网的API和套接字》，清华大学出版社出版了该书的影印版。它同样是Linux程序员的必备书籍之一。 Linux下查询Nginx的进程列表（使用Nginx自带） 第一种方法：查看进程列表并过滤 1ps -ef | grep nginx 第二种方法：直接查看进程id 1ps -C nginx -o pid 这种直接返回pid的方式比较适合跟其他程序结合使用，比如在shell/python脚本中执行这个命令拿到pid，让后根据pid来判断Nginx是否启动。 第三种方法：使用netstat命令 1netstat -anp | grep :80 第四种方法：使用lsof命令 1lsof -i:80 必须熟悉HTTP协议、TCP协议等 HTTP协议TCP协议 人事技术一起面试的，技术要求抛去框架，对原生基础要求多。 2018-08-28 广州纵思OA系统 OA系统的英文全称是：Office Automation System ，意为办公自动化系统。办公自动化（OA）是面向组织的日常运作和管理，员工及管理者使用频率最高的应用系统. 待做： 使用Laravel/ThinkPHP 各做一个OA系统 （曾经用TP3.2做过OA系统） ERP系统 ERP系统是企业资源计划(Enterprise Resource Planning )的简称，是指建立在信息技术基础上，集信息技术与先进管理思想于一身，以系统化的管理思想，为企业员工及决策层提供决策手段的管理平台。它是从MRP（物料需求计划）发展而来的新一代集成化管理信息系统，它扩展了MRP的功能，其核心思想是供应链管理。它跳出了传统企业边界，从供应链范围去优化企业的资源，优化了现代企业的运行模式，反映了市场对企业合理调配资源的要求。它对于改善企业业务流程、提高企业核心竞争力具有显著作用。 PHP跨库查询数据 如果是两个不同引擎的数据库，例如MYSQL和SQL SERVER，或者不同服务器上两个数据库，是无法直接关联查询的，PHP可以同时连接两个数据库，在循环里面的一次一条数据的相互操作。如果是同一服务器、同一引擎下的两个数据库，一般都可以直接操作，也就是完全当一个数据库使用，只是根据不同数据库引擎的语法要求写SQL就行的，对于非当前数据库里面的表，有的数据库是使用冒号（INFORMIX等），有的使用圆点（MSSQL、MYSQL、ORACLE等）。例如MYSQL下查询web和test两个数据库里面的表的语句：$sql = “SELECT * FROM test.tab1, web.tab2 WHERE tab1.id=tab2.id”; Thinkphp跨库连表查询1234567891011db1 数据库1db2 数据库2table1 数据表1table2 数据表2$spell = $this-&gt;SpellApply-&gt;table('db1.table1 t1,db2.table2 t2') -&gt;field('t1.uid,t2.avatar_img') -&gt;where('t1.uid=t2.uid and t1.spell_id ='.$id) -&gt;order('t1.create_time desc') -&gt;group('t1.uid') -&gt;select(); Laravel5.5 使用仓库模式处理业务报表（多至34十张表) PHP 设计模式全集 2018 Laravel与Repository Pattern(仓库模式)——概念篇 Laravel 5 中使用仓库(Repository)模式%E6%A8%A1%E5%BC%8F.md) 人事和技术都过了，说要评估，然后没有然后了， 2018-08-29 广州伊思高 环境不适合，看了下就直接走了没有面试。 来自小鸡的面试题： array+array 和array_merge()的区别？ 常见的网络攻击? 解决方案？ array+array 和array_merge()的区别？ 当下标为数值时，array_merge()不会覆盖掉原来的值，但array＋array合并数组则会把最先出现的值作为最终结果返回，而把后面的数组拥有相同键名的那些值“抛弃”掉（不是覆盖）. 当下标为字符时，array＋array仍然把最先出现的值作为最终结果返回，而把后面的数组拥有相同键名的那些值“抛弃”掉，但array_merge()此时会覆盖掉前面相同键名的值. https://segmentfault.com/a/1190000009114383 常见的网络攻击? 解决方案？XSS XSS，Cross-site script，跨站脚本攻击。它可以分为两类：反射型和持久型。 反射型XSS攻击场景：用户点击嵌入恶意脚本的链接，攻击者可以获取用户的cookie信息或密码等重要信息，进行恶性操作。 解决：开启cookie的HttpOnly属性，禁止JavaScript脚本读取cookie信息 持久型XSS攻击场景：攻击者提交含有恶意脚本的请求（通常使用&lt;script&gt;标签），此脚本被保存在数据库中。用户再次浏览页面，包含恶意脚本的页面会自动执行脚本，从而达到攻击效果。这种攻击常见于论坛，博客等应用中。 解决：前端提交请求时，转义&lt;为&amp;lt，转义&gt;为&amp;gt；或者后台存储数据时进行特殊字符转义。建议后台处理，因为攻击者可以绕过前端页面，直接模拟请求，提交恶意 SQL注入 攻击者在HTTP请求中注入恶意SQL命令，例如，drop table users，服务器用请求参数构造数据库SQL命令时，恶意SQL被执行。 解决：后台处理，例如，使用预编译语句PreparedStatement进行预处理。 CSRF CSRF，Cross-site request forgery，跨站请求伪造。这种方式是利用浏览器的cookie或服务器的session策略，盗取用户信息，模拟用户向第三方网站发送恶意请求。 因为从WEB页面产生的所以请求，包括文件请求，都会带上cookie，这样，只要用户在网站A的会话还没有过期，访问恶意网站B时就可能被动发出请求到网站A，同时携带cookie信息，从而达到伪造用户进行恶性操作。 解决方案： 提交请求中携带Token，并且每次请求的Token值都是合法的随机数。注意：使用时注意token的私密性，不要以url参数的形式发送（不要使用GET）。尽量采用POST操作，以form表单或者AJAX的形式提交。 referer check：根据http request信息里面的referer参数（请求源），验证请求源是否合法。注意：某些情况下，浏览器不会发送referer参数，比如，从https跳转到http，为了安全性不会发送referer。 https://www.jianshu.com/p/cacfe5749e81 按照osi七层协议，可以分为： 物理层 线路侦听 数据链路层 mac_flood 网络层 arp_poison，icmp_redirection 传输层 tcp_flood(包含ack_flood和syn_flood)，udp_flood(ntp,dns) 应用层 connection_flood，http_get等等 按照攻击目的，可以分为： 中间人攻击（为了获得网络数据）：mac_flood，arp_poison，icmp_redirection 拒绝服务攻击：tcp_flood，udp_flood，connection_flood，http_get 按照攻击者的位置，可以分为： 攻击者必须与攻击目标处于同一网段：mac_flood，arp_poison，icmp_redirection，线路侦听 不必处于同一网段：其他 2018-08-29 广州晨风 没有人事，直接技术，技术过了面试半天过了， 然后说要搬家到海珠区问我去不去， 我醉了 这种要搬家的面试个什么劲。。。 2018-08-30 广州微世纪你怎么做登录？你怎么知道是谁登录？ （听到这个问题我就想笑） 由于HTTP协议是无状态的，服务器无法知道两次访问是不是来自同一个人。这里就使用到COOKIE技术了，使用COOKIE可以解决以上问题，让服务器知道用户是否登录。https://blog.csdn.net/looksunli/article/details/9799395 1setcookie($name, $value, $expire, $path, $domain, $secure) 商城的核心模块？ 用户认证管理模块 商品检索引擎模块 广告管理与发布系统功能模块 订单系统模块、购物车模块。 怎么实现购物车模块？未登录怎么加入购物车？实现未登录统计加入购物车的商品？ https://blog.csdn.net/qfikh/article/details/52943068 搜索商品名称，并跳转到商品页面，并且搜索关键字高亮显示 站内搜索结果怎么高亮显示关键字？ 附笔试题 $this,self,parent的区别? 命名空间有什么作用？ JSON和JSONP的区别和注意细节？ MVC分层是什么？TP5各自需要继承什么？ trait功能是什么？ TP5和TP3在控制器上的区别？ TP参数绑定的定义和使用示例？ $this,self,parent的区别? 从字面上来理解，分别是指这、自己、父亲。先初步解释一下，this是指向当前对象的指针（可以看成C里面的指针），self是指向当前类的指针，parent是指向父类的指针 $this是在实例化的时候来确定指向谁 self是指向类本身，也就是self是不指向任何已经实例化的对象，一般self使用来指向类中的静态变量 使用parent来调用父类的构造函数 https://www.cnblogs.com/myjavawork/articles/1793664.html 命名空间有什么作用？命名空间主要解决class类/function 函数/常量 等一些的命名冲突问题 官方命名空间概述 JSON和JSONP的区别和注意细节？JSON下面是jquery的ajax请求，数据类型为json,它是以json格式在前后台进行数据的传输，它与局限性就是不能跨域请求，这是为了网络数据的安全所制定的规则。 123456789101112131415$.ajax(&#123; type: \"post\", // 数据提交类型 url: \"danmu.php\",// 请求地址 同源服务器/浏览器安全设置 data: &#123;word:\"abc\",username:\"ltt\"&#125;, // 发送数据 dataType: \"json\", // 返回数据的类型 async: true, // 是否异步，true为异步 // success为数据加载完成后的回调函数 success: function(data)&#123; var show = document.getElementById('show'); for(i in data)&#123; show.innerHTML += data[i]+\"&lt;br&gt;\"; &#125; console.log(data); &#125; &#125;); JSONP大家都知道script标签是可以跨域请求的，jsonp的原理就是通过script的src，将函数作为src请求地址的参数来传递数据，所以jsonp只有get一种传输方式。 下面是jsonp的数据交互，首先定义一个回调函数，定义dataType类型为jsonp,将函数作为参数传输给后台，它与json相比是多了一层函数。 12345678910111213&lt;script type=\"text/javascript\"&gt;// 自定义的回调函数function show(val)&#123; document.getElementById(\"show\").src=val[0].src;&#125;$.ajax(&#123; type:\"get\", url:\"myphp.php\", dataType:\"jsonp\", // 现在时jsonp请求，这个时候，jquery使用的是script标签发送请求 jsonp:\"callmyphp\", // 后台用来接受函数名的变量名 jsonpCallback:\"show\",// 自定义的回调函数名 async:true,&#125;); 至于什么时候用json什么时候用jsonp？我就一个原则，能使用json的时候都是用json，只有必须要跨域请求时才使用jsonp。 MVC分层是什么？TP5各自需要继承什么？ 视图层view：用于展示数据，与用户进行交互。 控制层controller：用于分发控制到来的请求,并调用模型层与数据库进行交互,以及将数据返回给视图层展示。 模型层model：数据模型，它与数据库进行交互，进行CURD操作。 继承: controller: use think\\Controller; model: use think\\Model; view: use think\\View; trait功能是什么？ Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题。 Trait 和 Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。 无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。 TP5和TP3在控制器上的区别？控制器的命名空间有所调整，并且可以无需继承任何的控制器类。 应用命名空间统一为app（可定义）而不是模块名； 控制器的类名默认不带Controller后缀，可以配置开启use_controller_suffix参数启用控制器类后缀； 控制器操作方法采用return方式返回数据 而非直接输出； 废除原来的操作前后置方法； 增加beforeActionList属性定义前置操作； 支持任意层次的控制器定义和访问； URL访问支持自动定位控制器； Tp3.2和Tp5.0区别 TP参数绑定的定义和使用示例？ 参数绑定是指绑定一个参数到预处理的SQL语句中的对应命名占位符或问号占位符指定的变量，并且可以提高SQL处理的效率，需要数据库驱动类的支持，目前只有PDO和Sqlsrv驱动支持参数绑定功能。https://www.kancloud.cn/beyondzgz/tp/52559 手动绑定参数手动绑定需要调用连贯操作的bind方法，例如： 123$Model = M('User');$where['name'] = ':name';$list = $Model-&gt;where($where)-&gt;bind(':name',I('name'))-&gt;select(); 自动绑定对于某些操作的情况（例如模型的写入和更新方法），可以支持参数的自动绑定，例如：首先需要开启DB_BIND_PARAM配置参数： 1234$Model = M('User');$Model-&gt;name = 'thinkphp';$Model-&gt;email = 'thinkphp@qq.com';$Model-&gt;add(); 2018-08-30 广州众享 以下是我听过最智障的面试， 来自一位老年人程序员（至少35+，看上去） 你上家公司做什么，你负责什么，具体点。。。你上上家公司做什么，你负责什么，具体点。。。你上上家公司坐什么，你负责什么，具体点。。。微信支付怎么做的， 具体流程说一下，具体点。。。 广州众享和广州微世纪是一起的，笔试题是一模一样的，然后还分别给了一份面试邀请。 2018-08-31 广州玩动网络（手趣网络、果玩网络） 面试让人很舒服，这个一定要说。是做游戏的，需要对游戏相关有了解 Swoole的使用？除此之外别的PHP组件？微服务？（RabbitMQ,Kafka,etcd,zookeeper）Facades的作用？不是静态方法为何可以::调用Facade其实是一个容器中类的静态代理，他可以让你以静态的方式来调用存放在容器中任何对象的任何方法。 Laravel 的 Facade 实现原理 依赖注入的原理？为什么可以这样做？ 依赖注入（Dependency Injection）是用于实现控制反转（Inversion of Control）的最常见的方式之一依赖注入原理(为什么需要依赖注入) RPC协议？ 英文原义：Remote Procedure Call Protocol中文释义：（RFC-1831）远过程调用协议 MySQL索引优化，慢查询优化？2018-08-31 广州天启互娱附笔试题 &lt;?php echo count(strlen(“http://php.net”)); ？&gt;的执行结果是？ 使用list()函数需要注意什么？ 请说明php_ini中safe_mode开启影响了哪些函数？ 请对POSIX风格和兼容Prel风格正则主要函数类比说明？ 简述PHP垃圾收集机制？ php查询mysql数据库出现中文乱码解决方法？ Session和Cookie的区别？ 数据库优化？ 如何处理负载和高并发？ 请说明php_ini中safe_mode开启影响了哪些函数？ 被安全模式限制或屏蔽的函数 2018-08-31 广州爱拍（不是本人面试） 爱拍面试在下周，这里记录一些爱拍的笔试题 GET和POST的区别？ 禁用Cookie后session是否可以正常使用，原理？ 如何实现多机器Session共享？ HTTP状态码1，2，3，4，5，6开头的分别什么意思？ 阐述opcache原理？ PHPTAL模板引擎，阐述原理 写出phpdocumentor 5个tags的名称及其含义？ 简述对Symfony的了解？ 简述Symfony中的announce路由原理？ 最近看过的技术类书记有哪些？ 写一个函数遍历目录？ MySQL事务语句？ Linux常见的shell有哪些？ Linux下查看磁盘空间命令？ 写清楚Linux命令统计/etc/passwd/文件下的每个组的人数 请简述进程和线程的区别？ 编写一个Nginx的rewrite规则 MYSQL有2000W数据，redis中只存20W数据，怎么保证redis都是热点数据？ 写出HTTP工作过程步骤？ 2018-09-03 广州港讯 公司环境很心水，公司团队不大，技术面试问的不深。 Left Join， Right Join， Inner Join的区别？ Left Join 时右表为空返回什么？怎么做条件判断？ Redis的应用场景？（什么时候需要使用Redis） Left Join， Right Join， Inner Join的区别？ left join(左联接): 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接): 返回包括右表中的所有记录和左表中联结字段相等的记录 inner join(等值连接): 只返回两个表中联结字段相等的行 Left Join 时右表为空返回什么？怎么做条件判断？1234567891011121314151617181920212223242526A表id aname 1 张三2 李四B表id score aid bname year1 90 1 语文 20182 92 1 数学 2019select aname,bname,score from A left join B on A.id=B.aid where year='2018'查询结果张三 语文 90select aname,bname,score from A left join B on A.id=B.aid and year='2018'查询结果张三 语文 90李四 null null select aname,bname,score from A left join B on A.id=B.aid where year=’2018’ select aname,bname,score from A left join B on A.id=B.aid and year=’2018’ Redis的应用场景?缓存作为Key-Value形态的内存数据库，Redis 最先会被想到的应用场景便是作为数据缓存。而使用 Redis 缓存数据非常简单，只需要通过string类型将序列化后的对象存起来即可，不过也有一些需要注意的地方： 必须保证不同对象的 key不会重复，并且使key尽量短，一般使用类名（表名）加主键拼接而成。 选择一个优秀的序列化方式也很重要，目的是提高序列化的效率和减少内存占用。 缓存内容与数据库的一致性，这里一般有两种做法： 只在数据库查询后将对象放入缓存，如果对象发生了修改或删除操作，直接清除对应缓存（或设为过期）。 在数据库新增和查询后将对象放入缓存，修改后更新缓存，删除后清除对应缓存（或设为过期）。 消息队列Redis 中list的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者 / 消费者模型）。消息的生产者只需要通过lpush将消息放入 list，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择sorted set。而pub/sub功能也可以用作发布者 / 订阅者模型的消息。无论使用何种方式，由于 Redis 拥有持久化功能，也不需要担心由于服务器故障导致消息丢失的情况。 时间轴（Timeline）list作为双向链表，不光可以作为队列使用。如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过lpush将它存放在一个 key 为LATEST_WEIBO的list中，之后便可以通过lrange取出当前最新的微博。 下午复试，大致了解，前身是做外包的，所以还有挺多外包。项目较多，除五险一金无其他福利。 排行榜使用sorted set和一个计算热度的算法便可以轻松打造一个热度排行榜，zrevrangebyscore可以得到以分数倒序排列的序列，zrank可以得到一个成员在该排行榜的位置（是分数正序排列时的位置，如果要获取倒序排列时的位置需要用zcard-zrank）。 计数器计数功能应该是最适合 Redis 的使用场景之一了，因为它高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted set都提供了incr方法用于原子性的自增操作，下面举例说明一下它们各自的使用场景： 如果应用需要显示每天的注册用户数，便可以使用string作为计数器，设定一个名为REGISTERED_COUNT_TODAY的 key，并在初始化时给它设置一个到凌晨 0 点的过期时间，每当用户注册成功后便使用incr命令使该 key 增长 1，同时当每天凌晨 0 点后，这个计数器都会因为 key 过期使值清零。 每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用hash进行计数会更好，将该计数器的 key 设为weibo:weibo_id，hash的 field 为like_number、comment_number、forward_number和view_number，在对应操作后通过hincrby使hash 中的 field 自增。 如果应用有一个发帖排行榜的功能，便选择sorted set吧，将集合的 key 设为POST_RANK。当用户发帖后，使用zincrby将该用户 id 的 score 增长 1。sorted set会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。 好友关系对于一个用户 A，将它的关注和粉丝的用户 id 都存放在两个 set 中： A:follow：存放 A 所有关注的用户 id A:follower：存放 A 所有粉丝的用户 id 那么通过sinter命令便可以根据A:follow和A:follower的交集得到与 A 互相关注的用户。当 A 进入另一个用户 B 的主页后，A:follow和B:follow的交集便是 A 和 B 的共同专注，A:follow和B:follower的交集便是 A 关注的人也关注了 B。 分布式锁在 Redis 2.6.12 版本开始，string的set命令增加了三个参数： EX：设置键的过期时间（单位为秒） PX：设置键的过期时间（单位为毫秒） NX | XX：当设置为NX时，仅当 key 存在时才进行操作，设置为XX时，仅当 key 不存在才会进行操作 由于这个操作是原子性的，可以简单地以此实现一个分布式的锁，例如： set key &quot;lock&quot; EX 1 XX 如果这个操作返回false，说明 key 的添加不成功，也就是当前有人在占用这把锁。而如果返回true，则说明得了锁，便可以继续进行操作，并且在操作后通过del命令释放掉锁。并且即使程序因为某些原因并没有释放锁，由于设置了过期时间，该锁也会在 1 秒后自动释放，不会影响到其他程序的运行。 倒排索引倒排索引是构造搜索功能的最常见方式，在 Redis 中也可以通过set进行建立倒排索引，这里以简单的拼音 + 前缀搜索城市功能举例： 假设一个城市北京，通过拼音词库将北京转为beijing，再通过前缀分词将这两个词分为若干个前缀索引，有：北、北京、b、be…beijin和beijing。将这些索引分别作为set的 key（例如:index:北）并存储北京的 id，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的set并得到其中的 id 即可。 一些建议 Redis 速度快是建立在内存数据库基础上的，但是一台服务器的内存要比磁盘金贵许多，所以在项目初期不要想什么都往 Redis 里放，这样当数据量上来后很快内存就会不够用，反而得不偿失。合理的利用有限的内存，将读（写）频繁的热数据放在 Redis 中才能更好感受到它带来的性能提升。 Redis 虽然提供了RDB和AOF两种持久化方式，但是普遍还是认为 Redis 的持久化并不是很靠谱。这也是我一直不敢尝试彻底的用 Redis 去实现第五点（好友关系）的原因。 2018-09-03 广州深科信 与广州港讯在同一栋楼，24层，人事技术面试了快2个小时。回去等通知，然后说不合适。技术聊了一个小时，大致围绕我原来的项目 技术问题： 购物车表设计？ 高并发问题？ 2018-09-04 广州米妍网研 从用户输入caoxl.com，到浏览器显示caoxl.com首页，经历了什么过程？ 订餐系统？ 美国上线，对接银联支付？ 2018-09-04 广州量子云 真·初创公司，没有后端，服务器也没有，办公地点还可以，在万达广场18楼 图片库，图床？ LBS（基于位置服务）？ Redis实现热点数据？实现好友关系？ PHP5和PHP7的垃圾回收机制？ PHP7可选参数机制？ IP协议，TCP协议，UDP协议的区别？ 数据库引擎myisam和innodb的区别（至少5点）？ 多进程和多线程的优缺点？ strtr和str_replace的区别？ $a=1,$b=$a,$a=2; 内存分配情况？ 有哪些数据库锁？ Redis是什么？Redis的数据类型有哪些？ MySQL优化手段？ 数据库引擎myisam和innodb的区别（至少5点）？1. 存储结构 MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。 InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。 2. 存储空间 MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。 InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 3. 事务支持 MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 4. CURD操作 MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。(因为没有支持行级锁)，在增删的时候需要锁定整个表格，效率会低一些。相关的是innodb支持行级锁，删除插入的时候只需要锁定改行就行，效率较高 InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。 5. 外键 MyISAM：不支持 InnoDB：支持 MySQL数据库类型从InnoDB转换为MyISAM123USE 数据库名;SHOW TABLES;ALTER TABLE 表名 ENGINE=MYISAM; 修改MySQL数据库引擎为INNODB： 首先修改my.ini，在[mysqld]下加上： 1default-storage-engine=INNODB 用sql语句修改已经建成表的引擎： 1alter table 待改表名 type=InnoDB; 公司需求 理解SOA架构体系。 有实际的缓存（Redis/Memcache）、MQ(RabbitMQ/NSQ/RocketMQ)使用经验。 对MySQL集群，查询和索引优化有深入了解。 对主流内存及文件搜索引擎（ElasticSearch、Solr、Sphinx）使用和调优经验。 熟悉各类通讯协议（thrift、http、json）有socket编程经验。 熟悉分布式、高可用、高并发、可扩展性架构设计。 广州面对面F2F Swoole进程池？ 索引的种类？区别？ Redis怎么做队列？ DDos攻击怎么解决？ 身份伪造攻击怎么解决？ TP5开发？ myisam和innodb的区别？如何选择？ 有那些队列组件？区别？ 广州硅碳鼠 缓存技术？ 关系型数据库和非关系型数据库区别？使用？ 多进程和单进程的优缺点？ 进程和异步的关系区别？ Memcache和Redis的优缺点？使用场景？ MySQL和MongoDB的区别？优缺点？ 索引优化？索引选择？ Linix下进程的交流？Nginx和Apache的优缺点？如何选择使用？ 附录 PHPer面试指南-PHP 篇 3年PHPer的面试总结","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/tags/Caoxl/"},{"name":"面试","slug":"面试","permalink":"http://blog.caoxl.com/tags/面试/"}]},{"title":"Linux 程序优化","slug":"Linux-Program-Optimization","date":"2018-08-24T03:04:53.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/24/Linux-Program-Optimization/","link":"","permalink":"http://blog.caoxl.com/2018/08/24/Linux-Program-Optimization/","excerpt":"性能优化的核心是找出系统的瓶颈点，问题找到了，优化的工作也就完成了大半； 这里介绍的性能优化主要从两个层面来介绍：系统层面和程序层面；","text":"性能优化的核心是找出系统的瓶颈点，问题找到了，优化的工作也就完成了大半； 这里介绍的性能优化主要从两个层面来介绍：系统层面和程序层面； 分析系统瓶颈系统响应变慢，首先得定位大致的问题出在哪里，是IO瓶颈、CPU瓶颈、内存瓶颈还是程序导致的系统问题； 使用top工具能够比较全面的查看我们关注的点: 1234567891011121314151617[root@caoxl ~]# toptop - 11:59:14 up 21 days, 2:19, 1 user, load average: 0.00, 0.01, 0.05Tasks: 91 total, 1 running, 90 sleeping, 0 stopped, 0 zombie%Cpu(s): 6.2 us, 0.0 sy, 0.0 ni, 93.8 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1015436 total, 130888 free, 309720 used, 574828 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 523220 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 43392 3080 1888 S 0.0 0.3 0:14.98 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.18 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:06.86 ksoftirqd/0 5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 6 root 20 0 0 0 0 S 0.0 0.0 0:02.57 kworker/u2:0 7 root rt 0 0 0 0 S 0.0 0.0 0:00.00 migration/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh 9 root 20 0 0 0 0 S 0.0 0.0 1:07.10 rcu_sched 10 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 lru-add-drain 进入交互模式后: 输入M，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题（检测内存泄漏问题）; 输入P，进程列表按CPU使用大小降序排序，便于我们观察最耗CPU资源的使用者是否有问题； top第三行显示当前系统的，其中有两个值很关键: %id：空闲CPU时间百分比，如果这个值过低，表明系统CPU存在瓶颈； %wa：等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈； 分析内存瓶颈查看内存是否存在瓶颈，使用top指令看比较麻烦，而free命令更为直观: 1234[root@caoxl ~]# free total used free shared buff/cache availableMem: 1015436 309332 127740 2664 578364 523596Swap: 0 0 0 top工具显示了free工具的第一行所有信息，但真实可用的内存，还需要自己计算才知道; 系统实际可用的内存为free工具输出第二行的free+buffer+cached；也就是第三行的free值127740； 如果是因为缺少内存，系统响应变慢很明显，因为这使得系统不停的做换入换出的工作; 进一步的监视内存使用情况，可使用vmstat工具，实时动态监视操作系统的内存和虚拟内存的动态变化。 分析IO瓶颈如果IO存在性能瓶颈，top工具中的%wa会偏高； 进一步分析使用iostat工具: 12345[root@caoxl ~]# iostat -d -x -k 1 1Linux 3.10.0-862.9.1.el7.x86_64 (caoxl) 08/24/2018 _x86_64_ (1 CPU)Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.17 0.06 0.31 1.26 2.84 22.37 0.00 5.88 6.97 5.65 0.64 0.02 如果 %iowait 的值过高，表示硬盘存在I/O瓶颈。 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。 如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间； 如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。 如果 avgqu-sz 比较大，也表示有大量io在等待。 分析进程调用过top等工具发现系统性能问题是由某个进程导致的之后，接下来我们就需要分析这个进程；继续 查询问题在哪； 这里我们有两个好用的工具： pstack和strace pstack用来跟踪进程栈，这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方； 示例：查看bash程序进程栈: 1234567891011[root@caoxl ~]# ps -ef | grep bashroot 5459 5457 0 10:23 pts/0 00:00:00 -bashroot 5902 5459 0 15:32 pts/0 00:00:00 grep --color=auto bash[root@caoxl ~]# pstack 5459#0 0x00007f513172f17c in waitpid () from /usr/lib64/libc.so.6#1 0x0000000000440b24 in waitchld.isra.10 ()#2 0x0000000000441ddc in wait_for ()#3 0x0000000000433aae in execute_command_internal ()#4 0x0000000000433cce in execute_command ()#5 0x000000000041e305 in reader_loop ()#6 0x000000000041c96e in main () 而strace用来跟踪进程中的系统调用；这个工具能够动态的跟踪进程执行时的系统调用和所接收的信号。是一个非常有效的检测、指导和调试工具。系统管理员可以通过该命令容易地解决程序问题。 优化程序代码优化自己开发的程序，建议采用以下准则: 二八法则：在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%的尽管是多数，却是次要的；在优化实践中，我们将精力集中在优化那20%最耗时的代码上，整体性能将有显著的提升；这个很好理解。函数A虽然代码量大，但在一次正常执行流程中，只调用了一次。而另一个函数B代码量比A小很多，但被调用了1000次。显然，我们更应关注B的优化。 编完代码，再优化；编码的时候总是考虑最佳性能未必总是好的；在强调最佳性能的编码方式的同时，可能就损失了代码的可读性和开发效率； gprof使用步骤 用gcc、g++、xlC编译程序时，使用-pg参数，如：g++ -pg -o test.exe test.cpp编译器会自动在目标代码中插入用于性能测试的代码片断，这些代码在程序运行时采集并记录函数的调用关系和调用次数，并记录函数自身执行时间和被调用函数的执行时间。 执行编译后的可执行程序，如：./test.exe。该步骤运行程序的时间会稍慢于正常编译的可执行程序的运行时间。程序运行结束后，会在程序所在路径下生成一个缺省文件名为gmon.out的文件，这个文件就是记录程序运行的性能、调用关系、调用次数等信息的数据文件。 使用gprof命令来分析记录程序运行信息的gmon.out文件，如：gprof test.exe gmon.out则可以在显示器上看到函数调用相关的统计、分析信息。上述信息也可以采用gprof test.exe gmon.out &gt; gprofresult.txt重定向到文本文件以便于后续分析。 其它工具调试内存泄漏的工具valgrind，感兴趣的朋友可以google了解； OProfile: Linux 平台上的一个功能强大的性能分析工具 除了上面介绍的工具，还有一些比较全面的性能分析工具，比如sar（Linux系统上默认不安装，需要手动安装下）； 将sar的常驻监控工具打开后，能够收集比较全面的性能分析数据；","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"优化","slug":"优化","permalink":"http://blog.caoxl.com/tags/优化/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Linux 程序调试","slug":"Linux-Program-Debug","date":"2018-08-24T03:04:34.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/24/Linux-Program-Debug/","link":"","permalink":"http://blog.caoxl.com/2018/08/24/Linux-Program-Debug/","excerpt":"GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。","text":"GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 进程调试gdb 程序交互调试GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 GDB中的命令固然很多，但我们只需掌握其中十个左右的命令，就大致可以完成日常的基本的程序调试工作。 以下从一个完整的调试过程简单说明最基本的几个命令; 1234567$gdb programmer # 启动gdb&gt;break main # 设置断点&gt;run # 运行调试程序&gt;next # 单步调试&gt;print var1 # 在调试过程中，我们需要查看当前某个变量值的时候，使用print 命令打印该值&gt;list # 显示当前调试处的源代码&gt;info b # 显示当前断点设置情况 同时，你需要更高效的调试：常用的调试命令都会有单字符的缩写，使用缩写更方便；同时，直接敲回车表示重复执行上一步命令；这在单步调试时非常有用； pstack 跟踪栈空间 pstack是一个脚本工具，可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。其核心实现就是使用了gdb以及thread apply all bt命令; 语法1pstrack &lt;program-pid&gt; 示例:12345678910111213141516171819202122232425262728293031323334353637[root@caoxl ~]# pstack 777#0 0x00007fde797c117c in waitpid () from /usr/lib64/libc.so.6#1 0x0000000000440b24 in waitchld.isra.10 ()#2 0x0000000000441ddc in wait_for ()#3 0x0000000000433aae in execute_command_internal ()#4 0x000000000046f6e4 in parse_and_execute ()#5 0x000000000042f27b in execute_builtin.isra.2 ()#6 0x00000000004313d9 in execute_simple_command ()#7 0x00000000004322e3 in execute_command_internal ()#8 0x0000000000432953 in execute_command_internal ()#9 0x000000000043283f in execute_command_internal ()#10 0x0000000000434e2f in execute_function.isra.7 ()#11 0x00000000004316f1 in execute_simple_command ()#12 0x00000000004322e3 in execute_command_internal ()#13 0x0000000000432953 in execute_command_internal ()#14 0x0000000000433cce in execute_command ()#15 0x0000000000432917 in execute_command_internal ()#16 0x0000000000433cce in execute_command ()#17 0x0000000000432917 in execute_command_internal ()#18 0x0000000000433cce in execute_command ()#19 0x0000000000432917 in execute_command_internal ()#20 0x0000000000433cce in execute_command ()#21 0x0000000000432917 in execute_command_internal ()#22 0x0000000000433cce in execute_command ()#23 0x0000000000432917 in execute_command_internal ()#24 0x0000000000433cce in execute_command ()#25 0x0000000000432917 in execute_command_internal ()#26 0x0000000000433cce in execute_command ()#27 0x0000000000432917 in execute_command_internal ()#28 0x0000000000433cce in execute_command ()#29 0x0000000000432917 in execute_command_internal ()#30 0x0000000000433cce in execute_command ()#31 0x0000000000433da5 in execute_while_or_until ()#32 0x0000000000432410 in execute_command_internal ()#33 0x0000000000433cce in execute_command ()#34 0x000000000041e305 in reader_loop ()#35 0x000000000041c96e in main () strace 分析系统调用 strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。 完整程序: 1strace -o output.txt -T -tt -e trace=all -p 777 跟踪777进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。 查看进程正在做什么(实时输出进程执行系统调用的情况): 123[root@caoxl ~]# strace -p 777strace: Process 777 attachedwait4(-1, 目标文件分析nmnm用来列出目标文件的符号清单。 123456789101112131415161718192021222324252627282930313233343536$nm myProgrammer08049f28 d _DYNAMIC08049ff4 d _GLOBAL_OFFSET_TABLE_080484dc R _IO_stdin_used w _Jv_RegisterClasses08049f18 d __CTOR_END__08049f14 d __CTOR_LIST__08049f20 D __DTOR_END__08049f1c d __DTOR_LIST__080485e0 r __FRAME_END__08049f24 d __JCR_END__08049f24 d __JCR_LIST__0804a014 A __bss_start0804a00c D __data_start08048490 t __do_global_ctors_aux08048360 t __do_global_dtors_aux0804a010 D __dso_handle w __gmon_start__08048482 T __i686.get_pc_thunk.bx08049f14 d __init_array_end08049f14 d __init_array_start08048480 T __libc_csu_fini08048410 T __libc_csu_init U __libc_start_main@@GLIBC_2.00804a014 A _edata0804a01c A _end080484bc T _fini080484d8 R _fp_hw080482b4 T _init08048330 T _start0804a014 b completed.60860804a00c W data_start0804a018 b dtor_idx.6088080483c0 t frame_dummy080483e4 T main U printf@@GLIBC_2.0 123456789101112[root@caoxl lib64]# nm -X 32_64 /usr/lib64/liby.amain.o:0000000000000000 T main U setlocale U yyparseyyerror.o: U fputc U fputs U stderr0000000000000000 T yyerror 这些包含可执行代码的段称为正文段。同样地，数据段包含了不可执行的信息或数据。另一种类型的段，称为 BSS 段，它包含以符号数据开头的块。对于 nm 命令列出的每个符号，它们的值使用十六进制来表示（缺省行为），并且在该符号前面加上了一个表示符号类型的编码字符。 常见的各种编码包括： A 表示绝对 (absolute)，这意味着不能将该值更改为其他的连接； B 表示 BSS 段中的符号； C 表示引用未初始化的数据的一般符号。 可以将目标文件中所包含的不同的部分划分为段。段可以包含可执行代码、符号名称、初始数据值和许多其他类型的数据。有关这些类型的数据的详细信息，可以阅读 UNIX 中 nm 的 man 页面，其中按照该命令输出中的字符编码分别对每种类型进行了描述。 在目标文件阶段，即使是一个简单的 Hello World 程序，其中也包含了大量的细节信息。nm 程序可用于列举符号及其类型和值，但是，要更仔细地研究目标文件中这些命名段的内容，需要使用功能更强大的工具。 objdumpogjdump工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。 12345678910111213141516171819202122232425262728293031[root@caoxl lib64]# objdump -d liby.aIn archive liby.a:main.o: file format elf64-x86-64Disassembly of section .text.startup:0000000000000000 &lt;main&gt;: 0: 48 83 ec 08 sub $0x8,%rsp 4: be 00 00 00 00 mov $0x0,%esi 9: bf 06 00 00 00 mov $0x6,%edi e: e8 00 00 00 00 callq 13 &lt;main+0x13&gt; 13: 48 83 c4 08 add $0x8,%rsp 17: e9 00 00 00 00 jmpq 1c &lt;main+0x1c&gt;yyerror.o: file format elf64-x86-64Disassembly of section .text:0000000000000000 &lt;yyerror&gt;: 0: 48 83 ec 08 sub $0x8,%rsp 4: 48 8b 35 00 00 00 00 mov 0x0(%rip),%rsi # b &lt;yyerror+0xb&gt; b: e8 00 00 00 00 callq 10 &lt;yyerror+0x10&gt; 10: 48 8b 35 00 00 00 00 mov 0x0(%rip),%rsi # 17 &lt;yyerror+0x17&gt; 17: bf 0a 00 00 00 mov $0xa,%edi 1c: e8 00 00 00 00 callq 21 &lt;yyerror+0x21&gt; 21: 31 c0 xor %eax,%eax 23: 48 83 c4 08 add $0x8,%rsp 27: c3 retq 每个可执行代码段将在需要特定的事件时执行，这些事件包括库的初始化和该程序本身主入口点。 对于那些着迷于底层编程细节的程序员来说，这是一个功能非常强大的工具，可用于研究编译器和汇编器的输出。细节信息，比如这段代码中所显示的这些信息，可以揭示有关本地处理器本身运行方式的很多内容。对该处理器制造商提供的技术文档进行深入的研究，您可以收集关于一些有价值的信息，通过这些信息可以深入地了解内部的运行机制，因为功能程序提供了清晰的输出。 我的功力还没有那么深厚, 这些都是转载而来, 等我努力努力再探讨这些. readelf这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）； 123456789101112131415161718192021222324[root@caoxl lib64]# readelf -all liby.aFile: liby.a(main.o)ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x0 Start of program headers: 0 (bytes into file) Start of section headers: 736 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 14 Section header string table index: 11... ELF Header 为该文件中所有段入口显示了详细的摘要。在列举出这些 Header 中的内容之前，您可以看到 Header 的具体数目。在研究一个较大的目标文件时，该信息可能非常有用。 除了所有这些段之外，编译器可以将调试信息放入到目标文件中，并且还可以显示这些信息。输入下面的命令，仔细分析编译器的输出（假设您扮演了调试程序的角色）: 1readelf --debug-dump a.out | more 调试工具，如 GDB，可以读取这些调试信息，并且当程序在调试器中运行的同时，您可以使用该工具显示更具描述性的标记，而不是对代码进行反汇编时的原始地址值。 size 查看程序内存占用size这个工具用来查看程序运行时各个段的实际内存占用: 1234[root@caoxl lib64]# size liby.a text data bss dec hex filename 77 0 0 77 4d main.o (ex liby.a) 88 0 0 88 58 yyerror.o (ex liby.a) file 文件类型查询这个工具用于查看文件的类型； 比如我们在64位机器上发现了一个32位的库，链接不上，这就有问题了： 12[root@caoxl lib64]# file liby.aliby.a: current ar archive 也可以查看Core文件是由哪个程序生成: 1[root@caoxl lib64]# file core.22355 strings 查询数据中的文本信息一个文件中包含二进制数据和文本数据，如果只需要查看其文本信息，使用这个命令就很方便；过滤掉非字符数据，将文本信息输出: 123456strings &lt;objfile&gt;# 例[root@caoxl ~]# strings test/test.php&lt;?phpecho 1024; fuser 显示文件使用者显示所有正在使用着指定的file, file system 或者 sockets的进程信息; 12[root@caoxl ~]# fuser -m -u test/test.php/root/test/test.php: 1rce(root) 2rc(root) 3rc(root) 5rc(root) 6rc(root) 7rc(root) 8rc(root) 9rc(root) 10rc(root) 11rc(root) 14rc(root) 15rc(root) 16rc(root) 17rc(root) 18rc(root) 19rc(root) 20rc(root) 21rc(root) 22rc(root) 23rc(root) 29rc(root) 30rc(root) 31rc(root) 32rc(root) 40rc(root) 42rc(root) 43rc(root) 44rc(root) 45rc(root) 58rc(root) 89rc(root) 219rc(root) 229rc(root) 230rc(root) 231rc(root) 232rc(root) 235rc(root) 242rc(root) 254rc(root) 255rc(root) 322rce(root) 354rce(root) 431rce(root) 460rce(polkitd) 462rce(dbus) 468rce(ntp) 470rce(root) 471rce(root) 472rce(root) 483rce(root) 711rce(root) 716rce(root) 777rce(root) 1358rce(mysql) 1448rce(root) 1476rce(root) 1508rce(root) 2277rce(root) 2278rce(www) 3114rce(root) 3121rce(root) 5457rce(root) 5459rce(root) 5628rc(root) 5643rc(root) 5652rc(root) 14571rc(root) 19436rce(root) 25899rce(root) 26119rce(root) 26120rce(www) 26121rce(www) 26828rce(www) 26829rce(www) 26830rce(www) 26831rce(www) 26832rce(www) 26833rce(www) 26834rce(www) 26835rce(www) 26841rce(www) 26842rce(www) 26863rce(www) 26864rce(www) 26865rce(www) 26866rce(www) 26867rce(www) 26982rce(www) 26983rce(www) 使用了-m和-u选项，用来查找所有正在使用test.php的所有进程的PID以及该进程的OWNER； fuser通常被用在诊断系统的”resource busy”问题。如果你希望kill所有正在使用某一指定的file, file system or sockets的进程的时候，你可以使用-k选项: 1fuser –k /path/to/your/filename xxd 十六进制显示数据12345678$xxd a.out0000000: 7f45 4c46 0101 0100 0000 0000 0000 0000 .ELF............0000010: 0200 0300 0100 0000 3083 0408 3400 0000 ........0...4...0000020: 3c11 0000 0000 0000 3400 2000 0900 2800 &lt;.......4. ...(.0000030: 1e00 1b00 0600 0000 3400 0000 3480 0408 ........4...4...0000040: 3480 0408 2001 0000 2001 0000 0500 0000 4... ... .......0000050: 0400 0000 0300 0000 5401 0000 5481 0408 ........T...T...... od 查看特殊格式的文件内容通常使用od命令查看特殊格式的文件内容。通过指定该命令的不同选项可以以十进制、八进制、十六进制和ASCII码来显示文件。 参数说明: -A 指定地址基数，包括： d 十进制 o 八进制（系统默认值） x 十六进制 n 不打印位移值 -t 指定数据的显示格式，主要的参数有： c ASCII字符或反斜杠序列 d 有符号十进制数 f 浮点数 o 八进制（系统默认值为02） u 无符号十进制数 x 十六进制数 除了选项c以外的其他选项后面都可以跟一个十进制数n，指定每个显示值所包含的字节数。 说明：od命令系统默认的显示方式是八进制，这也是该命令的名称由来（Octal Dump）。但这不是最有用的显示方式，用ASCII码和十六进制组合的方式能提供更有价值的信息输出。 以十六进制和字符同时显示: 123456789101112$od -Ax -tcx4 a.c000000 # i n c l u d e &lt; s t d i o . 636e6923 6564756c 74733c20 2e6f6964000010 h &gt; \\n \\n v o i d m a i n ( ) \\n 0a0a3e68 64696f76 69616d20 0a29286e000020 &#123; \\n \\t i n t i = 5 ; \\n \\t p 69090a7b 6920746e 35203d20 70090a3b000030 r i n t f ( \" h e l l o , % d \" 746e6972 68222866 6f6c6c65 2264252c000040 , i ) ; \\n &#125; \\n 3b29692c 000a7d0a000047 以字符方式显示: 1234567$od -c a.c0000000 # i n c l u d e &lt; s t d i o .0000020 h &gt; \\n \\n v o i d m a i n ( ) \\n0000040 &#123; \\n \\t i n t i = 5 ; \\n \\t p0000060 r i n t f ( \" h e l l o , % d \"0000100 , i ) ; \\n &#125; \\n0000107","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Linux 程序构建","slug":"Linux-Program-Build","date":"2018-08-24T03:04:18.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/24/Linux-Program-Build/","link":"","permalink":"http://blog.caoxl.com/2018/08/24/Linux-Program-Build/","excerpt":"一般源代码提供的程序安装需要通过配置、编译、安装三个步骤:","text":"一般源代码提供的程序安装需要通过配置、编译、安装三个步骤: 配置做的工作主要是检查当前环境是否满足要安装软件的依赖关系，以及设置程序安装所需要的初始化信息，比如安装路径，需要安装哪些组件；配置完成，会生成makefile文件供第二步make使用； 编译是对源文件进行编译链接生成可执行程序； 安装做的工作就简单多了，就是将生成的可执行文件拷贝到配置时设置的初始路径下； 配置 查询可用的配置选项: 1./configure --help 配置路径: 1./configure --prefix=/usr/local/snmp --prefix是配置使用的最常用选项，设置程序安装的路径； 编译 编译使用make编译: 1make -f myMakefile 通过-f选项显示指定需要编译的makefile；如果待使用makefile文件在当前路径，且文件名为以下几个，则不用显示指定： makefile Makefile makefile编写的要点 必须满足第一条规则，满足后停止 除第一条规则，其他无顺序 makefile中的全局自变量 $@ 目标文件名 @^ 所有前提名，除副本 @+ 所有前提名，含副本 @&lt; 一个前提名 @? 所有新于目标文件的前提名 @* 目标文件的基名称 更多选择 CMake CMake是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件。使用CMake，能够使程序员从复杂的编译连接过程中解脱出来。它使用一个名为 CMakeLists.txt 的文件来描述构建过程,可以生成标准的构建文件,如 Unix/Linux 的 Makefile 或Windows Visual C++ 的 projects/workspaces 。 编译依赖的库 makefile编译过程中所依赖的非标准库和头文件路径需要显示指明: 12CPPFLAGS -I 标记非标准头文件存放路径LDFLAGS -L 标记非标准库存放路径 如果CPPFLAGS和LDFLAGS已在用户环境变量中设置并且导出（使用export关键字），就不用再显示指定； 123make -f myMakefileLDFLAGS='-L/var/xxx/lib -L/opt/mysql/lib'CPPFLAGS='-I/usr/local/libcom/include -I/usr/local/libpng/include' 注意: 链接多库时，多个库之间如果有依赖，需要注意书写的顺序，右边是左边的前提； g++编译1g++ -o unixApp unixApp.o a.o b.o 选项说明： -o: 指明生成的目标文件 -g: 添加调试信息 -E: 查看中间文件 应用：查询宏展开的中间文件： 在g++的编译选项中，添加 -E 选项，然后去掉 -o 选项 ，重定向到一个文件中即可: 1g++ -g -E unixApp.cpp -I/opt/app/source &gt; midfile 查询应用程序需要链接的库: 1ldd myprogrammer 安装安装做的工作就简单多了，就是将生成的可执行文件拷贝到配置时设置的初始路径下: 1make install 其实 install 就是makefile中的一个规则，打开makefile文件后可以查看程序安装的所做的工作； 总结 configure make install g++","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Linux 系统管理及IPC资源管理","slug":"Linux-System-Manage","date":"2018-08-24T02:21:22.000Z","updated":"2018-08-28T09:51:38.000Z","comments":true,"path":"2018/08/24/Linux-System-Manage/","link":"","permalink":"http://blog.caoxl.com/2018/08/24/Linux-System-Manage/","excerpt":"Linux 系统管理及IPC资源管理","text":"Linux 系统管理及IPC资源管理 系统管理查询系统版本 查看Linux系统版本: 12345[root@caoxl ~]# uname -aLinux caoxl 3.10.0-862.9.1.el7.x86_64 #1 SMP Mon Jul 16 16:29:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux# 或者lsb_release -a 查询硬件信息 查看CPU使用情况: 123456789101112131415[root@caoxl ~]# sar -u 5 10Linux 3.10.0-862.9.1.el7.x86_64 (caoxl) 08/24/2018 _x86_64_ (1 CPU)10:26:12 AM CPU %user %nice %system %iowait %steal %idle10:26:17 AM all 0.20 0.00 0.20 0.00 0.00 99.6010:26:22 AM all 0.00 0.00 0.20 0.00 0.00 99.8010:26:27 AM all 0.40 0.00 0.20 0.00 0.00 99.4010:26:32 AM all 0.20 0.00 0.00 0.80 0.00 99.0010:26:37 AM all 0.20 0.00 0.20 0.00 0.00 99.6010:26:42 AM all 0.20 0.00 0.20 0.00 0.00 99.6010:26:47 AM all 0.00 0.00 0.00 0.00 0.00 100.0010:26:52 AM all 0.20 0.00 0.00 0.00 0.00 99.8010:26:57 AM all 0.20 0.00 0.20 0.00 0.00 99.6010:27:02 AM all 0.20 0.00 0.20 0.00 0.00 99.60Average: all 0.18 0.00 0.14 0.08 0.00 99.60 查询CPU信息: 1234567891011121314151617181920212223242526[root@caoxl ~]# cat /proc/cpuinfoprocessor : 0vendor_id : GenuineIntelcpu family : 6model : 79model name : Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHzstepping : 1microcode : 0x1cpu MHz : 2499.996cache size : 40960 KBphysical id : 0siblings : 1core id : 0cpu cores : 1apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch ibrs ibpb stibp fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm rdseed adx smap xsaveopt spec_ctrl intel_stibpbogomips : 4999.99clflush size : 64cache_alignment : 64address sizes : 46 bits physical, 48 bits virtualpower management: 查看CPU的核的个数: 12[root@caoxl ~]# cat /proc/cpuinfo | grep processor | wc -l1 查看内存信息: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@caoxl ~]# cat /proc/meminfoMemTotal: 1015436 kBMemFree: 117588 kBMemAvailable: 526340 kBBuffers: 77540 kBCached: 426928 kBSwapCached: 0 kBActive: 641068 kBInactive: 138596 kBActive(anon): 275492 kBInactive(anon): 2368 kBActive(file): 365576 kBInactive(file): 136228 kBUnevictable: 0 kBMlocked: 0 kBSwapTotal: 0 kBSwapFree: 0 kBDirty: 16 kBWriteback: 0 kBAnonPages: 275228 kBMapped: 37868 kBShmem: 2664 kBSlab: 84628 kBSReclaimable: 69448 kBSUnreclaim: 15180 kBKernelStack: 2928 kBPageTables: 10428 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 507716 kBCommitted_AS: 890020 kBVmallocTotal: 34359738367 kBVmallocUsed: 8812 kBVmallocChunk: 34359719676 kBHardwareCorrupted: 0 kBAnonHugePages: 57344 kBCmaTotal: 0 kBCmaFree: 0 kBHugePages_Total: 0HugePages_Free: 0HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBDirectMap4k: 63360 kBDirectMap2M: 985088 kBDirectMap1G: 0 kB 显示内存page大小（以KByte为单位）: 1234567891011[root@caoxl ~]# pagesize4096# 安装pagesize[root@caoxl ~]# yum search pagesizeLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfile===================================== Matched: pagesize ======================================libhugetlbfs-utils.x86_64 : Userspace utilities for configuring the hugepage environment[root@caoxl ~]# yum install -y libhugetlbfs-utils 显示架构: 12[root@caoxl ~]# archx86_64 设置系统时间 显示当前系统时间: 12[root@caoxl ~]# dateFri Aug 24 10:31:05 CST 2018 设置系统日期和时间(格式为2018-8-24 10:30:00): 123date -s 2018-8-24 10:30:00date -s 2018-8-24date -s 10:30:00 设置时区: 1234567891011121314151617选择时区信息。命令为：tzselect根据系统提示，选择相应的时区信息。[root@caoxl ~]# tzselectPlease identify a location so that time zone rules can be set correctly.Please select a continent or ocean. 1) Africa 2) Americas 3) Antarctica 4) Arctic Ocean 5) Asia 6) Atlantic Ocean 7) Australia 8) Europe 9) Indian Ocean10) Pacific Ocean11) none - I want to specify the time zone using the Posix TZ format. 强制把系统时间写入CMOS（这样，重启后时间也正确了）: 1[root@caoxl ~]# clock -w 设置系统时间需要root用户权限. 格式化输出当前日期时间: 12[root@caoxl ~]# date +%Y%m%d.%H%M%S20180824.103400 IPC资源管理IPC资源查询 查看系统使用的IPC资源: 12345678910[root@caoxl ~]# ipcs------ Message Queues --------key msqid owner perms used-bytes messages ------ Shared Memory Segments --------key shmid owner perms bytes nattch status ------ Semaphore Arrays --------key semid owner perms nsems 查看系统使用的IPC共享内存资源: 1234[root@caoxl ~]# ipcs -m------ Shared Memory Segments --------key shmid owner perms bytes nattch status 查看系统使用的IPC队列资源: 1234[root@caoxl ~]# ipcs -q------ Message Queues --------key msqid owner perms used-bytes messages 查看系统使用的IPC信号量资源: 1234[root@caoxl ~]# ipcs -s------ Semaphore Arrays --------key semid owner perms nsems 应用示例：查看IPC资源被谁占用 有个IPCKEY：51036 ，需要查询其是否被占用； 首先通过计算器将其转为十六进制: 51036 -&gt; c75c 如果知道是被共享内存占用: 1[root@caoxl ~]# ipcs -m | grep c75c 如果不确定，则直接查找: 1[root@caoxl ~]# ipcs | grep c75c 检测和设置系统资源限制 显示当前所有的系统资源 limit 信息: 1234567891011121314151617[root@caoxl ~]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 3883max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 65535pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 65535virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 对生成的 core 文件的大小不进行限制: 1[root@caoxl ~]# ulimit -c unlimited 总结 uname sar arch date ipcs ulimit","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"系统管理","slug":"系统管理","permalink":"http://blog.caoxl.com/tags/系统管理/"},{"name":"IPC","slug":"IPC","permalink":"http://blog.caoxl.com/tags/IPC/"}]},{"title":"Linux 进程管理工具","slug":"Linux-process-manage","date":"2018-08-23T07:31:16.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/23/Linux-process-manage/","link":"","permalink":"http://blog.caoxl.com/2018/08/23/Linux-process-manage/","excerpt":"任何进程都与文件关联；我们会用到lsof工具（list opened files），作用是列举系统中已经被打开的文件。在linux环境中，任何事物都是文件，设备是文件，目录是文件，甚至sockets也是文件。用好lsof命令，对日常的linux管理非常有帮助。","text":"任何进程都与文件关联；我们会用到lsof工具（list opened files），作用是列举系统中已经被打开的文件。在linux环境中，任何事物都是文件，设备是文件，目录是文件，甚至sockets也是文件。用好lsof命令，对日常的linux管理非常有帮助。 查询进程 查询正在运行的进程信息 12345[root@caoxl ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Aug03 ? 00:00:14 /usr/lib/systemd/systemd --switched-root --sysroot 2 0 0 Aug03 ? 00:00:00 [kthreadd]root 3 2 0 Aug03 ? 00:00:06 [ksoftirqd/0] 查询归属于用户caoxl的进程 1234567[root@caoxl ~]# ps -ef | grep caoxlroot 4243 3740 0 15:36 pts/0 00:00:00 grep --color=auto caoxl[root@caoxl ~]# ps -lu caoxlF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD[root@caoxl ~]# ps -lu gitF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD 查询进程ID（适合只记得部分进程字段） 12345pgrep 查找进程# 查询进程名中含有re的进程[root@caoxl ~]# pgrep -l re2 kthreadd 以完整的格式显示所有的进程 12345[root@caoxl ~]# ps -ajx PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 0 1 1 1 ? -1 Ss 0 0:14 /usr/lib/systemd/systemd --switched-r 0 2 0 0 ? -1 S 0 0:00 [kthreadd] 2 3 0 0 ? -1 S 0 0:06 [ksoftirqd/0] 显示进程信息，并实时更新 1234567891011[root@caoxl ~]# toptop - 15:39:34 up 20 days, 6:00, 1 user, load average: 0.00, 0.01, 0.05Tasks: 91 total, 1 running, 90 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.0 us, 0.0 sy, 0.0 ni,100.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1015436 total, 103440 free, 309648 used, 602348 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 527000 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 43392 3080 1888 S 0.0 0.3 0:14.48 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.17 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:06.59 ksoftirqd/0 查看端口占用的进程状态： 12345[root@caoxl ~]# lsof -i:6789COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEpython 1448 root 4u IPv6 15329 0t0 TCP *:smc-https (LISTEN)python 1448 root 6u IPv6 15330 0t0 UDP *:smc-https python 1448 root 10u IPv6 774840 0t0 TCP caoxl:smc-https-&gt;61.140.74.96:25124 (ESTABLISHED) 查看用户username的进程所打开的文件 1lsof -u username 查询mysqld进程当前打开的文件 123456[root@caoxl ~]# lsof -c mysqldCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld_sa 777 root cwd DIR 253,1 4096 1445566 /usr/local/mysqlmysqld_sa 777 root rtd DIR 253,1 4096 2 /mysqld_sa 777 root txt REG 253,1 964544 1055537 /usr/bin/bash... 查询指定的进程ID(777)打开的文件： 1234567[root@caoxl ~]# lsof -p 777COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld_sa 777 root cwd DIR 253,1 4096 1445566 /usr/local/mysqlmysqld_sa 777 root rtd DIR 253,1 4096 2 /mysqld_sa 777 root txt REG 253,1 964544 1055537 /usr/bin/bashmysqld_sa 777 root mem REG 253,1 62184 1053860 /usr/lib64/libnss_files-2.17.so... 查询指定目录下被进程开启的文件（使用+D 递归目录）： 123[root@caoxl ~]# lsof +d /usr/localCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld_sa 777 root cwd DIR 253,1 4096 1445566 /usr/local/mysql 终止进程 杀死指定PID的进程 (PID为Process ID) 1kill PID 杀死相关进程 1kill -p 1234 杀死job工作 (job为job number) 1kill $job 进程监控 查看系统中使用CPU、使用内存最多的进程； 1top 输入top命令后，进入到交互界面；接着输入字符命令后显示相应的进程状态：对于进程，平时我们最常想知道的就是哪些进程占用CPU最多，占用内存最多。以下两个命令就可以满足要求: P: 根据CPU使用百分比大小进行排序。 M: 根据驻留内存大小进行排序 i: 使top不显示任何闲置或者僵死进程。 分析线程栈使用命令pmap，来输出进程内存的状况，可以用来分析线程堆栈； 123456[root@caoxl ~]# pmap 777777: /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/usr/local/mysql/var --pid-file=/usr/local/mysql/var/izj6c6djex81rijczh0t8yz.pid0000000000400000 884K r-x-- bash00000000006dd000 4K r---- bash00000000006de000 36K rw--- bash... 综合运用 将用户caoxl下的所有进程名以av_开头的进程终止: 1ps -u caoxl | awk '/av_/ &#123;print \"kill -9 \" $1&#125;' | sh 将用户caoxl下所有进程名中包含HOST的进程终止: 1ps -fe| grep caoxl|grep HOST |awk '&#123;print $2&#125;' | xargs kill -9;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"进程管理","slug":"进程管理","permalink":"http://blog.caoxl.com/tags/进程管理/"}]},{"title":"SEO 3分钟入门","slug":"SEO-Introduction","date":"2018-08-23T06:37:54.000Z","updated":"2019-08-22T06:53:23.000Z","comments":true,"path":"2018/08/23/SEO-Introduction/","link":"","permalink":"http://blog.caoxl.com/2018/08/23/SEO-Introduction/","excerpt":"对于 Web 开发者，尤其是前端工程师来说，对网站进行 SEO 是必不可少的技能之一。今天来个简单入门。","text":"对于 Web 开发者，尤其是前端工程师来说，对网站进行 SEO 是必不可少的技能之一。今天来个简单入门。 一、背景知识：搜索引擎工作原理对于初学者来说，在某个搜索引擎网站上，从输入关键字到回车得到搜索结果的过程中发生了什么事？ 回答这个问题之前必须了解的概念有： 1、搜索引擎数据库存储着海量的关键字，每个关键字对应着相应的网址。关键字是由搜索引擎程序下载、分析而来，以供搜索。 2、Spider即搜索引擎程序，也被叫做网页蜘蛛或网络爬虫，它是搜索引擎的核心程序。 蜘蛛的工作就是每时每刻地重复链接所指的网页下载、网页内容分析、提炼关键字并根据需要将关键字加入数据库的工作。 那什么情况下蜘蛛会将关键字添加到搜索引擎数据库呢？ 如果蜘蛛认为网页的内容是数据库当前并没有的，并且对用户是有用的，那么提炼出来的关键字就将被存入数据库。 而如果经过蜘蛛的判断，网页内容是一些垃圾数据，那么蜘蛛会舍弃该网页，然后继续下载、分析下一个链接的网页。 3、搜索与排名过程当用户使用某个搜索引擎输入某个关键字回车后，搜索引擎程序就会从后台数据库中检索出与之相关的网址呈现给用户。 由于同一个关键字对应很多个网址的情况是非常普遍的，所以这就面临了一个 搜索排序 的问题。 通常情况下，与关键字最吻合的网站理所应当地排在搜索结果的前面。但是，这里还有一个问题，就是：网站能否被搜索引擎“读懂”。 什么叫读懂什么叫读不懂？举个例子： 如果网站是有 Flash 或者说 Javascript 生成的，那么此时无论关键字和网站内容是多么相符，搜索引擎也不会收录该网站。 即网站内容要想被搜索引擎所搜录，首先就要被搜索引擎所识别，而识别的前提就是使用搜索引擎能够理解的语言。 所以这里就引出了一个问题：如何使用搜索引擎能“读懂”的语言呢？ 二、什么是 SEO ?1、概念Search Engine Optimization：为了提升网页在搜索引擎自然搜索结果中的收录数量和排序位置而做出的优化行为就是 SEO !注意 如果关键字只关联到互联网上极少的网站，在这种情况下一般也能够获得较前的排序结果，但是这种情况并不是 SEO。 2、SEO 分类 白帽 SEO 是搜索引擎所鼓励的，具有改良和规范网站设计，使之对搜索引擎和用户更加地友好，同时也能帮助网站获得更多来自搜索引擎的合理的流量的作用。 黑帽 SEO 一种欺骗搜索引擎从而获得较高排序的行为。这种情况会浪费用户的时间，比如一些不良网站上罗列实际内容并没有提供的关键字，用户点击进去后往往什么有用的信息都得不到。 三、白帽 SEO 常见手段白帽 SEO 主要可以从以下方面来进行： 一、站在网站内容上的白帽 SEO主要有如下措施： 对 网站标题、关键字、描述 精心设计：让搜索引擎知道该网站是做什么的。 网站内容优化：网站内容和关键字的对应、增加关键字的密度、增加长尾关键字。 Robot.txt 文件 网站地图 增加外链引用：到其他网站上进行宣传，把搜索引擎从其他网站上引到自己的网站上。 二、从前端工程师的角度的白帽 SEO即：既可以让浏览器能读懂，也能让 Spider 读懂，越容易被 Spider 读懂的网站越容易被搜索引擎所收录。一般有如下 SEO 方案： 1、 网站结构布局优化结构布局尽量简单，目录层次要少( 一般中小型网站目录层次大于 3 层后搜索引擎就不会继续分析 )，推荐扁平化结构。 以扁平化结构来进行网站结构布局优化，一般注意以下三点： ① 控制首页链接数量 网站首页是权重最高的地方，首页链接既不能太少，否则影响搜索引擎的收录；也不能太多，中小型网站推荐链接数为 100 以内，否则会影响用户体验。 ② 扁平化的目录层次 不要使用纵深型的结构而是用扁平结构，目录层次不超过 3 次 —— 这既是对搜索引擎友好，也是对用户体验的考虑。 ③ 导航 SEO 导航一般可以分为主导航、副导航、分类导航等，其位置可以位于网页的任何位置，以方便 SEO 为参考依据。 导航方式尽量采用文字，但是如果用了图片作为导航超链接，那么一定要设置 title 或 alt 属性值，以防止图床出现问题时候用户不知该导航指的是什么从而影响用户体验。 2、 采用 面包屑导航说明: 起源于童话：樵夫、后母企图丢掉孩子、儿子事先留下面包屑，以方便回家的导航 使用面包屑导航的优势： 站在用户体验的角度 ①. 让用户了解当前所处位置。 ②. 使用户可以了解网站内容和组织形式。 站在 SEO 的角度 使搜索引擎清楚地“读懂”网站结构，还增加了大量的内部链接，方便抓取，降低了跳出率。 四、SEO 中不可忽略的细节 1、 增加页面相关性 首页中需要注意增加一些相关链接，以增强页面相关性和页面的权重。 除了 SEO 目的外，这样做还能留住访问者。 2、 优化分页 比较 3 中分页的写法： ①. 首页-上页-下页-尾页②. 首页 1 2 3 4 5 6 7 8 9 10 下一页③. 首页 1 2 3 4 5 6 7 8 9 10 下拉列表 推荐使用 ③ 的写法，对搜索引擎更友好。 3、 网站的加载速度 加载速度会影响用户和 Spider 的“耐心”，注意引用资源的可靠性。 此外，将 CSS 的引入放在 HTML 文档的开头，而将 Javascript 的引入放在 HTML 的末尾。 五、网页代码优化 &lt;title&gt; 网页标题要强调重点，每个页面不要重复出现。 &lt;meta name=&quot;Keywords&quot; content=&quot;..., ..., ...&quot;&gt; 列举出几个重要的关键词即可。 &lt;meta name=&quot;Description&quot; content=&quot;...&quot;&gt; 高度概括网页的内容，每个网页的 description 也要不同。 网页代码优化原则： 语义化代码HTML 中的每个标签都有特定的意义。语义化就是在适当的位置使用适当的标签，使访问者和 Spider 都能够一目了然。举例说明： 在 HTML 中，&lt;div&gt; 和 &lt;span&gt; 的语义化程度最小，所以在构建类似菜单的时候不要使用它们而使用 &lt;ul&gt; 和 &lt;li&gt;。 &lt;div&gt; 和 &lt;span&gt; 更适合网页布局和定位。 CSS 的渲染交给浏览器，Spider 的抓取仅是标签代码内的内容( 要求精简而正确 )，这样就不容易混乱。 这就是在适当的时机使用适当的标签的理念。 六、其他常用 HTML 标签的 SEO 措施 &lt;a&gt; 加上说明、设置 title 属性值。对于指向其他网站的链接要设置 rel=&quot;nofollow&quot; 属性，以防止 Spider 离开本网站而不再回来。 &lt;h1&gt; 标题一定要用 &lt;h1&gt;，这是 Spider 最看重的标签之一，所以 不要滥用&lt;h1&gt;。 &lt;p&gt; 与 &lt;br&gt; &lt;br&gt; 只出现在 &lt;p&gt; 中，其他块级标签使用 CSS 控制，比如 padding 和 margin 属性。 &lt;caption&gt; 表格标题很容易被忽视，但是如果使用表格时候没用 caption 标签，对搜索引擎不友好的。 &lt;img&gt; 现在的 Spider 对图片的读取能力是不够的，应使用 alt 属性说明，对图片进行注释，以帮助搜索引擎读取图片。 &lt;strong&gt;、&lt;em&gt; 与 &lt;b&gt;、&lt;i&gt; 都是强调文字，此外&lt;b&gt; 和 &lt;strong&gt;、&lt;em&gt; 和 &lt;i&gt; 在浏览器上的效果一样。 但也有不同之处。两组的使用场景为： &lt;b&gt;、&lt;i&gt; 对 SEO 效果不好而 &lt;strong&gt;、&lt;em&gt; 在搜索引擎看来是有比较高的权重的。 说明: &lt;strong&gt; 是权重标签的代表，能够突出关键词，表现重要的内容。&lt;em&gt; 也是强调内容和吸引访问者关注，&lt;em&gt;对搜索引擎的权重仅次于 &lt;strong&gt;。 如果要强调文字内容利于 SEO，则使用 、；如果仅仅强调内容在浏览器中的样式，则使用 、。 七、其他网页代码优化的 TIPS 1、 重要内容 HTML 代码放在最前面 巧妙利用 CSS 布局。因为 Spider 抓取网页的顺序是由上至下的，在 Spider 没有“失去耐心” 之前尽量先把最重要的内容显示出来。广告等不重要的代码放在网页底部。 2、 重要内容 不要用 Javascript 输出 因为 Spider 看不懂 Javascript。 3、 尽量少使用 iframe 框架。 4、 谨慎使用 display:none; 对于想要暂时隐藏的文字尽量使用 z-index 属性或将其设置到浏览器的显示范围外，因为 Spider 会过滤掉 display:none; 中的内容。 5、 不断精简代码 标签中的内容尽量就是内容，不要使用其他的 HTML 代码。比如 &nbsp;，如果确实需要空格效果，可以通过 CSS 来控制。","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.caoxl.com/tags/前端/"},{"name":"SEO","slug":"SEO","permalink":"http://blog.caoxl.com/tags/SEO/"}]},{"title":"Linux scp 跨机远程拷贝","slug":"Linux-Tool-scp","date":"2018-08-23T03:10:09.000Z","updated":"2019-08-22T03:50:22.000Z","comments":true,"path":"2018/08/23/Linux-Tool-scp/","link":"","permalink":"http://blog.caoxl.com/2018/08/23/Linux-Tool-scp/","excerpt":"scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。","text":"scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。 注解 类似的工具有rsync；scp消耗资源少，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。rsync比scp会快一点，但当小文件多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。 命令格式1scp [参数] [原路径] [目标路径] 命令参数 -1: 强制scp命令使用协议ssh1 -2: 强制scp命令使用协议ssh2 -4: 强制scp命令只使用IPv4寻址 -6: 强制scp命令只使用IPv6寻址 -B: 使用批处理模式 (传输过程中不询问传输口令或短语) -C: 允许压缩 (将-C标志传递给ssh, 从而打开压缩功能) -p: 留源文件的修改时间, 访问时间和访问权限 -q: 不显示传输进度条 -r: 递归复制整个目录 -v: 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c: cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F: ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i: identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l: limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o: ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P: port 注意是大写的P, port是指定数据传输用到的端口号 -S: program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。 使用说明 复制文件: 1234scp local_file remote_username@remote_ip:remote_folderscp local_file remote_username@remote_ip:remote_filescp local_file remote_ip:remote_folderscp local_file remote_ip:remote_file 指定了用户名，命令执行后需要输入用户密码；如果不指定用户名，命令执行后需要输入用户名和密码； 复制目录: 12scp -r local_folder remote_username@remote_ip:remote_folderscp -r local_folder remote_ip:remote_folder 第1个指定了用户名，命令执行后需要输入用户密码； 第2个没有指定用户名，命令执行后需要输入用户名和密码； 从远程复制到本地的scp命令与上面的命令一样，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。 可以在一个服务器上操作另外两个服务器, 如果你闲的蛋疼的话。 使用示例实例1：从远程复制文件到本地目录12345678910scp root@47.91.221.85:/root/test/test.php /root/test/[root@sciclean test]# scp root@47.91.221.85:/root/test/test.php /root/test/The authenticity of host '47.91.221.85 (47.91.221.85)' can't be established.ECDSA key fingerprint is SHA256:rGsD3scTCMNo6ZSoMepg0RMPz4n3CLHEZyZTyyJbgz4.ECDSA key fingerprint is MD5:ea:0d:b5:e0:5d:49:4a:5a:a0:85:e2:91:60:c7:0f:3d.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '47.91.221.85' (ECDSA) to the list of known hosts.root@47.91.221.85's password: test.php 100% 18 0.5KB/s 00:00 说明： 从47.91.221.85机器上的/root/test/的目录中下载 test.php 文件到本地/root/test 目录中 实例2：从远程复制目录到本地1scp -r root@47.91.221.85:/root/test/ /root/test/ 说明： 从47.91.221.85机器上的/root/中下载test目录到本地的/root/test/目录来。 实例3：上传本地文件到远程机器指定目录1scp /root/test/demo.tar root@47.91.221.85:/root/test/ 说明： 复制本地/root/test/目录下的文件demo.tar 到远程机器47.91.221.85的/root/test/目录 实例4：上传本地目录到远程机器指定目录1scp -r /root/test root@47.91.221.85:/root/test 说明： 上传本地目录 /root/test 到远程机器47.91.221.85上/root/test的目录中 参考 scp 跨机远程拷贝","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"scp","slug":"scp","permalink":"http://blog.caoxl.com/tags/scp/"}]},{"title":"关于 PJAX","slug":"About-PJAX","date":"2018-08-23T01:53:42.000Z","updated":"2019-08-22T06:53:36.000Z","comments":true,"path":"2018/08/23/About-PJAX/","link":"","permalink":"http://blog.caoxl.com/2018/08/23/About-PJAX/","excerpt":"使用 AJAX 和 window.history.pushState 无刷新改变页面内容和地址栏 URL。","text":"使用 AJAX 和 window.history.pushState 无刷新改变页面内容和地址栏 URL。 在访问现在很火的 Google plus 时，细心的用户也许会发现页面之间的点击是通过 AJAX 异步请求的，同时页面的URL发生了了改变。并且能够很好的支持浏览器的前进和后退。不禁让人想问，是什么有这么强大的功能呢？ HTML5 里引用了新的API，就是 history.pushState 和 history.replaceState，就是通过这个接口做到无刷新改变页面 URL 的。 与传统的AJAX的区别传统的 AJAX 有如下的问题： 虽然 AJAX 可以无刷新改变页面内容，但无法改变页面URL。 其次为了更好的可访问性，内容发生改变后，改变 URL 的 hash。但是 hash 的方式不能很好的处理浏览器的前进、后退等问题 有的浏览器引入了 onhashchange 的接口，不支持的浏览器只能定时去判断 hash 是否改变。 再有， AJAX 的使用对搜索引擎很不友好，往往蜘蛛爬到的区域是空的。 为了解决传统 AJAX 带来的问题，HTML5里引入了新的API，即：history.pushState, history.replaceState。 可以通过 pushState 和 replaceState 接口操作浏览器历史，并且改变当前页面的URL。 pushState 是将指定的 URL 添加到浏览器历史里; replaceState 是将指定的 URL 替换当前的 URL。 如何调用123456var state = &#123; title: title, url: options.url, otherkey: othervalue&#125; ;window.history.pushState(state, document.title, url); state 对象除了要 title 和 url 之外，也可以添加其他的数据，比如：还想将一些发送 AJAX 的配置给保存起来。 replaceState 和 pushState 是相似的，不需要多做解释。 如何响应浏览器的前进、后退操作?window 对象上提供了 onpopstate 事件，上面传递的 state 对象会成为 event 的子对象，这样就可以拿到存储的 title 和 URL 了。 123456window.addEventListener('popstate', function(e)&#123;if (history.state)&#123; var state = e.state; // do something(state.url, state.title);&#125;&#125;, false) ; 这样就可以结合 AJAX 和 pushState 完美的进行无刷新浏览了。 一些限制 无法跨域，这个是必然的。引用曾经在网上看到的一句经典的话： 如果javascript可以跨域的话，那他就可以逆天了… state 对象虽然可以存储很多自定义的属性，但值不能是个对象 对应后端的一些处理这种模式下除了当前使用 AJAX 可以无刷新浏览外，还要保证直接请求改变的URL后也可以正常浏览，所以后端要对这些处理下。 对结合 pushState 的 AJAX 可以发送一个特殊的头，如：setRequestHeader(‘PJAX’, ‘true’)。 后端获取到有 PJAX=true 的 header 时，将页面中通用的部分都不输出。 比如：PHP 可以通过下面的判断: 123function is_pjax()&#123; return array_key_exists('HTTP_X_PJAX', $_SERVER) &amp;&amp; $_SERVER['HTTP_X_PJAX'] === 'true';&#125; 虽然接口上只有 pushState、replaceState、onpopstate，但在使用的时候还是要做很多处理的。 快捷使用PJAX 引入PJAX 1&lt;script src='https://cdnjs.cloudflare.com/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js'&gt;&lt;/script&gt; 调用PJAX 12345$(document).pjax('a[href^=\"http://blog.caoxl.com\"]:not(a[target=\"_blank\"], a[no-pjax])', &#123; container: '#page', // 需要刷新的标签 fragment: '#page', // 容器 ??? timeout: 8000&#125;);","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://blog.caoxl.com/tags/前端/"},{"name":"PJAX","slug":"PJAX","permalink":"http://blog.caoxl.com/tags/PJAX/"}]},{"title":"计算机专业术语及其英文表达","slug":"Computer-Jargon","date":"2018-08-22T07:05:02.000Z","updated":"2019-08-22T03:15:29.000Z","comments":true,"path":"2018/08/22/Computer-Jargon/","link":"","permalink":"http://blog.caoxl.com/2018/08/22/Computer-Jargon/","excerpt":"随着在专业方向上的积累，对英语单词的记忆类别的差异自然会逐渐显现出来。本文章不断更新.","text":"随着在专业方向上的积累，对英语单词的记忆类别的差异自然会逐渐显现出来。本文章不断更新. 以下是计算机专业术语的英语表达。 A – Action speaks louder than words annotation 注释 arguably 可论证的 attribution 归属 authenticity 可靠性、真实性 ambiguous 模糊不清、引起歧义的 antennas 天线 archiver 归档 arbitrary 任意的、武断的 all-around 多面手、全方位的 B – Believe in yourself bogus 伪造的、假的 bottleneck 瓶颈 bash 猛击 尝试 bare-bones 最基本的 C – Confidence in yourself is the first step on the road to success conventions 习俗 公约 惯例 conform 遵守 符合 compress 压缩 codename 代号 cease 停止 cadence 节奏 chassis 底盘 D – Do one thing at time, and do well distill 精华 蒸馏 提炼 down to 归根结底 diagraming 图解法 示意图 dashboard 仪表盘 deploy 部署 data traffic 数据传输 数据业务 documentation 文档 文件 证明 登记 记录 daemons 守护进程 后台驻留程序 decompression 解压缩 detection 检测 发现 侦查 designate 指派 指定 dazzling 耀眼 令人眼花缭乱 directive 指令 命令 指示 delegate 代表 委托 授权 downside 下降趋势 缺点 dissect 分解 剖析 E – Experience is the best teacher esoteric 秘传的 机密的 难懂的 engross 独占 使全神贯注 embedded 可嵌入的 expires 到期 死亡 期满 explicitly 明确的 生动的 eternally 永久的 永恒的 emit 散发 发射 errata 排印错误 勘误表 erratum的复数 F – Failure is the mother of success frosty 严寒 冷淡的 friction 摩擦力 footprint 程序所占用的空间 对环境的影响 足迹脚印 front-page 首页 头版 fabric 基础 结构 织物 G – God helps those who help themselves gadget 小机械 小玩意 H – He that gains time gain all things hood 引擎罩 风貌 防护罩 high-end 高端 hypothetical 假想 假设 I – I can because i think i can injection 注射 投入 incorporating 结合 纳入 合并 interpreter 翻译员 解释程序 解释器 identical 一致的 相同的 intermediate 中级 incur 招致 引起 带来 J – Jack of all trades, master of none jurisdiction 司法权 管辖权 K – Keep on going never give upL – Learn and live log 日志 记录 lightweight 轻量级 轻量 lug 用力拖 耳状物 launch 发射 发动 实施 发行 literally 字面 逐字的 简直的 确实的 M – Many drops make a shower mechanics 力学 技工、操作方法 manually 手动地 mandatory 强制性的 manuscripts 手抄本 手稿 mainline 主线 modular 模块化的 multiplexes 复 多路传输 多种多样的 misconfigure 配置错误 milestone 里程碑 N – Never do things by halves nostalgia 怀旧 乡思 niche 地位 职业 壁龛(kan) narrative 叙事的 O – One thing i konw that is i know nothing originate 起源 发明 创造 odd out 格格不入 on-demand 按需的 随选的 offload 卸载 (货/数据) 转让 排解 overall 总体的 onward 继续 向前 over head 过头 经常性开支/消耗 P – Pride goes before, and shame comes after polyglot 多种语言的 portable 便携式 可携带 可移植 portal 入口 门户网站 patch 补丁 parallel 平行 并联 同时 pass 传递 (参数) parameter 参数 pinnacle 顶峰 pinch 捏 paradigm 范例 范式 plural 复数 pre-built 预编译 paperweight 镇纸 Q – Quickly come, quickly goR – Read, study and learn about everthing important in you life regular expressions 正则表达式 round robin 循环赛 联名请愿书 retrieve 检索 取回 remarkable 卓越的 可观的 平凡的 refresher 复习 额外诉讼费 resort 度假胜地 招数 rigid 刚性的 坚硬 死板 S – Success belongs to the persevering scheme 计划 体系 结构 方案 snag 障碍 妨碍 spoof 恶搞 哄骗 simultaneous/concurrent 同时发生的 并发的/一致的 sweat 汗水 担忧 焦虑 出汗 surge 涌动 冲刺 突发 superb 一流的 synthesized 合成的 综合的 scenario 脚本 剧本 设想的情况 suffice 足以 够了 stock 股票 存货 股份 scalable 可缩放 可拓展 scattered 散乱的 smudge 污迹 变模糊 subordinate 次要的 下属 T – The best preparatin for tomorrow is doing yuor best today tentacle 触角 触手 tablet 手写板 平板电脑 药片 tradeoff 折衷 权衡 折中 交易 transition 过渡 tweak 扭 拽 拧 trpographical 排印的 图文的 U – Use is a second nature ubiquitous 普及 无所不在 undesirable 不可取 不受欢迎的 令人不快的 underlie 背后 底层 构成…的基础 隐含的 根本的 upstream 逆流的 上游的 unknowingly 无心的 不知不觉 V – Victory won&#39;t come to me unless i go to it validate 验证 证实 使生效 W – Where there is a will, there is a wayX – Xcellerate your effortsY – You can not change your past, but you can improve your futureZ – Zero in your target, and go for it","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/tags/计算机专业必备/"},{"name":"Computer","slug":"Computer","permalink":"http://blog.caoxl.com/tags/Computer/"}]},{"title":"PHP 系统结构","slug":"PHP-System-Structure","date":"2018-08-22T03:46:19.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/22/PHP-System-Structure/","link":"","permalink":"http://blog.caoxl.com/2018/08/22/PHP-System-Structure/","excerpt":"php从下到上是一个4层体系:","text":"php从下到上是一个4层体系: Zend引擎 ​ Zend整体用纯c实现,是php的内核部分,它将php代码翻译(词法、语法解 析等一系列编译过程)为可执行opcode的处理并实现相应的处理方法、实 现了基本的数据结构(如hashtable、oo)、内存分配及管理、提供了相应 的api方法供外部调用,是一切的核心,所有的外围功能均围绕zend实现。 Extensions 围绕着zend引擎,extensions通过组件式的方式提供各种基础服务,我们常 见的各种内置函数(如array系列)、标准库等都是通过extension来实现, 用户也可以根据需要实现自己的extension以达到功能扩展、性能优化等目 的(如贴吧正在使用的php中间层、富文本解析就是extension的典型应 用)。 Sapi Sapi全称是Server Application Programming Interface,也就是服务端应用编 程接口,sapi通过一系列钩子函数,使得php可以和外围交互数据,这是 php非常优雅和成功的一个设计,通过sapi成功的将php本身和上层应用解 耦隔离,php可以不再考虑如何针对不同应用进行兼容,而应用本身也可以 针对自己的特点实现不同的处理方式。 上层应用 这就是我们平时编写的php程序,通过不同的sapi方式得到各种各样的应用 模式,如通过webserver实现web应用、在命令行下以脚本方式运行等等。 构架思想 引擎(Zend)+组件(ext)的模式降低内部耦合，中间层(sapi)隔绝web server和php。 如果php是一辆车,那么车的框架就是php本身，Zend是车的引擎(发动机) ，Ext下面的各种组件就是车的轮子 Sapi可以看做是公路,车可以跑在不同类型的公路上。而一次php程序的执行就是汽车跑在公路上。 因此,我们需要：性能优异的引擎+合适的车轮+正确的跑道。 Apache和php的关系Apache对于php的解析,就是通过众多Module中的php Module来完成的。 把php最终集成到Apache系统中,还需要对Apache进行一些必要的设置。 这里,我们就以php的mod_php5 SAPI运行模式为例进行讲解,至于SAPI这个概念后面我们还会详细讲解。 假定我们安装的版本是Apache2 和 Php5,那么需要编辑Apache的主配置文 件http.conf,在其中加入下面的几行内容: Unix/Linux环境下: LoadModule php5_module modules/mod_php5.soAddType application/x-httpd-php .php 注:其中modules/mod_php5.so 是X系统环境下mod_php5.so文件的安装位置。 Windows环境下: LoadModule php5_module d:/php/php5apache2.dllAddType application/x-httpd-php .php 注:其中d:/php/php5apache2.dll 是在Windows环境下php5apache2.dll文件 的安装位置 这两项配置就是告诉Apache Server，以后收到的Url用户请求,凡是以php 作为后缀,就需要调用php5_module模块(mod_php5.so/ php5apache2.dll) 进行处理。 Apache请求处理循环详解Apache 请求处理循环的11个阶段都做了哪些事情呢? 1、Post-Read-Request阶段在正常请求处理流程中,这是模块可以插入钩子的第一个阶段。对于那些 想很早进入处理请求的模块来说,这个阶段可以被利用。 2、URI Translation阶段将请求的URL映射到本地文件系统。模块可以在这阶段插入钩子,执行自己的映射逻辑。 mod_alias就是利用这个阶段工作的。 3、Header Parsing阶段检查请求的头部。由 于模块可以在请求处理流程的任何一个点上执行检查请求头部的任务,因 此这个钩子很少被使用。mod_setenvif就是利用这个阶段工作的。 4、Access Control阶段根据配置文件检查是否 允许访问请求的资源。Apache的标准逻辑实现了允许和拒绝指令。 mod_authz_host就是利用这个阶段工作的。 5、Authentication阶段按照配置文件设定的策 略对用户进行认证,并设定用户名区域。模块可以在这阶段插入钩子,实 现一个认证方法。 6、Authorization阶段根据配置文件检查是否 允许认证过的用户执行请求的操作。模块可以在这阶段插入钩子,实现一 个用户权限管理的方法。 7、MIME Type Checking阶段根据请求资源的 MIME类型的相关规则,判定将要使用的内容处理函数。标准模块 mod_negotiation和mod_mime实现了这个钩子。 8、FixUp阶段这是一个通用的阶段,允许模块在内容生成器之前,运行任 何必要的处理流程。和Post_Read_Request类似,这是一个能够捕获任何信 息的钩子,也是最常使用的钩子。 9、Response阶段生成返回客户端的内容,负 责给客户端发送一个恰当的回复。这个阶段是整个处理流程的核心部分。 10、Logging阶段在回复已经发送给客户端之 后记录事务。模块可能修改或者替换Apache的标准日志记录。 11、CleanUp阶段清理本次请求事务处理完成 之后遗留的环境,比如文件、目录的处理或者Socket的关闭等等,这是 Apache一次请求处理的最后一个阶段。 LAMP 架构 Liunx: 属于操作系统的底层 apache服务器: 属于次服务器,沟通linux和PHP php: 属于服务端编程语言,通过php_module 模块 和apache关联 mysql和其他web服务: 属于应用服务,通过PHP的Extensions外 挂模 块和mysql关联","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"系统结构","slug":"系统结构","permalink":"http://blog.caoxl.com/tags/系统结构/"}]},{"title":"Linux查找命令或组件对应安装包的方法","slug":"Linux-find-cmd-install-package","date":"2018-08-22T03:24:17.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/22/Linux-find-cmd-install-package/","link":"","permalink":"http://blog.caoxl.com/2018/08/22/Linux-find-cmd-install-package/","excerpt":"当新搭建服务器或者维护不熟悉的服务器环境时，难免会碰到自己想用的命令或组件不存在的情况。如何通过包管理软件，方便地找到命令或组件对应的package进行安装？下面介绍三种方法。","text":"当新搭建服务器或者维护不熟悉的服务器环境时，难免会碰到自己想用的命令或组件不存在的情况。如何通过包管理软件，方便地找到命令或组件对应的package进行安装？下面介绍三种方法。 名称搜索一种直观方法就是，猜测命令或组件与安装包同名或包含，尝试搜索安装。比如，想安装redis数据库： 123456789101112131415161718192021222324252627[root@caoxl ~]# yum search redisLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfile===================================== N/S matched: redis =====================================collectd-redis.x86_64 : Redis plugin for collectdcollectd-write_redis.x86_64 : Redis output plugin for collectdhiredis.x86_64 : Minimalistic C client library for Redishiredis-devel.x86_64 : Development files for hiredisopensips-redis.x86_64 : Redis connectorpcp-pmda-redis.x86_64 : Performance Co-Pilot (PCP) metrics for Redisperl-Apache-Session-Redis.noarch : Redis driver for Apache::Session::NoSQLperl-Redis.noarch : Perl binding for Redis databasephp-nrk-Predis.noarch : PHP client library for Redisphp-pecl-redis.x86_64 : Extension for communicating with the Redis key-value storephp-phpiredis.x86_64 : Client extension for Redispython-redis.noarch : Python 2 interface to the Redis key-value storepython-trollius-redis.noarch : Redis client for the Python event loop PEP3156 for Trollius.python2-django-redis.noarch : Full featured redis cache backend for Djangoredis-trib.noarch : Cluster management script for Redisrubygem-redis.noarch : A Ruby client library for Redisrubygem-redis-doc.noarch : Documentation for rubygem-redissyslog-ng-redis.x86_64 : redis support for syslog-nguwsgi-logger-redis.x86_64 : uWSGI - redislog logger pluginuwsgi-router-redis.x86_64 : uWSGI - Plugin for Redis router supportredis.x86_64 : A persistent key-value database Name and summary matches only, use \"search all\" for everything. 搜索repo的相关命令： 12345# Centos 7yum search &#123;cmd&#125; # Ubuntu 14.04apt-cache search &#123;cmd&#125; command-not-found组件：自动提示命令command-not-found组件，支持在命令未找到时，提示对应的安装命令语句 command-not-found的安装方法： 1234567# Centos 7# yum search command-not-foundyum install -y PackageKit-command-not-found # Ubuntu 14.04(很可能已预装)# apt-cache search command-not-foundapt-get install command-not-found 文件反查安装包果在身边其他的环境中，已经安装了相应的命令或组件，可以通过已安装的文件反查对应的安装包，如查找ss命令： 1234[root@caoxl ~]# which ss/usr/sbin/ss[root@caoxl ~]# rpm -qf /usr/sbin/ssiproute-4.11.0-14.el7.x86_64 反查文件对应安装包的命令： 12345# Centos 7rpm -qf &#123;file&#125; # Ubuntu 14.04dpkg -S &#123;file&#125; 另外，ubuntu的apt-file命令也支持安装包包含的文件反查安装包，即使未安装该安装包。 当然，终极大招就是：互联网上搜索！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Linux sar 找出系统瓶颈的利器","slug":"Linux-Tool-sar","date":"2018-08-22T02:37:36.000Z","updated":"2019-08-22T03:50:16.000Z","comments":true,"path":"2018/08/22/Linux-Tool-sar/","link":"","permalink":"http://blog.caoxl.com/2018/08/22/Linux-Tool-sar/","excerpt":"sar是System Activity Reporter（系统活动情况报告）的缩写.","text":"sar是System Activity Reporter（系统活动情况报告）的缩写. sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。 sar是目前Linux上最为全面的系统性能分析工具之一，可以从14个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU效率、内存使用状况、进程活动及IPC有关的活动等，使用也是较为复杂。 sar是查看操作系统报告指标的各种工具中，最为普遍和方便的；它有两种用法: 追溯过去的统计数据（默认） 周期性的查看当前数据 追溯过去的统计数据默认情况下，sar从最近的0点0分开始显示数据；如果想继续查看一天前的报告；可以查看保存在/var/log/sa/下的sa日志； 使用sar工具查看: 12345678[root@caoxl sa]# sar -r -f /var/log/sa/sa28Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/28/2018 _x86_64_ (1 CPU)12:00:01 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty12:10:01 AM 140860 874576 86.13 75444 439424 663856 65.38 494472 256208 22412:20:01 AM 140564 874872 86.16 75636 439436 663856 65.38 498048 252836 24812:30:01 AM 140380 875056 86.18 75900 439432 663856 65.38 498112 253032 292... 查看CPU使用率 sar -u : 默认情况下显示的cpu使用率等信息就是sar -u； 12345678[root@caoxl sa]# sar 1 3Linux 3.10.0-862.9.1.el7.x86_64 (caoxl) 08/22/2018 _x86_64_ (1 CPU)10:48:33 AM CPU %user %nice %system %iowait %steal %idle10:48:34 AM all 0.00 0.00 0.00 0.00 0.00 100.0010:48:35 AM all 0.00 0.00 1.00 0.00 0.00 99.0010:48:36 AM all 1.00 0.00 0.00 0.00 0.00 99.00Average: all 0.33 0.00 0.33 0.00 0.00 99.33 可以看到这台机器使用了虚拟化技术，有相应的时间消耗； 各列的指标分别是: %user: 用户模式下消耗的CPU时间的比例 %nice: 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例 %system: 系统模式下消耗的CPU时间的比例 %iowait: CPU等待磁盘I/O导致空闲状态消耗的时间比例 %steal: 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例 $idle: CPU空闲时间比例 查看平均负载 sar -q: 查看平均负载 指定-q后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等；与其它命令相比，它能查看各项指标随时间变化的情况； 123456789101112131415[root@caoxl sa]# sar -q 1 10Linux 3.10.0-862.9.1.el7.x86_64 (caoxl) 08/22/2018 _x86_64_ (1 CPU)10:55:42 AM runq-sz plist-sz ldavg-1 ldavg-5 ldavg-15 blocked10:55:43 AM 0 185 0.01 0.02 0.05 010:55:44 AM 0 185 0.01 0.02 0.05 010:55:45 AM 0 185 0.01 0.02 0.05 010:55:46 AM 0 185 0.01 0.02 0.05 010:55:47 AM 0 185 0.01 0.02 0.05 010:55:48 AM 0 185 0.01 0.02 0.05 010:55:49 AM 1 185 0.01 0.02 0.05 010:55:50 AM 1 185 0.01 0.02 0.05 010:55:51 AM 1 185 0.01 0.02 0.05 010:55:52 AM 1 185 0.01 0.02 0.05 0Average: 0 185 0.01 0.02 0.05 0 runq-sz: 运行队列的长度（等待运行的进程数） plist-sz: 进程列表中进程（processes）和线程（threads）的数量 ldavg-1: 最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载 ldavg-15: 过去15分钟的系统平均负载 查看内存使用状况 sar -r： 指定-r之后，可查看物理内存使用状况: 12345678[root@caoxl sa]# sar -r 1 3Linux 3.10.0-862.9.1.el7.x86_64 (caoxl) 08/22/2018 _x86_64_ (1 CPU)11:02:52 AM kbmemfree kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty11:02:53 AM 107144 908292 89.45 69736 440984 894140 88.05 540500 254560 3611:02:54 AM 107144 908292 89.45 69736 440984 894140 88.05 540504 254560 3611:02:55 AM 107144 908292 89.45 69736 440984 894140 88.05 540508 254560 36Average: 107144 908292 89.45 69736 440984 894140 88.05 540504 254560 36 kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间. kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间. %memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比. kbbuffers和kbcached：这两个值就是free命令中的buffer和cache. kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap). %commit：这个值是kbcommit与内存总量(包括swap)的一个百分比. 查看页面交换发生状况 sar -W：查看页面交换发生状况 页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用这个命令来确认是否发生了大量的交换； 12345678[root@caoxl sa]# sar -W 1 3Linux 3.10.0-862.9.1.el7.x86_64 (caoxl) 08/22/2018 _x86_64_ (1 CPU)11:06:59 AM pswpin/s pswpout/s11:07:00 AM 0.00 0.0011:07:01 AM 0.00 0.0011:07:02 AM 0.00 0.00Average: 0.00 0.00 pswpin/s：每秒系统换入的交换页面（swap page）数量 pswpout/s：每秒系统换出的交换页面（swap page）数量 要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来: 怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看 怀疑内存存在瓶颈，可用 sar -B、sar -r 和 sar -W 等来查看 怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看 安装 有的linux系统下，默认可能没有安装这个包: 12345# CentOSyum install systat# Ubuntuapt-get install sysstat 安装完毕，将性能收集工具的开关打开： vi /etc/default/sysstat 1设置 ENABLED=\"true\" 启动这个工具来收集系统性能数据： /etc/init.d/sysstat start sar参数说明 -A: 汇总所有的报告 -a: 报告文件读写使用情况 -B: 报告附加的缓存的使用情况 -b: 报告缓存的使用情况 -c: 报告系统调用的使用情况 -d: 报告磁盘的使用情况 -g: 报告串口的使用情况 -h: 报告关于buffer使用的统计数据 -m: 报告IPC消息队列和信号量的使用情况 -n: 报告命名cache的使用情况 -p: 报告调页活动的使用情况 -q: 报告运行队列和交换队列的平均长度 -R: 报告进程的活动情况 -r: 报告没有使用的内存页面和硬盘块 -u: 报告CPU的利用率 -v: 报告进程、i节点、文件和锁表状态 -w: 报告系统交换活动状况 -y: 报告TTY设备活动状况","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"sar","slug":"sar","permalink":"http://blog.caoxl.com/tags/sar/"}]},{"title":"PHP 「安装日志」","slug":"PHP-Install-Dev-Log","date":"2018-08-21T07:29:39.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/21/PHP-Install-Dev-Log/","link":"","permalink":"http://blog.caoxl.com/2018/08/21/PHP-Install-Dev-Log/","excerpt":"总结一些和PHP有关的 「 安装 」","text":"总结一些和PHP有关的 「 安装 」 PECL PECL 的全称是 The PHP Extension Community Library ，是一个开放的并通过 PEAR(PHP Extension and Application Repository，PHP 扩展和应用仓库)打包格式来打包安装的 PHP扩展库仓库。通过 PEAR 的 Package Manager 的安装管理方式，可以对 PECL 模块进行下载和安装。 PHP Extension Community Library。提供了一个 PHP 所有已知扩展的下载和托管目录，比如 fileinfo, APC, Xdebug 等，采用 C 语言编写。 PEARPHP Extension and Application Repository。简单说有 3 个作用： 打包和安装 C 语言形式的 PECL 扩展 托管 PHP 代码形式的应用仓库、提供可复用的组件和依赖管理（虽然做的不好） 作为 PHP 编码规范（曾经的） PEAR vs PECL官方的 解释是：PECL 是通过 PEAR 打包系统来的 PHP 扩展库仓库。 PECL代表PHP扩展社区库，它具有用C编写的扩展，可以加载到PHP中以提供其他功能。您需要具有管理员权限，C编译器和相关工具链才能安装这些扩展。 PEAR是PHP扩展和应用程序库，它具有用PHP编写的库和代码。您只需下载，安装并包含在您的代码中即可。 安装 PEAR／PECL以在 macOS 下为例简述流程： 12345# Download pearcurl -O http://pear.php.net/go-pear.phar# Install pear/peclsudo php -d zend_detect_unicode=0 go-pear.phar 然后选择安装的路径，一般要手动设置安装路径（1）为 /usr/local/pear，和二进制文件路径（4）为 /usr/local/bin。设置好后输入all 或者按回车即可开始安装。 如果没出意外，就可以检测是否安装成功： 12pear versionpecl version 最后，如果要使用任何由 pear 下载的扩展或者应用，必须在 php.ini 中更新 include_path 路径： 1sudo vim /etc/php.ini 找到 Paths and Directories 在下面添加： 1include_path=\"/usr/local/pear/share/pear\" 这个 include_path 的值，是安装成功后提示你的路径。 然后重启：sudo apachectl restart。 通过 PECL 和 PEAR 安装 PHP 扩展最后就可以使用 pear 和 pecl 安装 PHP 扩展了。比如安装 vld 扩展： 1sudo pecl install vld-0.14.0 # https://pecl.php.net/package/vld 注意：这里的扩展名必须是在 pecl.php.net 上面能搜到的准确扩展名称及其版本号。 如果没报错，则在 php.ini 中引入刚刚编译成功的 vld.so，重启 apache 即可。 说明通过 pecl 或者 pear 安装 PHP 扩展的时候，必须确保 perl 或者 pear 和 PHP 的版本一致，否则安装不会成功。 ComposerComposer 是现代 PHP（&gt;5.3） 中一个优秀的包管理器，通常和 Packagist 一起工作，可以很方便地管理大量的 PHP 代码依赖。 Composer 与 PackagistComposer 中管理的依赖都写在 composer.json 中，而最终安装的时候，都是去 Packagist 下载。 Packagist 是一个官方的 Composer 兼容包仓库，但是并不是唯一的，比如国内还有一个 Packagist 全量镜像。Composer 获取软件包的地址，是可以修改的，比如替换默认源就可以： 1234# 全局composer config -g repo.packagist composer https://packagist.phpcomposer.com# 单个项目composer config repo.packagist composer https://packagist.phpcomposer.com Composer vs PEARPHP 有很多可供使用的库、框架和组件。通常你的项目都会使用到其中的若干项，这些就是项目的依赖。 对于现代 PHP 来说，主要由 Composer 管理 PHP 依赖，而在以前，则是 PEAR 来管理的。两者的主要区别有： Composer 更活跃和成熟，PEAR 则将被弃用。 Composer 更灵活，可以为单独某个项目管理依赖，也可全局安装，而 PEAR 只能全局安装。（好处是当多个项目共同使用同一个扩展包的同一个版本, 坏处是如果你需要使用不同版本的话，就会产生冲突） PEAR 需要扩展包有专属的结构，开发者在开发扩展包的时候要提前考虑为 PEAR 定制，否则后面将无法使用 PEAR，而 Composer 的使用规范对所有组件都是统一的。 通过 Composer + Packgist，能安装到的软包数量远远多于 PEAR。 在依赖管理方面，Composer 更专业。 PEAR 能安装 PECL 扩展，而 Composer 不能。这算是当前 PEAR 唯一比得过 Composer 的地方了，不过 Composer 目前又有一个不算特别成熟的替代方案：GitHub: FriendsOfPHP/pickle。 软件包管理器Linux使用软件包管理器比较方便，不仅可以安装 PHP，也可以安装 PHP 扩展。缺点就是版本默认较低。 yum/dnfCentOS 使用 yum 安装的 PHP 版本很低，需要先开启 EPCL 和 REMI 源。 12345wget http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpmwget http://rpms.famillecollet.com/enterprise/remi-release-7.rpmrpm -Uvh remi-release-7*.rpm epel-release-7*.rpmvim /etc/yum.repos.d/remi.repo 添加如下内容后保存退出： 12345678910111213141516[remi]name=Les RPM de remi pour Enterprise Linux 6 - $basearch#baseurl=http://rpms.famillecollet.com/enterprise/6/remi/$basearch/mirrorlist=http://rpms.famillecollet.com/enterprise/6/remi/mirrorenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-remi[remi-php56]name=Les RPM de remi de PHP 5.6 pour Enterprise Linux 6 - $basearch#baseurl=http://rpms.famillecollet.com/enterprise/6/php56/$basearch/mirrorlist=http://rpms.famillecollet.com/enterprise/6/php56/mirror# WARNING: If you enable this repository, you must also enable \"remi\"enabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-remi 然后就可以搜索指定的版本并安装了： 12yum search php | grep ^phpyum install php php-gd php-mysql php-mcrypt apt-get12345echo \"deb http://packages.dotdeb.org wheezy-php56 all\" &gt;&gt; /etc/apt/sources.list.d/dotdeb.listecho \"deb-src http://packages.dotdeb.org wheezy-php56 all\" &gt;&gt; /etc/apt/sources.list.d/dotdeb.listwget http://www.dotdeb.org/dotdeb.gpg -O- | apt-key add - apt-get updateapt-get install php5-cli php5-fpm # or whatever package you might need MacMac 默认是没有包管理器的，但是有解决方案，比如Homebrew 。 Homebrew12345brew search php# 安装需要的版本brew install php56brew install php72 Macports12345sudo port install php56sudo port install php72# Switch PHP Versionsudo port select --set php php72 源码安装源码安装可以定制自己的环境，也能在一定程度上提高性能，只是流程稍微繁琐（其实还好）。 源码安装 PHP官方有很全的指导手册，下面只以在 Linux 下安装 php（work with nginx） 场景示例过程： 1234567891011121314151617181920212223242526# 1. Download（http://www.php.net/downloads.php）wget http://cn2.php.net/distributions/php-5.6.29.tar.bz2bzip2 -d php-5.6.29.tar.bz2# 2. Compile and installcd php-5.6.29./configure --help./configure --enable-fpm --with-mysqlmakesudo make install# 3. Configuration files readycp php.ini-development /usr/local/php/php.inicp /usr/local/etc/php-fpm.conf.default /usr/local/etc/php-fpm.confcp sapi/fpm/php-fpm /usr/local/bin# 4. Necessary configsvim /usr/local/php/php.ini cgi.fix_pathinfo=0vim /usr/local/etc/php-fpm.conf user = www-data group = www-data # 4. start php-fpm/usr/local/bin/php-fpm 源码安装 PHP 扩展安装 PHP 扩展的前提： 已安装 PHP 本身 必要的基础依赖已经安装，比如 gcc／make 知道要安装的扩展的安装依赖（参考 PECL 上的说明） 源码安装官方扩展Linux 下源码安装 PHP 官方（内置）扩展基本流程如下： 123456789101112131415161718192021222324# 1. Basic requirementsyum install php-devel php-mysqlnd gcc libtool# 2. Extensions dependency# differ from ext to ext ...# 3. Have source code of current PHP versioncd /path/to/php-x.y.z# 4. Assume we install fileinfo extensioncd fileinfophpize./configure --enable-fileinfomakesudo make install# 5. Enable new in php.inicd `php-config --extension-dir` # to checkout if has fileinfo.sovim /path/to/php.ini ; Dynamic Extensions extension = fileinfo.so# 6. Restart php-fpmservice php5-fpm restart 源码安装第三方扩展其实和安装官方扩展差不多，不同之处只是第三方扩展的源码包没有在 PHP 官方源码包中，需要手动到 github 或者 pecl.php.net 等下载，后续的配置、编译和安装完全一样。 1234git clone https://github.com/mongodb/mongo-php-drivercd mongo-php-driver# Same with above 部分操作解释 phpize准备扩展程序的文件夹以进行补充。它允许您通过创建configure文件来执行后续命令，并且基本上使扩展的文件夹“认为”它是PHP本身。phpize事实上，后面的过程与从源代码安装PHP时所做的相同 - 仅在这种情况下，只需编译PHP片段并准备好与已编译和安装的PHP一起使用。 ./configure --enable-XXX配置编译环境。它准备了编译器制作XXX.so我们将要使用的文件所需的一切。enable-XXX即使我们在XXX文件夹中，该标志也是必要的，因为该文件夹实际上认为它是 PHP，我们需要帮助它实现这种错觉。这个命令告诉它：“好的，你是PHP的源代码。现在使用intl扩展编译和安装。“，实际上，它是唯一可以从此文件夹安装的部分。 make将源XXX.so文件编译成子文件夹，将文件放入您当前所在的modules文件夹中。 sudo make install 将此文件移动到当前PHP安装的extensions文件夹中。 phpize prepares the extension’s folder for compliation. It allows you to do the subsequent commands by creating a configure file, and basically making the extension’s folder “think” it’s PHP itself. The procedure after phpize is, in fact, identical to what you would do when installing PHP from source – only in this case, just a fragment of PHP is compiled and prepared for use with the already compiled and installed PHP. ./configure --enable-XXX configures the environment for compilation. It prepares everything the compiler will need to craft the XXX.so file which we’ll be using. The enable-XXX flag is necessary even though we’re in the XXXfolder because the folder, effectively, thinks it is PHP, and we need to help it live that illusion. This command tells it: “Ok, you’re PHP’s source code. Now compile and install with the intl extension.”, when in fact, it’s the only part that can be installed from this folder. make will compile the sources into XXX.so, placing the file into the very folder you’re currently in, under the modulessubfolder. sudo make install will move this file into the current PHP installation’s extensions folder. PHP 版本切换phpbrewGithub: phpbrew phpenvGitHub: phpenv。 php-versionGitHub：php-version。 php-osx.liip.ch官网：PHP 5.3 to 7.1 for OS X / macOS 10.6 to 10.12 as binary package。 123curl -s https://php-osx.liip.ch/install.sh | bash -s 7.3curl -s https://php-osx.liip.ch/install.sh | bash -s 7.2curl -s https://php-osx.liip.ch/install.sh | bash -s 5.6 其他pickle跨平台的 PHP 扩展安装工具，详见 GitHub。 1sudo pickle.phar install vld 懒人必备：Oneinstack使用很简单，阿里云有些 ECS 就是用这个搭建的环境。 按照 官网做就行了，问你安装什么你选择就是了，对于纯 PHP 项目来说一般只需要先安装基本的 LNMP 就行了。 12345678910111213141516# CentOSyum -y install wget screen curl python# Debianapt-get -y install wget screen curl python# 阿里云用户下载wget http://aliyun-oss.linuxeye.com/oneinstack-full.tar.gz# 包含源码，国内外均可下载wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz# 不包含源码，建议仅国外主机下载wget http://mirrors.linuxeye.com/oneinstack.tar.gztar xzf oneinstack-full.tar.gz# 如果需要修改目录(安装、数据存储、Nginx日志)，请修改options.conf文件cd oneinstack# 如果网路出现中断，可以执行命令`screen -r oneinstack`重新连接安装窗口screen -S oneinstack./install.sh # 注：请勿sh install.sh或者bash install.sh这样执行 以下是常用的脚本和文件： vhost.sh：创建虚拟主机 addons.sh：添加常用扩展。 version.txt：这里面保存的是 Oneinstack 安装下载时会寻找的版本，如果安装前想要手动指定某个软件包的版本，可以直接修改这个文件。 upgrade.sh：更新软件包，也可以用于切换 PHP 版本。 All-in-one 集成环境 Linux：Oneinstack macOS：自带 &amp;&amp; MAMPs Windows：WAMP or phpStudy FAQ 安装部分扩展时候编译成功安装到 php-config --extension-dir 时不能写入？ 必须像Dan Willis建议的那样禁用系统完整性保护。 重启你的电脑。 当屏幕变黑时按住 command+r 直到您启动恢复。您将看到OS X Utilities菜单。 下一个开放终端。然后输入以下命令：csrutil disable确保将其写下来以便记住它。 重启你的mac，让它正常启动。 再次打开终端并再次安装INTL：sudo pecl install intl它现在将完成安装。 参考 What are differences between PECL and PEAR? What is the difference between PEAR and Composer? [closed] Failed to write error when installing intl extension on Os x El Capitan Checking if PEAR works 和 PHP 相关的「安装」","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Install","slug":"Install","permalink":"http://blog.caoxl.com/tags/Install/"}]},{"title":"Redis 使用日志","slug":"Redis-use-log","date":"2018-08-20T07:06:31.000Z","updated":"2019-08-22T03:37:12.000Z","comments":true,"path":"2018/08/20/Redis-use-log/","link":"","permalink":"http://blog.caoxl.com/2018/08/20/Redis-use-log/","excerpt":"Redis 在开发、测试、正式环境使用日志，不定时更新。","text":"Redis 在开发、测试、正式环境使用日志，不定时更新。 说明：本文旨在梳理 Redis 这门技术的学习思路，实际使用必须 RTFM: Redis 命令参考 / 英文版 简介定义Redis（REmote Dictionary Server，远程字典服务器） 是一个开源、高性能、基于键值对的缓存与存储系统，允许其他应用以字典（KV）形式通过 TCP 读写字典中的内容。 Redis 的优点 更符合程序员思维 Redis 字典结构的存储方式和对多种键值数据类型的支持，使得开发者可以将程序中的数据直接映射到 Redis 中，因为数据在 Redis 的存储形式和在程序中的存储方式非常相似。 各种数据类型有丰富的操作 Redis 中每种数据结构都具有很多非常方便的接口，可以实现部分关系型数据库实现起来性能不高且较为繁琐的操作。 支持持久化的内存存储，快速可靠 Redis 的所有数据都存储在内存中，因此在性能上比其他基于硬盘的数据库高。此外，Redis 也会将内存中的数据异步地写入到硬盘中，同时不影响继续提供服务。 Redis 支持 AOF 和 RDB 两种持久化方式。 RDB 将数据库的快照（snapshot）以二进制的方式保存到磁盘中。AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的 https://redisbook.readthedocs.io/en/latest/internal/aof.html 应用广 Redis 是作为数据库开发的，但是由于其功能丰富，也被广泛应用到缓存、队列系统中。 使用简单 Redis 在各种数据类型上均提供了很直观的调用方式。 开源，代码量少可定制 Redis 源代码只有 3W+ 行，可以为不同的项目定制更适合的 Redis 版本。 轻量级 一个空 Redis 实例只会占用 1M 左右内存，因此不用担心启动多个 Redis 实例会占用额外的内存。 支持集群 支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。 Redis 的缺点 由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。 Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。 Redis 的主从复制采用全量复制，复制过程中主机会 fork 出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一次全量的数据复制，这对实际的系统运营造成了不小的麻烦。 Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 Redis 适用场景 典型数据库（可持久化） 缓存 Redis 可以为每个键设置 TTL，到期后自动删除，即实现了缓存的功能，和典型的 KV 型同内存缓存 Memcached 不相上下。 队列 如何掌握 Redis 最小必须知识？ WHY/WHAT：明白 Redis 的优缺点，以及适用场景。 HOW：理解 Redis 五种基本数据结构的工作原理及其正确使用，使用正确的数据结构处理特定的问题。 使用编程语言驱动并使用 Redis。 掌握 Redis 主要的管理调试技巧 redis-cli 通用命令说明：redis-cli 命令不区分大小写。 连接服务器：redis-cli -h 127.0.0.1 -p 6379 测试连通情况：redis-cli PING，如果返回 PONG 则已经连通。 输出字符串：ECHO hello 停止 Redis Server: redis-cli SHUTDOWNRedis 收到此命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后退出。 选择数据库：select n，其中 n 是数据库编号对 Redis 来说，一个数据库就是一个字典（根据 Redis 定义），对外都是从 0 开始的递增数字命名，默认 Redis 支持 16 个数据库，可以配置 databases 来修改。 获取当前数据库中符合指定规则的键名：KEYS * 判断一个键是否存在：exists key 删除指定 KEY：del key1 key2 key3 ...，返回删除的键的个数。del 指令不支持通配符，但是可以这样曲线救国： 12redis-cli KEYS \"user:*\" | xargs redis-cli DELredis-cli DEL `redis-cli KEYS \"user:*\"` 获得键值的数据类型：TYPE key 清空所有 KEY：flushall 清除所有值：flushdb Redis 五大数据结构说明： 每个命令都相对应于一种特定的数据结构，这样的机制在 Redis 关键字集很小的情况下具有相当的可管理性。 一个命令，尤其是字符串相关的，只有在给定了明确的数据类型后，才会有实际意义。 使用各种数据结构时需要考虑是：如何利用散列数据结构去组织数据，是查询变得更高效。 字符串/string字符串的值是标量。字符串适合存储对象和计数，也适合缓存数据。 1234567set users:caoxl \"&#123;name: caoxl, gender: sir&#125;\"strlen users:caoxlgetrange users:caoxl 1 5append users:caoxl \"balabala\" 一些字符串命令是专门为一些类型或值的结构而设计的，比如整型数值。如下： 12incr stats:page:aboutincrby ratings:video:12333 5 散列表/hash散列数据结构很像字符串，区别在于：hash 提供了一个额外的间接层：域（Field）。 1234567hset users:caoxl age 18hget users:caoxl agehmset users:caoxl age attr1 attr2 1024hmget users:caoxl age genderhgetall users:caoxlhkeys users:caoxlhdel users:caoxl age 列表/list简而言之，列表就是数组。对于一个给定的关键字，列表让你可以存储和处理一组值，并对列表中的值进行 CRUD 和其他操作。 列表维护了值的顺序，提供了基于索引的高效操作。理论上列表可以存放任意个值。 123lpush newusers caoxlltrim newusers 0 50lrange newusers 0 10 LTRIM Key start stop，删除指定范围外的值，时间复杂度 O(N)，N 是被删除的值的数量 这个例子中，由于先插入一个元素到列表开始（入栈）再进行列表调整，间接使得 ltrim 具有了常数性能，因为这种情况下 N 始终为 1。 集合/set集合常被用来存储只能唯一存在的值，并提供了许多的基于集合的操作，例如交集、并集。集合没有对值进行操作，但是提供了高效的基于值的操作。 举例，使用集合实现朋友白名单： 12345678910111213# 声明朋友集合sadd friends:cao cao_1 cao_2 cao_3 caoxlsadd friends:xl xl_1 xl_2 xl_3 caoxl# 检查 X 是不是 Y 的朋友sismember friends:cao xl_1 # (integer) 0sismember friends:xl cao_2 # (integer) 1 # 检查 N 个人是不是有共同的朋友sinter friends:cao friends:cj # 1) \"caoxl\"# 检查 N 个人是不是有共同的朋友 并把结果存在 friends:caoxl 集合中sinterstore friends:caoxl friends:cao friends:xl 有时候需要对值的属性进行标记和跟踪处理，但不能通过简单的复制操作完成，集合数据结构是解决此类问题的最好方法之一。 有序集合（Sorted Set）/zset序集合类似集合，主要区分是标记（score）。标记提供了排序（sorting）和秩划分（ranking） 有序集合默认是根据 Score 对各个元素进行升序的排列。 1234zadd friends:caoxl 60 caoxl_1 80 caoxl_2 100 caoxl_3zcount friends:caoxl 80 100 # (integer) 2zrank friends:caoxl caoxl_2 # 从低到高 获取 caoxl_2 在 friends_caoxl 中的 rank（秩）zrevrank friends:caoxl caoxl_2 # 从高到低 获取 caoxl_2 在 friends_caoxl 中的 rank（秩） 管理Redis客户端验证通过设置 requirepass，可以让 Redis 需要一个密码验证。验证也很简单，客户端只需要执行 auth password 就可以了。 requirepass 可以通过 config set 和修改 redis.conf 文件配置。 通过验证的客户端可以对 Redis 所有数据库执行任何命令，为了安全性，你可以设置关键字别名，比如把 config 命令设置为一个随机字符串： 123rename-command CONFIG 9336ebf25087d91c818ee6e9ec29f8c1 rename-command FLUSHALL 9dd4e461268c8034f5c8564e155c67a6rename-command FLUSHDB 415290769594460e2e485922904f345d 甚至，你可以将新名字设置为一个空字符串，从而禁掉某个命令。 数据库之间访问问题Redis 不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据要么全部都无权访问。 此外，多个数据库之间并非完全隔离的。比如 FLUSHALL 命令会清空该 Redis 实例中的所有数据。 因此，同一个 Redis 实例中不适合存储不同应用的数据，最好同一应用的不同环境也隔离开（保护生产数据），所有，应该一个应用使用一个 Redis 实例。 复制集/读写分离所谓的复制集，指的是当我们向某个 Redis 实例（master）进行写入时，可以通过 slaveof 配置其他 Redis 实例（slaves）能够通过 master 保持更新。 为了数据安全性，也为了性能，应该将 Redis 复制到不同的服务器，实现异地冗余的同时，也提供了读写分离，因为读请求会被发送到 slave 实例。虽然数据可能出现滞后，但是大多数情况下都选择这种折中措施。 备份备份 Redis 只需要把 Redis 的快照拷贝到任何地方即可。默认情况，Redis 的快照文件名是 dump.rdb。 为了减少 Master 实例的负载，在备份策略上通常把备份操作放到 slave，master 会停用快照功能以及单一附加文件（AOF）。 伸缩/集群Redis 也能实现高可用和伸缩，以及集群间负载均衡，将命令负载转移或分散到多个 Slave 实例就可以了。不过，具体的效果需要根据实际情况针对性实现。 其他功能字段超时Redis 允许我们标记一个关键字的使用期限，从而实现缓存的作用。存活时间单位为秒或者时间戳。 123456expire pages:about 30expireat pages:about 1504988562ttl pages:about # 查看某个字段还有多久过期setex pages:about '&lt;h1&gt;about us&lt;h1&gt; ...' # 设置字符串的同时设置过期时间 persist pages:about # 取消某个字段的超时设置 发布/订阅机制Redis 提供的发布订阅机制可以在多个客户端之间实现通讯。 消费者订阅某个 channel 1subscribe music programming 生产者发布内容到某个 channel 12publish music 'jjlin new album'publish programming 'learn redis now' 慢日志123config set slowlog-log-slower-than 0 # 记录所有命令slowlog getslowlog get 10 原理什么是键值对？有什么含义？键值对中键就是一切，所有的操作命令都是针对键的，不能根据值来操作。 值是关联到键的实际值，可以是任何东西。在大多数情况下，Redis 会把值看作一个字节序列，而不会关注他们实际上是什么。 Redis 由哪些部分组成？命令、关键字、值、数据结构以及与其一一绑定的操作方法。 Redis 持久化原理？默认情况，Redis 会根据已变更的关键字数量来进行判断，然后在磁盘里面创建数据库的快照（snapshot），如果 1000 个或者更多的关键字已经变更，Redis 会每隔 60 秒存储数据库，而如果9 个或者更少的关键字已变更，则每隔 15 分钟存储数据库。当然，这可以设置。 为什么 Redis 具有原子性？Redis 事务如何使用？因为 Redis 是单线程的。每个 Redis 命令都具有原子性，也包括那些一次处理多项事情的命令。当一个命令在执行时，没有其他命令会运行。 常见一次处理多项事情的命令有： incr：先执行 get 命令再执行 set 命令。 getset：先设置一个新的值，然后返回原始值。 setnx：先测试关键字是否存在，只有当关键字不存在时才设置值。 此外，对于使用多个命令，Redis 支持事务功能。事务功能保证： 事务中的命令将会按顺序执行。 事务中的命令将会如单个原子操作般执行，没有其他客户端命令会在中途被执行。 事务中的命令要么全部执行，要么全不执行。 12345multi # 开始事务hincrby groups:1percent balance - 90000000hincrby groups:99percent balance 90000000exec # 提交事务# discard # 放弃执行 原子性的 Redis 还会遇到并发问题吗？会，因为客户端是可以同时运行很多个的，当多个客户端操作同一个值的时候，就会出现并发问题。举例说明： 123456789101112def add(): redis.multi() current = redis.get('sth') redis.set('sth', sth + 1) redis.exec()# 不安全的操作add()# 安全的操作（增加 watch）redis.watch('sth')add() 调用 watch 监控关键字之后，如果另一个客户端改变了 sth 的值，那么事务就会失败，我们可以在一个循环内运行这些代码，直到其能正常工作。 客户端与 Redis 实例之间的往返次数是不是越少越好？不是，往往相反。SQL 的程序员通常会致力于让数据库的数据往返次数减至最小，这对于任何的数据库而言都是个好建议，但是考虑到我们是在处理比较简单的数据类型，有时候我们会频繁与 Redis 服务器交互，以实现我们的目的，通常情况下，在 Redis 高性能的前提下，这点性能损失可以忽略不计。 FAQ 如何停止 monitor？ Redis 官方目前没有提供接口来专门处理这个问题，ctrl + c 无效，只有先断开连接，或者使用其他非官方的连接工具。 Docker redis container 作为命令行客户端? 1docker run -it --link &#123;REDIS_CONTAINER_NAME&#125;:redis --rm redis redis-cli -h redis -p 6379 说明：生产环境尽量不要使用 monitor 命令，因为这是调试和开发工具。 laravel 中使用 Redis 集群作为队列数据库？ hash tags, RTFM:https://redis.io/topics/cluster-spec#keys-hash-tags. Redis 和 Memcached 的区别？ 内存使用：Memcahced 是全内存的缓存系统，Redis 既支持内存，也支持硬盘。此外，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。 性能上：Redis 是单线程模型，而 Memcached 支持多线程，所以在多核服务器上以及大量数据存储时 Memcached 的性能理论上更高。在单核服务器上存储小量（100K内）数据，Redis 性能比 Memcached 高。 功能上：Redis 远比 Memcached 丰富，Redis 3.0+ 之后，Memcached 几乎所有功能都成了 Redis 的子集。 集群：Redis 原生支持集群，Memcached 需要借助第三方集群工具来实现。 分布式：两者都支持，Memcached 只能由客户端实现，Redis 更偏向在服务器构建。 队列：Redis 的类型键可用来实现队列，并且支持阻塞式读取，可以很容易地实现一个高性能的优先级队列。 消息通讯：Redis 支持发布/订阅模式，Memcached 无此机制。 参考 library/redis - Docker Hub 阿里云Redis开发规范","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"Cache","slug":"Cache","permalink":"http://blog.caoxl.com/tags/Cache/"},{"name":"RTFM","slug":"RTFM","permalink":"http://blog.caoxl.com/tags/RTFM/"}]},{"title":"Memcached 使用日志","slug":"Memcached-use-log","date":"2018-08-20T07:06:21.000Z","updated":"2019-08-22T03:37:05.000Z","comments":true,"path":"2018/08/20/Memcached-use-log/","link":"","permalink":"http://blog.caoxl.com/2018/08/20/Memcached-use-log/","excerpt":"Memcached 在正式环境的安装+使用日志。","text":"Memcached 在正式环境的安装+使用日志。 memcached 服务器虚拟主机／CentOS 7 运行1234567891011121314151617# 安装配置yum update &amp;&amp; yum install -y memcached# SASL 支持yum install cyrus-sasl-devel cyrus-sasl-plain# 启动+服务自启memcached -d -p 11211 -u memcached -m 229 -c 1024 -P /var/run/memcached/memcached.pid -l 127.0.0.1systemctl start memcachedsystemctl enable memcached# 查看运行状态netstat -pluntmemstat --servers=\"127.0.0.1\"# 允许外网访问（慎用）firewall-cmd --add-port=11211/tcp --permanentfirewall-cmd --reload 除了通过命名指定 memcached 的启动参数外，最好的方式是将通过配置文件启动： 123456789vi /etc/sysconfig/memcached`PORT=\"11211\"USER=\"memcached\"MAXCONN=\"1024\"CACHESIZE=\"64\"OPTIONS=\"-l 127.0.0.1 -U 0\" ` 关于服务启动选项 -d 是启动一个守护进程 -m 是分配给Memcache使用的内存数量，单位是MB -u 是运行Memcache的用户 -l 是监听的服务器IP地址，可以有多个地址 -p 是设置Memcache监听的端口，最好是 1024 以上的端口 -c 是最大运行的并发连接数，默认是1024 -P 是设置保存 Memcache 的 pid 文件 Docker 容器运行1234docker run --name local-memcached -d -p 11211:11211 \\-e VIRTUAL_HOST=memcached.docker \\-h memcached.docker \\memcached memcached 客户端CLI 使用 memcachedtelnet1telnet 127.0.0.1 11211 终止 telnet： ctrl + ] quit\\r\\n netcat/nc1nc 127.0.0.1 11211 memcache-cli python 1234567pip install memcache-climemcache-cli host1:port host2:port # 无参数默认 127.0.0.1:11211# macOSbrew upgrade pythonpip2 install --upgrade pippip2 install memcache-cli nodejs 1234567# npm npm install -g memcached-cli# yarn yarn global add memcached-climemcached-cli host:portmemcached-cli username:password@host:port PHP 使用 memcached安装 memcached 扩展完整流程源码安装 memcached 扩展并启用 SASL／igbinary／json 完整步骤： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 确保 `gcc -v` 大于 4.2+# 否则：yum install gcc+ gcc-c++# 确保 php 完整环境已安装# 否则：yum install php-devel php-common php-cli# 确保 SASL 相关环境包已正确安装# 否则：yum install cyrus-sasl-plain cyrus-sasl cyrus-sasl-devel cyrus-sasl-lib# 确保 libmemcached 已安装# rpm -qa | grep libmemcached# 否则下载编译安装wget https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gztar zxf libmemcached-1.0.18.tar.gzcd libmemcached-1.0.18./configure --prefix=/usr/local/libmemcached --enable-saslmake &amp;&amp; make install# 安装 igbinary 扩展# yum install -y php-pecl-igbinarywget https://github.com/igbinary/igbinary/releases/download/2.0.5/igbinary-2.0.5.tgztar -xzvf igbinary-2.0.5.tgzcd igbinary-2.0.5phpize./configuremake &amp;&amp; make install` iniextension=igbinary.so`# 安装 memcachedyum install zlib-develwget http://pecl.php.net/get/memcached-3.0.4.tgztar zxf memcached-3.0.4.tgzcd memcached-3.0.4phpize # 如果有多套 PHP 环境则需要使用各自的绝对路径./configure --with-libmemcached-dir=/usr/local/libmemcached --enable-memcached-sasl --enable-memcached-json --enable-memcached-json --enable-memcached-igbinarymake &amp;&amp; make installcp modules/memcached.so /path/to/php_extensions/no-debug-non-zts-XXXXXX/# 编辑 /path/to/php.ini` iniextension=memcached.somemcached.use_sasl = 1`# 重启 php-fpmservice php-fpm restart 代码示例12345678910111213$connect= new Memcached; //声明一个新的memcached链接$connect-&gt;setOption(Memcached::OPT_COMPRESSION, false); //关闭压缩功能$connect-&gt;setOption(Memcached::OPT_BINARY_PROTOCOL, true);//使用binary二进制协议$connect-&gt;setOption(Memcached::OPT_TCP_NODELAY, true); //重要，php memcached有个bug，当get的值不存在，有固定40ms延迟，开启这个参数，可以避免这个bug$connect-&gt;addServer('xxxxxxxx.m.yyyyyyyy.ocs.aliyuncs.com', 11211);//添加OCS实例地址及端口号$connect-&gt;setSaslAuthData('xxxxxxxx', 'bbbbbbbb');//设置OCS帐号密码进行鉴权，如已开启免密码功能，则无需此步骤$user = array( \"name\" =&gt; \"ocs\", \"age\" =&gt; 1, \"sex\" =&gt; \"male\"); //声明一组数组 $expire = 60; //设置过期时间$connect-&gt;set('your_name',$user,$expire); FAQPHP addServer() “成功”后 getStats() 返回 false 检查 memcached 安装配置是否正确 检查是否 SASL 连接配置是否正确。 附录：memcached 命令memcached Cheat Sheet。 参考 Docker Hub-Memcached How To Install and Secure Memcached on CentOS 7 memcachecli &amp;&amp; memcached-cli 阿里云文档-PHP: memcached libmemcached-memcached 依赖 memcache及其telnet命令使用详解","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Cache","slug":"Cache","permalink":"http://blog.caoxl.com/tags/Cache/"},{"name":"Memcached","slug":"Memcached","permalink":"http://blog.caoxl.com/tags/Memcached/"}]},{"title":"Linux pstack 跟踪进程栈","slug":"Linux-Tool-pstack","date":"2018-08-20T02:09:34.000Z","updated":"2019-08-22T03:50:06.000Z","comments":true,"path":"2018/08/20/Linux-Tool-pstack/","link":"","permalink":"http://blog.caoxl.com/2018/08/20/Linux-Tool-pstack/","excerpt":"此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID","text":"此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID 应用场景这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方 示例: 查看bash程序进程栈1234567891011[root@caoxl ~]# ps -ef | grep bashroot 31039 31037 0 09:42 pts/0 00:00:00 -bashroot 31229 31039 0 10:11 pts/0 00:00:00 grep --color=auto bash[root@caoxl ~]# pstack 31039#0 0x00007fe8aa1e817c in waitpid () from /usr/lib64/libc.so.6#1 0x0000000000440b24 in waitchld.isra.10 ()#2 0x0000000000441ddc in wait_for ()#3 0x0000000000433aae in execute_command_internal ()#4 0x0000000000433cce in execute_command ()#5 0x000000000041e305 in reader_loop ()#6 0x000000000041c96e in main () 安装pstack1234yum install gdb // 只要安装gdb,就会把pstack也一并安装成功[root@caoxl ~]# which pstack/usr/bin/pstack 参考 pstack 跟踪进程栈","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"pstack","slug":"pstack","permalink":"http://blog.caoxl.com/tags/pstack/"}]},{"title":"Linux lsof 一切皆文件","slug":"Linux-Tool-lsof","date":"2018-08-20T01:25:33.000Z","updated":"2019-08-22T03:50:02.000Z","comments":true,"path":"2018/08/20/Linux-Tool-lsof/","link":"","permalink":"http://blog.caoxl.com/2018/08/20/Linux-Tool-lsof/","excerpt":"lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。","text":"lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。 lsof打开的文件可以是： 普通文件 目录 网络文件系统的文件 字符或设备文件 (函数)共享库 管道, 命名管道 符号链接 网络文件(例如: NFS file、网络socket、unix域名socket) 还有其他类型的文件,等等 命令参数 -a: 列出打开文件存在的进程 -c&lt;进程号&gt;: 列出指定进程所打开的文件 -g: 列出GID号进程详情 -d&lt;文件号&gt;: 列出占用该文件的进程 +d&lt;目录&gt;: 列出目录下被打开的文件 +D&lt;目录&gt;: 递归列出目录下被打开的文件 -n&lt;目录&gt;: 列出使用NFS的文件 -i&lt;条件&gt;: 列出符合条件的进程 (4、6、协议、:端口、@ip) -p&lt;进程号&gt;: 列出指定进程号所打开的文件 -u: 列出UID号进程详情 -h: 显示帮助信息 -v: 显示版本信息 使用实例实例1：无任何参数1234567891011[root@caoxl ~]# lsof | moreCOMMAND PID TID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsystemd 1 root cwd DIR 253,1 4096 2 /systemd 1 root rtd DIR 253,1 4096 2 /systemd 1 root txt REG 253,1 1612152 1053843 /usr/lib/systemd/systemdsystemd 1 root mem REG 253,1 20112 1050279 /usr/lib64/libuuid.so.1.3.0systemd 1 root mem REG 253,1 261456 1067233 /usr/lib64/libblkid.so.1.1.0... 说明: lsof输出各列信息的意义如下： COMMAND：进程的名称 PID：进程标识符 PPID：父进程标识符（需要指定-R参数） USER：进程所有者 PGID：进程所属组 FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等: 12345678910111213141516171819202122232425262728293031323334（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序（3）lnn：library references (AIX);（4）er：FD information error (see NAME column);（5）jld：jail directory (FreeBSD);（6）ltx：shared library text (code and data);（7）mxx ：hex memory-mapped type number xx.（8）m86：DOS Merge mapped file;（9）mem：memory-mapped file;（10）mmap：memory-mapped device;（11）pd：parent directory;（12）rtd：root directory;（13）tr：kernel trace file (OpenBSD);（14）v86 VP/ix mapped file;（15）0：表示标准输入（16）1：表示标准输出（17）2：表示标准错误一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等（1）u：表示该文件被打开并处于读取/写入模式（2）r：表示该文件被打开并处于只读模式（3）w：表示该文件被打开并处于（4）空格：表示该文件的状态模式为unknow，且没有锁定（5）-：表示该文件的状态模式为unknow，且被锁定同时在文件状态模式后面，还跟着相关的锁（1）N：for a Solaris NFS lock of unknown type;（2）r：for read lock on part of the file;（3）R：for a read lock on the entire file;（4）w：for a write lock on part of the file;（文件的部分写锁）（5）W：for a write lock on the entire file;（整个文件的写锁）（6）u：for a read and write lock of any length;（7）U：for a lock of unknown type;（8）x：for an SCO OpenServer Xenix lock on part of the file;（9）X：for an SCO OpenServer Xenix lock on the entire file;（10）space：if there is no lock. TYPE：文件类型，如DIR、REG等，常见的文件类型: 123456（1）DIR：表示目录（2）CHR：表示字符类型（3）BLK：块设备类型（4）UNIX： UNIX 域套接字（5）FIFO：先进先出 (FIFO) 队列（6）IPv4：网际协议 (IP) 套接字 DEVICE：指定磁盘的名称 SIZE：文件的大小 NODE：索引节点（文件在磁盘上的标识） NAME：打开文件的确切名称 实例2：查找某个文件相关的进程1234[root@caoxl ~]# lsof /bin/bashCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld_sa 777 root txt REG 253,1 964544 1055537 /usr/bin/bashbash 31039 root txt REG 253,1 964544 1055537 /usr/bin/bash 实例3：列出某个用户打开的文件信息12[root@caoxl ~]# lsof -u root-u 选项,u是user的缩写 实例4：列出某个程序进程所打开的文件信息12345678[root@caoxl ~]# lsof -c mysqlCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld_sa 777 root cwd DIR 253,1 4096 1445566 /usr/local/mysqlmysqld_sa 777 root rtd DIR 253,1 4096 2 /mysqld_sa 777 root txt REG 253,1 964544 1055537 /usr/bin/bashmysqld_sa 777 root mem REG 253,1 62184 1053860 /usr/lib64/libnss_files-2.17.somysqld_sa 777 root mem REG 253,1 106070960 1050452 /usr/lib/locale/locale-archive... -c 选项将会列出所有以mysql这个进程开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符； 实例5：列出某个用户以及某个进程所打开的文件信息1234567[root@caoxl ~]# lsof -u git -c mysqlCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld_sa 777 root cwd DIR 253,1 4096 1445566 /usr/local/mysqlmysqld_sa 777 root rtd DIR 253,1 4096 2 /mysqld_sa 777 root txt REG 253,1 964544 1055537 /usr/bin/bashmysqld_sa 777 root mem REG 253,1 62184 1053860 /usr/lib64/libnss_files-2.17.so... 实例6：通过某个进程号显示该进程打开的文件1234567[root@caoxl ~]# lsof -p 777COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld_sa 777 root cwd DIR 253,1 4096 1445566 /usr/local/mysqlmysqld_sa 777 root rtd DIR 253,1 4096 2 /mysqld_sa 777 root txt REG 253,1 964544 1055537 /usr/bin/bashmysqld_sa 777 root mem REG 253,1 62184 1053860 /usr/lib64/libnss_files-2.17.so... 实例7：列出所有的网络连接1234567[root@caoxl ~]# lsof -iCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEntpd 468 ntp 16u IPv4 12395 0t0 UDP *:ntp ntpd 468 ntp 17u IPv6 12408 0t0 UDP *:ntp ntpd 468 ntp 18u IPv4 12610 0t0 UDP localhost:ntp ntpd 468 ntp 20u IPv4 15043 0t0 UDP caoxl:ntp ... 实例8：列出所有tcp 网络连接信息12345678[root@caoxl ~]# lsof -i tcpCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 1358 mysql 11u IPv4 15262 0t0 TCP *:mysql (LISTEN)AliYunDun 1366 root 18u IPv4 234684 0t0 TCP caoxl:49352-&gt;106.11.248.51:http (ESTABLISHED)python 1448 root 4u IPv6 15329 0t0 TCP *:smc-https (LISTEN)python 1448 root 10u IPv6 661910 0t0 TCP caoxl:smc-https-&gt;61.242.42.166:15810 (ESTABLISHED)python 1448 root 11u IPv4 661911 0t0 TCP caoxl:39612-&gt;th-in-f188.1e100.net:hpvroom (ESTABLISHED)... 实例9：列出谁在使用某个端口123[root@caoxl ~]# lsof -i :3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 1358 mysql 11u IPv4 15262 0t0 TCP *:mysql (LISTEN) 实例10：列出某个用户的所有活跃的网络端口12345678910111213141516[root@caoxl ~]# lsof -a -u root -iCOMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEAliYunDun 1366 root 18u IPv4 234684 0t0 TCP caoxl:49352-&gt;106.11.248.51:http (ESTABLISHED)python 1448 root 4u IPv6 15329 0t0 TCP *:smc-https (LISTEN)python 1448 root 6u IPv6 15330 0t0 UDP *:smc-https python 1448 root 9u IPv4 15332 0t0 UDP *:49276 python 1448 root 10u IPv6 662052 0t0 TCP caoxl:smc-https-&gt;61.242.42.166:15379 (ESTABLISHED)python 1448 root 11u IPv4 662053 0t0 TCP caoxl:36753-&gt;th-in-f188.1e100.net:hpvroom (ESTABLISHED)sshd 1476 root 3u IPv4 15908 0t0 TCP *:ssh (LISTEN)java 25899 root 49u IPv4 555565 0t0 TCP *:webcache (LISTEN)java 25899 root 54u IPv4 555569 0t0 TCP *:8009 (LISTEN)java 25899 root 71u IPv4 555583 0t0 TCP localhost:mxi (LISTEN)php-fpm 26119 root 7u IPv4 557416 0t0 TCP localhost:cslistener (LISTEN)nginx 26512 root 8u IPv4 561908 0t0 TCP *:http (LISTEN)nginx 26512 root 9u IPv4 561909 0t0 TCP *:https (LISTEN)sshd 31037 root 3u IPv4 651391 0t0 TCP caoxl:ssh-&gt;61.140.74.12:d2k-datamover1 (ESTABLISHED) 实例11：根据文件描述列出对应的文件信息1lsof -d description(like 2) 示例: 12345[root@caoxl ~]# lsof -d 2 | grep systemdsystemd 1 root 2u CHR 1,3 0t0 5078 /dev/nullsystemd-j 322 root 2w CHR 1,3 0t0 5078 /dev/nullsystemd-u 354 root 2u unix 0xffff8d25f6a74c00 0t0 10945 socketsystemd-l 470 root 2u unix 0xffff8d25faf60400 0t0 12201 socket 说明： 0表示标准输入，1表示标准输出，2表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始 实例12：列出被进程号为1358的进程所打开的所有IPV4 network files123[root@caoxl ~]# lsof -i 4 -a -p 1358COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 1358 mysql 11u IPv4 15262 0t0 TCP *:mysql (LISTEN) 实例13：列出目前连接主机caoxl上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行123456[root@caoxl ~]# lsof -i @caoxl:20,21,80 -r 3============================...","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"lsof","slug":"lsof","permalink":"http://blog.caoxl.com/tags/lsof/"}]},{"title":"Linux ps 进程查看器","slug":"Linux-Tool-ps","date":"2018-08-17T09:46:55.000Z","updated":"2019-08-22T03:49:53.000Z","comments":true,"path":"2018/08/17/Linux-Tool-ps/","link":"","permalink":"http://blog.caoxl.com/2018/08/17/Linux-Tool-ps/","excerpt":"已经有Linux cmd分类, 为何要新开一个Linux tool分类呢? 因为学习理论是第一位, 但是实际操作更重要, 这个分类将讲Linux下一些工具命令","text":"已经有Linux cmd分类, 为何要新开一个Linux tool分类呢? 因为学习理论是第一位, 但是实际操作更重要, 这个分类将讲Linux下一些工具命令 Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。 要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。 ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 [top linux下的任务管理器] 工具。 Linux上进程有5种状态: 运行: (正在运行或在运行队列中等待) 中断: (休眠中, 受阻, 在等待某个条件的形成或接受到信号) 不可中断: (收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 僵死: (进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) *停止: (进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行) ps工具标识进程的5种状态码: R 运行 runnable (on run queue) S 中断 sleeping D 不可中断 uninterruptible sleep (usually IO) Z 僵死 a defunct (”zombie”) process T 停止 traced or stopped 命令参数 a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 -N 反向选择 -e 等于“-A” e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 r 显示当前终端的进程 T 显示当前终端的所有程序 u 指定用户的所有进程 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 -C&lt;命令&gt; 列出指定命令的状况 -C&lt;命令&gt; 列出指定命令的状况 –width&lt;字符数&gt; 每页显示的字符数 –help 显示帮助信息 –version 显示版本显示 输出列的含义 F - 代表这个程序的旗标 (flag)， 4 代表使用者为 super user S - 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍 UID - 程序被该 UID 所拥有 PID - 进程的ID PPID - 则是其上级父程序的ID C - CPU 使用的资源百分比 PRI - 这个是 Priority (优先执行序) 的缩写，详细后面介绍 NI - 这个是 Nice 值，在下一小节我们会持续介绍 ADDR - 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“ SZ - 使用掉的内存大小 WCHAN - 目前这个程序是否正在运作当中，若为 - 表示正在运作 TTY - 登入者的终端机位置 TIME - 使用掉的 CPU 时间。 CMD - 所下达的指令为何 使用实例实例1：显示所有进程信息1234567891011[root@caoxl ~]# ps -A PID TTY TIME CMD 1 ? 00:00:11 systemd 2 ? 00:00:00 kthreadd 3 ? 00:00:04 ksoftirqd/0 5 ? 00:00:00 kworker/0:0H 6 ? 00:00:00 kworker/u2:0 7 ? 00:00:00 migration/0 8 ? 00:00:00 rcu_bh 9 ? 00:00:45 rcu_sched 10 ? 00:00:00 lru-add-drain 实例2：显示指定用户信息1234567891011[root@caoxl ~]# ps -u root PID TTY TIME CMD 1 ? 00:00:11 systemd 2 ? 00:00:00 kthreadd 3 ? 00:00:04 ksoftirqd/0 5 ? 00:00:00 kworker/0:0H 6 ? 00:00:00 kworker/u2:0 7 ? 00:00:00 migration/0 8 ? 00:00:00 rcu_bh 9 ? 00:00:45 rcu_sched 10 ? 00:00:00 lru-add-drain 实例3：显示所有进程信息，连同命令行1234567891011[root@caoxl ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Aug03 ? 00:00:11 /usr/lib/systemd/systemd --switched-root --sysroot 2 0 0 Aug03 ? 00:00:00 [kthreadd]root 3 2 0 Aug03 ? 00:00:04 [ksoftirqd/0]root 5 2 0 Aug03 ? 00:00:00 [kworker/0:0H]root 6 2 0 Aug03 ? 00:00:00 [kworker/u2:0]root 7 2 0 Aug03 ? 00:00:00 [migration/0]root 8 2 0 Aug03 ? 00:00:00 [rcu_bh]root 9 2 0 Aug03 ? 00:00:45 [rcu_sched]root 10 2 0 Aug03 ? 00:00:00 [lru-add-drain] 实例4： ps 与grep 组合使用，查找特定进程12345[root@caoxl ~]# ps -ef | grep sshroot 1476 1 0 Aug03 ? 00:00:00 /usr/sbin/sshd -Droot 25806 1476 0 10:10 ? 00:00:00 sshd: root@pts/0root 26877 1476 0 17:09 ? 00:00:00 sshd: root@pts/1root 27031 25808 0 18:03 pts/0 00:00:00 grep --color=auto ssh 实例5：将与这次登入的 PID 与相关信息列示出来12345[root@caoxl ~]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 25808 25806 0 80 0 - 28892 do_wai pts/0 00:00:00 bash0 S 0 25899 1 0 80 0 - 581002 futex_ pts/0 00:00:28 java0 R 0 27032 25808 0 80 0 - 38300 - pts/0 00:00:00 ps 实例6：列出目前所有的正在内存中的程序1234567891011[root@caoxl ~]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.3 43392 3388 ? Ss Aug03 0:11 /usr/lib/systemd/systemd --swroot 2 0.0 0.0 0 0 ? S Aug03 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S Aug03 0:04 [ksoftirqd/0]root 5 0.0 0.0 0 0 ? S&lt; Aug03 0:00 [kworker/0:0H]root 6 0.0 0.0 0 0 ? S Aug03 0:00 [kworker/u2:0]root 7 0.0 0.0 0 0 ? S Aug03 0:00 [migration/0]root 8 0.0 0.0 0 0 ? S Aug03 0:00 [rcu_bh]root 9 0.0 0.0 0 0 ? R Aug03 0:45 [rcu_sched]root 10 0.0 0.0 0 0 ? S&lt; Aug03 0:00 [lru-add-drain]","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"ps","slug":"ps","permalink":"http://blog.caoxl.com/tags/ps/"}]},{"title":"PHP异步的几个玩法","slug":"PHP-async-notes","date":"2018-08-17T09:16:30.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/17/PHP-async-notes/","link":"","permalink":"http://blog.caoxl.com/2018/08/17/PHP-async-notes/","excerpt":"没有异步的PHP是世界上最好的语言, 拥有异步的PHP是宇宙上最好的语言","text":"没有异步的PHP是世界上最好的语言, 拥有异步的PHP是宇宙上最好的语言 一. 先说说鸟哥文章中的几种玩法 一是通过渲染前端页面，使用js执行Ajax，这种方式现在还适用。只是受限于业务场景，因为只能在浏览器中调用，遇到接口请求就不行了。 二是通过popen()方法打开一个指向进程的管道，每个请求会多起一个进程。忽略进程来看最主要的原因是数据的传输特别不方便，使用场景有限。 三是使用CURL扩展，通过设置timeout超时参数，能实现离弦之箭的效果。不过这种方法会主动断开连接。被调用的服务如果有做连接检测，也会中断服务端脚本的执行。比如我们请求 微信的某个费时接口（20s），我们调用1s就断开连接，微信端是否会维持请求执行20S是不可控的。所以这种方法不推荐大家使用。 四方法与CURL类似，通过fsockopen创建socket连接访问远程服务，不循环获取请求结果。一样会有三中连接被断开的问题。 二. PHP发展了这么多年对异步支持方面都有哪些改进？ CURL扩展已支持毫秒配置，将 CURLOPT_TIMEOUT 改为 CURLOPT_TIMEOUT_MS即可生效（cURL 版本 &gt;= libcurl/7.21.0，老服务器要检查版本），但还是我前面说的需要服务端配合，不然接口的调用成功失败不可控。 CURL扩展已支持并发，我们能一次访问N个接口，执行时间取最长接口的时间。比如我们能一次访问 京东支付（1s），微信支付(1.2s)，支付宝(0.8s)不同服务的三个接口,总耗时才1.2s。详细用法 curl_multi_init 类似Node.js的异步IO框架Swoole，能很好的实现异步调用；不过Swoole理论上不能算PHP框架，他算是PHP功能的扩展。所以除非项目都用Swoole写，不然也是享受不到异步IO的福利。 对yield的支持，能实现调度器的功能，写单进程的服务时能大展拳脚，特别是实现协程，异步更不在话下。不过在多进程的web服务上没有太大的使用场景，看未来会不会有新的玩法吧。 当然还有很多新的特性，这里不再细说，总之PHP越是被黑越是能快速发展。 三. 最好的异步实现方法我们都知道PHP是支持多进程编程的，那完全可以新建一个进程去实现异步的调用。比如调用popen()方法，但是管道的方式传参异常麻烦，不过多进程这个方法是绝对可行的。如果要实现多进程的功能，毫无疑问我们会选择PHP官方提供的 pcntl 扩展,PHP默认会安装 pcntl 扩展， 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php// @caoxlclass Async&#123; static $instance; public static function getInstance() &#123; if (null == Async::$instance) Async::$instance = new Arrow(); return Async::$instance; &#125; public function run($rb) &#123; $pid = pcntl_fork(); if ($pid &gt; 0) &#123; pcntl_wait($status); &#125; elseif ($pid == 0) &#123; $cid = pcntl_fork(); if ($cid &gt; 0) &#123; exit(); &#125; elseif ($cid == 0) &#123; $rb(); &#125; else &#123; exit(); &#125; &#125; else &#123; exit(); &#125; &#125;&#125;$timeout = 30;Async::getInstance()-&gt;run(function () use ($timeout) &#123; echo 2; sleep($timeout);&#125;);echo 1; 代码说明: 首先Async类是个单例类，减少多次调用的开销。run()方法传递的是一个匿名函数，这样我们能非常方便的传递参数，并且保留上下文。 这个类最难的地方在于多进程的处理。因为我们要尽可能快的将数据返回给用户，所以主进程越快结束越好。但是我们又需要子进程来执行我们耗时的操作，执行完退出才行。如果不等子进程执行完就将父进程退出会出现什么结果呢？结果就是子进程会常驻内存变成僵死进程。那我们有什么办法让子进程执行完之后就自动结束呢？答案是很难……那么儿子进程这么不听话，孙子进程会不会听话一点呢？？答案是孙子进程执行结束后会被系统进程回收并销毁（还是孙子听话）。所以我在代码中使用了如下方法：当前请求进程fork出子进程，子进程fork出孙子进程，主进程和子进程都先行退出，最后由孙子进程来执行耗时操作，最后完美的解决了僵死进程问题。 当然这个方法的缺点就是调用的时候会多产生一个php-fpm的进程 为避免僵尸进程，当子进程结束后，手动杀死进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php// PHP Linux Cli 模式下利用 pcntl_fork 实现多进程处理// @caoxl// 进程数$processes = 5;// 所有任务就是是为了输出0到99中的所有数字// 这些数字将被分成5个块，代表5个进程，// 当输出的时候我们就可以看到所有进程的执行顺序$tasks = range(0, 99);$blocks = array();// 将任务按进程分块foreach ($tasks as $i) &#123; $blocks[($i % $processes)][] = $i;&#125;foreach ($blocks as $blockNum =&gt; $block) &#123; // 通过pcntl得到一个子进程的PID $pid = pcntl_fork(); if ($pid == -1) &#123; // 错误处理: 创建子进程失败时返回-1 die('cloud not fork'); &#125; elseif ($pid) &#123; // 父进程逻辑 // 等待子进程中断, 防止子进程成为僵尸进程 // WNOHANG为非阻塞进程，具体请查阅pcntl_wait PHP官方文档 pcntl_wait($status, WNOHANG); &#125; else &#123; // 子进程逻辑 foreach ($block as $i) &#123; echo \"I'm block &#123;$blockNum&#125;, I'm printing:&#123;$i&#125;\\n\"; sleep(1); &#125; // 为避免僵尸进程，当子进程结束后，手动杀死进程 if (function_exists('posix_kill')) &#123; posix_kill(getmypid(), SIGTERM); &#125; else &#123; system('kill -9'.getmypid()); &#125; exit(); &#125;&#125; 参考 PHP实现异步调用方法研究","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"异步","slug":"异步","permalink":"http://blog.caoxl.com/tags/异步/"}]},{"title":"MongoDB 可视化管理工具","slug":"MongoDB-Compass-DBA-must-know","date":"2018-08-16T07:17:15.000Z","updated":"2019-09-06T02:49:01.000Z","comments":true,"path":"2018/08/16/MongoDB-Compass-DBA-must-know/","link":"","permalink":"http://blog.caoxl.com/2018/08/16/MongoDB-Compass-DBA-must-know/","excerpt":"MongoDB Compass是MongoDB官网提供的一个集创建数据库、管理集合和文档、运行临时查询、评估和优化查询、性能图表、构建地理查询等功能为一体的MongoDB可视化管理工具。","text":"MongoDB Compass是MongoDB官网提供的一个集创建数据库、管理集合和文档、运行临时查询、评估和优化查询、性能图表、构建地理查询等功能为一体的MongoDB可视化管理工具。 MongoDB Compass 的安装MongoDB 下载 MongoDB Download Center 具体步骤详见: Windows 平台安装 MongoDB 这里就不多做赘述了~ MongoDB Compass 的使用1、创建MongoDB数据库连接 分别输入相应的Hostname和Port，如果没有用户认证，Authentication就默认为空。添加完后，点击CONNECT即可连接。 2、创建数据库连接MongDB数据库后，可以点击create database创建一个数据库。我这里创建了mongo_test数据库的同时也创建mongo_test集合。 3、集合管理插入文档在mongo_test集合的Documents页签下，点击INSERT DOCUMENT插入文档。 文档查看有两种方式一个是list（列表）方式，一个是table（表格）方式。 执行文档查询在FILTER行输入查询条件后，点击FIND，即可执行查询。 4、集合 5、解释执行计划在Explain Plan页签中，可以在FILTER中输入相关的查询语句后，点击EXPLAIN查看该语句解释执行计划。这个解释执行计划跟关系型数据库的SQL执行计划，有点类似。 6、索引在Indexes页签可以为集合创建索引及查看该集合下的索引详细信息。 附录 MongoDB 简介 RUNOOB.com MongoDB","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.caoxl.com/tags/MongoDB/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://blog.caoxl.com/tags/NoSQL/"}]},{"title":"基于Laravel MongoDB的部分实践","slug":"Laravel-test-MongoDB","date":"2018-08-16T03:26:02.000Z","updated":"2019-09-06T03:50:38.000Z","comments":true,"path":"2018/08/16/Laravel-test-MongoDB/","link":"","permalink":"http://blog.caoxl.com/2018/08/16/Laravel-test-MongoDB/","excerpt":"原文请看我的好朋友葉蕓榕的博客: laravel与MongoDB 的部分实践","text":"原文请看我的好朋友葉蕓榕的博客: laravel与MongoDB 的部分实践 MongoDB客户端安装 Windows 平台安装 MongoDB 12345678910111213141516171819202122232425PS C:\\Program Files\\MongoDB\\Server\\4.0\\bin&gt; ./mongoMongoDB shell version v4.0.1connecting to: mongodb://127.0.0.1:27017MongoDB server version: 4.0.1Welcome to the MongoDB shell.For interactive help, type \"help\".For more comprehensive documentation, see http://docs.mongodb.org/Questions? Try the support group http://groups.google.com/group/mongodb-userServer has startup warnings:2018-08-16T14:36:30.219+0800 I CONTROL [initandlisten]2018-08-16T14:36:30.219+0800 I CONTROL [initandlisten] ** WARNING: Access control is not enabled for the database.2018-08-16T14:36:30.220+0800 I CONTROL [initandlisten] ** Read and write access to data and configuration is unrestricted.2018-08-16T14:36:30.220+0800 I CONTROL [initandlisten]---Enable MongoDB's free cloud-based monitoring service, which will then receive and displaymetrics about your deployment (disk utilization, CPU, operation statistics, etc).The monitoring data will be available on a MongoDB website with a unique URL accessible to youand anyone you share the URL with. MongoDB may use this information to make productimprovements and to suggest MongoDB products and deployment options to you.To enable free monitoring, run the following command: db.enableFreeMonitoring()To permanently disable this reminder, run the following command: db.disableFreeMonitoring() MongoDB扩展安装这里做下补充, 在windows环境下开发需要安装mongodb的扩展 首先, php -m 查看是否已有mongodb的扩展 其次, php -v 查看环境的版本 12345$ php -vPHP 7.2.1 (cli) (built: Jan 4 2018 04:28:54) ( NTS MSVC15 (Visual C++ 2017) x86 )Copyright (c) 1997-2017 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2017 Zend Technologies 下载对应版本的mongodb扩展 https://pecl.php.net/package/mongodb/1.5.2/windows Laravel链接MongoDB 先在项目目录下运行如下代码 1composer require jenssegers/mongodb 在配置信息中添加如下信息: config.php/app.php 下的 providers 添加: 1Jenssegers\\Mongodb\\MongodbServiceProvider::class, config.php/app.php 下的 aliases 添加: 12'Mongo' =&gt; Jenssegers\\Mongodb\\MongodbServiceProvider::class,'MoEloquent' =&gt; Jenssegers\\Mongodb\\Eloquent\\Model::class, config.php/database.php 中的 connections 添加: 123456789'mongodb' =&gt; [ 'driver' =&gt; 'mongodb', 'host' =&gt; env('MONGO_HOST', 'localhost'), 'port' =&gt; env('MONGO_PORT', '27017'), 'database' =&gt; env('MONGO_DATABASE', 'test_mongo'), 'username' =&gt; env('MONGO_USERNAME', 'root'), 'password' =&gt; env('MONGO_PASSWORD', 'root'), 'strict' =&gt; false,], 在 .env中添加: 12345MONGO_HOST=127.0.0.1MONGO_PORT=27017MONGO_database=test_mongoMONGO_USERNAME=MONGO_PASSWORD= 添加测试路由 在 routes/web.php 中添加: 1Route::get('/test_mongo','TestMongoDBController@testMongo'); 添加测试Model app\\Models\\MongoDB.php 12345678910111213&lt;?phpnamespace App\\Models;# 已经在aliases添加即可不用下面这么# use Jenssegers\\Mongodb\\Eloquent\\Model as MoEloquent;use Illuminate\\Support\\Facades\\DB;class MongoDB extends MoEloquent&#123; protected $connection = \"mongodb\"; protected $collection = \"test_mongo\";&#125; 添加测试控制器 app\\Http\\Controllers\\TestMongoDBController 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\Http\\Controllers;use App\\Models\\MongoDB;class TestMongoDBController extends Controller&#123; public function testMongo() &#123; dd($this-&gt;testUpdate()); &#125; public function testAdd() &#123; $mongo = new MongoDB(); $mongo-&gt;name = 'test_name_1'; $mongo-&gt;info = 'test_info_1'; $res = $mongo-&gt;save(); return $res ? '插入成功' : '插入失败'; &#125; public function testDel() &#123; // 删除指定id $res = MongoDB::destroy('5b75205aa8ce413058001c42'); return $res ? '删除成功' : '删除失败'; &#125; public function testUpdate() &#123; $info = MongoDB::where('_id', '=', '5b752088a8ce413058001c43')-&gt;first(); $info-&gt;info = '更新后的信息'; $res = $info-&gt;save(); return $res ? '更新成功' : '更新失败'; &#125;&#125; 参考 Laravel MongoDB–jenssegers/laravel-mongodb","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.caoxl.com/tags/MongoDB/"}]},{"title":"「代码复用」 生成订单编号","slug":"CodeReuse-trade-number","date":"2018-08-15T07:34:37.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/15/CodeReuse-trade-number/","link":"","permalink":"http://blog.caoxl.com/2018/08/15/CodeReuse-trade-number/","excerpt":"这里生成的是仿造支付宝订单号","text":"这里生成的是仿造支付宝订单号 1234567891011121314151617181920212223242526&lt;?phpnamespace App\\Traits;class Tool&#123; // Generate inner system trade number // $uid: user id // $from: 01 =&gt; user; 02 =&gt; shop; 03 =&gt; staff; 04 =&gt; refund; ... // $domain: 00 =&gt; master // $suffix: 后缀 // @caoxl public static function tradeNo( $uid = 0, $from = '01', $domian = '00' ): string &#123; $domian = str_pad(($domian%42), 2, '0', STR_PAD_LEFT); $uid = str_pad(($uid%1024), 4, '0', STR_PAD_LEFT); $from = in_array($from, ['01', '02', '03']) ? $from : '00'; $suffix = mb_substr(microtime(), 2, 6); return date('YmdHis').$domian.$from.$uid.mt_rand(1000, 9999).$suffix; &#125;&#125; 例如: 20180815074921000101004317335415 20180815074608 - date(&#39;YmdHis) 00 - 处理后的master 01 - from user 0001 - 处理后的uid 4317 - mt_rand(1000, 9999) 335415 - mb_substr(microtime(), 2, 6) 说明: str_pad — 使用另一个字符串填充字符串为指定长度 123str_pad($input, $pad_length, pad_string, [pad_type])// 可选的 pad_type 参数的可能值为 STR_PAD_RIGHT，STR_PAD_LEFT 或 STR_PAD_BOTH。如果没有指定 pad_type，则假定它是 STR_PAD_RIGHT。","categories":[{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/categories/代码复用/"}],"tags":[{"name":"CodeReuse","slug":"CodeReuse","permalink":"http://blog.caoxl.com/tags/CodeReuse/"},{"name":"订单编号","slug":"订单编号","permalink":"http://blog.caoxl.com/tags/订单编号/"},{"name":"tradeNo","slug":"tradeNo","permalink":"http://blog.caoxl.com/tags/tradeNo/"}]},{"title":"Laravel 常见的验证规则","slug":"Laravel-validate-rules","date":"2018-08-15T03:46:31.000Z","updated":"2019-08-22T03:54:22.000Z","comments":true,"path":"2018/08/15/Laravel-validate-rules/","link":"","permalink":"http://blog.caoxl.com/2018/08/15/Laravel-validate-rules/","excerpt":"记录几个常见的验证规则","text":"记录几个常见的验证规则 我们将使用 Illuminate\\Http\\Request 对象提供的 validate 方法 。如果验证通过，你的代码就可以正常的运行。但是如果验证失败，就会抛出异常，并自动将对应的错误响应返回给用户。在典型的 HTTP 请求的情况下，会生成一个重定向响应，而对于 AJAX 请求则会发送 JSON 响应。 123456789101112131415161718192021222324252627use Illuminate\\Http\\Request;public function validate_rules(Request $request)&#123; $this-&gt;validate($request, [ 'username' =&gt; 'required|string', // 必须, 字符串 'password' =&gt; 'required|digits_between:6,18', // 验证的字段的长度必须在给定的 min 和 max 之间。 'passwd' =&gt; 'required|min:6|max:18', 'mobile' =&gt; 'required|numeric|regex:/^1[0-9]&#123;10&#125;$/', // 手机号码正则验证 'ip' =&gt; 'required|ip', // 验证的字段必须是 IP 地址。 'avatar' =&gt; 'required|dimensions:min_width=100,min_height=200', // 验证的文件必须是图片并且图片比例必须符合规则： 'file' =&gt; 'required|file', // 验证的字段必须是成功上传的文件。 'images' =&gt; 'required|image', // 验证的文件必须是一个图像（ jpeg、png、bmp、gif、或 svg ） 'photo' =&gt; 'required|mimes:jpeg,bmp,png', // 验证的文件必须具有与列出的其中一个扩展名相对应的 MIME 类型 'title' =&gt; 'bail|required|unique:posts|max:255', // 在第一次验证失败后停止 'email' =&gt; 'required|email', // 验证的字段必须符合 e-mail 地址格式。 'email_db' =&gt; 'required|connection.users,email_address', // 自定义数据库连接 'start_date' =&gt; 'required|date|after:tomorrow', // 验证的字段必须等于给定日期之后的值 'finish_date' =&gt; 'required|date|after:start_date', 'is_accepted' =&gt; 'required|accepted', // 验证的字段必须为 yes、 on、 1、或 true 'verify_code' =&gt; 'required|alpha', // 纯字母验证 'is_array' =&gt; 'required|array', // 数组验证 'is_bool' =&gt; 'required|boolean', // 验证的字段必须能够被转换为布尔值。可接受的参数为 true、false、1、0、\"1\" 以及 \"0\" 'order_status' =&gt;'required|in:1,2,3', // 验证的字段必须包含在给定的值列表中 ]); // 验证成功,继续逻辑&#125; 详细请看: https://laravel-china.org/docs/laravel/5.5/validation/1302#76a35d 别的验证写法12345678910111213protected function validate(array $params, array $rules)&#123; $validator = Validator::make($params, $rules); if ($validator-&gt;fails()) &#123; return [ 'err' =&gt; 400, 'msg' =&gt; $validator-&gt;errors()-&gt;first(), ]; &#125; return true;&#125; 1234567891011121314151617181920212223242526272829303132protected function verifyUserParams($params,$rules)&#123; if (!is_array($params) || empty($params) || !is_array($rules) || empty($rules)) &#123; return false; &#125; $validator = Validator::make($params, $rules); if ($validator-&gt;fails()) &#123; $this-&gt;_msg = $validator-&gt;errors()-&gt;first(); return false; &#125; return true;&#125;protected $_msg = 'request not allow';$rules = [ 'id' =&gt; 'required'];if (!$this-&gt;verifyUserParams($params,$rules) || $params['id'] &lt;= 0) &#123; return Tool::jsonResp([ 'err' =&gt; 2011, 'msg' =&gt; '参数错误', 'dat' =&gt; '' ]);&#125;","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"validate","slug":"validate","permalink":"http://blog.caoxl.com/tags/validate/"}]},{"title":"Laravel 版本选择","slug":"Laravel-version-selection","date":"2018-08-14T08:02:27.000Z","updated":"2019-08-22T03:52:59.000Z","comments":true,"path":"2018/08/14/Laravel-version-selection/","link":"","permalink":"http://blog.caoxl.com/2018/08/14/Laravel-version-selection/","excerpt":"原文地址: https://laravel-china.org/docs/laravel-specification/5.5/laravel-version-selection/512 转载到自己博客是为了加深记忆和方便查询","text":"原文地址: https://laravel-china.org/docs/laravel-specification/5.5/laravel-version-selection/512 转载到自己博客是为了加深记忆和方便查询 以下是 Laravel 的版本路线图： 版本 发布日期 版本类型 维护周期 Laravel 5.1 2015 年 6 月 LTS 长久支持 Bug 修复 2017 年 6 月份，安全修复 2018 年 6 月份 Laravel 5.2 2015 年 12 月 一般发行 提供 6 个月的 Bug 修复支持，一年的安全修复支持 Laravel 5.3 2016 年 8 月 一般发行 提供 6 个月的 Bug 修复支持，一年的安全修复支持 Laravel 5.4 2017 年 1 月 一般发行 提供 6 个月的 Bug 修复支持，一年的安全修复支持 Laravel 5.5 2017 年 8 月 LTS 长久支持 Bug 修复 2019 年 8 月份，安全修复 2020 年 8 月份 选择 Laravel 版本时，应该 优先考虑 LTS 版本，因为安全性和稳定性考虑，商业项目开发中 不应该 使用最新版本的 『Laravel 一般发行版』 。扩展阅读：如何选择 Laravel 框架版本。 什么是LTS长期支持 （英语：Long-term support，缩写：LTS）是一种软件的产品生命周期政策 请使用以下命令来创建指定版本的 Laravel 项目： 1composer create-project laravel/laravel project-name --prefer-dist \"5.5.*\"","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"}]},{"title":"Github Laravel 常用扩展包","slug":"Laravel-Github-Top-vendor","date":"2018-08-14T07:25:21.000Z","updated":"2019-08-22T03:53:20.000Z","comments":true,"path":"2018/08/14/Laravel-Github-Top-vendor/","link":"","permalink":"http://blog.caoxl.com/2018/08/14/Laravel-Github-Top-vendor/","excerpt":"不要重复造轮子, 是程序员之间的常识","text":"不要重复造轮子, 是程序员之间的常识 如何使用扩展包1composer require caoxl/caoxl # 引入需要的扩展包即可 以下推荐的扩展包均可在github查询具体文档以及使用. 1、laravel/tinker Laravel 框架自带的 REPL 交互控制台，允许你在 Laravel 运行环境中实时调试代码 2、intervention/image 图片处理扩展包，支持裁剪、水印等处理 3、barryvdh/laravel-ide-helper 扩展包能让你的 IDE ( PHPStorm, Sublime ) 实现自动补全、代码智能提示和代码跟踪等功能，大大提高你的开发效率。 4、maatwebsite/excel Excel 处理工具，基于 PhpSpreadsheet ，中文处理时会出现乱码，推荐使用 laravel-snappy 。 5、laravel/socialite 第三方登录相关的类库，对 OAuth 1 &amp; OAuth 2 协议进行了封装，支持自定义驱动，目前开源的 Socialite 驱动已经覆盖了大部分的第三方登录提供商。 6、barryvdh/laravel-cors 跨域资源共享的支持视频文档: https://laravel-china.org/courses/laravel-package/2026/solving-cross-domain-problems-cors-barryvdhlaravel-cors 7、tymon/jwt-auth JWT (JSON Web Token) 用户认证机制，支持 Laravel 和 Lumen 8、barryvdh/laravel-dompdf PDF 操作工具（基于 dompdf ） 9、laravel/passport Laravel 官方维护的 OAuth2 服务扩展包 —— 在 Laravel 中，实现基于传统表单的登陆和授权已经非常简单，但是如何满足 API 场景下的授权需求呢？在 API 场景里通常通过令牌来实现用户授权，而非维护请求之间的 Session 状态。在 Laravel 项目中使用 Passport 可以轻而易举地实现 API 授权认证，Passport 可以在几分钟之内为你的应用程序提供完整的 OAuth2 服务端实现。 10、dingo/api 支持 Laravel 和 Lumen ，功能包括 OAuth 服务、API 版本、Transformor 、节流等。 11、jenssegers/mongodb 让 Laravel 的 Eloquent 模型支持 MongoDB 12、davejamesmiller/laravel-breadcrumbs 可为你的 Laravel 项目快速定制拥有 Bootstrap 风格的面包屑导航。 13、laravel/dusk Laravel Dusk 提供了富有表现力、简单易用的浏览器自动化及测试 API 。默认情况下，Dusk 不需要在你的机器上安装 JDK 或者 Selenium 。而是需要使用单独的 Chrome 驱动 进行安装。当然，你也可以自由使用其他的兼容 Selenium 的驱动程序。 14、laracasts/generators Laracasts 出品的代码快速生成工具 15、spatie/laravel-permission 用户角色权限管理，功能包括模型单独权限、权限缓存优化等。 16、laravel/scout Laravel Scout 是一套基于驱动运行的全文搜索解决方案，目前第三方编写的驱动已经覆盖了主流的专业搜索软件。 17、simplesoftwareio/simple-qrcode PHP 二维码处理工具，基于 BaconQrCode 库。 18、torann/geoip 通过 IP 获取到对应的地理位置信息（GeoIP 数据库） 19、laravel/horizon Horizon 为 Laravel 官方出品的 Redis 队列提供了一个可以通过代码进行配置、并且非常漂亮的仪表盘，并且能够轻松监控队列的任务吞吐量、执行时间以及任务失败情况等关键指标。 20、overtrue/laravel-wechat 微信 SDK for Laravel 21、encore/laravel-admin laravel admin 22、三个 HTTP 缓存扩展包barryvdh/laravel-httpcachespatie/laravel-responsecachesilber/page-cache https://laravel-china.org/topics/10988/three-recommended-http-cache-extensions-for-laravel 23、barryvdh/laravel-debugbar 对 phpdebugbar 的封装，用于直观的显示调试及错误信息，提高开发效率，开发必备。 24、itsgoingd/clockwork 配合 Chrome 浏览器下同名插件的调试工具，与 laravel-debugbar 类似，不过侵入性更低。https://laravel-china.org/courses/laravel-package/1976/debugging-tool-under-chrome-itsgoingdclockwork 参考 以上是我自己挑选的几个我认为比较常用的.具体的可以自己查找以下推荐找到适合自己的. GitHub Laravel 扩展包 TOP 250","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Github","slug":"Github","permalink":"http://blog.caoxl.com/tags/Github/"}]},{"title":"PHP 基础知识 II","slug":"YouDao-notes","date":"2018-08-14T02:02:10.000Z","updated":"2019-08-22T03:17:04.000Z","comments":true,"path":"2018/08/14/YouDao-notes/","link":"","permalink":"http://blog.caoxl.com/2018/08/14/YouDao-notes/","excerpt":"整理原来写在有道云上的一些资料笔记, 做初次整理,后续再一一对号入座","text":"整理原来写在有道云上的一些资料笔记, 做初次整理,后续再一一对号入座 PHP杂的识PHP 的一些高效写法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041.用单引号代替双引号来包含字符串，这样做会更快一些。因为PHP会在双引号包围的字符串中搜寻变量，单引号则不会，注意：只有echo能这么做，它是一种可以把多个字符串当作参数的“函数”（译注：PHP手册中说echo是语言结构，不是真正的函数，故把函数加上了双引号）。2.如果能将类的方法定义成static，就尽量定义成static，它的速度会提升将近4倍。3.$row['id'] 的速度是$row[id]的7倍。4.echo 比 print 快，并且使用echo的多重参数（译注：指用逗号而不是句点）代替字符串连接，比如echo $str1,$str25.在执行for循环之前确定最大循环数，不要每循环一次都计算最大值，最好运用foreach代替6.注销那些不用的变量尤其是大数组，以便释放内存7.尽量避免使用__get，__set，__autoload8.require_once()代价昂贵9.include文件时尽量使用绝对路径，因为它避免了PHP去include_path里查找文件的速度，解析操作系统路径所需的时间会更少10.如果你想知道脚本开始执行（译注：即服务器端收到客户端请求）的时刻，使用$_SERVER['REQUEST_TIME']要好于time()11.函数代替正则表达式完成相同功能。12.str_replace函数比preg_replace函数快，但strtr函数的效率是str_replace函数的四倍13.如果一个字符串替换函数，可接受数组或字符作为参数，并且参数长度不太长，那么可以考虑额外写一段替换代码，使得每次传递参数是一个字符，而不是只写一行代码接受数组作为查询和替换的参数。14.使用选择分支语句（译注：即switch case）好于使用多个if，else if语句15.用@屏蔽错误消息的做法非常低效，极其低效16.打开apache的mod_deflate模块，可以提高网页的浏览速度17.数据库连接当使用完毕时应关掉，不要用长连接18.错误消息代价昂贵19.在方法中递增局部变量，速度是最快的。几乎与在函数中调用局部变量的速度相当20.递增一个全局变量要比递增一个局部变量慢2倍21.递增一个对象属性（如：$this-&gt;prop++）要比递增一个局部变量慢3倍。22.递增一个未预定义的局部变量要比递增一个预定义的局部变量慢9至10倍23.仅定义一个局部变量而没在函数中调用它，同样会减慢速度（其程度相当于递增一个局部变量）。PHP大概会检查看是否存在全局变量。24.方法调用看来与类中定义的方法的数量无关，因为我（在测试方法之前和之后都）添加了10个方法，但性能上没有变化25.派生类中的方法运行起来要快于在基类中定义的同样的方法26.调用带有一个参数的空函数，其花费的时间相当于执行7至8次的局部变量递增操作。类似的方法调用所花费的时间接近于15次的局部变量递增操作。27.Apache解析一个PHP脚本的时间要比解析一个静态HTML页面慢2至10倍。尽量多用静态HTML页面，少用脚本28.除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套PHP缓存机制通常可以提升25%至100%的性能，以免除编译开销。29.尽量做缓存，可使用memcached。memcached是一款高性能的内存对象缓存系统，可用来加速动态Web应用程序，减轻数据库负载。对运算码 (OP code)的缓存很有用，使得脚本不必为每个请求做重新编译。30.当操作字符串并需要检验其长度是否满足某种要求时，你想当然地会使用strlen()函数。此函数执行起来相当快，因为它不做任何计算，只返回在zval 结构（C的内置数据结构，用于存储PHP变量）中存储的已知字符串长度。但是，由于strlen()是函数，多多少少会有些慢，因为函数调用会经过诸多步骤，如字母小写化（译注：指函数名小写化，PHP不区分函数名大小写）、哈希查找，会跟随被调用的函数一起执行。在某些情况下，你可以使用isset() 技巧加速执行你的代码。（举例如下）if (strlen($foo) &lt; 5) &#123; echo “Foo is too short” &#125;（与下面的技巧做比较）if (!isset($foo&#123;5&#125;)) &#123; echo “Foo is too short” &#125; 调用isset()恰巧比strlen()快，因为与后者不同的是，isset()作为一种语言结构，意味着它的执行不需要函数查找和字母小写化。也就是说，实际上在检验字符串长度的顶层代码中你没有花太多开销。31.当执行变量$i的递增或递减时，$i++会比++$i慢一些。这种差异是PHP特有的，并不适用于其他语言，所以请不要修改你的C或Java代码并指望它们能立即变快，没用的。++$i更快是因为它只需要3条指令(opcodes)，$i++则需要4条指令。后置递增实际上会产生一个临时变量，这个临时变量随后被递增。而前置递增直接在原值上递增。这是最优化处理的一种，正如Zend的PHP优化器所作的那样。牢记这个优化处理不失为一个好主意，因为并不是所有的指令优化器都会做同样的优化处理，并且存在大量没有装配指令优化器的互联网服务提供商（ISPs）和服务器。32.并不是事必面向对象(OOP)，面向对象往往开销很大，每个方法和对象调用都会消耗很多内存33.并非要用类实现所有的数据结构，数组也很有用34.不要把方法细分得过多，仔细想想你真正打算重用的是哪些代码35.当你需要时，你总能把代码分解成方法。36.尽量采用大量的PHP内置函数。37.如果在代码中存在大量耗时的函数，你可以考虑用C扩展的方式实现它们38.评估检验(profile)你的代码。检验器会告诉你，代码的哪些部分消耗了多少时间。Xdebug调试器包含了检验程序，评估检验总体上可以显示出代码的瓶颈。39.mod_zip可作为Apache模块，用来即时压缩你的数据，并可让数据传输量降低80%。40.在可以用file_get_contents替代file、fopen、feof、fgets等系列方法的情况下，尽量用file_get_contents，因为他的效率高得多！但是要注意file_get_contents在打开一个URL文件时候的PHP版本问题；41.尽量的少进行文件操作，虽然PHP的文件操作效率也不低的；42.优化Select SQL语句，在可能的情况下尽量少的进行Insert、Update操作(在update上，我被恶批过)43.尽可能的使用PHP内部函数（但是我却为了找个PHP里面不存在的函数，浪费了本可以写出一个自定义函数的时间，经验问题啊！）；44.循环内部不要声明变量，尤其是大变量：对象(这好像不只是PHP里面要注意的问题吧？)45.多维数组尽量不要循环嵌套赋值；46.在可以用PHP内部字符串操作函数的情况下，不要用正则表达式47.foreach效率更高，尽量用foreach代替while和for循环48.用单引号替代双引号引用字符串；49.“用i+=1代替i=i+1。符合c/c++的习惯，效率还高”50.对global变量，应该用完就unset()掉 命名规则1234567常量名 类常量建议全大写，单词间用下划线分隔 // MIN_WIDTH变量名建议用下划线方式分隔 // $var_name函数名建议用驼峰命名法 // varName定界符建议全大写 // &lt;&lt;&lt;DING, &lt;&lt;&lt;'DING'文件名建议全小写和下划线、数字 // func_name.php私有属性名、方法名建议加下划线 // private $_name _func接口名建议加I_ // interface I_Name 配置选项12345set_time_limit($seconds) //设置脚本最大执行时间(默认30秒)，0表示不限制ini_get($varname) //获取一个配置选项的值ini_set($varname, $newvalue) //为一个配置选项设置值extension_loaded($ext_name) //检测一个扩展是否已经加载get_extension_funcs($ext_name) //返回模块函数名的数组 命令行CLI1234567891011121314151617181920212223//显示帮助信息php -h//解析并运行-f选项给定的文件名php [-f] &lt;file&gt; [--] [args...]//在命令行内运行单行PHP代码php [options] -r &lt;code&gt; [--] [args...]无需加上PHP的起始和结束标识符，否则将会导致语法解析错误//调用phpinfo()函数并显示出结果php -i/--info//检查PHP语法php -l/--syntax-check//打印出内置以及已加载的PHP及Zend模块php -m/--modules//将PHP，PHP SAPI和Zend的版本信息写入标准输出php -v/--version//参数接收$argv 传递给脚本的参数数组 第一个参数总是当前脚本的文件名，因此$argv[0]就是脚本文件名$argc 传递给脚本的参数数目 脚本的文件名总是作为参数传递给当前脚本，因此$argc的最小值为1包含当运行于命令行下时传递给当前脚本的参数的数组此两个变量仅在register_argc_argv打开时可用 类和对象123456789# 成员： 类成员：类常量、静态属性、静态方法 对象成员：非静态属性、非静态方法 # 除此外，类不能包含任何其他东西！！！# 类名、方法名、属性名均不区分大小写# $this代表本对象，self代表本类，parent代表父类# 类和函数均可被事先编译（仅作为最外层时）# 类的定义必须在单一的PHP区块内，不能被多个PHP标签分割 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367/ 构造方法- 具有构造函数的类会在每次创建新对象时先调用此方法void __construct([ mixed $args [, $... ]] )- 构造方法所需参数由new实例化对象时，给类增加参数值。- 构造方法也可以被手动调用。- 5.3.3版本以前，支持于类名同名的方法作为构造方法。- 两种冲突时，__construct 优先// 析构方法- 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。void __destruct( void )# 作用：释放对象所占用的资源# 调用的时机 - 脚本结束时所有资源均被释放，包括对象 - 手动删除对象时 - 保存对象的变量被赋予新值时(任何值，包括null) - 在使用exit()终止脚本运行时也会被调用// 静态成员(static关键字) - 声明类成员或方法为static，就可以不实例化类而直接访问。 - 静态成员（属性或方法）均属于类，故不能通过$this或-&gt;访问。 - 静态成员是所有对象共享，属于类。 - 静态成员用类调用，非静态成员用对象调用。# 静态属性 - 静态属性不可以由对象通过-&gt;操作符来访问。 - 静态属性只能被初始化为一个字符值或一个常量，不能使用表达式。 所以你可以把静态属性初始化为整型或数组，但不能指向另一个变量或函数返回值，也不能指向一个对象。# 静态方法 - 由于静态方法不需要通过对象即可调用，所以伪变量$this在静态方法中不可用。 - 用::方式调用一个非静态方法会导致一个E_STRICT级别的错误。// 访问解析操作符(::) - 可以用于访问静态成员、方法和常量，还可以用于覆盖类中的成员和方法。 - 当在类的外部访问这些静态成员、方法和常量时，必须使用类的名字。 - self 和 parent 这两个特殊的关键字是用于在类的内部对成员或方法进行访问的。// 访问辨析- 对象成员，内部通过$this指定，外部通过对象名指定，均用-&gt;访问，访问属性时不需加$。 对象名-&gt;属性名 对象名-&gt;方法名() $this-&gt;属性名 $this-&gt;方法名()- 类成员，内部通过self或parent指定，外部通过类名指定，均用::访问，访问属性时需加$。 类名::$属性名 类名::方法名() self::$属性名 self::方法名()- 特殊：也可以通过对象访问类成员。（不建议） 对象名::$类属性名 $this::$类属性名 对象名::$类方法名() $this::类方法名()# 对象成员访问用-&gt;，类成员访问用::- 无论是静态方法还是非静态方法，均可通过类或对象进行访问。- 静态属性通过类访问，静态方法通过对象访问。- 只有使用对象调用非静态方法时，$this才可以使用！- 静态方法不可使用$this。- 类可以调用对象方法，但注意方法内不能有$this。- 非静态方法可以调用静态属性或静态方法，反之不可以。// 类常量- 常量的值将始终保持不变。- 在定义和使用常量的时候不需要使用$符号。- 常量的值必须是一个定值，不能是变量，类属性或其它操作（如函数调用）的结果。# 定义：const 常量名 = 常量值;- 不需要加public等访问修饰限定符- 类常量属于类，使用类访问，类名::类常量 或 self::类常量// 自动加载对象- 在试图使用尚未被定义的类时自动调用 __autoload 函数- 自动加载使用到的类名文件（根据类名找相应名称的文件，故需类名与类文件名一致）- 每个需要加载类的文件都需要存在__autoload函数- 将__autoload函数写入单独的文件，每个需要用到类的文件再require该函数文件- __autoload 参数是类名function __autoload($class_name) &#123; require_once $_SERVER[\"DOCUMENT_ROOT\"] . \"/class/$class_name.php\";&#125; // $_SERVER[\"DOCUMENT_ROOT\"] 当前运行脚本所在的文档根目录- 可以通过类名，来推导出类所在的文件名！- 如果一个项目存在多个自动加载函数时，定义一个可以完成加载的普通函数，并在函数之前使用spl_autoload_register注册该函数。# spl_autoload_register- 注册__autoload()函数bool spl_autoload_register ([ callback $autoload_function ] )- 可以注册多个自动加载函数，先注册的先执行- 一旦注册自动加载函数，__autoload就失效。- 注册函数时，参数为函数名（注意加引号）；注册方法时，参数为数组# 注册类或对象的方法为自动加载方法时，参数需为数组：spl_autoload_register(array(__CLASS__, '__autoload'));__CLASS__表示当前类名，若是对象可用$this，详细见手册// 序列化（串行化）# 数据传输均是字符串类型# 除了资源类型，均可序列化# 序列化在存放数据时，会存放数据本身，也会存放数据类型作用：1.在网络传输数据时；2.为了将数组或对象放在磁盘时# 序列化serialize 产生一个可存储的值的表示string serialize ( mixed $value )- 返回字符串，此字符串包含了表示value的字节流，可以存储于任何地方。- 有利于存储或传递 PHP 的值，同时不丢失其类型和结构。# 反序列化unserialize 从已存储的表示中创建PHP的值mixed unserialize ( string $str [, string $callback ] )- 对单一的已序列化的变量进行操作，将其转换回PHP的值。# 文件的读写操作- file_put_contents 将一个字符串写入文件int file_put_contents($file, $data [,$flags]) $flags：FILE_USE_INCLUDE_PATH(覆盖)，FILE_APPEND(追加)- file_get_contents 将整个文件读入一个字符串string file_get_contents($file [, bool $use_include_path [,int $offset [,int $maxlen]]])# 对象序列化- 只能序列化对象内部的数据，即非静态属性。# 需在反序列化对象之前加载类，也可以触发自动加载机制。__sleep 序列化需序列化的属性。 - 提交未提交的数据，或类似的清理操作，部分串行化对象。 - 返回一个包含对象中所有应被序列化的变量名称的数组__wakeup 反序列化时，预先准备对象需要的资源 - 重新建立数据库连接，或执行其它初始化操作 public function __sleep() &#123; return array('server', 'username', 'password', 'db'); &#125; public function __wakeup() &#123; $this-&gt;connect(); &#125;// 对象继承class 子类名 extends 父类 &#123;&#125;如果一个对象是子类的对象，那么同时也是父类的对象。单继承：一个类只能继承一个父类，不能同时继承多个类。但一个父类可以被多个子类继承。instanceof 判断某对象是否为某类的对象 对象名 instanceof 类名// 访问控制public 公有的（继承链、本类、外部均可访问）protected 保护的（仅继承链、本类可访问）private 私有的（仅本类可访问）根据成员定义位置、访问位置判断。# 兼容性问题- 声明属性时，var关键字声明的默认为public权限- 声明方法时，省略访问修饰符，默认为public权限// 重写 override$this代表本对象，被谁调用，就代表哪个对象。- 继承时，子类成员名于父类成员名发生冲突，则子类成员会重写父类成员。- 属性和方法均可被子类重写。- 当父类的方法或属性已经不满足子类的需求，则需要重写。- 也可能因为命名不规范导致重写。私有属性不能被重写，每个私有属性都会被记录。在记录属性名的同时，还会记录类。如果有内置函数被重写，则可调用父类方法。如调用父类构造方法parent::__construct()# 重写限制访问限制： 子类的成员的访问控制必须相等或弱于父类。方法参数限制： 参数数量必须相同，参数名可不同。# $this确定原则$this为调用该方法的对象，表示该方法的执行环境对象。 - 对象调用 - 环境的传递。如果当前调用时，不能确定$this的值(静态调用)，此时静态调用所处对象环境会传递到被调用的方法内。$this并非永远代表本对象，而是由方法的执行环境决定。# final如果父类中的方法被声明为final，则子类无法覆盖（重写）该方法。如果一个类被声明为final，则不能被继承。但加有final关键字的类依旧能被实例化！# 抽象类关键字：abstract抽象类不能直接被实例化，必须先继承该抽象类，然后再实例化子类。抽象类中至少要包含一个抽象方法。非抽象类不能包含抽象方法。如果类方法被声明为抽象的，那么其中就不能包括具体的功能实现。抽象方法不能包含大括号及方法体。继承一个抽象类的时候，子类必须实现抽象类中的所有抽象方法。 即，子类必须重写抽象父类中的所有抽象方法。另外，这些方法的可见性必须和抽象类中一样（或者更为宽松）。 即，如果抽象类中某个抽象方法被声明为protected，那么子类中实现的方法就应该声明为protected或者public，而不能定义为private。- 抽象类的子类中的普通方法执行方式和其他类相同。- 作用： 1. 继承，为扩展类，统一公共操作。 2. 限制结构（规范）。规范子类的结构。// 接口关键字：interface- 对象提供的与对象交互的方式就是接口。- 使用接口可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。- 通过interface来定义一个接口，就像定义一个标准的类一样，但其中定义所有的方法都是空的。 - 接口中定义的所有属性和方法都必须是public，可省略public关键字。- 接口中也可以定义常量(const)。接口常量和类常量的使用完全相同。 可以用::访问。接口名::常量名，实现类::常量名。 它们都是定值，可以被子类或子接口使用，但不能修改。- 接口不能定义属性！# 定义接口interface 接口名 &#123; 接口内容（公共方法声明的集合）&#125;# 接口实现- 要实现一个接口，可以使用implements操作符。- 类中必须实现接口中定义的所有方法，否则会报一个fatal错误。- 如果要实现多个接口，可以用逗号来分隔多个接口的名称。- 实现多个接口时，接口中的方法不能有重名。- 接口也可以继承，通过使用extends操作符。class 类名 implements 接口名 &#123; 接口方法的实现&#125;# 注意 1. 类与抽象类之间是继承关系，类与接口之间是实现关系。 2. 类与抽象类是单继承，类与接口是多实现。 3. 接口不是类，限制类的结构。 4. 接口与接口之间是多继承。用extends关键字。 interface I_C extends I_A, I_B &#123;&#125;// 静态延迟绑定self::，代表本类(当前代码所在类) 永远代表本类，因为在类编译时已经被确定。 即，子类调用父类方法，self却不代表调用的子类。static::，代表本类(调用该方法的类) 用于在继承范围内引用静态调用的类。 运行时，才确定代表的类。 static::不再被解析为定义当前方法所在的类，而是在实际运行时计算的。// 对象的遍历（迭代）- 对象通过属性保存数据，故遍历对象的属性。- foreach语言结构，获得属性名和属性值。 foreach ($obj as $p_name =&gt; $p_value) &#123;&#125;# 自定义遍历(迭代器Iterator)Iterator - 可在内部迭代自己的外部迭代器或类的接口Iterator::current — 返回当前元素Iterator::key — 返回当前元素的键Iterator::next — 向前移动到下一个元素Iterator::rewind — 返回到迭代器的第一个元素Iterator::valid — 检查当前位置是否有效# 对象的克隆//对象之间的传值是[引用]传递。克隆：新对象 = clone 旧对象 - 所有的引用属性仍然会是一个指向原来的变量的引用。 __clone()方法在对象被克隆时自动调用。注意：构造方法对应实例化(new)，克隆方法对应克隆(clone)。// 单例模式#三私一公单例模式（Singleton）用于为一个类生成一个唯一的对象。最常用的地方是数据库连接。使用单例模式生成一个对象后，该对象可以被其它众多对象所使用。# 防止一个类被实例化多次class MySQLDB &#123; private static $instance = null; // 存类实例在此属性中 // 构造方法声明为private，防止直接创建对象 private function __construct() &#123;&#125; public static function getInstance() &#123; if(! self::$instance instanceof static) &#123; self::$instance = new static; &#125; return self::$instance; &#125; private function __clone() &#123;&#125; // 阻止用户复制对象实例&#125;// 魔术方法__construct 构造方法__destruct 析构方法__clone 克隆对象__sleep 序列化对象__wakeup 反序列化对象__autoload 自动加载，使用类但未找到时__toString 对象被当作字符串使用时__invoke 当尝试以调用函数的方式调用一个对象时# 重载 overload指动态地\"创建\"类属性和方法用户可以自由的为对象添加额外的属性，该特性就是重载。所有的重载方法都必须被声明为public。当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。重载相关魔术方法的参数都不能通过引用传递。# 属性重载- 处理不可访问的属性属性重载只能在对象中进行。# 属性重载对于静态属性无效在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被声明为static。__set 在给不可访问的属性赋值时 public void __set(string $name, mixed $value) 作用：批量管理私有属性，间接保护对象结构__get 读取不可访问的属性的值时 public mixed __get(string $name)__isset 当对不可访问的属性调用isset()或empty()时 public bool __isset(string $name)__unset 当对不可访问的属性调用unset()时 public void __unset(string $name)# 方法重载- 处理不可访问的方法__call 当调用一个不可访问的非静态方法（如未定义，或者不可见）时自动被调用 public mixed __call(string $name, array $arguments)__callStatic 当在调用一个不可访问的静态方法（如未定义，或者不可见）时自动被调用 public static mixed __callStatic(string $name, array $arguments)# $name参数是要调用的方法名称。$arguments参数是一个数组，包含着要传递给方法的参数。// 类型约束函数的参数可以指定只能为对象或数组限定为对象则在形参前加类名，限定为数组则在形参前加array类型约束允许NULL值类型约束不只是用在类的成员方法里，也能使用在函数里。 // 三大特性封装：隐藏内部是吸纳，仅开发接口。继承：一个对象的成员被另一个对象所使用。语法上体现为代码的共用。多态：多种形态。// 类与对象·关键字this 代表本对象public 公有的（继承链、本类、外部均可访问）protected 保护的（仅继承链、本类可访问）private 私有的（仅本类可访问）parent:: 代表父类self:: 代表本类(当前代码所在类)static:: 代表本类(调用该方法的类)static 静态成员（属性、方法），所有对象均可使用，外部也可直接使用或修改，静态方法不可访问非静态成员final 方法用final不可被子类重载，类用final不可被继承（方法、类）const 类常量（属性）abstract 抽象类interface 接口extends 类继承(子接口继承接口、其他普通类继承)implements 接口实现（类实现接口、抽象类实现借口）（对接口的实现和继承均可有多个）Iterator 内置接口（迭代）clone 克隆instance 实例instanceof 某对象是否属于某类/* 【类与对象相关函数】 */class_alias([$original [,$alias]]) 给类取别名class_exists($class [,$autoload]) 检查类是否已定义interface_exists($interface [,$autoload]) 检查接口是否已被定义method_exists($obj, $method)检查类的方法是否存在property_exists($class, $property) 检查对象或类是否具有该属性get_declared_classes(void) 返回由已定义类的名字所组成的数组get_declared_interfaces(void) 返回一个数组包含所有已声明的接口get_class([$obj]) 返回对象的类名get_parent_class([$obj]) 返回对象或类的父类名get_class_methods($class) 返回由类的方法名组成的数组get_object_vars($obj) 返回由对象属性组成的关联数组get_class_vars($class) 返回由类的默认属性组成的数组is_a($obj, $class) 如果对象属于该类或该类是此对象的父类则返回TRUEis_subclass_of($obj, $class) 如果此对象是该类的子类，则返回TRUEget_object_vars($obj) 返回由对象属性组成的关联数组// 常用类# PHP手册 -&gt; 预定义类Closure 闭包类，匿名函数对象的final类stdClass 标准类，通常用于对象类保存集合数据__PHP_Incomplete_Class 不完整类，当只有对象而没有找到类时，则该对象被认为是该类的对象Exception 异常类PDO 数据对象类// 魔术常量__DIR__ 文件所在的目录__LINE__ 文件中的当前行号 __FILE__ 文件的完整路径（绝对路径）和文件名__CLASS__ 类的名称__METHOD__ 类的方法名，包含类名和方法名__FUNCTION__ 函数名称，用在方法内只表示方法名// 反射机制 Reflection作用：1. 获取结构信息 2. 代理执行ReflectionClass 报告一个类的有关信息ReflectionMethod 报告一个方法的有关信息ReflectionClass::export 输出类结构报告# 代理执行实例化 ReflectionFunction 类的对象 $f = new ReflectionFunction('func'); // func为函数func($p) $f-&gt;invoke('param'); 网站并发12345678910111213141516171819202122232425测试工具：apache/bin/ab.exe用法：cmd&#123;%apache-bin%&#125;&gt;ab.exe -n 执行访问次数 -c 用户并发数量 URL地址MPM(多路处理模块)：perfork(预处理模式), worker(工作者模式), winnt(Win系统)MPM配置：httpd-mpm.conf查看当前MPM模式：httpd –l mpm_xxx.c中xxx表示当前模式类型httpd.conf配置(开启MPM)：#Include conf/extra/httpd-mpm.conf#参考配置#配置文件：extra/httpd-mpm.conf#mpm_winnt.c&lt;IfModule mpm_winnt_module&gt; ThreadsPerChild 1000 #中型网站1500-5500合理 MaxRequestsPerChild 0&lt;/IfModule&gt;#mpm_prefork.c&lt;IfModule mpm_prefork_module&gt; StartServers 5 #预先启动 MinSpareServers 5 MaxSpareServers 10 #最大空闲进程 ServerLimit 1500 #用于修改apache编程参数 MaxClients 1000 #最大并发数 MaxRequestsPerChild 0 #一个进程对应的线程数，对worker更用&lt;/IfModule&gt;#如果你的网站pv值上百万ServerLimit 2500 #用于修改apache编程参数MaxClients 2000 #最大并发数 预定义常量12345678910PATH_SEPARATOR //路径分隔符(Windows为分号，类Unix为冒号)DIRECTORY_SEPARATOR //目录分隔符PHP_EOL //当前系统的换行符PHP_VERSION //PHP版本号PHP_OS //PHP服务操作系统PHP_SAPI //用来判断是使用命令行还是浏览器执行的，如果 PHP_SAPI=='cli' 表示是在命令行下执行PHP_INT_MAX INT最大值，32位平台时值为2147483647PHP_INT_SIZE INT字长，32位平台时值为4（4字节）M_PI //圆周率值M_E //自然数 相对路径123456789101112131415161718192021222324当前浏览器请求的哪个脚本，当前位置就是属于哪个脚本。./file 和 file 都表示当前目录下的file文件file情况（嵌套载入文件时）：如果当前目录没找到该文件就在代码文件所在目录中继续找。如果当前目录找到有该文件，则不会再在代码文件所在目录去找也不会再加载。__DIR__ 脚本文件所在目录__FILE__ 脚本文件路径include_path 加载文件查找目录 set_include_path() 设置include_path，可多个，用字符串作参数 该函数设置的path只针对该当前文件有效 该设置只针对查找未直接写文件路径方式有效 设置新的include_path会覆盖原来的 get_include_path() 获取当前include_path设置项，无参数 路径分隔符，在Windows下是分号，在Linux下是冒号 利用预定义常量 PATH_SEPARATOR 来获得当前的分隔符如果直接写文件名： 1. include_path所设置的 2. 当前目录 3. 代码所在文件的目录如果文件名前带有路径，则会直接根据路径查找，include_path直接被忽略 变量函数1get_defined_vars //返回由所有已定义变量所组成的数组(包括环境变量、服务器变量和用户定义的变量) 可变标识符123456可变变量 $i = 3; $k = 'i'; echo $$k; //输出3可变函数 function func() &#123;echo 'hello!';&#125; $i = 'func'; $i(); //输出hello可变下标 $i = '1234'; $k = 3; echo $i[$k]; //输出4可变类名 class CLS&#123;public $k = 'hello';&#125; $i = 'CLS'; $j = new $i; echo $j-&gt;k;可变属性 class CLS&#123;public $k = 'hello';&#125; $i = 'k'; $j = new CLS; echo $j-&gt;$i;可变方法 class CLS&#123;public function k()&#123;echo 'hello';&#125;&#125; $i='k'; $j=new CLS; $j-&gt;$i(); 终止和延迟脚本执行123456789die / exit 终止return是终止所在脚本的执行die和exit会立即终止脚本执行die(\"到此为止\"); 该函数内的字符串可被输出sleep() 延迟(单位：秒) 默认最多可延迟30秒，PHP配置可以修改 max_execution_time 例：sleep(12);usleep() 以指定的微秒数延迟执行time_sleep_until 使脚本睡眠到指定的时间为止 定界符12345678910herodoc - 功能同双引号，能解析$str = &lt;&lt;&lt;AAA字符串内容AAA;nowdoc - 功能同单引号，不能解析只在开始位置有单引号$str = &lt;&lt;&lt;'AAA'字符串内容AAA; 静态化123456781. 页面URL长度不超过255字节2. meta信息尽量完整，keywords5个左右3. 前端不要使用框架4. 图片alt属性添加信息5. 静态页面不要带动态值&lt;script type=\"text/javascript\" language=\"javascript\" src=\"url\"&gt;&lt;/script&gt;url可以是js/php/图片等，返回的数据替换&lt;script&gt;标签所在位置的内容！相当于简单的Ajax 常量相关12345678910111213141516171819/* 常量定义 */define(常量名, 常量值, [区分大小写参数]) //true表示不区分/false表示区分大小写const 常量名 = 常量值 // 新，建议常量名可以使用特殊字符constant($name) // 获取常量名 // 例：echo constant('-_-');/* 常量相关函数 */definedget_defined_constants/* 预定义常量 */__FILE__ 所在文件的绝对路径__LINE__ 文件中的当前行号__DIR__ 文件所在目录__FUNCTION__ 函数名称__CLASS__ 类的名称__METHOD__ 类的方法名__NAMESPACE__ 当前命名空间的名称 变量生命周期 脚本结束时，全局变量消失 函数执行完时，局部变量消失 静态变量 static关键字静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。 静态变量仅会被初始化一次，其他局部变量每次被调用时都会被重新赋值。 static声明的静态变量的生命周期会被一直延续。 变量作用域a. 全局变量和局部变量 1) 作用域之间不重叠，即不同作用域的变量，之间不可访问 2) 全局作用域 - 函数之外的区域 3) 局部作用域 - 函数内的区域，每个函数都是一个独立的作用域 b. 超全局变量，既可以在全局也可在局部使用，仅能用系统自带的，均是数组变量。 $GLOBALS $_COOKIE $_ENV $_FILES $_GET $_POST $_REQUEST $_SERVER $_SESSIONc. $GLOBALS 1) 不能存在超全局变量，但可以有超全局的数据！ 2) 将需要的数据放到超全局变量的数组内，但统一使用$GLOBALS 3) $GLOBALS 特征 - 每个全局变量就是对应$GLOBALS内的一个元素！ 每当增加一个全局，则自动在$GLOBALS内增加一个同名元素！ 同理，每当增加元素，也会增加一个全局变量，一般在函数内增加 - 做的任何修改，也会映射到另一个，包括更新和删除 在函数内访问全局变量，只需使用$GLOBALS - 出现过的全局变量，就可以通过$GLOBALS这个数组取得 4) PHP生命周期中，定义在函数体外部的所谓全局变量，函数内部是不能直接获得的 4) global关键字（不建议使用） 将局部变量声明为同名全局变量的一个’引用’！相当于常量的引用传递 global $var; // $var = &amp;$GLOBALS[‘var’]; 不同于$GLOBALS！！！ global在函数产生一个指向函数外部变量的别名变量，而不是真正的函数外部变量。 $GLOBALS确确实实调用是外部的变量，函数内外会始终保持一致。 global的作用是定义全局变量，但是这个全局变量不是应用于整个网站，而是应用于当前页面，包括include或require的所有文件。d. 1) 作用域只针对变量，对常量无效 2) 被载入文件中定义的变量作用域取决于被载入的位置。 函数外被载入就是全局，函数内被载入就是局部！ 错误处理解析错误、运行错误//标准错误： 级别、信息、文件、行号 trigger_error 触发一个用户自定义的error/warning/notice错误信息 //php.ini配置，ini_set()error_reporting 设置报告哪些级别的错误 123456# 错误报告：显示到页面 display_errors = On 是否显示错误报告# 错误日志：存放到文件 log_errors = on 是否开启错误日志 error_log 发送错误信息到错误日志文件- 错误报告和错误日志可同时启用！ 自定义错误处理器set_error_handler — 注册自定义错误处理器函数 自定义处理器函数包含4个参数，分别是级别、信息、文件、行号 开启自定义错误处理器，则系统内置的错误报告和错误日志则不会执行。 自定义错误处理器函数返回false，则自定义函数结束后系统内置的会继续执行。 用户定义的错误级别(E_USER_ERROR)，可以被自定义的错误处理器所捕获并继续执行。系统内置的错误，则脚本会立即停止。restore_error_handler — 恢复预定义错误处理器函数error_get_last — 获取最近的错误信息 //错误处理函数debug_backtrace 产生一条回溯跟踪 返回数组，包含的键值：function, line, file, class, object, type, argsdebug_print_backtrace 打印一条回溯 //错误常量手册&gt;错误处理 #生产模式关闭错误报告，记录错误日志。 #开发模式关闭错误日志，开启错误报告。 //异常面向对象语法中的错误处理方式。一个异常就是一个包含当前异常信息的对象。预定义异常类Exception及其扩展类。 #抛出异常触发一个异常的错误throw new UserException();如果没有被捕获，则报告致命错误。 #监视异常try {代码段} #捕获异常catch (UserException $obj) {代码段}需要通过当前异常的类型匹配才可悲捕获。 #异常处理器用以处理未被捕获的异常。异常处理器函数与catch类似，参数也是含类型的对象。set_exception_handler — 注册异常处理器函数restore_exception_handler — 恢复预定义的异常处理器函数 #自定义异常用户定义的异常类须继承自Exception类。 //异常相关属性protected string $message 异常消息内容protected int $code 异常代码protected string $file 抛出异常的文件名protected int $line 抛出异常在该文件中的行号//异常相关方法Exception::construct — 异常构造函数Exception::getMessage — 获取异常消息内容Exception::getPrevious — 返回异常链中的前一个异常Exception::getCode — 获取异常代码Exception::getFile — 获取发生异常的程序文件名称Exception::getLine — 获取发生异常的代码在文件中的行号Exception::getTrace — 获取异常追踪信息Exception::getTraceAsString — 获取字符串类型的异常追踪信息Exception::toString — 将异常对象转换为字符串Exception::__clone — 异常克隆 $_SERVER12345678910111213141516171819202122232425262728293031323334353637//示例URL：http://desktop/dir/demo.php?a=aaa&amp;b=bbbPHP_SELF 当前执行脚本的文件名 // /dir/demo.phpGATEWAY_INTERFACE 服务器使用的CGI规范的版本 // CGI/1.1SERVER_ADDR 当前运行脚本所在的服务器的IP地址 // 127.0.0.1SERVER_NAME 当前运行脚本所在的服务器的主机名 // desktopSERVER_SOFTWARE 服务器标识字符串 // Apache/2.2.22 (Win32) PHP/5.3.13SERVER_PROTOCOL 请求页面时通信协议的名称和版本 // HTTP/1.1REQUEST_METHOD 访问页面使用的请求方式 // GETREQUEST_TIME 请求开始时的时间戳 // 1386032633QUERY_STRING 查询字符串(参数) // a=aaa&amp;b=bbbDOCUMENT_ROOT 当前运行脚本所在的文档根目录 // C:/Users/Administrator/DesktopHTTP_ACCEPT 当前请求头中Accept:项的内容 // text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8HTTP_ACCEPT_CHARSET 当前请求头中Accept-Charset:项的内容 // UTF-8,*HTTP_ACCEPT_ENCODING 当前请求头中Accept-Encoding:项的内容 // gzip, deflateHTTP_ACCEPT_LANGUAGE 当前请求头中Accept-Language:项的内容 // zh-cn,zh;q=0.5HTTP_CONNECTION 当前请求头中Connection:项的内容 // keep-aliveHTTP_HOST 当前请求头中Host:项的内容 // desktopHTTP_REFERER 引导用户代理到当前页的前一页的地址HTTP_USER_AGENT 当前请求头中User-Agent:项的内容 // Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1HTTPS 如果脚本是通过HTTPS协议被访问，则被设为一个非空的值REMOTE_ADDR 浏览当前页面的用户的IP地址 // 127.0.0.1REMOTE_HOST 浏览当前页面的用户的主机名REMOTE_PORT 用户机器上连接到Web服务器所使用的端口号 // 49197REMOTE_USER 经验证的用户REDIRECT_REMOTE_USER 验证的用户，如果请求已在内部重定向SCRIPT_FILENAME 当前执行脚本的绝对路径 // C:/Users/Administrator/Desktop/dir/demo.phpSERVER_ADMIN 该值指明了Apache服务器配置文件中的SERVER_ADMIN参数 //admin@shocker.comSERVER_PORT Web服务器使用的端口 // 80SERVER_SIGNATURE 包含了服务器版本和虚拟主机名的字符串PATH_TRANSLATED 当前脚本所在文件系统（非文档根目录）的基本路径SCRIPT_NAME 当前脚本的路径 // /dir/demo.phpREQUEST_URI URI用来指定要访问的页面 // /dir/demo.php?a=aaa&amp;b=bbbPHP_AUTH_DIGEST 客户端发送的“Authorization” HTTP头内容PHP_AUTH_PW 用户输入的密码AUTH_TYPE 认证的类型PATH_INFO 包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息ORIG_PATH_INFO 在被PHP处理之前，“PATH_INFO”的原始版本 其他123456789101112131415161718192021version_compare(str $ver1, str $ver2 [,str $operator]) //比较版本号 $operator表示操作符，可选：&lt;, lt, &lt;=, le, &gt;, gt, &gt;=, ge, ==, =, eq, !=, &lt;&gt;, ne 如果省略$operator，返回两个版本号的差值。符号@ 用于抑制系统运行错误的报告显示memory_get_usage //获取当期内存使用情况memory_get_peak_usage //获取内存使用的峰值getrusage //获取CPU使用情况(Windows不可用)uniqid([$prefix]) //获取一个带前缀、基于当前时间微秒数的唯一IDhighlight_string($str [,$return]) //字符串的语法高亮 $return：设置为TRUE，高亮后的代码不会被打印输出，而是以字符串的形式返回。高亮成功返回TRUE，否则返回FALSE。highlight_file($file [,$return]) //语法高亮一个文件__halt_compiler //中断编译器的执行get_browser //获取浏览器具有的功能 get_browser ([ string $user_agent [, bool $return_array = false ]] ) 如果设置为 TRUE，该函数会返回一个 array，而不是 objecteval($code) //把字符串作为PHP代码执行gzcompress($str [,$level=-1]) //压缩字符串gzuncompress($str) //解压缩字符串gzencode($str [,$level=-1]) //压缩字符串gzdecode($str) //解压缩字符串ignore_user_abort($bool) //设置客户端断开连接时是否中断脚本的执行 PHP函数字符串函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081addslashes($str) //使用反斜线转移字符串stripcslashes($str) //反引用一个使用addcslashes转义的字符串stripslashes($str) //反引用一个引用字符串chr($ascii) //返回ASCII码的字符ord($char) //返回字符的ASCII码substr_count($haystack, $needle) //计算子串出现的次数count_chars($str [,$mode]) 统计每个字节值出现的次数 //0 - 以所有的每个字节值作为键名，出现次数作为值的数组。 //1 - 与0相同，但只列出出现次数大于零的字节值。 //2 - 与0相同，但只列出出现次数等于零的字节值。 //3 - 返回由所有使用了的字节值组成的字符串。 //4 - 返回由所有未使用的字节值组成的字符串。 crypt($str, [$salt]) //单向字符串散列str_split($str [,$len]) //将字符串按长度分割为数组explode($separ, $str) //使用一个字符串分割另一个字符串implode([$glue,] $arr) //将数组元素的值根据$glue连接成字符串chunk_split($str [,$len [,$end]]) //将字符串分割成小块 $len：每段字符串的长度，$end：每段字符串末尾加的字符串(如\"\\r\\n\")html_entity_decode($str [,$flags [,$encoding]]) //将HTML实体转成字符信息htmlentities($str [,$flags [,$encoding]]) //将字符信息转成HTML实体htmlspecialchars_decode($str) //将特殊HTML实体转成字符信息htmlspecialchars($str [,$flags [,$encoding]]) //将字符信息转成特殊HTML实体lcfirst($str) //将字符串首字母转成小写ucfirst($str) //将字符串首字母转成大写ucwords($str) //将字符串中每个单词的首字母转换为大写strtolower($str) //将字符串转化为小写strtoupper($str) //将字符串转化为大写trim($str [,$charlist]) //去除字符串首尾处的空白字符（或者其他字符）ltrim($str [,$charlist]) //去除字符串首段的空白字符（或者其他字符）rtrim($str [,$charlist]) //去除字符串末端的空白字符（或者其他字符）md5_file($file) //计算指定文件的MD5散列值md5($str) //计算字符串的MD5散列值money_format($format, $num) //将数字格式化为货币形式number_format($num) //格式化数字nl2br($str) //在字符串所有新行之前插入HTML换行标记&lt;br /&gt;parse_str($str, [$arr]) //解析字符串print($str) //输出字符串printf //输出格式化字符串sprintf($format [,$args...]) //格式化字符串sha1_file //计算文件的sha1散列值sha1 //计算字符串的sha1散列值similar_text($first, $second [,$percent]) //计算两个字符串的相似度 返回在两个字符串中匹配字符的数目，$percent存储相似度百分比str_replace($search, $replace, $str [,$count [,$type]]) //子字符串替换str_ireplace //字符串替换(忽略大小写)str_pad($str, $len [,$pad [,$type]]) //使用另一个字符串填充字符串为指定长度 $type：在何处填充。STR_PAD_RIGHT，STR_PAD_LEFT 或 STR_PAD_BOTHstr_repeat($str, $num) //重复一个字符串str_shuffle($str) //随机打乱一个字符串str_word_count($str [,$format [,$charlist]]) //返回字符串中单词的使用情况strcasecmp($str1, $str2) //二进制安全比较字符串（不区分大小写） 如果str1小于str2，返回负数；如果str1大于str2，返回正数；二者相等则返回0。strcmp($str1, $str2) //二进制安全字符串比较strcoll($str1, $str1) //基于区域设置的字符串比较(区分大小写，非二进制安全)strcspn($str1, $str1 [,$start [,$len]]) //获取不匹配遮罩的起始子字符串的长度strip_tags($str) //从字符串中去除HTML和PHP标记strpos($haystack, $needle [,$offset]) //查找字符串首次出现的位置stripos($haystack, $needle [,$offset]) //查找字符串首次出现的位置（不区分大小写）strripos($haystack, $needle [,$offset]) //计算指定字符串在目标字符串中最后一次出现的位置（不区分大小写）strrpos($haystack, $needle [,$offset]) //计算指定字符串在目标字符串中最后一次出现的位置strlen($str) //获取字符串长度strpbrk($haystack, $str) //在字符串中查找一组字符的任何一个字符strrev($str) //反转字符串 join('', array_reverse(preg_split(\"//u\", $str))); //实现对UTF-8字符串的反转strspn$subject, $mask) //计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。strstr($haystack, $needle) //查找字符串的首次出现stristr($haystack, $needle) //查找字符串的首次出现(不区分大小写)strrchr($haystack, $needle) //查找指定字符在字符串中的最后一次出现strtok($str, $token) //标记分割字符串substr_compare($main_str, $str, $offset [,$len) //二进制安全比较字符串（从偏移位置比较指定长度）substr_replace$str, $replace, $start [,$len] //替换字符串的子串strtr($str, $from, $to) //转换指定字符substr($str, $start [,$len]) //返回字符串的子串vfprintf$handle, $format, $args) //将格式化字符串写入流vprintf($format, $args) //输出格式化字符串vsprintf($format, $args) //返回格式化字符串wordwrap($str [,$width=75 [,$break='\\n']]) //打断字符串为指定数量的字串crc32($str) //计算一个字符串的crc32多项式 crc32算法[循环冗余校验算法] 生成str的32位循环冗余校验码多项式。将数据转换成整数。 Math函数123456789101112131415161718192021222324/* Math函数 */base_convert($number, $frombase, $tobase) //在任意进制之间转换数字ceil($float) //向上取整floor($float) //向下取整exp($float) //计算e的指数hypot($x, $y) //计算直角三角形的斜边长is_nan($val) //判断是否为合法数值log($arg [,$base=e]) //自然对数max($num1, $num2, ...) //找出最大值 max($arr) //找出数组中的最大值min($num1, $num2, ...) //找出最小值rand([$min], $max) //产生一个随机整数srand([$seed]) //播下随机数发生器种子mt_rand([$min], $max) //生成更好的随机数mt_srand($seed) //播下一个更好的随机数发生器种子pi() //得到圆周率值pow($base, $exp) //指数表达式sqrt($float) //求平方根deg2rad($float) //将角度转换为弧度rad2deg($float) //将弧度数转换为相应的角度数round($val [,$pre=0]) //对浮点数进行四舍五入fmod($x, $y) //返回除法的浮点数余数 PHP运行环境检测函数1234php_sapi_name() //返回一个PHP与WEB服务器接口类型的小写字符串该函数返回值与常量PHP_SAPI一致！接口类型：SAPI(the Server API, SAPI)可能值：aolserver、apache、apache2filter、apache2handler、caudium、cgi、cgi-fcgi、cli、 continuity、embed、isapi、litespeed milter、nsapi、phttpd、pi3web、roxen、thttpd、tux、webjames fileinfo12345678910111213141516171819202122232425262728293031323334获取/设置文件信息#扩展Fileinfo，配置php.ini#extension=php_fileinfo.dllfinfo_open([$opt]) //创建一个文件信息资源finfo_file($finfo, $file [,$opt]) //获取文件信息finfo_set_flags($finfo, $opt) //设置文件信息项finfo_close($finfo) //关闭文件信息资源mime_content_type($file) //获取文件的MIME类型$opt参数选项：FILEINFO_MIME_ENCODING 文件编码类型FILEINFO_MIME_TYPE 文件MIME类型//目录chdir($dir) 改变当前目录chroot($dir) 将当前目录改变为当前进程的根目录closedir($handle) 关闭目录句柄dir($dir) 返回一个目录的实例对象getcwd() 取得当前工作目录opendir($path) 打开目录句柄readdir($handle) 从目录句柄中读取条目rewinddir($handle) 倒回目录句柄scandir($dir [,$order]) 列出指定路径中的文件和目录glob($pattern [,$flags]) 寻找与模式匹配的文件路径 $flags： GLOB_MARK - 在每个返回的项目中加一个斜线 GLOB_NOSORT - 按照文件在目录中出现的原始顺序返回（不排序） GLOB_NOCHECK - 如果没有文件匹配则返回用于搜索的模式 GLOB_NOESCAPE - 反斜线不转义元字符 GLOB_BRACE - 扩充 &#123;a,b,c&#125; 来匹配 'a'，'b' 或 'c' GLOB_ONLYDIR - 仅返回与模式匹配的目录项 查找多种后缀名文件：glob('*.&#123;php,txt&#125;', GLOB_BRACE); mbstring(多字节字符串)1234567891011121314151617181920//需开启mbstring扩展mb_strimwidth($str, $start, $width [,$trim [,$encoding]]) //保留指定的子串(并补充)mb_stripos($str, $needle [,$offset [,$encoding]]) //查找子串首次出现的位置(忽略大小写)mb_strpos($str, $needle [,$offset [,$encoding]]) //查找子串首次出现的位置mb_strripos($str, $needle [,$offset [,$encoding]]) //查找子串最后一次出现的位置(忽略大小写)mb_strrpos($str, $needle [,$offset [,$encoding]]) //查找子串最后一次出现的位置mb_strstr($str, $needle [,$before [,$encoding]]) //返回子串首次出现位置之后(前)的字符串mb_stristr($str, $needle [,$before [,$encoding]]) //返回子串首次出现位置之后(前)的字符串(忽略大小写)mb_strrchr($str, $needle [,$before [,$encoding]]) //返回字符最后一次出现位置之后(前)的字符串mb_strrichr($str, $needle [,$before [,$encoding]]) //返回字符最后一次出现位置之后(前)的字符串(忽略大小写)mb_strtoupper($str [,$encoding]) //转换成大写mb_strtolower($str [,$encoding]) //转换成小写mb_strlen($str [,$encoding]) //获取字符串长度mb_split($pattern, $str [,$limit]) //将字符串分割成数组mb_substr($str, $start [,$len [,$encoding]]) //获取字符串的子串mb_strcut($str, $start [,$len [,$encoding]]) //获取字符串的子串mb_strwidth($str [,$encoding]) //获取字符串的宽度mb_substr_count($str, $needle [,$encoding]) //子串在字符串中出现的次数 ob缓存(输出控制)12345678910111213141516171819202122232425262728293031323334Output Bufferingob_start() //打开一个输出缓冲区，所有的输出信息不再直接发送到浏览器，而是保存在输出缓冲区里面。 ob_start('ob_gzhandler'); //将gz编码的数据发送到支持压缩页面的浏览器ob_clean(); //删除内部缓冲区的内容，不关闭缓冲区(不输出)。ob_end_clean(); //删除内部缓冲区的内容，关闭缓冲区(不输出)。ob_get_clean(); //返回内部缓冲区的内容，关闭缓冲区。相当于执行ob_get_contents()与ob_end_clean()ob_flush(); //发送内部缓冲区的内容到浏览器，删除缓冲区的内容，不关闭缓冲区。ob_end_flush(); //发送内部缓冲区的内容到浏览器，删除缓冲区的内容，关闭缓冲区。ob_get_flush(); //返回内部缓冲区的内容，并关闭缓冲区，再释放缓冲区的内容。相当于ob_end_flush()并返回缓冲区内容。flush(); //将当前为止程序的所有输出发送到用户的浏览器ob_get_contents(); //返回缓冲区的内容，不输出。ob_get_length(); //返回内部缓冲区的长度，如果缓冲区未被激活，该函数返回FALSE。ob_get_level(); //Return the nesting level of the output buffering mechanism.ob_get_status(); //获取ob状态信息ob_implicit_flush(); //打开或关闭绝对刷新，默认为关闭，打开后ob_implicit_flush(true)，所谓绝对刷新，即当有输出语句(e.g: echo)被执行时，便把输出直接发送到浏览器，而不再需要调用flush()或等到脚本结束时才输出。ob_gzhandler //ob_start回调函数，用gzip压缩缓冲区的内容。ob_list_handlers //List all output handlers in useoutput_add_rewrite_var //Add URL rewriter valuesoutput_reset_rewrite_vars //Reset URL rewriter values这些函数的行为受php_ini设置的影响：output_buffering //该值为ON时，将在所有脚本中使用输出控制；若该值为一个数字，则代表缓冲区的最大字节限制，当缓存内容达到该上限时将会自动向浏览器输出当前的缓冲区里的内容。output_handler //该选项可将脚本所有的输出，重定向到一个函数。例如，将 output_handler 设置为 mb_output_handler() 时，字符的编码将被修改为指定的编码。设置的任何处理函数，将自动的处理输出缓冲。implicit_flush //作用同ob_implicit_flush，默认为Off。//ob缓存作用1)防止在浏览器有输出之后再使用setcookie()、header()或session_start()等发送头文件的函数造成的错误。其实这样的用法少用为好，养成良好的代码习惯。2)捕捉对一些不可获取的函数的输出，比如phpinfo()会输出一大堆的HTML，但是我们无法用一个变量例如$info=phpinfo();来捕捉，这时候ob就管用了。3)对输出的内容进行处理，例如进行gzip压缩，例如进行简繁转换，例如进行一些字符串替换。4)生成静态文件，其实就是捕捉整页的输出，然后存成文件。经常在生成HTML，或者整页缓存中使用。 Cookie1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253cookie是一种在远程浏览器端储存数据并以此来跟踪和识别用户的机制。cookie是HTTP标头的一部分，因此setcookie()函数必须在其它信息被输出到浏览器前调用，这和对header()函数的限制类似。可以使用输出缓冲函数来延迟脚本的输出，直到按需要设置好了所有的cookie或者其它HTTP标头。// 新增setcookie 新增一条cookie信息setcookie($name [,$value [,$expire [,$path [,$domain [,$secure [,$httponly]]]]]])#注意：setcookie()函数前不能有输出！除非开启ob缓存！# 参数说明$name - cookie的识别名称 使用$_COOKIE['name']抵用名为name的cookie$value - cookie值，可以为数值或字符串，此值保存在客户端，不要用来保存敏感数据 假定$name参数的值为'name'，则$_COOKIE['name']就可取得该$value值$expire - cookie的生存期限（Unix时间戳，秒数） 如果$expire参数的值为time()+60*60*24*7则可设定cookie在一周后失效。如果未设定该参数，则会话后立即失效。$path - cookie在服务器端的指定路径。当设定该值时，服务器中只有指定路径下的网页或程序可以存取该cookie。 如果该参数值为'/'，则cookie在整个domain内有效。 如果设为'/foo/'，则cookie就在domain下的/foo/目录及其子目录内有效。 默认值为设定cookie的当前目录及其子目录。$domain - 指定此cookie所属服务器的网址名称，预设是建立此cookie服务器的网址。 要是cookie能在如abc.com域名下的所有子域都有效，则该参赛应设为'.abc.com'。$secure - 指明cookie是否仅通过安全的HTTPS连接传送中的cookie的安全识别常数，如果设定该值则代表只有在某种情况下才能在客户端与服务端之间传递。 当设成true时，cookie仅在安全的连接中被设置。默认值为false。// 读取- 浏览器请求时会携带当前域名下的所有cookie信息到服务器。- 任何从客户端发送的cookie都会被自动存入$_COOKIE全局数组。- 如果希望对一个cookie变量设置多个值，则需在cookie的名称后加[]符号。即以数组形态保存多条数据到同一变量。 //设置为$_COOKIE['user']['name']，注意user[name]的name没有引号 setcookie('user[name]', 'shocker');- $_COOKIE也可以为索引数组// 删除方法1：将其值设置为空字符串 setcookie('user[name]', '');方法2：将目标cookie设为“已过期”状态。 //将cookie的生存时间设置为过期，则生存期限与浏览器一样，当浏览器关闭时就会被删除。 setcookie('usr[name]', '', time()-1);# 注意：1. cookie只能保存字符串数据2. $_COOKIE只用于接收cookie数据，不用于设置或管理cookie数据。 对$_COOKIE进行操作不会影响cookie数据。 $_COOKIE只会保存浏览器在请求时所携带的cookie数据。3. cookie生命周期： 临时cookie：浏览器关闭时被删除 持久cookie：$expire参数为时间戳，表示失效时间。4. 有效目录 cookie只在指定的目录有效。默认是当前目录及其子目录。 子目录的cookie在其父目录或同级目录不可获取。5. cookie区分域名 默认是当前域名及其子域名有效。6. js中通过document.cookie获得，类型为字符串7. 浏览器对COOKIE总数没有限制，但对每个域名的COOKIE数量和每个COOKIE的大小有限，而且不同浏览器的限制不同。 URL函数12345678get_headers — 取得服务器响应一个 HTTP 请求所发送的所有标头get_meta_tags — 从一个文件中提取所有的 meta 标签 content 属性，返回一个数组http_build_query — 生成 URL-encode 之后的请求字符串urldecode — 解码已编码的URL字符串urlencode — 编码URL字符串parse_url — 解析URL，返回其组成部分 'http://username:password@hostname/path?arg=value#anchor' scheme(如http), host, port, user, pass, path, query(在问号?之后), fragment(在散列符号#之后) Session1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781. 开启session机制 session_start() 注意：session_start()函数前不能有输出！除非开启ob缓存。2. 操作数据 对$_SESSION数组进行操作3. 浏览器端保存SessionID，默认为当前域名下的所有目录及其子目录生效。即默认设置cookie的path值为'/'4. 服务器保存session数据 默认保存方式：每个会话都会生成一个session数据文件，文件名为：sess_加SessionID5. session可以存储除了资源以外的任何类型数据。 数据被序列化后再保存到文件中。6. $_SESSION的元素下标不能为整型！ 因为只对元素值进行序列化。 元素内的数组下标无此要求。7. 生存周期 默认是浏览器关闭 因为浏览器保存的cookie变量SessionID是临时的 但是服务器端的session数据文件不一定消失（需要等待session的垃圾回收机制来处理） 可以延长cookie中PHPSESSID变量的生命周期。（不推荐） php.ini配置session.gc_maxlifetime8. 删除数据 $_SESSION变量在脚本结束时依然会消失。开启session机制时会造出$_SESSION变量。 $_SESSION与保存session数据的文件是两个空间。 unset($_SESSION['key'])只是删除数组内的该元素，不会立即相应到保存session数据的文件上。 等到脚本结束，才会将$_SESSION的数据写入到该文件中。 session_destroy() 销毁保存session数据的文件，也不会对该文件写入内容。 并不删除$_SESSION变量，unset或脚本结束才会删除该变量。 如何完全删除一个session？需删除3部分 unset($_SESSION); 删除$_SESSION变量后，数据文件并未被改动。如果单独使用unset，则需先置空$_SESSION = array() session_destroy(); setcookie('PHPSESSID', '', time()-1); //保险做法是将其生命周期失效 整个脚本周期内，只对数据文件读一次、写一次。// 重写session的存储机制# session存储方式session.save_handler = user|files|memcache# 因数据文件过多导致的问题，可通过分子目录保存进行解决PHP配置文件下session.save_path选项，并需手动创建数据存放目录。在该配置选项前加层级。分布子目录的原则，利用会话ID的相应字母来分配子目录。仍需手动创建子目录。session.save_path = \"2; F:/PHPJob/Temp\"# 多服务器数据共享问题# 数据存储操作： 初始化$open、释放资源$close、读$read、写$write、销毁存储介质$destroy(调用session_destroy时触发该操作)、垃圾回收$gc# 会话ID的长度可变。不同的设置方式导致不同长度的会话ID。session.hash_function 允许用户指定生成会话ID的散列算法。 '0' 表示MD5（128 位），'1' 表示SHA-1（160 位）。session.hash_bits_per_character 允许用户定义将二进制散列数据转换为可读的格式时每个字符存放多少个比特。 可能值为 '4'（0-9，a-f），'5'（0-9，a-v），以及 '6'（0-9，a-z，A-Z，\"-\"，\",\"）。 总hash长度为128bit，会话ID长度为128/可能值，4-&gt;32, 5-&gt;26, 6-&gt;22# 自定义数据存储操作方法# 注意：不用关心PHP如何序列化、反序列化、如何得到数据和写入数据，只做与数据存储相关的操作session_set_save_handler 设置用户自定义的会话数据存储函数 bool session_set_save_handler(callable $open, callable $close, callable $read, callable $write, callable $destroy, callable $gc)执行顺序：open, close, read, write, destroy, gc# 先设置处理器，再开启会话# 常用函数session_start 开启或恢复会话机制session_id 获取或设置当前会话IDsession_destroy 销毁当前会话的所有数据（销毁数据文件）session_name 获取或设置当前会话名称（cookie变量名，默认为PHPSESSID）session_save_path 获取或设置当前会话数据文件保存路径session_set_save_handler 设置用户自定义的会话数据存储函数session_unset 释放所有会话变量(清空$_SESSION数组元素)session_encode 将当前会话数据编码为一个字符串session_decode 将字符串解译为会话数据session_write_close 写入会话数据并关闭会话session_register_shutdown 关闭会话session_set_cookie_params 设置会话cookie变量，必须在session_start()前使用。 session_set_cookie_params(0,\"/webapp/\"); //设置session生存时间session_get_cookie_params 获取会话cookie变量。返回包含当前会话cookie信息的数组# 配置php.iniini_set($varname, $newvalue); //该函数的配置只对当前脚本生效 //并非所有php.ini设置均可用该函数设置ini_get($varname) //获取某配置项信息ini_get_all([str $extension]) //返回所有配置项信息的数组 类型操作函数123456789101112131415161718192021222324252627282930313233343536373839//获取/设置类型gettype($var) //获取变量的数据类型settype($var, $type) //设置变量的数据类型//类型判断is_intis_floatis_nullis_stringis_resourceis_arrayis_boolis_object is_numeric 检测变量是否为数字或数字字符串//转换成指定的数据类型boolvalfloatvalintvalstrval//强制转换类型(int)(float)(string)(bool)(array)(object)(unset) //转换为NULL(binary) 转换和 b前缀转换 //转换成二进制var_dump 打印变量的相关信息。 显示关于一个或多个表达式的结构信息，包括表达式的类型与值。 数组将递归展开值，通过缩进显示其结构。var_export($var [,bool $return]) //输出或返回一个变量的字符串表示 $return：为true，则返回变量执行后的结果print_r 打印关于变量的易于理解的信息empty 检查一个变量是否为空isset 检测变量是否存在 数组函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//统计计算count 计算数组中的单元数目或对象中的属性个数array_count_values 统计数组中所有的值出现的次数array_product 计算数组中所有值的乘积array_sum 计算数组中所有值的和range 建立一个包含指定范围单元的数组//获取数组内容array_chunk 将一个数组分割成多个 array array_chunk(array $input, int $size[, bool $preserve_keys]) array_filter 用回调函数过滤数组中的单元array_slice 从数组中取出一段 array array_slice($arr, $offset [,$len [,$preserve_keys]])array_keys 返回数组中所有的键名 array array_keys(array $input[, mixed $search_value[, bool $strict]] ) 如果指定了可选参数 search_value，则只返回该值的键名。否则input数组中的所有键名都会被返回。array_values 返回数组中所有的值，并建立数字索引array_merge 合并一个或多个数组 一个数组中的值附加在前一个数组的后面。 如果输入的数组中有相同的字符串键名，则该键名后面的值将覆盖前一个值。 如果数组包含数字键名，后面的值将不会覆盖原来的值，而是附加到后面。 如果只给了一个数组并且该数组是数字索引的，则键名会以连续方式重新索引。 array_merge_recursive 递归地合并一个或多个数组//搜索in_array 检查数组中是否存在某个值 bool in_array(mixed $needle, array $haystack[, bool $strict])array_key_exists 检查给定的键名或索引是否存在于数组中 isset()对于数组中为NULL的值不会返回TRUE，而 array_key_exists()会array_search 在数组中搜索给定的值，如果成功则返回相应的键名array_combine 创建一个数组，用一个数组的值作为其键名，另一个数组的值作为其值 如果两个数组的单元数不同或者数组为空时返回FALSE。array_rand 从数组中随机取出一个或多个单元，返回键名或键名组成的数组，下标是自然排序的array_fill 用给定的值填充数组 array_fill($start, $num, $value)array_flip 交换数组中的键和值array_pad 用值将数组填补到指定长度array_reverse 返回一个单元顺序相反的数组array_unique 移除数组中重复的值array_splice 把数组中的一部分去掉并用其它值取代implode 将数组元素值用某个字符串连接成字符串explode($delimiter, $str [,$limit]) //使用一个字符串分割另一个字符串 $delimiter不能为空字符串\"\"array_map 将回调函数作用到给定数组的单元上，只能处理元素值，可以处理多个数组 如果callback参数设为null，则合并多个数组为一个多维数组array_walk 对数组中的每个成员应用用户函数，只能处理一个数组，键和值均可处理，与foreach功能相同 bool array_walk ( array &amp;$array , callback $funcname [, mixed $userdata ] )//栈：后进先出入栈和出栈会重新分配索引下标array_push 将一个或多个单元压入数组的末尾（入栈）array_pop 将数组最后一个单元弹出（出栈） 使用此函数后会重置(reset())array 指针。//队列：先进先出队列函数会重新分配索引下标array_unshift 在数组开头插入一个或多个单元array_shift 将数组开头的单元移出数组 使用此函数后会重置(reset())array 指针。//排序函数sort 对数组排序rsort 对数组逆向排序asort 对数组进行排序并保持索引关系arsort 对数组进行逆向排序并保持索引关系ksort 对数组按照键名排序krsort 对数组按照键名逆向排序usort 使用用户自定义的比较函数对数组中的值进行排序uksort 使用用户自定义的比较函数对数组中的键名进行排序uasort 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联natsort 用用“自然排序”算法对数组排序natcasesort 用“自然排序”算法对数组进行不区分大小写字母的排序array_multisort 对多个数组或多维数组进行排序shuffle 将数组打乱 引用传递参数，返回bool值。 重新赋予索引键名，删除原有键名//差集array_udiff_assoc 带索引检查计算数组的差集，用回调函数比较数据array_udiff_uassoc 带索引检查计算数组的差集，用回调函数比较数据和索引array_udiff 用回调函数比较数据来计算数组的差集array_diff_assoc 带索引检查计算数组的差集array_diff_key 使用键名比较计算数组的差集array_diff_uassoc 用用户提供的回调函数做索引检查来计算数组的差集array_diff_ukey 用回调函数对键名比较计算数组的差集array_diff 计算数组的差集//交集array_intersect_assoc 带索引检查计算数组的交集array_intersect_key 使用键名比较计算数组的交集array_intersect_uassoc 带索引检查计算数组的交集，用回调函数比较索引array_intersect_ukey 用回调函数比较键名来计算数组的交集array_intersect 计算数组的交集array_key_exists 用回调函数比较键名来计算数组的交集array_uintersect_assoc 带索引检查计算数组的交集，用回调函数比较数据array_uintersect 计算数组的交集，用回调函数比较数据extract($arr [,$type [,$prefix]]) 从数组中将变量导入到当前的符号表(接受结合数组$arr作为参数并将键名当作变量名，值作为变量的值)compact($var [,...]) 建立一个数组，包括变量名和它们的值(变量名成为键名而变量的内容成为该键的值) 文件、目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061dirname($path) 返回路径中的目录部分basename($path [,$suffix]) 返回路径中的文件名部分pathinfo($path [,$options]) 返回文件路径的信息(数组元素：dirname,basename,extension)realpath($path) 返回规范化的绝对路径名copy($source, $dest) 拷贝文件unlink($file) 删除文件rename($old, $new) 重命名或移动一个文件或目录mkdir($path [,$mode [,$recursive]]) 新建目录 $mode表示权限，默认0777 $recursive表示可创建多级目录，默认falsermdir($dir) 删除目录(目录必须为空，且具有权限)file_exists($file) 检查文件或目录是否存在is_file($file) 判断文件是否存在且为正常的文件is_dir($file) 判断文件名是否存在且为目录is_readable($file) 判断文件或目录是否可读is_writable($file) 判断文件或目录是否可写is_executable($file) 判断给定文件名是否可执行is_link($file) 判断给定文件名是否为一个符号连接tmpfile(void) 建立一个临时文件tempnam($dir, $prefix) 在指定目录中建立一个具有唯一文件名的文件file($file) 把整个文件读入一个数组中fopen($filename, $mode [,$use_include_path]) $mode参数：(加入'b'标记解决移植性) 'r' 只读方式打开，将文件指针指向文件头。 'r+' 读写方式打开，将文件指针指向文件头。 'w' 写入方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 'w+' 读写方式打开，将文件指针指向文件头并将文件大小截为零。如果文件不存在则尝试创建之。 'a' 写入方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 'a+' 读写方式打开，将文件指针指向文件末尾。如果文件不存在则尝试创建之。 'x' 创建并以写入方式打开，将文件指针指向文件头。 'x+' 创建并以读写方式打开，将文件指针指向文件头。fclose($handle) 关闭一个已打开的文件指针fread($handle, $length) 读取文件（可安全用于二进制文件）fwrite($handle, $string [,$length]) 写入文件（可安全用于二进制文件）rewind($handle) 倒回文件指针的位置ftell($handle) 返回文件指针读/写的位置fseek($handle, $offset [,$whence]) 在文件指针中定位feof($handle) 测试文件指针是否到了文件结束的位置fgets 从文件指针中读取一行fgetss 从文件指针中读取一行并过滤掉HTML标记flock($handle, $opt) 轻便的咨询文件锁定 $opt：LOCK_SH 取得共享锁定（读取的程序）；LOCK_EX 取得独占锁定（写入的程序）；LOCK_UN 释放锁定（无论共享或独占）readfile($file) 读入一个文件并写入到输出缓冲fflush($handle) 将缓冲内容输出到文件touch($file [,$time [,$atime]]) 设定文件的访问和修改时间fileatime 取得文件的上次访问时间filectime 取得文件的inode修改时间filegroup 取得文件的组fileinode 取得文件的inodefilemtime 取得文件修改时间fileowner 取得文件的所有者fileperms 取得文件的权限filesize 取得文件大小filetype 取得文件类型 文件上传12345678910111213141516171819202122232425262728293031323334enctype=\"multipart/form-data\" //FORM标签必须的属性$_FILES 上传文件信息数组变量error 上传错误信息 0 无错误 1 文件大小超过php.ini配置 1) upload_max_filesize 允许上传的最大文件大小 2) post_max_size 最大的POST数据大小 3) memory_limit 每个脚本能够使用的最大内存数量(默认128MB) 2 文件大小超过浏览器表单配置 MAX_FILE_SIZE 表示表单数据最大文件大小，该元素需在文件上传域之前。(默认2M) &lt;input type=\"hidden\" name=\"MAX_FILE_SIZE\" value=\"102400\"&gt; 3 文件只有部分被上传 4 文件没有被上传 6,7 临时文件写入时失败 6 找不到临时文件 7 文件写入失败name 文件名type 文件类型tmp_name 上传文件临时路径size 文件大小move_uploaded_file($path, $newpath); //将上传的文件移动到新位置is_uploaded_file($file) //判断是否为POST上传的文件//多文件上传&lt;input type=\"file\" name=\"updfile[]\" /&gt; //HTML中以数组提交$_FILES['updfile']['tmp_name'][0] //服务器端可访问第一个文件的临时路径，其他属性类似//php.ini配置file_uploads = On 是否允许HTTP上传文件upload_max_filesize 上传文件大小限制，默认为2Mpost_max_size post方式表单数据总大小限制，默认为8Mupload_tmp_dir 上传文件临时目录，默认是系统临时目录 需设置上传文件临时目录，给其最小权限GET方式的最大传输量为2K 数据库相关数据库操作12345678910111213141516#连接认证mysql_connect 连接并认证数据库#发送SQL语句，接收执行结果mysql_query 发送SQL语句 仅对select, show, explain, describe语句执行成功返回一个资源标识符，其他语句成功返回true。执行失败均返回false。#处理结果mysql_fetch_assoc 从结果集中取得一行作为关联数组 每次只取回一条，类似each 结果集中记录指针mysql_fetch_row 从结果集中取得一行作为枚举数组mysql_fetch_array 从结果集中取得一行作为关联数组，或数字数组，或二者兼有 array mysql_fetch_array ( resource $result [, int $ result_type ] ) 可选参数result_type可选值为：MYSQL_ASSOC，MYSQL_NUM 和 MYSQL_BOTH(默认)mysql_free_result 释放结果内存#关闭链接mysql_close 关闭连接 代码复用基础代码 PHP加密解密 123456789101112131415161718192021222324252627282930&lt;?phpfunction encryptDecrypt($key, $string, $decrypt)&#123; if($decrypt)&#123; $decrypted = rtrim(mcrypt_decrypt( MCRYPT_RIJNDAEL_256, md5($key), base64_decode($string), MCRYPT_MODE_CBC, md5(md5($key))), \"12\"); return $decrypted; &#125;else&#123; $encrypted = base64_encode(mcrypt_encrypt( MCRYPT_RIJNDAEL_256, md5($key), $string, MCRYPT_MODE_CBC, md5(md5($key)))); return $encrypted; &#125;&#125;//以下是将字符串“Hello欢迎您”分别加密和解密//加密：echo encryptDecrypt('password', 'Hello欢迎您',0).PHP_EOL;//解密：echo encryptDecrypt('password', 'wA88E1Qs286hmS9tJvkHmiza2lwnW3pDAeiznKVbwEE=',1); PHP生成随机字符串 12345678910function generateRandomString($length = 10) &#123; $char = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'; $randomStr = ''; for ($i = 0; $i &lt; $length; $i++) &#123; $randomStr .= $char[rand(0, strlen($char) - 1)]; &#125; return $randomStr;&#125;echo generateRandomString(20); PHP获取文件扩展名（后缀） 12345678function getSuffix($filename)&#123; $ext = substr($filename, strrpos($filename, '.')); return str_replace('.','',$ext);&#125;$filename = '我的文档.doc';echo getSuffix($filename); PHP获取文件大小并格式化 1234567891011function formatSize($size) &#123; $sizes = array(\" Bytes\", \" KB\", \" MB\", \" GB\", \" TB\", \" PB\", \" EB\", \" ZB\", \" YB\"); if ($size == 0) &#123; return('n/a'); &#125; else &#123; return (round($size/pow(1024, ($i = floor(log($size, 1024)))), 2) . $sizes[$i]); &#125;&#125;$thefile = filesize('API');echo formatSize($thefile); PHP替换标签字符 12345678910function stringParser($string,$replacer)&#123; $result = str_replace(array_keys($replacer), array_values($replacer),$string); return $result;&#125;$string = 'The &#123;b&#125;anchor text&#123;/b&#125; is the &#123;b&#125;actual word&#123;/b&#125; or words used &#123;br&#125;to describe the link &#123;br&#125;itself';$replace_array = array('&#123;b&#125;' =&gt; '&lt;b&gt;','&#123;/b&#125;' =&gt; '&lt;/b&gt;','&#123;br&#125;' =&gt; '&lt;br /&gt;');echo stringParser($string,$replace_array); PHP列出目录下的文件名 123456789101112function listDirFiles($DirPath)&#123; if($dir = opendir($DirPath))&#123; while(($file = readdir($dir))!== false)&#123; if(!is_dir($DirPath.$file)) &#123; echo \"filename: $file&lt;br /&gt;\"; &#125; &#125; &#125;&#125;listDirFiles('../test.com/'); PHP获取当前页面UR 123456789101112131415161718192021function currentPageURL() &#123; $pageURL = 'http'; if (!empty($_SERVER['HTTPS'])) &#123; $pageURL .= \"s\"; &#125; $pageURL .= \"://\"; if ($_SERVER[\"SERVER_PORT\"] != \"80\") &#123; $pageURL .= $_SERVER[\"SERVER_NAME\"] .\":\" .$_SERVER[\"SERVER_PORT\"] .$_SERVER[\"REQUEST_URI\"]; &#125; else &#123; $pageURL .= $_SERVER[\"SERVER_NAME\"] .$_SERVER[\"REQUEST_URI\"]; &#125; return $pageURL;&#125;echo currentPageURL(); PHP强制下载文件 123456789101112function download($filename)&#123; if ((isset($filename))&amp;&amp;(file_exists($filename)))&#123; header(\"Content-length: \".filesize($filename)); header('Content-Type: application/octet-stream'); header('Content-Disposition: attachment; filename=\"' . $filename . '\"'); readfile(\"$filename\"); &#125; else &#123; echo \"Looks like file does not exist!\"; &#125;&#125;download('download/test.zip'); PHP获取客户端真实IP 1234567891011121314151617181920212223242526function getIp() &#123; if ( getenv(\"HTTP_CLIENT_IP\") &amp;&amp; strcasecmp(getenv(\"HTTP_CLIENT_IP\"), \"unknown\") ) &#123; $ip = getenv(\"HTTP_CLIENT_IP\"); &#125; elseif (getenv(\"HTTP_X_FORWARDED_FOR\") &amp;&amp; strcasecmp(getenv(\"HTTP_X_FORWARDED_FOR\"), \"unknown\") ) &#123; $ip = getenv(\"HTTP_X_FORWARDED_FOR\"); &#125; elseif (getenv(\"REMOTE_ADDR\") &amp;&amp; strcasecmp(getenv(\"REMOTE_ADDR\"), \"unknown\") )&#123; $ip = getenv(\"REMOTE_ADDR\"); &#125; elseif (isset ($_SERVER['REMOTE_ADDR']) &amp;&amp; $_SERVER['REMOTE_ADDR'] &amp;&amp; strcasecmp($_SERVER['REMOTE_ADDR'], \"unknown\") ) &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; else &#123; $ip = \"unknown\"; &#125; return ($ip);&#125;echo getIp(); 获取客户端IP 123456789101112131415161718192021222324function getClientIp() &#123; $ip = NULL; if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $arr = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $pos = array_search('unknown',$arr); if(false !== $pos) unset($arr[$pos]); $ip = trim($arr[0]); &#125; elseif (isset($_SERVER['HTTP_CLIENT_IP'])) &#123; $ip = $_SERVER['HTTP_CLIENT_IP']; &#125; elseif (isset($_SERVER['REMOTE_ADDR'])) &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; // IP地址合法验证 $ip = (false !== ip2long($ip)) ? $ip : '0.0.0.0'; return $ip;&#125;$ip = getClientIp();echo $ip; PHP计算时长(将秒数转化为时分秒格式) 1234567891011121314function changeTimeType($seconds) &#123; if ($seconds &gt; 3600) &#123; $hours = intval($seconds / 3600); $minutes = $seconds % 3600; $time = $hours . \":\" . gmstrftime('%M:%S', $minutes); &#125; else &#123; $time = gmstrftime('%H:%M:%S', $seconds); &#125; return $time;&#125;$seconds = 3512;$seconds = 3712;echo changeTimeType($seconds); 16进制颜色转10进制颜色 1234567891011121314151617181920212223242526function hex2rgb($hexcolor)&#123; $color = str_replace('#', '', $hexcolor); if (strlen($color) &gt; 3) &#123; $rgb = array( 'r' =&gt; hexdec(substr($color, 0, 2)), 'g' =&gt; hexdec(substr($color, 2, 2)), 'b' =&gt; hexdec(substr($color, 4, 2)) ); &#125; else &#123; $r = substr($color, 0, 1) . substr($color, 0, 1); $g = substr($color, 1, 1) . substr($color, 1, 1); $b = substr($color, 2, 1) . substr($color, 2, 1); $rgb = array( 'r' =&gt; hexdec($r), 'g' =&gt; hexdec($g), 'b' =&gt; hexdec($b) ); &#125; return $rgb;&#125;$hex = '#fffeff';$hex = '#ffe';var_dump(hex2rgb($hex)); Header头文件设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?php//定义编码header( 'Content-Type:text/html;charset=utf-8 ');//Atomheader('Content-type: application/atom+xml');//CSSheader('Content-type: text/css');//Javascriptheader('Content-type: text/javascript');//JPEG Imageheader('Content-type: image/jpeg');//JSONheader('Content-type: application/json');//PDFheader('Content-type: application/pdf');//RSSheader('Content-Type: application/rss+xml; charset=ISO-8859-1');//Text (Plain)header('Content-type: text/plain');//XMLheader('Content-type: text/xml');// okheader('HTTP/1.1 200 OK');//设置一个404头:header('HTTP/1.1 404 Not Found');//设置地址被永久的重定向header('HTTP/1.1 301 Moved Permanently');//转到一个新地址header('Location: http://www.jbxue.com/');//文件延迟转向:header('Refresh: 10; url=http://www.jbxue.com/');print 'You will be redirected in 10 seconds';//当然，也可以使用html语法实现// &lt;meta http-equiv=\"refresh\" content=\"10;http://www.jbxue.com/ /&gt;// override X-Powered-By: PHP:header('X-Powered-By: PHP/4.4.0');header('X-Powered-By: Brain/0.6b');//文档语言header('Content-language: en');//告诉浏览器最后一次修改时间$time = time() - 60; // or filemtime($fn), etcheader('Last-Modified: '.gmdate('D, d M Y H:i:s', $time).' GMT');//告诉浏览器文档内容没有发生改变header('HTTP/1.1 304 Not Modified');//设置内容长度header('Content-Length: 1234');//设置为一个下载类型header('Content-Type: application/octet-stream');header('Content-Disposition: attachment; filename=\"example.zip\"');header('Content-Transfer-Encoding: binary');// load the file to send:readfile('example.zip');// 对当前文档禁用缓存header('Cache-Control: no-cache, no-store, max-age=0, must-revalidate');header('Expires: Mon, 26 Jul 1997 05:00:00 GMT'); // Date in the pastheader('Pragma: no-cache');//设置内容类型:header('Content-Type: text/html; charset=iso-8859-1');header('Content-Type: text/html; charset=utf-8');header('Content-Type: text/plain'); //纯文本格式header('Content-Type: image/jpeg'); //JPG***header('Content-Type: application/zip'); // ZIP文件header('Content-Type: application/pdf'); // PDF文件header('Content-Type: audio/mpeg'); // 音频文件header('Content-Type: application/x-shockw**e-flash'); //Flash动画//显示登陆对话框header('HTTP/1.1 401 Unauthorized');header('WWW-Authenticate: Basic realm=\"Top Secret\"');print 'Text that will be displayed if the user hits cancel or ';print 'enters wrong login data'; Http_request 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public function _request($url, $method, $body=null, $times=1) &#123; $this-&gt;log(\"Send \" . $method . \" \" . $url . \", body:\" . $body . \", times:\" . $times); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_HEADER, true); // 设置User-Agent curl_setopt($ch, CURLOPT_USERAGENT, self::USER_AGENT); // 连接建立最长耗时 curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, self::CONNECT_TIMEOUT); // 请求最长耗时 curl_setopt($ch, CURLOPT_TIMEOUT, self::READ_TIMEOUT); // 设置SSL版本 curl_setopt($ch, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // 如果报证书相关失败,可以考虑取消注释掉该行,强制指定证书版本 //curl_setopt($ch, CURLOPT_SSL_CIPHER_LIST, 'TLSv1'); // 设置Basic认证 curl_setopt($ch, CURLOPT_HTTPAUTH, CURLAUTH_BASIC); curl_setopt($ch, CURLOPT_USERPWD, $this-&gt;appKey . \":\" . $this-&gt;masterSecret); // 设置Post参数 if ($method === self::HTTP_POST) &#123; curl_setopt($ch, CURLOPT_POST, true); &#125; else if ($method === self::HTTP_DELETE || $method === self::HTTP_PUT) &#123; curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method); &#125; if (!is_null($body)) &#123; curl_setopt($ch, CURLOPT_POSTFIELDS, $body); &#125; // 设置headers curl_setopt($ch, CURLOPT_HTTPHEADER, array( 'Content-Type: application/json', 'Connection: Keep-Alive' )); // 执行请求 $output = curl_exec($ch); // 解析Response $response = array(); $errorCode = curl_errno($ch); $this-&gt;log(array($output, $errorCode)); if ($errorCode) &#123; if ($errorCode === 28) &#123; throw new APIConnectionException(\"Response timeout. Your request has probably be received by JPush Server,please check that whether need to be pushed again.\", true); &#125; else if ($errorCode === 56) &#123; // resolve error[56 Problem (2) in the Chunked-Encoded data] throw new APIConnectionException(\"Response timeout, maybe cause by old CURL version. Your request has probably be received by JPush Server, please check that whether need to be pushed again.\", true); &#125; else if ($times &gt;= $this-&gt;retryTimes) &#123; throw new APIConnectionException(\"Connect timeout. Please retry later. Error:\" . $errorCode . \" \" . curl_error($ch)); &#125; else &#123; $this-&gt;log(\"Send \" . $method . \" \" . $url . \" fail, curl_code:\" . $errorCode . \", body:\" . $body . \", times:\" . $times); $this-&gt;_request($url, $method, $body, ++$times); &#125; &#125; else &#123; $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); $header_size = curl_getinfo($ch, CURLINFO_HEADER_SIZE); $header_text = substr($output, 0, $header_size); $body = substr($output, $header_size); $headers = array(); foreach (explode(\"\\r\\n\", $header_text) as $i =&gt; $line) &#123; if (!empty($line)) &#123; if ($i === 0) &#123; $headers['http_code'] = $line; &#125; else if (strpos($line, \": \")) &#123; list ($key, $value) = explode(': ', $line); $headers[$key] = $value; &#125; &#125; &#125; $response['headers'] = $headers; $response['body'] = $body; $response['http_code'] = $httpCode; &#125; curl_close($ch); return $response; &#125; MakeDir 12345678910111213141516public static function mkdir($dir, $mode = 0777, $makeindex = true)&#123; if(!is_dir($dir)) &#123; if(preg_match('/\\.(asp|php|aspx|jsp|cgi)/i', $dir))&#123; return false; &#125;else if(preg_match('/;/i', $dir))&#123; return false; &#125; self::mkdir(dirname($dir), $mode, $makeindex); @mkdir($dir, $mode); if(!empty($makeindex)) &#123; @touch($dir.'/index.html'); @chmod($dir.'/index.html', 0777); &#125; &#125; return true;&#125; createDir 12345678910111213141516171819public static function create($dir, $mode=0777, $makeindex=false)&#123; $dir = rtrim(str_replace(array('/', '\\\\'), DIRECTORY_SEPARATOR, $dir), DIRECTORY_SEPARATOR); return self::mkdir($dir, $mode, $makeindex); //在php设置为base_dir的时候会出错改用self::mkdir递归来创建 if(!file_exists($dir))&#123; if(!$arr = explode(DIRECTORY_SEPARATOR, $dir))&#123; return false; &#125; $path = ''; foreach ($arr as $k=&gt;$v) &#123; $path .= $v . DIRECTORY_SEPARATOR; if ($k &gt; 0 &amp;&amp; !file_exists($path)) &#123; mkdir($path); &#125; &#125; &#125; return true;&#125; generateQRCodeImage 123456789101112131415// 生成一个二维码图片public function generateQRCodeImage( $content, $errorLevel = 'L', $pointSize = 10, $margin = 1)&#123; if (!class_exists('QRcode')) &#123; include_once __CORE_DIR.'libs/qrcode/phpqrcode.php'; &#125; QRcode::png($content, false, $errorLevel, $pointSize, $margin); exit;&#125; base64转文件输出 1234567function base64ToFile($base64_data, $file)&#123; if(!$base64_data || !$file)&#123; return false; &#125; return file_put_contents($file, base64_decode($base64_data), true);&#125; getJWTString 12345678910111213141516public function getJWTString($params = [])&#123; $header = base64_encode(json_encode([ 'typ' =&gt; 'JWT', 'alg' =&gt; 'SHA256', ])); $claims = [ 'exp' =&gt; __TIME+604800, // 1 week 'nbf' =&gt; __TIME, 'iat' =&gt; __TIME, ]; $payload = base64_encode(json_encode(array_merge($params, $claims))); $signature = base64_encode(hash_hmac('sha256', $header.'.'.$payload, __CFG::JWT_SECRET_KEY)); return implode('.', [$header, $payload, $signature]);&#125; http_get 123456789101112131415161718private function http_get($url)&#123; $oCurl = curl_init(); if (stripos($url, \"https://\" ) !== FALSE)&#123; curl_setopt($oCurl, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($oCurl, CURLOPT_SSL_VERIFYHOST, FALSE); &#125; curl_setopt($oCurl, CURLOPT_URL, $url); curl_setopt($oCurl, CURLOPT_RETURNTRANSFER, 1); $sContent = curl_exec($oCurl); $aStatus = curl_getinfo($oCurl); curl_close($oCurl ); if (intval($aStatus [\"http_code\"]) == 200) &#123; return $sContent; &#125; else &#123; return false; &#125;&#125; http_post 1234567891011121314151617181920212223242526272829private function http_post($url, $param)&#123; $oCurl = curl_init (); if (stripos ( $url, \"https://\" ) !== FALSE) &#123; curl_setopt ( $oCurl, CURLOPT_SSL_VERIFYPEER, FALSE ); curl_setopt ( $oCurl, CURLOPT_SSL_VERIFYHOST, false ); &#125; if (is_string ( $param )) &#123; $strPOST = $param; &#125; else &#123; $aPOST = array (); foreach ( $param as $key =&gt; $val ) &#123; $aPOST [] = $key . \"=\" . urlencode ( $val ); &#125; $strPOST = join ( \"&amp;\", $aPOST ); &#125; curl_setopt ( $oCurl, CURLOPT_URL, $url ); curl_setopt ( $oCurl, CURLOPT_RETURNTRANSFER, 1 ); curl_setopt ( $oCurl, CURLOPT_POST, true ); curl_setopt ( $oCurl, CURLOPT_POSTFIELDS, $strPOST ); $sContent = curl_exec ( $oCurl ); $aStatus = curl_getinfo ( $oCurl ); curl_close ( $oCurl ); if (intval ( $aStatus [\"http_code\"] ) == 200) &#123; return $sContent; &#125; else &#123; return false; &#125;&#125; 框架相关使用 VarDumper 进行优雅的 PHP 调试12345678910111213全局安装Symfony VarDumper，这样不仅可以解决样式一次性问题，还可以让你在任何项目中使用Symfony VarDumper，安装方法如下：第一步，全局安装：composer global require symfony/var-dumper;第二：配置php.ini在php.ini中找到auto_prepend_file，然后写上你相对应的路径，比如像下面这样的： auto_prepend_file = $&#123;HOME&#125;/.composer/vendor/autoload.php 最后，更新composer直接命令行执行：composer global update 服务器网站高并发 大流量访问的处理及解决方法第一，确认服务器硬件是否足够支持当前的流量。普通的P4服务器一般最多能支持每天10万独立IP，如果访问量比这个还要大， 那么必须首先配置一台更高性能的专用服务器才能解决问题 ，否则怎么优化都不可能彻底解决性能问题。 第二，优化数据库访问。前台实现完全的静态化当然最好，可以完全不用访问数据库，不过对于频繁更新的网站， 静态化往往不能满足某些功能。 缓存技术就是另一个解决方案，就是将动态数据存储到缓存文件中，动态网页直接调用 这些文件，而不必再访问数据库，WordPress和Z-Blog都大量使用这种缓存技术。 如果确实无法避免对数据库的访问，那么可以尝试优化数据库的查询SQL.避免使用 Select * from这样的语句，每次查询只返回自己需要的结果，避免短时间内的大,尽量做到”所查即所得” ,遵循以小表为主,附表为辅,查询条件先索引,先小后大的原则,提高查询效率.量SQL查询。 第三，禁止外部的盗链。外部网站的图片或者文件盗链往往会带来大量的负载压力，因此应该严格限制外部对于自身的图片或者文件盗链，好在目前可以简单地通过refer来控制盗链，Apache自 己就可以通过配置来禁止盗链，IIS也有一些第三方的ISAPI可以实现同样的功能。当然，伪造refer也可以通过代码来实现盗链，不过目前蓄意伪造refer盗链的还不多， 可以先不去考虑，或者使用非技术手段来解决，比如在图片上增加水印。 第四，控制大文件的下载。大文件的下载会占用很大的流量，并且对于非SCSI硬盘来说，大量文件下载会消耗 CPU，使得网站响应能力下降。因此，尽量不要提供超过2M的大文件下载，如果需要提供，建议将大文件放在另外一台服务器上。 第五，使用不同主机分流主要流量将文件放在不同的主机上，提供不同的镜像供用户下载。比如如果觉得RSS文件占用流量大，那么使用FeedBurner或者FeedSky等服务将RSS输出放在其他主机上，这样别人访问的流量压力就大多集中在FeedBurner的主机上，RSS就不占用太多资源了。 第六，使用流量分析统计软件。在网站上安装一个流量分析统计软件，可以即时知道哪些地方耗费了大量流量，哪些页面需要再进行优化，因此，解决流量问题还需要进行精确的统计分析才可以。我推荐使用的流量分析统计软件是Google Analytics（Google分析）。若还有其他的流量分析软件,欢迎共享交流 太多了~~ 看到自己想吐~~","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP 基础知识","slug":"PHP-基础知识","permalink":"http://blog.caoxl.com/tags/PHP-基础知识/"}]},{"title":"基于Lumen-几种缓存方法","slug":"Lumen-Cache-Memcache-Redis","date":"2018-08-13T02:59:07.000Z","updated":"2019-08-22T06:17:35.000Z","comments":true,"path":"2018/08/13/Lumen-Cache-Memcache-Redis/","link":"","permalink":"http://blog.caoxl.com/2018/08/13/Lumen-Cache-Memcache-Redis/","excerpt":"缓存时PHPer优化所必备的一个知识点","text":"缓存时PHPer优化所必备的一个知识点 配置首先，修改.env文件配置缓存的驱动方式 12// 缓存驱动方式：apc, array, database, file, memcached, redisCACHE_DRIVER=memcached apc: APC驱动，APC是PHP的一个扩展，其目标是为缓存和优化PHP中间码（opcode）提供一个免费、开源、健壮的框架 array: 数组驱动，往往仅仅用于测试，好处是不会持久化，只会在一次PHP脚本执行的生命周期内有效 database: 数据库驱动，需参考下面代码在数据库中建立缓存表，并设置CACHE_DATABASE_TABLE和CACHE_DATABASE_CONNECTION 12345Schema::create('cache', function($table) &#123; $table-&gt;string('key')-&gt;unique(); $table-&gt;text('value'); $table-&gt;integer('expiration');&#125;); file: 文件驱动，系统将生成缓存文件储存在/storage/framework/cache文件夹里，所以，777权限是必须的 memcached: Memcached驱动，使用之前需要先在系统中安装Memcached，并设置MEMCACHED_HOST和MEMCACHED_PORT redis: Redis驱动，使用之前需要先在系统中安装Redis，并设置CACHE_REDIS_CONNECTION 众多驱动方式中，array不是持久缓存，database需要读取数据库，file需要读取文件，apc/memcached/redis是基于内存的，所以…选择适合自己的 使用 缓存需要Facade的支持，否则会提示Class &#39;Cache&#39; not found错误，所以，请检查/bootstrap/app.php，确认$app-&gt;withFacades();的注释已去掉 Lumen已经默认去掉注释 无论选用任何驱动方式，缓存的使用方式是统一的，请看以下代码： 12345678910111213use Cache;...$id = 5;// 读取缓存$result = Cache::get('UserData_'.$id);if($result)&#123; return $result;&#125;$result = User::findOrFail($id);// 添加缓存，时间60分钟Cache::put('UserData_'.$id, $result, 60); 接下来具体说一下Memcached和Redis MemcachedMemcache 与 Memcached Memcache: 是一个自由和开放源代码、高性能、分配的内存对象缓存系统。用于加速动态web应用程序，减轻数据库负载。它可以应对任意多个连接，使用非阻塞的网络IO。由于它的工作机制是在内存中开辟一块空间，然后建立一个Hash表，Memcached自管理这些Hash表。 Memcached: Memcache是该系统的项目名称，Memcached是该系统的主程序文件（字母d可以理解为daemon），以守护程序方式运行于一个或多个服务器中，随时接受客户端的连接操作，使用共享内存存取数据。 PHP 有两个 Memcached 客户端：“PHP Memcache 扩展” 和 “PHP Memcached 扩展”，这就是是我们搞混的地方。 PHP Memcache 扩展: 用 PHP 实现的，支持面向对象和面向过程两种接口，2004年就实现了，是老客户端，而且功能少，属性也可设置的少。 函数列表：http://php.net/manual/zh/book.memcache.php PHP Memcached 扩展: 基于 libmemcached 开发的，使用 libmemcached 库提供的 API 与 Memcached 服务进行交互，只支持面向对象的接口，2009年才实现，Memcached 扩展功能更加完善，支持的函数更多，比如支持批量操作， 函数列表：http://php.net/manual/zh/book.memcached.php现在一般建议使用 Memcached 扩展。 必须同时安装服务端和客户端如果安装了 Memcached 服务端不安装扩展，那么 PHP 无法操控 Memcached。 同样如果安装了 PHP Memcached 扩展（PHP Memcache 和 PHP memcached 两者选择一个)，但是没有安装 Memcached 服务端，那么这个就无法使用。 只有同时安装了 Memcached 服务端和 PHP 客户端扩展才可以提高动态网站性能。 具体应用 确保 PHP 安装并引入了 memcached 扩展（可能要重启 php-fpm）；确保 Memcached 已正常运行（略） 本地测试 windows下安装PHP7.0/7.1的Memcache扩展: nono303/PHP7-memcache-dll 1234567891011121314151617181920&lt;?php$memcache = new Memcache;$memcache-&gt;connect('localhost', 11211) or die (\"Could not connect\");$version = $memcache-&gt;getVersion();echo \"Memcache Server's version: \".$version.\"&lt;br/&gt;\\n\";$tmp_object = new stdClass;$tmp_object-&gt;str_attr = 'test';$tmp_object-&gt;int_attr = 123;$memcache-&gt;set('key', $tmp_object, false, 10) or die (\"Failed to save data at the server\");echo \"Store data in the cache (data will expire in 10 seconds)&lt;br/&gt;\\n\";$get_result = $memcache-&gt;get('key');echo \"Data from the cache:&lt;br/&gt;\\n\";var_dump($get_result); 在Lumen中应用 创建并配置 config/cache.php： 12345678910111213141516171819&lt;?phpreturn [ 'default' =&gt; 'memcached', 'stores' =&gt; [ 'memcached' =&gt; [ 'driver' =&gt; 'memcached', 'servers' =&gt; [ [ 'host' =&gt; env('MEMCACHED_HOST', '127.0.0.1'), 'port' =&gt; env('MEMCACHED_PORT', 11211), 'weight' =&gt; 100, ], ], ], ], ]; 配置.env 12CACHE_DRIVER=memcachedMEMCACHED_HOST=172.17.0.11 bootstrap/app.php 中引入配置和 memcached.connector： 123456$app-&gt;configure('cache');// !!! 不配会坑$app-&gt;singleton( 'memcached.connector', Illuminate\\Cache\\MemcachedConnector::class); 在Laravel中重新封装 app/Contract/Service/Cachable.php 123456789101112131415161718192021222324&lt;?php// Cache Service Interface// @caoxlnamespace App\\Contract\\Service;interface Cachable&#123; // Get cached value by given key public function get(string $key) : string; // Cache given value by key for seconds public function set(string $key, string $value, int $seconds) : Cachable; // Get cached value by given key // And delete that cache when fetch it successfully public function flush(string $key) : string; // Delete cached value by given key public function delete(string $key) : bool; public function incrementToday(string $key, int $step = 1) : int;&#125; app/Service/Cache/Laravel.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?php// Cache service re-packing from Laravel// @caoxlnamespace App\\Services\\Cache;use Illuminate\\Support\\Facades\\Cache;use App\\Contract\\Service\\Cachable;class Laravel implements Cachable&#123; public function get(string $key): string &#123; return (string) Cache::get($key); &#125; public function set(string $key, string $value, int $seconds): Cachable &#123; Cache::put($key, $value, ($seconds/60)); return $this; &#125; public function flush(string $key): string &#123; $value = null; if (Cache::has($key)) &#123; $value = Cache::get($key); Cache::forget($key); &#125; return (string) $value; &#125; public function delete(string $key): bool &#123; if (Cache::has($key)) &#123; return Cache::forget($key); &#125; return true; &#125; public function incrementToday(string $key, int $step = 1): int &#123; $times = intval(Cache::get($key)); $times += $step; $minutes = ($this-&gt;seconds_left_today() / 60); Cache::put($key, $times, $minutes); return $times; &#125; private function seconds_left_today() : int &#123; $tomorrow = strtotime(date('Y-m-d', strtotime('+1 day'))); return $tomorrow - time(); &#125;&#125; 注意：这里如果不事先加载单例 MemcachedConnector ，则会报如下错误： lumen.ERROR: ReflectionException: Class memcached.connector does not exist in /data/www/vendor/illuminate/container/Container.php:729` 如果是生产环境? 生产环境一般开启了 autoload 等缓存了的，为确保正确加载，部署时要清理下缓存先： 123456php artisan config:clearcomposer dump-autoload# Lumen 默认没有以下命令# php artisan optimize# php artisan clear-compiled memcached 默认的过期时间则 不能大于 30 天！ Redis 安装redis, 使用composer即可: 12composer require illuminate/rediscomposer require predis/predis 或者 123456\"require\": &#123; \"php\": \"&gt;=7.1.3\", \"illuminate/redis\": \"5.5.*\", \"laravel/lumen-framework\": \"5.5.*\", \"predis/predis\": \"^1.1\",&#125;, 注册redis类 1$app-&gt;register(Illuminate\\Redis\\RedisServiceProvider::class); 在要使用redis的地方即可 1use Illuminate\\Support\\Facades\\Redis; redis常用命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php// Redis Reference Resources// 这个文件仅供忘记Redis命令时参考,使用Redis无需重新封装.// @caoxlnamespace App\\Traits;class Redis&#123; public function set($key, $val) &#123; Redis::set($key, $val); &#125; public function setex($key, $exp, $val) &#123; Redis::setex($key, $exp, $val); &#125; public function get($key) &#123; return Redis::get($key); &#125; public function expire($key, $exp = 180) &#123; Redis::expire($key, $exp); &#125; public function incr($key) &#123; Redis::incr($key); &#125; public function del($key) &#123; Redis::del($key); &#125; public function exists($key) &#123; return Redis::exists($key); &#125;&#125; 参考 在 Windows 10 64 下安装 Memcached，安装 PHP 7.0.22 的 Memcache 扩展","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"Memcache","slug":"Memcache","permalink":"http://blog.caoxl.com/tags/Memcache/"}]},{"title":"Linux 管理总结","slug":"Linux-Dev-Notes","date":"2018-08-13T01:29:51.000Z","updated":"2018-11-22T09:30:11.000Z","comments":true,"path":"2018/08/13/Linux-Dev-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/08/13/Linux-Dev-Notes/","excerpt":"总结一下平日在 GNU/Linux，没有特殊说明都是在 CentOS 上经常使用到的命令／工具的使用，但有些命令同样适用于 macOS。 好记性不如烂笔头, 现在应该没有哪个公司是断网开发吧.","text":"总结一下平日在 GNU/Linux，没有特殊说明都是在 CentOS 上经常使用到的命令／工具的使用，但有些命令同样适用于 macOS。 好记性不如烂笔头, 现在应该没有哪个公司是断网开发吧. SSH/SCP/SFTPSSH管理12345678910111213141516171819202122232425262728# 登录远程主机ssh user@domain-namessh &lt;domain-alias&gt; # 在 ~/.ssh/config 中配置###### 配置 SSH Key 实现免密码远程操作 [参考]# 本地配置cd ~/.sshssh-keygen -t rsa -C 'USER@domain-name' -f id_rsa_xxxssh-copy-id -i ~/.ssh/id_rsa_xxx.pub www.remote-host.com # will ask for password if you are the first time to add public key# Or: scp id_rsa_xxx.pub USER@domain-name:/USER/.ssh/authorized_keys# Or: cat ~/.ssh/id_rsa.pub | ssh user@12.34.56.78 \"mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys\"vim config Host domain-alias HostName domain-name User USER Port 22 IdentityFile ~/.ssh/id_rsa_xxx# 远程配置cd ~/.sshchown -R user:user ../.sshchmod 0500 ../.sshchmod 0400 ./* ssh-add 添加记住 passphrase 如果生存公钥对的时候使用了 passphrase 可以使用 ssh-add 记住该公钥对应私钥的密码，避免每次登录都要输入使用秘钥的密码。 12ssh-add -K /path/to/ras_filessh-add -l 删除已记住的 passphrase 反之，从某个代理机器上删除记住过的私钥： 1234567# 删除单个秘钥ssh-add -d /path/to/ras_file# 删除所有秘钥add-add -Dssh-add -L 锁定与解锁秘钥 12ssh-add -x # 输入两次密码锁定ssh-add -X # 输入一次密码解锁 SCP 上传/下载1234567891011# 上传文件scp [-P &#123;port&#125;] filename user@domain-name:/path/to/save# 上传目录scp -r dirname user@domain-name:/path/to/save# 下载文件scp user@domain-name:/path/to/filename /path/to/save# 下载目录scp -r user@domain-name:/path/to/dirname /path/to/save SFTP 上传/下载1234567891011121314151617181920212223242526272829# 1. 连接远程服务器sftp user@domain-name# 2. 下载文件／目录get /path/to/filename /path/to/saveget -r /path/to/dirname /path/to/save# 3. 上传文件／目录put /path/to/filename /path/to/saveput -r /path/to/dirname /path/to/save# 4. 查询本机当前所在路径lpwd# 5. 查询远程主机当前所在路径pwd# 6. 改变本地路径lcd /path/to# 7. 改变远程路径cd /path/to# ... 更多 shell 指令规律类似: # 操作远程用原生 Shell 指令# 操作本地用 `l` + 原生 Shell 指令# 8. 退出 sftpexit | quit | bye 说明: scp 源 目标 ，因此 scp 既可以下载又可以上传，只需要调整下参数顺序，因为文件／目录都是：从 源 到 目标。 上传下载目录时，最好先压缩成单个文件再按文件的方式进行传输。 若指定的路径不存在将自动创建。 上面的 domain-name 都可以用相应的 IP 地址来代替。 若已经配置过 SSH Key，则在使用上述命令的时候便不再需要每次都输入密码。 SFTP 中，get 和 put 若不指定目标保存路径，则默认为远程主机／本机当前所在路径。 rsync同步本地和远程代码12# 手动同步rsync -avz --progress --delete --no-o --no-g -m --chmod=Du=rwx,Dgo=rx,Fu=rw,Fog=r /env/vagrant/www/app.dev/ root@app.dev:/data/wwwroot/app.dev 路径需要修改成你自己的 screen/tmux12345678910111213141516171819202122# screenscreen # start a new screen sessionscreen -S &lt;session_id&gt; # start a new screen session with namescreen -lsscreen -r &lt;session_id&gt; # recover a screen session detachedscreen -D -r &lt;session_id&gt; # recover a screen session even if attachedscreen -X -S [session #id you want to kill] quit|exitCtrl + A + D =&gt; 退出当前 Session# tmuxtmux # start a new tmux sessiontmux lstmux new -s &lt;session_id&gt;tmux at/attach -t &lt;session_id&gt;## rename a sessionctrl+b =&gt; `:` =&gt; rename-session [-t current-name] [new-name] (第二可选参数不填则重命名当前 attach 的会话)Ctrl + B + D =&gt; 退出当前 SessionCtrl + B + \" =&gt; 水平分屏Ctrl + B + % =&gt; 垂直分屏Ctrl + B + 上／下／左／右 =&gt; 分屏间切换 解压缩 .xz 1xz -d xxx.tar.xz # x .tar 12345tar -xvf xxx.tar # xtar -cf all.tar *.jpg # -c 表示产生新的包tar -rf all.tar *.gif # -r 表示增加文件tar -uf all.tar logo.gif # -u 表示更新文件tar -tf all.tar # -t 列出文件 gzip 123456789gzip /path/to/file_or_foldergzip -rv /path/to/file_or_foldergzip -l /path/to/file_or_foldergzip -dv /path/to/file_or_foldergzip -dr /path/to/file_or_folder# Example:gzip -d 1.sql.gz | mysql -h127.0.0.1 -u root -p db_demo .tar.gz 12tar -xzvf xxx.tar.gz # xtar -czf all.tar.gz *.jpg # tar 调用 gzip .tar.bz2 12tar -xjvf xxx.tar.bz2 # xtar -cjf all.tar.bz2 *.jpg # tar 调用 bzip2 .tar.Z 12tar –xZvf xxx.tar.Z # xtar -cZf all.tar.Z *.jpg # tar 调用 compress .rar 1unrar e xxx.rar # x .zip 12unzip xxx.zip # xzip -r xxx.zip /path/to/xxx # c 定时任务atd1echo 'schedule job' | at now Cron/Crontab 命令格式：分 时 日 月 周 命令，比如： 123# 0～59 0～23 1～31 1～12 0～6 command*/1 * * * * php /data/wwwroot/default/cron.php # 每分钟执行一次 cron.php0 8 * * * /sbin/service/sshd start # 每天 8:00 开启 ssh 服务 其中，* 代表取值范围内的数字，/ 代表「每」。 未预装 crond CentOS 下安装 crond 服务123456789# CentOS 6yum install vixie-cron# yum install crontabs # install cronie,cronie-anacron,exim the same timeservice crond startchkconfig crond on# CentOS 7yum install cronie 这里有个不错的在线校准网站：https://crontab.guru/。 其他命令 1234crontab -e # 编辑当前用户的 cron 服务crontab -l # 列出当前用户的 cron 服务的详细内容crontab -r # 删除某个用户的所有 cron 服务service crond start|restart|stop # 开启／重启／停止 crond 服务 网络工具iptables 查看 iptables 防火墙配置信息 1/etc/init.d/iptables status 放行某个端口 12# 如：放行 3306 端口/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT 保存配置信息 12 # !!! 在修改防火墙规则后需要保存配置才能生效service iptables save 打开、重启、关闭 iptables 服务 123service iptables restart|start|stop# 或者/etc/init.d/iptables restart|start|stop 取消 iptables 服务自启动 12# 相当于永久关闭 iptableschkconfig –level 35 iptables off nmap12345678910yum install -y nmap# 手册info nmap# 查看本机当前开放的端口nmap -sTU -O localhost# 检查 本机所在网段有多少台 live 机器nmap -sP 192.168.32.0/24 netstat从 netstat 里可以看到自己机器正在监听的端口、相关程序以及当前的连接数、连接来自何方等数据，然后有针对性的进行关闭相关服务或者用防火墙来屏蔽、过滤对本机服务的访问。 12345netstat -antp # 所有连接、数字显示主机、端口、TCP 连接、监听的程序netstat -anup # 所有连接、数字显示主机、端口、UDP 连接、监听的程序netstat -s # 统计所有（开机至今的）连接数据，包括 tcp、udp 等netstat -st # 统计所有 tcp 连接数据netstat -su # 统计所有 udp 连接数据 lsof查看哪个程序监听着哪个端口。 1lsof -i:80 dig1234567891011121314151617181920212223[root@caoxl ~]# dig github.com# 查询参数和统计; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-61.el7 &lt;&lt;&gt;&gt; github.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 58065;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0# 查询内容 (A 代表 address);; QUESTION SECTION:;github.com. IN A# DNS 服务器的答复 (31 代表缓存时间, 即TTL, 表示31秒内不用查询查询;; ANSWER SECTION:github.com. 31 IN A 192.30.253.112github.com. 31 IN A 192.30.253.113# DNS 服务器的一些传输信息;; Query time: 0 msec;; SERVER: 100.100.2.136#53(100.100.2.136);; WHEN: Mon Aug 13 10:05:46 CST 2018;; MSG SIZE rcvd: 60 如果有 AUTHORITY SECTION: 段，则为 dig 域名的 NS 记录（Name Server），即哪些服务器负责管理所查询域名的DNS记录。向任何一台 NS 查询都能查到所查域名的 IP 信息。 此时，会一同返回 ADDITIONAL SECTION: 段，即为 NS 的 IP。 12345678910111213141516171819# 精简查询dig +short github.com# 显示 DNS 的整个分级查询过程dig +trace github.com# 指定 DNS 服务器查询dig @8.8.8.8 github.com# 单独查看每一级域名的 NS 记录dig ns comdig ns github.com# 查询 PTR 记录（从 IP 地址查询域名）dig -x 1.2.3.4# 查询指定的记录类型dig a github.comdig mx github.com host简化版 dig。 1234567891011[root@caoxl ~]# host github.comgithub.com has address 192.30.253.113github.com has address 192.30.253.112github.com mail is handled by 10 alt4.aspmx.l.google.com.github.com mail is handled by 1 aspmx.l.google.com.github.com mail is handled by 5 alt1.aspmx.l.google.com.github.com mail is handled by 10 alt3.aspmx.l.google.com.github.com mail is handled by 5 alt2.aspmx.l.google.com.[root@caoxl ~]# host 192.30.253.113113.253.30.192.in-addr.arpa domain name pointer lb-192-30-253-113-iad.github.com. nslookup互动式地查询域名记录。 12345678[root@caoxl ~]# nslookup&gt; caoxl.comServer: 100.100.2.136Address: 100.100.2.136#53Non-authoritative answer:Name: caoxl.comAddress: 47.91.221.85 whois查看域名的注册情况。 1whois github.com wget 递归下载整站 1234567891011121314wget -r -p -np -k http://www.example.comwget \\ --recursive # download the entire Web site \\ --no-clobber # don't overwrite any existing files (used in case the download is interrupted and resumed) \\ --page-requisites # get all the elements that compose the page (images, CSS and so on) \\ --html-extension # save files with the .html extension \\ --convert-links #convert links so that they work locally, off-line \\ --restrict-file-names=windows # modify filenames so that they will work in Windows as well \\ --domains cloud.google.com # don't follow links outside cloud.google.com \\ --no-parent https://cloud.google.com/apis/design/resources # don't follow links outside the directory api/design/resources# 实例：下载在线电子书网站到本地wget --mirror --convert-links --no-parent --no-verbose https://landing.google.com/sre/book/ curl RESTFul 请求 1curl -X GET http://www.example.com 打印返回请求头 12curl -I http://www.example.comcurl --head http://www.example.com 自定义头信息 123curl -i-X POST http://www.example.com/api/with/key \\-H \"Accept: application/json\" \\ POST JSON 123curl -X POST http://www.example.com/api/with/key \\-H \"Accept: application/json\" \\-d '&#123;\"username\":\"xyz\",\"password\":\"xyz\"&#125;' 输出请求详情 1curl -v https://www.google.com 文件内容作为请求 payload 123curl -vX POST http://example.com \\-H 'Content-Type: application/json; charset=utf-8'-d @/path/to/file.json HTTP base authorization 1234curl -u user:passwd http://example.com# Or:curl http://user:passwd@example.com 进程管理supervisor12345678910111213141516171819yum info supervisoryum install -y supervisorservice supervisord start|stop|restartsupervisorctl rereadsupervisorctl start proj-worker:*vim /etc/supervisord.conf# 以编辑 Laravel 项目队列后台进程管理为例[program:proj-name]process_name=%(program_name)s_%(process_num)02dcommand=php /data/wwwroot/www.proj.com/artisan queue:work database --queue=phjs-cc-%(process_num)2d --memory=256 --sleep=2 --tries=2 --daemonautostart=trueautorestart=trueuser=wwwnumprocs=16redirect_stderr=truestdout_logfile=/data/wwwroot/www.proj.com/storage/logs/sv-worker.log “unix:///tmp/supervisor.sock no such file”在执行 supervisorctl -c /etc/supervisord.conf 的时候，出现该报错。 原因是： supervisor默认配置会把socket文件和pid守护进程生成在/tmp/目录下，/tmp/目录是缓存目录，Linux会根据不同情况自动删除其下面的文件。 解决办法： 123456789101112131415vi /etc/supervisord.conf`[unix_http_server]file=/var/run/supervisor.sock[supervisord]logfile=/var/log/supervisor/supervisord.log[supervisorctl]serverurl=unix:///var/run/supervisor.sock # 必须和 `unix_http_server` 一一对应`supervisorctl update# supervisord -c /etc/supervisord.conf systemd 守护进程创建一个自定义守护进程服务配置文件： 12345678910111213141516vi /lib/systemd/system/phpd-test.service`[Unit]Description=PHP Daemon Demo[Service]User=phpdemoGroup=phpdemoWorkingDirectory=/home/phpdemoRestart=alwaysExecStart=/usr/bin/php phpd-test.php`systemctl status phpd-test # systemd does not start new services automaticallysystemctl start mydaemon 测试：kill phpd-test 相关进程，查看 systemd 是否自动重启。 相关路径 services: /lib/systemd/system/*.service logs: /var/log/syslog 日志文件可以通过 journalctl —since “2018-08-13 12:13:31” 来快速获取 参考 http://rustamagasanov.com/blog/2017/02/24/systemd-example-for-a-simple-ruby-daemon-supervision/ https://serversforhackers.com/c/process-monitoring-with-systemd 批量杀死进程1ps -ef | grep php | grep -v grep | awk '&#123;print $2&#125;' | xargs kill -9 后台运行1nohup ~/shell/server-git-sync &gt; /dev/null 2&gt;&amp;1 &amp; 查看日志文件变动1tail -f /tmp/git-sync-client.log 文件系统管理批量重命名1i=0; for f in *.mp4 ; do let i=i+1; mv \"$f\" $i\".mp4\" ; done 递归创建文件夹1mkdir -p root/&#123;com,net,org&#125;/&#123;taobao,tmall&#125;/&#123;www,detail&#125; 将文件隐藏到图片1copy*/b*d:1.jpg*+*d:2.rar*d:3.jpg 常用命令man查看命令的使用说明。 1man htop cheat查看某个常用命令的使用举例。 123456789101112yum install docoptyum install python-pipgit clone git@github.com:chrisallenlane/cheat.gitcd cheat/python setup.py install# Checkcheat -v# Usage democheat tarcheat curl find12345678910111213141516171819202122232425262728293031323334353637383940414243# 找到文件大小小于 10000k 的文件并删除find . -size -10000k | xargs rm -rf# 找到文件名中包含字符串的文件find . -name '*linux*' # 区分大小写find . -iname '*linux*' # 不区分大小写# 找到后缀为 jpg/JPG 的文件find . -iname '*.jpg'# 找出目录类型find . -type d# 找出文件类型find . -type f# 找到八进制权限为 777 的文件find . -type f -perm 777# 找到文件名以 .tmp 结尾的并删除find . -name '*.txt' -exec rm '&#123;&#125;' \\;# 删除所有空文件夹find . -type d -empty -exec rmdir &#123;&#125; \\;# 找到所有最后修改时间为 7 天前的文件find . -type f -mtime +7d -ls# 从制定文件类型中找到查找字符串find . -name '*.php' | xargs grep -ri 'eval'# 找到文件大于 1M 的并排序find . -size +1M -type f -print0 | xargs -0 ls -Ssh | sort -z# 找到所有名称为 logs 的所有目录 最大深度为 2find . -maxdepth 2 -name logs -type d# 找到所有不在 .git 目录中的文件find . ! -iwholename '*.git*' -type f# 找到当前目录下所有文件并修改其权限find . -type f -exec chmod 644 &#123;&#125; \\; du12# 统计当前目录大写 输出目录深度为 1du . -h --max-depth=1 VIM快捷键 上翻整页：ctrl + f 上翻半页：ctrl + u 下翻整页：ctrl + b 下翻半页：ctrl + d 左缩进：命令模式下按 V，然后 &lt;&lt; (shift + &lt;) 右缩进：命令模式下按 V，然后 &gt;&gt; 常用命令123456789# 显示行号set nu# 关闭行号set nu!set nonu# 设置缩进set shiftwidth=4# 设置Tab宽度set tabstop=4 用户管理查看并剔除用户12345678910111213141516171819# 查看用户wwhowhoamiwho am i[root@caoxl ~]# w 10:48:34 up 10 days, 1:09, 1 user, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 61.140.74.36 10:00 2.00s 0.04s 0.00s w[root@caoxl ~]# whoroot pts/0 2018-08-13 10:00 (61.140.74.36)[root@caoxl ~]# whoamiroot[root@caoxl ~]# who am iroot pts/0 2018-08-13 10:00 (61.140.74.36)# 剔除指定终端的用户pkill -kill -t pts/2 FAQ scpnot a regular file? 12# 带 `-r` 选项scp -r xxx/ Linux 启动文件系统检查失败：Inode 2891983, end of extent exceeds allowed value 123456789# 1. 查看 /etc/fstab 文件中是否写入了错误的文件系统或者磁盘的分区信息# 1.1 定位／打印区块设备属性blkid# 1.2 查看系统文件系统的固定信息和 blkid 是否一致vim /etc/fstab# 2. 修复分区e2fsck -C0 -p -f -v /dev/sda1 SSH: connection rest by peer http://stackoverflow.com/questions/1434451/what-does-connection-reset-by-peer-mean 参考 Linux 管理个人总结 How To Set Up SSH Keys 云服务器 ECS Linux 系统 /etc/fstab 错误配置导致系统启动异常 DNS 原理入门 Linux 技巧：让进程在后台可靠运行的几种方法 Stupid ssh-add Tricks","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.caoxl.com/tags/服务器/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"技术 / 团队开发流程","slug":"Team-Dev-Flow","date":"2018-08-10T08:10:23.000Z","updated":"2019-08-22T03:18:00.000Z","comments":true,"path":"2018/08/10/Team-Dev-Flow/","link":"","permalink":"http://blog.caoxl.com/2018/08/10/Team-Dev-Flow/","excerpt":"以下流程，均基于现有的开发环境（设计、程序并行）和开发者水平重新提出的构想。","text":"以下流程，均基于现有的开发环境（设计、程序并行）和开发者水平重新提出的构想。 原则 每一层做完本层任务后，都需要直属上一层测试是否正确、如愿完成 每进行下一步之前，都必须开会，无异议后签字，签完字才动工。 顶层是客户，需求书是主导。 一、需求分析动工之前，客户、产品，需要开一个需求分析会议。 产品必须听懂客户的需求，且产品必须并做到以下几点： 系统模块化一个完整的系统必然是由多个小系统构成的，而这个小系统，对于程序的角度来说就是一个可以动工开发的最小模块。 模块组件化独立子系统，每个子系统必须是一个逻辑完整的可用模块。在项目再紧急的情况下，也必须一个模块一个模块，以完整逻辑的形式分到下面的程序实现。 如果不是，则开发开始后造成的一切改动都是不必要的成本浪费。 组件层次化大功能、小功能。 每层要完成的事情要清楚知道你要干啥（这很重要）。 需求书说明书本次会议结束后，产品需要根据脑海里的最新印象，出标准的需求说明书。 需求说明书写完后，必须开会给客户检查，看是否表达出需求的完整性。如果客户对此需求书无任何异议，则需要客户和产品当面在需求说明书签字，表示开发流程可以正式启动。 尤其要说明一下，需求说明书很重要，它是所有工作的开始（草图的重要依据），也是所有工作的结束（测试的重要依据 交付、验收的主要依据） 小结这一阶段需要完成两件事： 听懂客户在说什么 将自己听懂的以「需求说明书」的形式记录下来 二、草图产品根据上一阶段总结的内容，开始将需求表达出来。 表达需求的第一步就是画草图，通常由最了解需求的人完成或指导下完成。 每个模块的草图设计完后，必须要开会，让客户看看是否和需求说明书上一致，不是则根据情况修改，直到客户满意。 注意：这时候是以需求书为主而非客户口头说明为主了。 客户满意后，需要双方签字，表示这个模块的草图可以交到设计师出稿。 小结在这一阶段必须完成：需求的轮廓从无形到有形之间，尽可能无损表达的目标。 三、设计经过客户检查通过并签字的草图，将交到设计师，设计师根据草图出稿。 设计完成后，开会，交给产品检查，看草图中提到的东西是否完整。如果检查通过则称 「定稿」。 检查通过后，谁设计的，就由谁开会向前端和后台讲述其需求细节，并提出需要注意的。 这里，当设计图定稿后，技术组需要选择相关人员参与页面和功能的设计 前端和后台做好记录，有疑问现场提出，得到解答，记录设计师对疑问的解释。 小结这一阶段必须完成：将需求概念用 psd 实体原样表达出来，以便传递到前端使用。 四、第一次时间估算页面和程序听完需求说明和提出存在的问题并得到解决后，便估算自己所需的时间。 然后相关人员签字，便开始自己的工作，其中，后端人员估算的时间包括两个部分： 架构设计和数据库设计：这部分不需要出页面就可以估算时间。 关联功能：这部分是需要看到前端交来的最终页面来，视页面成熟度和关联难度来估算时间 前端人员和后台人员估算时间结束后，分别和设计师开会结果整理成表，复印多份，相关人员签字，由参与人员人手一份。 之后，前端才写页面，后台开始架构设计，数据库设计。 小结这一阶段必须完成的是：程序必须知道自己要做什么，并作出合理的时间评估。 五、页面页面「写好」后，谁写的页面，就由谁开会负责像设计师展示其功能，包括按钮、跳转、特效、基本交互、图片尺寸等等。 设计师负责检查页面和设计稿的出入，决定是否可以交到后台。如果可以，则开会为本次页面测试通过签字，表示可以将页面交给后台人员完善功能了。 小结这一阶段必须完成的是：设计稿所表达的东西要尽可能无损输出为页面。 六、第二次时间估算当设计师测试完页面的完整性后，页面将交到后台，后台估算自己关联上功能的时间。 这时候需要第二次估算时间，因为在团队现有水平的基础上，一些 JS 交互，以及和获得后台数据的 JS，需要后台人员来完成。因此，这时后端需要看到经过设计师检查通过后的具体页面情况来进行第二次时间估算。 第二次时间估算结束后，需要和设计开会，双方确认后表示可以进行下一步。 小结这一阶段必须完成的是，后台人员根据页面“复杂”情况，估算出关联上功能的时间。 七、后端后台功能写完后，首先自己测试完基本的功能是否可用，是否对异常／边界情况进行妥善处理。 我们程序在这方面，尤其要做到：不要让客户看到任何程序报错。 然后自己对照需求和设计稿初步测试完成后，交到测试，由测试进行统一测试。 小结这一阶段必须完成的是：功能、逻辑、数据，的完整性、正确性、安全性等。 八、最终统一测试原则 测试结果按格式出表 简洁明了描述出现错误的具体环境，以及如何复现该错误 页面样式 主要测试主流浏览器兼容情况 对照设计图和需求书测试和设计图、需求书的出入 功能 主要对照需求表测试功能的：完整性、可用性、便捷性、安全性 对照需求书验收功能。 动态疑问如果开发期间仍然遇到疑问和建议，比如现有设计在功能实现上有：实现不了、复杂度高、不合理等等，开发者须立即向设计师和需求方沟通，达成一致后根据讨论才可以继续下一步。 每达成一致后，如果有在上一次定稿基础上进行修改的东西，则需求方和程序要进行统一签字，然后按最新定稿执行。 项目需求变动时怎么办？ 本次迭代中不允许变动需求 重新解读需求，提出自己疑问，评估需求变动：考察「时间进度」和「技术实现」。 能接受，对则疑问以及，需求方对疑问的解释进行文字记录 签字，拿到四方签字才干活 (也不一定需要签字, 只需要四方确认即可)","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"团队开发","slug":"团队开发","permalink":"http://blog.caoxl.com/tags/团队开发/"}]},{"title":"PHP 冒泡排序由浅到深","slug":"PHP-Bubble-Sorting-Analysis","date":"2018-08-10T03:45:35.000Z","updated":"2019-08-22T03:01:38.000Z","comments":true,"path":"2018/08/10/PHP-Bubble-Sorting-Analysis/","link":"","permalink":"http://blog.caoxl.com/2018/08/10/PHP-Bubble-Sorting-Analysis/","excerpt":"冒泡排序算是最简单的排序算法了，但是深入研究的话，还是能学到不少东西。","text":"冒泡排序算是最简单的排序算法了，但是深入研究的话，还是能学到不少东西。 冒泡排序 ( 交换排序 )冒泡算法的基本思想 : 两两比较相邻记录值, 如果反序则交换, 直到没有反序之外 1. 最简单的交换排序1234567891011121314151617181920212223242526272829303132/** * 本函数是最简单的一种交换排序, 严格的说并不算标准的冒泡排序, 其实现思路: * 外层循环第 1 次遍历结束的时候找到所有数字中最小( 或最大 )的放到第 1 位 * 外层循环第 2 次遍历结束的时候找到所有数字中第 2 小( 或第 2 大 )的放到第 2 位 * 外层循环第 3 次遍历结束的时候找到所有数字中第 3 小( 或第 3 大 )的放到第 3 位 * 以此类推, 当外层循环第 n 次遍历结束的时候找到所有数字中第 n 小, 即最大( 或第 n 大, 即最小 )的放到第 n 位 * 本算法的时间复杂度是: O(n^2); * 由于排序过程中已排序好的序列对剩余序列的排序没有任何帮助, 所以其效率比较低下 * @param Array &amp;$arr, 必须传入一个数组类型 * @param int $type * @return bool|int */function bubble_sort1(&amp;$arr, $type = 0) &#123; if (!number_check($arr)) &#123; return false; &#125; $len = count($arr); for ($i = 0; $i &lt; $len; ++$i) &#123; # 环遍历到数组中最后一个数字的时候便不用再进行比较了 for ($j = $i+1; $j &lt; $len; ++$j) &#123; # 这里需要使用 `===` 来进行严格判断, 以免传入类似 null 等空元素产生安全隐患 if (1 === $type) &#123; if ($arr[$i] &lt; $arr[$j]) &#123;swap($arr[$i], $arr[$j]);&#125; &#125; else &#123; # 如果 $type 没指定值或者指定其他值都按 $type = 0 进行默认处理 if ($arr[$i] &gt; $arr[$j]) &#123;swap($arr[$i], $arr[$j]);&#125; &#125; &#125; &#125; return 1;&#125; 2. 标准冒泡排序123456789101112131415161718192021222324252627282930313233343536/** * 本函数是正宗的冒泡排序算法, 其基本实现思路是: * 外层循环的下标所对应的值总是代表本次外循环总最小或最大的数 * 内层循环总是从数组中最后一个数依次向前和相邻数比较, 根据所需顺序决定是否需要交换两者的值 * 外层循环第 1 次遍历结束的时候所有数字中最小( 或最大 )的数浮到第 1 位 * 外层循环第 2 次遍历结束的时候所有数字中第 2 小( 或第 2 大 )的数浮到第 2 位 * 外层循环第 3 次遍历结束的时候所有数字中第 3 小( 或第 3 大 )的数浮到第 3 位 * 以此类推, 当外层循环第 n 次遍历结束的时候所有数字中第 n 小, 即最大( 或第 n 大, 即最小 )的数位于第 n 位 * 本算法的时间复杂度是: O(n^2) * @param $arr * @param int $type 排序的类型: 0 为 从小到大 ( 默认 ) ; 1 为 从大到小 * @return bool|int */function bubble_sort2(&amp;$arr, $type = 0) &#123; if (!number_check($arr)) &#123; return false; &#125; $len = count($arr); # 写法不唯一但是必须注意外层循环和内层循环的数组越界问题 for ($i=0; $i&lt;$len; ++$i) &#123; # 这里因为第一位至少得比较一次, 所以必须 $j&gt;=$i 否则第一个元素无法被遍历到 # 为了形象, 模拟出冒泡的动作, 这里从尾部开始遍历, 表达最小或最大元素从最底部逐渐上浮到 `水面` 的感觉 # 这里的写法不唯一, 只要能遍历到每个元素然后体现相邻两个元素交换就行了, 向前和向后其实是一样的 for ($j=$len-2; $j&gt;=$i; --$j) &#123; # 这里需要使用 `===` 来进行严格判断, 以免传入类似 null 等空元素产生安全隐患 if (1 === $type) &#123; if ($arr[$j+1] &gt; $arr[$j]) &#123; swap($arr[$j+1], $arr[$j]);&#125; &#125; else &#123; # 如果 $type 没指定值或者指定其他值都按 $type = 0 进行默认处理 if ($arr[$j+1] &lt; $arr[$j]) &#123; swap($arr[$j+1], $arr[$j]);&#125; &#125; &#125; &#125; return 1;&#125; 3. 优化后的冒泡排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 本算法解决的是当对诸如 2,1,3,4,5,6,7,8,9 这种基本认为有序的数列进行排序的时候, 第 2 种算法在已经排好顺序后还是会去做多余的判断带来的效率降低问题 * 优化的基本思路是: * 已经有序的数字之间无需再次排序; 尽量利用已经有序的部分数列 * 如果在外层循环的一次完整遍历中都没有发生过一次交换则认为已经排序完成退出排序, 而如果发生交换过则证明序列还没有成为我们期望的顺序而需要继续排序 * 如果序列已经完全有序但是和想要的顺序刚好相反, 则此时可以先通过判断是否是这种情况然后使用 array_reverse() 翻转序列即可, 这样在 n 很大的情况下时间复杂度只有 O(1) * 本算法的时间复杂度是: 最好情况( 要排的序列自身可以认为有序 )下 O(1) 或者 O(n); 最坏情况下 O(n^2) * 分析算法的技巧在于: 可以通过分析几个情况推广到一般情况而不是把每种情况都验证一遍 * @param $arr * @param int $type 排序的类型: 0 为 从小到大 ( 默认 ) ; 1 为 从大到小 * @return bool|int */function bubble_sort3(&amp;$arr, $type = 0) &#123; if (!number_check($arr)) &#123; return false; &#125; $len = count($arr); # 如果数组中的数字本身有序则不用进行冒泡排序, 要么返回原数组, 要么返回原数组的翻转数组 # 如果 $type = 1 且数组本身也是从大到小 ( $is_order = 1 ) , 则直接返回 1 # 如果 $type = 1 且数组本身是从小到大 ( $is_order = 2 ) , 则翻转数组后返回 2 # 如果 $type = 0 且数组本身也是从小到大, 则直接返回 3 # 如果 $type = 0 且数组本身是从大到小, 则翻转数组后返回 4 $is_order = is_ordered($arr, $len, $type); switch ($is_order) &#123; case 1: if ($type == 1) &#123; return 1; &#125; else &#123; array_reverse($arr); return 2; &#125; break; case 2: if ($type == 1) &#123; array_reverse($arr); return 3; &#125; else &#123; return 4; &#125; default: break; &#125; # 对冒泡排序的优化, 保存是否排序好的状态 # 如果 $flag = true 代表本数列还没有排序好, 如果为 false 则代表本数列已经排序好无需再排, 然后退出外层循环 $flag = true; # 写法不唯一但是必须注意外层循环和内层循环的数组越界问题 for ($i=0; $i&lt;$len &amp;&amp; $flag; ++$i) &#123; # 乐观地认为该序列已经有序无需再排, 这是最好的情况, 如果真是这样则跳出外循环, 这样可以避免最好情况下的无意义比较 $flag = false; # 这里因为第一位至少得比较一次, 所以必须 $j&gt;=$i 否则第一个元素无法被遍历到 # 为了形象, 模拟出冒泡的动作, 这里从尾部开始遍历, 表达最小或最大元素从最底部逐渐上浮到 `水面` 的感觉 # 这里的写法不唯一, 只要能遍历到每个元素然后体现相邻两个元素交换就行了, 向前和向后其实是一样的 for ($j=$len-2; $j&gt;=$i; --$j) &#123; # 这里需要使用 `===` 来进行严格判断, 以免传入类似 null 等空元素产生安全隐患 if (1 === $type) &#123; if ($arr[$j+1] &gt; $arr[$j]) &#123; swap($arr[$j+1], $arr[$j]);&#125; $flag = true; &#125; else &#123; # 如果 $type 没指定值或者指定其他值都按 $type = 0 进行默认处理 if ($arr[$j+1] &lt; $arr[$j]) &#123; swap($arr[$j+1], $arr[$j]);&#125; $flag = true; &#125; &#125; &#125; return 0;&#125; 辅助函数 number_check() 12345678910111213141516/** * 对输入的参数进行检查, 不能为非数组, 也不能为非数字 * @param $arr * @return bool */function number_check( &amp;$arr ) &#123; if (!is_array($arr)) &#123; return false; &#125; else &#123; foreach ($arr as $val) &#123; if (!is_numeric($val)) &#123;return false;&#125; &#125; &#125; return true;&#125; swap() 123456789101112131415/** * 交换 2 个数字 * @param $a * @param $b * @return bool */function swap(&amp;$a, &amp;$b) &#123; if (is_numeric($a) &amp;&amp; is_numeric($b)) &#123; $a = $a + $b; $b = $a - $b; $a = $a - $b; &#125; else &#123; return false; &#125;&#125; is_ordered() 1234567891011121314151617181920212223242526/** * 判断数组中的数字序列是否是已经有序这种特殊情况 * 注意输入参数检查, 这里调用者已经检查过了所以这里不再进行检查 * @param $arr * @param $len: 这里直接传过来不用再多一次计算 * @param int $type 升序或者降序 - 0 代表从小到大( 默认 ) ; 1 代表从大到小 * @return int 为 0 代表序列无序; 为 1 代表已经是 从大到小 的顺序; 为 2 代表已经是 从小到大 的顺序 */function is_ordered(&amp;$arr, $len, $type = 0) &#123; $status = 0; for ($i=0; $i&lt;$len-1; ++$i) &#123; if (1 === $type) &#123; # 如果前一个数都不小于后一个数, 则说明数组中的数字已经是从大到小的顺序, 否则不是 if (($arr[$i] &gt;= $arr[$i+1]) &amp;&amp; (++$status == $len-1)) &#123; return 1; &#125; &#125; else &#123; # 如果前一个数都不大于后一个数, 则说明数组中的数字已经是从小到大的顺序, 否则不是 if (($arr[$i] &lt;= $arr[$i+1]) &amp;&amp; (++$status == $len-1)) &#123; return 2; &#125; &#125; &#125; return 0;&#125; 注意事项 引用传递不要在调用函数时声明 &amp; 而是在函数形式参数列表中指明 &amp;。即： 1234567891011function func( &amp;$var ) &#123; // do something&#125;$var = array() ;# 错误的写法func( &amp;$var ) ;# 正确的写法func( $var )","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"http://blog.caoxl.com/tags/冒泡排序/"},{"name":"算法","slug":"算法","permalink":"http://blog.caoxl.com/tags/算法/"}]},{"title":"Linux 常见服务启动、重启、关闭命令","slug":"Linux-Server-start-stop","date":"2018-08-10T02:34:35.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/10/Linux-Server-start-stop/","link":"","permalink":"http://blog.caoxl.com/2018/08/10/Linux-Server-start-stop/","excerpt":"Linux 常见服务启动、重启、关闭命令","text":"Linux 常见服务启动、重启、关闭命令 Nginx 查看状态 12[root@caoxl ~]# service nginx statusnginx (pid 1360 1359) is running... 启动 12345[root@caoxl ~]# service nginx startStarting nginx... nginx: [warn] conflicting server name \"caoxl.com\" on 0.0.0.0:80, ignored done[root@caoxl ~]# service nginx statusnginx (pid 14320 14319) is running... 重启 1234567[root@caoxl ~]# service nginx restartStoping nginx... nginx: [warn] conflicting server name \"caoxl.com\" on 0.0.0.0:80, ignored doneStarting nginx... nginx: [warn] conflicting server name \"caoxl.com\" on 0.0.0.0:80, ignored done[root@caoxl ~]# service nginx statusnginx (pid 14354 14353) is running... 停止 12345[root@caoxl ~]# service nginx stopStoping nginx... nginx: [warn] conflicting server name \"caoxl.com\" on 0.0.0.0:80, ignored done[root@caoxl ~]# service nginx statusnginx is stopped. Apache12345service httpd start // 启动service httpd restart // 重新启动service httpd stop // 停止服务 MySQL12345service mysql start // 启动service mysql restart // 重新启动service mysql stop // 停止服务 php-fpm 启动 1234[root@caoxl ~]# service php-fpm startStarting php-fpm done[root@caoxl ~]# service php-fpm statusphp-fpm (pid 14574) is running... 重启 12345[root@caoxl ~]# service php-fpm restartGracefully shutting down php-fpm . doneStarting php-fpm done[root@caoxl ~]# service php-fpm statusphp-fpm (pid 14602) is running... 停止 1234[root@caoxl ~]# service php-fpm stopGracefully shutting down php-fpm . done[root@caoxl ~]# service php-fpm statusphp-fpm is stopped 防火墙1234service iptables status // 状态service iptables start // 启动 service iptables stop // 停止service iptables restart // 重启 系统重启命令 shutdown poweroff reboot halt init","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Apache","slug":"Apache","permalink":"http://blog.caoxl.com/tags/Apache/"},{"name":"PHP-fpm","slug":"PHP-fpm","permalink":"http://blog.caoxl.com/tags/PHP-fpm/"}]},{"title":"基于Lumen-CORS跨域","slug":"Lumen-CORS","date":"2018-08-10T01:18:27.000Z","updated":"2019-08-22T06:19:02.000Z","comments":true,"path":"2018/08/10/Lumen-CORS/","link":"","permalink":"http://blog.caoxl.com/2018/08/10/Lumen-CORS/","excerpt":"如果是客户端是浏览器，则在调用 API 的时候，基本上无法避免跨域问题。不过处理也很简单，需要浏览器和服务器同时配合：浏览器在发起 OPTIONS preflight 请求的时候，服务器返回认可的一些信息就行了。","text":"如果是客户端是浏览器，则在调用 API 的时候，基本上无法避免跨域问题。不过处理也很简单，需要浏览器和服务器同时配合：浏览器在发起 OPTIONS preflight 请求的时候，服务器返回认可的一些信息就行了。 什么是跨域 ?浏览器的同源策略会导致跨域，这里同源策略又分为以下两种: DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。 XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。 只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。 为什么要有跨域限制了解完跨域之后，想必大家都会有这么一个思考，为什么要有跨域的限制，浏览器这么做是出于何种原因呢。其实仔细想一想就会明白，跨域限制主要是为了安全考虑。 AJAX同源策略主要用来防止CSRF攻击。如果没有AJAX同源策略，相当危险，我们发起的每一次HTTP请求都会带上请求地址对应的cookie，那么可以做如下攻击： 用户登录了自己的银行页面 http://mybank.com，http://mybank.com向用户的cookie中添加用户标识。 用户浏览了恶意页面 http://evil.com。执行了页面中的恶意AJAX请求代码。 evil.com向http://mybank.com发起AJAX HTTP请求，请求会默认把http://mybank.com对应cookie也同时发送过去。 银行页面从发送的cookie中提取用户标识，验证用户无误，response中返回请求数据。此时数据就泄露了。 而且由于Ajax在后台执行，用户无法感知这一过程。 DOM同源策略也一样，如果iframe之间可以跨域访问，可以这样攻击： 做一个假网站，里面用iframe嵌套一个银行网站 http://mybank.com。 把iframe宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。 这时如果用户输入账号密码，我们的主网站可以跨域访问到http://mybank.com的dom节点，就可以拿到用户的输入了，那么就完成了一次攻击。 所以说有了跨域跨域限制之后，我们才能更安全的上网了。 如何解决跨域 ?跨域资源共享 - CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing） 具体详见下面的代码封装~~~ Jsonp实现跨域基本原理就是通过动态创建script标签,然后利用src属性进行跨域。 这么说比较模糊，我们来看个例子: 12345678910// 定义一个fun函数function fun(fata) &#123; console.log(data);&#125;;// 创建一个脚本，并且告诉后端回调函数名叫funvar body = document.getElementsByTagName('body')[0];var script = document.gerElement('script');script.type = 'text/javasctipt';script.src = 'demo.js?callback=fun';body.appendChild(script); 返回的js脚本，直接会执行。所以就执行了事先定义好的fun函数了，并且把数据传入了进来。 1fun(&#123;\"name\": \"name\"&#125;) 当然，这个只是一个原理演示，实际情况下，我们需要动态创建这个fun函数，并且在数据返回的时候销毁它。 因为在实际使用的时候，我们用的各种ajax库，基本都包含了jsonp的封装，不过我们还是要知道一下原理，不然就不知道为什么jsonp不能发post请求了~ 服务器代理浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。 服务器代理是万能的。 document.domain来跨子域location.hash跨域使用postMessage实现页面之间通信基于Lumen封装CORS具体如下: app/Http/Middleware/CORS.php 12345678910111213141516171819202122232425262728&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CORS&#123; public function __construct() &#123; &#125; public function handle($request, Closure $next) &#123; $headers = [ 'Access-Control-Allow-Origin' =&gt; '*', 'Access-Control-Allow-Methods' =&gt; '*', 'Access-Control-Allow-Headers' =&gt; 'Access-Control-Allow-Origin, AUTHORIZATION', 'Access-Control-Max-Age' =&gt; 86400, ]; if ('OPTIONS' == $request-&gt;getMethod()) &#123; return response(null, 200, $headers); &#125; return $next($request)-&gt;withHeaders($headers); &#125;&#125; bootstrap/app.php 1234// 指定全局中间件$app-&gt;middleware([ 'cors' =&gt; App\\Http\\Middleware\\CORS::class,]); jQuery Ajax Demo 123456789101112131415$.ajax(&#123; url: 'http://api.example.com/path/to/resource', type: 'GET', dataType: 'json', async: false, cors: true , headers: &#123; 'Access-Control-Allow-Origin': '*', 'AUTHORIZATION': 'JWT_STRING' &#125;, success: function (res) &#123; &#125;, error: function (xhr, status) &#123; &#125;&#125;);","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"CORS","slug":"CORS","permalink":"http://blog.caoxl.com/tags/CORS/"}]},{"title":"Laravel中队列的应用 「database」","slug":"Laravel-Queue-database-Dev-Notes","date":"2018-08-09T01:35:44.000Z","updated":"2019-08-22T06:18:50.000Z","comments":true,"path":"2018/08/09/Laravel-Queue-database-Dev-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/08/09/Laravel-Queue-database-Dev-Notes/","excerpt":"Laravel 使用database驱动做队列","text":"Laravel 使用database驱动做队列 使用Databse驱动步骤 修改 .env 中的配置项 QUEUE_DRIVER 为 database Laravel队列系统介绍 首先要创建数据表来存储任务: 12php artisan queue:tablephp artisan migrate 创建 job 文件: 1php artisan make:job SendReminderEmail 在 Controller 层 $this-&gt;dispatch(new SendRemindEmail()) 生产队列，于是 database jobs 中记录了最新添加的队列任务 单一消费队列: 1php artisan queue:work 依次消费所有队列: 1php artisan queue:listen 失败任务存在failed_tabke 1php artisan queue:failed-table 使用队列步骤「创建」任务类1php artisan make:job SendNoticeEmail 原文中有:--queued 参数表示运行具有队列属性，即该任务类必须实现 ShouldQueue 接口。自成Laravel 5.2版本后,不需要--queued 创建后，根据业务需求编写任务类，通常是某个模块所需的耗时功能。比如：发邮件、截图、生成压缩包、七牛云上传，等。 本文写的是发邮件, 在那之前需要一些邮件配置, 这里我用的是163邮箱: 12345678MAIL_DRIVER=smtpMAIL_HOST=smtp.163.comMAIL_PORT=25MAIL_FROM_ADDRESS=你的邮箱MAIL_FROM_NAME=LCMAIL_USERNAME=你的邮箱MAIL_PASSWORD=邮箱授权码MAIL_ENCRYPTION=null app/Http/Jobs/SendNoticeEmail.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace App\\Jobs;use App\\User;use Illuminate\\Bus\\Queueable;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;use Illuminate\\Support\\Facades\\Mail;class SendNoticeEmail implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $user; /** * Create a new job instance. * 创建一个新的任务实例 * * @return void */ public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; /** * Execute the job. * 运行任务 * * @return void */ public function handle() &#123; $user = $this-&gt;user; Mail::send('emails.notice', ['user' =&gt; $user], function ($msg) use ($user) &#123; // 发件人的邮箱和用户名 $msg-&gt;from('code0807@163.com', 'LC'); // 收件人的邮箱地址,用户名,提示消息 $msg-&gt;to($user-&gt;email, $user-&gt;name); $msg-&gt;subject('队列发送邮件'); &#125;); &#125;&#125; Mail 「派发」任务在某个业务逻辑处派发具体的任务，即「任务入队」：$this-&gt;dispatch($job) 123456789101112131415161718192021&lt;?phpnamespace App\\Http\\Controllers;use App\\User;use App\\Jobs\\SendNoticeEmail;class UserController extends Controller&#123; public function sendNoticeEmail() &#123; $user = User::findOrFail(1); $job = (new SendNoticeEmail($user))-&gt;onQueue('emails'); //$job = (new SendNoticeEmail($user))-&gt;delay('10'); $this-&gt;dispatch($job); return view('emails.sendmail'); &#125;&#125; 也支持使用 $this-&gt;dispatchFrom() 从请求中派发任务。 只要使用了 DispatchesJobs trait 的类都可以直接通过 $this-&gt;dispatch($job)来派发任务到队列上。 在将任务入队的时候，可以用 onQueue(QUEUE_NAME) 指定任务所属的队列；也可以用 delay(secs) 来延迟多少秒后运行。 处理「回调」所注册的队列任务，运行完成后会被执行的回调操作，比如：数据库状态更新、邮件通知，等。主要有两种： 完成通过：Queue::after($connection, $job, $data)。 失败通过：Queue::failing($connection, $job, $data)。 通常在 AppServiceProvider 类的 boot() 方法中处理队列回调，其中失败事件可以直接在任务类中重写 failed() 方法来处理任务运行失败后的操作。 这里的 $connection 指的是队列连接类型，比如 database。 $job 是指当前任务实例本身的完整信息，其对应的类定义是：Illuminate\\Queue\\Jobs\\DatabaseJob，其中有很多方法可以获取当前队列和任务对象的信息。 $data 是被序列化的 $job 对象属性对象，被存储在任务表的 payload 字段，可以通过 unserialize($data[&#39;data&#39;][&#39;command&#39;]) 来恢复该实例对象。 「侦听」任务代码逻辑写好之后，只是单纯将任务入队操作，并不会执行。需要启动 Laravel 侦听器来处理这些队列任务： 1php artisan queue:listen --queue=default,capture --queue=default,capture 中代表此侦听器将处理哪些队列，排越靠左的队列，优先级越高。 queue:listen 和 queue:work 区别 ？ 本地调试的时候要使用 queue:listen，因为 queue:work在启动后，代码修改，queue:work不会再 Load 上下文，但是 queue:listen仍然会重新 Load 新代码。 其余情况全部使用 queue:work 吧，因为效率更高。 开发环境注意事项 ？ 方便调试队列任务，可以将 Queue Driver 设置为 sync，将队列变成同步执行。 Job 类中的 handle 方法是可以使用依赖注入的。 队列的释放和删除从队列中释放一个任务，只是把这个任务重新放回队列，并不是从队列中删除。 要删除一个队列，需要删除队列中相应的记录，比如是数据库驱动的队列，就需要删除任务表中相关的记录。 也可以用 Artisan 命令来删除失败任务： 123php artisan queue:forget 5 # 删除掉某个失败任务php artisan queue:flush # 删除所有失败任务 非失败任务不能删除，因为任务成功后会自动删除。 队列线上实践在实际应用（线上）中，往往不是使用 queue:listen 来处理队列任务，而是通过 queue:work 配合 --daemon 选项，再加上 supervisor 进程管理器，来处理线上环境的队列任务。 相关配置及脚本如下： 队列任务批量部署脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#! /bin/env bash# deploy.shworkers=1worker_len=16sleep_secs=3#path=/data/wwwroot/eme.devpath=/data/wwwroot/www.eme168.comwhile (( $workers&lt;=$worker_len ))do echo \"deploying phjs-cc queue daemon... ($workers/$worker_len)\" php $path/artisan queue:work database --queue=phjs-cc-$workers --memory=256 --sleep=2 --tries=2 --daemon &amp; sleep $sleep_secs echo \"deploying shrinking-thumb queue daemon... ($workers/$worker_len)\" php $path/artisan queue:work database --queue=shrink-thumb-$workers --memory=256 --sleep=2 --tries=2 --daemon &amp; sleep $sleep_secs echo \"deploying qn-upload queue daemon... ($workers/$worker_len)\" php $path/artisan queue:work database --queue=qn-upload-$workers --memory=128 --sleep=2 --tries=2 --daemon &amp; sleep $sleep_secs let \"workers++\"doneecho 'deploy finished.'exit 0#! /bin/env bash# undeploy.shworkers=0worker_len=16sleep_secs=1while (( $workers&lt;=$worker_len ))do echo \"un-deploying phjs-cc queue daemon... ($workers/$worker_len)\" `tmux kill-session -t \"phjs-cc-$workers\"` sleep $sleep_secs echo \"un-deploying shrinking-thumb queue daemon... ($workers/$worker_len)\" `tmux kill-session -t \"shrink-thumb-$workers\"` sleep $sleep_secs echo \"un-deploying qn-upload queue daemon... ($workers/$worker_len)\" `tmux kill-session -t \"qn-upload-$workers\"` sleep $sleep_secs let \"workers++\"doneecho 'un-deploy finished.'exit 0# ps -ef | grep php | grep -v grep | awk '&#123;print $2&#125;' | xargs kill -9 这里部署的后台处理进程个数根据服务器配置情况而定，这里是在 4 核／16G／20M 的阿里云 ECS 机器上部署的。 安装&amp;使用 supervisor 1234567891011# 以 CentOS 6 为例yum info supervisoryum install -y supervisorservice supervisord start|stop|restartsupervisorctl rereadsupervisorctl start proj-worker:*vim /etc/supervisord.conf supervisor 对应配置 1234567891011121314151617181920212223242526272829[program:proj-phjs]process_name=%(program_name)s_%(process_num)02dcommand=php /data/wwwroot/www.proj.com/artisan queue:work database --queue=phjs-cc-%(process_num)2d --memory=256 --sleep=2 --tries=2 --daemonautostart=trueautorestart=trueuser=wwwnumprocs=16redirect_stderr=truestdout_logfile=/data/wwwroot/www.proj.com/storage/logs/sv-worker.log[program:proj-shrink]process_name=%(program_name)s_%(process_num)02dcommand=php /data/wwwroot/www.proj.com/artisan queue:work database --queue=shrink-thumb-%(process_num)2d --memory=256 --sleep=2 --tries=2 --daemonautostart=trueautorestart=trueuser=wwwnumprocs=16redirect_stderr=truestdout_logfile=/data/wwwroot/www.proj.com/storage/logs/sv-worker.log[program:proj-upload]process_name=%(program_name)s_%(process_num)02dcommand=php /data/wwwroot/www.proj.com/artisan queue:work database --queue=qn-upload-%(process_num)2d --memory=256 --sleep=2 --tries=2 --daemonautostart=trueautorestart=trueuser=wwwnumprocs=16redirect_stderr=truestdout_logfile=/data/wwwroot/www.proj.com/storage/logs/sv-worker.log 注意这里的 numprocs 数最好和 deploy.sh 里面的 workers 数量保持一致，因为确保每个后台运行的队列处理进程都能被 supervisor 监控到。 其中，%(process_num)2d 对应的是数 numprocs 内的序号。0 表示不足多少位（这里是2位）时填充。 参考 Laravel 的队列系统介绍 Laravel队列小结 Laravel 队列系列 —— 基于 Redis 实现任务队列的基本配置和使用","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"Queue","slug":"Queue","permalink":"http://blog.caoxl.com/tags/Queue/"}]},{"title":"Windows 常用命令记录","slug":"Windows-cmd","date":"2018-08-08T03:47:52.000Z","updated":"2018-11-28T03:08:47.000Z","comments":true,"path":"2018/08/08/Windows-cmd/","link":"","permalink":"http://blog.caoxl.com/2018/08/08/Windows-cmd/","excerpt":"这篇文章将记录比较实用的一些 Windows 命令，将不间断更新。","text":"这篇文章将记录比较实用的一些 Windows 命令，将不间断更新。 唤起命令行123windows键 + F然后输入 cmd输出help 可以查看命令列表 命令行操作123456789101112131415161718192021cls // 清屏winver // 查看windows版本write // 写字板mspaint // 画图板magnify // 放大镜mmc // 打开控制中心regedit // 打开注册表calc // 启动计算器osk // 打开屏幕键盘userinit // 打开我的文档esc // 清除当前命令行F7 // 显示命令历史记录，以图形列表窗的形式给出所有曾经输入的命令，并可用上下箭头键选择再次执行该命令alt + F7 // 清除所有层级输入的命令历史记录F8 // 搜索命令的历史记录，循环显示所有曾经输入的命令，直到按下回车键为止F9 // 按编号选择命令，以图形对话框方式要求您输入命令所对应的编号(从0开始)，并将该命令显示在屏幕上ctrl + h // 删除光标左边的一个字符ctrl + c / ctrl + break // 强行终止命令执行ctrl + m // 表示回车确认键alt + printscreen // 截取屏幕上当前命令窗里的内容 电源管理123shutdown -s -t 0 // 立即关机shutdown -a // 取消关机rononce -p // 15秒关机 文件管理1234567891011121314type // 查看文本文件内容type NUL &gt; [path/to/file] // 在某个路径下新建文件fc // 查看两个文本文档的不同之处cd // 跳转到下一个目录copy // 复制move // 移动del // 删除文件/文件夹dir // 显示文件mkdir // 新建文件夹rmdir // 删除文件夹下所有文件及文件夹icacls * /reset // 清除(还原)当前目录下的所有文件/文件夹的权限设置ie4uinit -show // 清除系统图标缓存services.msc // 系统服务管理attrib // 设置文件属性 [详见这篇文章](https://paugram.com/tech/usb-disk-custom-icon.html#%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7)） 网络维护123ping (IP地址/域名) // 向指定服务器进行通信, 测试能否连接ipconfig /flushdns // 清除 DNS 缓存ssh (用户名)@(IP地址) // 建立 SSH 连接, 需要在控制面板添加功能 系统激活1slmgr.vbs -xpr // 查询系统是否批量激活还是永久激活 硬件维护 调取电池使用记录 123// 仅用于笔记本powercfg /BATTERYREPORTC:\\Users\\用户名\\battery-report.html 其他 刷新DNS解析缓存 1ipconfig /flushdns 输入后会自动保存到用户文件夹内，直接键入文件名打开。 其中 DESIGN CAPACITY 是设计容量， FULL CHARGE CAPACITY 是近期充满电池的容量。想要知道电池还有多少毫安，通过公式 mwh（毫瓦时） / 电池电压（V） = 毫安（mAh） 即可得到 参考 windows常用命令行命令 Windows批处理(cmd/bat)使用小记","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.caoxl.com/tags/Windows/"},{"name":"命令","slug":"命令","permalink":"http://blog.caoxl.com/tags/命令/"}]},{"title":"「代码复用」获取客户端IP","slug":"CodeReuse-Client-IP","date":"2018-08-08T02:51:36.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/08/CodeReuse-Client-IP/","link":"","permalink":"http://blog.caoxl.com/2018/08/08/CodeReuse-Client-IP/","excerpt":"Don’t repeat yourself","text":"Don’t repeat yourself 直接上源码123456789101112131415161718192021222324252627282930&lt;?php// Client releated operations// @caoxlnamespace App\\Traits;class Client&#123; public static function ip() &#123; if ($clientIP = self::tryIPKey('HTTP_CLIENT_IP')) &#123; &#125; elseif ($clientIP = self::tryIPKey('HTTP_X_FORWARDED_FOR')) &#123; &#125; elseif ($clientIP = self::tryIPKey('HTTP_X_FORWARDED')) &#123; &#125; elseif ($clientIP = self::tryIPKey('HTTP_FORWARDED_FOR')) &#123; &#125; elseif ($clientIP = self::tryIPKey('HTTP_FORWARDED')) &#123; &#125; elseif ($clientIP = self::tryIPKey('REMOTE_ADDR')) &#123; &#125; else $clientIP = 'UNKNOWN'; return $clientIP; &#125; public static function tryIPKey(string $possibleKey) &#123; return getenv($possibleKey) ?? ( $_SERVER[$possibleKey] ?? null ); &#125;&#125; 说明: getenv() - 获取一个环境变量的值 HTTP_CLIENT_IP - $_SERVER[‘HTTP_CLIENT_IP’] HTTP_CLIENT_IP 是代理服务器发送的HTTP头。如果是“超级匿名代理”，则返回none值 HTTP_X_FORWARDED_FOR - $_SERVER[‘HTTP_X_FORWARDED_FOR’] 用来识别经过HTTP代理后的客户端IP地址（有可能存在，也可以伪造） HTTP_X_FORWARDED - $_SERVER[‘HTTP_X_FORWARDED’] HTTP_FORWARDED_FOR - $_SERVER[‘HTTP_FORWARDED_FOR’] X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段 HTTP_FORWARDED - $_SERVER[‘HTTP_FORWARDED’] REMOTE_ADDR - $_SERVER[‘REMOTE_ADDR’] REMOTE_ADDR 是你的客户端跟你的服务器“握手”时候的IP。如果使用了“匿名代理”，REMOTE_ADDR将显示代理服务器的IP。浏览当前页面的用户的 IP 地址。","categories":[{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/categories/代码复用/"}],"tags":[{"name":"Client","slug":"Client","permalink":"http://blog.caoxl.com/tags/Client/"},{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/tags/代码复用/"},{"name":"IP","slug":"IP","permalink":"http://blog.caoxl.com/tags/IP/"}]},{"title":"「代码复用」 CURL","slug":"CodeReuse-Simple-CURL-functions","date":"2018-08-08T02:22:00.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/08/CodeReuse-Simple-CURL-functions/","link":"","permalink":"http://blog.caoxl.com/2018/08/08/CodeReuse-Simple-CURL-functions/","excerpt":"Don’t repeat yourself","text":"Don’t repeat yourself 直接上源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php// Simple CURL Helper funcitons// @caoxlnamespace App\\Traits;trait CURL&#123; public function requestJsonApi( $uri, $type = 'POST', $params = [], $headers = [] ) &#123; $headers = [ 'Content-Type: application/json; Charset=UTF-8', ]; $res = $this-&gt;requestHTTPApi($uri, $type, $headers, $params); if (! $res['err']) &#123; $res['res'] = json_decode($res['res'], true); &#125; return $res; &#125; public function requestHTTPApi( string $uri, string $type = 'GET', array $headers = [], $data ) &#123; $setOpt = [ CURLOPT_URL =&gt; $uri, CURLOPT_RETURNTRANSFER =&gt; true, ]; if ($headers) &#123; $setOpt[CURLOPT_HTTPHEADER] = $headers; &#125; if ('POST' == $type) &#123; $setOpt[CURLOPT_POST] = true; $setOpt[CURLOPT_POSTFIELDS] = $data; &#125; $ch = curl_init(); curl_setopt_array($ch, $setOpt); $res = curl_exec($ch); $errNo = curl_errno($ch); $errMsg = curl_error($ch); curl_close($ch); return [ 'err' =&gt; $errNo, 'msg' =&gt; ($errMsg ?: 'ok'), 'res' =&gt; $res, ]; &#125;&#125; 说明 Traits https://secure.php.net/manual/zh/language.oop5.traits.php自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。… requestHTTPApi curl_init() - 初始化新的会话，返回 cURL 句柄，供curl_setopt()、 curl_exec() 和 curl_close() 函数使用。 curl_setopt_array() - 为 cURL 传输会话批量设置选项。这个函数对于需要设置大量的 cURL 选项是非常有用的，不需要重复地调用 curl_setopt()。 curl_setopt() - 设置 cURL 传输选项 curl_setopt($ch, $option, $value)点击查看可以设置的CURLOPT_XXX选项 curl_exec() - 执行给定的 cURL 会话。 curl_errno() - 返回最后一次 cURL 操作的错误代码。 curl_error() - 返回最近一次 cURL 操作的文本错误详情。 curl_close() - 关闭 cURL 会话并且释放所有资源。cURL 句柄 ch 也会被删除。 requestJsonApi json_decode() - 对 JSON 格式的字符串进行解码, 当该参数为 TRUE 时，将返回 array 而非 object 。","categories":[{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/categories/代码复用/"}],"tags":[{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/tags/代码复用/"},{"name":"CURL","slug":"CURL","permalink":"http://blog.caoxl.com/tags/CURL/"}]},{"title":"基于Lumen-微信支付","slug":"Lumen-Wxpay","date":"2018-08-08T02:12:40.000Z","updated":"2019-08-22T06:19:34.000Z","comments":true,"path":"2018/08/08/Lumen-Wxpay/","link":"","permalink":"http://blog.caoxl.com/2018/08/08/Lumen-Wxpay/","excerpt":"用户在商家app内选择微信支付下单成功后，商家通过平台提供的接口获取到唤起微信支付的参数信息，然后在商家app内唤起微信支付，用户在微信内确认支付后会自动返回到用户app内。","text":"用户在商家app内选择微信支付下单成功后，商家通过平台提供的接口获取到唤起微信支付的参数信息，然后在商家app内唤起微信支付，用户在微信内确认支付后会自动返回到用户app内。 微信支付调用流程 原图点击–&gt; 业务流程 支付准备请求参数列表 https://open.swiftpass.cn/openapi/doc?index_1=4&amp;index_2=1&amp;chapter_1=516&amp;chapter_2=546 请求url: https://pay.swiftpass.cn/pay/gateway POST XML 内容体进行请求 直接上源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644&lt;?php// Weixin payment operations (Non-official)// see docs: &lt;https://open.swiftpass.cn/openapi&gt;// @caoxlnamespace App\\Http\\Controllers\\Payment;use Illuminate\\Support\\Facades\\Validator, Illuminate\\Http\\Request, App\\Models\\Finance\\RefundLog;use App\\Traits\\&#123;Client, Tool&#125;;use App\\Models\\User\\&#123;User, PaymentLog&#125;;class Wxpay implements \\App\\Contract\\PaymentMethod&#123; use \\App\\Traits\\CURL; private $config = null; private $amountEscape = 1; /** * @param array $params * @return array|bool */ public function prepare(array &amp;$params) &#123; if (true !== ($configCheckRes = $this-&gt;checkConfig())) &#123; return $configCheckRes; &#125; elseif (true !== ($paramsValidateRes = $this-&gt;validate($params, [ 'client' =&gt; 'required|in:wap,mobile', 'amount' =&gt; 'required|numeric|min:0.01', 'notify' =&gt; 'required|url', 'origin' =&gt; 'required', 'mid' =&gt; 'required|integer|min:1', 'desc' =&gt; 'required', ]))) &#123; return $paramsValidateRes; &#125; if ('wap' == $params['client']) &#123; if (true !== ($hasReturnUrl = $this-&gt;validate($params, [ 'wxuser_openid' =&gt; 'required', 'return' =&gt; 'required|url', ]))) &#123; return $hasReturnUrl; &#125; /*if (!isset($params['wxuser_openid'])) &#123; if (false === ($openID = $this-&gt;findUserWxOpenID( $params['mid'] ))) &#123; return [ 'err' =&gt; 5002, 'msg' =&gt; Tool::sysMsg('MISSING_WXUSER_OPENID'), ]; &#125; else &#123; $params['wxuser_openid'] = $openID; &#125; &#125;*/ &#125; return $this-&gt;createPaymentLog($params); &#125; /** * @param int $uid * @return bool */ protected function findUserWxOpenID(int $uid) &#123; $user = User::find($uid); if (!$user || !isset($user-&gt;wx_openid) || !$user-&gt;wx_openid) &#123; return false; &#125; return $user-&gt;wx_openid; &#125; /** * @return array|bool */ protected function checkConfig() &#123; $this-&gt;config = config('custom')['wxpay_wft'] ?? []; if (! $this-&gt;config) &#123; return [ 'err' =&gt; 5001, 'msg' =&gt; Tool::sysMsg('MISSING_WFT_WXPAY_CONFIG'), ]; &#125; elseif (true !== ($configValidateRes = $this-&gt;validate($this-&gt;config, [ 'gateway' =&gt; 'required|url', 'jspay_url' =&gt; 'required|url', 'appid_app' =&gt; 'required', 'appid_wap' =&gt; 'required', 'key_app' =&gt; 'required', 'key_wap' =&gt; 'required', 'mchid_app' =&gt; 'required', 'mchid_wap' =&gt; 'required', ]))) &#123; return $configValidateRes; &#125; return true; &#125; /** * @param array $params * @return array|bool */ protected function createPaymentLog(array &amp;$params) &#123; // Generate a trade no and create an payment log record of this user $params['trade_no'] = $params['trade_no'] ?? Tool::tradeNo($params['mid']); $params['client_ip'] = Client::ip(); $data = [ 'uid' =&gt; $params['mid'], 'from' =&gt; $params['origin'], 'payment' =&gt; 'wxpay', 'trade_no' =&gt; $params['trade_no'], 'amount' =&gt; $params['amount'], 'payed' =&gt; 0, 'clientip' =&gt; $params['client_ip'], 'dateline' =&gt; time(), ]; $_data = [ '__wx_client' =&gt; $params['client'] ]; if (isset($params['order_id']) &amp;&amp; $params['order_id']) &#123; $data['order_id'] = $params['order_id']; &#125; if (isset($params['data']) &amp;&amp; is_array($params['data']) &amp;&amp; $params['data'] ) &#123; $_data = array_merge($_data, $params['data']); &#125; $data['data'] = json_encode( $_data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ); $paymentLoggedId = PaymentLog::insertGetId($data); return $paymentLoggedId ? true : [ 'err' =&gt; 5001, 'msg' =&gt; Tool::sysMsg('DATA_UPDATE_ERROR'), ]; &#125; /** * @param array $params * @param array $rules * @return array|bool */ protected function validate(array $params, array $rules) &#123; $validator = Validator::make($params, $rules); if ($validator-&gt;fails()) &#123; return [ 'err' =&gt; 400, 'msg' =&gt; $validator-&gt;errors()-&gt;first(), ]; &#125; return true; &#125; /** * @return string */ protected function nonceStr(): string &#123; return mt_rand(time(), time()+rand()); &#125; /** * @param array $params * @param string $key * @return string */ protected function sign(array $params, string $key): string &#123; $sign = ''; ksort($params); foreach ($params as $k =&gt; $v) &#123; if (is_scalar($v) &amp;&amp; ('' != $v) &amp;&amp; ('sign' != $k)) &#123; $sign .= $k.'='.$v.'&amp;'; &#125; &#125; $sign .= 'key='.$key; $sign = strtoupper(md5($sign)); return $sign; &#125; /** * @return RefundLog */ protected function refundLog() &#123; return new RefundLog; &#125; /** * @param array $params * @return array|bool */ public function refund(array $params) &#123; if (true !== ($configCheckRes = $this-&gt;checkConfig())) &#123; return $configCheckRes; &#125; elseif (true !== ($legalParams = $this-&gt;validate($params, [ 'paylog_id' =&gt; 'required|integer|min:1', 'id_type' =&gt; 'required|in:transaction_id,out_trade_no', 'trade_no' =&gt; 'required', 'amount' =&gt; 'required|numeric|min:0.01', 'operator' =&gt; 'required', ]))) &#123; return $legalParams; &#125; $createAt = date('Y-m-d H:i:s'); try &#123; $paymentLog = PaymentLog::select('amount', 'data') -&gt;whereLogId($params['paylog_id']) -&gt;first(); if (! ($amountTotal = $paymentLog-&gt;amount)) &#123; return [ 'err' =&gt; 5001, 'msg' =&gt; Tool::sysMsg('No_PAYMENT_LOG'), ]; &#125; if ($paymentLog-&gt;data &amp;&amp; ($extra = json_decode($paymentLog-&gt;data, true)) &amp;&amp; isset($extra['__wx_client']) &amp;&amp; ('wap' == $extra['__wx_client']) ) &#123; $wxClient = 'wap'; &#125; else &#123; $wxClient = 'app'; &#125; // Check if all trade amount refunded already $refundLog = $this-&gt;refundLog(); $refundedAmount = $refundLog-&gt;refundedAmount( $params['paylog_id'], 'wxpay' ); if ($refundedAmount-&gt;amountRefunded) &#123; $amountRefunded = floatval($refundedAmount-&gt;amountRefunded); $amountTotal = floatval($amountTotal); $amountCanBeRefunded = abs($amountTotal - $amountRefunded); if ($amountTotal &lt; $amountCanBeRefunded) &#123; return [ 'err' =&gt; 5002, 'msg' =&gt; Tool::sysMsg('REFUND_AMOUNT_ILLEGAL'), ]; &#125; elseif ($amountRefunded &gt;= $amountTotal) &#123; return [ 'err' =&gt; 5003, 'msg' =&gt; Tool::sysMsg('REFUNDED_ALL_ALREADY'), ]; &#125; &#125; $totalFee = $this-&gt;getIntFee($amountTotal); $refundFee = $this-&gt;getIntFee($params['amount']); if ((false === $totalFee) || (false === $refundFee)) &#123; return [ 'err' =&gt; 5004, 'msg' =&gt; Tool::sysMsg('ILLEGAL_FEE_AMOUNT'), ]; &#125; $data = [ 'service' =&gt; 'unified.trade.refund', 'mch_id' =&gt; $this-&gt;config['mchid_'.$wxClient], 'total_fee' =&gt; $totalFee, 'refund_fee' =&gt; $refundFee, 'op_user_id' =&gt; 'mch_wxpay_program', // static 'nonce_str' =&gt; $this-&gt;nonceStr(), 'out_refund_no' =&gt; Tool::tradeNo(0, '04'), ]; $data[$params['id_type']] = $params['trade_no']; $data['sign'] = $this-&gt;sign( $data, $this-&gt;config['key_'.$wxClient] ); $xml = Tool::arrayToXML($data); $res = $this-&gt;requestHTTPApi( $this-&gt;config['gateway'], 'POST', [ 'Content-Type: application/xml; Charset=UTF-8', ], $xml ); $processAt = date('Y-m-d H:i:s'); $res['dat'] = Tool::xmlToArray($res['res']); unset($res['res']); // Check if sign is from swiftpass.cn (No need here anyway) // $legalRet = $res['dat']['sign']==$this-&gt;sign($res['dat']) $errMsg = $res['dat']['err_msg'] ?? false; $reason = $params['reason'] ?? Tool::sysMsg('REFUND_REASON_COMMON'); $_data = [ 'refund_no' =&gt; $data['out_refund_no'], 'paylog_id' =&gt; $params['paylog_id'], 'amount' =&gt; $params['amount'], 'reason_request' =&gt; $reason, 'operator' =&gt; $params['operator'], 'create_at' =&gt; $createAt, 'process_at' =&gt; $processAt, ]; $refundSuccess = false; if (isset($res['dat']['status']) &amp;&amp; (0 == $res['dat']['status']) &amp;&amp; isset($res['dat']['result_code']) &amp;&amp; (0 == $res['dat']['result_code']) &amp;&amp; isset($res['dat']['refund_id']) ) &#123; // Insert or update into refund log $_data['status'] = 1; $_data['out_refund_no'] = $res['dat']['refund_id']; if (! $refundLog-&gt;insert($_data)) &#123; return [ 'err' =&gt; '503X', 'msg' =&gt; Tool::sysMsg('DATA_UPDATE_ERROR'), ]; &#125; $refundSuccess = true; &#125; if ($refundSuccess) &#123; return [ 'err' =&gt; 0, 'msg' =&gt; 'ok', ]; &#125; elseif ($errMsg) &#123; $_data['status'] = 2; $_data['reason_fail'] = $errMsg; if (! $refundLog-&gt;insert($_data)) &#123; return [ 'err' =&gt; '503X', 'msg' =&gt; Tool::sysMsg('DATA_UPDATE_ERROR'), ]; &#125; return [ 'err' =&gt; 5005, 'msg' =&gt; $errMsg, ]; &#125; else &#123; return [ 'err' =&gt; 5006, 'msg' =&gt; Tool::sysMsg('REFUND_REQUEST_FAILED'), ]; &#125; &#125; catch (\\Exception $e) &#123; return [ 'err' =&gt; '500X', 'msg' =&gt; $e-&gt;getMessage(), ]; &#125; &#125; /** * @param float $amount * @return array|bool|float */ public function getIntFee(float $amount) &#123; $amount = explode('.', $amount*100); $amount = isset($amount[0]) ? intval($amount[0]) : false; return $amount; &#125; /** * @param array $params * @return array */ public function pay(array &amp;$params): array &#123; if (true !== ($prepareRes = $this-&gt;prepare($params))) &#123; return $prepareRes; &#125; $this-&gt;amountEscape = in_array( env('APP_ENV'), ['local', 'test', 'stage',] ) ? 1 : $this-&gt;getIntFee($params['amount']); if (false === $this-&gt;amountEscape) &#123; return [ 'err' =&gt; 5001, 'msg' =&gt; Tool::sysMsg('ILLEGAL_FEE_AMOUNT'), ]; &#125; $_params = [ 'out_trade_no' =&gt; $params['trade_no'], 'body' =&gt; $params['desc'], 'total_fee' =&gt; $this-&gt;amountEscape, 'mch_create_ip' =&gt; $params['client_id'], 'notify_url' =&gt; $params['notify'], 'nonce_str' =&gt; $this-&gt;nonceStr(), ]; $fillPayDataHandler = 'fillPayDataFor'.ucfirst($params['client']); if (! method_exists($this, $fillPayDataHandler)) &#123; return [ 'err' =&gt; 5002, 'msg' =&gt; Tool::sysMsg('MISSING_PAY_METHOD_HANDLER'), ]; &#125; return $this-&gt;$fillPayDataHandler($_params, $params); &#125; /** * @param array $params * @param array $_params * @return array */ protected function fillPayDataForWap(array $params, array $_params) &#123; $params['service'] = 'pay.weixin.jspay'; $params['sub_openid'] = $_params['wxuser_openid']; $params['callback_url'] = $_params['return']; $params['mch_id'] = $this-&gt;config['mchid_wap']; $params['sub_appid'] = $this-&gt;config['appid_wap']; $params['sign'] = $this-&gt;sign($params, $this-&gt;config['key_wap']); $xml = Tool::arrayToXML($params); $res = $this-&gt;requestHTTPApi( $this-&gt;config['gateway'], 'POST', [ 'Content-Type: application/xml; Charset=UTF-8', ], $xml ); if (! ($ret = Tool::xmlToArray($res['res'])) || !isset($ret['token_id']) || !($tokenId = $ret['token_id']) ) &#123; return [ 'err' =&gt; 5001, 'msg' =&gt; ( $ret['message'] ?? Tool::sysMsg('WXPAY_REQUEST_FAILED') ), ]; &#125; $res['dat']['url'] = base64_encode( $this-&gt;config['jspay_url'].'?token_id='.$tokenId ); unset($res['res']); return $res; &#125; /** * @param array $params * @param array $_params * @return array */ protected function fillPayDataForMobile(array $params, array $_params) &#123; $params['service'] = 'unified.trade.pay'; $params['mch_id'] = $this-&gt;config['mchid_app']; $params['sub_appid'] = $this-&gt;config['appid_app']; $params['sign'] = $this-&gt;sign($params, $this-&gt;config['key_app']); $xml = Tool::arrayToXML($params); $res = $this-&gt;requestHTTPApi( $this-&gt;config['gateway'], 'POST', [ 'Content-Type: application/xml; Charset=UTF-8', ], $xml ); $res['dat']['params'] = Tool::xmlToArray($res['res']); // For IOS SDK use only $res['dat']['params']['amount'] = $this-&gt;amountEscape; unset($res['res']); return $res; &#125; /** * @param $transHook * @param string $client * @return string */ public function payCallback($transHook, $client = 'app'): string &#123; $params = []; if (true === $this-&gt;tradeSuccess($params, $client)) &#123; // Update payment log // Execute wxpay caller's transhook // Find out the payment log $paymentLog = PaymentLog::select( 'log_id', 'uid', 'amount', 'clientip' )-&gt;whereTradeNoAndPayedAndPayment( $params['out_trade_no'], 0, 'wxpay' )-&gt;first(); if (!$paymentLog || !isset($paymentLog-&gt;uid)) &#123; return 'fail'; &#125; elseif (!($user = User::find($paymentLog-&gt;uid))) &#123; return 'fail'; &#125; \\DB::beginTransaction(); $timestamp = time(); // Execute transaction hook $transHookSuccess = $transHook( $user, $paymentLog-&gt;amount, 'wxpay', $paymentLog-&gt;clientip, $timestamp ); if ($transHookSuccess) &#123; // Update payment log $updatedPayStatus = PaymentLog::whereLogId( $paymentLog-&gt;log_id )-&gt;update([ 'payed' =&gt; 1, 'payedip' =&gt; $paymentLog-&gt;clientip, 'pay_trade_no' =&gt; $params['transaction_id'], 'payedtime' =&gt; $timestamp, ]); if ($updatedPayStatus &gt;= 0) &#123; \\DB::commit(); return 'success'; &#125; &#125; \\DB::rollBack(); &#125; return 'fail'; &#125; // Verify callback is from swiftpass.cn and payment is success /** * @param array $params * @param string $client * @return array|bool */ public function tradeSuccess(array &amp;$params = [], $client = 'app') &#123; $this-&gt;config = config('custom')['wxpay_wft'] ?? false; if (!in_array($client, ['app', 'wap'])) &#123; return [ 'err' =&gt; 5001, 'msg' =&gt; Tool::sysMsg('ILLEGAL_CLIENT_TYPE'), ]; &#125; if (true !== ($configValidateRes = $this-&gt;validate($this-&gt;config, [ 'key_'.$client =&gt; 'required', ]))) &#123; return $configValidateRes; &#125; $params = Tool::xmlToArray(file_get_contents('php://input')); if ($params &amp;&amp; is_array($params) &amp;&amp; isset($params['sign']) &amp;&amp; isset($params['result_code']) &amp;&amp; isset($params['total_fee']) &amp;&amp; ($params['sign'] == $this-&gt;sign( $params, $this-&gt;config['key_'.$client]) ) &amp;&amp; (0 == $params['status']) &amp;&amp; (0 == $params['result_code']) &amp;&amp; (0 &lt; $params['total_fee']) ) &#123; return true; &#125; return false; &#125; /** * @return float */ protected function getRefundFee() &#123; return 0.008; &#125;&#125; 说明 \\App\\Contract\\PaymentMethod - 见:基于Laravel/Lumen-支付宝支付(Alipay) \\App\\Traits\\CURL - 「代码复用」 CURL public function prepare(array &amp;params): 支付准备 protected function findUserWxOpendID(): 获得用户openid protectec function checkConfig(): 检查配置 protected function createPaymentLog(array &amp;$params): 生成支付日志 protected function validate(array $params, array $rules): 数据验证 protected function nonceStr(): string: 生成随机字符串 protected function sign(array $params, string $key): string: 生成签名 protected function refundLog(): 退款日志 public function refund(array $params): 微信退款 public function getIntFee(float $amount): 所有涉及到金额的单位都是分，最小的单位是1分，不能有小数出现 public function pay(array $params): array: 微信支付操作 protected function fillPayDataForWap(array $params, array $_params): 微信电脑端支付 protected function fillPayDataForMobile(array $params, array $_params): 微信手机端支付 public function payCallback($transHook, $client = &#39;app&#39;):string: 微信支付回调 public function tradeSuccess(array &amp;$params = [], $client = &#39;app&#39;): 交易验证 protected function getRefundFee(): 获取退款金额 本文仅供参考, 请结合文档以及具体需求, 编写适合自己的代码.","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"支付","slug":"支付","permalink":"http://blog.caoxl.com/tags/支付/"},{"name":"微信支付","slug":"微信支付","permalink":"http://blog.caoxl.com/tags/微信支付/"}]},{"title":"「代码复用」数组与XML互转","slug":"CodeReuse-arrayToXML-xmlToArray","date":"2018-08-08T01:59:58.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/08/CodeReuse-arrayToXML-xmlToArray/","link":"","permalink":"http://blog.caoxl.com/2018/08/08/CodeReuse-arrayToXML-xmlToArray/","excerpt":"Don’t repeat yourself","text":"Don’t repeat yourself xmlToArray12345678public static function xmlToArray(string $xml)&#123; return json_decode(json_encode(simplexml_load_string( $xml, 'SimpleXMLElement', LIBXML_NOCDATA )), true);&#125; json_decode() 对 JSON 格式的字符串进行解码,当该assoc为 TRUE 时，将返回 array 而非 object json_encode() json_encode — 对变量进行 JSON 编码 simplexml_load_string() simplexml_load_string - 将格式良好的XML字符串将其作为对象返回 arrayToXML1234567891011121314public static function arrayToXML(array $array, string &amp;$xml): string&#123; foreach ($array as $key =&gt; &amp;$val) &#123; if (is_array($val)) &#123; $_xml = ''; $val = self::arrayToXML($val, $_xml); &#125; $xml .= \"&lt;$key&gt;$val&lt;/$key&gt;\"; &#125; unset($val); return $xml;&#125; : string 写法是PHP7的新特性","categories":[{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/categories/代码复用/"}],"tags":[{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/tags/代码复用/"},{"name":"XML","slug":"XML","permalink":"http://blog.caoxl.com/tags/XML/"},{"name":"数组","slug":"数组","permalink":"http://blog.caoxl.com/tags/数组/"}]},{"title":"基于Laravel/Lumen-支付宝支付(Alipay)","slug":"Laravel-Lumen-Alipay","date":"2018-08-07T06:51:52.000Z","updated":"2019-08-22T06:20:06.000Z","comments":true,"path":"2018/08/07/Laravel-Lumen-Alipay/","link":"","permalink":"http://blog.caoxl.com/2018/08/07/Laravel-Lumen-Alipay/","excerpt":"latrell/Alipay支付宝SDK在Laravel5的封装。该拓展包想要达到在Laravel5/Lumen框架下，便捷使用支付宝的目的。 by latrell/Alipay博客中还有另外一篇 基于Lumen-支付宝支付(Payment)","text":"latrell/Alipay支付宝SDK在Laravel5的封装。该拓展包想要达到在Laravel5/Lumen框架下，便捷使用支付宝的目的。 by latrell/Alipay博客中还有另外一篇 基于Lumen-支付宝支付(Payment) 原图请看–&gt;手机网站支付快速接入 安装1composer require latrell/alipay dev-master 本文封装中还使用了: Payment 1composer require \"riverslei/payment:*\" 本文的返回值使用了: i18n 使用要使用支付宝SDK服务提供者，你必须自己注册服务提供者到Laravel/Lumen服务提供者列表中。 基本上有两种方法可以做到这一点。 Laravel找到 config/app.php 配置文件中，key为 providers 的数组，在数组中添加服务提供者。 1234'providers' =&gt; [ // ... 'Latrell\\Alipay\\AlipayServiceProvider',] 运行 php artisan vendor:publish 命令，发布配置文件到你的项目中。 Lumen在bootstrap/app.php里注册服务。 12// Register Service Providers$app-&gt;register(Latrell\\Alipay\\AlipayServiceProvider::class); 由于Lumen的artisan命令不支持vendor:publish,需要自己手动将src/config下的配置文件拷贝到项目的config目录下, 并将config.php改名成latrell-alipay.php, mobile.php改名成latrell-alipay-mobile.php, web.php改名成latrell-alipay-web.php. latrell-alipay.sample.php 123456789&lt;?phpreturn [ // 合作身份者id 以 `2088` 开头的16位纯数字 'partner_id' =&gt; '2088xxxxxxxxxxxxx', // 卖家支付宝帐户 'seller_id' =&gt; 'xxxx']; latrell-alipay-mobile.sample.php 123456789101112131415161718&lt;?phpreturn [ // 安全检验码，以数字和字母组成的32位字符 'key' =&gt; 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', // 签名方式 'sign_type' =&gt; 'RSA', // 商户私钥 'private_key_path' =&gt; __DIR__ . '/key/private_key.pem', // 阿里公钥 'public_key_path' =&gt; __DIR__ . '/key/public_key.pem', // 异步通知连接 'notify_url' =&gt; 'http://xxx']; latrell-alipay-web.sample.php 123456789101112131415&lt;?phpreturn [ // 安全检验码，以数字和字母组成的32位字符 'key' =&gt; 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx', // 签名方式 'sign_type' =&gt; 'MD5', // 服务器异步通知页面路径 'notify_url' =&gt; 'http://xxx', // 页面跳转同步通知页面路径 'return_url' =&gt; 'http://xxx']; 插件实例支付申请手机端123456789// 创建支付单。$alipay = app('alipay.mobile');$alipay-&gt;setOutTradeNo('order_id');$alipay-&gt;setTotalFee('order_price');$alipay-&gt;setSubject('goods_name');$alipay-&gt;setBody('goods_description');// 返回签名后的支付参数给支付宝移动端的SDK。return $alipay-&gt;getPayPara(); 网页1234567891011// 创建支付单。$alipay = app('alipay.web');$alipay-&gt;setOutTradeNo('order_id');$alipay-&gt;setTotalFee('order_price');$alipay-&gt;setSubject('goods_name');$alipay-&gt;setBody('goods_description');$alipay-&gt;setQrPayMode('4'); //该设置为可选，添加该参数设置，支持二维码支付。// 跳转到支付页面。return redirect()-&gt;to($alipay-&gt;getPayLink()); 项目应用代码封装 支付是一个与钱打交道的操作, 必须确保交易正常. app/Contract/PaymentMethod.php 12345678910111213141516171819202122&lt;?php// Payment methods contract// @caoxlnamespace App\\Contract;interface PaymentMethod&#123; // Validate payment parameters before pay action public function prepare(array &amp;$params); // Pay action // @params Payment uses parameters // @return format: // [ // 'err' =&gt; 0, // 'msg' =&gt; 'ok', // 'dat' =&gt; [...], // optional // ] public function pay(array &amp;$params): array;&#125; 所有支付类必须实现这个接口中定义的所有方法 app/Http/Controllers/Payment/Alipay.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323&lt;?php// Alipay operations// @caoxlnamespace App\\Http\\Controllers\\Payment;use Illuminate\\Support\\Facades\\Validator, Illuminate\\Http\\Request, App\\Traits\\Tool, Payment\\Common\\PayException, Payment\\Client\\Refund, Payment\\Config, App\\Models\\Finance\\RefundLog;class Alipay implements \\App\\Contract\\PaymentMethod&#123; /** * @param array $params * @return array|bool */ public function prepare(array &amp;$params) &#123; $validator = Validator::make($params, [ 'client' =&gt; 'required|in:web,wap,mobile', 'amount' =&gt; 'require|numeric|min:0.01', 'notify' =&gt; 'required|url', 'trade_no' =&gt; 'required', 'desc' =&gt; 'required', ]); if ($validator-&gt;fails()) &#123; return [ 'err' =&gt; 400, 'msg' =&gt; $validator-&gt;errors()-&gt;first(), ]; &#125; return true; &#125; /** * @param array $params * @return array */ public function pay(array &amp;$params): array &#123; if (true !== ($prepareRes = $this-&gt;prepare($params))) &#123; return $prepareRes; &#125; $amountEscape = in_array(env('APP_ENV'), ['local', 'test', 'stage']) ? 0.01 : $params ['amount']; $alipay = app('alipay.' . $params['client']); $alipay-&gt;setOutTradeNo($params['trade_no']); $alipay-&gt;setTotalFee($amountEscape); $alipay-&gt;setSubject($params['desc']); $alipay-&gt;setNotifyUrl($params['notify']); if (isset($params['body']) &amp;&amp; is_string($params['body']) &amp;&amp; $params['body'] ) &#123; $alipay-&gt;setBody($params['body']); &#125; $fillPayDatHandler = 'fillPayDataFor' . ucfirst($params['client']); if (! method_exists($this, $fillPayDatHandler)) &#123; return [ 'err' =&gt; 5001, 'msg' =&gt; Tool::sysMsg('MISSING_PAY_METHOD_HANDLER'), ]; &#125; return $this-&gt;$fillPayDatHandler($alipay, $params); &#125; /** * @param $alipay * @param $params * @return array */ protected function fillPayDataForMobile(&amp;$alipay, $params): array &#123; return [ 'err' =&gt; 0, 'msg' =&gt; 'ok', 'dat' =&gt; [ 'params' =&gt; $alipay-&gt;getPayPara(), ], ]; &#125; /** * @param $alipay * @param $params * @return array */ protected function fillPayDataForWeb(&amp;$alipay, $params): array &#123; $alipay-&gt;setAppPay('N'); $validator = Validator::make($params, [ 'return' =&gt; 'required|url', ]); if ($validator-&gt;fails()) &#123; return [ 'err' =&gt; 400, 'msg' =&gt; $validator-&gt;errors()-&gt;first(), ]; &#125; // Enable QR pay, optional // See: &lt;https://doc.open.alipay.com/support/hotProblemDetail.htm?spm=a219a.7386797.0.0.LjEOn6&amp;source=search&amp;id=226728&gt; if (isset($params['qrpay']) &amp;&amp; in_array($params['qrpay'], [0, 1, 2, 3, 4]) &amp;&amp; method_exists($alipay, 'setQrPayMode') ) &#123; $alipay-&gt;setQrPayMode($params['qrpay']); &#125; $alipay-&gt;setReturnUrl($params['return']); return [ 'err' =&gt; 0, 'msg' =&gt; 'ok', 'dat' =&gt; [ 'url' =&gt; base64_encode($alipay-&gt;getPayLink()), ], ]; &#125; /** * @param $alipay * @param $params * @return array */ protected function fillPayDataForWap(&amp;$alipay, $params): array &#123; return $this-&gt;fillPayDataForWeb($alipay, $params); &#125; /** * @param $client * @return bool */ public function tradeSuccess($client): bool &#123; if (! in_array($client, ['wap', 'web', 'mobile'])) &#123; return false; &#125; elseif (! app('alipay.' . $client)-&gt;verify()) &#123; return false; &#125; elseif (! ($tradeStatus = ($_REQUEST['trade_status'] ?? false)) || !in_array($tradeStatus, [ 'TRADE_SUCCESS', 'TRADE_FINISHED' ]) ) &#123; return false; &#125; return true; &#125; public function payCallback($transHook): string &#123; // TODO &#125; protected function validate(array $params, array $rules) &#123; $validator = Validator::make($params, $rules); if ($validator-&gt;fails()) &#123; return [ 'err' =&gt; 400, 'msg' =&gt; $validator-&gt;errors()-&gt;first(), ]; &#125; return true; &#125; /** * @param array $params * @return array|bool */ public function refund(array $params) &#123; $createAt = time(); $config = config('custom')['alipay'] ?? []; if (true !== ( $legalConfig = $this-&gt;validate($config, [ 'app_id' =&gt; 'required', 'sign_type' =&gt; 'required|in:RSA,RSA2', 'use_sandbox' =&gt; 'required', 'ali_public_key' =&gt; 'required', 'rsa_private_key' =&gt; 'required' ]))) &#123; return $legalConfig; &#125; elseif (true !== ($legalParams = $this-&gt;validate($params, [ 'paylog_id' =&gt; 'required|integer|min:1', 'id_type' =&gt; 'required|in:trade_no,out_trade_no', 'trade_no' =&gt; 'required', 'amount' =&gt; 'required|numeric|min:0.01', 'operator' =&gt; 'required', ]))) &#123; return $legalParams; &#125; try &#123; $refundLog = RefundLog::wherePaylogId($params['paylog_id'])-&gt;first(); $refundNo = $refundLog ? $refundLog-&gt;refund_no : Tool::tradeNo(0, '04'); $reason = $params['reason'] ?? Tool::sysMsg( 'REFUND_REASON_COMMON' ); $data = [ 'refund_fee' =&gt; $params['amount'], 'reason' =&gt; $reason, 'refund_no' =&gt; $refundNo, ]; $data[$params['id_type']] = $params['trade_no']; $_data = [ 'refund_no' =&gt; $refundNo, 'amount' =&gt; $params['amount'], 'paylog_id' =&gt; $params['paylog_id'], 'operator' =&gt; $params['operator'], 'reason_request' =&gt; $reason, ]; $err = 0; $msg = 'ok'; $ret = Refund::run(Config::ALI_REFUND, $config, $data); $processAt = time(); if (isset($ret['code']) &amp;&amp; ('10000' == $ret['code'])) &#123; $_data['process_at'] = date('Y-m-d H:i:s'); $_data['status'] = 1; &#125; else &#123; $err = $ret['code'] ?? 5001; $msg = $reasonFail = $ret['msg'] ?? Tool::sysMsg( 'REFUND_REQUEST_FAILED' ); &#125; if (true !== ($updateOrInsertRefundLogRes = $this-&gt;updateOrInsertRefundLog( $refundLog, $_data, $createAt ))) &#123; return $updateOrInsertRefundLogRes; &#125; return [ 'err' =&gt; $err, 'msg' =&gt; $msg, 'dat' =&gt; $ret, ]; &#125; catch (PayException $pe) &#123; $status = ($refundLog &amp;&amp; (1 == $refundLog-&gt;status)) ? 1 : 2; $_data['status'] = $status; $_data['reason_fail'] = $pe-&gt;getMessage(); $_data['process_at'] = date('Y-m-d H:i:s'); if (true !== ($updateOrInsertRefundLogRes = $this-&gt;updateOrInsertRefundLog( $refundLog, $_data, $createAt ))) &#123; return $updateOrInsertRefundLogRes; &#125; return [ 'err' =&gt; '500X', 'msg' =&gt; $pe-&gt;getMessage(), ]; &#125; catch (\\Exception $e) &#123; return [ 'err' =&gt; '503X', 'msg' =&gt; $e-&gt;getMessage(), ]; &#125; &#125; /** * @param $refundLog * @param $data * @param $createAt * @return array|bool */ protected function updateOrInsertRefundLog($refundLog, $data, $createAt) &#123; if ($refundLog) &#123; $processRes = RefundLog::whereId($refundLog-&gt;id) -&gt;update(); &#125; else &#123; date_default_timezone_set(env('APP_TIMEZONE', 'Asia/Shanghai')); $_data['create_at'] = date('Y-m-d H:i:s', $createAt); $processRes = RefundLog::insert($data); &#125; return $processRes ? true : [ $err = 5002, $msg = Tool::sysMsg('DATA_UPDATE_ERROR') ]; &#125;&#125; 代码说明: public function prepare(array &amp;$params): 支付前验证 public function pay(array &amp;$params): array: 支付操作 protected function fillPayDataForMobile(&amp;$alipay, $params): array: 手机端支付宝 protected function fillPayDataForWeb(&amp;$alipay, $params): array: 网页端支付宝 protected function fillPayDataForWap(&amp;$alipay, $params): array: 电脑端支付宝 public function tradeSuccess($client): bool: 验证交易 public function payCallback(array $params, array $rules): 支付后回调 public function refund(array $params): 支付宝退款 protect function updateOrInsertRefundLog($refundLog, $data, $createAt): 退款记录 附录 代码见: Github SoulMate94/Lumen_Pay 参考 latrell/Alipay GitHub Laravel 扩展包 TOP 250 使用OpenSSL来产生RSA密钥 App支付快速接入","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"}]},{"title":"基于Lumen-i18n","slug":"Lumen-il8n","date":"2018-08-07T03:31:50.000Z","updated":"2019-08-22T06:21:09.000Z","comments":true,"path":"2018/08/07/Lumen-il8n/","link":"","permalink":"http://blog.caoxl.com/2018/08/07/Lumen-il8n/","excerpt":"i18n（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是 “国际化” 的简称 通常与i18n相关的还有L10n（ “本地化” 的简称）","text":"i18n（其来源是英文单词 internationalization的首末字符i和n，18为中间的字符数）是 “国际化” 的简称 通常与i18n相关的还有L10n（ “本地化” 的简称） 核心代码 app/Traits/Tool.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace App\\Traits;class Tool&#123; public static function sysMsg($key, $lang = 'zh') &#123; $lang = $_REQUEST['lang'] ?? 'zh'; if (isset($GLOBALS['__sys_msg']) &amp;&amp; is_array($GLOBALS['__sys_msg']) &amp;&amp; $GLOBALS['__sys_msg'] ) &#123; $msg = $GLOBALS['__sys_msg']; &#125; else &#123; $msg = []; $langPath = resource_path().'/sys_msg/'; $path = $langPath.$lang; if (! file_exists($path)) &#123; $path = $langPath.'zh'; &#125; if (file_exists($path)) &#123; $fsi = new \\FilesystemIterator($path); foreach ($fsi as $file) &#123; if ($file-&gt;isFile() &amp;&amp; 'php' == $file-&gt;getExtension()) &#123; $_msg = include $file-&gt;getPathname(); if($_msg &amp;&amp; is_array($_msg)) &#123; $msg = array_merge($_msg, $msg); &#125; &#125; &#125; $GLOBALS['__sys_msg'] = $msg; &#125; &#125; return $msg[$key] ?? ( ('zh' == $lang) ? '服务器繁忙, 请稍后再试' : 'Service is busy or temporarily unavailable.' ); &#125;&#125; 新建: resources/sys_msg/en/Main.php 12345&lt;?phpreturn [ 'SYS_MSG_TEST' =&gt; 'Test the system message i18n',]; 新建: resources/sys_msg/zh/Main.php 12345&lt;?phpreturn [ 'SYS_MSG_TEST' =&gt; '测试一下系统消息i18n',]; 测试 app/Http/Controllers/TestController.php 1234567891011121314151617&lt;?phpnamespace App\\Http\\Controllers;use App\\Traits\\Tool;class TestController extends Controller&#123; public function test_i18n() &#123; return Tool::sysMsg('SYS_MSG_TEST'); // 测试一下系统消息i18n return Tool::sysMsg('SYS_MSG_TEST', 'en'); // Test the system message i18n &#125;&#125;","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"i18n","slug":"i18n","permalink":"http://blog.caoxl.com/tags/i18n/"},{"name":"国际化本地化","slug":"国际化本地化","permalink":"http://blog.caoxl.com/tags/国际化本地化/"}]},{"title":"基于Lumen-重写日志方法","slug":"Lumen-Custom-Log","date":"2018-08-07T03:23:26.000Z","updated":"2019-08-22T06:19:53.000Z","comments":true,"path":"2018/08/07/Lumen-Custom-Log/","link":"","permalink":"http://blog.caoxl.com/2018/08/07/Lumen-Custom-Log/","excerpt":"Lumen 中默认的文件名是被硬编码在 Application 类中了的，要实现这样的效果，必须重写 Laravel\\Lumen\\Application@getMonologHandler() 方法。","text":"Lumen 中默认的文件名是被硬编码在 Application 类中了的，要实现这样的效果，必须重写 Laravel\\Lumen\\Application@getMonologHandler() 方法。 源文件 /bootstrap/app.php 123$app = new Laravel\\Lumen\\Application( realpath(__DIR__.'/../')); 修改后 /bootstrap/app.php 123$app = new App\\Application( realpath(__DIR__.'/../')); 新增文件: app/Application.php 123456789101112131415161718192021222324252627&lt;?php// Custom default or hard-coded behavior of lumen// @caoxlnamespace App;use Laravel\\Lumen\\Application as LumenBase;use Monolog\\Formatter\\LineFormatter;use Monolog\\Handler\\StreamHandler;use Monolog\\Logger;class Application extends LumenBase&#123; // Rewrite log handler protected function getMonologHandler() &#123; return ( new StreamHandler(storage_path(env( 'APP_LOG_PATH', 'logs/'.date('Y-m-d').'.log' )), Logger::DEBUG )) -&gt;setFormatter(new LineFormatter(null, null, true, true)); &#125;&#125; 在/storage/logs/即可看到以类似 2018-08-07.log命名的日志文件","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"自定义日志","slug":"自定义日志","permalink":"http://blog.caoxl.com/tags/自定义日志/"}]},{"title":"基于Lumen-支付宝支付(Payment)","slug":"Lumen-Alipay","date":"2018-08-07T02:12:31.000Z","updated":"2019-08-22T06:19:34.000Z","comments":true,"path":"2018/08/07/Lumen-Alipay/","link":"","permalink":"http://blog.caoxl.com/2018/08/07/Lumen-Alipay/","excerpt":"基于Lumen-支付宝支付, 这里使用的是Payment第三方sdk by helei112g/payment","text":"基于Lumen-支付宝支付, 这里使用的是Payment第三方sdk by helei112g/payment Payment是php版本的支付聚合第三方sdk，集成了微信支付、支付宝支付、招商一网通支付。提供统一的调用接口，方便快速接入各种支付、查询、退款、转账能力。服务端接入支付功能，方便、快捷。 Payment使用文档Payment使用常见问题汇总 环境准备 Payment 需要 PHP &gt;= 5.6以上的版本，并且同时需要PHP安装以下扩展 cURL extension mbstring BC Math Guzzle guzzle 是一个开源的php http请求lib, 项目地址 安装Payment1composer require \"riverslei/payment:*\" 先看几个Payment Demo手机app支付demo vendor/riverslei/example/ali/appCharge.php 123456789101112131415161718192021222324252627282930313233&lt;?phprequire_once __DIR__ . '/../../autoload.php';use Payment\\Common\\PayException;use Payment\\Client\\Charge;use Payment\\Config;date_default_timezone_set('Asia/Shanghai');$aliConfig = require_once __DIR__ . '/../aliconfig.php';// 订单信息$orderNo = time() . rand(1000, 9999);$payData = [ 'body' =&gt; 'ali qr pay', 'subject' =&gt; '测试支付宝扫码支付', 'order_no' =&gt; $orderNo, 'timeout_express' =&gt; time() + 600,// 表示必须 600s 内付款 'amount' =&gt; '0.01',// 单位为元 ,最小为0.01 'return_param' =&gt; '123123', 'client_ip' =&gt; isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : '127.0.0.1',// 客户地址 'goods_type' =&gt; '1', 'store_id' =&gt; '',];try &#123; $str = Charge::run(Config::ALI_CHANNEL_APP, $aliConfig, $payData);&#125; catch (PayException $e) &#123; echo $e-&gt;errorMessage(); exit;&#125;echo $str;// 这里如果直接输出到页面，&amp;not 会被转义，请注意 wap网站支付 vendor/riverslei/example/ali/wapCharge.php 123456789101112131415161718192021222324252627282930313233&lt;?phprequire_once __DIR__ . '/../../autoload.php';use Payment\\Common\\PayException;use Payment\\Client\\Charge;use Payment\\Config;date_default_timezone_set('Asia/Shanghai');$aliConfig = require_once __DIR__ . '/../aliconfig.php';// 订单信息$orderNo = time() . rand(1000, 9999);$payData = [ 'body' =&gt; 'ali wap pay', 'subject' =&gt; '测试支付宝手机网站支付', 'order_no' =&gt; $orderNo, 'timeout_express' =&gt; time() + 600,// 表示必须 600s 内付款 'amount' =&gt; '0.01',// 单位为元 ,最小为0.01 'return_param' =&gt; 'tata',// 一定不要传入汉字，只能是 字母 数字组合 'client_ip' =&gt; isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : '127.0.0.1',// 客户地址 'goods_type' =&gt; '1', 'store_id' =&gt; '',];try &#123; $url = Charge::run(Config::ALI_CHANNEL_WAP, $aliConfig, $payData);&#125; catch (PayException $e) &#123; echo $e-&gt;errorMessage(); exit;&#125;header('Location:' . $url); web电脑支付 即时到账接口 vendor/riverslei/example/ali/webCharge.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?phprequire_once __DIR__ . '/../../autoload.php';use Payment\\Common\\PayException;use Payment\\Client\\Charge;use Payment\\Config;date_default_timezone_set('Asia/Shanghai');$aliConfig = require_once __DIR__ . '/../aliconfig.php';// 订单信息$orderNo = time() . rand(1000, 9999);$payData = [ 'body' =&gt; 'ali web pay', 'subject' =&gt; '测试支付宝电脑网站支付', 'order_no' =&gt; $orderNo, 'timeout_express' =&gt; time() + 600,// 表示必须 600s 内付款 'amount' =&gt; '0.01',// 单位为元 ,最小为0.01 'return_param' =&gt; '123123', 'client_ip' =&gt; isset($_SERVER['REMOTE_ADDR']) ? $_SERVER['REMOTE_ADDR'] : '127.0.0.1',// 客户地址 'goods_type' =&gt; '1', 'store_id' =&gt; '', // 说明地址：https://doc.open.alipay.com/doc2/detail.htm?treeId=270&amp;articleId=105901&amp;docType=1 // 建议什么也不填 'qr_mod' =&gt; '',];try &#123; $url = Charge::run(Config::ALI_CHANNEL_WEB, $aliConfig, $payData);&#125; catch (PayException $e) &#123; echo $e-&gt;errorMessage(); exit;&#125;header('Location:' . $url);","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"支付","slug":"支付","permalink":"http://blog.caoxl.com/tags/支付/"},{"name":"支付宝","slug":"支付宝","permalink":"http://blog.caoxl.com/tags/支付宝/"}]},{"title":"Composer 开发自己的组件","slug":"Composer-packages","date":"2018-08-03T06:09:35.000Z","updated":"2019-08-22T03:25:18.000Z","comments":true,"path":"2018/08/03/Composer-packages/","link":"","permalink":"http://blog.caoxl.com/2018/08/03/Composer-packages/","excerpt":"知识没有你的我的, 只有学习顺序的先后, 你从别人那学,我从你这学, 别人又从我这里学,多好~~。 写个 Composer 组件玩玩，顺便总结下 Composer 的使用。","text":"知识没有你的我的, 只有学习顺序的先后, 你从别人那学,我从你这学, 别人又从我这里学,多好~~。 写个 Composer 组件玩玩，顺便总结下 Composer 的使用。 基础知识组件化现代 Web 开发已经不再流行开发一个巨型框架了，反过来，我们更关心的是通过甄选一个个由专业人士编写的、可以具有互操作特性的组件，来组装解决方案。 互操作性：组件之间可以很方便的互相利用。 PHP Web 开发也不例外，composer 推动了 PHP 生态的组件化进程。 当我们准备创建 PHP 项目的时候，优先考虑的不是使用什么全能型框架而是考虑能否通过少量组件就可以满足需求。 此外，一些大型框架也是以组件的方式被 composer 管理。 autoloader当通过 composer 下载 PHP 组件的同时，composer 将会扫描每个组件的 composer.json 文件，并为我们的整个项目生成好了一份兼容 PSR 规范的 autoloader，位于 vendor/autoload.php，项目通过该引入自动加载器，便能够在项目范围内使用各个组件提供的功能。 composer.json 部分字段解释require列出了该 PHP 项目/组件的所有依赖，包括 PHP 版本以及其他库。该字段中的依赖包将会在开发环境和生产环境中被安装 require-dev和 required 作用大体一致，不过只是列举出开发当前项目/组件期间需要用的依赖，比如单元测试框架 phpunit 等。 生产环境中，该列表中的依赖不应该被安装。 suggestcomposer 不会安装这里指出的组件，仅仅起到提示作用：提示这些组件可能会对当前项目/组件有用。 autoload该字段用于指示 composer autoloader 如何进行自动加载。 一般来说，目前我们应该遵守并使用 psr-4 规范。举例说明： 12345\"autoload\": &#123; \"psr-4\": &#123; \"A\\\\B\\\\C\": \"src/\" &#125;&#125; 该例子的意思是，当需要找到命名空间为 A\\B\\C 的类文件时，到当前 composer.json 所在的路径(也是项目的根路径)下面的 src/ 目录下以此为跟路径开始找。 其中，两个反斜线 \\\\ 不能写漏。 举例: composer.json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#123; \"name\": \"laravel/lumen\", \"description\": \"The Laravel Lumen Framework.\", \"keywords\": [\"framework\", \"laravel\", \"lumen\"], \"license\": \"MIT\", \"type\": \"project\", \"require\": &#123; \"php\": \"^7.0\", \"laravel/lumen-framework\": \"5.4.*\", \"vlucas/phpdotenv\": \"~2.2\", \"firebase/php-jwt\": \"^5.0\", \"symfony/var-dumper\": \"^3.3\", \"predis/predis\": \"^1.1\", \"illuminate/redis\": \"^5.4\", \"qiniu/php-sdk\": \"^7.1\", \"maatwebsite/excel\": \"~2.1.0\", \"jpush/jpush\": \"^3.5\", &#125;, \"require-dev\": &#123; \"fzaninotto/faker\": \"~1.4\", \"phpunit/phpunit\": \"~5.0\", \"mockery/mockery\": \"~0.9\" &#125;, \"autoload\": &#123; \"psr-4\": &#123; \"App\\\\\": \"app/\" &#125;, \"files\": [ \"app/functions.php\" ] &#125;, \"autoload-dev\": &#123; \"classmap\": [ \"tests/\", \"database/\" ] &#125;, \"scripts\": &#123; \"post-root-package-install\": [ \"php -r \\\"copy('.env.example', '.env');\\\"\" ] &#125;, \"minimum-stability\": \"dev\", \"prefer-stable\": true, \"repositories\": &#123; \"packagist\": &#123; \"type\": \"composer\", \"url\": \"https://packagist.phpcomposer.com\" &#125; &#125;&#125; 搭建私有 composer 仓库 Handling private packages 123# Via composer/sourcecomposer create-project composer/statis --stability=dev --keep=vcsphp bin/satic build satic.json /path/to/output-web-dir/ -vvv 说明: /path/to/output-web-dir/ 此处为自定义目录 Composer组件开发流程初始化composer 项目是由一定规范限制的，可以通过如下命令初始化一个 composer 组件。 12mkdir test &amp;&amp; cd testscomposer init 出现以下内容: 1234567891011121314151617181920$ composer init Welcome to the Composer config generatorThis command will guide you through creating your composer.json config.Package name (&lt;vendor&gt;/&lt;name&gt;) [97321/test]: caoxl/caoxlDescription []: caoxl_packageAuthor [SoulMate94. &lt;code0809@163.com&gt;, n to skip]:Minimum Stability []: devPackage Type (e.g. library, project, metapackage, composer-plugin) []:License []: MITDefine your dependencies.Would you like to define your dependencies (require) interactively [yes]?Search for a package:Would you like to define your dev dependencies (require-dev) interactively [yes]? 结束时会生成一份 composer.json 文件。当然也可以直接创建 composer.json 然后定义同样的属性。 就像下面这样: 123456789101112131415161718192021&#123; \"name\": \"vendor_name/component_name\", \"description\": \"desc\", \"type\": \"library\", \"license\": \"MIT\", \"authors\": [ &#123; \"name\": \"your_name\", \"email\": \"your@email.com\" &#125; ], \"minimum-stability\": \"dev\", \"require\": &#123; \"php\": \"&gt;=5.4.0\" &#125;, \"autoload\": &#123; \"psr-4\": &#123; \"&lt;NAMESPACE&gt;\\\\\": \"src/\" &#125; &#125;&#125; 开发接下来就是敲代码了。 注意，为了规范和统一，一般在 src 目录中放主要的源码，然后 composer.json 使用的命名空间和这个 src 关联。 示例: 新建/src/test.php 123456&lt;?php// 获取扩展名function get_file_ext($file)&#123; return strtolower(pathinfo($file,PATHINFO_EXTENSION));&#125; 提交到 GitHhub代码写完了, 提交到Github托管 在Github上新建一个项目: 123456echo \"# composer_vendor\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin git@github.com:SoulMate94/composer_vendor.gitgit push -u origin master 至此代码已经提交到github托管; SoulMate94/composer_vendor 提交到 Packagist注册 packgist 账号后，点击 Submit，输入 仓库地址，点击 Check，检查无误确认提交。 成功后可以看到 Packagist-caoxl/caoxl 设置自动更新在 GitHub 仓库Settings中找到 Services，搜索 Packagist，然后填好： 用户名: Packagist 用户名 Token: 在 Packagist个人设置中可以查看 域名: packagist.org – 此处填https://packagist.org即可 测试如果上面测试无误则可以在任何地方使用 composer require &lt;Vendor&gt;/&lt;Package&gt; 来下载并使用你开放的 composer 组件了。 1composer require caoxl/caoxl FAQcomposer.lock 是否应该纳入版本控制？ 是, 这是lock存在的意义 版本库中的 composer.lock 确保了协作开发和在任何环境安装组件的时候都是同一个版本号 此外，尽量不要在正式环境执行 composer update。当某个开发者要更新某个组件的时候，应该现在他的环境更新该组件，测试后在提交 composer.lock 到版本库，其他开发者在不需要更新任何组件的情况下只需要执行 composer install 即可。 生产环境只允许执行 composer install。 对文件名／目录名大小写敏感导致 “Class Not found”？123\"autoload\": &#123; \"classmap\": [\"folder1/\", \"folder2/\"]&#125; How to add case insensitive autoloading using composer generated classmap? 缓存导致找不到PHP类 ?1composer dump-autoload 参考 Packagist - The PHP Package Repository &amp;&amp; Packagist/Composer中国全量镜像 composer-doc Creating your first Composer/Packagist package composer/satis 使用 satis 搭建私有的 Composer 包仓库 Composer: It’s All About the Lock File Should composer.lock be committed to version control? Composer 使用日志","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Composer","slug":"Composer","permalink":"http://blog.caoxl.com/tags/Composer/"},{"name":"Packagist","slug":"Packagist","permalink":"http://blog.caoxl.com/tags/Packagist/"}]},{"title":"Hexo 黑科技","slug":"Hexo-Black-Screen","date":"2018-08-02T07:23:30.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/02/Hexo-Black-Screen/","link":"","permalink":"http://blog.caoxl.com/2018/08/02/Hexo-Black-Screen/","excerpt":"科学表明, 当你撸管次数过多 , 会出现看不清字的征兆","text":"科学表明, 当你撸管次数过多 , 会出现看不清字的征兆 千万别点啊 叫你别点你还点 好了, 下面告诉你怎么使用的 安装/使用 安装: 1npm install hexo-spoiler --save 使用: 1&#123;% spoiler text %&#125; 成功展示 可以遮蔽正常文本：text 可以遮蔽带格式的文本：text text ~text~ 可以遮蔽行内代码，但是效果非常差：text 就是这么简单~~","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/tags/Hexo/"}]},{"title":"Hexo 鼠标点击心形特效","slug":"Hexo-Click-Heart","date":"2018-08-02T07:06:02.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/02/Hexo-Click-Heart/","link":"","permalink":"http://blog.caoxl.com/2018/08/02/Hexo-Click-Heart/","excerpt":"Hiker主题添加鼠标心形点击特效1、在themes\\hexo-theme-hiker\\source\\js\\src\\目录下新建love.js,代码如下:","text":"Hiker主题添加鼠标心形点击特效1、在themes\\hexo-theme-hiker\\source\\js\\src\\目录下新建love.js,代码如下: 1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 2、在themes\\hexo-theme-hiker\\layout\\_layout.ejs文件的最下方，前面添加: 1&lt;script type=\"text/javascript\" src=\"/js/love.js\"&gt;&lt;/script&gt; 下面的参考文档, 适用于Next主题 参考 Next主题添加鼠标心形点击特效","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/tags/Hexo/"}]},{"title":"Hexo 插入音乐","slug":"Hexo-Insert-Music","date":"2018-08-02T06:48:10.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/08/02/Hexo-Insert-Music/","link":"","permalink":"http://blog.caoxl.com/2018/08/02/Hexo-Insert-Music/","excerpt":"正如你在归档和文章正文看到的, 我引入了一个音乐播放器","text":"正如你在归档和文章正文看到的, 我引入了一个音乐播放器 装插件 首先我们需要通过命令行安装以下两款插件（当然装一个就可以了，如果一个实现不了再装另一个），这两款插件我们都可以从hexo的官方网站上查询到：Hexo 插件 12npm install hexo-tag-dplayer npm install hexo-tag-aplayer 添加音乐在我的博客中我选择添加的是网易云音乐。首先我们打开网易云音乐的主页，然后搜索你喜欢的音乐，然后进入音乐的详情页面，点击 生成外链播放器 复制iframe插件HTML代码 123&lt;div style=\"position:absolute; top:10%; left:1%; width:76%;\"&gt; &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=260 height=52 src=\"//music.163.com/outchain/player?type=2&amp;id=25706279&amp;auto=1&amp;height=32\"&gt;&lt;/iframe&gt;&lt;/div&gt; 以上代码复制到主题文件夹下, 想放在哪个区域，就把代码复制到实现那块区域的模板文件里 为了使得页面更加美观，我给这块代码自定义加了 div，这样方便给播放器设定样式，只要稍微懂一点前端知识的筒子，都可以随心所欲的加 css样式。这里需要提一下，播放器设定好后，默认是：打开页面即播放音乐；如果不喜欢默认打开音乐的筒子，也可以通过把代码中的 auto=1 修改为 auto=0 来关闭它。 这样就Done~~~","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/tags/Hexo/"}]},{"title":"实名认证 「聚合数据」","slug":"Juhe-Real-Name-Certification","date":"2018-08-01T06:54:28.000Z","updated":"2019-08-22T06:45:02.000Z","comments":true,"path":"2018/08/01/Juhe-Real-Name-Certification/","link":"","permalink":"http://blog.caoxl.com/2018/08/01/Juhe-Real-Name-Certification/","excerpt":"实名认证牵涉公安备案系统，需向公安机关申请接口进行验证。当然，调用其他已向公安机关申请了接口的第三方接口一样可行","text":"实名认证牵涉公安备案系统，需向公安机关申请接口进行验证。当然，调用其他已向公安机关申请了接口的第三方接口一样可行 聚合数据 身份证实名认证文档 API文档 接口地址: 1http://op.juhe.cn/idcard/query 返回格式: 1json 请求方式: 1http get/post 请求示例: 1http://op.juhe.cn/idcard/query?key=您申请的KEY&amp;idcard=420104198905015713&amp;realname=%E7%8E%8B%E9%9D%9E%E5%90%9F 接口备注: 1error_code 为0时计费 直接上源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php//----------------------------------// 身份证实名认证 － 聚合数据// 在线接口文档：http://www.juhe.cn/docs/103//----------------------------------header('Content-type:text/html;charset=utf-8');//配置您申请的appkey$appkey = \"*********************\";//************1.真实姓名和身份证号码判断是否一致************$url = \"http://op.juhe.cn/idcard/query\";$params = array( \"idcard\" =&gt; \"36072219940809****\", //身份证号码 \"realname\" =&gt; \"曹贤亮\", //真实姓名 \"key\" =&gt; $appkey, //应用APPKEY(应用详细页查询));$paramstring = http_build_query($params);$content = juhecurl($url,$paramstring);$result = json_decode($content,true);if($result)&#123; if($result['error_code'] == '0')&#123; if($result['result']['res'] == '1')&#123; echo \"身份证号码和真实姓名一致\"; &#125; else &#123; echo \"身份证号码和真实姓名不一致\"; &#125; &#125; else &#123; echo $result['error_code'].\":\".$result['reason']; &#125;&#125; else &#123; echo \"请求失败\";&#125;//**************************************************/** * 请求接口返回内容 * @param string $url [请求的URL地址] * @param string $params [请求的参数] * @param int $ipost [是否采用POST形式] * @return string */function juhecurl($url, $params = false, $ispost = 0)&#123; $httpInfo = array(); $ch = curl_init(); curl_setopt( $ch, CURLOPT_HTTP_VERSION , CURL_HTTP_VERSION_1_1 ); curl_setopt( $ch, CURLOPT_USERAGENT , 'JuheData' ); curl_setopt( $ch, CURLOPT_CONNECTTIMEOUT , 60 ); curl_setopt( $ch, CURLOPT_TIMEOUT , 60); curl_setopt( $ch, CURLOPT_RETURNTRANSFER , true ); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); if( $ispost ) &#123; curl_setopt( $ch , CURLOPT_POST , true ); curl_setopt( $ch , CURLOPT_POSTFIELDS , $params ); curl_setopt( $ch , CURLOPT_URL , $url ); &#125; else &#123; if($params) &#123; curl_setopt( $ch , CURLOPT_URL , $url.'?'.$params ); &#125; else &#123; curl_setopt( $ch , CURLOPT_URL , $url); &#125; &#125; $response = curl_exec( $ch ); if ($response === FALSE) &#123; //echo \"cURL Error: \" . curl_error($ch); return false; &#125; $httpCode = curl_getinfo( $ch , CURLINFO_HTTP_CODE ); $httpInfo = array_merge( $httpInfo , curl_getinfo( $ch ) ); curl_close( $ch ); return $response;&#125; 阿里云的实名认证API文档 身份证实名认证 调用地址: 1http://idcard.market.alicloudapi.com/lianzhuo/idcard 请求方式: 1GET 返回类型: 1JSON PHP请求示例1234567891011121314151617181920212223242526&lt;?php $host = \"http://idcard.market.alicloudapi.com\"; $path = \"/lianzhuo/idcard\"; $method = \"GET\"; $appcode = \"你自己的AppCode\"; $headers = array(); array_push($headers, \"Authorization:APPCODE \" . $appcode); $querys = \"cardno=370703198111300338&amp;name=%E9%83%AD%E5%BE%B7%E6%98%8C\"; $bodys = \"\"; $url = $host . $path . \"?\" . $querys; $curl = curl_init(); curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_HTTPHEADER, $headers); curl_setopt($curl, CURLOPT_FAILONERROR, false); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_HEADER, true); if (1 == strpos(\"$\".$host, \"https://\")) &#123; curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); &#125; var_dump(curl_exec($curl));?&gt;","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"},{"name":"实名认证","slug":"实名认证","permalink":"http://blog.caoxl.com/tags/实名认证/"}]},{"title":"让PHP7达到最高性能的几个Tips","slug":"PHP7-Max-Performance-Tips","date":"2018-08-01T02:46:59.000Z","updated":"2019-08-22T03:01:05.000Z","comments":true,"path":"2018/08/01/PHP7-Max-Performance-Tips/","link":"","permalink":"http://blog.caoxl.com/2018/08/01/PHP7-Max-Performance-Tips/","excerpt":"原文地址: http://www.laruence.com/2015/12/04/3086.html","text":"原文地址: http://www.laruence.com/2015/12/04/3086.html 这里只做博客的搬运工, 方便自己查找查看. 1. Opcache记得启用Zend Opcache, 因为PHP7即使不启用Opcache速度也比PHP-5.6启用了Opcache快, 所以之前测试时期就发生了有人一直没有启用Opcache的事情. 启用Opcache非常简单, 在php.ini配置文件中加入: 123zend_extension=opcache.soopcache.enable=1opcache.enable_cli=1\" 2. 使用新的编译器使用新一点的编译器, 推荐GCC 4.8以上, 因为只有GCC 4.8以上PHP才会开启Global Register for opline and execute_data支持, 这个会带来5%左右的性能提升(Wordpres的QPS角度衡量) 其实GCC 4.8以前的版本也支持, 但是我们发现它支持的有Bug, 所以必须是4.8以上的版本才会开启这个特性. 12345678[root@caoxianliang ~]# gcc -vUsing built-in specs.COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-redhat-linux/4.8.5/lto-wrapperTarget: x86_64-redhat-linuxConfigured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-linker-hash-style=gnu --enable-languages=c,c++,objc,obj-c++,java,fortran,ada,go,lto --enable-plugin --enable-initfini-array --disable-libgcj --with-isl=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/isl-install --with-cloog=/builddir/build/BUILD/gcc-4.8.5-20150702/obj-x86_64-redhat-linux/cloog-install --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linuxThread model: posixgcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) 3. HugePage我之前的文章也介绍过: 让你的PHP7更快之Hugepage , 首先在系统中开启HugePages, 然后开启Opcache的huge_code_pages. 以我的CentOS 6.5为例, 通过: 12[root@caoxianliang ~]# sudo sysctl vm.nr_hugepages=512vm.nr_hugepages = 512 分配512个预留的大页内存: 1234567[root@caoxianliang ~]# cat /proc/meminfo | grep HugeAnonHugePages: 59392 kBHugePages_Total: 512HugePages_Free: 37HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kB 然后再php.ini中加入: 1opcache.huge_code_pages=1 这样一来, PHP会把自身的text段, 以及内存分配中的huge都采用大内存页来保存, 减少TLB miss, 从而提高性能. 4. Opcache file cache开启Opcache File Cache(实验性), 通过开启这个, 我们可以让Opcache把opcode缓存缓存到外部文件中, 对于一些脚本, 会有很明显的性能提升. 在php.ini中加入: 1opcache.file_cache=/tmp 这样PHP就会在/tmp目录下Cache一些Opcode的二进制导出文件, 可以跨PHP生命周期存在. PGO我之前的文章: 让你的PHP7更快(GCC PGO) 也介绍过, 如果你的PHP是专门为一个项目服务, 比如只是为你的Wordpress, 或者drupal, 或者其他什么, 那么你就可以尝试通过PGO, 来提升PHP, 专门为你的这个项目提高性能. 具体的, 以wordpress 4.1为优化场景.. 首先在编译PHP的时候首先: 1make prof-gen 然后用你的项目训练PHP, 比如对于Wordpress: 1sapi/cgi/php-cgi -T 100 /home/huixinchen/local/www/htdocs/wordpress/index.php &gt;/dev/null 也就是让php-cgi跑100遍wordpress的首页, 从而生成一些在这个过程中的profile信息. 最后: 12make prof-cleanmake prof-use &amp;&amp; make install 这个时候你编译得到的PHP7就是为你的项目量身打造的最高性能的编译版本.","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"PHP7","slug":"PHP7","permalink":"http://blog.caoxl.com/tags/PHP7/"}]},{"title":"Laravel之父--让Laravel、Symfony、Zend来一场公平的性能测试","slug":"Laravel-Symfony-Zend-Performance-Compare","date":"2018-07-31T03:02:25.000Z","updated":"2019-08-22T03:39:34.000Z","comments":true,"path":"2018/07/31/Laravel-Symfony-Zend-Performance-Compare/","link":"","permalink":"http://blog.caoxl.com/2018/07/31/Laravel-Symfony-Zend-Performance-Compare/","excerpt":"原文地址: Benchmarking Laravel, Symfony, &amp; Zend by Taylor Otwell 本文引自: Laravel 之父：让 Laravel、Symfony、 Zend 来一场公平的性能测试","text":"原文地址: Benchmarking Laravel, Symfony, &amp; Zend by Taylor Otwell 本文引自: Laravel 之父：让 Laravel、Symfony、 Zend 来一场公平的性能测试 故事场景 网上充斥着各式各样的 PHP 框架性能对比的文章。然而，他们总是把“苹果”和“橘子”做对比（看上去有点儿像，都是圆的，但其实不是一码事）。这次，我将着重对 Laravel、Symfony 和 Zend 这三个框架做性能对比，并且还要说明为什么这三个框架总是被错误的进行比较。 我给的对比结果你不必全信。读完这篇文章之后，你可以自己搞一个 2GB 的 DigitalOcean 的服务器亲自去检验一下，也就 5 分钟而已。 开始之前，我希望你知道：所有这些框架都足够快，都可以满足你构建任何应用。写这篇文章之前我也犹豫过，我认为做这种层次的对比其实真的挺傻的。我唯一的目的是展示如何在三个框架之间进行公平的比较。 问题的源头当你在一台全新的 DigitalOcean 服务器上配置 Symfony 或 Zend 项目时，你会发现返回的 http 响应是没有 session 信息的。注意，看下图，cookie 并没有被返回： 然而，Laravel 默认是开启 session 的（另外还有一些中间件）。这样能让基于 Laravel 构建的应用很方便地利用 session 机制将用户状态持久化保存。为了 Laravel 框架的用户更方便而默认开启 session 反倒让 `Laravel 在性能对比中很受伤。 另一个常见错误是：要么没有倒出一份优化过的 Composer autoloader; 要么没有用 php artisan config:cache 指令缓存 Laravel 配置信息 – 这份缓存能够大幅度减少 Laravel 的启动（bootstrap）时间。 设置环境首先，我通过 Laravel Forge 在 DiginalOcean 上创建了一个 2GB 内存的服务器，安装的是 PHP 7.1 版本。然后安装 Symfony ，优化 Composer autoloader ，配置 Nginx 通过生产环境下的前端控制器（app.php）运行。并且我还按照 Symfony 生产环境调优指南一步步设置到位。对于 Zend 的配置也类似。 接下来，针对 PHP 7.1 的 opcache 设置如下（生产环境）： 1234567opcache.enable=1opcache.memory_consumption=512opcache.interned_strings_buffer=64opcache.max_accelerated_files=20000opcache.validate_timestamps=0opcache.save_comments=1opcache.fast_shutdown=1 安装 Laravel 时，执行 config:cache Artisan 指令，并且在 app/Http/Kernel.php 文件中将 web 中间件组注释掉（这些中间件的作用就是让 Laravel 支持 session）。做完上述修改之后就可以让三个框架都在无 session 支持的状态下进行对比了。 对比结果 After configuring the projects, I ran a simple test using Apache benchmark, which anyone can recreate: 三个框架都能正常运行后，终于可以祭出 Apache benchmark 来做简单的测试了。其实任何人都可以很容易地复现这一测试： 1ab -t 10 -c 10 [http://server.address/] 下面是测试结果: 无Session Laravel: 609.03 次请求／秒 (平均值) Zend: 559.91 次请求／秒 (平均值) Symfony: 532.97 次请求／秒 (平均值) 有Session: Laravel: 521.64 次请求／秒(平均值) Zend: 484.94 次请求／秒 (平均值) Symfony: 439.37 次请求／秒 (平均值)","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"Symfony","slug":"Symfony","permalink":"http://blog.caoxl.com/tags/Symfony/"},{"name":"Zend","slug":"Zend","permalink":"http://blog.caoxl.com/tags/Zend/"}]},{"title":"评判框架的10大标准","slug":"Ten-Standard-For-Frame","date":"2018-07-31T01:35:30.000Z","updated":"2019-08-22T03:41:30.000Z","comments":true,"path":"2018/07/31/Ten-Standard-For-Frame/","link":"","permalink":"http://blog.caoxl.com/2018/07/31/Ten-Standard-For-Frame/","excerpt":"选择框架时绝对不能拿来就用。它是一个长远的承诺。请确保你做出的是正确的选择！","text":"选择框架时绝对不能拿来就用。它是一个长远的承诺。请确保你做出的是正确的选择！ 1、受欢迎程度和社区规模愈是广为人知和受到认可的框架，活得就愈好，不断进化，愈发完整：全新的理念，数量众多的高质量插件，等等。 2、编程思想这是框架非常本质的东西了：也是确保框架合你意的根本标准。 显而易见的是，专业人士为自己量身定制的开发工具，定会与其他专业人士的需求不谋而合。 3、可持续性选择框架之前，先得确保框架能够跟上你的发展周期。一般是指对你程序的维护和升级。 4、支持另一个不应被忽视的标准是，你提出问题后寻找答案时的容易程度，以及能否受到帮助。 辨别支持度可以是：通过框架发布者。还有，通过社区（邮件列表、IRC等）？以及，通过专业服务公司 （开发，支持, 培训）？ 5、技术要避免迷失方向，总是要首选一个可互用的方案；在开发中，它要能遵循最佳实践(design patern)。 6、安全性任何程序都有潜在的脆弱一面。为减少危险，选择一种有能力确保安全功能（比如XSS管理）的框架总是好的。 7、文档评估一个框架的既存文档之数量、质量和先天条件是大有必要的：文档良好的工具，既容易使用又便于升级。 8、授权授权是重要的，理由很简单，它们可能会对你的程序造成重大冲击。 例如，以GPL-licensed的框架开发出来的程序将注定受限于GPL。 另一方面，这在MIT-licensed授权的框架中是完全不存在的。 9、放到市面之后的可用性出于对维护和升级两方面的考虑，也许你希望在开发阶段或更长期间内，拥有自己的技术团队。 换言之，要确保你所使用的开发工具所需之技巧放到市面上是可以通行无阻的（否则团队攒不起来）。 10、现在就用别靠着观看网上的或好或坏的评测、评论和传言来满足自己。 要测试一番，才可以补足你的感受，确保你在使用开发工具时完全舒适。","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://blog.caoxl.com/tags/框架/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"}]},{"title":"初识 YAML","slug":"What-is-YAML","date":"2018-07-30T07:52:05.000Z","updated":"2019-08-22T03:27:31.000Z","comments":true,"path":"2018/07/30/What-is-YAML/","link":"","permalink":"http://blog.caoxl.com/2018/07/30/What-is-YAML/","excerpt":"YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。","text":"YAML 是专门用来写配置文件的语言，非常简洁和强大，远比 JSON 格式方便。 简介YAML 语言的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式 它的基本语法规则如下: 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键, 只需要使用空格 缩进的空格数目不重要, 只要相同层级的元素左侧对其即可 # 表示注释, 从这个字符一直到行尾, 都会被解析器忽略 YAML 支持的数据结构有三种。 对象: 键值对的集合, 又称为映射(mapping) / 哈希(hashes) / 字典(dictionary) 数组: 一组按次序排列的值, 又称为序列(sequence) / 列表 (list) 纯量(scalars): 单个的、不可再分的值 对象对象的一组键值对, 使用冒号结果表示 1animal: pets 转为 JavaScript如下: 1&#123; animal: 'pets' &#125; YAML也允许另一种写法, 将所有键值写成一个行内对象 1hash: &#123; name: Caoxl, foo: bar &#125; 转为 JavaScript 如下: 1&#123; hash: &#123;name: 'Caoxl', foo: 'bar' &#125;&#125; 数组一组连词线开头的行, 构成一个数组 123- Cat- Dog- Goldfish 转为 JavaScript 如下: 1['Cat', 'Dog', 'Goldfish'] 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格 1234- - Cat - Dog - Goldfish 转为JavaScript如下: 1[['Cat', 'God', 'Goldfish']] 数组也可以采用行内表示法 1animal: [Cat, Dog] 转为JavaScript如下: 1&#123; animal: ['Cat', 'Dog']&#125; 复合结构对象和数组可以结合使用, 形成复合结构 12345678910languages: - Ruby - Perl - Pythonwebsites; YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 转为 JavaScript如下: 12345678&#123;language: ['Ruby, 'Perl', 'Python'], websites: &#123; YAML: 'yaml.org', Ruby: 'ruby-lang.org', Python: 'python.org', Perl: 'use.perl.org' &#125;&#125; 纯量纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串 布尔值 整数 浮点数 Null 时间 日期 数值直接以字面量的形式表示: 1number: 12.30 转为JavaScript如下: 1&#123; number: 12.30 &#125; 布尔值用true和false表示 1isSet: true 转为JavaScript如下: 1&#123; isSet: true &#125; null 用 ~表示 1parent: ~ 转为 JavaScript如下: 1&#123; parent: null &#125; 时间采用 ISO8601格式: 1iso8601: 2018-12-14t 21:59:43.10-05:00 转为JavaScript如下: 1&#123; iso8601: new Date('2018-12-14t21:59:43.10-05:00') &#125; 日期采用复合 ISO8601 格式的年、月、日表示。 1date: 1976-07-31 转为 JavaScript 如下。 1&#123; date: new Date('1976-07-31') &#125; YAML允许使用两个感叹号, 强制转换数据类型 12e: !!str 123f: !!str true 转为JavaScript如下: 1&#123; e: '123', f: 'true' &#125; 字符串字符串是最常见, 也是最复杂的一种数据类型 字符串默认不使用引号表示 1str: 这是一行字符串 转为 JavaScript如下: 1&#123; str: '这是一行字符串' &#125; 如果字符串之中包含空格或特殊字符, 需要放在引号之中 1str: '内容: 字符串' 单引号双引号都可以使用, 双引号不会对特殊字符转义 12s1: '内容\\n字符串's2: \"内容\\n字符串\" 转为JavaScript如下: 1&#123; s1: '内容\\\\n字符串', s2: '内容\\n字符串'&#125; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 1str: 'labor''s day' 转为JavaScript如下: 1&#123; str: 'labor\\'s day' &#125; 字符串可以写成多行, 从第二行开始, 必须有一个单空格缩进, 换行符会被转为空格 123str: 这是一段 多行 字符串 转为JavaScript如下: 1&#123; str: '这是一段 多行 字符串' &#125; 多行字符串可以使用|保留换行符, 也可以使用&gt;折叠换行 123456this: | Foo Barthat: &gt; Foo Bar 转为JavaScript如下: 1&#123; this: 'Foo\\nBar\\n', that: 'Foo Bar\\n' &#125; +表示保留文章块末尾的换行, -表示删除字符串末尾的换行 123456789s1: | Foos2: |+ Foos3: |- Foo 转为JavaScript如下: 1&#123; s1: 'Foo\\n', s2: 'Foo\\n\\n\\n', s3: 'Foo' &#125; 字符串之中可以插入HTML标记 1234message: | &lt;p style=\"color: red\"&gt; 段落 &lt;/p&gt; 转为 JavaScript 如下 1&#123; message: '\\n&lt;p style=\"color: red\"&gt;\\n 段落\\n&lt;/p&gt;\\n' &#125; 参考 YAML From Wikipedia YAML 语言教程 by 阮一峰","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"DevTool","slug":"DevTool","permalink":"http://blog.caoxl.com/tags/DevTool/"},{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/tags/Caoxl/"},{"name":"YAML","slug":"YAML","permalink":"http://blog.caoxl.com/tags/YAML/"}]},{"title":"Symfony 框架初次使用","slug":"Symfony-First-Use","date":"2018-07-27T08:51:14.000Z","updated":"2019-08-22T06:41:47.000Z","comments":true,"path":"2018/07/27/Symfony-First-Use/","link":"","permalink":"http://blog.caoxl.com/2018/07/27/Symfony-First-Use/","excerpt":"Symfony 框架的中文翻译是交响乐, 而Composer的中文翻译是作曲家, 这就让我非常有兴趣去学习一波Symfony 中文文档","text":"Symfony 框架的中文翻译是交响乐, 而Composer的中文翻译是作曲家, 这就让我非常有兴趣去学习一波Symfony 中文文档 安装 Symfony InstallerLinux和MAC OS X系统123sudo curl -LsS https://symfony.com/installer -o /usr/local/bin/symfonysudo chmod a+x /usr/local/bin/symfony Windows系统1c:\\&gt; php -r \"readfile('http://symfony.com/installer');\" &gt; symfony 它会下载一个symfony文件，然后把这文件移动到你想创建Symfony项目的文件夹里，通过下述命令可引导各种安装 12c:\\&gt; move symfony c:\\projectsc:\\projects\\&gt; php symfony 略略略, 直接进入Composer 用Composer创建Symfony程序1composer create-project symfony/framework-standard-edition my_project_name 若需指定版本，提供版本号作为create-project的第二个参数 1composer create-project symfony/framework-standard-edition my_project_name \"3.0.*\" 运行Symfony1php ./bin/console server:run 然后，打开浏览器访问http://localhost:8000/链接，即可看到Symfony欢迎页 创建一个页面路由和控制器12345678910111213141516171819202122232425&lt;?phpnamespace AppBundle\\Controller;use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;use Symfony\\Component\\HttpFoundation\\Request;use Symfony\\Component\\Routing\\Annotation\\Route;use Symfony\\Component\\HttpFoundation\\Response;use Symfony\\Component\\HttpFoundation\\JsonResponse;class LuckyController&#123; /** * @return Response * @Route(\"/lucky/number\") */ public function getRandNumber() &#123; $num = rand(1, 100); return new Response( '&lt;html&gt;&lt;body&gt;number: ' . $num . '&lt;/body&gt;&lt;/html&gt;' ); &#125;&#125; 访问 http://localhost:8000/lucky/number 路由在哪里 ? 路由写在注释里, 真的是长见识了, Symfony的路由居然是在注释里面 @Route(&quot;/lucky/number&quot;)@Route被称为annotation，它定义了URL匹配 创建一个JSON响应123456789101112131415161718192021&lt;?phpclass LuckyController&#123; /** * @return Response * @Route(\"/api/lucky/number2\") */ public function getRandNumberApi() &#123; $data = array( 'lucky_number' =&gt; rand(0, 100), ); return new Response( json_encode($data), 200, array('Content-Type' =&gt; 'application/json') ); &#125;&#125; 访问: http://localhost:8000/api/lucky/number2 你更可将代码精简为超好用的JsonResponse: 1234567891011121314151617181920&lt;?php// 使用JSONResponse需要引入下面这个声明use Symfony\\Component\\HttpFoundation\\JsonResponse;class LuckyController&#123; /** * @return Response * @Route(\"/api/lucky/number2\") */ public function getRandNumberApi() &#123; $data = array( 'lucky_number' =&gt; rand(0, 100), ); return new JsonResponse($data); &#125;&#125; 动态URL匹配: /lucky/number/{count}12345678910111213141516171819/** * @param $count * @return Response * @Route(\"/lucky/number3/&#123;count&#125;\") */public function getRandNumberCount($count)&#123; $numbers = array(); for ($i = 0; $i &lt; $count; $i++) &#123; $numbers[] = rand(0, 100); &#125; $numbersList = implode(',', $numbers); return new Response( '&lt;html&gt;&lt;body&gt;Lucky numbers: '.$numbersList.'&lt;/body&gt;&lt;/html&gt;' );&#125; 因为{count}占位符，页面URL变得不一样了。现在它要求URLs匹配/lucky/number/* 访问: http://localhost:8000/lucky/number3/7 渲染模板 (利用容器) 如果你在控制器中返回HTML，你可能需要渲染模板。幸运的是，Symfony拥有Twig 目前，LuckyController没有继承任何基类。此时引用Twig（或其他Symfony工具）最简单的方式，就是继承Symfony的Controller基类 Controller 12345678910111213141516171819202122/** * @param $count * @return Response * @Route(\"/lucky/number4/&#123;count&#125;\") */public function getRandNumberTwig($count)&#123; $numbers = array(); for ($i = 0; $i &lt; $count; $i++) &#123; $numbers[] = rand(0, 100); &#125; $numbersList = implode(',', $numbers); $html = $this-&gt;render( 'lucky/number.html.twig', array('luckyNumberList' =&gt; $numbersList) ); return new Response($html);&#125; Twig 123456&#123;# app/Resources/views/lucky/number.html.twig #&#125;&#123;% extends'base.html.twig' %&#125;&#123;% block body %&#125; &lt;h1&gt;Lucky Numbers: &#123;&#123; luckyNumberList &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125; 访问: http://localhost:8000/lucky/number4/7 Symfony 目录结构1234567891011121314151617├─app│ ├─config│ └─Resources│ └─views│ ├─default├─bin│ ├─console│ └─symfony_requirements├─src│ └─AppBundle│ └─Controller├─tests│ └─AppBundle│ └─Controller├─var├─vendor└─web app/ 内含配置文件和模板. 大体上, 只要不是PHP代码的材料都放在这里 bin/ 用于存放二进制（binary）文件。最重要的是console文件，它被用来在console中执行Symfony命令。 php ./bin/console server:run src/ 你的PHP程序之所在 src/目录下暂时只有一个目录 - src/AppBundle - 所有的东西都在这里面 test/ 你程序的自动测试（如Unit tests/单元测试）被存放在这里。 var/ 这是那些自动生成的文件被存放的地方，比如缓存文件 (var/cache/) 和日志文件(var/logs/) vendor/ 通过依赖管理器Composer，第三方类库、包、bundles被下载到这里。你应该不去编辑这个目录下的东西。 web/ 它是整个项目的文档根目录，存放可公开访问的文件，比如CSS、图片以及用来执行app（app_dev.php和app.php）的Symfony的前端控制器（front controller）。 路由路由实例123456789101112131415161718192021222324252627&lt;?phpnamespace AppBundle\\Controller;use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;use Symfony\\Component\\HttpFoundation\\Request;use Symfony\\Component\\Routing\\Annotation\\Route;class BlogController extends Controller&#123; /** * @Route(\"/blog\", name=\"blog_list\") */ public function listAction() &#123; &#125; /** * @param $slug * @Route(\"/blog/&#123;slug&#125;\", name=\"blog_show\") */ public function showAction($slug) &#123; &#125;&#125; 添加{通配符}条件 设想 blog_list 路由将包含博客主题带有分页的一个列表，对于第2和第3页有类似 /blog/2 和 /blog/3 这样的URL。如果你把路由路径改为 /blog/{page}，会出现问题: blog_list: /blog/{page} 将匹配 /blog/*; blog_show: /blog/{slug} 将 同样 匹配 /blog/*。 于是: 要修复这个，添加一个 requirement（条件），以便 {page} 通配符能够 仅 匹配数字(digits): 123456789101112131415161718192021222324252627&lt;?phpnamespace AppBundle\\Controller;use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;use Symfony\\Component\\HttpFoundation\\Request;use Symfony\\Component\\Routing\\Annotation\\Route;class BlogController extends Controller&#123; /** * @Route(\"/blog\", name=\"blog_list\", requirements=&#123;\"page\": \"\\d+\"&#125;) */ public function listAction() &#123; &#125; /** * @param $slug * @Route(\"/blog/&#123;slug&#125;\", name=\"blog_show\") */ public function showAction($slug) &#123; &#125;&#125; 给{占位符}一个默认值 前例中，blog_list 路由的路径是 /blog/{page}。如果用户访问 /blog/1，则会匹配。但如果他们访问的是 /blog，就将 无法 匹配到。一旦你添加了某个 {占位符} 到路由中，它就 必须 得有一个值 123456789101112131415161718&lt;?phpnamespace AppBundle\\Controller;use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;use Symfony\\Component\\HttpFoundation\\Request;use Symfony\\Component\\Routing\\Annotation\\Route;class BlogController extends Controller&#123; /** * @Route(\"/blog\", name=\"blog_list\", requirements=&#123;\"page\": \"\\d+\"&#125;) */ public function listAction($page = 1) &#123; &#125;&#125; 现在，当用户访问 /blog 时，blog_list 路由会匹配，并且 $page 路由参数会默认取值为 1。 高级路由示例1234567891011121314151617181920212223242526272829&lt;?phpnamespace AppBundle\\Controller;use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;use Symfony\\Component\\HttpFoundation\\Request;use Symfony\\Component\\Routing\\Annotation\\Route;class ArticleController extends Controller&#123; /** * @param $_locale * @param $year * @param $slug * @Route( * \"/article/&#123;_locale&#125;/&#123;year&#125;/&#123;slug&#125;.&#123;_format&#125;\", * defaults=&#123;\"_format\": \"html\"&#125;, * requirements=&#123; * \"_locale\": \"en|fr\", * \"_format\": \"html|rss\", * \"year\": \"\\d+\" * &#125; * ) */ public function showAction($_locale, $year, $slug) &#123; &#125;&#125; 如你所见，这个路由仅在URL的 {_locale} 部分是 en 或 fr 时，同时 {year} 是一个数字的时候，才会匹配。此路由也表明，你可以在占位符之间使用一个“点”而不是一个斜杠。匹配这个路由的URL可能是下面这种： /articles/en/2018/my-post /articles/fr/2018/my-post.rss /articles/en/2018/my-latest-post.html !!! 一个路由占位符名称不可以起于数字，也不可以长于32个字符。 特殊路由参数你已经看到，每一个路由参数或其默认值最终都是可以做为参数（arguments）用在控制器方法（译注：即action）中的。此外，还有四个特殊参数：每一个都能为你的程序增添一个独有的功能性。 _controller: 就像你看到的, 此参数用于决定, 当路由匹配时, 须执行哪个控制器 _format: 用于设置request format _fragment: 用于设置fragment identifier，即，URL中可选的最末部分，起自一个 # 字符，用来识别页面中的某一部分。 _locale: 用于设置请求中的locale信息 控制器命名法 bundle:controller:action 例如，AppBundle:Blog:show 这个 _controller 值代表: Bundle (Bundle名) - AppBundle Controller Class (控制器类名) - BlogController Method Name (控制器方法名) - showAction 1234567891011namespace AppBundle\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller; class BlogController extends Controller&#123; public function showAction($slug) &#123; // ... &#125;&#125; 加载路由 Symfony 从一个 单一的 路由配置文件: app/config/routing.yml中加载你的程序中的全部路由但从这个文件中，你可以加载任何一个 其他的 路由文件。实际上，Symfony默认从你 AppBundle 中的 Controller/ 目录中加载annotation路由配置，这就是为何Symfony能够看到我们的annotation路由: app\\config\\routing.yml 123app: resource: '@AppBundle/Controller/' type: annotation annotation: 注释的意思 生成URL路由系统也可用来生成URL链接。现实中，路由是个双向系统：把URL映射到控制器，或把路由反解为URL。 1234567891011/** * @param $slug * @Route(\"/blog/&#123;slug&#125;\", name=\"blog_show\") */public function showAction($slug)&#123; $url = $this-&gt;generateUrl( 'blog_show', array('slug' =&gt; 'my-blog-post') );&#125; generateUrl() 1234protected function generateUrl($route, $parameters = array(), $referenceType = UrlGeneratorInterface::ABSOLUTE_PATH)&#123; return $this-&gt;container-&gt;get('router')-&gt;generate($route, $parameters, $referenceType);&#125; 定义在 Controller 基类中的 generateUrl() 方法是以下代码的快捷方式: 1234$url = $this-&gt;container-&gt;get('router')-&gt;generate( 'blog_show', array('slug' =&gt; 'my-blog-post')); 生成带有Query字符串的URL generate() 方法接收通配符的值的数组，以生成URI。但如果你传入额外的值，它们将被添加到URI中，作为query string（查询字符串）: 1234$this-&gt;get('router')-&gt;generate('blog', array( 'page' =&gt; 2, 'category' =&gt; 'Symfony')); 生成绝对URL 默认时，路由生成相对链接 (如 /blog)。在控制器中把 UrlGeneratorInterface::ABSOLUTE_URL 作为 generateUrl() 方法的第三个参数传入: 123use Symfony\\Component\\Routing\\Generator\\UrlGeneratorInterface;$this-&gt;gengerateUrl('blog_show', array('slug' =&gt; 'my-blog-post'), UrlGeneratorInterface::ABSOLUTE_URL) 控制器基础控制器123456789101112131415&lt;?phpnamespace AppBundle\\Controller;use Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;use Symfony\\Component\\HttpFoundation\\Response;use Sensio\\Bundle\\FrameworkExtraBundle\\Configuration\\Route;class TestController extends Controller&#123; public function indexAction($name) &#123; return new Response('&lt;html&gt;&lt;body&gt;Hello '.$name.'!&lt;/body&gt;&lt;/html&gt;'); &#125;&#125; 重定向123456public function indexAction()&#123; return $this-&gt;redirectToRoute('homepage'); return $this-&gt;redirectToRoute('homepage', array(), 301);&#125; 渲染模板1234public function indexAction()&#123; return $this-&gt;render('default/index.html.twig', array('name' =&gt; $name));&#125; 访问其他服务当继承controller基类后，你可以通过get()方法访问任何Symfony的服务。下面列举了一些常见服务： 12345$templating = $this-&gt;get('templating');$router = $this-&gt;get('router');$mailer = $this-&gt;get('mailer'); 问: 到底存在哪些服务？我想要看所有的服务，请使用debug:container命令行查看： 1php bin/console debug:container Request对象作为一个控制器参数123456use Symfony\\Component\\HttpFoundation\\Request;public function indexAction($firstName, $lastName, Request $request)&#123; $page = $request-&gt;query-&gt;get('page', 1);&#125; 管理Session Symfony提供了一个好用的Session对象，它能够存储有关用户的信息（它可以是使用浏览器的人、bot或Web服务）之间的请求。默认情况下，Symfony通过使用PHP的原生Session来保存cookie中的属性。 12345678910111213141516171819&lt;?phpnamespace AppBundle\\Controller;use Symfony\\Component\\HttpFoundation\\Request;class Session&#123; public function indexAction(Request $request) &#123; $session = $request-&gt;getSession(); $session-&gt;set('foo', 'bar'); $fooBar = $session-&gt;get('foobar'); $filters = $session-&gt;get('filters', array()); &#125;&#125; 请求和响应对象正如前面所提到的，框架的Request对象会作为控制器的参数传入并强制指定数据类型为Request类： 12345678910111213141516171819public function indexList(Request $request)&#123; // is Ajax request ? $request-&gt;isXmlHttpRequest(); $request-&gt;getPreferredLanguage('en', 'fr'); $request-&gt;query-&gt;get('page'); $request-&gt;request-&gt;get('page'); $request-&gt;server-&gt;get('HTTP_HOST'); $request-&gt;files-&gt;get('foo'); $request-&gt;cookies-&gt;get('PHPSESSID'); $request-&gt;headers-&gt;get('host'); $request-&gt;headers-&gt;get('content_type');&#125; 配置 Symfony程序是由一组“负责呈现全部功能和可能性”的bundles所构成。每个bundle都可以通过YAML、XML或PHP格式的配置文件进行自定义 默认的主力配置文件是在app/config/目录下，它可以是config.yml、config.xml或config.php，根据你的偏好而定： 配置示例YAML12345678910111213141516# app/config/config.ymlimports: - &#123; resource: parameters.yml &#125; - &#123; resource: security.yml &#125;framework: secret: \"%secret%\" router: &#123; resource: \"%kernel.root_dir%/config/routing.yml\" &#125; # ... # Twig Configurationtwig: debug: \"%kernel.debug%\" strict_variables: \"%kernel.debug%\" # ... XML12345678910111213141516171819202122232425262728&lt;!-- app/config/config.xml --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;container xmlns=\"http://symfony.com/schema/dic/services\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:framework=\"http://symfony.com/schema/dic/symfony\" xmlns:twig=\"http://symfony.com/schema/dic/twig\" xsi:schemaLocation=\"http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd http://symfony.com/schema/dic/symfony http://symfony.com/schema/dic/symfony/symfony-1.0.xsd http://symfony.com/schema/dic/twig http://symfony.com/schema/dic/twig/twig-1.0.xsd\"&gt; &lt;imports&gt; &lt;import resource=\"parameters.yml\" /&gt; &lt;import resource=\"security.yml\" /&gt; &lt;/imports&gt; &lt;framework:config secret=\"%secret%\"&gt; &lt;framework:router resource=\"%kernel.root_dir%/config/routing.xml\" /&gt; &lt;!-- ... --&gt; &lt;/framework:config&gt; &lt;!-- Twig Configuration --&gt; &lt;twig:config debug=\"%kernel.debug%\" strict-variables=\"%kernel.debug%\" /&gt; &lt;!-- ... --&gt;&lt;/container&gt; PHP12345678910111213141516171819// app/config/config.php$this-&gt;import('parameters.yml');$this-&gt;import('security.yml'); $container-&gt;loadFromExtension('framework', array( 'secret' =&gt; '%secret%', 'router' =&gt; array( 'resource' =&gt; '%kernel.root_dir%/config/routing.php', ), // ...)); // Twig Configuration$container-&gt;loadFromExtension('twig', array( 'debug' =&gt; '%kernel.debug%', 'strict_variables' =&gt; '%kernel.debug%',)); // ... 环境配置 AppKernel类负责加载你指定的配置文件： 12345678910public function registerContainerConfiguration(LoaderInterface $loader)&#123; $loader-&gt;load(function (ContainerBuilder $container) &#123; $container-&gt;setParameter('container.autowiring.strict_mode', true); $container-&gt;setParameter('container.dumper.inline_class_loader', true); $container-&gt;addObjectResource($this); &#125;); $loader-&gt;load($this-&gt;getRootDir().'/config/config_'.$this-&gt;getEnvironment().'.yml');&#125;","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Symfony","slug":"Symfony","permalink":"http://blog.caoxl.com/tags/Symfony/"}]},{"title":"Linux终端查看服务器IP","slug":"Linux-show-IP","date":"2018-07-27T06:59:01.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/27/Linux-show-IP/","link":"","permalink":"http://blog.caoxl.com/2018/07/27/Linux-show-IP/","excerpt":"IP地址是计算机网络中用于区分不同主机的数字标识，所有连接到网络中的设备均采用IP协议来进行通信。IP地址的两个主要功能就是区分不同的网络或主机以及用于定位网络地址。","text":"IP地址是计算机网络中用于区分不同主机的数字标识，所有连接到网络中的设备均采用IP协议来进行通信。IP地址的两个主要功能就是区分不同的网络或主机以及用于定位网络地址。 查看服务器公网IP使用dig工具 安装dig命令 1yum install bind-utils dig (domain information groper)是一个用于查询DNS服务器的工具，为了查询主机的公网IP地址，可以通过查询opendns.com的反向解析结果来得到。 dig +short myip.opendns.com @resolver1.opendns.com 12[root@caoxianliang test]# dig +short myip.opendns.com @resolver1.opendns.com47.91.221.85 使用host命令 host命令是一条简便的DNS查询工具，同样可以通过向opendns.com发送查询请求来得到本机的公网地址 12[root@caoxianliang test]# host myip.opendns.com resolver1.opendns.com | grep \"myip.opendns.com has\" | awk '&#123;print $4&#125;'47.91.221.85 使用wget下载工具 wget是一种支持 HTTP, HTTPS, FTP等多种协议的命令行下载工具，于是我们可以通过wget第三方网站来得到本机的IP地址 12345[root@caoxianliang test]# wget -qO- http://ipecho.net/plain | xargs echo47.91.221.85[root@caoxianliang test]# wget -qO - icanhazip.com47.91.221.85 两条命令的执行结果是一致的，只是访问的第三方网站不相同。 使用cURL命令行下载工具 既然wget可以用，那么功能更加强大的curl工具当然也没有问题。curl是一种支持多种网络协议（HTTP、HTTPS、FILE、FTP、FTPS等）的上传下载工具，同样可以访问第三方网站查询服务器的公网IP地址 12345678[root@caoxianliang test]# curl ifconfig.co47.91.221.85[root@caoxianliang test]# curl ifconfig.me47.91.221.85[root@caoxianliang test]# curl icanhazip.com47.91.221.85 查看服务器内网IP使用 ifconfig12345678910111213141516[root@caoxianliang test]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.45.94 netmask 255.255.240.0 broadcast 172.31.47.255 ether 00:16:3e:01:a4:4f txqueuelen 1000 (Ethernet) RX packets 3714175 bytes 2541275565 (2.3 GiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 2733364 bytes 2746165972 (2.5 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 3046 bytes 3781560 (3.6 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3046 bytes 3781560 (3.6 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 使用 ip addr123456789[root@caoxianliang test]# ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:16:3e:01:a4:4f brd ff:ff:ff:ff:ff:ff inet 172.31.45.94/20 brd 172.31.47.255 scope global eth0 valid_lft forever preferred_lft forever 参考 Linux终端查看服务器公网IP地址的四条命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"IP","slug":"IP","permalink":"http://blog.caoxl.com/tags/IP/"}]},{"title":"各种操作系统下清空DNS缓存","slug":"Clear-DNS-Cache","date":"2018-07-26T07:39:50.000Z","updated":"2019-08-22T03:44:18.000Z","comments":true,"path":"2018/07/26/Clear-DNS-Cache/","link":"","permalink":"http://blog.caoxl.com/2018/07/26/Clear-DNS-Cache/","excerpt":"Windows 清空DNS缓存 1ipconfig /flushdns","text":"Windows 清空DNS缓存 1ipconfig /flushdns 查看DNS缓存 1ipconfig /displaydns Mac OSX下123lookupd -flushcache# 或 Linux下 在Linux中, nscd进程负责管理DNS缓存要清空DNS缓存, 重启nscd守护进程就行了 清除 nscd dns 缓存 1234567service nscd restart# 或sudo /etc/init.d/nscd restart# 或service nscd reload 清除 dnsmasq dns 缓存 1234sudo /etc/init.d/dnsmasq restart# 或service dnsmasq restart 清除BIND缓存服务器的dns缓存 1234567/etc/init.d/named restart# 或rndc restart# 或rndc exec","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"DNS","slug":"DNS","permalink":"http://blog.caoxl.com/tags/DNS/"}]},{"title":"CentOS下配置安装JavaWeb环境","slug":"Install-JavaWeb-In-CentOS","date":"2018-07-26T06:44:41.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/26/Install-JavaWeb-In-CentOS/","link":"","permalink":"http://blog.caoxl.com/2018/07/26/Install-JavaWeb-In-CentOS/","excerpt":"搭建 Java 开发环境","text":"搭建 Java 开发环境 安装 JDK JDK 是开发Java程序必须安装的软件,我们查看一下 yum 源里面的 JDK: 1234yum list java*# 或yum list | grep jdk 选择适合本机的JDK，并安装: 1yum install java-1.8.0-openjdk* -y 安装完成后，查看是否安装成功(安装成功回显示jdk的版本号): 1234[root@caoxianliang local]# java -versionopenjdk version \"1.8.0_171\"OpenJDK Runtime Environment (build 1.8.0_171-b10)OpenJDK 64-Bit Server VM (build 25.171-b10, mixed mode) 安装Tomcat 下载Tomcat，并解压到指定目录中。 /usr/local/java-tomcat (我的安装目录) 123cd /usr/local/java-tomcattar zxvf apache-tomcat-9.0.10.tar.gzmv ./apache-tomcat-9.0.10/ /usr/local/tomcat9 修改权限 1chmod -R 777 /usr/local/tomcat9/bin 启动tomcat 1/usr/local/tomcat9/bin/startup.sh 修改Nginx配置 (/usr/local/nginx/conf/nginx.conf) 123456789101112location ~ .+\\.jsp($|/) &#123; proxy_pass http://127.0.0.1:8080; #转发端口 proxy_set_header Host $host; client_max_body_size 10m; client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数。 proxy_connect_timeout 90; #Nginx跟后端服务器连接超时时间。 proxy_read_timeout 90; #连接成功后，后端服务器响应时间。 proxy_buffer_size 4k; #设置代理服务器保存用户头信息的缓冲区大小。 proxy_buffers 6 32k; #proxy_buffers缓冲区。 proxy_busy_buffers_size 64k; #高负荷下缓冲大小。 proxy_temp_file_write_size 64k;#设定缓存文件夹大小。 &#125; java.com.conf 12345678910111213141516171819202122232425262728server &#123; listen 80; #listen [::]:80 default_server; server_name java.caoxl.com; # Load configuration files for the default server block. #include /etc/nginx/default.d/*.conf; location /i/ &#123; alias /usr/local/tomcat9/webapps/ROOT/;&#125;location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://127.0.0.1:8080;&#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 别忘了 service nginx restart 重启Nginx 访问: java.caoxl.com 即可看到 动静分离 新建一个location来专门转发静态文件 1234location ~ \\.(html|js|css|gif|jpg|png|bmp|swf)$ &#123; expires 30d; root /usr/local/tomcat9/webapps/ROOT;&#125; 至此, JavaWeb搭建完成, 最后说一句, PHP是世界上最好的语言","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://blog.caoxl.com/tags/JavaWeb/"}]},{"title":"PHP根据银行卡号获取银行名称","slug":"PHP-Get-Bank-Card-Name","date":"2018-07-26T06:05:18.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/26/PHP-Get-Bank-Card-Name/","link":"","permalink":"http://blog.caoxl.com/2018/07/26/PHP-Get-Bank-Card-Name/","excerpt":"该方法只能获取银行名称, 且方法比较笨","text":"该方法只能获取银行名称, 且方法比较笨 直接上源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418&lt;?phpheader(\"Content-type: text/html; charset=utf-8\");class GetBank&#123; public static $bankBin = array( 621098, 622150, 622151, 622181, 622188, 955100, 621095, 620062, 621285, 621798, 621799, 621797, 620529, 622199, 621096, 621622, 623219, 621674, 623218, 621599, 370246, 370248, 370249, 427010, 427018, 427019, 427020, 427029, 427030, 427039, 370247, 438125, 438126, 451804, 451810, 451811, 458071, 489734, 489735, 489736, 510529, 427062, 524091, 427064, 530970, 530990, 558360, 620200, 620302, 620402, 620403, 620404, 524047, 620406, 620407, 525498, 620409, 620410, 620411, 620412, 620502, 620503, 620405, 620408, 620512, 620602, 620604, 620607, 620611, 620612, 620704, 620706, 620707, 620708, 620709, 620710, 620609, 620712, 620713, 620714, 620802, 620711, 620904, 620905, 621001, 620902, 621103, 621105, 621106, 621107, 621102, 621203, 621204, 621205, 621206, 621207, 621208, 621209, 621210, 621302, 621303, 621202, 621305, 621306, 621307, 621309, 621311, 621313, 621211, 621315, 621304, 621402, 621404, 621405, 621406, 621407, 621408, 621409, 621410, 621502, 621317, 621511, 621602, 621603, 621604, 621605, 621608, 621609, 621610, 621611, 621612, 621613, 621614, 621615, 621616, 621617, 621607, 621606, 621804, 621807, 621813, 621814, 621817, 621901, 621904, 621905, 621906, 621907, 621908, 621909, 621910, 621911, 621912, 621913, 621915, 622002, 621903, 622004, 622005, 622006, 622007, 622008, 622010, 622011, 622012, 621914, 622015, 622016, 622003, 622018, 622019, 622020, 622102, 622103, 622104, 622105, 622013, 622111, 622114, 622200, 622017, 622202, 622203, 622208, 622210, 622211, 622212, 622213, 622214, 622110, 622220, 622223, 622225, 622229, 622230, 622231, 622232, 622233, 622234, 622235, 622237, 622215, 622239, 622240, 622245, 622224, 622303, 622304, 622305, 622306, 622307, 622308, 622309, 622238, 622314, 622315, 622317, 622302, 622402, 622403, 622404, 622313, 622504, 622505, 622509, 622513, 622517, 622502, 622604, 622605, 622606, 622510, 622703, 622715, 622806, 622902, 622903, 622706, 623002, 623006, 623008, 623011, 623012, 622904, 623015, 623100, 623202, 623301, 623400, 623500, 623602, 623803, 623901, 623014, 624100, 624200, 624301, 624402, 62451804, 62451810, 62451811, 62458071, 623700, 628288, 624000, 628286, 622206, 621225, 526836, 513685, 543098, 458441, 620058, 621281, 622246, 900000, 544210, 548943, 370267, 621558, 621559, 621722, 621723, 620086, 621226, 402791, 427028, 427038, 548259, 356879, 356880, 356881, 356882, 528856, 621618, 620516, 621227, 621721, 900010, 625330, 625331, 625332, 623062, 622236, 621670, 524374, 550213, 374738, 374739, 621288, 625708, 625709, 622597, 622599, 360883, 360884, 625865, 625866, 625899, 621376, 620054, 620142, 621428, 625939, 621434, 625987, 621761, 621749, 620184, 621300, 621378, 625114, 622159, 621720, 625021, 625022, 621379, 620114, 620146, 621724, 625918, 621371, 620143, 620149, 621414, 625914, 621375, 620187, 621433, 625986, 621370, 625925, 622926, 622927, 622928, 622929, 622930, 622931, 620124, 620183, 620561, 625116, 622227, 621372, 621464, 625942, 622158, 625917, 621765, 620094, 620186, 621719, 621719, 621750, 621377, 620148, 620185, 621374, 621731, 621781, 552599, 623206, 621671, 620059, 403361, 404117, 404118, 404119, 404120, 404121, 463758, 514027, 519412, 519413, 520082, 520083, 558730, 621282, 621336, 621619, 622821, 622822, 622823, 622824, 622825, 622826, 622827, 622828, 622836, 622837, 622840, 622841, 622843, 622844, 622845, 622846, 622847, 622848, 622849, 623018, 625996, 625997, 625998, 628268, 625826, 625827, 548478, 544243, 622820, 622830, 622838, 625336, 628269, 620501, 621660, 621661, 621662, 621663, 621665, 621667, 621668, 621669, 621666, 625908, 625910, 625909, 356833, 356835, 409665, 409666, 409668, 409669, 409670, 409671, 409672, 456351, 512315, 512316, 512411, 512412, 514957, 409667, 518378, 518379, 518474, 518475, 518476, 438088, 524865, 525745, 525746, 547766, 552742, 553131, 558868, 514958, 622752, 622753, 622755, 524864, 622757, 622758, 622759, 622760, 622761, 622762, 622763, 601382, 622756, 628388, 621256, 621212, 620514, 622754, 622764, 518377, 622765, 622788, 621283, 620061, 621725, 620040, 558869, 621330, 621331, 621332, 621333, 621297, 377677, 621568, 621569, 625905, 625906, 625907, 628313, 625333, 628312, 623208, 621620, 621756, 621757, 621758, 621759, 621785, 621786, 621787, 621788, 621789, 621790, 621672, 625337, 625338, 625568, 621648, 621248, 621249, 622750, 622751, 622771, 622772, 622770, 625145, 620531, 620210, 620211, 622479, 622480, 622273, 622274, 621231, 621638, 621334, 625140, 621395, 622725, 622728, 621284, 421349, 434061, 434062, 436728, 436742, 453242, 491031, 524094, 526410, 544033, 552245, 589970, 620060, 621080, 621081, 621466, 621467, 621488, 621499, 621598, 621621, 621700, 622280, 622700, 622707, 622966, 622988, 625955, 625956, 553242, 621082, 621673, 623211, 356896, 356899, 356895, 436718, 436738, 436745, 436748, 489592, 531693, 532450, 532458, 544887, 552801, 557080, 558895, 559051, 622166, 622168, 622708, 625964, 625965, 625966, 628266, 628366, 625362, 625363, 628316, 628317, 620021, 620521, 405512, 601428, 405512, 434910, 458123, 458124, 520169, 522964, 552853, 601428, 622250, 622251, 521899, 622254, 622255, 622256, 622257, 622258, 622259, 622253, 622261, 622284, 622656, 628216, 622252, 66405512, 622260, 66601428, 955590, 955591, 955592, 955593, 628218, 622262, 621069, 620013, 625028, 625029, 621436, 621002, 621335, 433670, 433680, 442729, 442730, 620082, 622690, 622691, 622692, 622696, 622698, 622998, 622999, 433671, 968807, 968808, 968809, 621771, 621767, 621768, 621770, 621772, 621773, 620527, 356837, 356838, 486497, 622660, 622662, 622663, 622664, 622665, 622666, 622667, 622669, 622670, 622671, 622672, 622668, 622661, 622674, 622673, 620518, 621489, 621492, 620535, 623156, 621490, 621491, 620085, 623155, 623157, 623158, 623159, 999999, 621222, 623020, 623021, 623022, 623023, 622630, 622631, 622632, 622633, 622615, 622616, 622618, 622622, 622617, 622619, 415599, 421393, 421865, 427570, 427571, 472067, 472068, 622620, 621691, 545392, 545393, 545431, 545447, 356859, 356857, 407405, 421869, 421870, 421871, 512466, 356856, 528948, 552288, 622600, 622601, 622602, 517636, 622621, 628258, 556610, 622603, 464580, 464581, 523952, 545217, 553161, 356858, 622623, 625911, 377152, 377153, 377158, 377155, 625912, 625913, 356885, 356886, 356887, 356888, 356890, 402658, 410062, 439188, 439227, 468203, 479228, 479229, 512425, 521302, 524011, 356889, 545620, 545621, 545947, 545948, 552534, 552587, 622575, 622576, 622577, 622579, 622580, 545619, 622581, 622582, 622588, 622598, 622609, 690755, 690755, 545623, 621286, 620520, 621483, 621485, 621486, 628290, 622578, 370285, 370286, 370287, 370289, 439225, 518710, 518718, 628362, 439226, 628262, 625802, 625803, 621299, 966666, 622909, 622908, 438588, 438589, 461982, 486493, 486494, 486861, 523036, 451289, 527414, 528057, 622901, 622902, 622922, 628212, 451290, 524070, 625084, 625085, 625086, 625087, 548738, 549633, 552398, 625082, 625083, 625960, 625961, 625962, 625963, 356851, 356852, 404738, 404739, 456418, 498451, 515672, 356850, 517650, 525998, 622177, 622277, 622516, 622517, 622518, 622520, 622521, 622522, 622523, 628222, 628221, 984301, 984303, 622176, 622276, 622228, 621352, 621351, 621390, 621792, 625957, 625958, 621791, 620530, 625993, 622519, 621793, 621795, 621796, 622500, 623078, 622384, 940034, 940015, 622886, 622391, 940072, 622359, 940066, 622857, 940065, 621019, 622309, 621268, 622884, 621453, 622684, 621016, 621015, 622950, 622951, 621072, 623183, 623185, 621005, 622172, 622985, 622987, 622267, 622278, 622279, 622468, 622892, 940021, 621050, 620522, 356827, 356828, 356830, 402673, 402674, 438600, 486466, 519498, 520131, 524031, 548838, 622148, 622149, 622268, 356829, 622300, 628230, 622269, 625099, 625953, 625350, 625351, 625352, 519961, 625839, 421317, 602969, 621030, 621420, 621468, 623111, 422160, 422161, 622865, 940012, 623131, 622178, 622179, 628358, 622394, 940025, 621279, 622281, 622316, 940022, 621418, 512431, 520194, 621626, 623058, 602907, 622986, 622989, 622298, 622338, 940032, 623205, 621977, 990027, 622325, 623029, 623105, 621244, 623081, 623108, 566666, 622455, 940039, 622466, 628285, 622420, 940041, 623118, 603708, 622993, 623070, 623069, 623172, 623173, 622383, 622385, 628299, 603506, 603367, 622878, 623061, 623209, 628242, 622595, 622303, 622305, 621259, 622596, 622333, 940050, 621439, 623010, 621751, 628278, 625502, 625503, 625135, 622476, 621754, 622143, 940001, 623026, 623086, 628291, 621532, 621482, 622135, 622152, 622153, 622154, 622996, 622997, 940027, 623099, 623007, 940055, 622397, 622398, 940054, 622331, 622426, 625995, 621452, 628205, 628214, 625529, 622428, 621529, 622429, 621417, 623089, 623200, 940057, 622311, 623119, 622877, 622879, 621775, 623203, 603601, 622137, 622327, 622340, 622366, 622134, 940018, 623016, 623096, 940049, 622425, 622425, 621577, 622485, 623098, 628329, 621538, 940006, 621269, 622275, 621216, 622465, 940031, 621252, 622146, 940061, 621419, 623170, 622440, 940047, 940017, 622418, 623077, 622413, 940002, 623188, 622310, 940068, 622321, 625001, 622427, 940069, 623039, 628273, 622370, 683970, 940074, 621437, 628319, 990871, 622308, 621415, 623166, 622132, 621340, 621341, 622140, 623073, 622147, 621633, 622301, 623171, 621422, 622335, 622336, 622165, 622315, 628295, 625950, 621760, 622337, 622411, 623102, 622342, 623048, 622367, 622392, 623085, 622395, 622441, 622448, 621413, 622856, 621037, 621097, 621588, 623032, 622644, 623518, 622870, 622866, 623072, 622897, 628279, 622864, 621403, 622561, 622562, 622563, 622167, 622777, 621497, 622868, 622899, 628255, 625988, 622566, 622567, 622625, 622626, 625946, 628200, 621076, 504923, 622173, 622422, 622447, 622131, 940076, 621579, 622876, 622873, 622962, 622936, 623060, 622937, 623101, 621460, 622939, 622960, 623523, 621591, 622961, 628210, 622283, 625902, 621010, 622980, 623135, 621726, 621088, 620517, 622740, 625036, 621014, 621004, 622972, 623196, 621028, 623083, 628250, 623121, 621070, 628253, 622979, 621035, 621038, 621086, 621498, 621296, 621448, 622945, 621755, 622940, 623120, 628355, 621089, 623161, 628339, 621074, 621515, 623030, 621345, 621090, 623178, 621091, 623168, 621057, 623199, 621075, 623037, 628303, 621233, 621235, 621223, 621780, 621221, 623138, 628389, 621239, 623068, 621271, 628315, 621272, 621738, 621273, 623079, 621263, 621325, 623084, 621327, 621753, 628331, 623160, 621366, 621388, 621348, 621359, 621360, 621217, 622959, 621270, 622396, 622511, 623076, 621391, 621339, 621469, 621625, 623688, 623113, 621601, 621655, 621636, 623182, 623087, 621696, 622955, 622478, 940013, 621495, 621688, 623162, 622462, 628272, 625101, 622323, 623071, 603694, 622128, 622129, 623035, 623186, 621522, 622271, 940037, 940038, 985262, 622322, 628381, 622481, 622341, 940058, 623115, 621258, 621465, 621528, 622328, 940062, 625288, 623038, 625888, 622332, 940063, 623123, 622138, 621066, 621560, 621068, 620088, 621067, 622531, 622329, 623103, 622339, 620500, 621024, 622289, 622389, 628300, 625516, 621516, 622859, 622869, 623075, 622895, 623125, 622947, 621561, 623095, 621073, 623109, 621361, 623033, 623207, 622891, 621363, 623189, 623510, 622995, 621053, 621230, 621229, 622218, 628267, 621392, 621481, 621310, 621396, 623251, 628351, 627066, 627066, 627067, 627068, 627069, 412962, 412963, 415752, 415753, 622535, 622536, 622538, 622539, 622983, 998800 ); // \"发卡行.卡种名称\" public static $bankName = array( \"邮储银行·绿卡通\", \"邮储银行·绿卡银联标准卡\", \"邮储银行·绿卡银联标准卡\", \"邮储银行·绿卡专用卡\", \"邮储银行·绿卡银联标准卡\", \"邮储银行·绿卡(银联卡)\", \"邮储银行·绿卡VIP卡\", \"邮储银行·银联标准卡\", \"邮储银行·中职学生资助卡\", \"邮政储蓄银行·IC绿卡通VIP卡\", \"邮政储蓄银行·IC绿卡通\", \"邮政储蓄银行·IC联名卡\", \"邮政储蓄银行·IC预付费卡\", \"邮储银行·绿卡银联标准卡\", \"邮储银行·绿卡通\", \"邮政储蓄银行·武警军人保障卡\", \"邮政储蓄银行·中国旅游卡（金卡）\", \"邮政储蓄银行·普通高中学生资助卡\", \"邮政储蓄银行·中国旅游卡（普卡）\", \"邮政储蓄银行·福农卡\", \"工商银行·牡丹运通卡金卡\", \"工商银行·牡丹运通卡金卡\", \"工商银行·牡丹运通卡金卡\", \"工商银行·牡丹VISA卡(单位卡)\", \"工商银行·牡丹VISA信用卡\", \"工商银行·牡丹VISA卡(单位卡)\", \"工商银行·牡丹VISA信用卡\", \"工商银行·牡丹VISA信用卡\", \"工商银行·牡丹VISA信用卡\", \"工商银行·牡丹VISA信用卡\", \"工商银行·牡丹运通卡普通卡\", \"工商银行·牡丹VISA信用卡\", \"工商银行·牡丹VISA白金卡\", \"工商银行·牡丹贷记卡(银联卡)\", \"工商银行·牡丹贷记卡(银联卡)\", \"工商银行·牡丹贷记卡(银联卡)\", \"工商银行·牡丹贷记卡(银联卡)\", \"工商银行·牡丹欧元卡\", \"工商银行·牡丹欧元卡\", \"工商银行·牡丹欧元卡\", \"工商银行·牡丹万事达国际借记卡\", \"工商银行·牡丹VISA信用卡\", \"工商银行·海航信用卡\", \"工商银行·牡丹VISA信用卡\", \"工商银行·牡丹万事达信用卡\", \"工商银行·牡丹万事达信用卡\", \"工商银行·牡丹万事达信用卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹万事达白金卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·海航信用卡个人普卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·E时代卡\", \"工商银行·E时代卡\", \"工商银行·理财金卡\", \"工商银行·准贷记卡(个普)\", \"工商银行·准贷记卡(个普)\", \"工商银行·准贷记卡(个普)\", \"工商银行·准贷记卡(个普)\", \"工商银行·准贷记卡(个普)\", \"工商银行·牡丹灵通卡\", \"工商银行·准贷记卡(商普)\", \"工商银行·牡丹卡(商务卡)\", \"工商银行·准贷记卡(商金)\", \"工商银行·牡丹卡(商务卡)\", \"工商银行·贷记卡(个普)\", \"工商银行·牡丹卡(个人卡)\", \"工商银行·牡丹卡(个人卡)\", \"工商银行·牡丹卡(个人卡)\", \"工商银行·牡丹卡(个人卡)\", \"工商银行·贷记卡(个金)\", \"工商银行·牡丹交通卡\", \"工商银行·准贷记卡(个金)\", \"工商银行·牡丹交通卡\", \"工商银行·贷记卡(商普)\", \"工商银行·贷记卡(商金)\", \"工商银行·牡丹卡(商务卡)\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹交通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹灵通卡\", \"工商银行·牡丹贷记卡\", \"工商银行·牡丹贷记卡\", \"工商银行·牡丹贷记卡\", \"工商银行·牡丹贷记卡\", \"工商银行·牡丹灵通卡\", \"工商银行·中央预算单位公务卡\", \"工商银行·牡丹灵通卡\", \"工商银行·财政预算单位公务卡\", \"工商银行·牡丹卡白金卡\", \"工商银行·牡丹卡普卡\", \"工商银行·国航知音牡丹信用卡\", \"工商银行·国航知音牡丹信用卡\", \"工商银行·国航知音牡丹信用卡\", \"工商银行·国航知音牡丹信用卡\", \"工商银行·银联标准卡\", \"工商银行·中职学生资助卡\", \"工商银行·专用信用消费卡\", \"工商银行·牡丹社会保障卡\", \"中国工商银行·牡丹东航联名卡\", \"中国工商银行·牡丹东航联名卡\", \"中国工商银行·牡丹运通白金卡\", \"中国工商银行·福农灵通卡\", \"中国工商银行·福农灵通卡\", \"工商银行·灵通卡\", \"工商银行·灵通卡\", \"中国工商银行·中国旅行卡\", \"工商银行·牡丹卡普卡\", \"工商银行·国际借记卡\", \"工商银行·国际借记卡\", \"工商银行·国际借记卡\", \"工商银行·国际借记卡\", \"中国工商银行·牡丹JCB信用卡\", \"中国工商银行·牡丹JCB信用卡\", \"中国工商银行·牡丹JCB信用卡\", \"中国工商银行·牡丹JCB信用卡\", \"中国工商银行·牡丹多币种卡\", \"中国工商银行·武警军人保障卡\", \"工商银行·预付芯片卡\", \"工商银行·理财金账户金卡\", \"工商银行·灵通卡\", \"工商银行·牡丹宁波市民卡\", \"中国工商银行·中国旅游卡\", \"中国工商银行·中国旅游卡\", \"中国工商银行·中国旅游卡\", \"中国工商银行·借记卡\", \"中国工商银行·借贷合一卡\", \"中国工商银行·普通高中学生资助卡\", \"中国工商银行·牡丹多币种卡\", \"中国工商银行·牡丹多币种卡\", \"中国工商银行·牡丹百夫长信用卡\", \"中国工商银行·牡丹百夫长信用卡\", \"工商银行·工银财富卡\", \"中国工商银行·中小商户采购卡\", \"中国工商银行·中小商户采购卡\", \"中国工商银行·环球旅行金卡\", \"中国工商银行·环球旅行白金卡\", \"中国工商银行·牡丹工银大来卡\", \"中国工商银行·牡丹工银大莱卡\", \"中国工商银行·IC金卡\", \"中国工商银行·IC白金卡\", \"中国工商银行·工行IC卡（红卡）\", \"中国工商银行布鲁塞尔分行·借记卡\", \"中国工商银行布鲁塞尔分行·预付卡\", \"中国工商银行布鲁塞尔分行·预付卡\", \"中国工商银行金边分行·借记卡\", \"中国工商银行金边分行·信用卡\", \"中国工商银行金边分行·借记卡\", \"中国工商银行金边分行·信用卡\", \"中国工商银行加拿大分行·借记卡\", \"中国工商银行加拿大分行·借记卡\", \"中国工商银行加拿大分行·预付卡\", \"中国工商银行巴黎分行·借记卡\", \"中国工商银行巴黎分行·借记卡\", \"中国工商银行巴黎分行·贷记卡\", \"中国工商银行法兰克福分行·贷记卡\", \"中国工商银行法兰克福分行·借记卡\", \"中国工商银行法兰克福分行·贷记卡\", \"中国工商银行法兰克福分行·贷记卡\", \"中国工商银行法兰克福分行·借记卡\", \"中国工商银行法兰克福分行·预付卡\", \"中国工商银行法兰克福分行·预付卡\", \"中国工商银行印尼分行·借记卡\", \"中国工商银行印尼分行·信用卡\", \"中国工商银行米兰分行·借记卡\", \"中国工商银行米兰分行·预付卡\", \"中国工商银行米兰分行·预付卡\", \"中国工商银行阿拉木图子行·借记卡\", \"中国工商银行阿拉木图子行·贷记卡\", \"中国工商银行阿拉木图子行·借记卡\", \"中国工商银行阿拉木图子行·预付卡\", \"中国工商银行万象分行·借记卡\", \"中国工商银行万象分行·贷记卡\", \"中国工商银行卢森堡分行·借记卡\", \"中国工商银行卢森堡分行·贷记卡\", \"中国工商银行澳门分行·E时代卡\", \"中国工商银行澳门分行·E时代卡\", \"中国工商银行澳门分行·E时代卡\", \"中国工商银行澳门分行·理财金账户\", \"中国工商银行澳门分行·理财金账户\", \"中国工商银行澳门分行·理财金账户\", \"中国工商银行澳门分行·预付卡\", \"中国工商银行澳门分行·预付卡\", \"中国工商银行澳门分行·工银闪付预付卡\", \"中国工商银行澳门分行·工银银联公司卡\", \"中国工商银行澳门分行·Diamond\", \"中国工商银行阿姆斯特丹·借记卡\", \"中国工商银行卡拉奇分行·借记卡\", \"中国工商银行卡拉奇分行·贷记卡\", \"中国工商银行新加坡分行·贷记卡\", \"中国工商银行新加坡分行·贷记卡\", \"中国工商银行新加坡分行·借记卡\", \"中国工商银行新加坡分行·预付卡\", \"中国工商银行新加坡分行·预付卡\", \"中国工商银行新加坡分行·借记卡\", \"中国工商银行新加坡分行·借记卡\", \"中国工商银行马德里分行·借记卡\", \"中国工商银行马德里分行·借记卡\", \"中国工商银行马德里分行·预付卡\", \"中国工商银行马德里分行·预付卡\", \"中国工商银行伦敦子行·借记卡\", \"中国工商银行伦敦子行·工银伦敦借记卡\", \"中国工商银行伦敦子行·借记卡\", \"农业银行·金穗贷记卡\", \"农业银行·中国旅游卡\", \"农业银行·普通高中学生资助卡\", \"农业银行·银联标准卡\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·VISA白金卡\", \"农业银行·万事达白金卡\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡(银联卡)\", \"农业银行·金穗贷记卡\", \"农业银行·中职学生资助卡\", \"农业银行·专用惠农卡\", \"农业银行·武警军人保障卡\", \"农业银行·金穗校园卡(银联卡)\", \"农业银行·金穗星座卡(银联卡)\", \"农业银行·金穗社保卡(银联卡)\", \"农业银行·金穗旅游卡(银联卡)\", \"农业银行·金穗青年卡(银联卡)\", \"农业银行·复合介质金穗通宝卡\", \"农业银行·金穗海通卡\", \"农业银行·退役金卡\", \"农业银行·金穗贷记卡\", \"农业银行·金穗贷记卡\", \"农业银行·金穗通宝卡(银联卡)\", \"农业银行·金穗惠农卡\", \"农业银行·金穗通宝银卡\", \"农业银行·金穗通宝卡(银联卡)\", \"农业银行·金穗通宝卡(银联卡)\", \"农业银行·金穗通宝卡\", \"农业银行·金穗通宝卡(银联卡)\", \"农业银行·金穗通宝卡(银联卡)\", \"农业银行·金穗通宝钻石卡\", \"农业银行·掌尚钱包\", \"农业银行·银联IC卡金卡\", \"农业银行·银联预算单位公务卡金卡\", \"农业银行·银联IC卡白金卡\", \"农业银行·金穗公务卡\", \"中国农业银行贷记卡·IC普卡\", \"中国农业银行贷记卡·IC金卡\", \"中国农业银行贷记卡·澳元卡\", \"中国农业银行贷记卡·欧元卡\", \"中国农业银行贷记卡·金穗通商卡\", \"中国农业银行贷记卡·金穗通商卡\", \"中国农业银行贷记卡·银联白金卡\", \"中国农业银行贷记卡·中国旅游卡\", \"中国农业银行贷记卡·银联IC公务卡\", \"宁波市农业银行·市民卡B卡\", \"中国银行·联名卡\", \"中国银行·个人普卡\", \"中国银行·个人金卡\", \"中国银行·员工普卡\", \"中国银行·员工金卡\", \"中国银行·理财普卡\", \"中国银行·理财金卡\", \"中国银行·理财银卡\", \"中国银行·理财白金卡\", \"中国银行·中行金融IC卡白金卡\", \"中国银行·中行金融IC卡普卡\", \"中国银行·中行金融IC卡金卡\", \"中国银行·中银JCB卡金卡\", \"中国银行·中银JCB卡普卡\", \"中国银行·员工普卡\", \"中国银行·个人普卡\", \"中国银行·中银威士信用卡员\", \"中国银行·中银威士信用卡员\", \"中国银行·个人白金卡\", \"中国银行·中银威士信用卡\", \"中国银行·长城公务卡\", \"中国银行·长城电子借记卡\", \"中国银行·中银万事达信用卡\", \"中国银行·中银万事达信用卡\", \"中国银行·中银万事达信用卡\", \"中国银行·中银万事达信用卡\", \"中国银行·中银万事达信用卡\", \"中国银行·中银威士信用卡员\", \"中国银行·长城万事达信用卡\", \"中国银行·长城万事达信用卡\", \"中国银行·长城万事达信用卡\", \"中国银行·长城万事达信用卡\", \"中国银行·长城万事达信用卡\", \"中国银行·中银奥运信用卡\", \"中国银行·长城信用卡\", \"中国银行·长城信用卡\", \"中国银行·长城信用卡\", \"中国银行·长城万事达信用卡\", \"中国银行·长城公务卡\", \"中国银行·长城公务卡\", \"中国银行·中银万事达信用卡\", \"中国银行·中银万事达信用卡\", \"中国银行·长城人民币信用卡\", \"中国银行·长城人民币信用卡\", \"中国银行·长城人民币信用卡\", \"中国银行·长城信用卡\", \"中国银行·长城人民币信用卡\", \"中国银行·长城人民币信用卡\", \"中国银行·长城信用卡\", \"中国银行·银联单币贷记卡\", \"中国银行·长城信用卡\", \"中国银行·长城信用卡\", \"中国银行·长城信用卡\", \"中国银行·长城电子借记卡\", \"中国银行·长城人民币信用卡\", \"中国银行·银联标准公务卡\", \"中国银行·一卡双账户普卡\", \"中国银行·财互通卡\", \"中国银行·电子现金卡\", \"中国银行·长城人民币信用卡\", \"中国银行·长城单位信用卡普卡\", \"中国银行·中银女性主题信用卡\", \"中国银行·长城单位信用卡金卡\", \"中国银行·白金卡\", \"中国银行·中职学生资助卡\", \"中国银行·银联标准卡\", \"中国银行·金融IC卡\", \"中国银行·长城社会保障卡\", \"中国银行·世界卡\", \"中国银行·社保联名卡\", \"中国银行·社保联名卡\", \"中国银行·医保联名卡\", \"中国银行·医保联名卡\", \"中国银行·公司借记卡\", \"中国银行·银联美运顶级卡\", \"中国银行·长城福农借记卡金卡\", \"中国银行·长城福农借记卡普卡\", \"中国银行·中行金融IC卡普卡\", \"中国银行·中行金融IC卡金卡\", \"中国银行·中行金融IC卡白金卡\", \"中国银行·长城银联公务IC卡白金卡\", \"中国银行·中银旅游信用卡\", \"中国银行·长城银联公务IC卡金卡\", \"中国银行·中国旅游卡\", \"中国银行·武警军人保障卡\", \"中国银行·社保联名借记IC卡\", \"中国银行·社保联名借记IC卡\", \"中国银行·医保联名借记IC卡\", \"中国银行·医保联名借记IC卡\", \"中国银行·借记IC个人普卡\", \"中国银行·借记IC个人金卡\", \"中国银行·借记IC个人普卡\", \"中国银行·借记IC白金卡\", \"中国银行·借记IC钻石卡\", \"中国银行·借记IC联名卡\", \"中国银行·普通高中学生资助卡\", \"中国银行·长城环球通港澳台旅游金卡\", \"中国银行·长城环球通港澳台旅游白金卡\", \"中国银行·中银福农信用卡\", \"中国银行金边分行·借记卡\", \"中国银行雅加达分行·借记卡\", \"中国银行首尔分行·借记卡\", \"中国银行澳门分行·人民币信用卡\", \"中国银行澳门分行·人民币信用卡\", \"中国银行澳门分行·中银卡\", \"中国银行澳门分行·中银卡\", \"中国银行澳门分行·中银卡\", \"中国银行澳门分行·中银银联双币商务卡\", \"中国银行澳门分行·预付卡\", \"中国银行澳门分行·澳门中国银行银联预付卡\", \"中国银行澳门分行·澳门中国银行银联预付卡\", \"中国银行澳门分行·熊猫卡\", \"中国银行澳门分行·财富卡\", \"中国银行澳门分行·银联港币卡\", \"中国银行澳门分行·银联澳门币卡\", \"中国银行马尼拉分行·双币种借记卡\", \"中国银行胡志明分行·借记卡\", \"中国银行曼谷分行·借记卡\", \"中国银行曼谷分行·长城信用卡环球通\", \"中国银行曼谷分行·借记卡\", \"建设银行·龙卡准贷记卡\", \"建设银行·龙卡准贷记卡金卡\", \"建设银行·中职学生资助卡\", \"建设银行·乐当家银卡VISA\", \"建设银行·乐当家金卡VISA\", \"建设银行·乐当家白金卡\", \"建设银行·龙卡普通卡VISA\", \"建设银行·龙卡储蓄卡\", \"建设银行·VISA准贷记卡(银联卡)\", \"建设银行·VISA准贷记金卡\", \"建设银行·乐当家\", \"建设银行·乐当家\", \"建设银行·准贷记金卡\", \"建设银行·乐当家白金卡\", \"建设银行·金融复合IC卡\", \"建设银行·银联标准卡\", \"建设银行·银联理财钻石卡\", \"建设银行·金融IC卡\", \"建设银行·理财白金卡\", \"建设银行·社保IC卡\", \"建设银行·财富卡私人银行卡\", \"建设银行·理财金卡\", \"建设银行·福农卡\", \"建设银行·武警军人保障卡\", \"建设银行·龙卡通\", \"建设银行·银联储蓄卡\", \"建设银行·龙卡储蓄卡(银联卡)\", \"建设银行·准贷记卡\", \"建设银行·理财白金卡\", \"建设银行·理财金卡\", \"建设银行·准贷记卡普卡\", \"建设银行·准贷记卡金卡\", \"建设银行·龙卡信用卡\", \"建设银行·建行陆港通龙卡\", \"中国建设银行·普通高中学生资助卡\", \"中国建设银行·中国旅游卡\", \"中国建设银行·龙卡JCB金卡\", \"中国建设银行·龙卡JCB白金卡\", \"中国建设银行·龙卡JCB普卡\", \"中国建设银行·龙卡贷记卡公司卡\", \"中国建设银行·龙卡贷记卡\", \"中国建设银行·龙卡国际普通卡VISA\", \"中国建设银行·龙卡国际金卡VISA\", \"中国建设银行·VISA白金信用卡\", \"中国建设银行·龙卡国际白金卡\", \"中国建设银行·龙卡国际普通卡MASTER\", \"中国建设银行·龙卡国际金卡MASTER\", \"中国建设银行·龙卡万事达金卡\", \"中国建设银行·龙卡贷记卡\", \"中国建设银行·龙卡万事达白金卡\", \"中国建设银行·龙卡贷记卡\", \"中国建设银行·龙卡万事达信用卡\", \"中国建设银行·龙卡人民币信用卡\", \"中国建设银行·龙卡人民币信用金卡\", \"中国建设银行·龙卡人民币白金卡\", \"中国建设银行·龙卡IC信用卡普卡\", \"中国建设银行·龙卡IC信用卡金卡\", \"中国建设银行·龙卡IC信用卡白金卡\", \"中国建设银行·龙卡银联公务卡普卡\", \"中国建设银行·龙卡银联公务卡金卡\", \"中国建设银行·中国旅游卡\", \"中国建设银行·中国旅游卡\", \"中国建设银行·龙卡IC公务卡\", \"中国建设银行·龙卡IC公务卡\", \"交通银行·交行预付卡\", \"交通银行·世博预付IC卡\", \"交通银行·太平洋互连卡\", \"交通银行·太平洋万事顺卡\", \"交通银行·太平洋互连卡(银联卡)\", \"交通银行·太平洋白金信用卡\", \"交通银行·太平洋双币贷记卡\", \"交通银行·太平洋双币贷记卡\", \"交通银行·太平洋双币贷记卡\", \"交通银行·太平洋白金信用卡\", \"交通银行·太平洋双币贷记卡\", \"交通银行·太平洋万事顺卡\", \"交通银行·太平洋人民币贷记卡\", \"交通银行·太平洋人民币贷记卡\", \"交通银行·太平洋双币贷记卡\", \"交通银行·太平洋准贷记卡\", \"交通银行·太平洋准贷记卡\", \"交通银行·太平洋准贷记卡\", \"交通银行·太平洋准贷记卡\", \"交通银行·太平洋借记卡\", \"交通银行·太平洋借记卡\", \"交通银行·太平洋人民币贷记卡\", \"交通银行·太平洋借记卡\", \"交通银行·太平洋MORE卡\", \"交通银行·白金卡\", \"交通银行·交通银行公务卡普卡\", \"交通银行·太平洋人民币贷记卡\", \"交通银行·太平洋互连卡\", \"交通银行·太平洋借记卡\", \"交通银行·太平洋万事顺卡\", \"交通银行·太平洋贷记卡(银联卡)\", \"交通银行·太平洋贷记卡(银联卡)\", \"交通银行·太平洋贷记卡(银联卡)\", \"交通银行·太平洋贷记卡(银联卡)\", \"交通银行·交通银行公务卡金卡\", \"交通银行·交银IC卡\", \"交通银行香港分行·交通银行港币借记卡\", \"交通银行香港分行·港币礼物卡\", \"交通银行香港分行·双币种信用卡\", \"交通银行香港分行·双币种信用卡\", \"交通银行香港分行·双币卡\", \"交通银行香港分行·银联人民币卡\", \"交通银行澳门分行·银联借记卡\", \"中信银行·中信借记卡\", \"中信银行·中信借记卡\", \"中信银行·中信国际借记卡\", \"中信银行·中信国际借记卡\", \"中信银行·中国旅行卡\", \"中信银行·中信借记卡(银联卡)\", \"中信银行·中信借记卡(银联卡)\", \"中信银行·中信贵宾卡(银联卡)\", \"中信银行·中信理财宝金卡\", \"中信银行·中信理财宝白金卡\", \"中信银行·中信钻石卡\", \"中信银行·中信钻石卡\", \"中信银行·中信借记卡\", \"中信银行·中信理财宝(银联卡)\", \"中信银行·中信理财宝(银联卡)\", \"中信银行·中信理财宝(银联卡)\", \"中信银行·借记卡\", \"中信银行·理财宝IC卡\", \"中信银行·理财宝IC卡\", \"中信银行·理财宝IC卡\", \"中信银行·理财宝IC卡\", \"中信银行·理财宝IC卡\", \"中信银行·主账户复合电子现金卡\", \"光大银行·阳光商旅信用卡\", \"光大银行·阳光商旅信用卡\", \"光大银行·阳光商旅信用卡\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·阳光卡(银联卡)\", \"光大银行·借记卡普卡\", \"光大银行·社会保障IC卡\", \"光大银行·IC借记卡普卡\", \"光大银行·手机支付卡\", \"光大银行·联名IC卡普卡\", \"光大银行·借记IC卡白金卡\", \"光大银行·借记IC卡金卡\", \"光大银行·阳光旅行卡\", \"光大银行·借记IC卡钻石卡\", \"光大银行·联名IC卡金卡\", \"光大银行·联名IC卡白金卡\", \"光大银行·联名IC卡钻石卡\", \"华夏银行·华夏卡(银联卡)\", \"华夏银行·华夏白金卡\", \"华夏银行·华夏普卡\", \"华夏银行·华夏金卡\", \"华夏银行·华夏白金卡\", \"华夏银行·华夏钻石卡\", \"华夏银行·华夏卡(银联卡)\", \"华夏银行·华夏至尊金卡(银联卡)\", \"华夏银行·华夏丽人卡(银联卡)\", \"华夏银行·华夏万通卡\", \"民生银行·民生借记卡(银联卡)\", \"民生银行·民生银联借记卡－金卡\", \"民生银行·钻石卡\", \"民生银行·民生借记卡(银联卡)\", \"民生银行·民生借记卡(银联卡)\", \"民生银行·民生借记卡(银联卡)\", \"民生银行·民生借记卡\", \"民生银行·民生国际卡\", \"民生银行·民生国际卡(银卡)\", \"民生银行·民生国际卡(欧元卡)\", \"民生银行·民生国际卡(澳元卡)\", \"民生银行·民生国际卡\", \"民生银行·民生国际卡\", \"民生银行·薪资理财卡\", \"民生银行·借记卡普卡\", \"民生银行·民生MasterCard\", \"民生银行·民生MasterCard\", \"民生银行·民生MasterCard\", \"民生银行·民生MasterCard\", \"民生银行·民生JCB信用卡\", \"民生银行·民生JCB金卡\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生JCB普卡\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生信用卡(银联卡)\", \"民生银行·民生信用卡(银联卡)\", \"民生银行·民生银联白金信用卡\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生银联个人白金卡\", \"民生银行·公务卡金卡\", \"民生银行·民生贷记卡(银联卡)\", \"民生银行·民生银联商务信用卡\", \"民生银行·民VISA无限卡\", \"民生银行·民生VISA商务白金卡\", \"民生银行·民生万事达钛金卡\", \"民生银行·民生万事达世界卡\", \"民生银行·民生万事达白金公务卡\", \"民生银行·民生JCB白金卡\", \"民生银行·银联标准金卡\", \"民生银行·银联芯片普卡\", \"民生银行·民生运通双币信用卡普卡\", \"民生银行·民生运通双币信用卡金卡\", \"民生银行·民生运通双币信用卡钻石卡\", \"民生银行·民生运通双币标准信用卡白金卡\", \"民生银行·银联芯片金卡\", \"民生银行·银联芯片白金卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·两地一卡通\", \"招商银行·招行国际卡(银联卡)\", \"招商银行·招商银行信用卡\", \"招商银行·VISA商务信用卡\", \"招商银行·招行国际卡(银联卡)\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招行国际卡(银联卡)\", \"招商银行·世纪金花联名信用卡\", \"招商银行·招行国际卡(银联卡)\", \"招商银行·招商银行信用卡\", \"招商银行·万事达信用卡\", \"招商银行·万事达信用卡\", \"招商银行·万事达信用卡\", \"招商银行·万事达信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·一卡通(银联卡)\", \"招商银行·万事达信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·招商银行信用卡\", \"招商银行·一卡通(银联卡)\", \"招商银行·公司卡(银联卡)\", \"招商银行·金卡\", \"招商银行·招行一卡通\", \"招商银行·招行一卡通\", \"招商银行·万事达信用卡\", \"招商银行·金葵花卡\", \"招商银行·电子现金卡\", \"招商银行·银联IC普卡\", \"招商银行·银联IC金卡\", \"招商银行·银联金葵花IC卡\", \"招商银行·IC公务卡\", \"招商银行·招商银行信用卡\", \"招商银行信用卡中心·美国运通绿卡\", \"招商银行信用卡中心·美国运通金卡\", \"招商银行信用卡中心·美国运通商务绿卡\", \"招商银行信用卡中心·美国运通商务金卡\", \"招商银行信用卡中心·VISA信用卡\", \"招商银行信用卡中心·MASTER信用卡\", \"招商银行信用卡中心·MASTER信用金卡\", \"招商银行信用卡中心·银联标准公务卡(金卡)\", \"招商银行信用卡中心·VISA信用卡\", \"招商银行信用卡中心·银联标准财政公务卡\", \"招商银行信用卡中心·芯片IC信用卡\", \"招商银行信用卡中心·芯片IC信用卡\", \"招商银行香港分行·香港一卡通\", \"兴业银行·兴业卡(银联卡)\", \"兴业银行·兴业卡(银联标准卡)\", \"兴业银行·兴业自然人生理财卡\", \"兴业银行·兴业智能卡(银联卡)\", \"兴业银行·兴业智能卡\", \"兴业银行·visa标准双币个人普卡\", \"兴业银行·VISA商务普卡\", \"兴业银行·VISA商务金卡\", \"兴业银行·VISA运动白金信用卡\", \"兴业银行·万事达信用卡(银联卡)\", \"兴业银行·VISA信用卡(银联卡)\", \"兴业银行·加菲猫信用卡\", \"兴业银行·个人白金卡\", \"兴业银行·银联信用卡(银联卡)\", \"兴业银行·银联信用卡(银联卡)\", \"兴业银行·银联白金信用卡\", \"兴业银行·银联标准公务卡\", \"兴业银行·VISA信用卡(银联卡)\", \"兴业银行·万事达信用卡(银联卡)\", \"兴业银行·银联标准贷记普卡\", \"兴业银行·银联标准贷记金卡\", \"兴业银行·银联标准贷记金卡\", \"兴业银行·银联标准贷记金卡\", \"兴业银行·兴业信用卡\", \"兴业银行·兴业信用卡\", \"兴业银行·兴业信用卡\", \"兴业银行·银联标准贷记普卡\", \"兴业银行·银联标准贷记普卡\", \"兴业银行·兴业芯片普卡\", \"兴业银行·兴业芯片金卡\", \"兴业银行·兴业芯片白金卡\", \"兴业银行·兴业芯片钻石卡\", \"浦东发展银行·浦发JCB金卡\", \"浦东发展银行·浦发JCB白金卡\", \"浦东发展银行·信用卡VISA普通\", \"浦东发展银行·信用卡VISA金卡\", \"浦东发展银行·浦发银行VISA年青卡\", \"浦东发展银行·VISA白金信用卡\", \"浦东发展银行·浦发万事达白金卡\", \"浦东发展银行·浦发JCB普卡\", \"浦东发展银行·浦发万事达金卡\", \"浦东发展银行·浦发万事达普卡\", \"浦东发展银行·浦发单币卡\", \"浦东发展银行·浦发银联单币麦兜普卡\", \"浦东发展银行·东方轻松理财卡\", \"浦东发展银行·东方-轻松理财卡普卡\", \"浦东发展银行·东方轻松理财卡\", \"浦东发展银行·东方轻松理财智业金卡\", \"浦东发展银行·东方卡(银联卡)\", \"浦东发展银行·东方卡(银联卡)\", \"浦东发展银行·东方卡(银联卡)\", \"浦东发展银行·公务卡金卡\", \"浦东发展银行·公务卡普卡\", \"浦东发展银行·东方卡\", \"浦东发展银行·东方卡\", \"浦东发展银行·浦发单币卡\", \"浦东发展银行·浦发联名信用卡\", \"浦东发展银行·浦发银联白金卡\", \"浦东发展银行·轻松理财普卡\", \"浦东发展银行·移动联名卡\", \"浦东发展银行·轻松理财消贷易卡\", \"浦东发展银行·轻松理财普卡（复合卡）\", \"浦东发展银行·贷记卡\", \"浦东发展银行·贷记卡\", \"浦东发展银行·东方借记卡（复合卡）\", \"浦东发展银行·电子现金卡（IC卡）\", \"浦东发展银行·移动浦发联名卡\", \"浦东发展银行·东方-标准准贷记卡\", \"浦东发展银行·轻松理财金卡（复合卡）\", \"浦东发展银行·轻松理财白金卡（复合卡）\", \"浦东发展银行·轻松理财钻石卡（复合卡）\", \"浦东发展银行·东方卡\", \"恒丰银行·九州IC卡\", \"恒丰银行·九州借记卡(银联卡)\", \"恒丰银行·九州借记卡(银联卡)\", \"天津市商业银行·银联卡(银联卡)\", \"烟台商业银行·金通卡\", \"潍坊银行·鸢都卡(银联卡)\", \"潍坊银行·鸳都卡(银联卡)\", \"临沂商业银行·沂蒙卡(银联卡)\", \"临沂商业银行·沂蒙卡(银联卡)\", \"日照市商业银行·黄海卡\", \"日照市商业银行·黄海卡(银联卡)\", \"浙商银行·商卡\", \"浙商银行·商卡\", \"渤海银行·浩瀚金卡\", \"渤海银行·渤海银行借记卡\", \"渤海银行·金融IC卡\", \"渤海银行·渤海银行公司借记卡\", \"星展银行·星展银行借记卡\", \"星展银行·星展银行借记卡\", \"恒生银行·恒生通财卡\", \"恒生银行·恒生优越通财卡\", \"新韩银行·新韩卡\", \"上海银行·慧通钻石卡\", \"上海银行·慧通金卡\", \"上海银行·私人银行卡\", \"上海银行·综合保险卡\", \"上海银行·申卡社保副卡(有折)\", \"上海银行·申卡社保副卡(无折)\", \"上海银行·白金IC借记卡\", \"上海银行·慧通白金卡(配折)\", \"上海银行·慧通白金卡(不配折)\", \"上海银行·申卡(银联卡)\", \"上海银行·申卡借记卡\", \"上海银行·银联申卡(银联卡)\", \"上海银行·单位借记卡\", \"上海银行·首发纪念版IC卡\", \"上海银行·申卡贷记卡\", \"上海银行·申卡贷记卡\", \"上海银行·J分期付款信用卡\", \"上海银行·申卡贷记卡\", \"上海银行·申卡贷记卡\", \"上海银行·上海申卡IC\", \"上海银行·申卡贷记卡\", \"上海银行·申卡贷记卡普通卡\", \"上海银行·申卡贷记卡金卡\", \"上海银行·万事达白金卡\", \"上海银行·万事达星运卡\", \"上海银行·申卡贷记卡金卡\", \"上海银行·申卡贷记卡普通卡\", \"上海银行·安融卡\", \"上海银行·分期付款信用卡\", \"上海银行·信用卡\", \"上海银行·个人公务卡\", \"上海银行·安融卡\", \"上海银行·上海银行银联白金卡\", \"上海银行·贷记IC卡\", \"上海银行·中国旅游卡（IC普卡）\", \"上海银行·中国旅游卡（IC金卡）\", \"上海银行·中国旅游卡（IC白金卡）\", \"上海银行·万事达钻石卡\", \"上海银行·淘宝IC普卡\", \"北京银行·京卡借记卡\", \"北京银行·京卡(银联卡)\", \"北京银行·京卡借记卡\", \"北京银行·京卡\", \"北京银行·京卡\", \"北京银行·借记IC卡\", \"北京银行·京卡贵宾金卡\", \"北京银行·京卡贵宾白金卡\", \"吉林银行·君子兰一卡通(银联卡)\", \"吉林银行·君子兰卡(银联卡)\", \"吉林银行·长白山金融IC卡\", \"吉林银行·信用卡\", \"吉林银行·信用卡\", \"吉林银行·公务卡\", \"镇江市商业银行·金山灵通卡(银联卡)\", \"镇江市商业银行·金山灵通卡(银联卡)\", \"宁波银行·银联标准卡\", \"宁波银行·汇通借记卡\", \"宁波银行·汇通卡(银联卡)\", \"宁波银行·明州卡\", \"宁波银行·汇通借记卡\", \"宁波银行·汇通国际卡银联双币卡\", \"宁波银行·汇通国际卡银联双币卡\", \"平安银行·新磁条借记卡\", \"平安银行·平安银行IC借记卡\", \"平安银行·万事顺卡\", \"平安银行·平安银行借记卡\", \"平安银行·平安银行借记卡\", \"平安银行·万事顺借记卡\", \"焦作市商业银行·月季借记卡(银联卡)\", \"焦作市商业银行·月季城市通(银联卡)\", \"焦作市商业银行·中国旅游卡\", \"温州银行·金鹿卡\", \"汉口银行·九通卡(银联卡)\", \"汉口银行·九通卡\", \"汉口银行·借记卡\", \"汉口银行·借记卡\", \"盛京银行·玫瑰卡\", \"盛京银行·玫瑰IC卡\", \"盛京银行·玫瑰IC卡\", \"盛京银行·玫瑰卡\", \"盛京银行·玫瑰卡\", \"盛京银行·玫瑰卡(银联卡)\", \"盛京银行·玫瑰卡(银联卡)\", \"盛京银行·盛京银行公务卡\", \"洛阳银行·都市一卡通(银联卡)\", \"洛阳银行·都市一卡通(银联卡)\", \"洛阳银行·--\", \"大连银行·北方明珠卡\", \"大连银行·人民币借记卡\", \"大连银行·金融IC借记卡\", \"大连银行·大连市社会保障卡\", \"大连银行·借记IC卡\", \"大连银行·借记IC卡\", \"大连银行·大连市商业银行贷记卡\", \"大连银行·大连市商业银行贷记卡\", \"大连银行·银联标准公务卡\", \"苏州市商业银行·姑苏卡\", \"杭州商业银行·西湖卡\", \"杭州商业银行·西湖卡\", \"杭州商业银行·借记IC卡\", \"杭州商业银行·\", \"南京银行·梅花信用卡公务卡\", \"南京银行·梅花信用卡商务卡\", \"南京银行·梅花贷记卡(银联卡)\", \"南京银行·梅花借记卡(银联卡)\", \"南京银行·白金卡\", \"南京银行·商务卡\", \"东莞市商业银行·万顺通卡(银联卡)\", \"东莞市商业银行·万顺通卡(银联卡)\", \"东莞市商业银行·万顺通借记卡\", \"东莞市商业银行·社会保障卡\", \"乌鲁木齐市商业银行·雪莲借记IC卡\", \"乌鲁木齐市商业银行·乌鲁木齐市公务卡\", \"乌鲁木齐市商业银行·福农卡贷记卡\", \"乌鲁木齐市商业银行·福农卡准贷记卡\", \"乌鲁木齐市商业银行·雪莲准贷记卡\", \"乌鲁木齐市商业银行·雪莲贷记卡(银联卡)\", \"乌鲁木齐市商业银行·雪莲借记IC卡\", \"乌鲁木齐市商业银行·雪莲借记卡(银联卡)\", \"乌鲁木齐市商业银行·雪莲卡(银联卡)\", \"绍兴银行·兰花IC借记卡\", \"绍兴银行·社保IC借记卡\", \"绍兴银行·兰花公务卡\", \"成都商业银行·芙蓉锦程福农卡\", \"成都商业银行·芙蓉锦程天府通卡\", \"成都商业银行·锦程卡(银联卡)\", \"成都商业银行·锦程卡金卡\", \"成都商业银行·锦程卡定活一卡通金卡\", \"成都商业银行·锦程卡定活一卡通\", \"成都商业银行·锦程力诚联名卡\", \"成都商业银行·锦程力诚联名卡\", \"成都商业银行·锦程卡(银联卡)\", \"抚顺银行·借记IC卡\", \"临商银行·借记卡\", \"宜昌市商业银行·三峡卡(银联卡)\", \"宜昌市商业银行·信用卡(银联卡)\", \"葫芦岛市商业银行·一通卡\", \"葫芦岛市商业银行·一卡通(银联卡)\", \"天津市商业银行·津卡\", \"天津市商业银行·津卡贷记卡(银联卡)\", \"天津市商业银行·贷记IC卡\", \"天津市商业银行·--\", \"天津银行·商务卡\", \"宁夏银行·宁夏银行公务卡\", \"宁夏银行·宁夏银行福农贷记卡\", \"宁夏银行·如意卡(银联卡)\", \"宁夏银行·宁夏银行福农借记卡\", \"宁夏银行·如意借记卡\", \"宁夏银行·如意IC卡\", \"宁夏银行·宁夏银行如意借记卡\", \"宁夏银行·中国旅游卡\", \"齐商银行·金达卡(银联卡)\", \"齐商银行·金达借记卡(银联卡)\", \"齐商银行·金达IC卡\", \"徽商银行·黄山卡\", \"徽商银行·黄山卡\", \"徽商银行·借记卡\", \"徽商银行·徽商银行中国旅游卡（安徽）\", \"徽商银行合肥分行·黄山卡\", \"徽商银行芜湖分行·黄山卡(银联卡)\", \"徽商银行马鞍山分行·黄山卡(银联卡)\", \"徽商银行淮北分行·黄山卡(银联卡)\", \"徽商银行安庆分行·黄山卡(银联卡)\", \"重庆银行·长江卡(银联卡)\", \"重庆银行·长江卡(银联卡)\", \"重庆银行·长江卡\", \"重庆银行·借记IC卡\", \"哈尔滨银行·丁香一卡通(银联卡)\", \"哈尔滨银行·丁香借记卡(银联卡)\", \"哈尔滨银行·丁香卡\", \"哈尔滨银行·福农借记卡\", \"无锡市商业银行·太湖金保卡(银联卡)\", \"丹东银行·借记IC卡\", \"丹东银行·丹东银行公务卡\", \"兰州银行·敦煌卡\", \"南昌银行·金瑞卡(银联卡)\", \"南昌银行·南昌银行借记卡\", \"南昌银行·金瑞卡\", \"晋商银行·晋龙一卡通\", \"晋商银行·晋龙一卡通\", \"晋商银行·晋龙卡(银联卡)\", \"青岛银行·金桥通卡\", \"青岛银行·金桥卡(银联卡)\", \"青岛银行·金桥卡(银联卡)\", \"青岛银行·金桥卡\", \"青岛银行·借记IC卡\", \"吉林银行·雾凇卡(银联卡)\", \"吉林银行·雾凇卡(银联卡)\", \"南通商业银行·金桥卡(银联卡)\", \"南通商业银行·金桥卡(银联卡)\", \"日照银行·黄海卡、财富卡借记卡\", \"鞍山银行·千山卡(银联卡)\", \"鞍山银行·千山卡(银联卡)\", \"鞍山银行·千山卡\", \"青海银行·三江银行卡(银联卡)\", \"青海银行·三江卡\", \"台州银行·大唐贷记卡\", \"台州银行·大唐准贷记卡\", \"台州银行·大唐卡(银联卡)\", \"台州银行·大唐卡\", \"台州银行·借记卡\", \"台州银行·公务卡\", \"泉州银行·海峡银联卡(银联卡)\", \"泉州银行·海峡储蓄卡\", \"泉州银行·海峡银联卡(银联卡)\", \"泉州银行·海峡卡\", \"泉州银行·公务卡\", \"昆明商业银行·春城卡(银联卡)\", \"昆明商业银行·春城卡(银联卡)\", \"昆明商业银行·富滇IC卡（复合卡）\", \"阜新银行·借记IC卡\", \"嘉兴银行·南湖借记卡(银联卡)\", \"廊坊银行·白金卡\", \"廊坊银行·金卡\", \"廊坊银行·银星卡(银联卡)\", \"廊坊银行·龙凤呈祥卡\", \"内蒙古银行·百灵卡(银联卡)\", \"内蒙古银行·成吉思汗卡\", \"湖州市商业银行·百合卡\", \"湖州市商业银行·\", \"沧州银行·狮城卡\", \"南宁市商业银行·桂花卡(银联卡)\", \"包商银行·雄鹰卡(银联卡)\", \"包商银行·包头市商业银行借记卡\", \"包商银行·雄鹰贷记卡\", \"包商银行·包商银行内蒙古自治区公务卡\", \"包商银行·贷记卡\", \"包商银行·借记卡\", \"连云港市商业银行·金猴神通借记卡\", \"威海商业银行·通达卡(银联卡)\", \"威海市商业银行·通达借记IC卡\", \"攀枝花市商业银行·攀枝花卡(银联卡)\", \"攀枝花市商业银行·攀枝花卡\", \"绵阳市商业银行·科技城卡(银联卡)\", \"泸州市商业银行·酒城卡(银联卡)\", \"泸州市商业银行·酒城IC卡\", \"大同市商业银行·云冈卡(银联卡)\", \"三门峡银行·天鹅卡(银联卡)\", \"广东南粤银行·南珠卡(银联卡)\", \"张家口市商业银行·好运IC借记卡\", \"桂林市商业银行·漓江卡(银联卡)\", \"龙江银行·福农借记卡\", \"龙江银行·联名借记卡\", \"龙江银行·福农借记卡\", \"龙江银行·龙江IC卡\", \"龙江银行·社会保障卡\", \"龙江银行·--\", \"江苏长江商业银行·长江卡\", \"徐州市商业银行·彭城借记卡(银联卡)\", \"南充市商业银行·借记IC卡\", \"南充市商业银行·熊猫团团卡\", \"莱商银行·银联标准卡\", \"莱芜银行·金凤卡\", \"莱商银行·借记IC卡\", \"德阳银行·锦程卡定活一卡通\", \"德阳银行·锦程卡定活一卡通金卡\", \"德阳银行·锦程卡定活一卡通\", \"唐山市商业银行·唐山市城通卡\", \"曲靖市商业银行·珠江源卡\", \"曲靖市商业银行·珠江源IC卡\", \"温州银行·金鹿信用卡\", \"温州银行·金鹿信用卡\", \"温州银行·金鹿公务卡\", \"温州银行·贷记IC卡\", \"汉口银行·汉口银行贷记卡\", \"汉口银行·汉口银行贷记卡\", \"汉口银行·九通香港旅游贷记普卡\", \"汉口银行·九通香港旅游贷记金卡\", \"汉口银行·贷记卡\", \"汉口银行·九通公务卡\", \"江苏银行·聚宝借记卡\", \"江苏银行·月季卡\", \"江苏银行·紫金卡\", \"江苏银行·绿扬卡(银联卡)\", \"江苏银行·月季卡(银联卡)\", \"江苏银行·九州借记卡(银联卡)\", \"江苏银行·月季卡(银联卡)\", \"江苏银行·聚宝惠民福农卡\", \"江苏银行·江苏银行聚宝IC借记卡\", \"江苏银行·聚宝IC借记卡VIP卡\", \"长治市商业银行·长治商行银联晋龙卡\", \"承德市商业银行·热河卡\", \"承德银行·借记IC卡\", \"德州银行·长河借记卡\", \"德州银行·--\", \"遵义市商业银行·社保卡\", \"遵义市商业银行·尊卡\", \"邯郸市商业银行·邯银卡\", \"邯郸市商业银行·邯郸银行贵宾IC借记卡\", \"安顺市商业银行·黄果树福农卡\", \"安顺市商业银行·黄果树借记卡\", \"江苏银行·紫金信用卡(公务卡)\", \"江苏银行·紫金信用卡\", \"江苏银行·天翼联名信用卡\", \"平凉市商业银行·广成卡\", \"玉溪市商业银行·红塔卡\", \"玉溪市商业银行·红塔卡\", \"浙江民泰商业银行·金融IC卡\", \"浙江民泰商业银行·民泰借记卡\", \"浙江民泰商业银行·金融IC卡C卡\", \"浙江民泰商业银行·银联标准普卡金卡\", \"浙江民泰商业银行·商惠通\", \"上饶市商业银行·三清山卡\", \"东营银行·胜利卡\", \"泰安市商业银行·岱宗卡\", \"泰安市商业银行·市民一卡通\", \"浙江稠州商业银行·义卡\", \"浙江稠州商业银行·义卡借记IC卡\", \"浙江稠州商业银行·公务卡\", \"自贡市商业银行·借记IC卡\", \"自贡市商业银行·锦程卡\", \"鄂尔多斯银行·天骄公务卡\", \"鹤壁银行·鹤卡\", \"许昌银行·连城卡\", \"铁岭银行·龙凤卡\", \"乐山市商业银行·大福卡\", \"乐山市商业银行·--\", \"长安银行·长长卡\", \"长安银行·借记IC卡\", \"重庆三峡银行·财富人生卡\", \"重庆三峡银行·借记卡\", \"石嘴山银行·麒麟借记卡\", \"石嘴山银行·麒麟借记卡\", \"石嘴山银行·麒麟公务卡\", \"盘锦市商业银行·鹤卡\", \"盘锦市商业银行·盘锦市商业银行鹤卡\", \"平顶山银行·平顶山银行公务卡\", \"朝阳银行·鑫鑫通卡\", \"朝阳银行·朝阳银行福农卡\", \"朝阳银行·红山卡\", \"宁波东海银行·绿叶卡\", \"遂宁市商业银行·锦程卡\", \"遂宁是商业银行·金荷卡\", \"保定银行·直隶卡\", \"保定银行·直隶卡\", \"凉山州商业银行·锦程卡\", \"凉山州商业银行·金凉山卡\", \"漯河银行·福卡\", \"漯河银行·福源卡\", \"漯河银行·福源公务卡\", \"达州市商业银行·锦程卡\", \"新乡市商业银行·新卡\", \"晋中银行·九州方圆借记卡\", \"晋中银行·九州方圆卡\", \"驻马店银行·驿站卡\", \"驻马店银行·驿站卡\", \"驻马店银行·公务卡\", \"衡水银行·金鼎卡\", \"衡水银行·借记IC卡\", \"周口银行·如愿卡\", \"周口银行·公务卡\", \"阳泉市商业银行·金鼎卡\", \"阳泉市商业银行·金鼎卡\", \"宜宾市商业银行·锦程卡\", \"宜宾市商业银行·借记IC卡\", \"库尔勒市商业银行·孔雀胡杨卡\", \"雅安市商业银行·锦城卡\", \"雅安市商业银行·--\", \"安阳银行·安鼎卡\", \"信阳银行·信阳卡\", \"信阳银行·公务卡\", \"信阳银行·信阳卡\", \"华融湘江银行·华融卡\", \"华融湘江银行·华融卡\", \"营口沿海银行·祥云借记卡\", \"景德镇商业银行·瓷都卡\", \"哈密市商业银行·瓜香借记卡\", \"湖北银行·金牛卡\", \"湖北银行·汉江卡\", \"湖北银行·借记卡\", \"湖北银行·三峡卡\", \"湖北银行·至尊卡\", \"湖北银行·金融IC卡\", \"西藏银行·借记IC卡\", \"新疆汇和银行·汇和卡\", \"广东华兴银行·借记卡\", \"广东华兴银行·华兴银联公司卡\", \"广东华兴银行·华兴联名IC卡\", \"广东华兴银行·华兴金融IC借记卡\", \"濮阳银行·龙翔卡\", \"宁波通商银行·借记卡\", \"甘肃银行·神舟兴陇借记卡\", \"甘肃银行·甘肃银行神州兴陇IC卡\", \"枣庄银行·借记IC卡\", \"本溪市商业银行·借记卡\", \"盛京银行·医保卡\", \"上海农商银行·如意卡(银联卡)\", \"上海农商银行·如意卡(银联卡)\", \"上海农商银行·鑫通卡\", \"上海农商银行·国际如意卡\", \"上海农商银行·借记IC卡\", \"常熟市农村商业银行·粒金贷记卡(银联卡)\", \"常熟市农村商业银行·公务卡\", \"常熟市农村商业银行·粒金准贷卡\", \"常熟农村商业银行·粒金借记卡(银联卡)\", \"常熟农村商业银行·粒金IC卡\", \"常熟农村商业银行·粒金卡\", \"深圳农村商业银行·信通卡(银联卡)\", \"深圳农村商业银行·信通商务卡(银联卡)\", \"深圳农村商业银行·信通卡\", \"深圳农村商业银行·信通商务卡\", \"广州农村商业银行·福农太阳卡\", \"广东南海农村商业银行·盛通卡\", \"广东南海农村商业银行·盛通卡(银联卡)\", \"佛山顺德农村商业银行·恒通卡(银联卡)\", \"佛山顺德农村商业银行·恒通卡\", \"佛山顺德农村商业银行·恒通卡(银联卡)\", \"江阴农村商业银行·暨阳公务卡\", \"江阴市农村商业银行·合作贷记卡(银联卡)\", \"江阴农村商业银行·合作借记卡\", \"江阴农村商业银行·合作卡(银联卡)\", \"江阴农村商业银行·暨阳卡\", \"重庆农村商业银行·江渝借记卡VIP卡\", \"重庆农村商业银行·江渝IC借记卡\", \"重庆农村商业银行·江渝乡情福农卡\", \"东莞农村商业银行·信通卡(银联卡)\", \"东莞农村商业银行·信通卡(银联卡)\", \"东莞农村商业银行·信通信用卡\", \"东莞农村商业银行·信通借记卡\", \"东莞农村商业银行·贷记IC卡\", \"张家港农村商业银行·一卡通(银联卡)\", \"张家港农村商业银行·一卡通(银联卡)\", \"张家港农村商业银行·\", \"北京农村商业银行·信通卡\", \"北京农村商业银行·惠通卡\", \"北京农村商业银行·凤凰福农卡\", \"北京农村商业银行·惠通卡\", \"北京农村商业银行·中国旅行卡\", \"北京农村商业银行·凤凰卡\", \"天津农村商业银行·吉祥商联IC卡\", \"天津农村商业银行·信通借记卡(银联卡)\", \"天津农村商业银行·借记IC卡\", \"鄞州农村合作银行·蜜蜂借记卡(银联卡)\", \"宁波鄞州农村合作银行·蜜蜂电子钱包(IC)\", \"宁波鄞州农村合作银行·蜜蜂IC借记卡\", \"宁波鄞州农村合作银行·蜜蜂贷记IC卡\", \"宁波鄞州农村合作银行·蜜蜂贷记卡\", \"宁波鄞州农村合作银行·公务卡\", \"成都农村商业银行·福农卡\", \"成都农村商业银行·福农卡\", \"珠海农村商业银行·信通卡(银联卡)\", \"太仓农村商业银行·郑和卡(银联卡)\", \"太仓农村商业银行·郑和IC借记卡\", \"无锡农村商业银行·金阿福\", \"无锡农村商业银行·借记IC卡\", \"黄河农村商业银行·黄河卡\", \"黄河农村商业银行·黄河富农卡福农卡\", \"黄河农村商业银行·借记IC卡\", \"天津滨海农村商业银行·四海通卡\", \"天津滨海农村商业银行·四海通e芯卡\", \"武汉农村商业银行·汉卡\", \"武汉农村商业银行·汉卡\", \"武汉农村商业银行·中国旅游卡\", \"江南农村商业银行·阳湖卡(银联卡)\", \"江南农村商业银行·天天红火卡\", \"江南农村商业银行·借记IC卡\", \"海口联合农村商业银行·海口联合农村商业银行合卡\", \"湖北嘉鱼吴江村镇银行·垂虹卡\", \"福建建瓯石狮村镇银行·玉竹卡\", \"浙江平湖工银村镇银行·金平卡\", \"重庆璧山工银村镇银行·翡翠卡\", \"重庆农村商业银行·银联标准贷记卡\", \"重庆农村商业银行·公务卡\", \"南阳村镇银行·玉都卡\", \"晋中市榆次融信村镇银行·魏榆卡\", \"三水珠江村镇银行·珠江太阳卡\", \"东营莱商村镇银行·绿洲卡\", \"建设银行·单位结算卡\", \"玉溪市商业银行·红塔卡\" ,\"平安银行\",\"平安银行\",\"平安银行\",\"平安银行\",\"深圳发展银行\",\"深圳发展银行\",\"深圳发展银行\",\"深圳发展银行\",\"深圳发展银行\",\"深圳发展银行\",\"深圳发展银行\",\"深圳发展银行\",\"深圳发展银行\",\"深圳发展银行\" ); /** * 获取银行卡名称 * @param $cardNumber * @return mixed|null */ public function getBankName($cardNumber) &#123; $charBin = substr($cardNumber, 0, 6); $bin = 0; $index = 0; $index = array_search($charBin, self::$bankBin); if ($index == -1 || $index &gt; count(self::$bankName)) &#123; return null; &#125; return self::$bankName[$index]; &#125; /** * 校验银行卡卡号 * @param $cardId * @return bool */ public function checkBankCard($cardId) &#123; $bit = getBankCardCheckCode($cardId.substring(0, count($cardId) - 1)); if ($bit == 'N') &#123; return false; &#125; return $cardId[count($cardId) - 1] == $bit; &#125; /** * 从不含校验位的银行卡卡号采用 Luhn 校验算法获得校验位 * @param $nonCheckCodeCardId * @return int|string */ public function getBankCardCheckCode($nonCheckCodeCardId) &#123; if ($nonCheckCodeCardId == null || count(trim($nonCheckCodeCardId)) == 0 || !preg_match(\"\\\\d+\", $nonCheckCodeCardId) ) &#123; return 'N'; &#125; $chs = trim($nonCheckCodeCardId).toCharArray(); $LuhnSum = 0; for ($i = count($chs) - 1, $j = 0; $i &gt;= 0; $i--, $j++) &#123; $k = $chs[i] - '0'; if ($j % 2 == 0) &#123; $k *= 2; $k = $k / 10 + $k % 10; &#125; $LuhnSum += $k; &#125; return ($LuhnSum % 10 == 0) ? '0' : ((10 - $LuhnSum % 10)); &#125;&#125;$bank = new GetBank();echo $bank-&gt;getBankName(\"6212263007000674715\");// 工商银行·牡丹卡普卡 Luhn算法 (Luhn algorithm), 也称为“模10”（Mod 10）算法，是一种简单的校验和算法，一般用于验证身份识别码，例如发卡行识别码、国际移动设备辨识码（IMEI），美国国家提供商标识号码，或是加拿大社会保险号码。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"银行卡","slug":"银行卡","permalink":"http://blog.caoxl.com/tags/银行卡/"}]},{"title":"根据银行卡号获取银行信息 「阿里API」","slug":"ThirdParty-use-bankcard","date":"2018-07-26T03:17:02.000Z","updated":"2019-08-22T06:45:12.000Z","comments":true,"path":"2018/07/26/ThirdParty-use-bankcard/","link":"","permalink":"http://blog.caoxl.com/2018/07/26/ThirdParty-use-bankcard/","excerpt":"根据银行卡号获取银行信息（银行名称, 信用卡/借记卡, 银行LOGO 等）, 供任何 PHP 框架或者原生代码使用.","text":"根据银行卡号获取银行信息（银行名称, 信用卡/借记卡, 银行LOGO 等）, 供任何 PHP 框架或者原生代码使用. 还记得在支付宝上给同学同志同事女朋友打钱的时候，当你输入完银行卡号的时候自动帮你选择好银行卡的小细节吗？当你给信用卡还款的时候，能自动判断出是信用卡还是储蓄卡。如此贴心的功能，你值得拥有！ 1234567891011// 只输入前五位即可查询BankCard::info('6225700000000000');// 将得到array (size=6) 'validated' =&gt; true // 是否验证成功 'bank' =&gt; 'CEB', // 银行标识 'bankName' =&gt; '中国光大银行' , // 银行名称 'bankImg' =&gt; 'https://apimg.alipay.com/combo.png?d=cashier&amp;t=CEB', // 银行LOGO 'cardType' =&gt; 'CC', // 卡类型 'cardTypeName' =&gt; '信用卡', // 卡类型名称 引入Laravel/Lumen1composer require zhuzhichao/bank-card-info 其他框架 点击下载: zhuzhichao/bank-card-info 使用 超级简单 12345use Zhuzhichao\\BankCardInfo\\BankCard;$bankInfo = BankCard::info($bank_card_number);var_dump($bankInfo); 单独获取银行logo BankCard::getBankImg(&#39;ABC&#39;) 1https://apimg.alipay.com/combo.png?d=cashier&amp;t=ABC 获取银行列表信息 BankCard::getBankList() 12345678910111213array (size=165) 'SRCB' =&gt; '深圳农村商业银行', 'BGB' =&gt; '广西北部湾银行', 'SHRCB' =&gt; '上海农村商业银行', 'BJBANK' =&gt; '北京银行', 'WHCCB' =&gt; '威海市商业银行', 'BOZK' =&gt; '周口银行', ... 'LYBANK' =&gt; '洛阳银行', 'GDB' =&gt; '广东发展银行', 'ZBCB' =&gt; '齐商银行', 'CBKF' =&gt; '开封市商业银行', ... 特点 不配置和使用数据库，妈妈再也不用担心配置问题了 使用简单，功能专(dān)注(yī) 使用composer进行安装管理，国际标准，方便快捷，即安即用，随时更新数据库 该接口由支付宝提供~~~ 参考 Bank card info","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"},{"name":"银行卡","slug":"银行卡","permalink":"http://blog.caoxl.com/tags/银行卡/"}]},{"title":"MySQL 查看表结构","slug":"MySQL-show-tables","date":"2018-07-26T01:41:59.000Z","updated":"2019-08-22T06:28:34.000Z","comments":true,"path":"2018/07/26/MySQL-show-tables/","link":"","permalink":"http://blog.caoxl.com/2018/07/26/MySQL-show-tables/","excerpt":"简单描述表结构, 字段类型1desc table_name;","text":"简单描述表结构, 字段类型1desc table_name; 例如: 12345678910111213MariaDB [skb]&gt; desc users;+----------------+------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------------+------------------+------+-----+---------+----------------+| id | int(10) unsigned | NO | PRI | NULL | auto_increment || name | varchar(191) | NO | | NULL | || email | varchar(191) | NO | UNI | NULL | || password | varchar(191) | NO | | NULL | || homepage | varchar(191) | NO | | NULL | || remember_token | varchar(100) | YES | | NULL | || created_at | timestamp | YES | | NULL | || updated_at | timestamp | YES | | NULL | |+----------------+------------------+------+-----+---------+----------------+ 查看表中列的注释信息123select * from information_schema.columns where table_schema = 'db' # 表所在数据库and table_name = 'table_name'; # 要查询的表 例如: 1select * from information_schema.columns where table_schema = 'skb' and table_name = 'skb_users'; 只查询列名和注释123select column_name, column_comment from information_schema.columns where table_schema = 'db' # 表所在数据库and table_name = 'table_name'; # 要查询的表 例如: 12345678910111213141516171819MariaDB [skb]&gt; select column_name, column_comment from information_schema.columns where table_schema = 'skb' and table_name = 'skb_users'; +-------------+-------------------------------------------------------------+| column_name | column_comment |+-------------+-------------------------------------------------------------+| id | || username | 用户名 || password | 密码 || openid | 微信ID || nickname | 微信昵称,用户昵称 || avatar | 微信头像,用户头像 || mobile | 微信手机号,用户手机号 || is_del | 1表示删除,0表示未删除 || role | 1表示仅是用户,2表示仅是师傅,3表示两者皆是 || created_at | || updated_at | || deleted_at | || money | 余额 |+-------------+-------------------------------------------------------------+13 rows in set (0.00 sec) 查看表的注释123select table_name, table_comment from information_schema.tables where table_schema = 'db' # 表所在数据库and table_name = 'table_name'; # 要查询的表 例如: 1234567MariaDB [skb]&gt; select table_name, table_comment from information_schema.tables where table_schema = 'skb' and table_name = 'skb_users'; +------------+---------------+| table_name | table_comment |+------------+---------------+| skb_users | |+------------+---------------+1 row in set (0.00 sec) 查看表生成的DDL1234show create table table_name;# 更美观的显示show create table table_name \\G; 例如: 12345678910111213141516171819202122MariaDB [skb]&gt; show create table skb_users\\G;*************************** 1. row *************************** Table: skb_usersCreate Table: CREATE TABLE `skb_users` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `username` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '用户名', `password` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '密码', `openid` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '微信ID', `nickname` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '微信昵称,用户昵称', `avatar` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '微信头像,用户头像', `mobile` char(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '微信手机号,用户手机号', `is_del` tinyint(4) DEFAULT '0' COMMENT '1表示删除,0表示未删除', `role` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1表示仅是用户,2表示仅是师傅,3表示两者皆是', `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, `deleted_at` timestamp NULL DEFAULT NULL, `money` double(8,2) NOT NULL COMMENT '余额', PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci1 row in set (0.00 sec)ERROR: No query specified","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"}]},{"title":"Linux服务器执行sql文件","slug":"Linux-exec-sql","date":"2018-07-24T06:28:32.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/24/Linux-exec-sql/","link":"","permalink":"http://blog.caoxl.com/2018/07/24/Linux-exec-sql/","excerpt":"Linux服务器执行sql文件","text":"Linux服务器执行sql文件 连接数据库1mysql -u user -p password 新建数据库12create database database_name;show databases; 选择数据库12source /test.sqlshow tables; 删除数据库1drop database dabatase_name; 备份数据库查看 MySQL bin日志","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"偶尔看看前端 「CSS3」","slug":"Learn-CSS3-Notes","date":"2018-07-23T08:00:26.000Z","updated":"2019-08-22T06:53:02.000Z","comments":true,"path":"2018/07/23/Learn-CSS3-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/07/23/Learn-CSS3-Notes/","excerpt":"CSS3 是最新的 CSS 标准。 作为一个后端还是要偶尔看看前端的.CSS是入门PHP的时候该看的, 为啥现在发这个呢, –因为人都需要不断的学习和复习.","text":"CSS3 是最新的 CSS 标准。 作为一个后端还是要偶尔看看前端的.CSS是入门PHP的时候该看的, 为啥现在发这个呢, –因为人都需要不断的学习和复习. CSS3模块 选择器 框模型 背景和边框 文本效果 2D/3D转换 动画 多列布局 用户界面 CSS3边框CSS3 圆角边框12345div &#123; border:2px solid; border-radius:25px; -moz-border-radius:25px; /* Old Firefox */&#125; CSS3 边框阴影123div &#123; box-shadow: 10px 10px 5px #888888;&#125; CSS3 边框图片123456div &#123; border-image:url(border.png) 30 30 round; -moz-border-image:url(border.png) 30 30 round; /* 老的 Firefox */ -webkit-border-image:url(border.png) 30 30 round; /* Safari 和 Chrome */ -o-border-image:url(border.png) 30 30 round; /* Opera */&#125; 新的边框属性 border-image 设置所有 border-image-* 属性的简写属性。 border-redius 设置所有四个 border-*-radius 属性的简写属性。 box-shadow 向方框添加一个或多个阴影。 CSS3背景CSS3 background-size 属性background-size 属性规定背景图片的尺寸。 调整背景图片的大小 123456div &#123; background:url(bg_flower.gif); -moz-background-size:63px 100px; /* 老版本的 Firefox */ background-size:63px 100px; background-repeat:no-repeat;&#125; 对背景图片进行拉伸，使其完成填充内容区域 123456div &#123; background:url(bg_flower.gif); -moz-background-size:40% 100%; /* 老版本的 Firefox */ background-size:40% 100%; background-repeat:no-repeat;&#125; CSS3 background-origin 属性 在 content-box 中定位背景图片: 1234567div &#123; background:url(bg_flower.gif); background-repeat:no-repeat; background-size:100% 100%; -webkit-background-origin:content-box; /* Safari */ background-origin:content-box;&#125; CSS3 多重背景图片 为 body 元素设置两幅背景图片 123body &#123; background-image:url(bg_flower.gif),url(bg_flower_2.gif);&#125; CSS3 文本效果CSS3 文本阴影 向标题添加阴影 123h1 &#123; text-shadow: 5px 5px 5px #FF0000;&#125; CSS3 自动换行 允许对长单词进行拆分，并换行到下一行 1p &#123;word-wrap:break-word;&#125; 新的文本属性 hanging-punctuation - 规定标点字符是否位于线框之外 punctuation-trim - 规定是否对标点字符进行修剪 text-align-last - 设置如何对齐最后一行或紧挨着强制换行符之前的行 text-emphasis - 向元素的文本应用重点标记以及重点标记的前景色 text-justify - 规定当 text-align 设置为 “justify” 时所使用的对齐方法 text-outline - 规定文本的轮廓。 text-overflow - 规定当文本溢出包含元素时发生的事情 text-shadow - 向文本添加阴影 text-wrap - 规定文本的换行规则 word-break - 规定非中日韩文本的换行规则 word-wrap - 允许对长的不可分割的单词进行分割并换行到下一行 CSS3 2D 转换translate() 方法 通过 translate() 方法，元素从其当前位置移动，根据给定的 left（x 坐标） 和 top（y 坐标） 位置参数： 1234567div &#123; transform: translate(50px,100px); -ms-transform: translate(50px,100px); /* IE 9 */ -webkit-transform: translate(50px,100px); /* Safari and Chrome */ -o-transform: translate(50px,100px); /* Opera */ -moz-transform: translate(50px,100px); /* Firefox */&#125; rotate() 方法 通过 rotate() 方法，元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转。 1234567div &#123; transform: rotate(30deg); -ms-transform: rotate(30deg); /* IE 9 */ -webkit-transform: rotate(30deg); /* Safari and Chrome */ -o-transform: rotate(30deg); /* Opera */ -moz-transform: rotate(30deg); /* Firefox */&#125; scale() 方法 通过 scale() 方法，元素的尺寸会增加或减少，根据给定的宽度（X 轴）和高度（Y 轴）参数 1234567div &#123; transform: scale(2,4); -ms-transform: scale(2,4); /* IE 9 */ -webkit-transform: scale(2,4); /* Safari 和 Chrome */ -o-transform: scale(2,4); /* Opera */ -moz-transform: scale(2,4); /* Firefox */&#125; skew() 方法 通过 skew() 方法，元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数 1234567div &#123; transform: skew(30deg,20deg); -ms-transform: skew(30deg,20deg); /* IE 9 */ -webkit-transform: skew(30deg,20deg); /* Safari and Chrome */ -o-transform: skew(30deg,20deg); /* Opera */ -moz-transform: skew(30deg,20deg); /* Firefox */&#125; matrix() 方法 如何使用 matrix 方法将 div 元素旋转 30 度 1234567div &#123; transform:matrix(0.866,0.5,-0.5,0.866,0,0); -ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */ -moz-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Firefox */ -webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */ -o-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Opera */&#125; CSS3 3D 转换rotateX() 方法 通过 rotateX() 方法，元素围绕其 X 轴以给定的度数进行旋转 12345div &#123; transform: rotateX(120deg); -webkit-transform: rotateX(120deg); /* Safari 和 Chrome */ -moz-transform: rotateX(120deg); /* Firefox */&#125; rotateY() 旋转 通过 rotateY() 方法，元素围绕其 Y 轴以给定的度数进行旋转 12345div &#123; transform: rotateY(130deg); -webkit-transform: rotateY(130deg); /* Safari 和 Chrome */ -moz-transform: rotateY(130deg); /* Firefox */&#125; CSS3 过渡 CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。 要实现这一点, 必须规定两项内容: 规定你希望把添加到哪个CSS属性上 规定效果的时长 应用于宽度属性的过渡效果，时长为 2 秒 123456div &#123; transition: width 2s; -moz-transition: width 2s; /* Firefox 4 */ -webkit-transition: width 2s; /* Safari 和 Chrome */ -o-transition: width 2s; /* Opera */&#125; CSS3 动画 动画是使元素从一种样式逐渐变化为另一种样式的效果 当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变 12345678910111213141516171819202122232425262728293031@keyframes myfirst&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background: red;&#125;25% &#123;background: yellow;&#125;50% &#123;background: blue;&#125;100% &#123;background: green;&#125;&#125; 改变背景色和位置 1234567891011121314151617181920212223242526272829303132333435@keyframes myfirst&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-moz-keyframes myfirst /* Firefox */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari 和 Chrome */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-o-keyframes myfirst /* Opera */&#123;0% &#123;background: red; left:0px; top:0px;&#125;25% &#123;background: yellow; left:200px; top:0px;&#125;50% &#123;background: blue; left:200px; top:200px;&#125;75% &#123;background: green; left:0px; top:200px;&#125;100% &#123;background: red; left:0px; top:0px;&#125;&#125; CSS3 多列CSS3 创建多列 column-count 属性规定元素应该被分隔的列数 把 div 元素中的文本分隔为三列 12345div &#123; -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari 和 Chrome */ column-count:3;&#125; CSS3 规定列之间的间隔 column-gap 属性规定列之间的间隔 规定列之间 40 像素的间隔 12345div &#123; -moz-column-gap:40px; /* Firefox */ -webkit-column-gap:40px; /* Safari 和 Chrome */ column-gap:40px;&#125; CSS3 列规则 column-rule 属性设置列之间的宽度、样式和颜色规则 规定列之间的宽度、样式和颜色规则 12345div &#123; -moz-column-rule:3px outset #ff0000; /* Firefox */ -webkit-column-rule:3px outset #ff0000; /* Safari and Chrome */ column-rule:3px outset #ff0000;&#125; CSS3 用户界面CSS3 Resizing 在 CSS3，resize 属性规定是否可由用户调整元素尺寸。 规定 div 元素可由用户调整大小 1234div &#123; resize:both; overflow:auto;&#125; CSS3 Box Sizing box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。 规定两个并排的带边框方框 1234567div &#123; box-sizing:border-box; -moz-box-sizing:border-box; /* Firefox */ -webkit-box-sizing:border-box; /* Safari */ width:50%; float:left;&#125; CSS3 Outline Offset outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。 规定边框边缘之外 15 像素处的轮廓 12345div &#123; border:2px solid black; outline:2px solid red; outline-offset:15px;&#125; 没事看看, 虽然不写前端的东西了, 不过多了解总是不会亏的~~~","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://blog.caoxl.com/tags/FrontEnd/"},{"name":"前端","slug":"前端","permalink":"http://blog.caoxl.com/tags/前端/"},{"name":"CSS3","slug":"CSS3","permalink":"http://blog.caoxl.com/tags/CSS3/"}]},{"title":"Linux 「运维命令」","slug":"Linux-Operation","date":"2018-07-23T01:27:41.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/23/Linux-Operation/","link":"","permalink":"http://blog.caoxl.com/2018/07/23/Linux-Operation/","excerpt":"Linux 运维命令总结","text":"Linux 运维命令总结 查看某个端口进程 netstat 12[root@caoxianliang ~]# netstat -tnlp | grep 80tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 17121/nginx: master lsof 123456[root@caoxianliang ~]# lsof -i:80COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEpython 1175 root 17u IPv4 930540 0t0 TCP caoxianliang:37217-&gt;36.110.220.15:http (ESTABLISHED)AliYunDun 17050 root 19u IPv4 926114 0t0 TCP caoxianliang:58918-&gt;106.11.68.13:http (ESTABLISHED)nginx 17121 root 8u IPv4 926506 0t0 TCP *:http (LISTEN)nginx 17122 www 8u IPv4 926506 0t0 TCP *:http (LISTEN) 删除0字节文件1find -type f -size 0 -exec rm -rf &#123;&#125; \\; 查看进程 按内存从大到小排列 1ps -e -o \"%C : %p : %z : %a\" | sort -k5 -nr 按CPU利用率从大到小排列1ps -e -o \"%C : %p : %z : %a\" | sort -nr 查看HTTP的并发请求数及其TCP连接状态1netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;' 如何杀掉MYSQL进程1ps aux |grep mysql |grep -v grep |awk '&#123;print $2&#125;' |xargs kill -9 1killall -TERM mysqld 查看mysql进程 1service mysql status 显示运行3级别开启的服务1ls /etc/rc3.d/S* |cut -c 15- 查看内存的大小1free -m |grep \"Mem\" | awk '&#123;print $2&#125;' 统计一下服务器下面所有的jpg的文件的大小1find / -name *.jpg -exec wc -c &#123;&#125; \\;|awk '&#123;print $1&#125;'|awk '&#123;a+=$1&#125;END&#123;print a&#125;' 查看CPU 负载 cat /proc/loadavg 12[root@caoxianliang ~]# cat /proc/loadavg0.00 0.01 0.05 3/123 13560 检查前三个输出值是否超过了系统逻辑CPU的4倍。 mpstat 1 1 123456[root@caoxianliang ~]# mpstat 1 1Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)10:07:25 AM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle10:07:26 AM all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00Average: all 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00 检查%idle是否过低(比如小于5%) 找出占用空间最多的文件或目录1du -cks * | sort -rn | head -n 10 1234567891011[root@caoxianliang ~]# du -cks * | sort -rn | head -n 10669900 total348556 bin159544 lib124740 mysql-test30000 var2800 sql-bench2644 share732 man708 include100 support-files 查看磁盘I/O负载1iostat -x 1 2 1234567891011121314[root@caoxianliang ~]# iostat -x 1 2Linux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)avg-cpu: %user %nice %system %iowait %steal %idle 0.20 0.01 0.11 0.02 0.00 99.65Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.34 0.09 0.77 1.49 5.37 15.97 0.00 5.54 7.19 5.35 0.33 0.03avg-cpu: %user %nice %system %iowait %steal %idle 0.00 0.00 0.00 0.00 0.00 100.00Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %utilvda 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 检查I/O使用率(%util)是否超过100% 查看网络负载1sar -n DEV 1234567891011[root@caoxianliang ~]# sar -n DEVLinux 3.10.0-862.3.2.el7.x86_64 (caoxianliang) 07/23/2018 _x86_64_ (1 CPU)12:00:01 AM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s12:10:01 AM eth0 0.14 0.14 0.01 0.04 0.00 0.00 0.0012:10:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0012:20:01 AM eth0 0.08 0.10 0.00 0.01 0.00 0.00 0.0012:20:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0012:30:01 AM eth0 0.29 0.23 0.02 0.03 0.00 0.00 0.0012:30:01 AM lo 0.00 0.00 0.00 0.00 0.00 0.00 0.0012:40:01 AM eth0 0.26 0.17 0.02 0.02 0.00 0.00 0.00 检查网络流量(rxbyt/s, txbyt/s)是否过高 查看网络错误12345[root@caoxianliang ~]# netstat -iKernel Interface tableIface MTU RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flgeth0 1500 1648927 0 0 0 1454542 0 0 0 BMRUlo 65536 306 0 0 0 306 0 0 0 LRU 查看网络连接数目123456[root@caoxianliang ~]# netstat -an | grep -E \"^(tcp)\" | cut -c 68- | sort | uniq -c | sort -n 1 FIN_WAIT1 1 LAST_ACK 5 TIME_WAIT 6 ESTABLISHED 6 LISTEN 查看进程总数12[root@caoxianliang ~]# ps aux | wc -l74 检查进程个数是否正常 (比如超过250) 查看可运行进程数目12345678[root@caoxianliang ~]# vmstat 1 5procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 3 0 0 108564 135436 614224 0 0 2 5 41 7 0 0 100 0 0 0 0 0 108564 135436 614224 0 0 0 0 118 179 1 0 99 0 0 0 0 0 108564 135436 614224 0 0 0 0 128 189 0 0 100 0 0 0 0 0 108564 135436 614224 0 0 0 0 138 208 0 0 100 0 0 0 0 0 108564 135436 614224 0 0 0 0 128 187 0 1 99 0 0 列给出的是可运行进程的数目，检查其是否超过系统逻辑CPU的4倍 观察是否有异常进程出现1top -id 1 检查登录用户是否过多 uptime 12[root@caoxianliang ~]# uptime 11:01:15 up 9 days, 17:35, 1 user, load average: 0.14, 0.14, 0.10 who |wc -l 12[root@caoxianliang ~]# who | wc -l1 查看系统时间 date 12345[root@caoxianliang ~]# dateMon Jul 23 11:03:45 CST 2018[root@caoxianliang ~]# date --date=yesterdaySun Jul 22 11:34:21 CST 2018 cal 12345678[root@caoxianliang ~]# cal July 2018 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 1415 16 17 18 19 20 2122 23 24 25 26 27 2829 30 31 检查打开文件总数是否过多 lsof |wc -l 12[root@caoxianliang ~]# lsof | wc -l3957 杀掉80端口相关的进程1lsof -i :80|grep -v \"ID\"|awk '&#123;print \"kill -9\",$2&#125;'|sh 使用 netstat -lntp 查看 tcpdump 抓包 ，用来防止80端口被人攻击时可以分析数据1tcpdump -c 10000 -i eth0 -n dst port 80 &gt; /root/packets 实例: 123456[root@caoxianliang ~]# tcpdump -c 100 -i eth0 -n dst port 80 &gt; /root/packetstcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes100 packets captured101 packets received by filter0 packets dropped by kernel 然后检查IP的重复数 并从小到大排序 注意 &quot;-t\\ +0&quot; 中间是两个空格 1less packets | awk &#123;'printf $3\"\\n\"'&#125; | cut -d. -f 1-4 | sort | uniq -c | awk &#123;'printf $1\" \"$2\"\\n\"'&#125; | sort -n -t\\ +0 实例: 12[root@caoxianliang ~]# less packets | awk &#123;'printf $3\"\\n\"'&#125; | cut -d. -f 1-4 | sort | uniq -c | awk &#123;'printf $1\" \"$2\"\\n\"'&#125; | sort -n 100 172.31.45.94 查看有多少个活动的php-cgi进程1netstat -anp | grep php-cgi | grep ^tcp | wc -l 实例: 12[root@caoxianliang ~]# netstat -anp | grep php-cgi | grep ^tcp | wc -l0 查看系统自启动的服务1chkconfig --list | awk '&#123;if ($5 == \"3:on\") print $1&#125;' 实例: 1234567891011121314151617[root@caoxianliang ~]# chkconfig --list | awk '&#123;if ($5==\"3:on\") print $1&#125;'Note: This output shows SysV services only and does not include native systemd services. SysV configuration data might be overridden by native systemd configuration. If you want to list systemd services use 'systemctl list-unit-files'. To see services enabled on particular target use 'systemctl list-dependencies [target]'.aegisagentwatchmysqlnetworknginxphp-fpmshadowsocks 查看硬件制作商1dmidecode -s system-product-name 实例: 12[root@caoxianliang ~]# dmidecode -s system-product-nameAlibaba Cloud ECS 显示最常用的20条命令1cat ~/.bash_history |grep -v ^# |awk '&#123;print $1&#125;' |sort |uniq -c |sort -nr |head -20 实例: 123456789101112131415161718192021[root@caoxianliang ~]# cat .bash_history |grep -v ^# |awk '&#123;print $1&#125;' |sort |uniq -c |sort -nr |head -20 265 ls 200 cd 43 vim 28 rm 28 ll 28 cat 24 rz 24 ps 15 yum 15 uname 14 rpm 12 mkdir 11 rar 10 sh 10 php 9 whereis 9 df 9 chage 8 tar 8 curl","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"将Nginx加到系统变量中","slug":"Linux-Export-Nginx-Path","date":"2018-07-20T08:07:34.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/20/Linux-Export-Nginx-Path/","link":"","permalink":"http://blog.caoxl.com/2018/07/20/Linux-Export-Nginx-Path/","excerpt":"PHP, MYSQL和这个方法一样","text":"PHP, MYSQL和这个方法一样 配置环境变量 在/etc/profile中加入 12export NGINX_HOME=/usr/local/nginxexport PATH=$PATH:$NGINX_HOME/sbin 执行 source /etc/profile, 使配置文件生效即可.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"在服务器上搭建 「ShadowSocksR」","slug":"How-To-Make-ShadowSocksR","date":"2018-07-19T06:22:07.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/19/How-To-Make-ShadowSocksR/","link":"","permalink":"http://blog.caoxl.com/2018/07/19/How-To-Make-ShadowSocksR/","excerpt":"墙外的世界很精彩, 墙外的世界很美好, 墙外的世界你值得拥有","text":"墙外的世界很精彩, 墙外的世界很美好, 墙外的世界你值得拥有 服务器上安装SSR 下载 1wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh 赋予可执行权限 1chmod +x shadowsocksR.sh 运行 1./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 出现以下内容, 输入密码和端口号(自定义) 12345678[root@caoxianliang ssr]# ./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log############################################################## One click Install ShadowsocksR Server ## Intro: https://shadowsocks.be/9.html ## Author: Teddysun &lt;i@teddysun.com&gt; ## Github: https://github.com/shadowsocksr/shadowsocksr ############################################################## 安装完成, 以下会输出在服务器上, 保存. 123456789101112Starting ShadowsocksR successCongratulations, ShadowsocksR server install completed!Your Server IP : *** Your Server Port : *** Your Password : *** Your Protocol : origin Your obfs : plain Your Encryption Method: aes-256-cfb Welcome to visit:https://shadowsocks.be/9.htmlEnjoy it! 在阿里云-云服务器ECS-网络和安全组-安全组配置中开放你设置的端口号 SSR客户端1链接：https://pan.baidu.com/s/18FOGMNwcd4trWQrxQgN-ZA 密码：oywm 以上的链接也许会过期, 过期就自己去网上找吧~~ 下载完成后, 将服务器返回的配置, 输入到客户端即可. 参考 来自一个鸡的博客: SSR一键安装 Shadowsocks非官方网站","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Laravel/Lumen/Dingo 的路由","slug":"Laravel-Lumen-Routes","date":"2018-07-17T01:17:12.000Z","updated":"2019-08-22T03:54:35.000Z","comments":true,"path":"2018/07/17/Laravel-Lumen-Routes/","link":"","permalink":"http://blog.caoxl.com/2018/07/17/Laravel-Lumen-Routes/","excerpt":"Laravel/Lumen/Dingo 的路由区别","text":"Laravel/Lumen/Dingo 的路由区别 Laravel基础路由123456Route::get($uri, $callback);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback); 有的时候你可能需要注册一个可响应多个 HTTP 请求的路由，这时你可以使用 match 方法，也可以使用 any 方法注册一个实现响应所有 HTTP 请求的路由： 1234567Route::match(['get', 'post'], '/', function () &#123; // &#125;);Route::any('foo', function () &#123; //&#125;); 路由组中间件12345Route::middleware(['first', 'second'])-&gt;group(function () &#123; Route::get('/', function () &#123; // 使用 first 和 second 中间件 &#125;);&#125;); 命名空间123Route::namespace('Admin')-&gt;group(function () &#123; // 在 \"App\\Http\\Controllers\\Admin\" 命名空间下的控制器&#125;); 路由前缀12345Route::prefix('admin')-&gt;group(function () &#123; Route::get('users', function () &#123; // 匹配包含 \"/admin/users\" 的 URL &#125;;&#125;); 路由组-group12345678910Route::group([ 'namespace' =&gt; 'Admin', 'prefix' =&gt; 'admin', 'middleware' =&gt; 'auth', 'domain' =&gt; 'blog.domain.com'], function () &#123; Route::get('test', function () &#123; // &#125;);&#125;); Lumenbootstrap/app.php12345678&lt;?php$app-&gt;group(['namespace' =&gt; 'App\\Http\\Controllers'], function ($app) &#123; require_once __DIR__.'/../routes/web.php'; require_once __DIR__.'/../routes/api.php';&#125;);return $app; 上面括号中使用的是$app 所以在路由文件中也使用$app route.php 1234567891011&lt;?php$app-&gt;group([ 'namespace' =&gt; 'Test', 'prefix' =&gt; 'test', 'middleware' =&gt; 'auth', 'domain' =&gt; 'test.domain.com'], function ($app) &#123; $app-&gt;get('/', 'Index@index'); $app-&gt;post('login', 'AuthController@login');&#125;); 123456$app-&gt;get('/', function () use ($app) &#123; return response()-&gt;json([ 'err' =&gt; '403, 'msg' =&gt; 'Forbidden', ], 403);&#125;); Dingo原生 route.php 12345678910111213141516&lt;?php$api = app('Dingo\\Api\\Routing\\Router');$api-&gt;version('v1', [ 'namespace' =&gt; 'App\\Api\\V1',], function ($router) &#123; $router-&gt;group([ 'prefix' =&gt; 'test', 'middleware' =&gt; [ 'api.auth', ], ], function ($router) &#123; $router-&gt;get('/', 'Test@index'); $router-&gt;post('wechat', 'Passport@login')-&gt;name('wechat.login'); &#125;);&#125;); 封装后 functions.php 12345678910111213&lt;?phpif (! function_exists('fe')) &#123; function fe(string $name) &#123; return function_exists($name); &#125;&#125; if (! fe('dingo')) &#123; function dingo() &#123; return app('Dingo\\Api\\Routing\\Router'); &#125;&#125; route.php 123456789101112131415&lt;?phpdingo()-&gt;version('v1', [ 'namespace' =&gt; 'App\\Api\\V1',], function ($router) &#123; $router-&gt;group([ 'prefix' =&gt; 'test', 'middleware' =&gt; [ 'api.auth', ], ], function ($router) &#123; $router-&gt;get('/', 'Test@index'); $router-&gt;post('wechat', 'Passport@login')-&gt;name('wechat.login'); &#125;);&#125;);","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"Dingo","slug":"Dingo","permalink":"http://blog.caoxl.com/tags/Dingo/"}]},{"title":"基于Laravel, 使用Redis做购物车","slug":"Laravel-Redis-ShopCar","date":"2018-07-16T09:19:56.000Z","updated":"2019-08-22T03:55:11.000Z","comments":true,"path":"2018/07/16/Laravel-Redis-ShopCar/","link":"","permalink":"http://blog.caoxl.com/2018/07/16/Laravel-Redis-ShopCar/","excerpt":"三人行必有我师, 本文出自我的好朋友 葉蕓榕: laravel与Redis开发购物车 的博客","text":"三人行必有我师, 本文出自我的好朋友 葉蕓榕: laravel与Redis开发购物车 的博客 我在这里就不做过多赘述, 只写一些必要的东西 环境准备 使用laravel内置的用户登陆认证系统并再其基础上进行修改 123php artisan make:authphp artisan migrate 安装Redis 1composer require predis/predis 直接上源码路由准备 /routes/web.php 1234567891011# ShopCar RoutesRoute::get('shopping/add/&#123;id&#125;', 'ShoppingController@add')-&gt;name('shopping.add');Route::get('shopping/shop_car_info', 'ShoppingController@getShopCarInfo')-&gt;name('shopping.shop_car_info');Route::get('shopping/shop_add/&#123;id&#125;', 'ShoppingController@shopCarAdd')-&gt;name('shopping.shop_add');Route::get('shopping/shop_del/&#123;id&#125;', 'ShoppingController@shopCarDel')-&gt;name('shopping.shop_del');Route::get('shopping/shop_clean/&#123;id&#125;', 'ShoppingController@cleanShopCar')-&gt;name('shopping.shop_clean'); 前端页面 home.blade.php 1234567891011121314151617181920212223242526272829303132333435@extends('layouts.app')@section('content')&lt;div class=\"container\"&gt; &lt;div class=\"row justify-content-center\"&gt; &lt;div class=\"col-md-8\"&gt; &lt;div class=\"card\"&gt; &#123;&#123;--@include('shared.message')--&#125;&#125; &lt;div class=\"card-header\"&gt;Dashboard&lt;/div&gt; &lt;div class=\"card-body\"&gt; @if (session('status')) &lt;div class=\"alert alert-success\" role=\"alert\"&gt; &#123;&#123; session('status') &#125;&#125; &lt;/div&gt; @endif You are logged in! &lt;/div&gt; &lt;div class=\"card-body\"&gt; 商品0001&lt;a href=\"/shopping/add/1\"&gt;加入购物车&lt;/a&gt; &lt;br&gt; 商品0002&lt;a href=\"/shopping/add/2\"&gt;加入购物车&lt;/a&gt; &lt;br/&gt; 商品0003&lt;a href=\"/shopping/add/3\"&gt;加入购物车&lt;/a&gt; &lt;/div&gt; &lt;div class=\"card-body\"&gt; &lt;a href=\"/shopping/shop_car_info\"&gt;购物车&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;@endsection shopcar.blade.php 12345678910111213141516171819202122232425262728293031323334353637@extends('layouts.app')@section('content') &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;div class=\"card\"&gt; &#123;&#123;--@include('shared.messages')--&#125;&#125; &lt;div class=\"card-body\"&gt; @if($allGoodsKey) @for($i = 0; $i &lt; count($allGoodsKey); $i++) &lt;p&gt; 商品ID: &#123;&#123; $allGoodsInfo[$allGoodsKey[$i]]['id'] &#125;&#125; &lt;br&gt; 商品昵称: &#123;&#123; $allGoodsInfo[$allGoodsKey[$i]]['gname'] &#125;&#125; &lt;br&gt; 商品价格: &#123;&#123; $allGoodsInfo[$allGoodsKey[$i]]['price'] &#125;&#125; &lt;br&gt; 商品数量: &#123;&#123; $allGoodsNum[$allGoodsKey[$i]] &#125;&#125; &lt;br&gt; 商品总价: &#123;&#123; $allGoodsNum[$allGoodsKey[$i]] * $allGoodsInfo[$allGoodsKey[$i]]['price'] &#125;&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href=&#123;&#123; route('shopping.shop_add', $allGoodsInfo[$allGoodsKey[$i]]['id']) &#125;&#125;&gt;+增加&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&#123;&#123; route('shopping.shop_del', $allGoodsInfo[$allGoodsKey[$i]]['id']) &#125;&#125;&gt;-减少&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;a href=&#123;&#123; route('shopping.shop_clean', $allGoodsInfo[$allGoodsKey[$i]]['id']) &#125;&#125;&gt;清除&lt;/a&gt;&amp;nbsp;&amp;nbsp; &lt;/p&gt; @endfor @else &lt;h2&gt;购物车空空如也~&lt;/h2&gt; @endif &lt;/div&gt; &lt;div class=\"card-body\"&gt; &lt;a href=&#123;&#123; route('home') &#125;&#125;&gt;去购物&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;@endsection 后端代码 ShoppingController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Support\\Facades\\Redis;use Illuminate\\Support\\Facades\\Auth;class ShoppingController extends Controller&#123; /** * 添加商品 * @param $goods_id * @return \\Illuminate\\Http\\RedirectResponse */ public function add($goods_id) &#123; $user = Auth::user(); $users_table = Redis::exists('ShoppingCar :' . $user-&gt;id); if ($users_table) &#123; // 用户表存在 // 检查该商品ID是否存在 $GoodsId = Redis::hexists('ShoppingCar :' . $user-&gt;id, $goods_id); if ($GoodsId) &#123; // 存在取出该商品数量, 进行+1操作 $num = Redis::hget('ShoppingCar :' . $user-&gt;id, $goods_id); $newNum = $num + 1; // 修改完之后的保存 Redis::hset('ShoppingCar :' . $user-&gt;id, $goods_id, $newNum); &#125; else &#123; // 将数量设置为1 Redis::hset('ShoppingCar :' . $user-&gt;id, $goods_id, 1); &#125; &#125; else &#123; // 用户表不存在 Redis::hmset('ShoppingCar :' . $user-&gt;id, array($goods_id =&gt; 1)); &#125; $goods_info_table = Redis::hexists('GoodsInfo:Goods', $goods_id); if (!$goods_info_table) &#123; // 先将商品数组信息取出并转换成Json格式 Redis::hset('GoodsInfo:Goods', $goods_id, json_encode($this-&gt;getGoodsInfo($goods_id))); &#125; // 通知用户 session()-&gt;flash('Success', '添加成功'); return redirect()-&gt;route('home'); &#125; /** * 获取用户全部商品 * @return \\Illuminate\\Contracts\\View\\Factory|\\Illuminate\\View\\View */ public function getShopCarInfo() &#123; $user = Auth::user(); $allGoodsKey = Redis::hkeys('ShoppingCar :' . $user-&gt;id); if (null == $allGoodsKey) &#123; $allGoodsNum = false; $allGoodsInfo = false; &#125; for ($i = 0; $i &lt; count($allGoodsKey); $i++) &#123; $allGoodsNum[$allGoodsKey[$i]] = Redis::hget('ShoppingCar :' . $user-&gt;id, $allGoodsKey[$i]); $allGoodsInfo[$allGoodsKey[$i]] = json_decode(Redis::hget('GoodsInfo:Goods', $allGoodsKey[$i]), true); &#125; return view('shopping_car.shopcar', [ 'allGoodsInfo' =&gt; $allGoodsInfo, 'allGoodsNum' =&gt; $allGoodsNum, 'allGoodsKey' =&gt; $allGoodsKey ]); &#125; public function getGoodsInfo($goods_id) &#123; $GoodsInfo= array( 1 =&gt; array( 'id' =&gt; 1, 'gname' =&gt; 'goods1', 'price' =&gt; '1' ), 2 =&gt; array( 'id' =&gt; 2, 'gname' =&gt; 'goods2', 'price' =&gt; '2' ), 3 =&gt; array( 'id' =&gt; 3, 'gname' =&gt; 'goods3', 'price' =&gt; '3' ), 4 =&gt; array( 'id' =&gt; 4, 'gname' =&gt; 'goods4', 'price' =&gt; '4' ), ); return $GoodsInfo[$goods_id]; &#125; /** * 购物车内添加商品 * @param $goods_id * @return \\Illuminate\\Contracts\\View\\Factory|\\Illuminate\\View\\View */ public function shopCarAdd($goods_id) &#123; $user = Auth::user(); if (!$user) &#123; redirect()-&gt;route('home'); &#125; // 取出该商品数 $num = Redis::hget('ShoppingCar :' . $user-&gt;id, $goods_id); $newNum = $num + 1; // 修改完之后的保存 Redis::hset('ShoppingCar :' . $user-&gt;id, $goods_id, $newNum); $allGoodsKey = Redis::hkeys('ShoppingCar :' . $user-&gt;id); for ($i = 0; $i &lt; count($allGoodsKey); $i++) &#123; $allGoodsNum[$allGoodsKey[$i]] = Redis::hget('ShoppingCar :' . $user-&gt;id, $allGoodsKey[$i]); $allGoodsInfo[$allGoodsKey[$i]] = json_decode(Redis::hget('GoodsInfo:Goods', $allGoodsKey[$i]), true); &#125; return view('shopping_car.shopcar', [ 'allGoodsInfo' =&gt; $allGoodsInfo, 'allGoodsNum' =&gt; $allGoodsNum, 'allGoodsKey' =&gt; $allGoodsKey ]); &#125; /** * 购物车内减少商品 * @param $goods_id * @return \\Illuminate\\Contracts\\View\\Factory|\\Illuminate\\View\\View */ public function shopCarDel($goods_id) &#123; $user = Auth::user(); if (!$user) &#123; redirect()-&gt;route('home'); &#125; $goods = Redis::hexists('ShoppingCar :' . $user-&gt;id, $goods_id); if ($goods) &#123; // 存在; 取出该商品数进行减1操作 $num = Redis::hget('ShoppingCar :' . $user-&gt;id, $goods_id); if ($num &gt; 1) &#123; $newNum = $num - 1; Redis::hset('ShoppingCar :' . $user-&gt;id, $goods_id, $newNum); &#125; else &#123; // 删除指定商品 Redis::hdel('ShoppingCar :' . $user-&gt;id, $goods_id); &#125; &#125; $allGoodsKey = Redis::hkeys('ShoppingCar :' . $user-&gt;id); if (null == $allGoodsKey) &#123; $allGoodsNum = false; $allGoodsInfo = false; &#125; for ($i = 0; $i &lt; count($allGoodsKey); $i++) &#123; $allGoodsNum[$allGoodsKey[$i]] = Redis::hget('ShoppingCar :' . $user-&gt;id, $allGoodsKey[$i]); $allGoodsInfo[$allGoodsKey[$i]] = json_decode(Redis::hget('GoodsInfo:Goods', $allGoodsKey[$i]), true); &#125; return view('shopping_car.shopcar', [ 'allGoodsInfo' =&gt; $allGoodsInfo, 'allGoodsNum' =&gt; $allGoodsNum, 'allGoodsKey' =&gt; $allGoodsKey ]); &#125; /** * 清空购物车 * @param $goods_id * @return \\Illuminate\\Contracts\\View\\Factory|\\Illuminate\\View\\View */ public function cleanShopCar($goods_id) &#123; $user = Auth::user(); Redis::hdel('ShoppingCar :' . $user-&gt;id, $goods_id); $allGoodsKey = Redis::hkeys('ShoppingCar :' . $user-&gt;id); if (null == $allGoodsKey) &#123; $allGoodsNum = false; $allGoodsInfo = false; &#125; for ($i = 0; $i &lt; count($allGoodsKey); $i++) &#123; $allGoodsNum[$allGoodsKey[$i]] = Redis::hget('ShoppingCar :' . $user-&gt;id, $allGoodsKey[$i]); $allGoodsInfo[$allGoodsKey[$i]] = json_decode(Redis::hget('GoodsInfo:Goods', $allGoodsKey[$i]), true); &#125; return view('shopping_car.shopcar', [ 'allGoodsInfo' =&gt; $allGoodsInfo, 'allGoodsNum' =&gt; $allGoodsNum, 'allGoodsKey' =&gt; $allGoodsKey ]); &#125;&#125; 使用到的Redis讲解 Redis::exists() 检查给定 key 是否存在。 若 key 存在，返回 1 ，否则返回 0 。 Redis::hexists() 查看哈希表 key 中，给定域 field 是否存在。 如果哈希表含有给定域，返回 1 。 如果哈希表不含有给定域，或 key 不存在，返回 0 。 Redis::hget() 返回哈希表 key 中给定域 field 的值。 给定域的值。 当给定域不存在或是给定 key 不存在时，返回 nil 。 Redis::hset() 将哈希表 key 中的域 field 的值设为 value 。 如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。 如果域 field 已经存在于哈希表中，旧值将被覆盖。 如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。 如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。 Redis::hmset() 同时将多个 field-value (域-值)对设置到哈希表 key 中。 此命令会覆盖哈希表中已存在的域。 如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。 如果命令执行成功，返回 OK 。 当 key 不是哈希表(hash)类型时，返回一个错误。 Redis::hkeys() 返回哈希表 key 中的所有域。 一个包含哈希表中所有域的表。 当 key 不存在时，返回一个空表。 Redis::hdel() 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。 被成功移除的域的数量，不包括被忽略的域。 参考 Redis 命令参考","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"},{"name":"购物车","slug":"购物车","permalink":"http://blog.caoxl.com/tags/购物车/"}]},{"title":"数据库 锁机制","slug":"PHP-Laravel-MySQL-lock","date":"2018-07-16T03:45:51.000Z","updated":"2019-08-22T03:54:55.000Z","comments":true,"path":"2018/07/16/PHP-Laravel-MySQL-lock/","link":"","permalink":"http://blog.caoxl.com/2018/07/16/PHP-Laravel-MySQL-lock/","excerpt":"使用锁的场景 通常在并发场景下，为了防止某个资源被重复创建／更新，在同时存在查询-更新／创建操作的时候","text":"使用锁的场景 通常在并发场景下，为了防止某个资源被重复创建／更新，在同时存在查询-更新／创建操作的时候 直接上源码12345678910111213141516$amount = 100;\\DB::beginTransction();// 锁住该用户对于的行记录, 防止并发中的其他请求修改该用户状态$user = \\App\\Models\\User::lockForUpdate()-&gt;find(1); # 不可读不可写$user = \\App\\Models\\User::sharedLock()-&gt;find(1); # 可读不可写$log = \\App\\Models\\BalanceLog::insert([ 'before' =&gt; $user-&gt;balance, 'create_at' =&gt; time(), 'amount' =&gt; $amount,]); $user-&gt;balance += $amount;$user-&gt;save();\\DB::commit(); 说明: 如果不使用 lockForUpdate() 或者 sharedLock() 来锁住该用户对应的记录，那么在多个相同请求到来时，该用户的余额和日志会被更新／／创建多条，这明显不是我们想要的。 lockForUpdate() 创建的锁将在本次事务结束后释放，且如果记录不存在，lockForUpdate() 则不会起到什么作用。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"锁","slug":"锁","permalink":"http://blog.caoxl.com/tags/锁/"}]},{"title":"如何选择Linux操作系统版本?","slug":"Linux-version","date":"2018-07-16T02:11:01.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/16/Linux-version/","link":"","permalink":"http://blog.caoxl.com/2018/07/16/Linux-version/","excerpt":"如何选择Linux操作系统版本?","text":"如何选择Linux操作系统版本? 一般来讲, 桌面用户首选Ubuntu; 服务器首选RHEL或CentOS, 两者中首选CentOS; 根据具体要求: 安全性要求较高, 则选择Debian或者FreeBSD; 需要要使用数据库高级服务和电子邮件网络应用的用户可以选择SUSE; 想要新技术新功能可以选择Feddora, Feddora是RHEL和CentOS的一个测试版和预发布版本; 根据现有状况, 绝大多数互联网选择CentOS. 现在比较常用的是6系列, 现在市场占有大概一半左右, 另外的原因是CentOS更侧重服务器领域, 并且无版权约束;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"系统版本","slug":"系统版本","permalink":"http://blog.caoxl.com/tags/系统版本/"}]},{"title":"Linux 系统优化小建议","slug":"Linux-System-Optimization","date":"2018-07-16T01:37:05.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/16/Linux-System-Optimization/","link":"","permalink":"http://blog.caoxl.com/2018/07/16/Linux-System-Optimization/","excerpt":"关于Linux系统优化的几个小建议","text":"关于Linux系统优化的几个小建议 Linux 系统优化 登录系统: 不使用root登录, 通过sudo授权管理, 使用普遍用户登录 禁止SSH进程: 更改默认的远程连接SSH服务及禁止root远程连接 时间同步: 定时自动更新服务器时间 配置yum更新源, 从国内更新下载更新rpm包 关闭selinux及iptabls (iptables 工作场景如有 wan ip, 一般要打开, 高并发除外) 调整文件描述符数量, 进程及文件的打开都会消耗文件描述符 定时自动清理/var/spool/clientmquene/目录垃圾文件, 防止节点被占满 (c6.4默认没有sendmial, 因此可以不配) 精简开机启动服务 (crond、 sshd、 network、rsyslog) Linux内核参数优化 /etc/sysctl.conf, 执行sysct-p生效 更改字符集, 支持中文, 但是还是建议使用英文, 防止乱码问题出现 锁定关键系统文件 (chattr +i /etc/passwd /etc/shadow /etc/group /etc/gshadow /etc/inittab 处理以上内容后，把chatter改名，就更安全了。) 清空 /etc/issue, 去除系统及内核版本登陆前的屏幕显示 Linux 启动过程 描述Linux系统从开机到登陆界面的启动过程, 了解整个过程, 才知道在哪个地方着手优化 开机BIOS自检，加载硬盘 读取MBR, MBR引导 grub引导菜单(Boot Loader) 加载内核kernel 启动init进程，依据inittab文件设定运行级别 init进程，执行rc.sysinit文件 启动内核模块, 执行不同级别的脚本程序 执行/etc/rc.d/rc.local 启动mingetty, 进入系统登录界面","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Linux 面试题集","slug":"Linux-Interview-Questions","date":"2018-07-13T06:59:58.000Z","updated":"2019-08-22T06:56:28.000Z","comments":true,"path":"2018/07/13/Linux-Interview-Questions/","link":"","permalink":"http://blog.caoxl.com/2018/07/13/Linux-Interview-Questions/","excerpt":"多说无益, 实战为王","text":"多说无益, 实战为王 问:如何查看当前的Linux服务器的运行级别？ 答: who -r 和 runlevel 命令可以用来查看当前的Linux服务器的运行级别。 who -r 12[root@izj6c6djex81rijczh0t8yz ~]# who -r run-level 3 2018-06-25 17:02 runlevel 12[root@izj6c6djex81rijczh0t8yz ~]# runlevelN 3 问: 如何查看Linux的默认网关？ 答: 用 route -n 和 netstat -nr 命令,我们可以查看默认网关。除了默认的网关信息,这两个命令还可以显示当前的路由表。 route -n 123456[root@izj6c6djex81rijczh0t8yz ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.31.47.253 0.0.0.0 UG 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 eth0172.31.32.0 0.0.0.0 255.255.240.0 U 0 0 0 eth0 netstat -nr 123456[root@izj6c6djex81rijczh0t8yz ~]# netstat -nrKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface0.0.0.0 172.31.47.253 0.0.0.0 UG 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth0172.31.32.0 0.0.0.0 255.255.240.0 U 0 0 0 eth0 问: 如何在Linux上重建初始化内存盘镜像文件？ 答: 在CentOS 5.X / RHEL 5.X中,可以用mkinitrd命令来创建初始化内存盘文件,举例如下 1[root@izj6c6djex81rijczh0t8yz ~]# mkinitrd -f -v /boot/initrd-$(uname -r).img $(uname -r) 如果你想要给特定的内核版本创建初始化内存盘,你就用所需的内核名替换掉 uname -r 在CentOS 6.X / RHEL 6.X中,则用dracut命令来创建初始化内存盘文件,举例如下: 1[root@izj6c6djex81rijczh0t8yz ~]# dracut -f 问: cpio命令是什么？ 答: cpio就是复制入和复制出的意思。cpio可以向一个归档文件（或单个文件）复制文件、列表,还可以从中提取文件。 问: patch命令是什么？如何使用？ 答: 顾名思义,patch命令就是用来将修改（或补丁）写进文本文件里。patch命令通常是接收diff的输出并把文件的旧版本转换为新版本 问: aspell有什么用 ? 答: 顾名思义,aspell就是Linux操作系统上的一款交互式拼写检查器。aspell命令继任了更早的一个名为ispell的程序,并且作为一款免费替代品 ,最重要的是它非常好用 问: 如何从命令行查看域SPF记录 ？ 答: 我们可以用dig命令来查看域SPF记录。举例如下: 12345678910111213141516171819202122[root@izj6c6djex81rijczh0t8yz test]# dig -t TXT google.com; &lt;&lt;&gt;&gt; DiG 9.9.4-RedHat-9.9.4-61.el7 &lt;&lt;&gt;&gt; -t TXT google.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 21277;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 4096;; QUESTION SECTION:;google.com. IN TXT;; ANSWER SECTION:google.com. 300 IN TXT \"docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e\"google.com. 300 IN TXT \"facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95\"google.com. 300 IN TXT \"v=spf1 include:_spf.google.com ~all\";; Query time: 13 msec;; SERVER: 100.100.2.136#53(100.100.2.136);; WHEN: Fri Jul 13 15:17:02 CST 2018;; MSG SIZE rcvd: 217 问: 如何识别Linux系统中指定文件(/etc/fstab)的关联包？ rpm -qf /etc/fstab 12[root@izj6c6djex81rijczh0t8yz test]# rpm -qf /etc/fstabsetup-2.8.71-9.el7.noarch 以上命令能列出提供“/etc/fstab”这个文件的包。 问: 哪条命令用来查看bond0的状态？1cat /proc/net/bonding/bond0 问: Linux系统中的/proc文件系统有什么用 ？ 答: /proc文件系统是一个基于内存的文件系统,其维护着关于当前正在运行的内核状态信息,其中包括CPU、内存、分区划分、I/O地址、直接内存访问通道和正在运行的进程。这个文件系统所代表的并不是各种实际存储信息的文件,它们指向的是内存里的信息。/proc文件系统是由系统自动维护的。 问: 如何在/usr目录下找出大小超过10MB的文件？ find /usr -size +10M 问: 如何在/home目录下找出120天之前被修改过的文件？ find /home -mtime +120 问: 如何在/var目录下找出90天之内未被访问过的文件？ find /var ! -atime -90 问: 在整个目录树下查找文件“core”,如发现则无需提示直接删除它们。 find / -name core -exec rm {} \\; 上个这个命令不要随意使用!!! 问: strings命令有什么作用？ 答: strings命令用来提取和显示非文本文件中的文本字符串。 问: tee 过滤器有什么作用 ? 答: tee 过滤器用来向多个目标发送输出内容。如果用于管道的话,它可以将输出复制一份到一个文件,并复制另外一份到屏幕上（或一些其它程序） 123456789[root@izj6c6djex81rijczh0t8yz tmp]# cat ll.out 1 total 1.5M 2 -rw-r--r--. 1 root root 18 Oct 15 2017 adjtime 3 -rw-r--r-- 1 root root 1.5K Jun 7 2013 aliases 4 -rw-r--r-- 1 root root 12K Oct 15 2017 aliases.db 5 drwxr-xr-x. 2 root root 4.0K Jun 13 11:37 alternatives 6 -rw------- 1 root root 541 Apr 11 09:48 anacrontab 7 -rw-r--r-- 1 root root 55 Apr 11 04:38 asound.conf ... 在以上例子中,从ll输出可以捕获到 /tmp/ll.out 文件中,并且同样在屏幕上显示了出来。 问: export PS1 = &quot;$LOGNAME@hostname:\\$PWD&quot;: 这条命令是在做什么？ 答: 这条export命令会更改登录提示符来显示用户名、本机名和当前工作目录。 12[root@izj6c6djex81rijczh0t8yz ~]# export PS1=\"$LOGNAME@hostname:\\$PWD\"root@hostname:/root 问: ll | awk &#39;{print $3,&quot;owns&quot;,$9}&#39; 这条命令是在做什么？ 答: 这条ll命令会显示这些文件的文件名和它们的拥有者。 123456789101112[root@izj6c6djex81rijczh0t8yz ~]# ll | awk '&#123;print $3,\"owns\",$9&#125;' owns root owns curlroot owns dnf-0.6.4-2.sdl7.noarch.rpmroot owns dnf-conf-0.6.4-2.sdl7.noarch.rpmroot owns letsencryptroot owns linuxroot owns lnmp-install.logmysql owns package.xmlroot owns python-dnf-0.6.4-2.sdl7.noarch.rpmroot owns redis-4.0.2root owns test 问: Linux中的at命令有什么用 ？ 答: at命令用来安排一个程序在未来的做一次一次性执行。所有提交的任务都被放在 /var/spool/at 目录下并且到了执行时间的时候通过atd守护进程来执行 问: Linux中lspci命令的作用是什么？ 答: lspci命令用来显示你的系统上PCI总线和附加设备的信息。指定-v,-vv或-vvv来获取越来越详细的输出,加上-r参数的话,命令的输出则会更具有易读性。 问: 如何看当前Linux系统有几颗物理CPU和每颗CPU的核数？1234[root@izj6c6djex81rijczh0t8yz ~]# cat /proc/cpuinfo|grep -c 'physical id'1[root@izj6c6djex81rijczh0t8yz ~]# cat /proc/cpuinfo|grep -c 'processor'1 问: 查看系统负载有两个常用的命令,是哪两个？这三个数值表示什么含义呢？12345678[root@shuidianbang ~]# w 16:28:08 up 319 days, 58 min, 1 user, load average: 0.00, 0.00, 0.00USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 59.41.94.109 14:52 0.00s 0.10s 0.00s w[root@shuidianbang ~]# uptime 16:28:13 up 319 days, 58 min, 1 user, load average: 0.00, 0.00, 0.00 其中load average即系统负载,三个数值分别表示一分钟、五分钟、十五分钟内系统的平均负载,即平均任务数。 问: vmstat 命令 r, b, si, so, bi, bo 这几列表示什么含义呢？1234[root@shuidianbang ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 1004452 237088 1612324 0 0 0 6 1 0 0 0 100 0 0 r: running,表示正在跑的任务数 b: blocked,表示被阻塞的任务数 si: si表示有多少数据从交换分区读入内存 so: 表示有多少数据从内存写入交换分区 bi: 表示有多少数据从磁盘读入内存 bo: 表示有多少数据从内存写入磁盘 i: input, 进入内存 o: output, 从内存出去 s: swap, 交换分区 b: block, 块设备, 磁盘 单位都是KB 问: Linux系统里,您知道buffer和cache如何区分吗？ 答: buffer和cache都是内存中的一块区域,当CPU需要写数据到磁盘时,由于磁盘速度比较慢,所以CPU先把数据存进buffer,然后CPU去执行其他任务,buffer中的数据会定期写入磁盘;当CPU需要从磁盘读入数据时,由于磁盘速度比较慢,可以把即将用到的数据提前存入cache,CPU直接从Cache中拿数据要快的多 问: 使用top查看系统资源占用情况时,哪一列表示内存占用呢？1234567top - 16:54:58 up 319 days, 1:25, 1 user, load average: 0.00, 0.00, 0.00Tasks: 105 total, 1 running, 104 sleeping, 0 stopped, 0 zombieCpu(s): 0.0%us, 0.3%sy, 0.0%ni, 99.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 4056656k total, 3064012k used, 992644k free, 237088k buffersSwap: 0k total, 0k used, 0k free, 1612444k cachedPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND VIRT: 虚拟内存用量 RES: 物理内存用量 SHR: 共享内存用量 %MEM: 内存用量 问: 如何实时查看网卡流量为多少？如何查看历史网卡流量？ 答: 安装sysstat包,使用sar命令查看 12345yum install -y sysstatsar -n DEV # 查看网卡流量, 默认十分钟更新一次sar -n DEV 1 10 # 一秒显示一次, 一共显示10次sar -n DEV -f /var/log/sa/sa22 # 查看指定日期的流量日志 123456789[root@izj6c6djex81rijczh0t8yz ~]# sarLinux 3.10.0-862.3.2.el7.x86_64 (izj6c6djex81rijczh0t8yz) 07/13/2018 _x86_64_ (1 CPU)12:00:01 AM CPU %user %nice %system %iowait %steal %idle12:10:01 AM all 0.13 0.00 0.09 0.00 0.00 99.7812:20:01 AM all 0.13 0.00 0.08 0.00 0.00 99.7912:30:01 AM all 0.13 0.00 0.09 0.00 0.00 99.7812:40:01 AM all 0.12 0.03 0.10 0.01 0.00 99.74... 问: 如何查看当前系统都有哪些进程？ 答: ps -aux 或者ps -elf ps -aux 123456[root@izj6c6djex81rijczh0t8yz ~]# ps -auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.2 51600 2680 ? Ss Jun25 0:47 /usr/lib/systemd/systemd --switchroot 2 0.0 0.0 0 0 ? S Jun25 0:00 [kthreadd]root 3 0.0 0.0 0 0 ? S Jun25 0:06 [ksoftirqd/0]... ps -elf 1234567[root@izj6c6djex81rijczh0t8yz ~]# ps -elfF S UID PID PPID C PRI NI ADDR SZ WCHAN STIME TTY TIME CMD4 S root 1 0 0 80 0 - 12900 ep_pol Jun25 ? 00:00:47 /usr/lib/systemd/system1 S root 2 0 0 80 0 - 0 kthrea Jun25 ? 00:00:00 [kthreadd]1 S root 3 2 0 80 0 - 0 smpboo Jun25 ? 00:00:06 [ksoftirqd/0]1 S root 5 2 0 60 -20 - 0 worker Jun25 ? 00:00:00 [kworker/0:0H]1 S root 7 2 0 -40 - - 0 smpboo Jun25 ? 00:00:00 [migration/0] 问: ps 查看系统进程时,有一列为STAT, 如果当前进程的stat为Ss 表示什么含义？如果为Z表示什么含义？ 答: S表示正在休眠; s表示主进程; Z表示僵尸进程。 问: 如何查看系统都开启了哪些端口？ netstat -lnp 12345678[root@izj6c6djex81rijczh0t8yz ~]# netstat -lnpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN 2236/nginx: master tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 2256/php-fpm: maste tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 1349/mysqld tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 2236/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1443/sshd 问: 如何查看网络连接状况？ 答: netstat -an 1234567891011121314[root@izj6c6djex81rijczh0t8yz ~]# netstat -anActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp 0 0 172.31.45.94:41058 140.205.140.205:80 ESTABLISHEDtcp 0 52 172.31.45.94:22 59.41.94.109:23385 ESTABLISHEDudp 0 0 172.31.45.94:123 0.0.0.0:* udp 0 0 127.0.0.1:123 0.0.0.0:* udp 0 0 0.0.0.0:123 0.0.0.0:* udp6 0 0 :::123 :::* 问: 想修改ip, 需要编辑哪个配置文件, 修改完配置文件后, 如何重启网卡,使配置生效？ 答: 使用vi/vim编辑器编辑网卡配置文件/etc/sysconfig/network-scripts/ifcft-eth0 (如果是eth1文件名为ifcft-eth1), 内容如下: 123456789101112DEVICE=eth0HWADDR=00:0C:29:06:37:BATYPE=EthernetUUID=0eea1820-1fe8-4a80-a6f0-39b3d314f8daONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.147.130NETMASK=255.255.255.0GATEWAY=192.168.147.2DNS1=192.168.147.2DNS2=8.8.8.8 修改网卡后,可以使用命令重启网卡: 12ifdown eth0ifup eth0 也可以重启网络服务: 1service network restart 问: 能否给一个网卡配置多个IP? 如果能,怎么配置？ 答: 可以给一个网卡配置多个IP,配置步骤如下: 12345678910111213cat /etc/sysconfig/network-scripts/ifcfg-eth0#查看eth0的配置DEVICE=eth0HWADDR=00:0C:29:06:37:BATYPE=EthernetUUID=0eea1820-1fe8-4a80-a6f0-39b3d314f8daONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.147.130NETMASK=255.255.255.0GATEWAY=192.168.147.2DNS1=192.168.147.2DNS2=8.8.8.8 新建一个ifcfg-eth0:1文件 1cp /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0:1 修改其内容如下: 12345678910111213vim /etc/sysconfig/network-scripts/ifcfg-eth0:1DEVICE=eth0:1HWADDR=00:0C:29:06:37:BATYPE=EthernetUUID=0eea1820-1fe8-4a80-a6f0-39b3d314f8daONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.147.133NETMASK=255.255.255.0GATEWAY=192.168.147.2DNS1=192.168.147.2DNS2=8.8.8.8 重启网络服务: 1service network restart 问: 如何查看当前主机的主机名,如何修改主机名？要想重启后依旧生效,需要修改哪个配 置文件呢？ 查看主机名 12[root@izj6c6djex81rijczh0t8yz ~]# hostnameizj6c6djex81rijczh0t8yz 修改主机名 123[root@izj6c6djex81rijczh0t8yz ~]# hostname caoxianliang[root@izj6c6djex81rijczh0t8yz ~]# hostnamecaoxianliang 永久生效需要修改配置文件: 123[root@caoxianliang ~]# vim /etc/sysconfig/networkNETWORKING=yesHOSTNAME=caoxianliang 问: 设置DNS需要修改哪个配置文件？ (1) 在文件 /etc/resolv.conf 中设置DNS(2) 在文件 /etc/sysconfig/network-scripts/ifcfg-eth0 中设置DNS 问: 使用iptables 写一条规则：把来源IP为192.168.1.101访问本机80端口的包直接拒绝 答: iptables -I INPUT -s 192.168.1.101 -p tcp --dport 80 -j REJECT 问: 要想把iptable的规则保存到一个文件中如何做？如何恢复？ 使用iptables-save重定向到文件中: 1iptables-save &gt; 1.ipt 使用iptables-restore反重定向回来: 1iptables-restore &lt; 1.ipt 问: 如何备份某个用户的任务计划？ 答: 将/var/spool/cron/目录下指定用户的任务计划拷贝到备份目录cron_bak/下即可 1234cp /var/spool/cron/root /tmp/bak/cron_bak/[root@izj6c6djex81rijczh0t8yz cron]# cat root 47 20 * * * curl https://caoxl.com/Aliyun/api_demo/SmsDemo.php 问: 如何可以把系统中不用的服务关掉？ 使用可视化工具 ntsysv: 1yum install ntsysv 使用命令: 1chkconfig service_name off // service_name 指服务名 问: 如何让某个服务(假如服务名为 nginx) 只在3,5两个运行级别开启,其他级别关闭？ 先关闭所有运行级别: 1chkconfig nginx off 然后打开35运行级别: 1chkconfig --level 35 nginx on 问: rsync 同步命令中,下面两种方式有什么不同呢？12(1) rsync -av /dira/ ip:/dirb/(2) rsync -av /dira/ ip::dirb 答: (1)前者是通过ssh方式同步的(2)后者是通过rsync服务的方式同步的 问: 某个账号登陆Linux后,系统会在哪些日志文件中记录相关信息？ 答: 用户身份验证过程记录在/var/log/secure中,登录成功的信息记录在/var/log/wtmp 问: 在Linux系统下如何按照下面要求抓包: 只过滤出访问http服务的,目标ip为192.168.0.111, 一共抓1000个包,并且保存到1.cap文件中？ 答: tcpdump -nn -s0 host 192.168.0.111 and port 80 -c 1000 -w 1.cap 问: rsync 同步数据时, 如何过滤出所有.txt的文件不同步？ 答: 加上--exclude选项 1--exclude=\"*.txt\" 问: 想在Linux命令行下访问某个网站，并且该网站域名还没有解析，如何做 ？ 答: 在/etc/hosts文件中增加一条从该网站域名到其IP的解析记录即可，或者使用curl -x 问: 自定义解析域名的时候，我们可以编辑哪个文件？是否可以一个ip对应多个域名？是否一个域名对应多个ip？ 答: 编辑 /etc/hosts ,可以一个ip对应多个域名，不可以一个域名对多个ip 问: 我们可以使用哪个命令查看系统的历史负载（比如说两天前的）？ 答: sar -q -f /var/log/sa/sa22 # 查看22号的系统负载 12345678910[root@caoxianliang sa]# sar -q -f /var/log/sa/sa22Linux 3.10.0-693.11.1.el7.x86_64 (izj6c6djex81rijczh0t8yz) 06/22/2018 _x86_64_ (1 CPU)12:00:01 AM runq-sz plist-sz ldavg-1 ldavg-5 ldavg-15 blocked12:10:01 AM 2 142 0.00 0.01 0.05 012:20:01 AM 2 142 0.00 0.01 0.05 012:30:01 AM 2 142 0.00 0.01 0.05 012:40:01 AM 3 142 0.00 0.01 0.05 012:50:01 AM 2 142 0.00 0.01 0.05 001:00:01 AM 2 142 0.00 0.01 0.05 0 问: 在Linux下如何指定dns服务器，来解析某个域名？ 答：使用dig命令: dig @DNSip http://domain.com 如:1dig @8.8.8.8 www.baidu.com#使用谷歌DNS解析百度 问: 使用rsync同步数据时，假如我们采用的是ssh方式，并且目标机器的sshd端口并不是默认的22端口，那我们如何做？1234rsync \"--rsh=ssh -p 10022\"或rsync -e \"ssh -p 10022\" 问: rsync同步时，如何删除目标数据多出来的数据，即源上不存在，但目标却存在的文件或者目录？ 答: 加上--delete选项 问: 使用free查看内存使用情况时，哪个数值表示真正可用的内存量？ 答: free列第二行的值 问: 有一天你突然发现公司网站访问速度变的很慢很慢，你该怎么办呢？ 答: 可以从两个方面入手分析1.分析系统负载，使用w命令或者uptime命令查看系统负载，2.如果负载很高，则使用top命令查看CPU，MEM等占用情况，要么是CPU繁忙，要么是内存不够，如果这二者都正常，再去使用sar命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。 问: rsync使用服务模式时，如果我们指定了一个密码文件，那么这个密码文件的权限应该设置成多少才可以？ 答: 600或400","categories":[{"name":"面试/笔试题","slug":"面试-笔试题","permalink":"http://blog.caoxl.com/categories/面试-笔试题/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"PHP 加密解密","slug":"PHP-Encrypt-Decrypt","date":"2018-07-13T01:30:11.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/13/PHP-Encrypt-Decrypt/","link":"","permalink":"http://blog.caoxl.com/2018/07/13/PHP-Encrypt-Decrypt/","excerpt":"加密不同于密码，加密是一个动作或者过程，其目的就是将一段明文信息（人类或机器可以直接读懂的信息）变为一段看上去没有任何意义的字符，必须通过事先约定的解密规则才能将信息转换回有意义的可读信息，通过加密可以防止非授权的信息窃取。","text":"加密不同于密码，加密是一个动作或者过程，其目的就是将一段明文信息（人类或机器可以直接读懂的信息）变为一段看上去没有任何意义的字符，必须通过事先约定的解密规则才能将信息转换回有意义的可读信息，通过加密可以防止非授权的信息窃取。 存储加密和传输加密 存储加密 存储加密是指对存储在纸质、磁盘、数据库等介质上的数据进行的加密 传输加密 传输加密则是指对数据在计算机网络、电话、电报等通信信道上进行的加密 不管是上述哪种加密，本质上仍是对信息进行加密。 加密算法对称加密 所谓对称加密，就是加密和解密使用同一秘钥，这也是这种加密算法最显著的缺点之一。 现代的加密算法中，DES、3DES、AES等算法都属于对称加密算法 对称加密有一个明显的缺点，就是即秘钥。特别是在传输加密时，信息的发送方和接收方需要使用相同的秘钥来对信息进行加解密，接收方如何安全的获取秘钥成为这类加密的焦点，因为一旦秘钥被截获，整个加密通信就形同明文传输。 对称加密比较适合存储加密 非对称加密 这种加密算法的秘钥分为“公开秘钥”和“私有秘钥”，公开秘钥用于对信息进行加密，而解密时使用私有秘钥进行解密，这样，信息的接收方可以事先生成好一份公钥和私钥，然后将公钥发给所有的信息发送方，信息发送方使用公钥对信息进行加密，然后将信息发送给接收方，接收方使用私钥进行解密即可 这种算法的优势在于，解密的私钥不需要传递，降低（只能降低，无法避免，要考虑认为因素）了私钥泄密的可能性 常见的非对称加密算法有：RSA、EIGamal、背包算法、Rebin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法和椭圆曲线加密算法等 而最为大家熟知的就是RSA算法 其主要缺点之一就是慢，适合加密少量数据。 误区看到这里，有些人可能会问，我常用的md5、hash算法(sha1、sha256、sha512、sha1024等）怎么没见你提及 其实准确的说，md5和hash算法不能算是加密算法，它们都属于信息摘要算法，可以为不同的信息生成独一无二的信息摘要，而它们都属于不可逆算法，即无法通过生成的摘要信息还原出原始信息 PHP加密最佳实践加密总是与安全密不可分，而每个PHPer都必须将应用安全作为必要的设计思路融入代码中，以下是一些最佳实践的建议。 不要再使用MD5，不要使用sha1，基本上已经没有破解难度了 请使用password_hash来哈希密码(php版本大于等于5.5，小于5.5请使用password_compat库)，由于password_hash函数已帮你处理好了加盐，而且作为盐的随机字串已通过加密算法成为了哈希的一部分，password_verify()函数会自动将盐从哈希中提取出来，所以你无需考虑盐的存储问题。 通信接口的签名，请使用非对称算法对签名秘钥进行加密，并对秘钥设置有效期，定期更换。 不过还是需要了解加密与解密函数的~ 加密函数MD5 md5()默认情况下以 32 字符十六进制数字形式返回散列值，它接受两个参数，第一个为要加密的字符串，第二个为raw_output的布尔值，默认为false，如果设置为true，md5()则会返回原始的 16 位二进制格式报文摘要 md5()为单向加密，没有逆向解密算法，但是还是可以对一些常见的字符串通过收集，枚举，碰撞等方法破解 12345678910111213$username = 'caoxl';$password = 'caoxl.com';echo md5($username);echo '&lt;hr&gt;';echo md5($password);echo '&lt;hr&gt;';echo md5(md5($password));# 得到// 39e1e7e20baad16de47d95d155dc84d8// 7badf979f092ff575c62bd85f2fbb06d// b380ba1215610227ad957856d5a8574c 使用md5函数生成16位md5值返回乱码1$code = md5($str, true); // $code是乱码 解决方法 1$code = substr(md5($str), 8, 16); // $code是16位的md5码 Crypt crypt()接受两个参数，第一个为需要加密的字符串，第二个为盐值（就是加密干扰值，如果没有提供，则默认由PHP自动生成); 返回散列后的字符串或一个少于 13 字符的字符串，后者为了区别盐值。 crypt()为单向加密，跟md5一样。 12345678$password = 'caoxl.com';echo crypt($password);echo '&lt;hr&gt;';echo crypt($password, 'caoxl');echo '&lt;hr&gt;';echo crypt($password, '$1$caoxl$'); Sha1 跟md5很像，不同的是sha1()默认情况下返回40个字符的散列值，传入参数性质一样，第一个为加密的字符串，第二个为raw_output的布尔值，默认为false，如果设置为true，sha1()则会返回原始的20 位原始格式报文摘要 sha1()也是单行加密，没有逆向解密算法 12345$username = 'caoxl';echo sha1($username);echo '&lt;hr&gt;';echo md5(sha1($username)); Sha2 - SHA256/SHA512 这两个加密方式分别生成256和512比特长度的hash字串。 PHP内置了hash()函数，你只需要将加密方式传给hash()函数就好了。你可以直接指明sha256, sha512, md5, sha1等加密方式。 1234567891011121314151617181920$string = 'qadbk+365t';$password1 = hash(\"sha256\", $string);echo $password1;// f07e1599e5cd19c27fc6968997c09b95a4fc8178581ebab6397aa2341b233f38echo '&lt;hr&gt;';$password2 = hash(\"sha512\", $string);echo $password2;// ddf4d3860b5b0cc7adcfc61bed0e9cee2e92a849ce6a48d7e638fcc465f6e74940867e1e161ba3acaf5698c0bdad3ea0bad6a989d39bedd9f70f26d5f9f507fcecho '&lt;hr&gt;';$password3 = hash(\"md5\", $string);echo $password3;// 6a175a68affe2e511b4a2f35bdf52b63echo '&lt;hr&gt;';$password4 = hash(\"sha1\", $string);echo $password4;// 230b01dbc74306bdd0e7826ae5b3461a3ed6374e Urlencode 一个参数，传入要加密的字符串 (通常应用于对URL的加密) urlencode为双向加密，可以用urldecode来加密(严格意义上来说，不算真正的加密) 返回字符串，此字符串中除了 -_. 之外的所有非字母数字字符都将被替换成百分号(%) 后跟两位十六进制数，空格则编码为加号(+)。 12345678$my_urlencode = \"caoxl.com?caoxl=true + 4-3%5= \\&amp; @!\";echo urlencode($my_urlencode);// caoxl.com%3Fcaoxl%3Dtrue+%2B+4-3%255%3D+%5C%26+%40%21echo '&lt;hr&gt;';$my_urldecode=\"caoxl.com%3Fcaoxl%3Dtrue+%2B+4-3%255%3D+%5C%26+%40%21\";echo urldecode($my_urldecode);// caoxl.com?caoxl=true + 4-3%5= \\&amp; @! 常见的urlencode转换字符12345? =&gt; %3F= =&gt; %3D% =&gt; %25&amp; =&gt; %26\\ =&gt; %5C base64 base64_encode()接受一个参数，也就是要编码的数据(这里不说字符串，是因为很多时候base64用来编码图片) base64_encode()为双向加密，可用base64_decode()来解密 1234567$imgUrl = 'https://caoxl.com/images/php7.jpg';echo base64_encode($imgUrl);// aHR0cHM6Ly9jYW94bC5jb20vaW1hZ2VzL3BocDcuanBnecho '&lt;hr&gt;';echo base64_decode('aHR0cHM6Ly9jYW94bC5jb20vaW1hZ2VzL3BocDcuanBn');// https://caoxl.com/images/php7.jpg Password Hashing APIPassword Hashing API是PHP 5.5之后才有的新特性，它主要是提供下面几个函数供我们使用 password_hash() - 对密码加密 password-verify() - 验证已经加密的密码，检验其hash字串是否一致 password_needs_rehash() - 给密码重新加密 password_get_info() - 返回加密算法的名称和一些相关信息 123456789101112131415161718192021222324252627282930313233343536&lt;?php# password_hash$password = 'qadbk+365t';$hash1 = password_hash($password, PASSWORD_DEFAULT);echo $hash1;echo '&lt;hr&gt;';$options = [ 'salt' =&gt; md5('caoxl'), 'cost' =&gt; 12 // 默认10];$hash2 = password_hash($password, PASSWORD_DEFAULT, $options);echo $hash2;echo '&lt;hr&gt;';# password_verifyif (password_verify($password, $hash2)) &#123; echo \"验证成功\";&#125; else &#123; echo \"验证失败\";&#125;echo '&lt;hr&gt;';# password_needs_rehashif (password_needs_rehash($hash2, PASSWORD_DEFAULT, ['cost' =&gt; 14])) &#123; // cost change to 12 $hash = password_hash($password, PASSWORD_DEFAULT, ['cost' =&gt; 14]); echo $hash; // don't forget to store the new hash!&#125;# password_get_infoprint_r( password_get_info( $hash2 ) );// Array ( [algo] =&gt; 1 [algoName] =&gt; bcrypt [options] =&gt; Array ( [cost] =&gt; 12 ) ) password_get_info() 返回信息 algo - 匹配密码算法的常量 algoName - 算法名字 options - 加密时候的可选参数 参考 PHP的几个常用加密函数","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"「代码复用」获取文件后缀","slug":"Reuse-Code-get-File-Ext","date":"2018-07-12T03:46:09.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/12/Reuse-Code-get-File-Ext/","link":"","permalink":"http://blog.caoxl.com/2018/07/12/Reuse-Code-get-File-Ext/","excerpt":"很有必要开启一个代码复用的专栏, 作为程序员切记重复造轮子","text":"很有必要开启一个代码复用的专栏, 作为程序员切记重复造轮子 直接上源码1234567891011&lt;?php// 获取扩展名function file_ext($file)&#123; return strtolower(pathinfo($file, 4)); // return strtolower(pathinfo($file,PATHINFO_EXTENSION));&#125;echo file_ext('./php.php');// print_r(pathinfo('./php.php'));// Array ( [dirname] =&gt; . [basename] =&gt; php.php [extension] =&gt; php [filename] =&gt; php ) strtolower - 将字符串转化为小写 pathinfo - 返回文件路径的信息 pathinfo语法1pathinfo(path, options) 参数 path - 必需. 规定要检查的路径 options - 可选. 规定要返回额数组元素.默认是all. 可能的值: PATHINFO_DIRNAME - 只返回 dirname PATHINFO_BASENAME - 只返回 basename PATHINFO_EXTENSION - 只返回 extension","categories":[{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/categories/代码复用/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/tags/代码复用/"}]},{"title":"页面静态化技术","slug":"Page-Static-Design","date":"2018-07-12T01:29:12.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/12/Page-Static-Design/","link":"","permalink":"http://blog.caoxl.com/2018/07/12/Page-Static-Design/","excerpt":"页面静态化的方法，分为两种，一种是伪静态，就是url重写，一种是你真的静态化。下面介绍PHP中页面静态化的方法。","text":"页面静态化的方法，分为两种，一种是伪静态，就是url重写，一种是你真的静态化。下面介绍PHP中页面静态化的方法。 什么是PHP静态化 ? PHP静态化的简单理解就是使网站生成页面以静态HTML的形式展现在访客面前，PHP静态化分纯静态化和伪静态化，两者的区别在于PHP生成静态页面的处理机制不同 PHP生成静态HTML页面的方法利用PHP模板生成静态页面PHP模板实现静态化非常方便，比如安装和使用PHP Smarty实现网站静态化。 使用PHP文件读写功能生成静态页面 static.php 1234567891011121314&lt;?php$out = \"&lt;html&gt;&lt;head&gt;&lt;title&gt;PHP静态化设计&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello STATIC&lt;/body&gt;&lt;/html&gt;\";$fp = fopen(\"static.html\", \"w\");if (!$fp) &#123; echo \"System Error.\";exit();&#125; else &#123; fwrite($fp, $out); fclose($fp); echo \"Success\";&#125; static.html 1234567891011&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;PHP静态化设计&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello Caoxl&lt;/body&gt;&lt;/html&gt; 使用PHP输出控制函数(Output Control)生成静态页面输出控制函数(Output Control) 也就是使用和控制缓存来生成静态HTML页面，也会使用到PHP文件读写函数。 1234567891011121314151617181920&lt;?phpob_start();echo \"&lt;html&gt;&lt;head&gt;&lt;title&gt;PHP静态化设计&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello OB&lt;/body&gt;&lt;/html&gt;\";$out = ob_get_contents();ob_end_clean();$fp = fopen(\"static.html\", \"w\");if (!$fp) &#123; echo \"System Error.\";exit();&#125; else &#123; fwrite($fp, $out); fclose($fp); echo \"Success\";&#125; PHP ob函数介绍 ob_start() - 打开缓冲区 ob_get_contents - 获取缓存中的内容 ob_get_clean - 获取内存中的数据并且清空 ob_end_clean - 清空内存数据 PHP生成静态页面的思路为: 首先开启缓存 然后输出了HTML内容（你也可以通过include将HTML内容以文件形式包含进来） 之后获取缓存中的内容，清空缓存后通过PHP文件读写函数将缓存内容写入到静态HTML页面文件中","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"静态化","slug":"静态化","permalink":"http://blog.caoxl.com/tags/静态化/"}]},{"title":"单元测试「PHPUnit」的使用","slug":"PHP-PHPUnit","date":"2018-07-11T08:17:45.000Z","updated":"2018-11-22T09:36:47.000Z","comments":true,"path":"2018/07/11/PHP-PHPUnit/","link":"","permalink":"http://blog.caoxl.com/2018/07/11/PHP-PHPUnit/","excerpt":"本文是在Laravel框架下使用PHPUnit进行单元测试","text":"本文是在Laravel框架下使用PHPUnit进行单元测试 为什么要单元测试 ？ 只要你想到输入一些东西到print语句或调试表达式中，就用测试代替它。 安装PHPUnit 使用 composer 方式安装 PHPUnit 1composer require --dev phpunit/phpunit 安装 Monolog日志包, 做phpunit测试记录日志使用 1composer require monolog/monolog PHPUnit简单用法单个文件测试创建目录 tests, 新建文件 StackTest.php, 编辑如下: 一般初始化Laravel框架就带有tests文件夹, 用于存放测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App\\tests;require_once __DIR__ . '/../vendor/autoload.php';define(\"ROOT_PATH\", dirname(__DIR__) . \"StackTest.php/\");use Monolog\\Logger;use Monolog\\Handler\\StreamHandler;use PHPUnit\\Framework\\TestCase;class StackTest extends TestCase&#123; public function testPushAndPop() &#123; $stack = []; $this-&gt;assertEquals(0, count($stack)); array_push($stack, 'foo'); // 添加日志文件, 如果没有安装monolog，则有关monolog的代码都可以注释掉 $this-&gt;Log()-&gt;error('hello', $stack); $this-&gt;assertEquals('foo', $stack[count($stack) - 1]); $this-&gt;assertEquals(1, count($stack)); $this-&gt;assertEquals('foo', array_pop($stack)); $this-&gt;assertEquals(0, count($stack)); &#125; public function Log() &#123; // create a log channel $log = new Logger('Tester'); $log-&gt;pushHandler(new StreamHandler(ROOT_PATH . 'storage/logs/app.log', Logger::WARNING)); $log-&gt;error('Error'); return $log; &#125;&#125; 代码解释: StackTest为测试类 StackTest 继承于 PHPUnit\\Framework\\TestCase 测试方法testPushAndPop(), 测试方法必须为public权限, 一般以test开头,或者你也可以选择给其加注释@test来表示 在测试方法内，类似于 assertEquals() 这样的断言方法用来对实际值与预期值的匹配做出断言。 命令行执行1phpunit命令 测试文件命名 例如:1234./vendor/bin/phpunit tests/StackTest.php// 或者可以省略文件后缀名./vendor/bin/phpunit tests/StackTest 执行结果: 12345678$ ./vendor/bin/phpunit tests/StackTest.phpPHPUnit 7.2.6 by Sebastian Bergmann and contributors.. 1 / 1 (100%)Time: 203 ms, Memory: 4.00MBOK (1 test, 5 assertions) 我们可以在app.log文件中查看我们打印的日志信息。 storage/logs/app.log 12[2018-07-11 08:45:24] Tester.ERROR: Error [] [][2018-07-11 08:45:24] Tester.ERROR: hello [\"foo\"] [] 类文件引入 Calculator.php 123456789&lt;?phpclass Calculator&#123; public function sum($a, $b) &#123; return $a + $b; &#125;&#125; 单元测试类: CalculatorTest.php 123456789101112131415161718&lt;?phpnamespace App\\tests;require_once __DIR__ . '/../vendor/autoload.php';require \"Calculator.php\";use PHPUnit\\Framework\\TestCase;class CalculatorTest extends TestCase&#123; public function testSum() &#123; $obj = new \\Calculator; $this-&gt;assertEquals(2, $obj-&gt;sum(1, 1)); &#125;&#125; 命令执行: 12345678$ ./vendor/bin/phpunit tests/CalculatorTestPHPUnit 7.2.6 by Sebastian Bergmann and contributors.. 1 / 1 (100%)Time: 185 ms, Memory: 4.00MBOK (1 test, 1 assertion) 如果我们把这里的断言故意写错，$this-&gt;assertEquals(1, $obj-&gt;sum(0, 0)); 12345678910111213141516$ ./vendor/bin/phpunit tests/CalculatorTestPHPUnit 7.2.6 by Sebastian Bergmann and contributors.F 1 / 1 (100%)Time: 194 ms, Memory: 4.00MBThere was 1 failure:1) App\\tests\\CalculatorTest::testSumFailed asserting that 2 matches expected 1.C:\\WWW\\Laravel\\tests\\CalculatorTest.php:16FAILURES!Tests: 1, Assertions: 1, Failures: 1. 会直接报出方法错误信息及行号，有助于我们快速找出bug 高级用法你是否已经厌烦了在每一个测试方法命名前面加一个test，是否因为只是调用的参数不同，却要写多个测试用例而纠结？我最喜欢的高级功能，现在隆重推荐给你，叫做框架生成器。 Calculator.php 12345678910&lt;?php class Calculator &#123; public function sum($a, $b) &#123; return $a + $b; &#125; &#125; ?&gt; 命令行启动测试用例，使用关键字 --skeleton 1./vendor/bin/phpunit --skeleton Calculator.php 执行结果: 123PHPUnit 7.2.6 by Sebastian Bergmann and contributors.Wrote test class skeleton for Calculator to CalculatorTest.php. 是不是很简单，因为没有测试数据，所以这里加测试数据，然后重新执行上边的命令 12345678910111213141516&lt;?php class Calculator &#123; /** * @assert (0, 0) == 0 * @assert (0, 1) == 1 * @assert (1, 0) == 1 * @assert (1, 1) == 2 */ public function sum($a, $b) &#123; return $a + $b; &#125; &#125; ?&gt; 原始类中的每个方法都进行@assert注解的检测。这些被转变为测试代码，像这样: 1234567/** * Generated from @assert (0, 0) == 0. */public function testSum() &#123; $obj = new Calculator; $this-&gt;assertEquals(0, $obj-&gt;sum(0, 0));&#125; 出现错误: unrecognized option --skeleton12wget https://phar.phpunit.de/phpunit-skelgen.pharphp phpunit-skelgen.phar 参考 PHPUnit中文网 PHPUnit中文文档 PHP单元测试框架PHPUnit的使用","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"PHPUnit","slug":"PHPUnit","permalink":"http://blog.caoxl.com/tags/PHPUnit/"}]},{"title":"Linux 压缩/解压缩","slug":"Linux-winRAR","date":"2018-07-11T01:25:57.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/11/Linux-winRAR/","link":"","permalink":"http://blog.caoxl.com/2018/07/11/Linux-winRAR/","excerpt":"Linux下的压缩解压缩命令集合","text":"Linux下的压缩解压缩命令集合 .tar tar是打包, 不是压缩! 打包1tar -cvf filename.tar DirName 解包1tar -xvf filename.tar .tar.gz 和 .gz压缩1tar -zcvf filename.tar.gz DirName 解压1tar -zxvf filename.tar.gz .gz压缩1gzip filename 解压1234gunzip filename.gz或gzip -d filename.gz .zip压缩1zip filename.zip DirName 解压1unzip filename.zip .rar压缩1rar a filename.rar DirName 解压1rar x filename.rar 常见问题使用rar遇到问题 报错: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file 出现这种情况的原因是，rar命令需要libstdc++的32位版本，系统应该只安装64位版本，可以通过rpm查看是否 123456789101112131415161718192021222324[root@izj6c6djex81rijczh0t8yz winrar]# rpm -ql libstdc++ | cat -n 1 /usr/lib64/libstdc++.so.6 2 /usr/lib64/libstdc++.so.6.0.19 3 /usr/share/gcc-4.8.2 4 /usr/share/gcc-4.8.2/python 5 /usr/share/gcc-4.8.2/python/libstdcxx 6 /usr/share/gcc-4.8.2/python/libstdcxx/__init__.py 7 /usr/share/gcc-4.8.2/python/libstdcxx/__init__.pyc 8 /usr/share/gcc-4.8.2/python/libstdcxx/__init__.pyo 9 /usr/share/gcc-4.8.2/python/libstdcxx/v6 10 /usr/share/gcc-4.8.2/python/libstdcxx/v6/__init__.py 11 /usr/share/gcc-4.8.2/python/libstdcxx/v6/__init__.pyc 12 /usr/share/gcc-4.8.2/python/libstdcxx/v6/__init__.pyo 13 /usr/share/gcc-4.8.2/python/libstdcxx/v6/printers.py 14 /usr/share/gcc-4.8.2/python/libstdcxx/v6/printers.pyc 15 /usr/share/gcc-4.8.2/python/libstdcxx/v6/printers.pyo 16 /usr/share/gcc-4.8.5 17 /usr/share/gdb 18 /usr/share/gdb/auto-load 19 /usr/share/gdb/auto-load/usr 20 /usr/share/gdb/auto-load/usr/lib64 21 /usr/share/gdb/auto-load/usr/lib64/libstdc++.so.6.0.19-gdb.py 22 /usr/share/gdb/auto-load/usr/lib64/libstdc++.so.6.0.19-gdb.pyc 23 /usr/share/gdb/auto-load/usr/lib64/libstdc++.so.6.0.19-gdb.pyo 说明没有安装32位的libstdc++版本，需要安全32位的，可以通过yum安装，先执行 123456789101112[root@izj6c6djex81rijczh0t8yz winrar]# yum list | grep libstdc++libstdc++.x86_64 4.8.5-28.el7_5.1 @updates libstdc++-devel.x86_64 4.8.5-28.el7_5.1 @updates compat-libstdc++-33.i686 3.2.3-72.el7 base compat-libstdc++-33.x86_64 3.2.3-72.el7 base libstdc++.i686 4.8.5-28.el7_5.1 updates libstdc++-devel.i686 4.8.5-28.el7_5.1 updates libstdc++-docs.x86_64 4.8.5-28.el7_5.1 updates libstdc++-static.i686 4.8.5-28.el7_5.1 updates libstdc++-static.x86_64 4.8.5-28.el7_5.1 updates 发现libstdc++.i686(注有的可能是i386,i586), 然后执行安装命令 123456789101112131415[root@izj6c6djex81rijczh0t8yz winrar]# yum -y install libstdc++.i686Running transaction Installing : libgcc-4.8.5-28.el7_5.1.i686 1/2 Installing : libstdc++-4.8.5-28.el7_5.1.i686 2/2 Verifying : libgcc-4.8.5-28.el7_5.1.i686 1/2 Verifying : libstdc++-4.8.5-28.el7_5.1.i686 2/2 Installed: libstdc++.i686 0:4.8.5-28.el7_5.1 Dependency Installed: libgcc.i686 0:4.8.5-28.el7_5.1 Complete!","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Linux 系统目录 (简易版)","slug":"Linux-Simple-Catalog","date":"2018-07-10T08:33:29.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/10/Linux-Simple-Catalog/","link":"","permalink":"http://blog.caoxl.com/2018/07/10/Linux-Simple-Catalog/","excerpt":"曾经做了一个详细的目录说明 Linux 系统中的目录","text":"曾经做了一个详细的目录说明 Linux 系统中的目录 目录结构 root / ~ 超级用户的家目录 1cd /root 相当于 cd ~ home 普通用户的家目录 bin 所有用户都可以执行的命令 sbin 只有root用户才可以执行的命令 etc 软件的配置文件 1/etc/init.d # 系统服务文件夹 usr 自定义安装的软件, 执行程序, 帮助手册 var 日志, 缓存 boot 启动文件, 包括linux内核, init进程镜像文件 tmp 临时目录 dev 硬盘设备文件 media 挂载光盘用的 mnt 空目录 proc 内存镜像文件 dev 存放设备节点 lib 存放核心系统程序需要的库文件 lib64 如果你使用的是X86_64的Linux系统, 那可能会有/lib64/目录产生 opt 用来安装“可选的”软件, srv service的缩写, 存储:网络服务启动后，这些服务所需要取用的数据目录,一般是空目录 lost+found 恢复一个损坏的文件系统时，会用到这个目录, 一般是空目录 sys 存储虚拟文件系统 run 某些程序或者服务启动后，会将他们的 PID 放置在这个目录下。 参考 linux各文件夹的作用 linux 目录结构及其含义","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Linux 下安装开发环境(多版本PHP)","slug":"Linux-env-install","date":"2018-07-10T01:09:44.000Z","updated":"2020-06-29T03:09:15.000Z","comments":true,"path":"2018/07/10/Linux-env-install/","link":"","permalink":"http://blog.caoxl.com/2018/07/10/Linux-env-install/","excerpt":"Linux下配置一个 PHP+Nginx+MySQL/MariaDB环境","text":"Linux下配置一个 PHP+Nginx+MySQL/MariaDB环境 编译安装多版本PHP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/bin/sh#编译安装多版本PHP, Nginx+PHP使用#定义函数，默认绿色输出 '#' 开头为红色function echocolor()&#123; [[ $1 = '#' ]] &amp;&amp; echo -e \"\\033[31m $* \\033[0m\" || echo -e \"\\033[32m $* \\033[0m\"&#125;#检测网络ping baidu.com -c 2 &amp;&gt;/dev/null || ping qq.com -c 2 &amp;&gt;/dev/null || &#123; echocolor '#' \"网络异常！\";exit; &#125;#设置yum 安装包不删除 目录 /var/cache/yum/#sed -i 's/keepcache=0/keepcache=1/g' /etc/yum.confechocolor '#安装需要的库'yum install epel-release -yyum install gcc bison bison-devel zlib-devel libmcrypt-devel mcrypt mhash-devel openssl-devel libxml2-devel libcurl-devel bzip2-devel readline-devel libedit-devel sqlite-devel jemalloc jemalloc-devel libjpeg-devel libpng-devel libicu-devel openldap-devel ftp -yechocolor \"#设置相关目录\"echocolor \"#下载目录\"read Ddirechocolor \"#安装版本\"read DverSdir=\"/usr/local/php/php$Dver\"echocolor \"#安装目录:\"echocolor \"$Sdir\"[ -d $Ddir ] || mkdir -p $Ddir[ -d $Sdir/etc ] || mkdir -p $Sdir/etc#[ -d $Sdir/apache/bin/apxs ] || mkdir -p $Sdir/apache/bin/apxs##下载echocolor \"#请输入下载链接\"read Durlwget -c $Durl -O $Ddir/php.tar.gzechocolor \"添加用户\"useradd -s /sbin/nologin -M wwwid wwwechocolor \"解压\"[ -e $Ddir/php.tar.gz ] &amp;&amp; &#123; tar xzvf $Ddir/php*.tar.gz -C $Ddir/;cd $Ddir/php*; &#125; || &#123; echocolor '#' \"$Ddir目录无php源码包\";exit ; &#125;# [ `uname -m` = \"x86_64\" ] &amp;&amp; LIB=/usr/lib64 || LIB=/usr/lib64# --with-apxs2=/usr/local/apache/bin/apxs #编译参数，apache+php使用make cleanechocolor 编译./configure \\--prefix=$Sdir/ \\--with-config-file-path=$Sdir/etc \\--enable-inline-optimization \\--disable-debug \\--disable-rpath \\--enable-shared \\--enable-opcache \\--enable-fpm \\--with-fpm-user=www \\--with-fpm-group=www \\--with-mysql=mysqlnd \\--with-mysqli=mysqlnd \\--with-pdo-mysql=mysqlnd \\--with-gettext \\--enable-mbstring \\--with-iconv \\--with-mcrypt \\--with-mhash \\--with-openssl \\--enable-bcmath \\--enable-soap \\--with-libxml-dir \\--enable-pcntl \\--enable-shmop \\--enable-sysvmsg \\--enable-sysvsem \\--enable-sysvshm \\--enable-sockets \\--with-curl \\--with-zlib \\--enable-zip \\--with-bz2 \\--enable-ftp \\--with-ldap-dir=/usr/lib \\--with-png-dir=/usr/lib \\--with-jpeg-dir=/usr/lib \\--with-readline[ $? = 0 ] || &#123; echocolor '#' \"编译出现问题 ！\";exit; &#125;echo 编译安装make -j4 make installmake cleanmake clean allecho #配置PHPcp php.ini-production $Sdir/etc/php.inicp $Sdir/etc/php-fpm.conf.default $Sdir/etc/php-fpm.confcp sapi/fpm/init.d.php-fpm $Sdir/bin/php-fpm-$Dvercp $Sdir/etc/php-fpm.d/www.conf.default $Sdir/etc/php-fpm.d/www.confchmod +x $Sdir/bin/php-fpm-$Dverln -s $Sdir/bin/php-fpm-$Dver /etc/init.d/php-fpm-$Dverln -s $Sdir/etc/php-fpm.conf /etc/php-fpm/php-fpm-$Dver.confln -s $Sdir/etc/php.ini /etc/php/php-$Dver.inichkconfig --add php-fpm-$Dverchkconfig php-fpm-$Dver onchkconfig --list php-fpm-$Dverechocolor #显示版本$Sdir/bin/php -vnetstat -antp|grep php-fpm-$Dverechocolor \"#php-$Dver已经安装完毕\" 安装PHP7.2输入示例: 123456789#设置相关目录 #下载目录 /download#安装版本 72#安装目录: /usr/local/php/php72 #请输入下载链接 http://cn2.php.net/get/php-7.2.7.tar.gz/from/this/mirror 说明 PHP安装包(tar.gz) 8.0: https://downloads.php.net/~pollita/php-8.0.0alpha1.tar.gz7.4: https://www.php.net/distributions/php-7.4.7.tar.gz7.2: http://cn2.php.net/get/php-7.2.7.tar.gz/from/this/mirror5.6: http://cn2.php.net/get/php-5.6.36.tar.gz/from/this/mirror 变量说明: Ddir: 下载目录 Dver: 安装版本 Sdir: 安装目录 Durl: 下载链接 下载过程输入: 设置目录 - 无需输入, 起提示作用 下载目录 - 输入下载目录 安装目录 - 输入安装目录 (默认前缀有php, 只需要输入类似56、71) 请输入下载链接 - 输入下载链接(tar.gz包), 选择自己需要的PHP版本 123456789101112#设置相关目录 #下载目录 /root/linux#安装版本 72#安装目录: /usr/local/php/php72 #请输入下载链接 http://cn2.php.net/get/php-7.2.7.tar.gz/from/this/mirror 源码解释12345678910111213141516171819202122232425262728293031323334353637383940echocolor 编译./configure \\--prefix=$Sdir/ \\ # 指定 php 安装目录--with-config-file-path=$Sdir/etc \\ # 指定 php.ini 位置--enable-inline-optimization \\ # 优化线程--disable-debug \\ # 关闭调试模式--disable-rpath \\ # 关闭额外的运行库文件--enable-shared \\--enable-opcache \\--enable-fpm \\ # 打上PHP-fpm 补丁后才有这个参数，CGI方式安装的启动程序--with-fpm-user=www \\--with-fpm-group=www \\--with-mysql=mysqlnd \\ # mysql 安装目录，对`mysql`的支持--with-mysqli=mysqlnd \\ # 指定`mysqli`位置--with-pdo-mysql=mysqlnd \\--with-gettext \\ # 打开gnu 的gettext 支持，编码库用到 --enable-mbstring \\ # 多字节，字符串的支持 --with-iconv \\ # 用于 PHP 编译时指定 iconv 在系统里的路径，否则会扫描默认路径--with-mcrypt \\ # mcrypt算法扩展--with-mhash \\ # mhash算法扩展--with-openssl \\ # openssl的支持，加密传输https时用到的--enable-bcmath \\ # 打开图片大小调整,用到zabbix监控的时候用到了这个模块--enable-soap \\--with-libxml-dir \\ # 打开libxml2库的支持--enable-pcntl \\ # freeTDS需要用到的，可能是链接mssql 才用到--enable-shmop \\ # 这样就使得你的PHP系统可以处理相关的IPC函数了--enable-sysvmsg \\ # 这样就使得你的PHP系统可以处理相关的IPC函数了--enable-sysvsem \\--enable-sysvshm \\--enable-sockets \\ # 打开 sockets 支持--with-curl \\ # 打开curl浏览工具的支持--with-zlib \\ # 打开zlib库的支持，用于http压缩传输--enable-zip \\ # 打开对zip的支持--with-bz2 \\ # 打开对bz2文件的支持--enable-ftp \\ # 打开ftp的支持--with-ldap-dir=/usr/lib \\--with-png-dir=/usr/lib \\--with-jpeg-dir=/usr/lib \\--with-readline[ $? = 0 ] || &#123; echocolor '#' \"编译出现问题 ！\";exit; &#125; 其他: 1234567891011121314--with-freetype-dir \\ # 打开对freetype字体库的支持--with-jpeg-dir \\ # 打开对jpeg图片的支持 --with-png-dir \\ # 打开对png图片的支持--with-curlwrappers \\ # 运用curl工具打开url流--with-gd \\ # 打开gd库的支持--enable-gd-native-ttf \\ # 支持TrueType字符串函数库--with-xmlrpc \\ # 打开xml-rpc的c语言--without-iconv \\ # 关闭iconv函数，字符集间的转换--with-ttf \\ # 打开freetype1.*的支持，可以不加了--with-xsl \\ # 打开XSLT 文件支持，扩展了libXML2库 ，需要libxslt软件 --with-pear \\ # 打开pear命令的支持，PHP扩展用的--enable-calendar \\ # 打开日历扩展功能 --enable-exif \\ # 图片的元数据支持--enable-magic-quotes \\ # 魔术引用的支持 CGI方式安装才用的参数 12345678910111213--enable-fastCGI \\ # 支持fastcgi方式启动PHP--enable-force-CGI-redirect \\ # 重定向方式启动PHP--with-ncurses \\ # 支持ncurses 屏幕绘制以及基于文本终端的图形互动功能的动态库--with-gmp \\ # 应该是支持一种规范--enable-dbase \\ # 建立DBA 作为共享模块--with-pcre-dir=/usr/local/bin/pcre-config # perl的正则库案安装位置--disable-dmalloc--with-gdbm # dba的gdbm支持--enable-sigchild--enable-sysvshm--enable-zend-multibyte \\ # 支持zend的多字节--enable-wddx--enable-soap 编译安装Nginx环境准备安装编译工具、依赖包12yum -y install gcc gcc-c++ autoconf automakeyum -y install zlib zlib-devel openssl openssl-devel pcre-devel 以上安装的是一些主要的依赖包，具体可根据自己情况或者报错信息提示安装或修改 新建匿名用户和用户组123sudo groupadd -r nginxsudo useradd -s /sbin/nologin -g nginx -r nginx Nginx编译安装下载源码包 建议从官网下载 1wget https://nginx.org/download/nginx-1.15.1.tar.gz # 版本自选 解压并编译 解压 1tar -zxvf nginx-1.15.1.tar.gz 配置 123456789101112131415161718./configure --prefix=/usr/local/nginx \\--pid-path=/var/run/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--with-http_ssl_module \\--with-http_dav_module \\--with-http_flv_module \\--with-http_realip_module \\--with-http_gzip_static_module \\--with-http_stub_status_module \\--with-mail \\--with-mail_ssl_module \\--with-debug \\--http-client-body-temp-path=/var/tmp/nginx/client \\--http-proxy-temp-path=/var/tmp/nginx/proxy \\--http-fastcgi-temp-path=/var/tmp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \\--http-scgi-temp-path=/var/tmp/nginx/scgi 配置正常的话可以看到这些信息 1234567891011121314151617181920Configuration summary + using system PCRE library + OpenSSL library is not used + md5: using system crypto library + sha1: using system crypto library + using system zlib library nginx path prefix: \"/usr/local/nginx\" nginx binary file: \"/usr/local/nginx/sbin/nginx\" nginx modules path: \"/usr/local/nginx/modules\" nginx configuration prefix: \"/etc/nginx\" nginx configuration file: \"/etc/nginx/nginx.conf\" nginx pid file: \"/usr/local/nginx/logs/nginx.pid\" nginx error log file: \"/usr/local/nginx/logs/error.log\" nginx http access log file: \"/usr/local/nginx/logs/access.log\" nginx http client request body temporary files: \"client_body_temp\" nginx http proxy temporary files: \"proxy_temp\" nginx http fastcgi temporary files: \"fastcgi_temp\" nginx http uwsgi temporary files: \"uwsgi_temp\" nginx http scgi temporary files: \"scgi_temp\" 以上编译参数只是配置了主要的东西，全部配置参数说明你可以通过这个命令查看: ./configure --help 编译并安装 1make &amp;&amp; make install 启动等命令,须进入到/usr/local/nginx/sbin目录下 启动: nginx 停止: nginx -s stop 重启: nginx -s reload 编译安装MySQL环境准备编译环境12yum install cmakeyum install –y openssl openssl-devel ncurses ncurses-devel boost-devel 其他可选准备1234567891011121314151617181920212223# 有旧版本的话,先卸载旧版本rpm -qa | grep mysql # 查看MySQL是否已经安装 (注意大小写，如果mysql 不行就换MySQL)[root@shuidianbang ~]# rpm -qa | grep mysqllibmysqlclient16-5.1.69-1.w6.x86_64mysql55w-5.5.59-1.w6.x86_64mysql55w-libs-5.5.59-1.w6.x86_64mysql55w-server-5.5.59-1.w6.x86_64[root@shuidianbang ~]# rpm -qa | grep MySQLperl-DBD-MySQL-4.013-3.el6.x86_64// 屏幕上将显示已安装的mysql包名如: mysql55w-5.5.59-1.w6.x86_64 ; rpm -e --nodeps mysql-server (nodeps表示强制删除)rpm -e --nodeps mysql# 建立用户、组groupadd -r mysqluseradd -r -g mysql -d /data/mysql -s /sbin/nologin mysql# 数据目录(个人习惯将MySQL数据目录改成/data/mysql,所以先准备好目录,在编译时指定该路径)mkdir /data/mysqlchown -R mysql:mysql /data/mysql 相关编译选项 完整的编译配置选项 安装时路径相关的配置 123-DCMAKE_INSTALL_PREFIX=/usr/local/mysql # 安装路径-DMYSQL_DATADIR=/data/mysql # MySQL的数据目录-DSYSCONFDIR=/etc # MySQL配置文件路径 存储引擎相关的配置 12345678910111213# 若要明确指定编译某引擎，可使用类似如下的选项：-DWITH_INNOBASE_STORAGE_ENGINE=1-DWITH_ARCHIVE_STORAGE_ENGINE=1-DWITH_BLACKHOLE_STORAGE_ENGINE=1-DWITH_FEDEFATED_STORAGE_ENGINE=1# 若要明确指定不编译某引擎，可使用类似如下的选项：-DWITHOUT_&lt;engine-name&gt;_ENGINE=1# 如-DWITHOUT_EXAMPLE_STORAGE_ENGINE=1-DWITHOUT_FEDERATED_STORAGE_ENGINE=1-DWITHOUT_PARTITION_STORAGE_ENGINE=1 其他配置项 12345678910111213-DMYSQL_TCP_PORT=3306-DMYSQL_UNIX_ADDR=/tmp/mysql.sock-DENABLED_LOCAL_INFILE=1-DEXTRA_CHARSETS=all-DDEFAULT_CHARSET=utf8-DDEFAULT_COLLATION=utf8_general_ci-DWITH_DEBUG=0-DENABLED_PROFILING=1-DWITH_READLINE=1-DWITH_SSL=system-DWITH_ZLIB=system-DWITH_LIBWRAP=0 编译安装 注意：如果多次编译不成功的话,更改配置后记得rm CMakeCache.txt清理临时文件 下载源码 123wget http://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.10.tar.gztar -xvf mysql-5.7.10.tar.gzcd mysql-5.7.10 编译安装 123456789101112131415161718cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ -DMYSQL_DATADIR=/data/mysql \\ -DSYSCONFDIR=/etc \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_ARCHIVE_STORAGE_ENGINE=1 \\ -DWITH_ARCHIVE_STORAGE_ENGINE=1 \\ -DWITH_READLINE=1 \\ -DWITH_SSL=system \\ -DWITH_ZLIB=system \\ -DWITH_LIBWRAP=0 \\ -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock \\ -DDEFAULT_CHARSET=utf8 \\ -DENABLE_DOWNLOADS=1 \\ -DDEFAULT_COLLATION=utf8_general_ci \\ -DWITH_BOOST=/usr/local/boost # -DDOWNLOAD_BOOST=1 \\ 如果没有boost-devel时可以加上该选项 make &amp;&amp; make install 修改属组和属主 1chown -R mysql:mysql /usr/local/mysql/ 配置和初始化初始化配置文件关于配置文件的一点说明: 众所周知,MySQL至关重要的配置文件就是my.cnf。 该文件可以存在多个,MySQL启动时候的搜寻路径如下: /etc/my.cnf /etc/mysql/my.cnf /${MYSQL_HOME}/my.cnf default-extra-file ~/my.cnf 对于配置文件搜寻顺序的说明: 即使是在第一个位置找到了配置文件，后续路径中的搜寻仍然会继续 如果找到多个配置文件，所有配置文件中的配置都将生效 如果在多个文件中找到了同一个配置，将使用最后一个配置 复制配置文件: 123456789cp support-files/my-default.cnf /etc/my.cnf# 注意--如果复制的配置文件中没有配置以下几项 请手动指定# 否则mysql服务启动会找不到目录# /etc/my.cnf[mysqld]basedir =/usr/local/mysqldatadir =/data/mysqlport =3306 将MySQL做成系统服务12345# support-files在安装目录和解压后的MySQL目录都有cp support-files/mysql.server /etc/init.d/mysqldchkconfig --add mysqldchkconfig --list mysqld 将MySQL加入环境变量123456789# 编辑/etc/profile.d/mysql.shvim /etc/profile.d/mysql.sh# 加入如下文件export MYSQL_HOME=/usr/local/mysqlexport PATH=$PATH:$MYSQL_HOME/bin# 使配置生效source /etc/profile.d/mysql.sh 启动MySQL 注意,在这一步可能会遇到很多问题,请确保权限正常 chown -R mysql:mysql /data/mysql/ chown -R mysql:mysql /usr/local/mysql chown -R mysql:mysql /usr/share/mysql/ 做成系统服务后直接启动即可 1service mysqld start root登录 12345678# 注意此处的密码是在初始化时生成的临时密码mysql -u root -p# 修改密码set password=password('新密码');# 刷新权限flush privileges; 编译安装MariaDB MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险 环境准备源码包下载 选择自己需要的版本: https://downloads.mariadb.org/ 这里使用:mariadb-10.2.16.tar.gz 编译环境及依赖关系12yum groupinstall -y Development Toolsyum -y install ncurses-devel zlib-devel 获取cmake: 12wget https://cmake.org/files/v3.12/cmake-3.12.0-rc3.tar.gztar -zxvf cmake-3.12.0-rc3.tar.gz -C /usr/local/ 编译安装: 12cd /usr/local/cmake-3.12.0/./configure 安装MariaDB1234567891011121314151617181920wget https://downloads.mariadb.org/interstitial/mariadb-10.2.16/source/mariadb-10.2.16.tar.gztar -zxvf mariadb-10.2.16.tar.gz -C /usr/local/mysqlcd /usr/local/mysqlcmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\-DSYSCONFDIR=/etc \\-DDEFAULT_CHARSET=utf8 \\-DDEFAULT_COLLATION=utf8_general_ci \\-DWITH_EXTRA_CHARSETS=all \\# 注:# 第一行是mysql主程序安装目录# 第二行是配置文件目录# 第三行默认字符集为utf8# 第四行默认的字符集校对规则# 第五行安装所有字符集# 最后make &amp;&amp; make install 创建mysql用户12useradd -M -s /sbin/nologin mysqlchown mysql:root /usr/local/mysql/ MariaDB配置文件创建及更改1234567891011121314151617# 复制配置文件cp support-files/my-medium.cnf /etc/my.cnf# 复制启动脚本cp support-files/mysql.server /etc/init.d/mysqld# 编辑配置文件,做以下修改vim /etc/my.conf # 指定数据库路径，不然无法启动mysqldatadir = /usr/local/mysql/data/# 设置后当创建数据库的表的时候表文件都会分离开，方便复制表，不开启创建的表都在一个文件innodb_file_per_table = on# 跳过名称反解，Mysql每次使用客户端链接时都会把ip地址反解成主机名skip_name_resolve = on 设置Mysql环境变量1echo \"export PATH=$PATH:/usr/local/mysql/bin\"&gt;&gt;/etc/profile 执行脚本初始化数据库1/usr/local/mysql/scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/mydata/ 安全初始化mysql及设定(前提先启动Mysql服务: service mysqld start)1/usr/local/mysql/bin/mysql_secure_installation 常见问题virtual memory exhausted: Cannot allocate memory发生该问题的原因是服务器的内存不够，从而导致编译失败。 而购买的Linux服务器，未给你分配虚拟内存，所以可以通过自行增加虚拟内存的方法予以解决 第一步: 1234[root@izj6c6djex81rijczh0t8yz ~]# free -m total used free shared buff/cache availableMem: 991 142 664 2 184 696Swap: 0 0 0 第二步: 1234567[root@izj6c6djex81rijczh0t8yz ~]# mkdir /usr/img/[root@izj6c6djex81rijczh0t8yz ~]# rm -rf /usr/img/swap[root@izj6c6djex81rijczh0t8yz ~]# dd if=/dev/zero of=/usr/img/swap bs=1024 count=20480002048000+0 records in2048000+0 records out2097152000 bytes (2.1 GB) copied, 36.0165 s, 58.2 MB/s 第三步: 1234567891011[root@izj6c6djex81rijczh0t8yz ~]# mkswap /usr/img/swap Setting up swapspace version 1, size = 2047996 KiBno label, UUID=b2d350d1-b5e4-427b-ae10-6a523121b6b9[root@izj6c6djex81rijczh0t8yz ~]# swapon /usr/img/swapswapon: /usr/img/swap: insecure permissions 0644, 0600 suggested.[root@izj6c6djex81rijczh0t8yz ~]# free -m total used free shared buff/cache availableMem: 991 144 67 2 779 688Swap: 1999 0 1999 使用完毕后可以关掉swap 12[root@izj6c6djex81rijczh0t8yz ~]# swapoff swap[root@izj6c6djex81rijczh0t8yz ~]# rm -f /usr/img/swap CMake Error at cmake/boost.cmake:81 (MESSAGE) 在/usr/local下创建一个名为boost的文件夹 1mkdir -p /usr/local/boost 进入这个新创建的文件夹然后下载boost 1wget http://www.sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz 解压 1tar -xvzf boost_1_59_0.tar.gz 继续cmake，添加上 1-DWITH_BOOST=/usr/local/boost \\ Starting MySQL..The server quit without updating PID file","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://blog.caoxl.com/tags/MariaDB/"}]},{"title":"技术 / 团队规范","slug":"Technical-Specigications","date":"2018-07-09T08:06:45.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/09/Technical-Specigications/","link":"","permalink":"http://blog.caoxl.com/2018/07/09/Technical-Specigications/","excerpt":"由于每个团队都不太一样, 所以这里的规范仅供参考","text":"由于每个团队都不太一样, 所以这里的规范仅供参考 服务器操作规范 账号 非必要情况下，以非root用户登录操作 多人操作环境，给定普通用户账号 口令 控制口令强度，修改频次为一个月或三个月 (当有拥有密码用户离职,立即更改口令) 磁盘使用 监控磁盘使用情况, 防止爆盘 重要文件管理 备份 添加不可更改位, 这样root用户修改也要指定参数 12chattr +i filename // 加 不可更改位 chattr -i filename // 删除 不可更改位 IP、端口 限制端口访问 禁止修改登录接口 禁止绑定任意程序到特定端口 进程不直接绑定在环路地址上面(0.0.0.0), 需要绑定内网IP 监控 开启监控, 比如开启监控日志, nginx默认自带开启日志 系统或软件从官方渠道下载 系统命令禁止修改,如rm、mv 访问控制 禁用目录浏览、敏感文件数据禁止放在web目录下面 相关操作规范 服务器 危险操作前一定要备份 数据库 绑定内网ip 设置登录密码 删除默认数据及用户 新建mysql用户和组,相关权限给到mysql用户 库、表级别操作慎重(例如:drop、truncate 命令) 危险操作 rm -rf dir/filename 此命令强制删除文件或目录，操作前务必备份 cp -r kill -9 pid 此命令强制杀掉正在运行的进程，使当前进程对应程序立即退出，一般会丢失数据 数据库相关 (delete，drop，truncate) 操作前一定备份数据，操作时最好有人确认 自动化 重要文件或数据库备份自动化 可通过crontab任务来定时执行 服务或程序本身属于定时任务，则对于重要数据、文件在服务或程序内部自行实现 团队编码规范 详细规范参考 PSR – PHP 标准规范 这里列举一些: [强制] 采用 4 个空格缩进而不是 2 个空格或 tab 字符 [强制] 所有的块状结构都要缩进 [强制] switch 语句缩进要合理 [强制] 注释时，注释符两边的空白符必不可少 [强制] 任何保留字（如if, while, for等等）与紧随其后的左括号之间要有一个空格 [强制] 任何保留字(如else、catch等)与其前面的右大括号之间要有一个空格 [强制] 任何左大括号 { 前必须加一个空格 [强制] 在任何二元或三元运算符的两侧必须有空格 12345// goodint i = 1 + 2;// badint i = 1+2; [强制] 一元运算符与操作对象之间不允许有空格 123456789// goodif (!isOk) &#123;&#125;i++;// badif (! isOk) &#123;&#125;i ++; [强制] 在 ,、:、; 及右括号 ) 后必须空格 123for (int i = 0; i &lt; 100; i++) &#123;&#125;int i = (int) 3.5f; [强制] 行尾不得有多余的空格 [强制] 本规范没有要求的空格不要随便乱加 错误例子: 1234567891011// goodvoid foo(int i) &#123;&#125;// badvoid foo (int i) &#123;&#125;// badvoid foo( int i) &#123;&#125;// badvoid foo(int i ) &#123;&#125; [强制] 列限制：80、100 还是 120？ 一个项目可以选择一行80个字符或100个字符的列限制。 我推荐 80 个字符。 任何一行如果超过这个字符数限制，必须换行。 [强制] 如果在非赋值运算符处断开，那么在该符号前断开 1234567// goodint i = 1 + 2 + 3 + ... + 1000000 + 1000001; // badint i = 1 + 2 + 3 + ... + 1000000 + 1000001; [强制] 如果在赋值运算符处断开，通常的做法是在该符号后断开 123456// good，虽然在这里没必要换行int i = 100000000;// badint i = 100000000; [强制] 非空块得换行遵守 K &amp; R 风格 左大括号前不换行 左大括号后换行 右大括号前换行 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号,, 则不换行。 [强制] 类名、接口名以 UpperCamelCase 风格编写 12345// goodclass Foo &#123;...&#125;// badclass foo &#123;...&#125; [强制] 测试类的命名以它要测试的类的名称开始，以 Test 结束 1234class HashTest &#123;&#125;HashIntegrationTest &#123;&#125; [强制] 常量名以 CONSTANT_CASE 风格编写 全部字母大写, 用下划线分隔单词。 [强制] 常量必须用常量修饰符修饰 12345// goodfinal int MAX_COUNT = 99;// badint int MAX_COUNT = 99; [强制] 非常量字段名、参数名、局部变量名以 lowerCamelCase 风格编写 版本控制规范语义化版本版本格式: 1主版本号.次版本号.修订号 版本号递增规则如下: 主版本号：当你做了不兼容的 API 修改 次版本号：当你做了向下兼容的功能性新增 修订号：当你做了向下兼容的问题修正。 大中小版本版本号希望遵循大中小版本号编制： X.0为大版本改版上线; X.X.0为小版本优化升级; X.X.X为同版本的bug修复更新; 比如:blog2.0 为博客系统大改版V2.0的象征;blog2.1 为博客系统小版本升级V2.1的象征blog2.1.1为博客系统同版本bug修复优化的信号。 参考 语义化版本 2.0.0 版本命名及限定规则详解","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"技术规范","slug":"技术规范","permalink":"http://blog.caoxl.com/tags/技术规范/"},{"name":"团队规范","slug":"团队规范","permalink":"http://blog.caoxl.com/tags/团队规范/"},{"name":"开发规范","slug":"开发规范","permalink":"http://blog.caoxl.com/tags/开发规范/"}]},{"title":"Laravel / Lumen 生命周期","slug":"Laravel-Lumen-Life","date":"2018-07-06T03:36:13.000Z","updated":"2019-08-22T03:57:29.000Z","comments":true,"path":"2018/07/06/Laravel-Lumen-Life/","link":"","permalink":"http://blog.caoxl.com/2018/07/06/Laravel-Lumen-Life/","excerpt":"当我们在决定使用某项技术的时候，除了需要了解它能「做什么」，其实还应当研究它是「怎么做的」。","text":"当我们在决定使用某项技术的时候，除了需要了解它能「做什么」，其实还应当研究它是「怎么做的」。 Laravel 生命周期 以下所有是基于 Laravel-5.6.* Laravel 的生命周期从public\\index.php开始，从public\\index.php结束。 生命周期始末12345678910111213141516171819&lt;?php// 第一阶段require __DIR__.'/../vendor/autoload.php';// 第二阶段$app = reuqire_once __DIR__.'/../bootstrap/app.php';$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);// 第三阶段$response = $kernel-&gt;handle( $request - Illuminate\\Http\\Request::capture());// 发送响应$response-&gt;send();// 其它$kernel-&gt;terminate($request, $response); 不妨再详细一点第一步: 加载项目依赖 现代 PHP 依赖于 Composer 包管理器，入口文件通过引入由 Composer 包管理器自动生成的类加载程序，可以轻松注册并加载项目所依赖的第三方组件库。 所有组件的加载工作，仅需一行代码即可完成: 1require __DIR__.'/../vendor/autoload.php'; 第二步: 创建Laravel应用实例下面是 bootstrap/app.php 的代码，包含两个主要部分「创建应用实例」和「绑定内核至 APP 服务容器」: 12345678910111213141516171819202122232425&lt;?php// 第一部分: 创建应用实例$app = new Illuminate\\Foundation\\Application( realpath(__DIR__.'/../'));// 第二部分: 完成内核绑定$app-&gt;singleton( Illuminate\\Contracts\\Http\\Kernel::class, App\\Http\\Kernel::class);$app-&gt;singleton( Illuminate\\Contracts\\Console\\Kernel::class, App\\Console\\Kernel::class);// 第三部分: 注册异常处理$app-&gt;singleton( Illuminate\\Contracts\\Debug\\ExceptionHandler::class, App\\Exceptions\\Handler::class);return $app; 创建应用实例创建应用实例即实例化 Illuminate\\Foundation\\Application 这个服务容器，后续我们称其为 APP 容器 在创建 APP 容器主要会完成: 注册应用的基础路径并将路径绑定到 APP 容器 注册基础服务提供者至 APP 容器 注册核心容器别名至 APP 容器 等基础服务的注册工作。 123456789101112public function __construct($basePath = null)&#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases();&#125; 内核绑定Laravel 会依据 HTTP 请求的运行环境的不同，将请求发送至相应的内核: HTTP 内核 或 Console 内核。无论 HTTP 内核还是 Console 内核,它们的作用都是是接收一个 HTTP 请求，随后返回一个响应，就是这么简单。 1234567891011// Http$app-&gt;singleton( Illuminate\\Contracts\\Http\\Kernel::class, App\\Http\\Kernel::class);// Console$app-&gt;singleton( Illuminate\\Contracts\\Console\\Kernel::class, App\\Console\\Kernel::class); 认识一下两个内核请求被送到HTTP内核或Console内核, 这取决于进入应用的请求类型 取决于是通过浏览器请求还是通过控制台请求, 这里我们主要通过浏览器请求. HTTP内核的标志性方法handle处理的逻辑相当简单: 获取一个 Request,返回一个Response,把该内核想象作一个代表整个应用的大黑盒子, 输入HTTP请求, 返回HTTP响应. HTTP 12345678protected $bootstrappers = [ \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class, \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class, \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class, \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class, \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class, \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,]; Console 123456789protected $bootstrappers = [ \\Illuminate\\Foundation\\Bootstrap\\LoadEnvironmentVariables::class, \\Illuminate\\Foundation\\Bootstrap\\LoadConfiguration::class, \\Illuminate\\Foundation\\Bootstrap\\HandleExceptions::class, \\Illuminate\\Foundation\\Bootstrap\\RegisterFacades::class, \\Illuminate\\Foundation\\Bootstrap\\SetRequestForConsole::class, \\Illuminate\\Foundation\\Bootstrap\\RegisterProviders::class, \\Illuminate\\Foundation\\Bootstrap\\BootProviders::class,]; 注意顺序:Facades 先于 ServiceProviders, Facades也是重点,后面说.这里简单提一下,注册Facades就是注册config\\app.php中的aliases数组, 你使用的很多,如:Auth, Cache, DB等等都是Facades, 而ServiceProviders的register方法永远先于boot方法执行, 以免产生boot方法依赖某个实例而该实例还未注册的现象 HTTP内核还定义了一系列所有请求在处理前需要经过的HTTP中间件, 这些中间件处理HTTP会话的读写、判断应是否处于维护模式、验证CSRF令牌等等. 第三步: 接收请求并响应在完成创建 APP 容器后即进入了第三个阶段 「接收请求并响应」。 「接收请求并响应」 有关代码如下: 1234567$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture());$response-&gt;send(); 解析内核实例在第二步我们已经将 HTTP 内核 和 Console 内核 绑定到了 APP 容器，使用时通过 APP 容器 的 make() 方法将内核解析出来，解析的过程就是内核实例化的过程。 1$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class); 内核实例化时它的内部究竟又做了哪些操作呢？进一步挖掘 Illuminate\\Foundation\\Http\\Kernel 内核的 __construct(IlluminateContractsFoundationApplication $app, \\Illuminate\\Routing\\Router $router) 构造方法,它接收 APP 容器 和 路由器 两个参数。 在实例化内核时，构造函数内将在 HTTP 内核定义的「中间件组」注册到 路由器，注册完后就可以在实际处理 HTTP 请求前调用这些「中间件」实现 过滤 请求的目的。 123456789101112131415public function __construct(Application $app, Router $router)&#123; $this-&gt;app = $app; $this-&gt;router = $router; $router-&gt;middlewarePriority = $this-&gt;middlewarePriority; foreach ($this-&gt;middlewareGroups as $key =&gt; $middleware) &#123; $router-&gt;middlewareGroup($key, $middleware); &#125; foreach ($this-&gt;routeMiddleware as $key =&gt; $middleware) &#123; $router-&gt;aliasMiddleware($key, $middleware); &#125;&#125; middlewareGroup 1234567891011121314/** * Register a group of middleware. * 注册中间件组 * * @param string $name * @param array $middleware * @return $this */public function middlewareGroup($name, array $middleware)&#123; $this-&gt;middlewareGroups[$name] = $middleware; return $this;&#125; aliasMiddleware 1234567891011121314/** * Register a short-hand name for a middleware. * 注册中间件别名 * * @param string $name * @param string $class * @return $this */public function aliasMiddleware($name, $class)&#123; $this-&gt;middleware[$name] = $class; return $this;&#125; 处理HTTP请求 之前的所有处理，基本都是围绕在配置变量、注册服务等运行环境的构建上，构建完成后才是真刀真枪的来处理一个「HTTP 请求」。 处理请求实际包含两个阶段: 创建请求实例 处理请求 12345// 处理请求$response = $kernel-&gt;handle( // 创建请求实例 $request = Illuminate\\Http\\Request::capture();); 创建请求实例请求实例 Illuminate\\Http\\Request 的 capture() 方法内部通过 Symfony 实例创建一个 Laravel 请求实例,这样我们就可以获取到用户请求报文的相关信息了 12345678910111213141516171819202122232425262728293031323334353637/** * Create a new Illuminate HTTP request from server variables. * * @return static */public static function capture()&#123; static::enableHttpMethodParameterOverride(); return static::createFromBase(SymfonyRequest::createFromGlobals());&#125;/** * Create an Illuminate request from a Symfony instance. * * @param \\Symfony\\Component\\HttpFoundation\\Request $request * @return \\Illuminate\\Http\\Request */public static function createFromBase(SymfonyRequest $request)&#123; if ($request instanceof static) &#123; return $request; &#125; $content = $request-&gt;content; $request = (new static)-&gt;duplicate( $request-&gt;query-&gt;all(), $request-&gt;request-&gt;all(), $request-&gt;attributes-&gt;all(), $request-&gt;cookies-&gt;all(), $request-&gt;files-&gt;all(), $request-&gt;server-&gt;all() ); $request-&gt;content = $content; $request-&gt;request = $request-&gt;getInputSource(); return $request;&#125; 处理请求请求处理发生在 HTTP内核的handle()方法中 12345678910111213141516171819202122232425262728/** * Handle an incoming HTTP request. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */ public function handle($request) &#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; catch (Exception $e) &#123; $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); &#125; catch (Throwable $e) &#123; $this-&gt;reportException($e = new FatalThrowableError($e)); $response = $this-&gt;renderException($request, $e); &#125; $this-&gt;app['events']-&gt;dispatch( new Events\\RequestHandled($request, $response) ); return $response;&#125; handle() 方法接收一个HTTP请求, 并最终生成一个HTTP响应. 继续深入到处理 HTTP 请求的方法 $this-&gt;sendRequestThroughRouter($request) 内部。 $this-&gt;sendRequestThroughRouter($request) 12345678910111213141516171819/** * Send the given request through the middleware / router. * * @param \\Illuminate\\Http\\Request $request * @return \\Illuminate\\Http\\Response */protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 将发现这段代码没有一行废话，它完成了大量的逻辑处理: 首先, 将$request实例注册到APP容器供后续使用 之后, 清除之前$request实例缓存 然后, 启动「引导程序」 最后, 发送请求至路由 启动 「引导程序」 下面看看:$this-&gt;bootstrap(); 在 $this-&gt;bootstrap(); 方法内部有实际调用「引导程序」，而 bootstrap() 实际调用的是 APP 容器的 bootstrapWith(),来看看 123456789101112131415161718192021/** * Bootstrap the application for HTTP requests. * * @return void */public function bootstrap()&#123; if (! $this-&gt;app-&gt;hasBeenBootstrapped()) &#123; $this-&gt;app-&gt;bootstrapWith($this-&gt;bootstrappers()); &#125;&#125;/** * Get the bootstrap classes for the application. * * @return array */protected function bootstrappers()&#123; return $this-&gt;bootstrappers;&#125; 最终还是要看 Illuminate\\Foundation\\Application 的 bootstrapWith() 方法究竟如何来启动这些引导程序的。 这里 按 CTRL + 鼠标左键追踪不到, 具体位置如下 \\vendor\\laravel\\framework\\src\\Illuminate\\Foundation\\Application.php 123456789101112131415161718/** * Run the given array of bootstrap classes. * * @param array $bootstrappers * @return void */public function bootstrapWith(array $bootstrappers)&#123; $this-&gt;hasBeenBootstrapped = true; foreach ($bootstrappers as $bootstrapper) &#123; $this['events']-&gt;fire('bootstrapping: '.$bootstrapper, [$this]); $this-&gt;make($bootstrapper)-&gt;bootstrap($this); $this['events']-&gt;fire('bootstrapped: '.$bootstrapper, [$this]); &#125;&#125; 这里可以看到在 APP 容器内, 惠先解析对应的 「引导程序」 (即实例化), 随后调用 「引导程序」的bootstrap()完成 「引导程序」来看看其内部的启动原理. 发送请求至路由完成「引导程序」启动操作后，随机进入到请求处理阶段。 12345678910protected function sendRequestThroughRouter($request)&#123; ... // 发送请求至路由 return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 在 「发送请求至路由」这行代码中，完成了： 管道（pipeline）创建 将 $request 传入管道 对 $request 执行「中间件」处理 实际的请求处理四个不同的操作。 传递给路由是通过 Pipeline（管道）来传递的，但是Pipeline有一堵墙，在传递给路由之前所有请求都要经过，这堵墙定义在app\\Http\\Kernel.php中的$middleware数组中，没错就是中间件，默认有一个CheckForMaintenanceMode中间件，用来检测你的网站是否暂时关闭。这是一个全局中间件，所有请求都要经过，你也可以添加自己的全局中间件。 那么，究竟一个请求是如何被处理的呢？ 12345678910111213/** * Get the route dispatcher callback. * * @return \\Closure */protected function dispatchToRouter()&#123; return function ($request) &#123; $this-&gt;app-&gt;instance('request', $request); return $this-&gt;router-&gt;dispatch($request); &#125;;&#125; 通过 「解析内核实例」章节，可知我们已经将 Illuminate\\Routing\\Router 对象赋值给 $this-&gt;router 属性 通过 router 实例的 disptach() 方法去执行 HTTP 请求，在它的内部会完成如下处理： 查找对应的路由实例 通过一个实例盏运行给定的路由 运行在routes/web.php配置的匹配到的控制器或匿名函数 返回响应结果 执行 $route-&gt;run() 的方法定义在 Illuminate\\Routing\\Route 类中，最终执行「在 routes/web.php 配置的匹配到的控制器或匿名函数」: 12345678910111213141516171819/** * Run the route action and return the response. * * @return mixed */public function run()&#123; $this-&gt;container = $this-&gt;container ?: new Container; try &#123; if ($this-&gt;isControllerAction()) &#123; return $this-&gt;runController(); &#125; return $this-&gt;runCallable(); &#125; catch (HttpResponseException $e) &#123; return $e-&gt;getResponse(); &#125;&#125; 这部分如果路由的实现是一个控制器，会完成控制器实例化并执行指定方法；如果是一个匿名函数则直接调用这个匿名函数。 其执行结果会通过 Illuminate\\Routing\\Router::prepareResponse($request, $response) 生一个响应实例并返回。 至此，Laravel 就完成了一个 HTTP 请求的请求处理。 发送响应发送响应由 Illuminate\\Http\\Response 父类 Symfony\\Component\\HttpFoundation\\Response 中的 send() 方法完成 123456789101112131415161718/** * Sends HTTP headers and content. * * @return $this */public function send()&#123; $this-&gt;sendHeaders(); // 发送响应头部信息 $this-&gt;sendContent(); // 发送报文主题 if (function_exists('fastcgi_finish_request')) &#123; fastcgi_finish_request(); &#125; elseif (!\\in_array(PHP_SAPI, array('cli', 'phpdbg'), true)) &#123; static::closeOutputBuffers(0, true); &#125; return $this;&#125; 终止程序 程序终止, 完成终止中间件的调用 Illuminate\\Foundation\\Http\\Kernel.php 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Call the terminate method on any terminable middleware. * * @param \\Illuminate\\Http\\Request $request * @param \\Illuminate\\Http\\Response $response * @return void */public function terminate($request, $response)&#123; $this-&gt;terminateMiddleware($request, $response); $this-&gt;app-&gt;terminate();&#125;/** * Call the terminate method on any terminable middleware. * 终止中间件 * * @param \\Illuminate\\Http\\Request $request * @param \\Illuminate\\Http\\Response $response * @return void */protected function terminateMiddleware($request, $response)&#123; $middlewares = $this-&gt;app-&gt;shouldSkipMiddleware() ? [] : array_merge( $this-&gt;gatherRouteMiddleware($request), $this-&gt;middleware ); foreach ($middlewares as $middleware) &#123; if (! is_string($middleware)) &#123; continue; &#125; list($name) = $this-&gt;parseMiddleware($middleware); $instance = $this-&gt;app-&gt;make($name); if (method_exists($instance, 'terminate')) &#123; $instance-&gt;terminate($request, $response); &#125; &#125;&#125; 总结 在 「创建 Laravel 应用实例」时不仅会注册项目基础服务、注册项目服务提供者别名、注册目录路径等在内的一系列注册工作；还会绑定 HTTP 内核及 Console 内核到 APP 容器， 同时在 HTTP 内核里配置中间件和引导程序。 进入 「接收请求并响应」里，会依据运行环境从 APP 容器 解析出 HTTP 内核或 Console 内核。如果是 HTTP 内核，还将把「中间件」及「引导程序」注册到 APP 容器。 所有初始化工作完成后便进入「处理 HTTP 请求」阶段。 一个 Http 请求实例会被注册到 APP 容器，通过启动「引导程序」来设置环境变量、加载配置文件等等系统环境配置; 随后请求被分发到匹配的路由，在路由中执行「中间件」以过滤不满足校验规则的请求，只有通过「中间件」处理的请求才最终处理实际的控制器或匿名函数生成响应结果。 最后发送响应给用户，清理项目中的中间件，完成一个 「请求」 - 「响应」 的生命周期，之后我们的 Web 服务器将等待下一轮用户请求。 Lumen 生命周期 Lumen 被称为简洁版 Laravel, 但是还是有很多差异的! 程序入口 public/index.php 加载bootstrap/app.php 1$app = require __DIR__.'/../bootstrap/app.php'; 执行容器的run() 1$app-&gt;run(); bootstrap/app.php中的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phprequire_once __DIR__.'/../vendor/autoload.php';try &#123; (new Dotenv\\Dotenv(__DIR__.'/../'))-&gt;load();&#125; catch (Dotenv\\Exception\\InvalidPathException $e) &#123; //&#125;$app = new Laravel\\Lumen\\Application( realpath(__DIR__.'/../'));$app-&gt;withFacades();$app-&gt;withEloquent();$app-&gt;singleton( Illuminate\\Contracts\\Debug\\ExceptionHandler::class, App\\Exceptions\\Handler::class);$app-&gt;singleton( Illuminate\\Contracts\\Console\\Kernel::class, App\\Console\\Kernel::class);$app-&gt;middleware([ App\\Http\\Middleware\\ExampleMiddleware::class]);$app-&gt;routeMiddleware([ 'auth' =&gt; App\\Http\\Middleware\\Authenticate::class,]);$app-&gt;register(App\\Providers\\AppServiceProvider::class);$app-&gt;register(App\\Providers\\AuthServiceProvider::class);$app-&gt;register(App\\Providers\\EventServiceProvider::class);$app-&gt;router-&gt;group([ 'namespace' =&gt; 'App\\Http\\Controllers',], function ($router) &#123; require __DIR__.'/../routes/web.php';&#125;);return $app; 说明: require_once __DIR__.&#39;/../vendor/autoload.php; 加载vendor目录自动加载文件; 这是composer默认自动加载文件 ()new Dotnev\\Dotenv(__DIR__.&#39;/../))-&gt;load(); 加载.env配置; Lumen采用.env接管配置, 此处进行配置加载 $app = new Laravel\\Lumen\\Application(); 生成容器$app; 其实Laravel/Lumen的核心就是容器, 再看Application源码也是继承了Container $app-&gt;withFacades(); 启用Facades特性; Lumen默认是禁用了Facades特性, 取消注释则启用. $app-&gt;withEloquent(); 启用Eloquent特性; Lumen默认禁用了Eloquent的ORM支持, **作者说是给用户自行选择不同ORM的权利 $app-&gt;configure(&#39;app&#39;); 加载配置文件; 如果有自定义的配置文件, 则需要在此进行加载. $app-&gt;singleton(); 注册容器绑定; 看过源码singleton和bind的区别就是前者内部调用了bind, 且第三个参数设为true, 意思是共享、独一的对象，也就是单例模式. $app-&gt;middleware(); 注册中间件; 根据需要添加或去除注释启用 $app-&gt;register(App\\Providers\\LogServiceProvider::class); 注册ServiceProvider; Laravel/Lumen的很大一部分特性是依赖ServiceProvider实现的 $app-&gt;group(); 加载路由文件; 这里可以再跟下group()的实现, 在vendor/laravel/lumen-framework/src/Routing/Router.php return $app; 返回容器$app Laravel/Lumen 容器 Facades模式 中文译名: 外观模式、门面模式主要特性: 屏蔽内部实现, 开发接口供外部使用, 提高模块抽离 Laravel的Facades也是在框架级提供抽象调用, 从而是开发者无需关心内容实现. Facades的理解: 别名, 首先通过class_alias将DB、Log、Cache等关键词映射为不同的Facades类 1class_alias('Illuminate\\Support\\Facades\\Cache', 'Cache'); 不同Facades子类返回容器内注册服务的关键词db、log、cache等 vendor/illuminate/support/Facades/ 123456789101112class Cache extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'cache'; &#125;&#125; 通过绑定函数,向容器注册或绑定ServiceProvider /vendor/laravel/lumen-framework/src/Application.php 123456789protected function registerCacheBindings()&#123; $this-&gt;singleton('cache', function () &#123; return $this-&gt;loadComponent('cache', 'Illuminate\\Cache\\CacheServiceProvider'); &#125;); $this-&gt;singleton('cache.store', function () &#123; return $this-&gt;loadComponent('cache', 'Illuminate\\Cache\\CacheServiceProvider', 'cache.store'); &#125;);&#125; Facades主要依赖Service Container和Service Provider实现 推荐一篇文章对容器介绍很全面: laravel 学习笔记 —— 神奇的服务容器 Service Container其实就是$app, 它是全局的一个容器，是Lumen的核心。 容器(Service Container)实现: vendor/laravel/lumen-framework/src/Application.php 123456789101112131415161718class Application extends Container&#123; use Concerns\\RoutesRequests, Concerns\\RegistersExceptionHandlers; public function register($provider) &#123;&#125; public function make($abstract, array $parameters = []) &#123;&#125; public function configure($name) &#123;&#125; public function withFacades($aliases = true, $userAliases = []) &#123;&#125; public function withAliases($userAliases = []) &#123;&#125; public function withEloquent() &#123;&#125; protected function registerCacheBindings() &#123;&#125; protected function registerDatabaseBindings() &#123;&#125; protected function registerEncrypterBindings() &#123;&#125; protected function registerLogBindings() &#123;&#125; ... // 各种`Service Provider`的绑定 ...&#125; Service Provider向容器提供不同的服务, 通过register函数向容器中注入类实例, 从而实现DI(依赖注入), 是一种IOC的实现方式, 不同服务的ServiceProvider分布在不同额服务子目录下 不同服务的ServiceProvider分布在不同的服务子目录下: cache: vendor/illuminate/cache/CacheServiceProviders.php db: vendor/illuminate/database/DatabaseServiceProvider.php queue: vendor/illminate/queue/QueueServiceProvider.php 不同的ServiceProvider都继承ServiceProvider 重写register()方法 $defer变量表征是否延迟加载 providers()方法返回该ServiceProvider可向容器提供的所有服务列表 参考 深度挖掘 Laravel 生命周期 Laravel 的生命周期– 该Laravel版本较低 laravel 学习笔记 —— 神奇的服务容器","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"PHP 生命周期","slug":"PHP-life","date":"2018-07-06T03:36:00.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/07/06/PHP-life/","link":"","permalink":"http://blog.caoxl.com/2018/07/06/PHP-life/","excerpt":"想做一些关于框架的生命周期的探讨, 又一想, 在那之前很有必要做一下PHP生命周期的功课","text":"想做一些关于框架的生命周期的探讨, 又一想, 在那之前很有必要做一下PHP生命周期的功课 SAPI: 一切的开始什么是SAPI ? 为什么先讲这个 ? 看下图! SAPI(Server Application Programming Interface 服务器端应用编程端口) is an application programming interface (API)provided by the web server to help other developers in extending the web server capabilities. SAPI是一个用来帮助其他开发程序扩展web服务器功能的应用程序接口(api) 它将外部条件抽象,为内部的PHP提供一套固定统一的接口,使得PHP自身实现能够不受外部环境影响，保持一定的独立性。 PHP中常用的SAPI有cli(命令行模式，单进程)、php-fpm、CGI、Apache… 有点像策略模式,使用相同的接口，但是实现会略有不同。 深入理解Zend SAPIs(Zend SAPI Internals) PHP的启动和终止请求之前的开始阶段 MINIT: 模块初始化阶段, 初始化一些扩展、常量、类、资源、等所有被php脚本用到的东西. (常驻内存, 可以被所有请求使用) 12345PHP_MINIT_FUNCTION(myphp_extentsion)&#123; // 注册常量或者类等初始化操作 return SUCCESS;&#125; PRINT: 模块激活阶段, PHP惠调用所有模块的RINIT函数, 在这个阶段各个模块也可以执行一些相关的操作, 比如初始化本次请求使用到的变量 123456PHP_RINIT_FUNCTION(myphp_extension)&#123; // 例如记录请求开始时间 // 随后在请求结束的时候记录结束时间, 这样我们就能够记录下处理请求所花费的时间了 return SUCCESS;&#125; 请求之后的结束阶段 RSHUTDOWN: 这个页面请求执行完毕，或者被用户给die（exit）了， 这时PHP会启动回收程序，回收本次请求使用的资源。这次会执行所有已加载扩展的RSHUTDOWN（俗称Request Shutdown）方法， 这时候扩展可以利用内核中的变量表等做的一些事情。因为PHP一旦把所有扩展的RSHUTDOWN方法执行完，便会释放掉这次请求使用过的所有资源，比如变量表的所有变量、所有在这次请求中申请的内存等 12345PHP_RSHUTDOWN_FUNCTION(myphp_extension)&#123; // 例如记录请求结束时间, 并把相应的信息写入到日志文件中 return SUCCESS;&#125; MSHUTDOWN: PHP执行所有扩展的MSHUDOWN, 释放资源. 12345PHP_MSHUTDOWN_FUNCTION(extension_name)&#123; // 自由处理程序和持久内存等 return SUCCESS;&#125; PHP的生命周期单进程SAPI生命周期(CLI/CGI) 多进程SAPI生命周期(Apache2) 多线程SAPI生命周期 EmbedEmbed SAPI是一种比较特殊的sapi, 容许你在C/C++语言中调用PHP/ZE提供的函数。 使用PHP Embed SAPI实现Opcodes查看器 图片基本是从参考链接那边拿过来, 站在前人的肩膀上 参考 深入理解Zend SAPIs(Zend SAPI Internals) 使用PHP Embed SAPI实现Opcodes查看器 服务器应用编程接口 理解php内核中SAPI的作用 生命周期和Zend引擎 深入理解php底层：php生命周期","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"生命周期","slug":"生命周期","permalink":"http://blog.caoxl.com/tags/生命周期/"}]},{"title":"Shell 学习日志","slug":"Shell-Script","date":"2018-07-04T07:04:32.000Z","updated":"2019-08-22T06:57:07.000Z","comments":true,"path":"2018/07/04/Shell-Script/","link":"","permalink":"http://blog.caoxl.com/2018/07/04/Shell-Script/","excerpt":"sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客， grep:负责找出特定的行 awk能将行拆分成多个字段 sed则可以实现更新插入删除等写操作。","text":"sh脚本结合系统命令便有了强大的威力，在字符处理领域，有grep、awk、sed三剑客， grep:负责找出特定的行 awk能将行拆分成多个字段 sed则可以实现更新插入删除等写操作。 几种常见的 Shellbash bash 是 Linux 标准默认的 shell, 是BourneAgain Shell的缩写 shsh 由 Steve Bourne 开发，是 Bourne Shell 的缩写，sh 是 Unix 标准默认的 shell。 ashash shell 是由 Kenneth Almquist 编写的，Linux 中占用系统资源最少的一个小 shell，它只包含24个内部命令，因而使用起来很不方便。 cshcsh 是 Linux 比较大的内核，它由以 William Joy 为代表的共计47位作者编成，共有52个内部命令。该 shell 其实是指向 /bin/tcsh 这样的一个 shell，也就是说，csh 其实就是 tcsh。 kshksh 是 Korn shell 的缩写，由 Eric Gisin 编写，共有42条内部命令。该 shell 最大的优点是几乎和商业发行版的 ksh 完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。 实例定时检测nginx、mysql是否被关闭12345678910111213141516171819path=/var/loglog=$&#123;path&#125;/httpd-mysql.logname=(apache mysql)exs_init[0]=\"service httpd start\"exs_init[1]=\"/etc/init.d/mysqld restart\"for ((i=0; i&lt;2; i++)); do echo \"检查$&#123;name[i]&#125;进程是否存在\" ps -ef | grep $&#123;name[i]&#125; | grep -v grep if [ $? -eq 0]; then pid=$(pgrep -f $&#123;name[i]&#125;) echo \"`date +\"%Y-%m-%d %H:%M:%S\"` $&#123;name[$i]&#125; is running with pid $pid\" &gt;&gt; $&#123;log&#125; else $($&#123;exs_init[i]&#125;) echo \"`date +\"%Y-%m-%d %H:%M:%S\"` $&#123;name[$i]&#125; start success\" &gt;&gt; $&#123;log&#125; fidone 说明: 检测 nginx、mysql进程是否存在，如果不存在了会自动重新启动。 脚本每次运行会写日志的，没事可以去看看该日志文件，如果进程是不是真的经常性不存在，恐怕就要排查一下深层原因了。 1234567[root@izj6c6djex81rijczh0t8yz test]# sh check_nginx.sh 检查apache进程是否存在Redirecting to /bin/systemctl start httpd.serviceFailed to start httpd.service: Unit not found.检查mysql进程是否存在root 755 1 0 Jun25 ? 00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/usr/local/mysql/var --pid-file=/usr/local/mysql/var/izj6c6djex81rijczh0t8yz.pidmysql 1349 755 0 Jun25 ? 00:03:04 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/var/izj6c6djex81rijczh0t8yz.err --open-files-limit=65535 --pid-file=/usr/local/mysql/var/izj6c6djex81rijczh0t8yz.pid --socket=/tmp/mysql.sock --port=3306 开始学习 Shell 啦~~Shell 变量 定义变量 定义变量时，变量名不加美元符号（$），如： 1variableName=\"value\" 使用变量 12your_name=\"caoxl\"echo $your_name 重新定义变量 1234my_url=\"https://caoxl.com/shell\"echo $&#123;my_url&#125;my_url=\"https://caoxl.com/linux\"echo $&#123;my_url&#125; 只读变量 123my_url=\"https://caoxl.com/shell\"readonly my_urlmy_url=\"https://caoxl.com/linux\" 运行结果: 1/bin/sh: NAME:This variable is read only. 删除变量 1unset variable_name 变量类型 局部变量 环境变量 shell变量 Shell 特殊变量 $0: 当前脚本的文件名 $n: 传递给脚本或函数的参数 $#: 传递给脚本或函数的参数个数 $*: 传递给脚本或函数的所有参数 $@: 传递给脚本或函数的所有参数.被双引号(&quot; &quot;)包含时，与 $* 稍有不同 $?: 上个命令的退出状态,或函数的返回值 $$: 当前Shell进程ID,对于Shell脚本.就是这些脚本所在的进程ID Shell 替换如果表达式中包含特殊字符，Shell 将会进行替换。例如，在双引号中使用变量就是一种替换，转义字符也是一种替换。 \\: 反斜杠 \\a: 警报,响铃 \\b: 退格(删除键) \\f: 换页(FF), 将当前位置移到下页开头 \\n: 换行 \\r: 回车 \\t: 水平制表符(tab键) \\v: 垂直制表符 命令替换 命令替换是指 Shell 可以先执行命令，将输出结果暂时保存，在适当的地方输出。 命令替换的语法： “``“ 注意是反引号，不是单引号，这个键位于 Esc 键下方。 实例12345678910#!/bin/bashDATE=`date`echo \"Date is $DATE\"USERS=`who | wc -l`echo \"Logged in user are $USERS\"UP=`date ; uptime`echo \"Uptime is $UP\" 结果: 1234Date is Logged in user are 1Uptime is Wed Jul 4 17:20:55 CST 2018 17:20:55 up 9 days, 18 min, 1 user, load average: 0.00, 0.01, 0.05 变量替换 ${var}: 变量本来的值 ${var:-word}: 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值 ${var:=word}: 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。 ${var:?message}: 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标 准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在 Shell 脚本中，那么脚本将停止运行。 ${var:+word}: 如果变量 var 被定义，那么返回 word，但不改变 var 的值。 Shell 运算符 expr expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 两点注意: 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样 完整的表达式要被”`“包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算术运算符12345678910111213141516171819202122232425262728#!/bin/sha=10b=20val=`expr $a + $b`echo \"a + b : $val\"val=`expr $a - $b`echo \"a - b : $val\"val=`expr $a \\* $b`echo \"a * b : $val\"val=`expr $b / $a`echo \"b / a : $val\"val=`expr $b % $a`echo \"b % a : $val\"if [ $a == $b ]then echo \"a is equal to b\"fiif [ $a != $b ]then echo \"a is not equal to b\"fi 注意: 乘号(*)前边必须加反斜杠()才能实现乘法运算 if…then…fi 是条件语句，后续将会讲解。 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 -eq: 检测两个数是否相等，相等返回 true。 -ne: 检测两个数是否相等，不相等返回 true。 -gt: 检测左边的数是否大于右边的，如果是，则返回 true。 -lt: 检测左边的数是否小于右边的，如果是，则返回 true。 -ge: 检测左边的数是否大等于右边的，如果是，则返回 true。 -le: 检测左边的数是否小于等于右边的，如果是，则返回 true 布尔运算符 !: 非运算，表达式为 true 则返回 false，否则返回 true。 -o: 或运算，有一个表达式为 true 则返回 true。 -a: 与运算，两个表达式都为 true 才返回 true。 字符串运算符 =: 检测两个字符串是否相等，相等返回 true。 !=: 检测两个字符串是否相等，不相等返回 true -z: 检测字符串长度是否为0，为0返回 true。 -n: 检测字符串长度是否为0，不为0返回 true。 str: 检测字符串是否为空，不为空返回 true。 文件测试运算符 文件测试运算符用于检测 Unix 文件的各种属性。 Shell 注释以“#”开头的行就是注释，会被解释器忽略。 sh 里没有多行注释，只能每一行加一个#号。只能像这样： Shell 字符串字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟 PHP 类似。 单引号单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的;单引号字串中不能出现单引号（对单引号使用转义符后也不行）。 双引号双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串1234str1=\"hello\"str2=\"shell\"echo $str1 $str2 获取字符串长度12str=\"abcd\"echo $&#123;#str&#125; #输出4 提取子字符串12str=\"alibaba is a great company\"echo $&#123;str:0:6&#125; #输出 alibaba 查找子字符串12str=\"alibaba is a great company\"echo `expr index \"$str\" is` Shell 数组Shell echo命令Shell printf命令Shell if else语句Shell case esac语句Shell for循环Shell while循环Shell until循环Shell 跳出循环Shell 函数Shell 函数参数Shell 输入输出重定向Shell 文件包含","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"http://blog.caoxl.com/tags/Shell/"}]},{"title":"微信小程序 「微信支付」","slug":"WxPay-Small-Program","date":"2018-07-03T05:53:45.000Z","updated":"2019-08-22T06:45:22.000Z","comments":true,"path":"2018/07/03/WxPay-Small-Program/","link":"","permalink":"http://blog.caoxl.com/2018/07/03/WxPay-Small-Program/","excerpt":"新项目是一个小程序,需要使用到支付~","text":"新项目是一个小程序,需要使用到支付~ 业务流程 商户系统和微信支付系统主要交互: 小程序内调用登录接口, 获取到用户的openid; API参见小程序登录API 商户server调用支付统一下单; API参见统一下单API 商户server调用再次签名; API参见再次签名 商户server接收支付通知; API参见支付结果通知API 商户server查询支付结果; API参见查询订单API 直接上源码前端部分 调用wx.requestPayment(OBJECT)发起微信支付 12345678910wx.requestPayment(&#123; 'timeStamp': '', 'nonceStr': '', 'package': '', 'signType': 'MD5', 'paySign': '', 'success': function (res) &#123;&#125;, 'fail': function (res) &#123;&#125;, 'complete': function (res) &#123;&#125;&#125;); 参数说明: timeStamp: 时间戳, 即当前的时间 nonceStr: 随机字符串, 长度为32个字符以下 package: 统一下单接口返回的prepay_id参数值, 提交格式如: prepay_id=* signType: 签名类型, 默认为MD5, 支持HMAC-SHA256和MD5, 注意此处需要与统一下单的签名类型一致 paySign: 签名, 详见:微信公众号支付帮助文档 success: 接口调用成的回调函数 fail: 接口调用失败的回调函数 complete: 接口调用结束的回调函数(调用成功、失败都会执行) 数据签名举例 1paySign = MD5(appId=wxd678efh567hg6787&amp;nonceStr=5K8264ILTKCH16CQ2502SI8ZNMTM67VS&amp;package=prepay_id=wx2017033010242291fcfe0db70013231072&amp;signType=MD5&amp;timeStamp=1490840662&amp;key=qazwsxedcrfvtgbyhnujmikolp111111) = 22D9B4E54AB1950F51E0649E8810ACD6 后端部分发起支付 pay 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public function pay(Session $ssn, Request $req) &#123; $user = $ssn-&gt;get('user'); $_params = [ 'appid' =&gt; 'your_appid', 'mch_id' =&gt; '1439831202', 'nonce_str' =&gt; md5(microtime()), 'body' =&gt; 'JSAPI支持测试', 'attach' =&gt; '支持测试', 'fee_type' =&gt; 'CNY', 'total_fee' =&gt; $req-&gt;all()['total_fee'], 'notify_url' =&gt; 'https://skb-api.sciclean.cn/test/pay/payCallback', 'trade_type' =&gt; 'JSAPI', 'openid' =&gt; $user['openid'], 'out_trade_no' =&gt; md5(time()), 'spbill_create_ip' =&gt; $this-&gt;getRealIP() ]; $_sign = ''; $WxPay = '&lt;xml&gt;'; ksort($_params); foreach ($_params as $k =&gt; $v) &#123; if(is_scalar($v) &amp;&amp; 'sign' != $k &amp;&amp; '' != $v) &#123; $_sign .= $k . '=' . $v . '&amp;'; $WxPay .= '&lt;'.$k.'&gt;'.$v.'&lt;/'.$k.'&gt;'; &#125; &#125; $sign = $this-&gt;getSign($_sign); $WxPay .= '&lt;sign&gt;'.$sign.'&lt;/sign&gt;&lt;/xml&gt;'; $url = 'https://api.mch.weixin.qq.com/pay/unifiedorder'; $res = $this-&gt;curl_post_ssl($url, $WxPay); $res = $this-&gt;xmlToArray($res); $params = [ 'appId' =&gt; $res['appid'], 'nonceStr' =&gt; $res['nonce_str'], 'package' =&gt; 'prepay_id='.$res['prepay_id'], 'signType' =&gt; 'MD5', 'timeStamp' =&gt; ''.time() ]; ksort($params); $sign = ''; foreach($params as $k =&gt; $v) &#123; $sign .= $k . '=' . $v . \"&amp;\"; &#125; $params['paySign'] = $this-&gt;getSign($sign); return Tool::jsonResp([ 'err' =&gt; 0, 'msg' =&gt; 'Order Create Success!', 'dat' =&gt; $params ]); &#125; 参数说明: appid - 小程序ID mch_id - 商户号 device_info - 设备号 nonce_str - 随机字符串 sign - 签名 sign_type - 签名类型 body - 商品描述 detail - 商品详情 attach - 附加数据 out_trade_no - 商户订单号 fee_type - 标价币种 total_fee - 标价金额 spbill_create_ip - 终端IP notify_url - 通知地址 openid - 用户标识 trade_type - 交易类型 申请退款 refund 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public function refund(Session $ssn)&#123; $user = $ssn-&gt;get('user'); $_params = [ 'appid' =&gt; 'your_appid', 'mch_id' =&gt; '1439831202', 'nonce_str' =&gt; md5(microtime()), 'fee_type' =&gt; 'CNY', 'total_fee' =&gt; 100, 'refund_fee' =&gt; 100, 'notify_url' =&gt; 'https://skb-api.sciclean.cn/test/pay/payCallback', 'refund_desc' =&gt; 'JSAPI退款测试', 'transaction_id' =&gt; '4200000153201806292573121489', //'out_trade_no' =&gt; '35f3751220e4c1d7396e8b1bc4d05ee41', 'out_refund_no' =&gt; md5(time()) ]; $sign = ''; $WxPay = '&lt;xml&gt;'; ksort($_params); foreach ($_params as $k =&gt; $v) &#123; if(\"sign\" != $k &amp;&amp; !is_null($v)) &#123; $sign .= $k . \"=\" . $v . \"&amp;\"; $WxPay .= '&lt;'.$k.'&gt;'.$v.'&lt;/'.$k.'&gt;'; &#125; &#125; $sign = $this-&gt;getSign($sign); $WxPay .= '&lt;sign&gt;'.$sign.'&lt;/sign&gt;&lt;/xml&gt;'; $url = 'https://api.mch.weixin.qq.com/pay/unifiedorder'; $res = $this-&gt;curl_post_ssl($url, $WxPay); if ($res) &#123; $res = Tool::xmlToArray($res); return Tool::jsonResp([ 'err' =&gt; 0, 'msg' =&gt; 'Refund Success!', 'dat' =&gt; $res ]); &#125; return Tool::jsonResp([ 'err' =&gt; -1, 'msg' =&gt; 'Refund Failed!', 'dat' =&gt; [] ]);&#125; 参数说明: appid - 小程序ID mch_id - 商户号 nonce_str - 随机字符串 sign - 签名 sign_type - 签名类型 transaction_id - 微信订单号 out_trade_no - 商户订单号 与微信订单号 二选一即可 out_refund_no - 商户退款单号 total_fee - 订单金额 refund_fee - 退款金额 refund_fee_type - 货币种类 refund_desc - 退款原因 refund_account - 退款资金来源 notify_url - 退款结果通知url 注意: 交易时间超过一年的订单无法提交退款 微信支付退款支持单笔交易分多次退款，多次退款需要提交原支付订单的商户订单号和设置不同的退款单号。申请退款总金额不能超过订单金额。 一笔退款失败后重新提交，请不要更换退款单号，请使用原商户退款单号 请求频率限制：150qps，即每秒钟正常的申请退款请求次数不超过150次错误或无效请求频率限制：6qps，即每秒钟异常或错误的退款申请请求不超过6次 每个支付订单的部分退款次数不能超过50次 用到的方法 getRealIP 123456789101112protected function getRealIP()&#123; if ($clientIP = self::tryIPKey('HTTP_CLIENT_IP')) &#123; &#125; elseif ($clientIP = self::tryIPKey('HTTP_X_FORWARDED_FOR')) &#123; &#125; elseif ($clientIP = self::tryIPKey('HTTP_X_FORWARDED')) &#123; &#125; elseif ($clientIP = self::tryIPKey('HTTP_FORWARDED_FOR')) &#123; &#125; elseif ($clientIP = self::tryIPKey('HTTP_FORWARDED')) &#123; &#125; elseif ($clientIP = self::tryIPKey('REMOTE_ADDR')) &#123; &#125; else $clientIP = 'UNKNOWN'; return $clientIP;&#125; xmlToArray 12345678protected function xmlToArray(string $xml)&#123; return json_decode(json_encode(simplexml_load_string( $xml, 'SimpleXMLElement', LIBXML_NOCDATA )), true);&#125; arrayToXML 123456789101112131415protected function arrayToXML(array $array, string &amp;$xml): string&#123; foreach ($array as $key =&gt; &amp;$val) &#123; if (is_array($val)) &#123; $_xml = ''; $val = self::arrayToXML($val, $_xml); &#125; $xml .= \"&lt;key&gt;$val&lt;/key&gt;\"; &#125; unset($val); return $xml;&#125; jsonResp 123456789101112private function jsonResp( $data, int $status = 200, bool $unicode = true) &#123; $unicode = $unicode ? JSON_UNESCAPED_UNICODE : null; $data = json_encode($data, $unicode); return response($data) -&gt;header('Content-Type', 'application/json; charset=utf-8');&#125; nonceStr 1234protected function nonceStr(): string&#123; return mt_rand(time(), time()+rand());&#125; sign 1234567891011121314protected function sign(array $params, string $key)&#123; $sign = ''; ksort($params); foreach ($params as $k =&gt; $v) &#123; if (is_scalar($v) &amp;&amp; ('' != $v) &amp;&amp; ('sign' != $k)) &#123; $sign .= $k.'='.$v.'&amp;'; &#125; &#125; $sign .= '$key='.$key; $sign = strtoupper(md5($sign)); return $sign;&#125; 参考 小程序调起支付API 统一下单 申请退款","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://blog.caoxl.com/tags/微信小程序/"},{"name":"微信支付","slug":"微信支付","permalink":"http://blog.caoxl.com/tags/微信支付/"}]},{"title":"Linux 「查看命令」","slug":"Linux-see-cmd","date":"2018-07-03T02:15:57.000Z","updated":"2019-08-22T03:49:21.000Z","comments":true,"path":"2018/07/03/Linux-see-cmd/","link":"","permalink":"http://blog.caoxl.com/2018/07/03/Linux-see-cmd/","excerpt":"Linux 查询系统信息以及一些别的参数的命令集合","text":"Linux 查询系统信息以及一些别的参数的命令集合 系统 cat /etc/redhat-release - 查看安装的操作系统版本 12[root@izj6c6djex81rijczh0t8yz linux]# cat /etc/redhat-releaseCentOS Linux release 7.5.1804 (Core) uname -a - 查看内核/操作系统/CPU信息 12[root@izj6c6djex81rijczh0t8yz ~]# uname -aLinux izj6c6djex81rijczh0t8yz 3.10.0-862.3.2.el7.x86_64 #1 SMP Mon May 21 23:36:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux head -n 1 /etc/issue - 查看操作系统版本 12[root@izj6c6djex81rijczh0t8yz ~]# head -n 1 /etc/issue\\S cat /proc/cpuinfo - 查看CPU信息 1234567891011[root@izj6c6djex81rijczh0t8yz ~]# cat /proc/cpuinfoprocessor : 0vendor_id : GenuineIntelcpu family : 6model : 79model name : Intel(R) Xeon(R) CPU E5-2682 v4 @ 2.50GHzstepping : 1microcode : 0x1cpu MHz : 2494.222cache size : 40960 KB... hostname - 查看计算机名 12[root@izj6c6djex81rijczh0t8yz ~]# hostnameizj6c6djex81rijczh0t8yz lspci -tv - 列出所有PCI设备 安装lspci CentOs: yum install pciutils 12345678910111213[root@shuidianbang ~]# lspci -tv-[0000:00]-+-00.0 Intel Corporation 440FX - 82441FX PMC [Natoma] +-01.0 Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II] +-01.1 Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II] +-01.2 Intel Corporation 82371SB PIIX3 USB [Natoma/Triton II] +-01.3 Intel Corporation 82371AB/EB/MB PIIX4 ACPI +-02.0 Cirrus Logic GD 5446 +-03.0 Red Hat, Inc Virtio network device +-04.0 Red Hat, Inc Virtio console +-05.0 Red Hat, Inc Virtio block device +-06.0 Red Hat, Inc Virtio block device +-07.0 Red Hat, Inc Virtio memory balloon \\-08.0 Red Hat, Inc Device 1014 lsusb -tv - 列出所有USB设备 安装lsusb CentOs: yum install usbutils Debian: apt-get install usbutils 123[root@shuidianbang ~]# lsusb -tv/: Bus 01.Port 1: Dev 1, Class=root_hub, Driver=uhci_hcd/2p, 12M |__ Port 1: Dev 2, If 0, Class=HID, Driver=usbhid, 12M lsmod - 列出加载的内核模块 123456789101112[root@izj6c6djex81rijczh0t8yz ~]# lsmodModule Size Used bysb_edac 32034 0 iosf_mbi 14990 0 crc32_pclmul 13133 0 ghash_clmulni_intel 13273 0 aesni_intel 189415 0 lrw 13286 1 aesni_intelgf128mul 15139 1 lrwglue_helper 13990 1 aesni_intelablk_helper 13597 1 aesni_intel... env - 查看环境变量 12345678910[root@izj6c6djex81rijczh0t8yz ~]# envXDG_SESSION_ID=1322HOSTNAME=izj6c6djex81rijczh0t8yzTERM=xtermSHELL=/bin/bashHISTSIZE=1000SSH_CLIENT=61.140.75.213 27033 22SSH_TTY=/dev/pts/0USER=root... 资源 free -m - 查看内存使用量和交换区使用量 1234[root@izj6c6djex81rijczh0t8yz ~]# free -m total used free shared buff/cache availableMem: 991 143 156 2 691 674Swap: 0 0 0 df -h - 查看各分区使用情况 12345678[root@izj6c6djex81rijczh0t8yz ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/vda1 40G 4.4G 33G 12% /devtmpfs 486M 0 486M 0% /devtmpfs 496M 0 496M 0% /dev/shmtmpfs 496M 472K 496M 1% /runtmpfs 496M 0 496M 0% /sys/fs/cgrouptmpfs 100M 0 100M 0% /run/user/0 du -sh &lt;目录名&gt; - 查看指定目录的大小 123[root@izj6c6djex81rijczh0t8yz ~]# [root@izj6c6djex81rijczh0t8yz ~]# du -sh test16K test grep MemTotal /proc/meminfo - 查看内存总量 12[root@izj6c6djex81rijczh0t8yz ~]# grep MemTotal /proc/meminfoMemTotal: 1015436 kB grep MemFree /proc/meminfo - 查看空闲内存量 12[root@izj6c6djex81rijczh0t8yz ~]# grep MemFree /proc/meminfoMemFree: 160156 kB uptime - 查看系统运行时间、用户数、负载 12[root@izj6c6djex81rijczh0t8yz ~]# uptime 10:35:49 up 7 days, 17:33, 1 user, load average: 0.00, 0.01, 0.05 cat /proc/loadavg - 查看系统负载 12[root@izj6c6djex81rijczh0t8yz ~]# cat /proc/loadavg0.00 0.01 0.05 2/120 22010 磁盘和分区 mount | column -t - 查看挂接的分区状态 123456789[root@izj6c6djex81rijczh0t8yz ~]# mount | column -tsysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)devtmpfs on /dev type devtmpfs (rw,nosuid,size=497116k,nr_inodes=124279,mode=755)securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)tmpfs on /run type tmpfs (rw,nosuid,nodev,mode=755)... fdisk -l - 查看所有分区 1234567891011[root@izj6c6djex81rijczh0t8yz ~]# fdisk -lDisk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0008d73a Device Boot Start End Blocks Id System/dev/vda1 * 2048 83884031 41940992 83 Linux swapon -s - 查看所有交换分区 12[root@shuidianbang ~]# swapon -sFilename Type Size Used Priority hdparm -i /dev/had - 查看磁盘参数(仅适用于IDE设备) 安装hdparm CentOs: yum install hdparm -y 12345[root@izj6c6djex81rijczh0t8yz dev]# hdparm -i /dev/disk/dev/disk: HDIO_DRIVE_CMD(identify) failed: Inappropriate ioctl for device HDIO_GET_IDENTITY failed: Inappropriate ioctl for device dmesg | grep IDE - 查看启动时IDE设备检测状况 12345[root@izj6c6djex81rijczh0t8yz ~]# dmesg | grep IDE[ 0.123640] pci 0000:00:01.1: legacy IDE quirk: reg 0x10: [io 0x01f0-0x01f7][ 0.123642] pci 0000:00:01.1: legacy IDE quirk: reg 0x14: [io 0x03f6][ 0.123643] pci 0000:00:01.1: legacy IDE quirk: reg 0x18: [io 0x0170-0x0177][ 0.123645] pci 0000:00:01.1: legacy IDE quirk: reg 0x1c: [io 0x0376] 网络 ifconfig - 查看所有网络接口的属性 12345678910111213141516[root@izj6c6djex81rijczh0t8yz ~]# ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.31.45.94 netmask 255.255.240.0 broadcast 172.31.47.255 ether 00:16:3e:01:a4:4f txqueuelen 1000 (Ethernet) RX packets 374364 bytes 214011595 (204.0 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 224541 bytes 36447017 (34.7 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 loop txqueuelen 1000 (Local Loopback) RX packets 1408 bytes 1195160 (1.1 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 1408 bytes 1195160 (1.1 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 iptables -L - 查看防火墙设置 123456789[root@izj6c6djex81rijczh0t8yz ~]# iptables -LChain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination route -n - 查看路由表 123456[root@izj6c6djex81rijczh0t8yz ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface0.0.0.0 172.31.47.253 0.0.0.0 UG 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 eth0172.31.32.0 0.0.0.0 255.255.240.0 U 0 0 0 eth0 netstat -lntp - 查看所有监听端口 12345678[root@izj6c6djex81rijczh0t8yz ~]# netstat -lntpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN 2236/nginx: master tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 2256/php-fpm: maste tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 1349/mysqld tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 2236/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1443/sshd netstat -antp - 查看所有已经建立的连接 1234567891011[root@izj6c6djex81rijczh0t8yz ~]# [root@izj6c6djex81rijczh0t8yz ~]# netstat -antpActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:443 0.0.0.0:* LISTEN 2236/nginx: master tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 2256/php-fpm: maste tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 1349/mysqld tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 2236/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1443/sshd tcp 0 0 172.31.45.94:36556 140.205.140.205:80 ESTABLISHED 2798/AliYunDun tcp 0 52 172.31.45.94:22 61.140.75.213:27033 ESTABLISHED 21941/sshd: root@pt netstat -s - 查看网络统计信息 12345678910[root@izj6c6djex81rijczh0t8yz ~]# netstat -sIp: 262879 total packets received 0 forwarded 0 incoming packets discarded 262877 incoming packets delivered 215178 requests sent out 324 dropped because of missing routeIcmp:... 进程 ps -ef - 查看所有进程 12345678[root@izj6c6djex81rijczh0t8yz ~]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 Jun25 ? 00:00:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root 2 0 0 Jun25 ? 00:00:00 [kthreadd]root 3 2 0 Jun25 ? 00:00:02 [ksoftirqd/0]root 5 2 0 Jun25 ? 00:00:00 [kworker/0:0H]root 7 2 0 Jun25 ? 00:00:00 [migration/0]... top - 实时显示进程状态 123456top - 10:51:41 up 7 days, 17:48, 1 user, load average: 0.00, 0.01, 0.05Tasks: 69 total, 1 running, 68 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.0 us, 0.3 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1015436 total, 155664 free, 147448 used, 712324 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 690456 avail Mem... 用户 w - 查看活跃用户 1234[root@izj6c6djex81rijczh0t8yz ~]# w 10:52:27 up 7 days, 17:49, 1 user, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot pts/0 61.140.75.213 10:13 3.00s 0.05s 0.00s w id &lt;用户名&gt; - 查看指定用户信息 1234[root@izj6c6djex81rijczh0t8yz ~]# id rootuid=0(root) gid=0(root) groups=0(root)[root@izj6c6djex81rijczh0t8yz ~]# id gituid=1002(git) gid=1002(git) groups=1002(git) last - 查看用户登录信息 12345[root@izj6c6djex81rijczh0t8yz ~]# lastroot pts/0 61.140.75.213 Tue Jul 3 10:54 still logged in root pts/0 61.140.75.213 Tue Jul 3 10:13 - 10:54 (00:41) root pts/0 61.140.75.213 Tue Jul 3 10:12 - 10:13 (00:01) ... cut -d: -f1 /etc/passwd - 查看系统所有用户 12345678[root@izj6c6djex81rijczh0t8yz ~]# cut -d: -f1 /etc/passwdrootbindaemonadmlpsync... cut -d: -f1 /etc/group - 查看系统所有组 1234567891011[root@izj6c6djex81rijczh0t8yz ~]# cut -d: -f1 /etc/grouprootbindaemonsysadmttydisklpmem... crontab -l - 查看当前用户的计划任务 12[root@izj6c6djex81rijczh0t8yz ~]# crontab -l47 20 * * * curl https://caoxl.com/Aliyun/api_demo/SmsDemo.php 服务 chkconfig --list - 列出所有系统服务 123456789[root@shuidianbang ~]# chkconfig --listaegis 0:off 1:off 2:on 3:on 4:on 5:on 6:offagentwatch 0:off 1:off 2:on 3:on 4:on 5:on 6:offatd 0:off 1:off 2:off 3:on 4:on 5:on 6:offauditd 0:off 1:off 2:on 3:on 4:on 5:on 6:offblk-availability 0:off 1:on 2:on 3:on 4:on 5:on 6:offcloud-config 0:off 1:off 2:on 3:on 4:on 5:on 6:offcloud-final 0:off 1:off 2:on 3:on 4:on 5:on 6:off... chkconfig --list | grep on - 列出所有启动的系统服务 12345678910[root@shuidianbang ~]# chkconfig --list | grep onaegis 0:off 1:off 2:on 3:on 4:on 5:on 6:offagentwatch 0:off 1:off 2:on 3:on 4:on 5:on 6:offatd 0:off 1:off 2:off 3:on 4:on 5:on 6:offauditd 0:off 1:off 2:on 3:on 4:on 5:on 6:offblk-availability 0:off 1:on 2:on 3:on 4:on 5:on 6:offcloud-config 0:off 1:off 2:on 3:on 4:on 5:on 6:offcloud-final 0:off 1:off 2:on 3:on 4:on 5:on 6:offcloud-init 0:off 1:off 2:on 3:on 4:on 5:on 6:off... 程序 rpm -qa - 查看所有安装的软件包 123456[root@shuidianbang ~]# rpm -qaexpat-2.0.1-13.el6_8.x86_64python-libs-2.6.6-66.el6_8.x86_64basesystem-10.0-4.el6.noarchyum-plugin-fastestmirror-1.1.30-40.el6.noarch... rpm -qa | grep git - 查看指定的已安装的软件包 1234567[root@shuidianbang ~]# rpm -qa | grep gitxz-4.999.9-0.5.beta.20091007git.el6.x86_64git-1.7.1-9.el6_9.x86_64xz-libs-4.999.9-0.5.beta.20091007git.el6.x86_64libpcap-1.4.0-4.20130826git2dbcaa1.el6.x86_64xz-lzma-compat-4.999.9-0.5.beta.20091007git.el6.x86_64tcpdump-4.0.0-11.20090921gitdf3cb4.2.el6.x86_64 参考 看系统信息的一些命令及查看已安装软件包的命令（转) lspci命令详解 在 Linux 中安装使用 lsusb 查看 USB 设备","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"「PSR」 笔记","slug":"PHP-PSR-notes","date":"2018-07-02T03:56:05.000Z","updated":"2018-11-22T09:39:13.000Z","comments":true,"path":"2018/07/02/PHP-PSR-notes/","link":"","permalink":"http://blog.caoxl.com/2018/07/02/PHP-PSR-notes/","excerpt":"PSR 是 PHP Standard Recommendations 的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。详细请看: PHP 标准规范","text":"PSR 是 PHP Standard Recommendations 的简写，由 PHP FIG 组织制定的 PHP 规范，是 PHP 开发的实践标准。详细请看: PHP 标准规范 PSR-1 基本代码规范 PHP代码文件必须以&lt;?php 或 &lt;?=标签开始; PHP代码文件必须以不带BOM的UTF-8编码; PHP代码中应该只定义类、函数、常量等声明,或其他惠产生副作用的操作(如:生成文件输出以及修改php.ini配置文件等)二者只能选其一; 命令空间以及类必须符合PSR的自动加载规范: [PSR-4]中的一个; 类的命名必须遵循StudlyCaps大写开头的驼峰命名规范; 类中的常量所有字母都必须大写,单词间用下划线分隔; 方法名称必须符合camelCase式的小写开头驼峰命名规范; 类的属性命名可以遵循 大写开头的驼峰式($StudlyCaps) 小写开头的驼峰式($camelCase) 下划线分隔式($under_score) PSR-2 编码风格规范 代码必须遵循[PSR]中的编码规范; 代码必须使用4个空格符而不是[Tab键]进行缩进; 每行的字符数应该软性保持在80个之内,理论上一定不可多于120个,但一定不可有硬性限制; 每个namespace命名空间声明语句和use声明语句块后面,必须插入一个空白行; 类的开始花括号{必须写在函数声明后自成一行,结束花括号}也必须写在函数主题后自成一行; 方法的开始花括号{必须写在函数声明后自成一行,结束花括号}也必须写在函数主题后自成一行; 类的属性和方法必须添加访问修饰符(private、protected以及public), abstract以及final必须声明在访问修饰符之前, 而static必须声明在访问修饰符之后; 控制结构的关键字后必须要有一个空格符, 而调用方法或函数时则一定不可有; 控制结构的开始花括号{必须写在声明的同一行,而结束的花括号}必须写在主体后自成一行; 控制结构的开始左括号后和结束右括号前,都一定不可有空格符 PSR-3 日志接口规范 本规范的主要目的，是为了让日志类库以简单通用的方式，通过接收一个 Psr\\Log\\LoggerInterface 对象，来记录日志信息。 LoggerInterface 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志： debug info notice warning error critical alert emergency 第九个方法 —— log，其第一个参数为记录的等级。可使用一个预先定义的等级常量作为参数来调用此方法，必须 与直接调用以上八个方法具有相同的效果。如果传入的等级常量参数没有预先定义，则 必须 抛出 Psr\\Log\\InvalidArgumentException 类型的异常。在不确定的情况下，使用者 不该 使用未支持的等级常量来调用此方法。 PSR-4 自动加载规范 此处的[类]泛指所有的[Class类]、[接口]、[traits可复用代码块]以及其他类似结构; 一个玩转的类名需具有以下结构 \\&lt;命名空间&gt;(\\&lt;子命名空间&gt;)*\\&lt;类名&gt; 完整的类名 必须 要有一个顶级命名空间，被称为 &quot;vendor namespace&quot;; 完整的类名 可以 有一个或多个子命名空间; 完整的类名 必须 有一个最终的类名; 完整的类名中任意一部分中的下滑线都是没有特殊含义的; 完整的类名 可以 由任意大小写字母组成; 所有类名都 必须 是大小写敏感的; 当根据完整的类名载入相应的文件 完整的类名中，去掉最前面的命名空间分隔符，前面连续的一个或多个命名空间和子命名空间，作为「命名空间前缀」，其必须与至少一个「文件基目录」相对应; 紧接命名空间前缀后的子命名空间 必须 与相应的「文件基目录」相匹配，其中的命名空间分隔符将作为目录分隔符 末尾的类名 必须 与对应的以 .php 为后缀的文件同名; 自动加载器（autoloader）的实现 一定不可 抛出异常、一定不可 触发任一级别的错误信息以及 不应该 有返回值。 PSR-6 缓存接口规范 调用类库(Calling Library) - 调用者, 使用缓存服务的类库，这个类库调用缓存服务，调用的是此缓存接口规范的具体「实现类库」，调用者不需要知道任何「缓存服务」的具体实现。 实现类库 (Implementing Library) - 此类库是对「缓存接口规范」的具体实现，封装起来的缓存服务，供「调用类库」使用。实现类库 必须 提供 PHP 类来实现Cache\\CacheItemPoolInterface 和 Cache\\CacheItemInterface 接口。实现类库必须支持最小的如下描述的TTL功能, 秒级别的精准度. 生存时间值 (TTL - Time To Live) - 定义了缓存可以存活的时间，以秒为单位的整数值。 过期时间 (Expiration) - 定义准确的过期时间点，一般为缓存存储发生的时间点加上 TTL 时间值，也可以指定一个 DateTime 对象。 键 (KEY) - 长度大于 1 的字串，用作缓存项在缓存系统里的唯一标识符 命中 (Hit) - 一个缓存的命中，指的是当调用类库使用「键」在请求一个缓存项的时候，在缓存池里能找到对应的缓存项，并且此缓存项还未过期，并且此数据不会因为任何原因出现错误 未命中 (Miss) - 一个缓存未命中，是完全的上面描述的「命中」的相反 延迟 (Deferred) - 一个延迟的缓存，指的是这个缓存项可能不会立刻被存储到物理缓存池里。 数据 实现类库 必须 支持所有的可序列化的 PHP 数据类型，包含： 字符串 - 任何大小的PHP兼容字符串 整数 - PHP支持的低于64位的有符号整数值 浮点数 - 所有的有符号浮点数 布尔 - true和false Null - null值 数组 - 各种形式的PHP数组 对象(Object) - 所有的支持无损序列化和反序列化的对象 PSR-7 HTTP 消息接口规范 HTTP 消息是 Web 技术发展的基础。浏览器或 HTTP 客户端如 curl 生成发送 HTTP 请求消息到 Web 服务器，Web 服务器响应 HTTP 请求。服务端的代码接受 HTTP 请求消息后返回 HTTP 响应消息。 消息一个 HTTP 消息，指定是一个从客户端发往服务器端的请求，或者是服务器端返回客户端的响应。对应的两 个消息接口： Psr\\Http\\Message\\RequestInterface Psr\\Http\\Message\\ResponseInterface HTTP 头信息大小写不敏感的字段名字HTTP 消息包含大小写不敏感头信息。使用 MessageInterface 接口来设置和获取头信息，大小写 不敏感的定义在于，如果你设置了一个 Foo 的头信息，foo 的值会被重写，你也可以通过 foo 来 拿到 FOO 头对应的值。 对应多条数组的头信息为了适用一个 HTTP 「键」可以对应多条数据的情况，我们使用字符串配合数组来实现，你可以从一个 MessageInterface 取出数组或字符串，使用 getHeaderLine($name) 方法可以获取通过逗号分割的不区分大小写的字符串形式的所有值。也可以通过 getHeader($name) 获取数组形式头信息的所有值。 注意：并不是所有的头信息都可以适用逗号分割（例如 Set-Cookie），当处理这种头信息时候， MessageInterace 的继承类 应该 使用 getHeader($name) 方法来获取这种多值的情况 主机信息在请求中，Host 头信息通常和 URI 的 host 信息，还有建立起 TCP 连接使用的 Host 信息一致。 然而，HTTP 标准规范允许主机 host 信息与其他两个不一样。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PSR","slug":"PSR","permalink":"http://blog.caoxl.com/tags/PSR/"},{"name":"代码规范","slug":"代码规范","permalink":"http://blog.caoxl.com/tags/代码规范/"}]},{"title":"命令行快捷键/别名","slug":"Linux-Custom-cmd","date":"2018-07-02T02:27:14.000Z","updated":"2019-08-19T03:53:54.000Z","comments":true,"path":"2018/07/02/Linux-Custom-cmd/","link":"","permalink":"http://blog.caoxl.com/2018/07/02/Linux-Custom-cmd/","excerpt":"为了节约时间（偷懒），下面介绍一下mac/Linux下使用alias配置常用命令。","text":"为了节约时间（偷懒），下面介绍一下mac/Linux下使用alias配置常用命令。 自定义命令 Windows下编辑~/.bash_profile Linux下编辑~/.bashrc 直接上我的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# Linuxalias rm='rm -i'alias cp='cp -i'alias mv='mv -i'# Artisanalias autoload='composer dump-autoload';alias migrate='php artisan migrate';alias seed='php artisan db:seed';alias key='php artisan key:generate';alias jwt='php artisan jwt:secret';alias art.ext='composer require laravel-admin-ext/helpers'alias art.import='php artisan admin:import helpers'alias art.list='php artisan list'alias php.unit='./vendor/bin/phpunit'# BGCFUNalias fun.token=\"php artisan token:make code0809@163.com qadbk365t\"alias fun.scan=\"php artisan route:scan\"alias fun.model=\"php artisan code:models\"alias fun.reliese=\"composer update reliese/laravel\"# Composeralias com.conf='composer config -gl'alias com.ali='composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/'alias repo.install='composer global require slince/composer-registry-manager'alias repo.ls='composer repo:ls'alias repo.use='composer repo:use laravel-china'# Cowsayalias cowsay='fortune | cowsay';# Cmatrixalias cxl='cmatrix';# ElasticSearchalias es.run=\"bin/elasticsearch.bat\"alias es.test=\"curl http://127.0.0.1:9200\"# FILEalias ..='cd ..';alias ....='cd ../../';# Hexoalias hexogd='hexo g &amp;&amp; hexo d'# IPalias wget.ip='wget -qO- http://ipecho.net/plain | xargs echo'alias wget.ip2='wget -qO - icanhazip.com'alias curl.ip='curl ifconfig.co'alias curl.ip2='curl ifconfig.me'alias curl.ip3='icanhazip.com'# GuangZhou Weatheralias gztq='curl -4 http://wttr.in/GuangZhou --header \"Accept-Language:zh-CN,zh;q=0.8\"';# Githubalias github='git config --global user.name \"SoulMate94\" &amp;&amp; git config --globaluser.email \"code0809@163.com\" &amp;&amp; ssh-keygen -t rsa -C \"code0809@163.com\"';# Gitalias ls='ls --color=auto';alias ll='ls -lh';alias ld='ll |grep \"^d\"';alias psw='ps -a --windows';alias gst='git status';alias gad='git add -A';alias gcm='git commit -m $1';alias gcb='git checkout $1';alias gpushb=\"git push origin $1\";alias gpushm=\"git push origim master\";alias gpullb=\"git pull origin $1\";alias gpullm=\"git pull origin master\";alias gcb=\"git checkout $1\";alias gcc=\"git checkout caoxl\";alias gm=\"git checkout master\";alias gb=\"git branch\";alias gba=\"git branch -a\";alias gmb=\"git merge $1\";alias gmm=\"git merger master\";alias gdf=\"git diff\";alias grv=\"git remote -v\";alias greset='git reset --hard';alias gll=\"git log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'\";# LaravelSalias laravels.start='php artisan laravels start';alias laravels.stop='php artisan laravels stop';alias laravels.restart='php artisan laravels restart';alias laravels.reload='php artisan laravels reload';alias laravels.publish='php artisan laravels publish';alias laravels.cmd=\"php artisan laravels $1\";# Nginxalias nginx.start='service nginx start';alias nginx.status='service nginx status';alias nginx.stop='service nginx stop';alias nginx.restart='service nginx restart';# PHPalias serve='php artisan serve';# VI/VIMalias vi='vim';# Otheralias zi='figlet';alias see.cpu='cat /proc/cpuinfo';alias see.linux='cat /etc/redhat-release';alias see.io='iostat -x /dev/sda1';# .bashrc (Windows下为`.bash_profile`)alias sss='source ~/.bash_profile';alias vbash='vim ~/.bash_profile';","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"Linux 别名， Git 别名","slug":"Linux-别名，-Git-别名","permalink":"http://blog.caoxl.com/tags/Linux-别名，-Git-别名/"},{"name":"自定义命令","slug":"自定义命令","permalink":"http://blog.caoxl.com/tags/自定义命令/"}]},{"title":"HTTP 请求头/响应头","slug":"HTTP-Header","date":"2018-06-29T02:09:26.000Z","updated":"2019-08-22T03:44:30.000Z","comments":true,"path":"2018/06/29/HTTP-Header/","link":"","permalink":"http://blog.caoxl.com/2018/06/29/HTTP-Header/","excerpt":"学习Web开发不好好学习HTTP，将会“打拳不练功，到老一场空”，你花在犯迷糊上的时间比你沉下心来学习HTTP的时间肯定会多很多。","text":"学习Web开发不好好学习HTTP，将会“打拳不练功，到老一场空”，你花在犯迷糊上的时间比你沉下心来学习HTTP的时间肯定会多很多。 常用请求头 Accept-Charset: 用于指定客户端接受的字符集 Accept-Encoding: 用于指定可接受的内容编码,如Accept-Encoding:gzip.deflate Accept-Language: 用于指定一种自然语言, 如Accept-Language:zh-cn Host: 用户指定被请求资源的Internet主机和端口号, 如:Host:www.baidu.com User-Agent: 客户端将它的操作系统, 浏览器和其他属性告诉服务器 Connection: 当前连接是否保持, 如Connection:Keep-Alive 实例:www.google.com Request Headers 123456789101112:authority: www.google.com:method: GET:path: /:scheme: httpsaccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8accept-encoding: gzip, deflate, braccept-language: zh-CN,zh;q=0.9,en;q=0.8cache-control: max-age=0cookie: HSID=Ao92eQFZB7kOEw6yA; SSID=AlC3MG6I7bTxZDQO7; APISID=X9CY9NZ28EJTz_eV/AQWH2CR8lf0fNgW8e; SAPISID=rKRnvK8jf4WaTiP_/AzvzGc4aeAWEmw_Zy; SID=BgbU8VicgfUPXbPG_1K5CNKIObkJhzhMkCO0KwYGPAVkVZHtmeSjZ7H_DSPwqbW5bnqv2Q.; NID=133=bbY2KtALCHEfXVadHQT3yEU0qjiu-QrJXO8KRmKLBKvLzcbdGceq0jZVJQ8CG1FltiIWwr7qoDMKnYuJsNGPZ3RQCaPokGRdwatE_Pelzu9zzI5H-0NMP2KfSw-0k4G0SpY743QzHq4yd1XJEQU0iiKpwodX__rSOcuY-4Y8-7QnCZnHekLRSJxUj5GhQeGut-nWzsJq8sz6UHmD6GOmdJvt2EcrwahS47UdlOnm9A10acXIVEeziHbIcY_-DkiDmcQaNugksHQ; 1P_JAR=2018-6-29-2; SIDCC=AEfoLebf0c1-B3cWJBdIC56FZhmwxbqb-awIbH8dOJEdHA8pD_S71ZAbojm1tZwefxQ1mimuNz8upgrade-insecure-requests: 1user-agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36x-client-data: CI22yQEIpLbJAQjBtskBCI2aygEIqZ3KAQjXncoBCKijygE= www.baidu.com Request Headers 123456789Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Connection: keep-aliveCookie: BAIDUID=28C52FEE8FBF24DE95D26F820D40665B:FG=1; BIDUPSID=28C52FEE8FBF24DE95D26F820D40665B; PSTM=1522721732; __cfduid=d80a99d77873ca28f1bc17def9f921d161522722327; BDUSS=C00Y0x2ekZVYzdjcm5aT09QU2JsYXlJc3lhb2txU29jRzdvT1RLVFBRWmczQmhiQVFBQUFBJCQAAAAAAAAAAAEAAADV-TlJtbDM27XE1u648LTlt~IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGBP8VpgT~FaM; MCITY=-257%3A; locale=zh; pgv_pvi=3210548224; BD_UPN=12314753; BD_HOME=1; H_PS_PSSID=26748_1430_21112_20697_26350_22159Host: www.baidu.comUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.62 Safari/537.36 参数详解: Requests部分 格式: Header - 解释 - 示例 Accept - 指定客户端能够接收的内容类型 - Accept: text/plain, text/html Accept-Charset - 浏览器可以接受的字符编码集。 - Accept-Charset: iso-8859-5 Accept-Encoding - 指定浏览器可以支持的web服务器返回内容压缩编码类型。 - Accept-Encoding: compress, gzip Accept-Language - 浏览器可接受的语言 - Accept-Language: en,zh Accept-Ranges - 可以请求网页实体的一个或者多个子范围字段 - Accept-Ranges: bytes Authorization - HTTP授权的授权证书 - Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control - 指定请求和响应遵循的缓存机制 - Cache-Control: no-cache Connection - 表示是否需要持久连接。（HTTP 1.1默认进行持久连接）- Connection: close Cookie - HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 - Cookie: $Version=1; Skin=new; Content-Length - 请求的内容长度 - Content-Length: 348 Content-Type - 请求的与实体对应的MIME信息 - Content-Type: application/x-www-form-urlencoded Date - 请求发送的日期和时间 - Date: Tue, 15 Nov 2010 08:12:31 GMT Expect - 请求的特定的服务器行为 - Expect: 100-continue From - 发出请求的用户的Email - From: user@email.com Host - 指定请求的服务器的域名和端口号 - Host: www.zcmhi.com If-Match - 只有请求内容与实体相匹配才有效 - If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since - 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码 - If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT If-None-Match - 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 - If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range - 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag - If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since - 只在实体在指定时间之后未被修改才请求成功 - If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards - 限制信息通过代理和网关传送的时间 - Max-Forwards: 10 Pragma - 用来包含实现特定的指令 - Pragma: no-cache Proxy-Authorization - 连接到代理的授权证书 - Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range - 只请求实体的一部分，指定范围 - Range: bytes=500-999 Referer - 先前网页的地址，当前请求网页紧随其后,即来路 - Referer: http://www.zcmhi.com/archives/71.html TE - 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 - TE: trailers,deflate;q=0.5 Upgrade - 向服务器指定某种传输协议以便服务器进行转换（如果支持） - Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent - User-Agent的内容包含发出请求的用户信息 - User-Agent: Mozilla/5.0 (Linux; X11) Via - 通知中间网关或代理服务器地址，通信协议 - Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning - 关于消息实体的警告信息 - Warn: 199 Miscellaneous warning 常见响应头 Server: 使用的服务器名称, 如Server:Apache/13.6(Unix) Content-Type: 用来指明发送给接受者的实体正文的媒体类型. 如Content-Type:text/html;charset=GBK Content-Encoding: 与请求头Accept-Encoding相对应.告诉浏览器服务器采用的是什么压缩编码 Content-Language: 描述了资源所用的自然语言,与Accept-Language相对应 Content-Length: 指明实体正文的长度, 用以字节方式存储十进制数字来表示 Keep-Alive: 保持连接的时间,如Keep-Alive:timeout=5,max=120 实例:www.google.com Response Headers 12345678910111213alt-svc: quic=\":443\"; ma=2592000; v=\"43,42,41,39,35\"cache-control: private, max-age=0content-encoding: brcontent-type: text/html; charset=UTF-8date: Fri, 29 Jun 2018 02:59:34 GMTexpires: -1server: gwsset-cookie: 1P_JAR=2018-06-29-02; expires=Sun, 29-Jul-2018 02:59:34 GMT; path=/; domain=.google.comset-cookie: SIDCC=AEfoLeZmeujSZGZUWN8cMFDTFhHJWI1_plOiVlNP-Zivyba_nD9nsZbftwsJJRyp3DxhNeULcwQ; expires=Thu, 27-Sep-2018 02:59:34 GMT; path=/; domain=.google.com; priority=highstatus: 200strict-transport-security: max-age=86400x-frame-options: SAMEORIGINx-xss-protection: 1; mode=block www.baidu.com Response Headers 123456789101112131415Bdpagetype: 2Bdqid: 0x928027420000b0f6Cache-Control: privateConnection: Keep-AliveContent-Encoding: gzipContent-Type: text/html;charset=utf-8Date: Fri, 29 Jun 2018 03:03:40 GMTExpires: Fri, 29 Jun 2018 03:03:40 GMTServer: BWS/1.1Set-Cookie: BDSVRTM=230; path=/Set-Cookie: BD_HOME=1; path=/Set-Cookie: H_PS_PSSID=26748_1430_21112_20697_26350_22159; path=/; domain=.baidu.comStrict-Transport-Security: max-age=172800Transfer-Encoding: chunkedX-Ua-Compatible: IE=Edge,chrome=1 参数详解: Responses部分 格式: Header - 解释 - 示例 Accept-Ranges - 表明服务器是否支持指定范围请求及哪种类型的分段请求 - Accept-Ranges: bytes Age - 从原始服务器到代理缓存形成的估算时间（以秒计，非负） - Age: 12 Allow - 对某网络资源的有效的请求行为，不允许则返回405 - Allow: GET, HEAD Cache-Control - 告诉所有的缓存机制是否可以缓存及哪种类型 - Cache-Control: no-cache Content-Encoding - web服务器支持的返回内容压缩编码类型。 - Content-Encoding: gzip Content-Language - 响应体的语言 - Content-Language: en,zh Content-Length - 响应体的长度 - Content-Length: 348 Content-Location - 请求资源可替代的备用的另一地址 - 请求资源可替代的备用的另一地址 Content-MD5 - 返回资源的MD5校验值 - Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Range - 在整个返回体中本部分的字节位置 - Content-Range: bytes 21010-47021/47022 Content-Type - 返回内容的MIME类型 - Content-Type: text/html; charset=utf-8 Date - 原始服务器消息发出的时间 - Date: Tue, 15 Nov 2010 08:12:31 GMT ETag - 请求变量的实体标签的当前值 - ETag: “737060cd8c284d8af7ad3082f209582d” Expires - 响应过期的日期和时间 - Expires: Thu, 01 Dec 2010 16:00:00 GMT Last-Modified - 请求资源的最后修改时间 - Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT Location - 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 - Location: http://www.zcmhi.com/archives/94.html Pragma - 包括实现特定的指令，它可应用到响应链上的任何接收方 - Pragma: no-cache Proxy-Authenticate - 它指出认证方案和可应用到代理的该URL上的参数 - Proxy-Authenticate: Basic refresh - 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） - Refresh: 5; url=http://www.zcmhi.com/archives/94.html Retry-After - 如果实体暂时不可取，通知客户端在指定时间之后再次尝试 - Retry-After: 120 Server - web服务器软件名称 - Server: Apache/1.3.27 (Unix) (Red-Hat/Linux) Set-Cookie - 设置Http Cookie - Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1 Trailer - 指出头域在分块传输编码的尾部存在 - Trailer: Max-Forwards Transfer-Encoding - 文件传输编码 - Transfer-Encoding:chunked Vary - 告诉下游代理是使用缓存响应还是从原始服务器请求 - Vary: * Via - 告知代理客户端响应是通过哪里发送的 - Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning - 警告实体可能存在的问题 - Warning: 199 Miscellaneous warning WWW-Authenticate - 表明客户端请求实体应该使用的授权方案 - WWW-Authenticate: Basic HTTP Header可选字段 Cache-Control/Pragma Public: 所有的内容都将被缓存, 在响应头中设置 Private: 内容只缓存到私有缓存中, 在响应头中设置 no-cache: 所有内容都不会被缓存, 在请求头和响应头中设置 no-store: 所有内容都不会被缓存到缓存或Internet临时文件中, 在响应头中设置 must-revalidation/proxy-revalidation: 如果缓存内容失效, 请求必须发送到服务器/代理以进行重新验证,在请求头中设置 max-age=xxx: 缓存的内容将在xxx秒后失效, 这个选项只在Http 1.1中可用, 和Last-Modified一起使用时优先级较高,在响应头中设置 PHP设置HTTP请求头/响应头使用header函数 设置请求头 1header('Accept-Language:zh-cn'); 设置响应头 1header('Server:Apache/13.6(Unix)'); 多个直接要写多个header,不可以连接在一起! 使用fsockopen函数 1.php 1234567891011121314151617181920&lt;?php$fp = fsockopen(\"test.com\", 80,$errNo,$errStr, 30);if (!$fp) &#123; echo \"$errStr ($errNo)\",PHP_EOL;&#125; else &#123; $out = \"GET /2.php HTTP/1.1 \\r\\n\"; $out .= \"Host: test.com \\r\\n\"; $out .= \"name:cxl \\r\\n\"; $out .= \"Connection: Close \\r\\n\\r\\n\"; fwrite($fp, $out); while (!feof($fp)) &#123; echo fgets($fp, 128); &#125; fclose($fp);&#125; 2.php 1print_r(getallheaders()) 会返回自己设置请求的头信息 使用cURL组件的使用PHP获取请求头/响应头 getallheaders - 获取所有HTTP请求标头, (或$_SERVER) headers_list - 返回已发送(或准备发送)的响应头列表 参考 HTTP Header 详解 14 Header Field Definitions","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.caoxl.com/tags/HTTP/"},{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"请求头","slug":"请求头","permalink":"http://blog.caoxl.com/tags/请求头/"},{"name":"响应头","slug":"响应头","permalink":"http://blog.caoxl.com/tags/响应头/"}]},{"title":"HTTP 状态码","slug":"HTTP-state-code","date":"2018-06-28T07:57:58.000Z","updated":"2019-08-22T03:44:33.000Z","comments":true,"path":"2018/06/28/HTTP-state-code/","link":"","permalink":"http://blog.caoxl.com/2018/06/28/HTTP-state-code/","excerpt":"为啥要放这么简单的东西?问题常常出现在理所应当以为正确的地方","text":"为啥要放这么简单的东西?问题常常出现在理所应当以为正确的地方 1xx - 信息提示 这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个 1xx 响应。 100 - Continue - 继续 101 - Switching Protocols - 切换协议 2xx - 成功 这类状态代码表明服务器成功地接受了客户端请求。 200 - OK - 确定,客户端请求已成功(一般用于GET与POST请求) 201 - Created - 已创建.成功请求并创建了新的资源 202 - Accepted - 已接受.已经接受请求，但未处理完成 203 - Non-Authoritative Information - 非权威信息,非授权信息.请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 - No Content - 无内容 205 - Reset Content - 重置内容. 服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 - Partial Content - 部分内容 3xx - 重定向 客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。 300 - Multiple Choices - 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端 301 - Moved Permanently - 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 - Found - 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 - See Other - 查看其它地址。与301类似。使用GET和POST请求查看 304 - Not Modified - 未修改 305 - Use Proxy - 使用代理。所请求的资源必须通过代理访问 306 - Unused - 已经被废弃的HTTP状态码 307 - Temporary Redirect - 临时重定向, 与302类似。使用GET请求重定向 4xx - 客户端错误 发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。 400 - Bad Request - 错误的请求 401 - Unauthorized - 访问被拒绝, IIS定义了许多不同的 401.1 – 登录失败。 401.2 – 服务器配置导致登录失败。 401.3 – 由于 ACL 对资源的限制而未获得授权。 401.4 – 筛选器授权失败。 401.5 – ISAPI/CGI 应用程序授权失败。 401.7 – 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。 402 - Payment Required - 保留, 将来使用 403 - Forbidden – 禁止访问：IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因 403.1 – 执行访问被禁止。 403.2 – 读访问被禁止。 403.3 – 写访问被禁止。 403.4 – 要求 SSL。 403.5 – 要求 SSL 128。 403.6 – IP 地址被拒绝。 403.7 – 要求客户端证书。 403.8 – 站点访问被 拒绝。 403.9 – 用户数过多。 403.10 – 配置无效。 403.11 – 密码更改。 403.12 – 拒绝访问映射表。 403.13 – 客户端证书被吊销。 403.14 – 拒绝目录列表。 403.15 – 超出客户端访问许可。 403.16 – 客户端证书不受信任或无效。 403.17 – 客户端证书已过期或尚未生效。 403.18 – 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。 403.19 – 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。 403.20 – Passport 登录失败。这个错误代码为 IIS 6.0 所专用。 404 - Not Found – 服务器无法根据客户端的请求找到资源（网页）。 404.0 -（无） – 没有找到文件或目录。 404.1 – 无法在所请求的端口上访问 Web 站点。 404.2 – Web 服务扩展锁定策略阻止本请求。 404.3 – MIME 映射策略阻止本请求。 405 - Method Not Allowed – 用来访问本页面的 HTTP 谓词不被允许（方法不被允许） 406 - Method Not Allowed – 客户端浏览器不接受所请求页面的 MIME 类型。 407 - Proxy Authentication Required – 要求进行代理身份验证。与401类似，但请求者应当使用代理进行授权 408 - Request Time-out - 服务器等待客户端发送的请求时间过长，超时 409 - Conflict - 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 410 - Gone - 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码 411 - Length Required - 服务器无法处理客户端发送的不带Content-Length的请求信息 412 - Precondition Failed - 客户端请求信息的先决条件错误 413 - Request Entity Too Large - 由于请求的实体过大，服务器无法处理，因此拒绝请求。 414 - Request-URI Too Large - 请求URI太长(URI通常为网址), 服务器无法处理 415 - Unsupported Media Type - 不支持的媒体类型,服务器无法处理请求附带的媒体格式 416 - Requested range not satisfiable - 客户端请求的范围无效 417 - Expectation Failed - 执行失败,服务器无法满足Expect的请求头信息 423 - 锁定的错误 5xx - 服务器错误 服务器由于遇到错误而不能完成该请求。 500 - Internal Server Error – 内部服务器错误。 500.12 – 应用程序正忙于在 Web 服务器上重新启动。 500.13 – Web 服务器太忙。 500.15 – 不允许直接请求 Global.asa。 500.16 – UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。 500.18 – URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。 500.100 – 内部 ASP 错误。 501 - Not Implemented – 页眉值指定了未实现的配置。 502 - Bad Gateway – Web 服务器用作网关或代理服务器时收到了无效响应。 502.1 – CGI 应用程序超时。 502.2 – CGI 应用程序出错。application. 503 - Service Unavailable – 服务不可用。这个错误代码为 IIS 6.0 所专用。 504 - Gateway Time-out – 网关超时。 505 - HTTP Version not supported – HTTP 版本不受支持。","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.caoxl.com/tags/HTTP/"},{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"状态码","slug":"状态码","permalink":"http://blog.caoxl.com/tags/状态码/"}]},{"title":"说说JSON和JSONP","slug":"JSON-JSONP","date":"2018-06-27T06:49:12.000Z","updated":"2019-08-22T03:44:49.000Z","comments":true,"path":"2018/06/27/JSON-JSONP/","link":"","permalink":"http://blog.caoxl.com/2018/06/27/JSON-JSONP/","excerpt":"JSON和JSONP虽然只有一个字母的差别，但其实他们根本不是一回事儿;就像Java和JavaScript没有关系,老婆和老婆饼没有关系一个道理","text":"JSON和JSONP虽然只有一个字母的差别，但其实他们根本不是一回事儿;就像Java和JavaScript没有关系,老婆和老婆饼没有关系一个道理 什么是JSON? JSON是一种基于文本的数据交换方式，或者叫做数据描述格式 JSON的优点 基于纯文本，跨平台传递极其简单 Javascript原生支持，后台语言几乎全部支持 轻量级数据格式，占用字符数量极少，特别适合互联网传递 可读性较强，虽然比不上XML那么一目了然，但在合理的依次缩进之后还是很容易识别的 容易编写和解析，当然前提是你要知道数据结构 JSON的格式JSON能够以非常简单的方式来描述数据结构，XML能做的它都能做，因此在跨平台方面两者完全不分伯仲。 JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号&quot;&quot;是定义符。 大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组） 上述两种集合中若有多个子项，则通过英文逗号,进行分隔。 键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号&quot;&quot;，以便于不同语言的解析。 JSON内部常用数据类型无非就是字符串、数字、布尔、日期、null 这么几个，字符串必须用双引号引起来，其余的都不用，日期类型比较特殊，这里就不展开讲述了 实例12345678910&#123; \"Name\": \"caoxl\", \"Age\": 23, \"Com\": \"IBM\"&#125;,&#123; \"Name\": \"caolx\", \"Age\": 24, \"Com\": \"IBM\"&#125; JSON12345678910111213141516$.ajax(&#123; type: \"post\", url: \"danmu.php\", data: &#123;word:\"adc\",username:\"cxl\"&#125;, datatype: \"json\", async: true, //是否异步,true为异步 // success为数据加载完成后的回调函数 success: function (data) &#123; var show = document.getElementById('show'); for (i in data) &#123; show.innerHTML += data[i]+\"&lt;br&gt;; &#125; console.log(data); &#125;&#125;); 什么是JSONP? JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。 先说说JSONP是怎么产生的： Ajax直接请求普通文件存在跨域无权限访问的问题 Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有&quot;src&quot;这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;） 跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理 恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持 Web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去 客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 JSONP的客户端具体实现 我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。 远程服务器remoteserver.com根目录下有个remote.js文件代码如下： 1alert('我是远程文件,跨域调用成功'); 本地服务器localserver.com下有个jsonp.html页面代码如下： 123456789&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"http://remoteserver.com/remote.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。 现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。 123456789101112131415&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var localHandler = function(data)&#123; alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;; &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"http://remoteserver.com/remote.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。 12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。'); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = \"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler\"; // 创建script标签，设置其属性 var script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html 到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 想知道jQuery如何实现jsonp调用？123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" &gt;&lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type=\"text/javascript\" src=jquery.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: \"get\", async: false, url: \"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998\", dataType: \"jsonp\", jsonp: \"callback\",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:\"flightHandler\",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据 success: function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; JSONP1234567891011121314&lt;script type=\"text/javascript&gt; // 自定义的回调函数 function show(val) &#123; document.getElementById(\"show\").src=val[0].src; &#125; $.ajax(&#123; type: \"get\", url: \"myphp.php\", datatype: \"jsonp\", jsonp: \"callmyapp\", jsonpCallback: \"show\", async: true, &#125;);&lt;/script&gt; 总结只有必须要跨域请求时才使用JSONP。 参考 【原创】说说JSON和JSONP，也许你会豁然开朗，含jQuery用例 json与jsonp的区别","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"JSON","slug":"JSON","permalink":"http://blog.caoxl.com/tags/JSON/"},{"name":"JSONP","slug":"JSONP","permalink":"http://blog.caoxl.com/tags/JSONP/"}]},{"title":"CSP 学习笔记","slug":"CSP-Content-Security-Policy","date":"2018-06-27T03:01:05.000Z","updated":"2019-08-22T03:44:42.000Z","comments":true,"path":"2018/06/27/CSP-Content-Security-Policy/","link":"","permalink":"http://blog.caoxl.com/2018/06/27/CSP-Content-Security-Policy/","excerpt":"CSP Is Dead, Long Live CSP!On the Insecurity of Whitelists and the Future of Content Security Policy","text":"CSP Is Dead, Long Live CSP!On the Insecurity of Whitelists and the Future of Content Security Policy CSP ? Content Security Policy 内容安全策略 诞生场景能不能根本上解决跨域脚本攻击问题，浏览器自动禁止外部注入恶意脚本？ 这就是”网页安全政策”（Content Security Policy，缩写 CSP）的来历 CSP简介 CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。 启用CSP通过 HTTP 头信息的 Content-Security-Policy 的字段12Content-Security-Policy: script-src 'self'; object-src 'none';style-src cdn.example.org third-party.org; child-src https: 通过网页的&lt;meta&gt;标签1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:\"&gt; 说明: 上面的代码中,CSP做了如下配置 脚本: 只信任当前域名 标签: 不信任任何URL, 即不加载任何资源 样式表: 只信任cdn.example.org和third-party.org 框架(frame): 必须适应HTTPS协议加载 其他资源: 没有限制 启用后，不符合 CSP 的外部资源就会被阻止加载。 CSP限制选项CSP 提供了很多限制选项，涉及安全的各个方面。 资源加载限制 script-src: 外部脚本 style-src: 样式表 img-src: 图像 media-src: 媒体文件(音频和视频) font-src: 字体文件 object-src: 插件 child-src: 框架 frame-ancestors: 嵌入的外部资源 connect-src: HTTP 连接(通过XHR、WebSockets、EventSource等) worker-src: worker脚本 mainfest-src: manifest文件 default-srcdefault-src用来设置上面各个选项的默认值。 1Content-Security-Policy: default-src 'self' 上面代码限制所有的外部资源，都只能从当前域名加载。 如果同时设置某个单项限制（比如font-src）和default-src，前者会覆盖后者，即字体文件会采用font-src的值，其他资源依然采用default-src的值。 URL限制 frame-ancestors: 限制嵌入框架的网页 base-uri: 限制&lt;base#href&gt; form-action: 限制&lt;form#action&gt; 其他限制 block-all-mixed-content: HTTPS网页不得加载HTTP资源(浏览器已经默认开启) upgrade-insecure-requests: 自动将网页上所有加载外部资源的HTTP链接换成HTTPS协议 plugin-types: 限制可以使用的插件格式 sandbox: 浏览器行为的限制,比如不能有弹出窗口等 report-uri有时，我们不仅希望防止 XSS，还希望记录此类行为。report-uri就用来告诉浏览器，应该把注入行为报告给哪个网址。 1Content-Security-Policy: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser; 上面代码指定，将注入行为报告给/my_amazing_csp_report_parser这个 URL。 Content-Security-Policy-Report-Only除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。 它必须与report-uri选项配合使用。 1Content-Security-Policy-Report-Only: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser; 选项值每个限制选项可以设置以下几种值，这些值就构成了白名单。 主机名: exaple.org, https://example.com:443 路径名: example.org/resources/js/ 通配符: .example.org, ://.example.com: (表示任意协议、任意子域名、任意端口) 协议名: https、data 关键字’self’: 当前域名,需要加引号 关键字’none’: 禁止加载任何外部资源,需要加引号 多个值也可以并列，用空格分隔。 1Content-Security-Policy: script-src 'self' https://apis.google.com 如果同一个限制选项使用多次，只有第一次会生效。 12345# 错误的写法script-src https://host1.com; script-src https://host2.com# 正确的写法script-src https://host1.com https://host2.com script-src 的特殊值除了常规值，script-src 还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。 unsafa-inline: 允许执行页面内嵌的&amp;lt;script&gt;标签和事件监听函数 unsafe-eval: 允许将字符串当做代码执行,比如使用eval,setTimeout,setInterval和Function等函数 nonce值: 每次HTTP回应给出一个授权token, 页面内嵌脚本必须有这个token,才会执行 hash值: 列出允许执行的脚本代码的Hash值,页面内嵌脚本的哈希值只有吻合的情况下,才会执行 注意 script-src和object-src是必设的，除非设置了default-src。 因为攻击者只要能注入脚本，其他限制都可以规避。而object-src必设是因为 Flash 里面可以执行外部脚本。 script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data:URL。 举例: 12&lt;img src=\"x\" onerror=\"evil()\"&gt;&lt;script src=\"data:text/javascript,evil()\"&gt;&lt;/script&gt; 必须特别注意 JSONP 的回调函数。 123&lt;script src=\"/path/jsonp?callback=alert(document.domain)//\"&gt;&lt;/script&gt; 上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。 参考 Content Security Policy 入门教程 内容安全策略( CSP ) CSP Is Dead, Long Live CSP!","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"CSP","slug":"CSP","permalink":"http://blog.caoxl.com/tags/CSP/"}]},{"title":"XML与Array互相转换","slug":"XML-exchange-Array","date":"2018-06-27T01:52:03.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/06/27/XML-exchange-Array/","link":"","permalink":"http://blog.caoxl.com/2018/06/27/XML-exchange-Array/","excerpt":"封装XML和Array互相转换的方法","text":"封装XML和Array互相转换的方法 XML2Array12345678public static function xml2Array(string $xml)&#123; return json_decode(json_encode(simplexml_load_string( $xml, 'SimpleXMLElement', LIBXML_NOCDATA )), true);&#125; 说明 json_encode — 对变量进行 JSON 编码 json_decode — 对 JSON 格式的字符串进行解码,当该assoc为 TRUE 时，将返回 array 而非 object simplexml_load_string - 将格式良好的XML字符串将其作为对象返回 Array2XML1234567891011121314public static function array2XML(array $array, string &amp;$xml): string&#123; foreach ($array as $key =&gt; &amp;$val) &#123; if (is_array($val)) &#123; $_xml = ''; $val = self::array2XML($val, $_xml); &#125; $xml .= \"&lt;$key&gt;$val&lt;/$key&gt;\"; &#125; unset($val); return $xml;&#125; 说明 : string 写法是PHP7的新特性 参考 LIBXML预定义常量","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"PHP 常用端口","slug":"PHP-port","date":"2018-06-26T02:59:18.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/06/26/PHP-port/","link":"","permalink":"http://blog.caoxl.com/2018/06/26/PHP-port/","excerpt":"记录一些常用的端口号","text":"记录一些常用的端口号 常见端口号 Nginx 80 Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP服务器。 MySQL 3306 MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 php-fpm 9000 PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)是一个PHPFastCGI管理器，对于PHP 5.3.3之前的php来说，是一个补丁包 ，旨在将FastCGI进程管理整合进PHP包中。如果你使用的是PHP5.3.3之前的PHP的话，就必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。 php-fpm即php-Fastcgi Process Manager.php-fpm是 FastCGI 的实现，并提供了进程管理的功能。进程包含 master 进程和 worker 进程两种进程。master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方 redis 6379 redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。 memcache 11211 memcache是一套分布式的高速缓存系统 ftp 21 FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。 默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。 ssh 22 简单说，SSH是一种网络协议，用于计算机之间的加密登录。 如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 主要用于远程登录; smtp 465 SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。 HTTPS 443 超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 telnet 23 Telnet协议是一种应用层协议，使用于互联网及局域网中，使用虚拟终端机的形式，提供双向、以文字字符串为主的命令行接口交互功能。属于TCP/IP协议族的其中之一，是Internet远程登录服务的标准协议和主要方式，常用于服务器的远程控制，可供用户在本地主机运行远程主机上的工作。 DNS 53 域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"Nginx 配置详解","slug":"Nginx-Config","date":"2018-06-26T02:06:02.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/06/26/Nginx-Config/","link":"","permalink":"http://blog.caoxl.com/2018/06/26/Nginx-Config/","excerpt":"Nginx（发音同engine x）是一个异步框架的 Web服务器，也可以用作反向代理，负载平衡器 和 HTTP缓存.作为一个后起之秀的http服务器，nginx与他的老大哥apache相比，在性能上，nginx占用更少的系统资源，特定的场景应用(静态数据)能支持更多的并发连接，达到更高的访问效率；","text":"Nginx（发音同engine x）是一个异步框架的 Web服务器，也可以用作反向代理，负载平衡器 和 HTTP缓存.作为一个后起之秀的http服务器，nginx与他的老大哥apache相比，在性能上，nginx占用更少的系统资源，特定的场景应用(静态数据)能支持更多的并发连接，达到更高的访问效率； Nginx 配置管理初始化的nginx默认主配置 执行 grep -Evi &quot;#|^$&quot; nginx.conf 得到如下结果！ 或者直接找到 nginx.conf 打开即可 123456789101112131415161718192021222324worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; Nginx 配置段全局配置区 worker_processes 1; 指有一个工作的子进程，可以自行修改，因为要争CPU资源，一般设置为CPU*核数。 也可以设置成自动: worker_processes auto; Event配置区一般是配置Nginx连接的特性 worker_connections 1024; 指一个worker能同时允许产生多少个连接 配置值的时候需要结合系统参数 http服务器配置区server虚拟主机配置区 提 示: 如果未明确配置服务器IP地址访问配置，将使用第一个server配置。 基于域名的虚拟主机使用域名www.caoxl.com为例 1234567891011121314151617181920server &#123; listen 80; server_name www.caoxl.com; error_page 404 /404.html;&#125;location / &#123; root html/www; index index.html; access_log logs/www.caoxl.com_access.log main; error_loh logs/www.caoxl.com_error.log;&#125;location ~ .+\\.php.*$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; fastcgi_param SCRIPT_FILENAME $request_filename; include fastcgi_params;&#125; Nginx 日志管理我们观察Nginx的server段，可以看到如下内容： access_log logs/www.caoxl.com_access.log main; 参数1: 配置名 参数2: 指定访问日志的文件是 logs/www.caoxl.com_access.log 参数3: 使用的日志格式main格式, 同时我们也可以通过log_format配置其他格式的日志记录方式 123log_format main '$remote_addr - $remote_user [$time_local] \"$request\"' '$status $body_bytes_sent \"$http_referer\"' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; 另外和其他的web服务器一样，nginx可以针对不同的server配置不同的log 基于端口的虚拟主机以端口8080为例,域名依然使用www.caoxl.com 1234567891011121314151617181920server &#123; listen 8080; server_name www.caoxl.com; error_page 404 /404.html; location / &#123; root html/port; index index.html; access_log logs/www.caoxl.com_access.log main; error_log logs/www.caoxl.com.com_error.log; &#125; location ~ .+\\.php.*$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; fastcgi_param SCRIPT_FILENAME $request_filename; include fastcgi_params; &#125;&#125; 基于IP虚拟主机以 192.168.0.200 为默认IP配置虚拟主机 12345678910111213141516171819server &#123; listen 80; server_name 192.168.0.200; error_page 404 /404.html; location / &#123; root html/ipvhosts; index index.html; access_log logs/192.168.0.200_access.log main; error_log logs/192.168.0.200_error.log; &#125; location ~ .+\\.php.*$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; fastcgi_param SCRIPT_FILENAME $request_filename; &#125;&#125; Nginx定时任务完成日志切割任务需求：每日凌晨将nginx日志根据日期重命名日志文件进行切割。 昨天时间命令 date -d yesterday +%Y%m%d 123456789101112#!/bin/bash# filename cutlog.shDATE=$(date -d yesterday + %Y%m%d)LOG_PATH=/usr/local/nginx/logs/LOG_NAME=access.logBASE_PATH=/var/log/SAVE_LOG_NAME=$&#123;DATE&#125;.$&#123;LOG_NAME&#125;mv $&#123;LOG_PATH&#125;$&#123;LOG_NAME&#125; $&#123;BASE_PATH&#125;$&#123;SAVE_LOG_NAME&#125;kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid) 定时执行任务11/* 0 * * * /usr/bin/crontab /root/cutlog.sh &gt; /dev/null 2 &gt; &amp;1 Nginx的location详解location 语法123location [=|~|~*|^~\\ patt &#123;&#125; 参数解释： = 开头表示精确匹配 ^~开头表示uri以某个常规字符串开头,理解为匹配url路径即可 nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。 ~ 开头表示区分大小写的正则匹配 ~* 开头表示不区分大小写的正则匹配 !~ 开头表示区分大小写不匹配的正则 !~* 开头表示不区分大小写不匹配的正则 location匹配类型location匹配之精准匹配1234567location = / &#123; # 规则A&#125;location = /login &#123; # 规则B&#125; location匹配之正则匹配12345678910111213141516171819location ^~ /static/ &#123; # 规则C&#125;location ~ \\.(gif|jpg|png|js|css)$ &#123; # 规则D&#125;location ~* \\.png$ &#123; # 规则E&#125;location !~ \\.xhtml$ &#123; # 规则F&#125;location !~* \\.xhtml$ &#123; # 规则G&#125; location匹配之一般匹配123location / &#123; # 规则H&#125; location配置优先级 先判断精准匹配，如果匹配，立即返回结果并结束解析过程 然后，判断普通命中没如果有多个命中，记录最长的匹配结果 再然后判断正则表达式的解析过程，按配置里的正则表达式顺序为准，由上到下开始匹配，一旦匹配成功立即返回结果并结束解析过程。 通过上面的分析我们可以知道： 普通匹配与顺序无关，因为按照匹配的长短来取匹配结果。 正则匹配与顺序有关，因为是从上往下匹配。(首先匹配，取其之。结束解析过程) nginx的rewrite语法详解rewrite 使用环境 Server location if 重写过程中可能用到的指令1234567891011if (条件) &#123; // 设定条件再进行重写&#125;set # 设置变量return # 返回状态码break # 跳出rewriterewrite # 重写 nginx缓存expires模块控制图片等过期时间为30天，当然这个时间可以设置的更长。具体视情况而定,将下列的location配置写入server下。 123location ~\\.(gif|jpg|jpeg|png|bmp|ico)$ &#123; expires 30d;&#125; nginx.conf配置文件Nginx配置文件主要分成四部分： main（全局设置）、 server（主机设置）、 upstream（上游服务器设置，主要为反向代理、负载均衡相关配置） location（URL匹配特定位置后的设置） main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。 通用下面的nginx.conf简单的实现nginx在前端做反向代理服务器的例子，处理js、png等静态文件，jsp等动态请求转发到其它服务器tomcat： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114# nginx.confuser www www;worker_processes 2;error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;pid logs/nginx.pid;events &#123; use epoll; worker_connections 2048;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; # tcp_nopush on; keepalive_timeout 65; #gzip压缩功能设置 gzip on; gzip_min_length 1k; gzip_buffers 4 16k; gzip_http_version 1.0; gzip_comp_level 6; gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; gzip_vary on; #http_proxy设置 client_max_body_size 10m; client_body_buffer_size 128k; proxy_connect_timeout 75; proxy_send_timeout 75; proxy_read_timeout 75; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_temp_path /usr/local/nginx/proxy_temp 1 2; #设定负载均衡后台服务器列表 upstream backend &#123; #ip_hash; server 192.168.10.100:8080 max_fails=2 fail_timeout=30s ; server 192.168.11.100:8080 max_fails=2 fail_timeout=30s ; &#125; #很重要的虚拟主机配置 server &#123; listen 80; server_name itoatest.example.com; root /apps/oaapp; charset utf-8; access_log logs/host.access.log main; #对 / 所有做负载均衡+反向代理 location / &#123; root /apps/oaapp; index index.jsp index.html index.htm; proxy_pass http://backend; proxy_redirect off; #后端的web服务器可以通过X-Forward-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; &#125; #静态文件，nginx自己处理，不去backend请求tomcat location ~* /download/ &#123; root /apps/oa/fs; &#125; location ~ .*\\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123; root /apps/oaapp; expires 7d; &#125; location /nginx_status &#123; stub_status on; access_log off; allow 192.168.10.0/24; deny all; &#125; location ~ ^/(WEB-INF)/ &#123; deny all; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ## 其它虚拟主机，server 指令开始&#125; 参考 nginx服务器安装及配置文件详解","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"}]},{"title":"Swoole 快速起步","slug":"Swoole-quick-quide","date":"2018-06-15T07:02:51.000Z","updated":"2019-10-17T03:58:49.000Z","comments":true,"path":"2018/06/15/Swoole-quick-quide/","link":"","permalink":"http://blog.caoxl.com/2018/06/15/Swoole-quick-quide/","excerpt":"Swoole的绝大部分功能只能用于cli命令行环境，请首先准备好Linux Shell环境。可使用vim、emacs、phpstorm或其他编辑器编写代码，并在命令行中通过下列指令执行程序。","text":"Swoole的绝大部分功能只能用于cli命令行环境，请首先准备好Linux Shell环境。可使用vim、emacs、phpstorm或其他编辑器编写代码，并在命令行中通过下列指令执行程序。 以下是根据文档,进行实操,手敲文档. 创建TCP服务器1234567891011121314151617181920// 创建Server对象, 监听127.0.0.1:9501端口$serv = new swoole_server(&quot;127.0.0.1&quot;, 9501);// 监听连接进入事件$serv-&gt;on(&apos;connect&apos;, function ($serv, $fd) &#123; echo &quot;Client: Connection.\\n&quot;;&#125;);// 监听数据接收事件$serv-&gt;on(&apos;receive&apos;, function ($serv, $fd, $from_id, $data) &#123; $serv-&gt;send($fd, &quot;Server: &quot;.$data);&#125;);// 监听连接关闭事件$serv-&gt;on(&apos;close&apos;, function ($serv, $fd) &#123; echo &quot;Client: Close.\\n&quot;;&#125;);// 启动服务器$serv-&gt;start(); 这里就创建了一个TCP服务器，监听本机9501端口。它的逻辑很简单，当客户端Socket通过网络发送一个 hello 字符串时，服务器会回复一个 Server: hello 字符串。 123456[root@izj6c6djex81rijczh0t8yz ~]# telnet 127.0.0.1 9501Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is '^]'.hello Server: hello swoole_server是异步服务器，所以是通过监听事件的方式来编写程序的。当对应的事件发生时底层会主动回调指定的PHP函数。如当有新的TCP连接进入时会执行onConnect事件回调，当某个连接向服务器发送数据时会回调onReceive函数 服务器可以同时被成千上万个客户端连接，$fd就是客户端连接的唯一标识符 调用 $server-&gt;send() 方法向客户端连接发送数据，参数就是$fd客户端标识符 调用 $server-&gt;close() 方法可以强制关闭某个客户端连接 客户端可能会主动断开连接，此时会触发onClose事件回调 测试123telnet 127.0.0.1 9501helloServer: hello 创建UDP服务器1234567891011// 创建server对象, 监听127.0.0.1:9502端口, 类型为SWOOLE_SOCK_UDP$serv = new swoole_server(\"127.0.0.1\", 9502, SWOOLE_PROCESS, SWOOLE_SOCK_UDP);// 监听数据接收事件$serv-&gt;on('Packet', function ($serv, $data, $clientInfo) &#123; $serv-&gt;sendto($clientInfo['address'], $clientInfo['port'], \"Server\".$data); var_dump($clientInfo);&#125;);// 启动服务器$serv-&gt;start(); UDP服务器与TCP服务器不同，UDP没有连接的概念。启动Server后，客户端无需Connect，直接可以向Server监听的9502端口发送数据包。对应的事件为onPacket。 $clientInfo是客户端的相关信息，是一个数组，有客户端的IP和端口等内容 调用 $server-&gt;sendto 方法向客户端发送数据 测试123netcat -u 127.0.0.1 9502helloServer: hello 或者 123456789// 安装ncyum install -y nc// 测试[root@caoxl Start]# nc -vuz 127.0.0.1 9502Ncat: Version 7.50 ( https://nmap.org/ncat )Ncat: Connected to 127.0.0.1:9502.Server Ncat: UDP packet sent successfullyNcat: 1 bytes sent, 8 bytes received in 2.01 seconds. 创建WEB服务器123456789$http = new swoole_http_server(\"0.0.0.0\", 9501);$http-&gt;on('request', function ($request, $response) &#123; var_dump($request-&gt;get, $request-&gt;post); $response-&gt;header(\"Content-type\", \"text/html;charset=utf-8\"); $response-&gt;end(\"&lt;h1&gt;Hello Swoole.#&lt;/h1&gt;\".rand(1000, 9999).\"&lt;/h1&gt;\");&#125;);$http-&gt;start(); Http服务器只需要关注请求响应即可，所以只需要监听一个onRequest事件。当有新的Http请求进入就会触发此事件 事件回调函数有2个参数: 一个是$request对象，包含了请求的相关信息，如GET/POST请求的数据。 另外一个是response对象，对request的响应可以通过操作response对象来完成。$response-&gt;end()方法表示输出一段HTML内容，并结束此请求。 0.0.0.0 表示监听所有IP地址，一台服务器可能同时有多个IP，如127.0.0.1本地回环IP、192.168.1.100局域网IP、210.127.20.2 外网IP，这里也可以单独指定监听一个IP 9501 监听的端口，如果被占用程序会抛出致命错误，中断执行。 测试 可以打开浏览器，访问http://127.0.0.1:9501查看程序的结果。 Linux下: curl http://127.0.0.1:9501 也可以使用apache ab工具对服务器进行压力测试 创建WebSocket服务器123456789101112131415161718192021// 创建WebSocket服务器对象, 监听0.0.0.0:9502端口$ws = new swoole_websocket_server(\"0.0.0.0\", 9502);// 监听WebSocket连接打开事件$ws-&gt;on('open', function ($ws, $request) &#123; var_dump($request-&gt;fd, $request-&gt;get, $request-&gt;server); $ws-&gt;push($request-&gt;fd, \"hello, welcome\\n\");&#125;);// 监听WebSocket消息事件$ws-&gt;on('message', function ($ws, $frame) &#123; echo \"Message: &#123;$frame-&gt;data&#125;\\n\"; $ws-&gt;push($frame-&gt;fd, \"server: &#123;$frame-&gt;data&#125;\");&#125;);// 监听WebSocket连接关闭事件$ws-&gt;on('close', function ($ws, $fd) &#123; echo \"client-&#123;$fd&#125; is closed\\n\";&#125;);$ws-&gt;start(); WebSocket服务器是建立在Http服务器之上的长连接服务器，客户端首先会发送一个Http的请求与服务器进行握手。握手成功后会触发onOpen事件，表示连接已就绪，onOpen函数中可以得到$request对象，包含了Http握手的相关信息，如GET参数、Cookie、Http头信息等。 建立连接后客户端与服务器端就可以双向通信了。 客户端向服务器端发送信息时，服务器端触发onMessage事件回调 服务器端可以调用$server-&gt;push()向某个客户端（使用$fd标识符）发送消息 服务器端可以设置onHandShake事件回调来手工处理WebSocket握手 测试12345678910111213141516171819// JSvar wsServer = 'ws://127.0.0.1:9502';var websocket = new WebSocket(wsServer);websocket.onopen = function (evt) &#123; console.log(\"Connected to WebSocket server.\");&#125;websocket.onclose = function (evt) &#123; console.log(\"Disconnected\");&#125;websocket.onmessage = function (evt) &#123; console.log('Retrieved data from server:' + evt.data);&#125;websocket.onerror = function (evt, e) &#123; console.log('Error occured: ' + evt.data);&#125; 不能直接使用swoole_client与websocket服务器通信，swoole_client是TCP客户端 必须实现WebSocket协议才能和WebSocket服务器通信，可以使用swoole/framework提供的PHP WebSocket客户端 WebSocket服务器除了提供WebSocket功能之外，实际上也可以处理Http长连接。只需要增加onRequest事件监听即可实现Comet方案Http长轮询 Chrome 请求两次问题使用Chrome浏览器访问服务器，会产生额外的一次请求，/favicon.ico，可以在代码中响应404错误。 12345678$http-&gt;on('request', function ($request, $response) &#123; if ($request-&gt;server['path_info'] == '/favicon.ico' || $request-&gt;server['request_uri'] == '/favicon.ico') &#123; return $response-&gt;end(); &#125; var_dump($request-&gt;get, $request-&gt;post); $response-&gt;header(\"Content-Type\", \"text/html; charset=utf-8\"); $response-&gt;end(\"&lt;h1&gt;Hello Swoole. #\".rand(1000, 9999).\"&lt;/h1&gt;\");&#125;); 设置定时器swoole提供了类似JavaScript的setInterval/setTimeout异步高精度定时器，粒度为毫秒级。使用也非常简单。 123456789// 每隔2000ms触发一次swoole_timer_tick(2000, function ($timer_id) &#123; echo \"tick-2000ms\\n\";&#125;);// 3000ms后执行此函数swoole_timer_after(3000, function () &#123; echo \"after 3000ms.\\n\";&#125;); swoole_timer_tick函数就相当于setInterval，是持续触发的 swoole_timer_after函数相当于setTimeout，仅在约定的时间触发一次 swoole_timer_tick和swoole_timer_after函数会返回一个整数，表示定时器的ID 可以使用 swoole_timer_clear 清除此定时器，参数为定时器ID 实例1234567891011121314151617public function onWorkerStart($serv, $worker_id)&#123; $this-&gt;redis = new Redis; $this-&gt;redis-&gt;connect('127.0.0.1', 6379); $this-&gt;redis-&gt;auth('123456'); $this-&gt;redis-&gt;flushAll(); if ($worker_id === 0) &#123; $serv-&gt;tick(1000, function ($id) use ($serv) &#123; foreach ($serv-&gt;connections as $fd) &#123; $serv-&gt;push($fd, json_encode([ 'err' =&gt; 1, ])); &#125; &#125;); &#125;&#125; 执行异步任务 在Server程序中如果需要执行很耗时的操作，比如一个聊天服务器发送广播，Web服务器中发送邮件。如果直接去执行这些函数就会阻塞当前进程，导致服务器响应变慢。 Swoole提供了异步任务处理的功能，可以投递一个异步任务到TaskWorker进程池中执行，不影响当前请求的处理速度。 基于第一个TCP服务器，只需要增加onTask和onFinish2个事件回调函数即可。另外需要设置task进程数量，可以根据任务的耗时和任务量配置适量的task进程。 12345678910111213141516171819202122232425$serv = new swoole_server(\"127.0.0.1\", 9501);// 设置异步任务的工作进程数量$serv-&gt;set(array('task_worker_num' =&gt; 4));$serv-&gt;on('receive', function($serv, $fd, $from_id, $data) &#123; // 投递异步任务 $task_id = $serv-&gt;task($data); echo \"Dispath AsynTask: id=$task_id\\n\";&#125;);// 处理异步任务$serv-&gt;on('task', function($serv, $task_id, $from_id, $data) &#123; echo \"New AsynTask[id=$task_id]\".PHP_EOL; // 返回任务执行的结果 $serv-&gt;finish(\"$data-&gt; OK\");&#125;);// 处理异步任务的结果$serv-&gt;on('finish', function ($serv, $task_id, $data) &#123; echo \"AsynTask[$task_id] Finish: $data\".PHP_EOL;&#125;);$serv-&gt;start(); 调用$serv-&gt;task()后，程序立即返回，继续向下执行代码。onTask回调函数Task进程池内被异步执行。执行完成后调用$serv-&gt;finish()返回结果。 finish操作是可选的，也可以不返回任何结果 创建同步TCP客户端12345678910111213141516171819202122$client = new swoole_client(SWOOLE_SOCK_TCP);// 连接到服务器if (!$client-&gt;connect('127.0.0.1', 9501, 0.5)) &#123; die(\"Connect failed.\");&#125;// 向服务器发送数据if (!$client-&gt;send(\"hello world\")) &#123; die(\"Send failed.\");&#125;// 从服务器接收数据$data = $client-&gt;recv();if (!$data) &#123; die(\"Recv failed.\");&#125;echo $data;// 关闭连接$client-&gt;close(); 创建一个TCP的同步客户端，此客户端可以用于连接到我们第一个示例的TCP服务器。向服务器端发送一个hello world字符串，服务器会返回一个 Server: hello world字符串。 个客户端是同步阻塞的，connect/send/recv 会等待IO完成后再返回。同步阻塞操作并不消耗CPU资源，IO操作未完成当前进程会自动转入sleep模式，当IO完成后操作系统会唤醒当前进程，继续向下执行代码。 TCP需要进行3次握手，所以connect至少需要3次网络传输过程 在发送少量数据时$client-&gt;send都是可以立即返回的。发送大量数据时，socket缓存区可能会塞满，send操作会阻塞。 recv操作会阻塞等待服务器返回数据，recv耗时等于服务器处理时间+网络传输耗时之合。 创建异步TCP客户端123456789101112131415161718192021222324$client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC);// 注册连接成功回调$client-&gt;on(\"connect\", function ($cli) &#123; $cli-&gt;send(\"hello world\\n\");&#125;);// 注册数据接收回调$client-&gt;on(\"receive\", function ($cli, $data) &#123; echo \"Received: \".$data.\"\\n\";&#125;);// 注册连接失败回调$client-&gt;on(\"error\", function ($cli) &#123; echo \"Connect failed\\n\";&#125;);// 注册连接关闭回调$client-&gt;on(\"close\", function ($cli) &#123; echo \"Connection close\\n\";&#125;);// 发起连接$client-&gt;connect('127.0.0.1', 9501, 0.5); 异步客户端与上一个同步TCP客户端不同，异步客户端是非阻塞的。可以用于编写高并发的程序。swoole官方提供的redis-async、mysql-async都是基于异步swoole_client实现的。 异步客户端需要设置回调函数，有4个事件回调必须设置onConnect、onError、onReceive、onClose。分别在客户端连接成功、连接失败、收到数据、连接关闭时触发。 $client-&gt;connect() 发起连接的操作会立即返回，不存在任何等待。当对应的IO事件完成后，swoole底层会自动调用设置好的回调函数。 异步客户端只能用于cli环境 网络通信协议设计为什么需要通信协议? TCP协议在底层机制上解决了UDP协议的顺序和丢包重传问题。但相比UDP又带来了新的问题，TCP协议是流式的，数据包没有边界。应用程序使用TCP通信就会面临这些难题。 因为TCP通信是流式的，在接收1个大数据包时，可能会被拆分成多个数据包发送。多次Send底层也可能会合并成一次进行发送。这里就需要2个操作来解决： 分包：Server收到了多个数据包，需要拆分数据包 合包：Server收到的数据只是包的一部分，需要缓存数据，合并成完整的包 所以TCP网络通信时需要设定通信协议。常见的TCP网络通信协议有 HTTP、HTTPS、FTP、SMTP、POP3、IMAP、SSH、Redis、Memcache、MySQL 。 如果要设计一个通用协议的Server，那么就要按照通用协议的标准去处理网络数据。除了通用协议外还可以自定义协议。Swoole支持了2种类型的自定义网络通信协议。 EOF结束符协议 EOF协议处理的原理是每个数据包结尾加一串特殊字符表示包已结束。如memcache、ftp、stmp都使用\\r\\n作为结束符。发送数据时只需要在包末尾增加\\r\\n即可。使用EOF协议处理，一定要确保数据包中间不会出现EOF，否则会造成分包错误。 在swoole_server和swoole_client的代码中只需要设置2个参数就可以使用EOF协议处理。 123456789$server-&gt;set(array( 'open_eof_split' =&gt; true, 'package_eof' =&gt; \"\\r\\n\",));$client-&gt;set(array( 'open_eof_split' =&gt; true, 'package_eof' =&gt; \"\\r\\n\",)); 固定包头+包体协议固定包头的协议非常通用，在BAT的服务器程序中经常能看到。这种协议的特点是一个数据包总是由包头+包体2部分组成 包头由一个字段指定了包体或整个包的长度，长度一般是使用2字节/4字节整数来表示。服务器收到包头后，可以根据长度值来精确控制需要再接收多少数据就是完整的数据包。 Swoole的配置可以很好的支持这种协议，可以灵活地设置4项参数应对所有情况。 Swoole的Server和异步Client都是在onReceive回调函数中处理数据包，当设置了协议处理后，只有收到一个完整数据包时才会触发onReceive事件 同步客户端在设置了协议处理后，调用 $client-&gt;recv() 不再需要传入长度，recv函数在收到完整数据包或发生错误后返回。 1234567$server-&gt;set(array( 'open_length_check' =&gt; true, 'package_max_length' =&gt; 81920, 'package_length_type' =&gt; 'n', //see php pack() 'package_length_offset' =&gt; 0, 'package_body_offset' =&gt; 2,)); 使用异步客户端PHP提供的MySQL、CURL、Redis 等客户端是同步的，会导致服务器程序发生阻塞。Swoole提供了常用的异步客户端组件，来解决此问题。编写纯异步服务器程序时，可以使用这些异步客户端。 异步客户端可以配合使用SplQueue实现连接池，以达到长连接复用的目的。在实际项目中可以使用PHP提供的Yield/Generator语法实现半协程的异步框架。也可以基于Promises简化异步程序的编写。 MySQL123456789101112131415$db = new Swoole\\MySQL;$server = array( 'host' =&gt; '127.0.0.1', 'user' =&gt; 'test', 'password' =&gt; 'test', 'database' =&gt; 'test',);$db-&gt;connect($server, function ($db, $result) &#123; $db-&gt;query(\"show tables\", function (Swoole\\MySQL $db, $result) &#123; var_dump($result); $db-&gt;close(); &#125;);&#125;); 与mysqli和PDO等客户端不同，Swoole\\MySQL是异步非阻塞的，连接服务器、执行SQL时，需要传入一个回调函数。connect的结果不在返回值中，而是在回调函数中。query的结果也需要在回调函数中进行处理。 Redis123456789$redis = new Swoole\\Redis;$redis-&gt;connect('127.0.0.1', 6379, function ($redis, $result) &#123; $redis-&gt;set('test_key', 'value', function ($redis, $result) &#123; $redis-&gt;get('test_key', function ($redis, $result) &#123; var_dump($result); &#125;); &#125;);&#125;); Http1234567891011$cli = new Swoole\\Http\\Client('127.0.0.1', 80);$cli-&gt;setHeaders(array('User-Agent' =&gt; 'swoole-http-client'));$cli-&gt;setCookies(array('test' =&gt; 'value'));$cli-&gt;post('/dump.php', array(\"test\" =&gt;' abc'), function ($cli) &#123; var_dump($cli-&gt;body); $cli-&gt;get('/index.php', function ($cli) &#123; var_dump($cli-&gt;cookies); var_dump($cli-&gt;headers); &#125;);&#125;); Swoole\\Http\\Client的作用与CURL完全一致，它完整实现了Http客户端的相关功能。具体请参考 HttpClient文档 其他客户端Swoole底层目前只提供了最常用的MySQL、Redis、Http异步客户端，如果你的应用程序中需要实现其他协议客户端，如Kafka、AMQP等协议，可以基于Swoole\\Client异步TCP客户端，开发相关协议解析代码，来自行实现 多进程共享数据由于PHP语言不支持多线程，因此Swoole使用多进程模式。在多进程模式下存在进程内存隔离，在工作进程内修改global全局变量和超全局变量时，在其他进程是无效的。 进程隔离1234567$fds = array();$server-&gt;on('connect', function ($server, $fd)&#123; echo \"connection open: &#123;$fd&#125;\\n\"; global $fds; $fds[] = $fd; var_dump($fds);&#125;); $fds 虽然是全局变量，但只在当前的进程内有效。Swoole服务器底层会创建多个Worker进程，在var_dump($fds)打印出来的值，只有部分连接的fd。 对应的解决方案就是使用外部存储服务： 数据库，如：MySQL、MongoDB 缓存服务器，如：Redis、Memcache 磁盘文件，多进程并发读写时需要加锁 普通的数据库和磁盘文件操作，存在较多IO等待时间。因此推荐使用： Redis 内存数据库，读写速度非常快 /dev/shm 内存文件系统，读写操作全部在内存中完成，无IO消耗，性能极高 除了使用存储之外，还可以使用共享内存来保存数据 参考 快速起步","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"}]},{"title":"Swoole 体验篇 (Socket服务器)","slug":"Swoole-Socket-Intro","date":"2018-06-14T06:55:57.000Z","updated":"2019-08-22T06:40:03.000Z","comments":true,"path":"2018/06/14/Swoole-Socket-Intro/","link":"","permalink":"http://blog.caoxl.com/2018/06/14/Swoole-Socket-Intro/","excerpt":"做的一个项目要用到 Socket 长链接，Google 了一番最终使用的是 Swoole，这里简单介绍一下。","text":"做的一个项目要用到 Socket 长链接，Google 了一番最终使用的是 Swoole，这里简单介绍一下。 简介使用场景这里的需求是这样的，iOS 应用处于打开状态时，服务器能根据业务最新状态决定是否发送给该应用一些数据，即：服务器在满足某些条件时，主动给客户端发送消息。 一般情况下指的只给在线用户推送消息. 短连接在这种场景下，App 可以使用 http 接口主动轮询服务器（短连接），然后根据服务器的返回状态做一些相应操作，但是这种做法有如下不足： 低效 假设很长时间都没有事件发生，即服务器很长时间都没有返回新的数据，但是 App 却总在向服务器发相同的 http 请求（打开一个新的连接），那么这段无事发生的期间就是在做无用功。 浪费客户端和服务器双方资源 客户端发请求需要占用客户端资源，服务器响应需要占用服务器资源。 长连接当然目前更高效的做法就是使用长连接。（TCP，非 HTTP ） 在每次客户端发出请求后，服务器检查上次返回的数据与此次请求时的数据之间是否有更新，如果有更新则返回新数据并结束此次连接，否则服务器保持此次连接，直到有新数据时再返回相应 长链接比短链接高效的地方在于：减少了打开新连接个数和无用响应数。在保持长连接期间，C/S 交互都使用的是同一个连接，这极大减少了资源浪费。 为什么选择 Swoole ?处于对 Swoole 在圈内的名声和口碑的信心，我这里选择了 Swoole 来实现这个需求。 Swoole 本质是一个标准的 PHP 扩展，但是又与普通的 PHP 扩展又有很大的区别： 普通的扩展只是提供一个库函数。而swoole扩展在运行后会接管PHP的控制权，进入事件循环。当IO事件发生后，swoole会自动回调指定的PHP函数。 Swoole 可以扮演的角色有很多：服务器、客户端、事件 API、异步 IO 接口、进程管理、内存区管理、高性能内存表等，而这里，我只需要一个 Socket 服务器。 安装配置 请下载releases版本的swoole，直接从github主干上拉取最新代码可能会编译不过。 1234567891011121314151617# 1.下载（https://github.com/swoole/swoole-src/releases）wget https://github.com/swoole/swoole-src/archive/1.8.10-stable.zip# 2.编译安装cd swoole-src-swoole-1.8.10-stable/phpize./configuresudo makesudo make install# Or：`pecl install swoole`# 3. 配置 php.iniextension=swoole.so# 4. 检查php -m | grep swoole 说明：swoole_server 绝大部分功能只能用于 php-cli 环境，否则会抛出致命错误。 使用示例：服务器主动发送消息这里只提供服务端的代码和返回的通信接口格式。客户端和服务器通信只需要按照事先规定好的数据格式进行通信就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;?phpclass Server&#123; private $db_conf = [ 'host' =&gt; '127.0.0.1', 'port' =&gt; '3306', 'name' =&gt; 'root', 'pwd' =&gt; '123456', 'db' =&gt; 'proj' ]; private $secret = '10be8c337984d3a3c470f7cf5239c298'; private $mysql = null, private $serv; public function __construct() &#123; $this-&gt;serv = new swoole_server(\"0.0.0.0\", 9501); $this-&gt;serv-&gt;set(array( 'worker_num' =&gt; 8, 'daemonize' =&gt; false, )); if ($this-&gt;serv &amp;&amp; !$this-&gt;mysql) $this-&gt;mysqli_reconnect(); if ($this-&gt;mysql &amp;&amp; $this-&gt;mysql-&gt;set_charset('utf8')) &#123; $this-&gt;serv-&gt;on('Start', array($this, 'onStart')); $this-&gt;serv-&gt;on('Connect', array($this, 'onConnect')); $this-&gt;serv-&gt;on('Receive', array($this, 'onReceive')); $this-&gt;serv-&gt;on('Close', array($this, 'onClose')); $this-&gt;serv-&gt;start(); &#125; &#125; public function mysqli_reconnect() &#123; $this-&gt;mysql = new mysqli( $this-&gt;db_conf['host'], $this-&gt;db_conf['name'], $this-&gt;db_conf['pwd'], $this-&gt;db_conf['db'], $this-&gt;db_conf['port'] ); return $this-&gt;mysql; &#125; public function onStart( $serv ) &#123; // echo \"Swoole socket Server Started. \\n\"; &#125; public function onConnect( $serv, $fd, $from_id) &#123; // $serv-&gt;send( $fd, \"Hello &#123;$fd&#125;!\"); &#125; public function onReceive( swoole_server, $serv, $fd, $from_id, $data) &#123; // echo \"Get Message From Client &#123;$fd&#125;:&#123;$data&#125;\\n\"; $response = [ 'nq_id' =&gt; 'empty', 'nq_data' =&gt; 'empty', 'nq_ref' =&gt; 'empty', 'nq_type' =&gt; 'empty', ]; if ($data) &#123; $arr = json_decode($data, true); if ($arr &amp;&amp; is_array($arr) &amp;&amp; (isset($arr['secret']) &amp;&amp; ($arr['secret'] == $this-&gt;secret)) &amp;&amp; in_array($arr['option'], ['nothing', 'query', 'return']) &amp;&amp; isset($arr['uid']) &amp;&amp; is_numeric($arr['uid'])) &#123; if ($arr['option'] == 'query') &#123; // 查询user_id 为 $arr['uid']的所有消息记录 $sql = 'select * from bm_notice_queues where nq_uid =' .$arr['uid'] .'limit 1'; if ($this-&gt;mysql-&gt;errno == 2006) &#123; while(!$this-&gt;mysqli_reconnect()) &#123; $this-&gt;mysqli_reconnect(); &#125; &#125; $res = $this-&gt;mysql-&gt;query($sql); if ($res &amp;&amp; is_object($res) &amp;&amp; $res-&gt;num_rows) &#123; if ($row = $res-&gt;fetch_assoc()) &#123; $response['nq_id'] = $row['nq_id']; $response['nq_data'] = $row['nq_data']; $response['nq_ref'] = $row['nq_ref']; $response['nq_type'] = $row['nq_type']; &#125; &#125; &#125; elseif ($arr['option'] == 'return') &#123; if (($arr['status'] == 'success') &amp;&amp; is_numeric($arr['return']) &amp;&amp; $arr['return'] &gt; 0) &#123; // 删除 id 为 $arr['return']的消息记录 $sql = 'delete from bm_notice_queues where nq_id = '.$arr['return']; if ($this-&gt;mysql-&gt;errno == 2006) &#123; while(!$this-&gt;mysqli_reconnect()) &#123; $this-&gt;mysqli_reconnect(); &#125; &#125; $this-&gt;mysql-&gt;query($sql); &#125; &#125; &#125; &#125; $serv-&gt;send($fd, json_encode($response)); &#125; public function onClose( $serv, $fd, $from_id) &#123; // echo \"Client &#123;$fd&#125; close connection\\n\"; &#125;&#125;# 启动服务器$server = new Server(); 可能用到的指令 定位到php.ini的绝对路径： 1php -i | grep php.ini 查看端口号是否被 监听 1netstat -an | grep &lt;PORT&gt; 参考 转载自: Swoole 开发：体验篇（Socket 服务器） mac 安装 swoole扩展","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"}]},{"title":"Git 服务器 搭建/自动部署/远程连接","slug":"Git-Server-Deploy","date":"2018-06-14T01:41:20.000Z","updated":"2019-08-22T03:42:12.000Z","comments":true,"path":"2018/06/14/Git-Server-Deploy/","link":"","permalink":"http://blog.caoxl.com/2018/06/14/Git-Server-Deploy/","excerpt":"对于不想给Github之类的代码托管掏钱的人.搭建一个自己的Git服务器很有必要","text":"对于不想给Github之类的代码托管掏钱的人.搭建一个自己的Git服务器很有必要 GIT服务器搭建 安装git 1234yum install git// Ubuntusudo apt-get install git 创建git用户/组 12useradd gitgroupadd git 如果忘记git用户密码: sudo passwd git 重置即可 创建git裸仓库 1sudo git init --bare sample.git 创建证书登录 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/root/.ssh/authorized_keys文件里，一行一个。 1234git config --global user.email \"code0809@163.com\"git config --global user.name \"SoulMate94.\"ssh-keygen -t rsa -C \"code0809@163.com\" 初始化Git仓库 1sudo git init --bare dirname.git // dirname 设置为自己想要的项目目录名称 Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： 1sudo chown -R git:git dirname.git 禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： 12vim /etc/passwdgit:x:1002:1002:,,,:/home/git:/bin/bash 改为: 1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 克隆远程仓库： 1234git clone git@server:/dirname.gitCloning into 'dirname'...warning: You appear to have cloned an empty repository. 添加远程仓库到本地12git initgit remote add origin git@server:/dirname.git 查看远程仓库12345git remote -v例:origin git@47.91.221.85:/home/wwwroot/git/sample.git (fetch)origin git@47.91.221.85:/home/wwwroot/git/sample.git (push) 操作12345678// 在第一次进行push时,我们加上-u参数,后期push时就不用再加-u参数git push -u origin master// 正常工作中git pull origin master // 拉取仓库代码, 解决冲突git add . // 将文件添加到本地版本库git commit -m \"注释\" // 将文件修改提交到仓库git push origin master // 这里origin 仅代表远程仓库在本地的连接名称 远程仓库操作命令: 检出 1git clone git@server:/dirname.git 查看 1git remote -v 添加 1git remote add remoteName(连接名) git@server:/dirname.git 删除 1git remote rm remoteName(连接名) 修改 1git remote set-url --push remoteName(连接名) git@server:/dirname.git 拉取 1git pull remoteName(连接名) Git pull 强制覆盖本地文件 ? 123git fetch --allgit reset --hard origin/mastergit pull 推送 1git push remoteNmae(连接名) PHPStorm连接远程服务器 首先打开phpstorm选择：Tools-&gt;Deployment-&gt;Configuration 点击新建 操作测试/成功截图 远程服务器自动部署 sample 为自定义目录名称 sample.git/hooks/post-receive 12345678910#!/bin/shunset GIT_INDEX_FILEecho \"=&gt; update source code to the latest\"while read oldrev newrev refdo branch=$(git rev-parse --symbolic --abbrev-ref $refname) echo \"$branch\" git --work-tree=/home/wwwroot/sample --git-dir=/home/wwwroot/git/sample.git git checkout $branch -fdone 需要自定义: --work-tree=/home/wwwroot/sample 是工作目录--git-dir=/home/wwwroot/git/sample.git 是.git目录 sample.git/config 1234567891011[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true worktree = /home/wwwroot/sample[receive] denycurrentbranch = ignore 需要自定义: worktree = /home/wwwroot/sample 是工作目录 用户权限设置12345678// Git 仓库的 owner 修改为 gitchown -R git:git dirname.git// .ssh 文件夹的 owner 修改为 gitchown -R git:git .ssh// 工作目录文件夹的 owner 修改为 gitchown -R git:git work_dir 注意配置里面不能有//注释符!","categories":[{"name":"Git / Svn","slug":"Git-Svn","permalink":"http://blog.caoxl.com/categories/Git-Svn/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.caoxl.com/tags/Git/"}]},{"title":"心跳检测","slug":"Heart-Rate-PRO","date":"2018-06-13T07:43:58.000Z","updated":"2019-08-22T03:44:54.000Z","comments":true,"path":"2018/06/13/Heart-Rate-PRO/","link":"","permalink":"http://blog.caoxl.com/2018/06/13/Heart-Rate-PRO/","excerpt":"为什么需要心跳检测？有些极端情况如客户端掉电、网络关闭、拔网线、路由故障等，这些极端情况都属于连接断开的情况，然而这些情况如果没有应用层的心跳检测，服务端是无法快速感知的。而服务端定时向客户端发送心跳数据可以解决这个问题。","text":"为什么需要心跳检测？有些极端情况如客户端掉电、网络关闭、拔网线、路由故障等，这些极端情况都属于连接断开的情况，然而这些情况如果没有应用层的心跳检测，服务端是无法快速感知的。而服务端定时向客户端发送心跳数据可以解决这个问题。 心跳检测的原理是什么？ 判断对方（设备，进程或其它网元）是否正常动行，一般采用定时发送简单的通讯包，如果在指定时间段内未收到对方响应，则判断对方已经当掉。用于检测TCP的异常断开。 服务端向客户端发送心跳检测，客户端接收到心跳数据后，可以忽略不做任何处理，也可以回应心跳检测, 这就分为两种情况: 当服务端不要求客户端必须回应心跳检测时，假如客户端遇到掉电等极端情况，这时服务端向客户端发送的心跳数据在TCP层面就会发送超时，遇到这种超时情况TCP会重试多次（次数及间隔依赖操作系统的配置），多次无果后会断开连接。这种极端情况从连接断开到服务端检测到可能要持续至少10分钟。 当服务端要求必须回应检测时，如果服务端在规定的时间内没有收到客户端的任何数据，则立刻判定客户端已经断开，服务端就立即断开连接。 心跳检测可以是服务端主动，也可以是客户端主动，一般客户端来发会好点，对服务端压力没那么大 “心跳”分为两种，第一种是客户端发起的心跳，第二种是服务端发起的心跳。客户端发起的心跳客户端每隔一段时间发送策略消息给Socket服务器，Socket服务器原路返回策略消息，如果客户端在设定时间段内没有收到Socket服务器的返回消息，经重试机制后，判定Socket服务器已Down，关闭连接。 服务端发起的心跳服务端实时记录每条Socket的IO操作时间，每隔一段时间获取所有Socket列表的快照，扫描每条Socket，如果该Socket的IO操作时间距当前时间已超出设定值，则判定客户端Down，关闭连接。 基于Workerman的PHP心跳12345678910111213141516171819202122232425262728293031323334353637&lt;?phprequire_once __DIR__.'/Workerman/Autoloader.php';use Workerman\\Worker;use Workerman\\Lib\\Timer;define('HEARTBEAT_TIME', 25); //心跳间隔25秒$worker = new Worker('text://0.0.0.0:1234');$worker-&gt;onMessage = function ($connection, $msg) &#123; // 给connection临时设置一个lastMessageTime属性，用来记录上次收到消息的时间 $connection-&gt;lastMessageTime = time(); //&#125;;// 进程启动后设置一个每秒运行一次的定时器$worker-&gt;onWorkerStart = function($worker) &#123; Timer::add(1, function () use ($worker) &#123; $time_now = time(); foreach ($worker-&gt;connections as $connection) &#123; // 有可能该connection还没收到过消息，则lastMessageTime设置为当前时间 if (empty($connection-&gt;lastMessageTime)) &#123; $connection-&gt;lastMessageTime = $time_now; continue; &#125; // 上次通讯时间间隔大于心跳间隔，则认为客户端已经下线，关闭连接 if ($time_now - $connection-&gt;lastMessageTime &gt; HEARTBEAT_TIME) &#123; $connection-&gt;close(); &#125; &#125; &#125;);&#125;;Worker::runAll(); Swoole做心跳检测事实上，Swoole已经内置了心跳检测功能，能自动close掉长时间没有数据来往的连接。而开启心跳检测功能，只需要设置heartbeat_check_interval和heartbeat_idle_time即可。如下： 123456$this-&gt;serv-&gt;set( array( 'headerbeat_check_interval' =&gt; 60, 'headerbeat_idle_time' =&gt; 600, )); 其中heartbeat_idle_time的默认值是heartbeat_check_interval的两倍。在设置这两个选项后，swoole会在内部启动一个线程，每隔heartbeat_check_interval秒后遍历一次全部连接，检查最近一次发送数据的时间和当前时间的差，如果这个差值大于heartbeat_idle_time，则会强制关闭这个连接，并通过回调onClose通知Server进程结合之前的Timer功能，如果我们想维持连接，就设置一个略小于如果这个差值大于heartbeat_idle_time的定时器，在定时器内向所有连接发送一个心跳包。如果收到心跳回应，则判断连接正常，如果没有收到，则关闭这个连接或者再次尝试发送。 互联网推送原理: 长连接＋心跳机制 参考 workerman心跳检测原理 Timer定时器、心跳检测及Task进阶实例：mysql连接池","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"心跳检测","slug":"心跳检测","permalink":"http://blog.caoxl.com/tags/心跳检测/"}]},{"title":"MySQL 大表优化","slug":"MySQL-large-table-opt","date":"2018-06-13T05:33:27.000Z","updated":"2019-08-22T06:28:44.000Z","comments":true,"path":"2018/06/13/MySQL-large-table-opt/","link":"","permalink":"http://blog.caoxl.com/2018/06/13/MySQL-large-table-opt/","excerpt":"当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化：","text":"当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化： 单表优化除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量 字段 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED VARCHAR的长度只分配真正需要的空间 使用枚举或整数代替字符串类型 (推荐使用TINYINT替代枚举) 尽量使用TIMESTAMP而非DATETIME，(时间推荐INT) 单表不要有太多字段，建议在20以内 避免使用NULL字段，很难查询优化且占用额外索引空间 用整型来存IP 索引 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描 值分布很稀少的字段不适合建索引，例如”性别”这种只有两三个值的字段 字符字段只建前缀索引 字符字段最好不要做主键 不用外键，由程序保证约束 尽量不用UNIQUE，由程序保证约束 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引 查询SQL 可通过开启慢查询日志来找出较慢的SQL 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边 sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库 不用 SELECT * OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内 不用函数和触发器，在应用程序实现 避免%xxx式查询 少用JOIN 使用同类型进行比较，比如用&#39;123&#39;和&#39;123&#39;比，123和123比 尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大 引擎目前广泛使用的是MyISAM和InnoDB两种引擎： MyISAMMyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是： 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁 不支持事务 不支持外键 不支持崩溃后的安全恢复 在表有读取查询的同时，支持往表中插入新纪录 支持BLOB和TEXT的前500个字符索引，支持全文索引 支持延迟更新索引，极大提升写入性能 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用 InonoDBInnoDB在MySQL 5.5后成为默认索引，它的特点是： 支持行锁，采用MVCC来支持高并发 支持事务 支持外键 支持崩溃后的安全恢复 不支持全文索引 (5.6以上支持) 系统调优参数可以使用下面几个工具来做基准测试： sysbench:一个模块化，跨平台以及多线程的性能测试工具 iibench-mysql:基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具 tpcc-mysql:Percona开发的TPC-C测试工具 具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数： back_log: back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500 wait_timeout: 数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时 max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限 thread_concurrency: 并发线程数，设为CPU核数的两倍 skip_name_resolve: 禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问 key_buffer_size: 索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M， 通过查询show status like &#39;key_read%&#39;，保证key_reads / key_read_requests在0.1%以下最好 innodb_buffer_pool_size: 缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like &#39;Innodb_buffer_pool_read%&#39;，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests 越高越好 innodb_additional_mem_pool_size: InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小 innodb_log_buffer_size: InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB query_cache_size: 缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大. 可以通过命令show status like &#39;Qcache_%&#39;查看目前系统Query catch使用大小 read_buffer_size: MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能 sort_buffer_size: MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小 read_rnd_buffer_size: MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。 record_buffer: 每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值 thread_cache_size: 保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的 table_cache: 类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM 升级硬件Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能 花钱总是比不花钱来的简单~~~ 读写分离也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离 缓存缓存可以发生在这些层次： MySQL内部：在系统调优参数介绍了相关设置 数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象Persistence Object 应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象Data Transfer Object Web层：针对web页面做缓存 浏览器客户端：用户端的缓存 可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式： 直写式（Write Through）： 在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。 回写式（Write Back）： 当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。 表分区MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码 对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引 用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上： 1234567mysql&gt; explain partitions select count(1) from user_partition where id in (1,2,3,4,5);+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+| 1 | SIMPLE | user_partition | p1,p4 | range | PRIMARY | PRIMARY | 8 | NULL | 5 | Using where; Using index |+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+1 row in set (0.00 sec) 分区的好处是： 可以让单表存储更多的数据 分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作 部分查询能够从查询条件确定只落在少数分区上，速度会很快 分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备 可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争 可以备份和恢复单个分区 分区的限制和缺点： 一个表最多只能有1024个分区 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来 分区表无法使用外键约束 NULL值会使分区过滤无效 所有分区必须使用相同的存储引擎 分区的类型： RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区 LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择 HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式 KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值 分区适合的场景有：最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示： 1234567891011121314CREATE TABLE members ( firstname VARCHAR(25) NOT NULL, lastname VARCHAR(25) NOT NULL, username VARCHAR(16) NOT NULL, email VARCHAR(35), joined DATE NOT NULL)PARTITION BY RANGE( YEAR(joined) ) ( PARTITION p0 VALUES LESS THAN (1960), PARTITION p1 VALUES LESS THAN (1970), PARTITION p2 VALUES LESS THAN (1980), PARTITION p3 VALUES LESS THAN (1990), PARTITION p4 VALUES LESS THAN MAXVALUE); 查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。 如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存 另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代 垂直分表 垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联 比如原始的用户表是： 垂直拆分后是： 优点: 可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block就少) 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起 数据维护简单 缺点: 主键出现冗余，需要管理冗余列 会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力 依然存在单表数据量过大的问题（需要水平拆分） 事务处理复杂 水平分表 水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表 库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决 前面垂直拆分的用户表如果进行水平拆分，结果是： 实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表 优点 不存在单库大数据和高并发的性能瓶颈 应用端改造较少 提高了系统的稳定性和负载能力 缺点 分片事务一致性难以解决 跨节点Join性能差，逻辑复杂 数据多次扩展难度跟维护量极大 分片原则 能不分就不分，参考单表优化 分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量 分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容 尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题 查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。 通过数据冗余和表分区赖降低跨库Join的可能 这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。 总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。 解决方案由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。 客户端架构通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现 可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现 优点 应用直连数据库，降低外围系统依赖所带来的宕机风险 集成成本低，无需额外运维的组件 缺点 限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心 将分片逻辑的压力放在应用服务器上，造成额外风险 代理架构通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件 代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理 优点 能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强 对于应用服务器透明且没有增加任何额外负载 缺点 需部署和运维独立的代理中间件，成本高 应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险 NoSQL在MySQL上做Sharding是一种戴着镣铐的跳舞，事实上很多大表本身对MySQL这种RDBMS的需求并不大，并不要求ACID，可以考虑将这些表迁移到NoSQL，彻底解决水平扩展问题，例如： 日志类、监控类、统计类数据 非结构化或弱结构化数据 对事务要求不强，且无太多关联操作的数据 参考 MySQL大表优化方案","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"}]},{"title":"高并发和大流量解决方案","slug":"High-Conc-Large-Flow","date":"2018-06-13T01:07:09.000Z","updated":"2019-08-22T03:44:58.000Z","comments":true,"path":"2018/06/13/High-Conc-Large-Flow/","link":"","permalink":"http://blog.caoxl.com/2018/06/13/High-Conc-Large-Flow/","excerpt":"解决高并发和大流量问题","text":"解决高并发和大流量问题 我们说的高并发是什么? 在互联网时代,所讲的并发、高并发,通常是指并发访问。也就是在某个时间点,有多少个访问同时到来通常如果一个系统的日PV在干万以上,有可能是一个高并发的系统 高并发的问题,我们具体该关心什么? QPS 每秒钟请求或者査询的数量,在互联网领域,指毎秒响应请求数(指HTTP请求);一个页面中可能有多个 http 请求: (总PV数*80%)/(6小时秒数*20%)=峰值每秒请求数(QPS) 吞吐量 单位时间内处理的请求数量(通常由QPS与并发数决定) 响应时间 从请求发出到收到响应花费的时间。例如系统处理一个HTTP请求需要100ms,这个100ms就是系统的响应时间 PV 综合浏览量(Page view),即页面浏览量或者点击量,个访客在24小时內访问的页面数量 UV 独立访客(Unique Visitor),即一定时间范围内相同访客多次访问网站,只计算为1个独立访客 带宽 计算带宽大小需关注两个指标,峰值流量和页面的平均大小日网站带宽=PV/统计时间(换算到秒)*平均页面大小(单位KB)*8 常用性能测试工具ab、wrk、 http_load、 Web bench、 Siege、 Apache Jmeter ab概念 全称是 apache benchmark,是 apache官方推出的工具刨建多个并发访问线程,模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的,因此,它既可以用来测试apache的负载压力,也可以测试 nginx、 lighthttp、 tomcat、IS等其它Web服务器的压力 ab的使用12模拟并发请求100次,总共请求5000次ab -c 100 -n 5000 www.demo.com 注意事项 测试机器与被测试机器分开 不要对线上服务做压力测试 观察测试工具ab所在机器,以及被测试的前端机的cPU,内存,网络等都不超过最高限度的75% (top 命令) 详细请看: Linux 命令 「ab」 QPS划分QPS达到50可以称之为小型网站,一般的服务器就可以应付,无需优化 QPS达到100假设关系型数据库的每次请求在0.01秒完成假设单页面只有一个SQL查询,那么100QPS意味着1秒钟完成100次请求,但是此时我们并不能保证数据库查询能完成100次 方案:数据库缓存层、数据库的负载均衡 QPS达到800假设我们使用百兆带宽,意味着网站出口的实际带宽是8M左右假设每个页面只有10K,在这个并发条件下,百兆带宽已经吃完 方案:CDN加速、负载均衡 QPS达到1000假设使用 Memcache缓存数据库查询数据,每个页面对Memcache的请求远大于直接对DB的请求Memcache的悲观并发数在2W左右,但有可能在之前内网带宽已经吃光,表现出不稳定 方案:静态HTML缓存 QPS达到2000这个级别下,文件系统访问锁都成为了灾难 方案:做业务分离,分布式存储 数据库的优化 数据库的缓存(memcache 缓存,redis 缓存等) 分库分表、分区操作 读写分离 负载均衡 数据表数据类型优化字段使用什么样的数据类型更合适 tinyint (0-255) smallint , bigint char, varchar enum 特定、固定的分类可以使用enum存储,效率更快 `IP地址的存储 //用 php 的 ip2long(‘192.168.1.38’); //3232235814 对字段进行 not null 这样,存储的字段就不会有 null 值 ,只有空值 索引优化 索引不是越多越好,在合适的字段上创建合适的索引 复合索引的前缀原则 like查询%的问题(% 在前如:%name 则索引失败) 全表扫描优化 or条件索引使用情况 字符串类型索引失效的问题(如字符串类型的字段必须要加引号查询) SQL语句的优化 优化查询过程中的数据访问 优化长难句的查询语句 优化特定类型的查询语句 使用 Limit 返回列不用* 变复杂为简单 切分查询(如删大量数据时,可分多次删除) 分解关联查询 优化 count() (如对统计数据单独存放在一个字段,而不是进行 count() 统计) 优化关联查询 优化子查询 优化 Group by 和 distinct 优化 limit 和 union 存储引擎优化尽量使用 Inno DB存储引擎 数据表结构设计的优化分区操作 通过特定的策略对数据表进行物理拆分 对用户透明 partition by (分区) 对新建表进行分区 123456789101112131415CREATE TABLE employees ( id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30), hired DATE NOT NULL DEFAULT '1970-01-01', separated DATE NOT NULL DEFAULT '9999-12-31', job_code INT NOT NULL, store_id INT NOT NULL)PARTITION BY RANGE (store_id) ( PARTITION p0 VALUES LESS THAN (6), PARTITION p1 VALUES LESS THAN (11), PARTITION p2 VALUES LESS THAN (16), PARTITION p3 VALUES LESS THAN MAXVALUE); 对已有表进行分区 123456ALTER TABLE user PARTITION BY RANGE (id)( PARTITION p_Apr VALUES LESS THAN (2),PARTITION p_May VALUES LESS THAN (4), PARTITION p_Dec VALUES LESS THAN MAXVALUE ); 分库分表 水平拆分 垂直拆分 数据库服务器架构的优化 主从复制 读写分离 双主热备 负载均衡: 通过LVS的三种基本模式实现负载均衡 My Cat数据库中间件实现负载均衡 流量优化-防盗链防盗链处理盗链概念 盗链是指在自己的页面上展示一些并不在自己服务器上的内容获得他人服务器上的资源地址,绕过别人的资源展示页面,直接在自己的页面上向最终用户提供此内容 常见的是小站盗用大站的图片、音乐、视频、软件等资源通过盗链的方法可以减轻自己服务器的负担,因为真实的空间和流量均是来自别人的服务器 防盗链概念 防止别人通过一些技术手段绕过本站的资源展示页面,盗用本站的资源,让绕开本站资源展示页面的资源链接失效 可以大大减轻服务器及带宽的压力 工作原理通过 Referer 或者 签名,网站可以检测目标网页访问的来源网页,如果是资源文件,则可以跟踪到显示它的网页地址。一旦检测到来源不是本站即进行阻止或者返回指定的页面 Referer 方式防盗链Nginx模块 ngx_http_referer_module用于阻挡来源非法的域名请求Nginx指令 valid referers, 全局变量$invalid referervalid_referers none / blocked / server_names,string 123none:\" Referer\"来源头部为空的情况blocked:\" Referer\"来源头部不为空,但是里面的值被代理或者防火墙删除了,这些值都不以htp:/或者 https://开头.server names:“ Referer\"来源头部包含当前的 server names 1234567location ~ .*\\.(gifljpglpnglflvlswfrarlzips)$&#123; valid_referers none blocked imooc.com * imooc.com: if($invalid_referer)&#123; #return 403: rewrite ^/ http://www.imooc.com/403.jpg; &#125;&#125; 加密签名伪造 Referer:可以使用加密签名解决使用第三方模块HttpaccesskeyModule实现 Nginx防盗链 1234accesskey on off模块开关accesskey_hashmethod md5 | sha-1签名加密方式accesskey_arg GET参数名称accesskey signature加密规则 123456location ~ .*\\.(gifljpglpnglflvlswfrarlzips)$&#123; accesskey on; accesskey_hashmethod md5; accesskey_arg sign; accesskey_signature\"pwd11111$remote_addr; # pwd11111 加客户端 ip&#125; 12$sign= md5('jason'. $_SERVER['remote_addr'];echo '&lt;img src=”./logo_new,png?sign=. $sign.'\"&gt;'; CDN加速CDN ?CDN的全称是Content Delivery Network，即内容分发网络。 其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。 传统模式 入域名发起请求–&gt;解析域名获取内容–&gt;对应的服务器–&gt;服务器响应并返 使用CDN访问 用户发起请求–&gt;智能DNS的解析(根据IP判断地理位置、接入网类型、选择路由最短和负载最轻的服务器)–&gt;取得缓存服务器IP–&gt;把内容返回给用户(如果缓存中有)–&gt;缓存中无,向源站发起请求–&gt;将结果返回给用户–&gt;将结果存入缓存服务器 场景站点或者应用中大量静态资源的加速分发,例如:Css,JS图片和HTML,大文件下载,直播网站等 实现 BAT等都有提供CDN服务 可用VS做4层负载均衡 可用 Nginx, Varnish, Squid, Apache Trafficserver做7层负载均衡和 cache 使用 squid反向代理, 或者 Nginx等的反向代理 独立图片服务器部署独立的必要性 分担Web服务器的I/O负载将耗费资源的图片服务分离出来,提高服务器的性能和稳定性 能够专门对图片服务器进行优化-为图片服务设置有针对性的缓存方案,减少带宽成本,提高访问速度 提高网站的可扩展性-通过增加图片服务器,提高图片吞吐能力 采用独立域名 并非二级域名 原因 同一域名下浏览器的并发连接数有限制,突破浏览器连接数的限制 由于cookie的原因,对缓存不利,大部分 Web cache都只缓存不带cookie的请求,导致每次的图片请求都不能命中 cache 独立后的问题如何进行图片上传和图片同步 NFS共享方式 利用FTP同步(php 可以操作 ftp) 动态语言静态化什么是动态语言静态化将现有PHP等动态语言的逻辑代码生成为静态HTML文件,用户访问动态脚本重定向到静态HTML文件的过程。对实时性要求不高的页面 为什么要静态化动态脚本通常会做逻辑计算和数据查询,访问量越大,服务器压力越大访问量大时可能会造成CPU负载过高,数据库服务器压力过大 静态化的实现方式使用模板引擎可以使用Smarty的缓存机制生成静态HTML缓存文件 1234567$smarty-&gt; cache dir=$RooT.\"/ cache\";/缓存目录$smarty-&gt; caching=true;//是否开启缓存$smarty-&gt; cache_lifetime=\"3600\";/缓存时间$smarty-&gt; display(string template, string cache_id[, string compile_id]]):$smarty-&gt; clear_all_cache();//清除所有缓存$smarty-&gt; clear_cache(\" file.html\");/清除指定的缓存$smarty-&gt; clear_cache( 'article.htm',$art_id);//清除同一个模板下的指定缓存号的缓存 利用ob系列的函数1234ob_start():打开输出控制缓冲ob_get_contents0:返回输出缓冲区内容ob_clean():清空输出缓冲区ob_end_flush0:冲刷出(送出)输出缓冲区内容并关闭缓冲 123456ob_start()://输出到页面的HTML代码...ob_get_contents();ob end flush();fopen(); //写入 实现页面静态化,并且当内容改变时,主动缓存新内容,且如果有$_ GET参数时候,带参数的静态化页面 例: 12345678910111213141516171819202122&lt;?php$id = $_GET['id'];if (empty($id)) &#123; $id = '';&#125;$cache_name = md5(__FILE__) . '-' . $id . '.html';$cache_lifetime = 3600;if (@filectime(__FILE__) &lt;= @filectime($cache_name) &amp;&amp; file_exists($cache_name) &amp;&amp; $cache_lifetime+@filectime($cache_name) &gt; time()) &#123; include $cache_name; exit;&#125;ob_start();?&gt;&lt;b&gt;This is My script &lt;?php echo $id; ?&gt;&lt;/b&gt;&lt;?php$content = ob_get_contents();ob_end_flush();file_put_contents($cache_name, $content);?&gt; 动态语言的并发处理什么是进程、线程、协程?进程(Process)是计算机中的程序关于某数据集合上的一次运行活动,是系统进行资源分配和调度的基本单位,是操作系统结构的基础,进程是一个“执行中的程序” 进程的三态模型:多道程序系统中,进程在处理器上交替运行,状态不断地发生变化 运行 运行:当一个进程在处理机上运行时,则称该进程处于运行状态。处于此状态的进程的数目小于等于处理器的数目,对于单处理机系统,处于运行状态的进程只有一个。在没有其他进程可以执行时(如所有进程都在阻塞状态),通常会自动执行系统的空闲进程。 就绪 就绪:当一个进程获得了除处理机以外的一切所需资源,一旦得到处理机即可运行,则称此进程处于就绪状态。就绪进程可以按多个优先级来划分队列。例如,当一个进程由于时间片用完而进入就绪状态时,排入低优先级队列;当进程由I/O操作完成而进入就绪状态时,排入高优先级队列。 阻塞 阻塞:也称为等待或睡眠状态,一个进程正在等待某一事件发生(例如请求Io而等待I/o完成等)而暂时停止运行,这时即使把处理机分配给进程也无法运行,故称该进程处于阻塞状态 进程的五态模型:对于一个实际的系统,进程的状态及其转换更为复杂。 新建态 活跃就绪/静止就绪 运行 活跃阻塞/静止阻塞 终止态 线程线程,有时被称为轻量级进程 (Lightweight Process,LWP),是程序执行流的最小单元。 线程是进程中的一个实体,是被系统独立调度和分派的基本单位,线程自己不拥有系统资源,只拥有一点儿在运行中必不可少的资源但它可与同属一个进程的其它线程共享进程所拥有的全部资源。 一个线程可以创建和撤销另一个线程,同一进程中的多个线程之间可以并发执行。 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元,是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。 在单个程序中同时运行多个线程完成不同的工作,称为多线程。 每一个程序都至少有一个线程,若程序只有一个线程,那就是程序本身。 线程的状态:就绪、阻塞、运行 协程 协程是一种用户态的轻量级线程,协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时,将寄存器上下文和栈保存到其他地方,在切回来的时候,恢复先前保存的寄存器上下文和栈,直接操作栈则基本没有内核切换的开销,可以不加锁的访问全局变量,所以上下文的切换非常快。 线程与进程的区别 ? 线程是进程内的一个执行单元,进程内至少有一个线程,它们共享进程的地址空间,而进程有自己独立的地址空间 进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 线程是处理器调度的基本单位但进程不是 二者均可并发执行 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制 线程与协程的区别 一个线程可以多个协程,一个进程也可以单独拥有多个协程 线程进程都是同步机制,而协程则是异步 协程能保留上一次调用时的状态,每次过程重入时,就相当于进入上一次调用的状态 什么是多进程、多线程 ?多进程同一个时间里,同一个计算机系统中如果允许两个或两个以上的进程处于运行状态,这就是多进程(如同时听歌,玩游戏)多开一个进程,多分配一份资源,进程间通讯不方便 多线程线程就是把一个进程分为很多片,每一片都可以是一个独立的流程与多进程的区别是只会使用一个进程的资源,线程间可以直接通信 同步阻塞模型多进程最早的服务器端程序都是通过多进程、多线程来解决并发IO的问题一个请求创建一个进程,然后子进程进入循环同步堵塞地与客户端连接进行交互,收发处理数据 多线程用多线程模式实现非常简单,线程中可以直接向某一个客户端连接发送数据 缺点这种模型严重依赖进程的数量解决并发问题启动大量进程会带来额外的进程调度消耗 异步非阻塞模型 现在各种高并发异步IO的服务器程序都是基于epol!实现的 IO复用异步非阻塞程序使用经典的 Reactor模型,Reactor顾名思义就是反应堆的意思,它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化 Reactor有4个核心的操作 add添加socket监听到 reactor set修改事件监听,可以设置监听的类型,如可读、可写 del从reactor中移除,不再监听事件 callback,事件发生后对应的处理逻辑,一般在add/set时制定 -&gt;more Nginx: 多线程 ReactorSwoole: 多线程 Reactor + 多进程 Worker PHP并发编程实践PHP的 Swoole扩展PHP的异步、并行、高性能网络通信引擎,使用纯C语言编写,提供了PHP语言的异步多线程服务器,异步TCP/UDP网络客户端,异步 MYSQL,异步 Redis, 数据库连接池, Asynctask, 消息队列, 毫秒定时器, 异步文件读写, 异步DNS查询 除了异步IO的支持之外, Swoole为PHP多进程的模式设计了多个并发数据结构和IPC通信机制,可以大大简化多进程并发编程的工作 Swoole2.0支持了类似Go语言的协程,可以使用完全同步的代码实现异步程序 Swoole的异步MYSQL实现: 1234567$db = new Swoole\\MYSQL;$server = array('host'=&gt;\",'user=&gt;'','password'=&gt;\",database=&gt;\",);$db-&gt;connect($server, function(Sdb, Result)&#123; $db-&gt;query (\"show tables\", function(Swoole\\MYSQL $db, $result)&#123; //do some thing &#125;);&#125;); 并发处理消息队列 场景说明 用户注册后,需要发注册邮件和注册短信 串行方式 将注册信息写入数据库成功后,发送注册邮件,再发送注册短信 并行方式 将注册信息写入数据库成功后,发送注册邮件的同时发送注册短信 消息队列方式 将注册信息写入数据库成功后,将成功信息写入队列,此时直接返回成功给用户,写入队列的时间非常短,可以忽略不计,然后异步发送邮件和短信 应用解耦 场景说明 用户下单后,订单系统需要通知库存系统。假如库存系统无法访问,则订单减库存将失败,从而导致订单失败订单系统与库存系统耦合 引用队列 用户下单后,订单系统完成持久化处理,将消息写入消息队列,返回用户订单下单成功,订阅下单的消息,采用拉/推的方式,获取下单信息,库存系统根据下单信息,进行库存操作 流量削锋 应用场景 秒杀活动,流量瞬时激增,服务器压力大。 用户发起请求,服务器接收后,先写入消息队列。假如消息队列长度超过最大值,则直接报错或提示用户后续程序读取消息队列再做处理控制请求量缓解高流量 日志处理 应用场景 解决大量日志的传输,日志采集程序将程序写入消息队列,然后通过日志处理程序的订阅消费日志 消息通讯 应用场景 聊天室多个客户端订阅同一主题,进行消息发布和接收 常见消息队列产品Kafka、 Activemq、 Zeros、 Rabbitmq、 Redis等 接口的并发请求curl_multi_init php 端可同时调用多个接口 数据库缓存 MySQL等一些常见的关系型数据库的数据都存储在磁盘当中,在高并发场景下,业务应用对MYSQL产生的增、删、改、查的操作造成巨大的I/O开销和查询压力,这无疑对数据库和服务器都是一种巨大的压力,为了解决此类问题,缓存数据的概念应运而生。 优点极大地解决数据库服务器的压力提高应用数据的响应速度 常见的缓存形式 内存缓存 文件缓存 启用 MYSQL查询缓存极大地降低CPU使用率 query_cache_type查询缓存类型,有0、1、2三个取值: 0表示不使用查询缓存。 1表示始终使用查询缓存。 12// 对某一条不进行缓存SELECT SQL_NO_CACHE* FROM my_table WHERE condition 2表示按需使用查询缓存 12// 在需要缓存时,添加SQL_CACHESELECT SQL_CACHE * FROM my_table WHERE condition query_cache_size默认情况下 query_cache_size为0,表示为查询缓存预留的内存为0,无法使用查询缓存 设置 1SET GLOBAL query cache size =134217728; 注意事项查询缓存可以看做是SQL文本和查询结果的映射第二次查询的SQL和第一次查询的SQL完全相同,则会使用缓存SHOW STATUS LIKE &#39;Qcache_hits;查看命中次数表的结构或数据发生改变时,查询缓存中的数据不再有效 清理缓存FLUSH QUERY CACHE; // 清理查询缓存内存碎片RESET QUERY CACHE; // 从查询缓存中移出所有查询FLUSH TABLES; // 关闭所有打开的表, 同时该操作将惠清空查询缓存中的内容 使用 Memcache 缓存查询数据对于大型站点,如果没有中间缓存层,当流量打入数据库层时,即便有之前的几层为我们挡住一部分流量,但是在大并发的情况下,还是会有大量请求涌入数据库层,这样对于数据库服务器的压力冲击很大,响应速度也会下降,因此添加中间缓存层很有必要。 工作原理Memcache是一个高性能的分布式的内存对象缓存系统,通过在内存里维护一个统一的巨大的hash表,它能够用来存储各种格式的数据,包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存,然后从内存中读取,从而大大提高读取速度 方法 获取: get(key) 设置: set(key, val, exp) 删除: delete(key) 使用 Redis 绶存查询数据与 Memcache的区别 性能相差不大 Redis在2.0版本后增加了自己的VM特性,突破物理内存的限制,Memcache可以修改最大可用内存采用LRU算法 Redis,依赖客户端来实现分布式读写 Memcache本身没有数据冗余机制 Redis支持(快照、AOF),依赖快照进行持久化,aof增强了可靠性的同时,对性能有所影响 Memcache不支持持久化,通常做缓存,提升性能; Memcache在并发场景下,用cas保证一致性, redis事务支持比较弱,只能保证事务中的毎个操作连续执行 Redis支持多种类的数据类型 Redis用于数据量较小的高性能操作和运算上 Memcache用于在动态系统中减少数据库负载,提升性能;适合做缓存,提高性能 Web服务器的负载均衡-Ngnix反向代理七层负载均衡的实现基于URL等应用层信息的负载均衡Nginx的proxy是它一个很强大的功能,实现了7层负载均衡 Nginx负载均衡 内置策略: IP Hash、加权轮询 扩展策略: fair策略、通用hash、一致性hash 内置策略 加权轮询策略 首先将请求都分给高权重的机器,直到该机器的权值降到了比其他机器低,才开始将请求分给下一个高权重的机器当所有后端机器都down掉时, Nginx会立即将所有机器的标志位清成初始状态,以避免造成所有的机器都处在 timeout的状态 IP Hash Nginx内置的另一个负载均衡的策略,流程和轮询很类似,只是其中的算法和具体的策略有些变化IP Hash算法是一种变相的轮询算法 扩展策略 fair策略 根据后端服务器的响应时间判断负载情况,从中选出负载最轻的机器进行分流 通用Hash、一致性Hash策略 通用hash比较简单,可以以Nginx内置的变量为key进行hash,一致性hash采用了Nginx内置的一致性hash环,支持 memcache 123456789101112131415// Nginx配置http&#123; upstream imooc_cluster &#123; server 121.42.68.3:8001 weight=10;// 加权中 server 121.42.69.3:8002 weight=9; #server 121.42.68.3:8003; #server 121.42.68.4; &#125; server &#123; listen 80; location / &#123; proxy_pass http: //imooc_cluster; &#125; &#125;&#125; 四层负载均衡的实现通过报文中的目标地址和端口,再加上负载均衡设备设置的服务器选择方式,决定最终选择的内部服务器 LVS实现服务器集群负载均衡有三种方式: NAT, DR 和 TUN 参考 第九章高并发和大流量解决方案","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"高并发","slug":"高并发","permalink":"http://blog.caoxl.com/tags/高并发/"},{"name":"大流量","slug":"大流量","permalink":"http://blog.caoxl.com/tags/大流量/"}]},{"title":"PHP7 新特性","slug":"PHP-7","date":"2018-06-12T05:53:39.000Z","updated":"2019-08-22T03:01:20.000Z","comments":true,"path":"2018/06/12/PHP-7/","link":"","permalink":"http://blog.caoxl.com/2018/06/12/PHP-7/","excerpt":"PHP7都发布好几年了,你确定不了解一下?","text":"PHP7都发布好几年了,你确定不了解一下? PHP7新特性语法标量类型声明123456789// 强制模式function sumOfInts(int ...$ints)&#123; return array_sum($ints);&#125;var_dump(sumOfInts(2, '3', 4.1));// echo int(9) 强制模式（默认，既强制类型转换）下还是会对不符合预期的参数进行强制类型转换，严格模式下则触发 TypeError 的致命错误。 返回值类型声明12345678910function arraysSum(array ...$arrays): array&#123; return array_map(function(array $array): int &#123; return array_sum($array); &#125;, $arrays);&#125;print_r(arraysSum([1,2,3],[4,5,6],[7,8,9]));// Array ( [0] =&gt; 6 [1] =&gt; 15 [2] =&gt; 24 ) NULL 合并运算符: ??由于日常使用中存在大量同时使用三元表达式和 isset()的情况，NULL 合并运算符使得变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。 12345// 如果 $_GET['user'] 不存在返回 'nobody'，否则返回 $_GET['user'] 的值$username = $_GET['user'] ?? 'nobody';// 类似的三元运算符$username = isset($_GET['user']) ? $_GET['user'] : 'nobody'; 太空船操作符（组合比较符）太空船操作符用于比较两个表达式。当$a大于、等于或小于$b时它分别返回-1、0或1。 1234567891011121314// 整型echo 1 &lt;=&gt; 1; //0 等于返回0echo 1 &lt;=&gt; 2; //-1 小于返回-1echo 2 &lt;=&gt; 1; //1 大于返回1// 浮点型echo 1.5 &lt;=&gt; 1.5; // 0echo 1.5 &lt;=&gt; 2.5; // -1echo 2.5 &lt;=&gt; 1.5; // 1 // 字符串echo \"a\" &lt;=&gt; \"a\"; // 0echo \"a\" &lt;=&gt; \"b\"; // -1echo \"b\" &lt;=&gt; \"a\"; // 1 通过 define() 定义常量数组12345678define('ANIMALS', [ 'dog', 'cat', 'bird']);echo ANIMALS[1];// echo cat 匿名类现在支持通过new class 来实例化一个匿名类，实例如下: 1234567891011121314151617181920212223242526interface Logger &#123; public function log(string $msg);&#125;class Application &#123; private $logger; public function getLogger(): Logger &#123; return $this-&gt;logger; &#125; public function setLogger(Logger $logger) &#123; $this-&gt;logger = $logger; &#125;&#125;$app = new Application;$app-&gt;setLogger(new class implements Logger &#123; public function log(string $msg) &#123; echo $msg; &#125;&#125;);var_dump($app-&gt;getLogger());// object(class@anonymous)#2 (0) &#123; &#125; Unicode codepoint 转译语法这接受一个以16进制形式的 Unicode codepoint，并打印出一个双引号或heredoc包围的 UTF-8 编码格式的字符串。可以接受任何有效的 codepoint，并且开头的 0 是可以省略的。 1234echo \"\\u&#123;aa&#125;\";echo \"\\u&#123;0000aa&#125;\";echo \"\\u&#123;9999&#125;\";// a a 香 Closure::call()Closure::call() 现在有着更好的性能，简短干练的暂时绑定一个方法到对象上闭包并调用它。 123456789101112class A &#123;private $x = 1;&#125;// Pre PHP 7$getXCB = function () &#123;return $this-&gt;x;&#125;;$getX = $getXCB-&gt;bindTo(new A, 'A'); //中间闭合 ???echo $getX();// echo 1// New PHP 7$getX = function () &#123;return $this-&gt;x;&#125;;echo $getX-&gt;call(new A);// echo 1 为unserialize()提供过滤这个特性旨在提供更安全的方式解包不可靠的数据。它通过白名单的方式来防止潜在的代码注入。 12345678// 转换对象为 __PHP_Incomplete_Class 对象$data = unserialize($foo, [\"allowed_classes\" =&gt; false]);// 转换对象为 __PHP_Incomplete_Class 对象，除了 MyClass 和 MyClass2$data = unserialize($foo, [\"allowed_classes\" =&gt; [\"MyClass\", \"MyClass2\"]]);// 默认接受所有类$data = unserialize($foo, [\"allowed_classes\" =&gt; true]); use 加强从同一 namespace 导入的类、函数和常量现在可以通过单个 use 语句 一次性导入了。 1234567891011121314151617// PHP 7 之前版本用法use some\\namespace\\ClassA;use some\\namespace\\ClassB;use some\\namespace\\ClassC as C;use function some\\namespace\\fn_a;use function some\\namespace\\fn_b;use function some\\namespace\\fn_c;use const some\\namespace\\ConstA;use const some\\namespace\\ConstB;use const some\\namespace\\ConstC;// PHP 7+ 用法use some\\namespace\\&#123;ClassA, ClassB, ClassC as C&#125;;use function some\\namespace\\&#123;fn_a, fn_b, fn_c&#125;;use const some\\namespace\\&#123;ConstA, ConstB, ConstC&#125;; Generator 加强增强了Generator的功能，这个可以实现很多先进的特性 1234567891011121314151617181920function gen()&#123; yield 1; yield 2; yield from gen2();&#125;function gen2()&#123; yield 3; yield 4;&#125;foreach (gen() as $val)&#123; echo $val,PHP_EOL;&#125;// 1 2 3 4 整除 intdiv新增了整除函数 intdiv(),使用实例： 1var_dump(intdiv(10, 3)); //int(3) PHP7废弃特性PHP4 风格的构造函数在 PHP4 中类中的函数可以与类名同名，这一特性在 PHP7 中被废弃，同时会发出一个 E_DEPRECATED 错误。当方法名与类名相同，且类不在命名空间中，同时PHP5的构造函数（__construct）不存在时，会产生一个 E_DEPRECATED 错误。 12345678class A &#123; function A() &#123; print ('Style Constructor'); &#125;&#125;// Deprecated: Methods with the same name as their class will not be constructors in a future version of PHP;// A has a deprecated constructor in... 以静态的方式调用非静态方法以静态的方式调用非静态方法，不再支持： 123456789class A &#123; function b() &#123; print('Non-static call'); &#125;&#125;A::b();// Deprecated: Non-static method A::b() should not be called statically in...// Non-static call password_hash() 随机因子选项函数原 salt 量不再需要由开发者提供了。函数内部默认带有 salt 能力，无需开发者提供 salt 值。 capture_session_meta SSL 上下文选项废弃了 &quot;capture_session_meta&quot; SSL 上下文选项。在流资源上活动的加密相关的元数据可以通过 stream_get_meta_data() 的返回值访问。 PHP7移除的扩展 ereg mssql mysql sybase_ct PHP7: 再深入一点~~PHP7引擎( What will be in PHP 7 / PHPNG ) Performance Improvements with the addition of PHPNG engine.（使用PHPNG引擎来提升性能） PHPNG不再使用zval的二级指针。大多数出现的zval*变量和参数都将改变成zval。相应的，使用在这些变量上的宏Z_PP()也需要变成Z_P()。 More -&gt; https://wiki.php.net/phpng-upgrading JIT - Just in Time compiler 即时编译 (参考百度百科介绍) Abstract Syntax Tree for compilation(抽象语法树编译) Asynchronous refactoring of the I/O layer.对I/O层的异步重构 Multi-threaded build in Web Server多线程构建Web服务器 Expanded use of -&gt;, [], (), {}, and :: operators 扩展使用 -&gt;, [], (), {}, 和 :: 符号 100% increase in performance性能提升 100% (应该是QPS) Cool Name: PHPNG 酷名：PHPNG引擎 Zval的改变 PHP的各种类型的变量，其实，真正存储的载体就是Zval，它特点是海纳百川，有容乃大。从本质上看，它是C语言实现的一个结构体（struct）。对于写PHP的同学，可以将它粗略理解为是一个类似array数组的东西。 PHP5的Zval，内存占据24个字节,PHP7的Zval，内存占据16个字节。 不需要引用的类型：NULL、Boolean、Long、Double 需要引用的类型：String、Array、Object、Resource、Reference 内部类型zend_stringZend_string是实际存储字符串的结构体，实际的内容会存储在val（char，字符型）中，而val是一个char数组，长度为1（方便成员变量占位）。 PHP数组的变化（HashTable和Zend Array） 在编写PHP程序过程中，使用最频繁的类型莫过于数组，PHP5的数组采用HashTable实现。如果用比较粗略的概括方式来说，它算是一个支持双向链表的HashTable，不仅支持通过数组的key来做hash映射访问元素，也能通过foreach以访问双向链表的方式遍历数组元素。 当我们通过key值访问一个元素内容的时候，有时需要3次的指针跳跃才能找对需要的内容。而最重要的一点，就在于这些数组元素存储，都是分散在各个不同的内存区域的。同理可得，在CPU读取的时候，因为它们就很可能不在同一级缓存中，会导致CPU不得不到下级缓存甚至内存区域查找，也就是引起CPU缓存命中下降，进而增加更多的耗时。 新版本的数组结构，非常简洁，让人眼前一亮。最大的特点是，整块的数组元素和hash映射表全部连接在一起，被分配在同一块内存内。如果是遍历一个整型的简单类型数组，效率会非常快，因为，数组元素（Bucket）本身是连续分配在同一块内存里，并且，数组元素的zval会把整型元素存储在内部，也不再有指针外链，全部数据都存储在当前内存区域内。当然，最重要的是，它能够避免CPU Cache Miss（CPU缓存命中率下降）。 Zend Array的变化： 数组的value默认为zval。 HashTable的大小从72下降到56字节，减少22%。 Buckets的大小从72下降到32字节，减少50%。 数组元素的Buckets的内存空间是一同分配的。 数组元素的key（Bucket.key）指向zend_string。 数组元素的value被嵌入到Bucket中。 降低CPU Cache Miss。 函数调用机制（Function Calling Convention）PHP7改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率。 通过宏定义和内联函数（inline），让编译器提前完成部分工作PHP7在这方面做了不少的优化，将不少需要在运行阶段要执行的工作，放到了编译阶段。例如参数类型的判断（Parameters Parsing），因为这里涉及的都是固定的字符常量，因此，可以放到到编译阶段来完成，进而提升后续的执行效率。 AST（Abstract Syntax Tree，抽象语法树） AST在PHP编译过程作为一个中间件的角色，替换原来直接从解释器吐出opcode的方式， 让解释器（parser）和编译器（compliler）解耦，可以减少一些Hack代码，同时，让实现更容易理解和可维护。 TLS（Native Thread local storage，原生线程本地存储） PHP在多线程模式下（例如，Web服务器Apache的woker和event模式，就是多线程），需要解决“线程安全”（TS，Thread Safe）的问题，因为线程是共享进程的内存空间的，所以每个线程本身需要通过某种方式，构建私有的空间来保存自己的私有数据，避免和其他线程相互污染。而PHP5采用的方式，就是维护一个全局大数组，为每一个线程分配一份独立的存储空间，线程通过各自拥有的key值来访问这个全局数据组。 而这个独有的key值在PHP5中需要传递给每一个需要用到全局变量的函数，PHP7认为这种传递的方式并不友好，并且存在一些问题。因而，尝试采用一个全局的线程特定变量来保存这个key值。 参考 新特性 PHP 7 新特性 PHP7新特性整理介绍篇","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"PHP7 新特性","slug":"PHP7-新特性","permalink":"http://blog.caoxl.com/tags/PHP7-新特性/"}]},{"title":"Linux 安装命令集合","slug":"Linux-install-cmd","date":"2018-06-12T02:31:06.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/06/12/Linux-install-cmd/","link":"","permalink":"http://blog.caoxl.com/2018/06/12/Linux-install-cmd/","excerpt":"整理Linux下的不同系统的下载安装命令","text":"整理Linux下的不同系统的下载安装命令 yumyum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 语法1yum (选项)(参数) 选项 -h: 显示帮助信息 -y: 对所有的提问都回答”yes” -c: 指定配置文件 -q: 安静模式 -v: 详细模式 -d: 设置调试等级(0-10) -e: 设置错误等级(0-10) -R: 设置yum处理一个命令的最大等待时间 -C: 完成从缓存中运行, 而不去下载或更新任何文件 参数 install: 安装rpm软件包 update: 更新rpm软件包 check-update: 检查是否有可用的更新rpm软件包 remove: 删除指定的rpm软件包 list: 显示软件包的信息 search: 检查软件包的信息 info: 显示指定的rpm软件包的描述信息和概要信息 clean: 清理yum过期的缓存 shell: 进入yum的shell提示符 resolvedep: 显示rpm软件包的依赖关系 localinstall: 安装本地的rpm软件包 localupdate: 显示本地rpm软件包进行更新 deplist: 显示rpm软件包的所有依赖关系 实例常用命令 自动搜索最快镜像插件 1yum install yum-fastestmirror 安装yum图形窗口插件 1yum install yumex 查看可能批量安装的列表 1yum grouplist 安装123yum install #全部安装yum install package1 #安装指定的安装包package1yum groupinsatll group1 #安装程序组group1 更新和升级12345yum update #全部更新yum update package1 #更新指定程序包package1yum check-update #检查可更新的程序yum upgrade package1 #升级指定程序包package1yum groupupdate group1 #升级程序组group1 查找和显示1234yum info package1 #显示安装包信息package1yum list #显示所有已经安装和可以安装的程序包yum list package1 #显示指定程序包安装情况package1yum groupinfo group1 #显示程序组group1信息yum search string 根据关键字string查找安装包 删除程序123yum remove &amp;#124; erase package1 #删除程序包package1yum groupremove group #删除程序组group1yum deplist package1 #查看程序package1依赖情况 清除缓存123yum clean packages #清除缓存目录下的软件包yum clean headers #清除缓存目录下的headersyum clean oldheaders #清除缓存目录下旧的headers apt-getapt-get命令是Debian Linux发行版中的APT软件包管理工具。所有基于Debian的发行都使用这个包管理系统。deb包可以把一个应用的文件包在一起，大体就如同Windows上的安装文件。 语法1apt-get(选项)(参数) 选项 -c: 指定配置文件 参数 管理指令: 对APT软件包的管理操作 软件包: 指定要操纵的软件包 实例 安装 1apt-get install packagename 卸载一个已安装的软件包（保留配置文件）： 1apt-get remove packagename 卸载一个已安装的软件包（删除配置文件）： 1apt-get -purge remove packagename 删除你已经删掉的软件： 1apt-get autoclean apt 把安装的软件的备份也删除 1apt-get clean 更新所有已安装的软件包： 1apt-get upgrade 将系统升级到新版本： 1apt-get dist-upgrade rpmrpm命令是RPM软件包的管理工具 语法1rpm (选项)(参数) 选项 -a: 查询所有套件 -b&lt;完成阶段&gt;&lt;套件挡&gt;+或-t&lt;完成阶段&gt;&lt;套件档&gt;+: 设置包装 套件的完成阶段,并指定套件档的文件名称 -c: 只列出组态配置文件,本参数需配合”-l”参数使用 -d: 只列出文本文件,本参数需配合”-l”参数使用 -e&lt;套件档&gt;或–erase&lt;套件档&gt;: 删除指定的套件 -f&lt;文件&gt;+: 查询拥有指定文件的套件 -h/--hash: 套件安装时列出标记 -i: 显示套件的相关信息 -l: 显示套件的文件列表 -p&lt;套件档&gt;+: 查询指定的文件列表 -q: 使用询问模式,当遇到任何问题是,rpm指令会先询问用户 -R: 显示套件的关联性信息 -s: 显示文件状态,本参数需要配置”-l”参数使用 -U&lt;套件档&gt;或–upgrade&lt;套件档&gt;：升级指定的套件档 -v: 显示指令执行过程 -vv: 详细显示指令执行过程,便于排错 参数 软件包: 指定要操纵的rpm软件包 实例1rpm -ivh your-package.rpm 如何安装.src.rpm软件包有些软件包是以.src.rpm结尾的，这类软件包是包含了源代码的rpm包,在安装时需要进行编译。这类软件包有两种安装方法： 方法一: 1234567rpm -i your-package.src.rpmcd /usr/src/redhat/SPECSrpmbuild -bp your-package.specs #一个和你的软件包同名的specs文件cd /usr/src/redhat/BUILD/your-package/ #一个和你的软件包同名的目录./configure #这一步和编译普通的源码软件一样，可以加上参数makemake install 方法二: 12rpm -i you-package.src.rpmcd /usr/src/redhat/SPECS 前两步和方法一相同 123rpmbuild -bb your-package.specs #一个和你的软件包同名的specs文件执行rpm -i new-package.rpm即可安装完成。 如何卸载rpm软件包使用命令rpm -e包名，包名可以包含版本号等信息，但是不可以有后缀.rpm，比如卸载软件包proftpd-1.2.8-1，可以使用下列格式： 1234rpm -e proftpd-1.2.8-1rpm -e proftpd-1.2.8rpm -e proftpd-rpm -e proftpd 不可以是下列格式： 1234rpm -e proftpd-1.2.8-1.i386.rpmrpm -e proftpd-1.2.8-1.i386rpm -e proftpd-1.2rpm -e proftpd-1 如何不安装但是获取rpm包中的文件使用工具rpm2cpio和cpio 123rpm2cpio xxx.rpm | cpio -virpm2cpio xxx.rpm | cpio -idmvrpm2cpio xxx.rpm | cpio --extract --make-directories 如何查看与rpm包相关的文件和其他信息 我的系统中安装了那些rpm软件包。 1rpm -qa 将列出所有安装过的包 如果要查找所有安装过的包含某个字符串sql的软件包 1rpm -qa | grep sql 如何获得某个软件包的文件全名。 1rpm -q mysql pear/peclPEAR go-pear会同时安装 pear 和 pecl 命令 1234#这是一个安装 pear 的 php 发行包文件wget http://pear.php.net/go-pear.phar#执行安装php go-pear.phar pear 升级或更新源 1234#如果想升级到最新版本pear upgrade --force PEAR#更新下仓库pecl channel-update pecl.php.net pear 安装扩展工具 1pear install DB PECLPHP Extension Community Library php 的 C 扩展仓库，即 php 的 so 格式的扩展 因为是 C 所以得装个编译器 12yum groupinstall \"Development tools\"yum -y install gcc gcc-c++ make cmake automake autoconf 安装redis扩展 123456789pecl info redispecl install redispecl uninstall redis#也可以使用安装包wget http://pecl.php.net/get/redis-4.0.0.tgzpecl install redis-4.0.0.tgz// 就会生成 redis.so 文件，加入到 php.ini 中即可 dpkgdpkg命令是Debian Linux系统用来安装、创建和管理软件包的实用工具。 选项/参数 -i: 安装软件包 -r: 删除软件包 -P: 删除软件包的同时删除其配置文件 -L: 显示与软件包关联的文件 -l: 显示已安装软件包列表 --unpack: 解开软件包 -c: 显示软件包内文件列表 --configure: 配置软件包 参数 Deb软件包: 指定要操纵的.deb软件包 实例12345678910dpkg -i package.deb #安装包dpkg -r package #删除包dpkg -P package #删除包(包括配置文件)dpkg -L package #列出与该包关联的文件dpkg -l package #显示该包的版本dpkg --unpack package.deb #解开deb包的内容dpkg -S keyword #搜索所属的包内容dpkg -l #列出deb包的内容dpkg -c package.deb #列出deb包的内容dpkg --configure package #配置包 tar.gz源码包安装 找到相应的软件包，比如soft.tar.gz，下载到本机某个目录 打开一个终端，su root cd soft.tar.gz所在的目录； tar -xzvf soft.tar.gz //一般会生成一个soft目录 cd soft ./configure make &amp;&amp; make install","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"MySQL bin日志","slug":"MySQL-binlog","date":"2018-06-11T08:09:53.000Z","updated":"2019-08-22T06:28:48.000Z","comments":true,"path":"2018/06/11/MySQL-binlog/","link":"","permalink":"http://blog.caoxl.com/2018/06/11/MySQL-binlog/","excerpt":"mysqlbinlog是从二进制日志读取语句的工具。在二进制日志文件中包含的执行过的语句的日志可用来帮助从崩溃中恢复","text":"mysqlbinlog是从二进制日志读取语句的工具。在二进制日志文件中包含的执行过的语句的日志可用来帮助从崩溃中恢复 查看配置 查看binlog是否开启 1show variables like 'log_bin'; 查看binlog文件的目录位置 1show variables like 'datadir'; 开启Binlog Windows下 123// my.ini[mysqld]log-bin=mysqlbin-log # =号后面的名字自定义 Linux下 123// my.conf[mysqld]log-bin=/var/log/mysql/mysql-bin.log 基础使用1mysqlbinlog --start-datetime=\"2018-06-09 17:50:00\" --stop-datetime=\"2018-06-09 18:00:00\" mysql-bin.000009 bin.000009 是当前的binlog文件(使用 show master status可查询) 查看 binlog1mysqlbinlog -vv --base64-output=decode-rows /path/to/mysql-bin-log 恢复成 SQL 恢复本地 binlog 12345678mysqlbinlog \\--no-defaults \\ #不要阅读任何选项文件--base64-output=AUTO \\ #base64输出=自动--verbose \\ #重建为SQL语句-- set-charset=utf8 \\ #将字符集添加到输出--start-datetime='2018-06-11 00:00:00' \\ #开始时间--stop-datetime='2018-06-12 00:00:00' \\ #结束时间./mysql-bin.000009 &gt; /data/restore.sql #存储 恢复远程服务器 binlog 123456mysqlbinlog \\--no-defaults \\ #不要阅读任何选项文件-uroot -p \\ #用户名/密码-hrm-wz93132ahz16ttyhq.mysql.rds.aliyuncs.com \\ #服务器地址--read-from-remote-server \\ #从远程服务器读取,mysql-bin.000009 &gt; restore.sql #存储 小插曲不到迫不得已不用binlog日志,当你要使用binlog日志的时候说明你的数据已经丢失了. 可以把错误扼杀在摇篮. 使用mysqldump进行备份. 导出所有数据库1mysqldump -uroot -proot --all-databases &gt; /all.sql 导出部分数据库全部数据1mysqldump -uroot -proot --databases db1 db2 &gt; /db.sql 导出数据库部分表数据1mysqldump -uroot -proot db1 --tables a1 a2 &gt; /table.sql 条件导出1mysqldump -uroot -proot -databases db1 --tables a1 --where='id=1' &gt; where.sql 导出数据后生产新的binlog文件1mysqldump -uroot -proot --databases db1 -F &gt; binlog.sql 只导出表结构不导出数据1mysqldump -uroot -proot --no-data --databases db1 &gt; nodata.sql 跨服务器导出导入数据1msyqldump --host=h1 -uroot -proot --databases db1 | mysql --hosts=h2 -uroot -proot db2 将h1服务器中的db1数据库的所有数据导入到h2中的db2数据库中，db2的数据库必须存在否则会报错 1mysqldump --host=h1 -uroot -proot -C --databases db1 |mysql --host=h2 -uroot -proot db2 加上-C参数可以启用压缩传递。 锁表导出 --lock-tables开始导出前，锁定所有表。用READ LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，--single-transaction是一个更好的选择，因为它根本不需要锁定表。 请注意当导出多个数据库时，--lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。 导出存储过程和自定义函数--routines, -R1mysqldump -uroot -proot -host=localhost --all-databases --routines 压缩备份1234// 压缩mysqldump -uroot -proot -databases abd 2&gt;/dev/null | gzip &gt;/adc.sql.gz// 还原gunzip -c abc.sql.gz | mysql -uroot -proot abc 参考 mysqlbinlog - 处理二进制日志文件的实用程序 MySQL mysqldump数据导出详解","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"binlog","slug":"binlog","permalink":"http://blog.caoxl.com/tags/binlog/"}]},{"title":"JavaScript 区分IOS/安卓 跳转下载","slug":"JavaScript-IOS-Android","date":"2018-06-11T07:39:17.000Z","updated":"2019-08-22T06:52:42.000Z","comments":true,"path":"2018/06/11/JavaScript-IOS-Android/","link":"","permalink":"http://blog.caoxl.com/2018/06/11/JavaScript-IOS-Android/","excerpt":"简单做一下前端判断,根据设备跳转不同的下载环境","text":"简单做一下前端判断,根据设备跳转不同的下载环境 123456var u = navigator.userAgent;if(!!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/))&#123; window.location.href='https://itunes.apple.com/cn/app/App Store下载地址';&#125;else &#123; window.location.href='http://android.myapp.com/myapp/应用宝下载地址';&#125;","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://blog.caoxl.com/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.caoxl.com/tags/JavaScript/"}]},{"title":"Nginx 反向代理/负载均衡","slug":"Nginx-reverse-proxy","date":"2018-06-08T07:38:49.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/06/08/Nginx-reverse-proxy/","link":"","permalink":"http://blog.caoxl.com/2018/06/08/Nginx-reverse-proxy/","excerpt":"反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时站在服务器角度来看，代理服务器对外就表现为一个反向代理服务器。","text":"反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时站在服务器角度来看，代理服务器对外就表现为一个反向代理服务器。 Nginx负载均衡集群配置 修改nginx.conf配置文件 配置服务器组,在http{}节点之间添加upstream配置(注意不要写localhost，不然访问速度会很慢) 1234upstream nginx &#123; server 127.0.0.1:8081; server 127.0.0.1:8082;&#125; 修改nginx监听的端口号80, 改为8080 1listen 8080; 在location / {}中,利用proxy_pass配置反向代理地址;此处&quot;http://&quot;不能少,后面的地址要和第一步upstream的名称保持一致. 123location / &#123; proxy_pass http://nginx; #配置反向代理地址&#125; 访问:url:http://127.0.0.1:8080/nginx Nginx负载均衡策略一、轮询（默认）每个web请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 1234upstream nginxDemo &#123; server 127.0.0.1:8081; server 127.0.0.1:8082;&#125; 二、最少链接web请求会被转发到连接数最少的服务器上。 12345upstream nginxDemo &#123; least_conn; server 127.0.0.1:8081; server 127.0.0.1:8082;&#125; 三、weight权重指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况，weight默认是1。 12345#服务器A和服务器B的访问比例为：2-1;比如有3个请求，前两个会访问A，三个访问B，其它规则和轮询一样。upstream nginxDemo &#123; server 127.0.0.1:8081 weight=2; #服务器A server 127.0.0.1:8082; #服务器B&#125; 四、ip_hash每个请求按访问ip的hash值分配，这样同一客户端连续的Web请求都会被分发到同一服务器进行处理，可以解决session的问题。当后台服务器宕机时，会自动跳转到其它服务器。 12345upstrea nginxDemo &#123; ip_hash; server 127.0.0.1:8081 weight=2; #服务器A server 127.0.0.1:8082; #服务器B&#125; 基于weight的负载均衡和基于ip_hash的负载均衡可以组合在一起使用。 五、url_hash (第三方)url_hash是nginx的第三方模块，nginx本身不支持，需要打补丁。 nginx按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存服务器、文件服务器、静态服务器时比较有效。 缺点是当后端服务器宕机的时候，url_hash不会自动跳转的其他缓存服务器，而是返回给用户一个503错误。 12345upstream nginxDemo &#123; server 127.0.0.1:8081; #服务器A server 127.0.0.1:8082; #服务器B hash $requert_url;&#125; 六、fair (第三方)按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream nginxDemo &#123; server 127.0.0.1:8081; #服务器A server 127.0.0.1:8082; #服务器B fair;&#125;","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"}]},{"title":"MySQL 主从复制","slug":"MySQL-Master-Slave","date":"2018-06-08T06:05:59.000Z","updated":"2019-08-22T06:28:55.000Z","comments":true,"path":"2018/06/08/MySQL-Master-Slave/","link":"","permalink":"http://blog.caoxl.com/2018/06/08/MySQL-Master-Slave/","excerpt":"MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。","text":"MySQL数据库自身提供的主从复制功能可以方便的实现数据的多处自动备份，实现数据库的拓展。多个数据备份不仅可以加强数据的安全性，通过实现读写分离还能进一步提升数据库的负载性能。 主从复制/读写分离模型 Mysql主从复制的实现原理图大致如下(来源网络)： MySQL之间数据复制的基础是二进制日志文件（binary log file） 实现原理一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。 实现配置主服务器 开启二进制日志 配置唯一的server-id 获得master二进制日志文件名及位置 创建一个用户slave和master通信的用户账号 123[mysqld]server-id = 1log_bin = /var/log/mysql/mysql-bin.log 从服务器 配置唯一的server-id 使用master分配的用户账号读取master二进制日志 启用slave服务 12[mysqld]server-id = 2 具体操作准备工作 主从数据库版本最好一致 主从数据库内数据保持一致 主数据库: 47.91.221.85/linux 从数据库: 106.15.38.11/linux 主服务器master修改 修改mysql配置 找到主数据库的配置文件my.cnf(或者my.ini),插入以下数据 123[mysqld]log-bin = /var/log/mysql/mysql-bin.log #开启二进制日志server-id = 99 #设置server-id 唯一即可 重启mysql, 创建用于同步的用户账号 1234567891011service mysql restart// mysql -u root -p 进入mysql// 创建用户,IP为可访问该master的IP，任意IP就写'%'mysql&gt; CREATE user 'cxl@106.15.38.11' IDENTIFIED By '110119';// 分配权限,IP为可访问该 master的IP，任意IP就写'%'mysql&gt; GRANT REPLICATION SLAVE On *.* TO 'cxl@106.15.38.11';// 刷新权限mysql&gt; flush privileges; 查看master状态,记录二进制文件名(mysql-bin.000009)和位置(421) 123456mysql&gt; show master status;+------------------+----------+--------------+------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000009 | 421 | | |+------------------+----------+--------------+------------------+ 从服务器Slave修改 修改mysql配置 同样找到my.cnf配置文件，添加server-id 12[mysqld]server-id = 66 #设置server-id，必须唯一 重启mysql,打开mysql,执行同步SQL语句 (需要主服务器主机名，登陆凭据，二进制文件的名称和位置)： 123456mysql&gt; CHANGE MASTER TO -&gt; MASTER_HOST='47.91.221.85', // 主服务器地址(外网地址) -&gt; MASTER_USER='cxl', // 用户 -&gt; MASTER_PASSWORD='110119', // 密码 -&gt; MASTER_LOG_FILE='mysql-bin.000009', -&gt; MASTER_LOG_POS=421; 启动slave同步进程 1mysql&gt;start slave; 查看slave状态 1234567891011121314151617mysql&gt; show slave status\\G;*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 47.91.221.85 Master_User: cxl Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000009 Read_Master_Log_Pos: 11662 Relay_Log_File: mysqld-relay-bin.000022 Relay_Log_Pos: 11765 Relay_Master_Log_File: mysql-bin.000013 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: ... 当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。 master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体在mysql配置文件的[mysqld]可添加修改如下选项： 1234567# 不同步哪些数据库 binlog-ignore-db = mysql binlog-ignore-db = test binlog-ignore-db = information_schema # 只同步哪些数据库，除此之外，其他不同步 binlog-do-db = game 查看master状态时就可以看到只记录了test库，忽略了manual和mysql库。 参考 CentOS下MySQL主从复制(Master-Slave)实践","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"}]},{"title":"Linux 安装redis","slug":"Linux-install-redis","date":"2018-06-08T03:06:52.000Z","updated":"2018-12-04T08:35:38.000Z","comments":true,"path":"2018/06/08/Linux-install-redis/","link":"","permalink":"http://blog.caoxl.com/2018/06/08/Linux-install-redis/","excerpt":"redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止redis支持的键值数据类型如下字符串、列表（lists）、集合（sets）、有序集合（sorts sets）、哈希表（hashs）","text":"redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止redis支持的键值数据类型如下字符串、列表（lists）、集合（sets）、有序集合（sorts sets）、哈希表（hashs） Redis的安装和部署安装/部署 下载 1wget http://download.redis.io/releases/redis-4.0.0.tar.gz 在http://download.redis.io/releases/找自己需要的版本 移动 1cp redis-4.0.0.rar.gz /usr/local 解压并进入目录 12tar -zxvf redis-4.0.0.tar.gzcd /usr/local/redis-4.0.0 编译安装 12// 安装到指定目录make PREFIX=/usr/local/redis install redis.conf是redis的配置文件，redis.conf在redis源码目录 拷贝配置文件 123cd /usr/local/redismkdir confcp /usr/local/redis-4.0.0/redis.conf /usr/local/redis/bin 进入安装目录bin下 1cd /usr/local/redis/bin 目录结构解释: redis-benchmark: redis性能测试工具 redis-check-aof: AOF文件修复工具 redis-check-rdb: RDB文件修复工具 redis-cli: redis命令行客户端 redis.conf: redis配置文件 redis-sentinal redis集群管理工具 redis-server: redis服务进程 启动redis 前端模式启动 12cd /usr/local/redis/bin/./redis-server 后台模式启动 修改redis.conf配置文件， daemonize yes 以后端模式启动 12vim /usr/local/redis/bin/redis.confdaemonize yes 执行如下命令启动redis： 12cd /usr/local/redis/bin./redis-server ./redis.conf 连接redis 1/usr/local/redis/bin/redis-cli 关闭redis1234shutdown// 强行终止redispkill redis-server redis开机启动123vim /etc/rc.local//添加/usr/local/redis/bin/redis-server /usr/local/redis/bin/redis-conf Redis扩展的安装下载1wget http://pecl.php.net/get/redis-4.1.0.tgz // 版本自选 解压/进入目录12tar zxf redis-4.1.0.tgz cd redis-4.1.0 在Redis文件夹下，生成configure配置文件123/usr/local/php/bin/phpize./configure --with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install redis.so扩展存放在/usr/local/php/lib/php/extensions/no-debug-non-zts-20160303/目录下。 在PHP配置文件php.ini里面加载Redis扩展1extension=redis.so 重启服务器(Apache或者Nginx)123service httpd restart// 或service nginx start 测试浏览器phpinfo信息，如果有Redis信息，则安装成功 参考 Linux下redis安装和部署 Linux下PHP安装Redis扩展（二）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"}]},{"title":"Swoole 初步了解","slug":"Swoole-first-use-note","date":"2018-06-07T06:22:10.000Z","updated":"2019-08-22T06:40:20.000Z","comments":true,"path":"2018/06/07/Swoole-first-use-note/","link":"","permalink":"http://blog.caoxl.com/2018/06/07/Swoole-first-use-note/","excerpt":"Swoole 初步了解 Swoole这个名字不是一个英文单词，是由我创造的一个音近字。我最早想到的名字是叫做sword-server，寓意是为广大PHPer创造一把锋利的剑，后来联想到google也是凭空创造出来的，所以我就给它命名为swoole。 &lt;韩天峰&gt;","text":"Swoole 初步了解 Swoole这个名字不是一个英文单词，是由我创造的一个音近字。我最早想到的名字是叫做sword-server，寓意是为广大PHPer创造一把锋利的剑，后来联想到google也是凭空创造出来的，所以我就给它命名为swoole。 &lt;韩天峰&gt; 安装 PECL 一键安装 1pecl install swoole 源码安装 123456// 下载源码并解压cd swoole-src-swoole-1.8.0-table/phpize./configure --enable-async-mysqlsudo makesudo make install 配置 php.ini1extension=swoole.so 基础实例服务端1234567891011121314151617181920212223242526272829303132333435363738394041class Server&#123; private $serv; public function __construct() &#123; $this-&gt;serv = new swoole_server(\"0.0.0.0\", 9501); $this-&gt;serv-&gt;set(array( 'worker_num' =&gt; 8, 'daemonize' =&gt; false, 'max_request' =&gt; 10000, 'dispatch_mode' =&gt; 2, 'debug_mode' =&gt; 1 )); $this-&gt;serv-&gt;on('Start', array($this, 'onStart')); $this-&gt;serv-&gt;on('Connect', array($this, 'onConnect')); $this-&gt;serv-&gt;on('Receive', array($this, 'onReceive')); $this-&gt;serv-&gt;on('Close', array($this, 'onClose')); $this-&gt;serv-&gt;start(); &#125; public function onStart( $serv ) &#123; echo \"Start\\n\"; &#125; public function onConnect( $serv, $fd, $from_id ) &#123; $serv-&gt;send( $fd, \"Hello &#123;$fd&#125;!\" ); &#125; public function onReceive( swoole_server $serv, $fd, $from_id, $data ) &#123; echo \"Get Message From Client &#123;$fd&#125;:&#123;$data&#125;\\n\"; &#125; public function onClose( $serv, $fd, $from_id ) &#123; echo \"Client &#123;$fd&#125; close connection\\n\"; &#125;&#125;// 启动服务器$server = new Server(); 解析从代码中可以看出，创建一个swoole_server基本分三步: 通过构造函数创建swoole_server对象 调用set函数设置swoole_server的相关配置选项 调用on函数设置相关回调函数 onStart回调在server运行前被调用， onConnect在有新客户端连接过来时被调用， onReceive函数在有数据发送到server时被调用 onClose在有客户端断开连接时被调用。 配置选项说明 worker_num: 指定启动的worker进程数。 max_request: 每个worker进程允许处理的最大任务数。 max_conn: 服务器允许维持的最大TCP连接数 ipc_mode: 设置进程间的通信方式。 1 =&gt; 使用unix socket通信 2 =&gt; 使用消息队列通信 3 =&gt; 使用消息队列通信，并设置为争抢模式 dispatch_mode: 指定数据包分发策略。 1 =&gt; 轮循模式，收到会轮循分配给每一个worker进程 2 =&gt; 固定模式，根据连接的文件描述符分配worker。这样可以保证同一个连接发来的数据只会被同一个worker处理 3 =&gt; 抢占模式，主进程会根据Worker的忙闲状态选择投递，只会投递给处于闲置状态的Worker task_worker_num: 服务器开启的task进程数。 设置此参数后，必须要给swoole_server设置onTask/onFinish两个回调函数，否则启动服务器会报错。 task_max_request: 每个task进程允许处理的最大任务数。 task_ipc_mode: 设置task进程与worker进程之间通信的方式。 daemonize: 设置程序进入后台作为守护进程运行。 说明:长时间运行的服务器端程序必须启用此项。如果不启用守护进程，当ssh终端退出后，程序将被终止运行。启用守护进程后，标准输入和输出会被重定向到 log_file，如果 log_file未设置，则所有输出会被丢弃。 log_file: 指定日志文件路径 说明:在swoole运行期发生的异常信息会记录到这个文件中。默认会打印到屏幕。注意 log_file 不会自动切分文件，所以需要定期清理此文件。 heartbeat_check_interval: 设置心跳检测间隔 说明:此选项表示每隔多久轮循一次，单位为秒。每次检测时遍历所有连接，如果某个连接在间隔时间内没有数据发送，则强制关闭连接（会有onClose回调）。 heartbeat_idle_time: 设置某个连接允许的最大闲置时间。 说明:该参数配合heartbeat_check_interval使用。每次遍历所有连接时，如果某个连接在heartbeat_idle_time时间内没有数据发送，则强制关闭连接。默认设置为heartbeat_check_interval * 2。 open_eof_check: 打开eof检测功能 说明:与 package_eof 配合使用。此选项将检测客户端连接发来的数据，当数据包结尾是指定的package_eof 字符串时才会将数据包投递至Worker进程，否则会一直拼接数据包直到缓存溢出或超时才会终止。一旦出错，该连接会被判定为恶意连接，数据包会被丢弃并强制关闭连接。 package_eof: 设置EOF字符串 说明:package_eof最大只允许传入8个字节的字符串 open_length_check: 打开包长检测 说明:包长检测提供了固定包头+包体这种格式协议的解析，。启用后，可以保证Worker进程onReceive每次都会收到一个完整的数据包。 package_length_offset: 包头中第几个字节开始存放了长度字段 说明:配合open_length_check使用，用于指明长度字段的位置。 package_body_offset: 从第几个字节开始计算长度 说明:配合open_length_check使用，用于指明包头的长度。 package_length_type: 指定包长字段的类型 s =&gt; int16_t 机器字节序 S =&gt; uint16_t 机器字节序 n =&gt; uint16_t 大端字节序 N =&gt; uint32_t 大端字节序 L =&gt; uint32_t 机器字节序 l =&gt; int 机器字节序 说明:配合open_length_check使用，指定长度字段的类型，参数如下: package_max_length: 设置最大数据包尺寸 说明:该值决定了数据包缓存区的大小。如果缓存的数据超过了该值，则会引发错误。具体错误处理由开启的协议解析的类型决定。 open_cpu_affinity: 启用CPU亲和性设置 说明:在多核的硬件平台中，启用此特性会将swoole的reactor线程/worker进程绑定到固定的一个核上。可以避免进程/线程的运行时在多个核之间互相切换，提高CPU Cache的命中率。 open_tcp_nodelay: 启用open_tcp_nodelay 说明:开启后TCP连接发送数据时会无关闭Nagle合并算法，立即发往客户端连接。在某些场景下，如http服务器，可以提升响应速度。 tcp_defer_accept: 启用tcp_defer_accept特性 说明:启动后，只有一个TCP连接有数据发送时才会触发accept。 ssl_cert_file/ssl_key_file: 设置SSL隧道加密 说明:设置值为一个文件名字符串，指定cert证书和key的路径。 open_tcp_keepalive: 打开TCP的KEEP_ALIVE选项 说明:使用TCP内置的keep_alive属性，用于保证连接不会因为长时闲置而被关闭。 tcp_keepidle: 指定探测间隔。 说明:配合open_tcp_keepalive使用，如果某个连接在tcp_keepidle内没有任何数据来往，则进行探测。 tcp_keepinterval: 指定探测时的发包间隔 说明:配合open_tcp_keepalive使用 tcp_keepcount: 指定探测的尝试次数 说明:配合open_tcp_keepalive使用，若tcp_keepcount次尝试后仍无响应，则判定连接已关闭 backlog: 指定Listen队列长度 说明:此参数将决定最多同时有多少个等待accept的连接。 reactor_num: 指定Reactor线程数 说明:设置主进程内事件处理线程的数量，默认会启用CPU核数相同的数量，一般设置为CPU核数的1-4倍，最大不得超过CPU核数*4。 task_tmpdir: 设置task的数据临时目录 说明:在swoole_server中，如果投递的数据超过8192字节，将启用临时文件来保存数据。这里的task_tmpdir就是用来设置临时文件保存的位置。 客户端123456789101112131415161718192021222324&lt;?phpclass Client&#123; private $client; public function __construct() &#123; $this-&gt;client = new swoole_client(SWOOLE_SOCK_TCP); &#125; public function connect() &#123; if( !$this-&gt;client-&gt;connect(\"127.0.0.1\", 9501 , 1) ) &#123; echo \"Error: &#123;$fp-&gt;errMsg&#125;[&#123;$fp-&gt;errCode&#125;]\\n\"; &#125; $message = $this-&gt;client-&gt;recv(); echo \"Get Message From Server:&#123;$message&#125;\\n\"; fwrite(STDOUT, \"请输入消息:\"); $msg = trim(fgets(STDIN)); $this-&gt;client-&gt;send( $msg ); &#125;&#125;$client = new Client();$client-&gt;connect(); 这里，通过swoole_client创建一个基于TCP的客户端实例，并调用connect函数向指定的IP及端口发起连接请求。随后即可通过recv()和send()两个函数来接收和发送请求。需要注意的是，这里我使用了默认的同步阻塞客户端，因此recv和send操作都会产生网络阻塞。 Swoole 异步任务TaskTask简介Swoole的业务逻辑部分是同步阻塞运行的，如果遇到一些耗时较大的操作，例如访问数据库、广播消息等，就会影响服务器的响应速度。因此Swoole提供了Task功能，将这些耗时操作放到另外的进程去处理，当前进程继续执行后面的逻辑。 开启Task功能开启Task功能只需要在swoole_server的配置项中添加task_worker_num一项即可，如下: 123$serv-&gt;set(array( 'task_worker_num' =&gt; 8)); 即可开启task功能。此外，必须给swoole_server绑定两个回调函数:onTask和onFinish。这两个回调函数分别用于执行Task任务和处理Task任务的返回结果。 使用Task首先是发起一个Task，代码如下:123456789101112public function onReceive (swoole_server $serv, $fd, $from_id, $data ) &#123; echo \"Get Message From Client &#123;$fd&#125;:&#123;$data&#125;\\n\"; // send a task to task worker $parm = array( 'fd' =&gt; $fd ); // start a task $serv-&gt;task(json_encode($param)); echo \"Continue Handle Worker\\n\";&#125; 可以看到，发起一个任务时，只需通过swoole_server对象调用task函数即可发起一个任务。swoole内部会将这个请求投递给task_worker，而当前Worker进程会继续执行。 当一个任务发起后，task_worker进程会响应onTask回调函数，如下: 12345678910111213public function onTask($serv, $task_id, $from_id, $data)&#123; echo \"This Task &#123;$task_id&#125; from Worker &#123;$from_id&#125;\\n\"; echo \"Data: &#123;$data&#125;\\n\"; for($i = 0; $i &lt; 10; $i ++) &#123; sleep(1); echo \"Task &#123;$task_id&#125; Handle &#123;$i&#125; times...\\n\"; &#125; $fd = json_decode($data, true)['fd']; $serv-&gt;send($fd, \"Data in Task &#123;$task_id&#125;\"); return \"Task &#123;$task_id&#125;'s result\";&#125; 这里我用sleep函数和循环模拟了一个长耗时任务。在onTask回调中，我们通过task_id和from_id(也就是worker_id)来区分不同进程投递的不同task。当一个task执行结束后，通过return一个字符串将执行结果返回给Worker进程。Worker进程将通过onFinish回调函数接收这个处理结果。 12345public function onFinish($serv, $task_id, $data)&#123; echo \"Task &#123;$task_id&#125; finish\\n\"; echo \"Result: &#123;$data&#125;\\n\";&#125; 在onFinish回调中，会接收到Task任务的处理结果$data。在这里处理这个返回结果即可。 swoole_client 在这里讲解如何使用swoole_client是因为，在写服务端代码的时候，不可避免的需要用到客户端来进行测试。swoole提供了swoole_client用于编写测试客户端，下面我将讲解如何使用这个工具。 swoole_client有两种工作模式:同步阻塞模式和异步回调模式 其中，同步阻塞模式在上一章中已经给出示例，其使用和一般的socket基本无异。因此，我将重点讲解swoole_client的异步回调模式。 创建一个异步client的代码如下: 1$client = new swoole_client(SWOOLE_SOCK_TCP, SWOOLE_SOCK_ASYNC); 其中，SWOOLE_SOCK_ASYNC选项即表明创建一个异步client。 既然是异步，那当然需要回调函数。swoole_client一共有四个回调函数，如下: 123456789101112$client-&gt;on(\"connect\", function ($cli) &#123; $cli-&gt;send(\"hello world\\n\");&#125;);$client-&gt;on(\"receive\", function ($cli, $data) &#123; echo \"Received: \".$data.\"\\n\";&#125;);$client-&gt;on(\"error\", function ($cli) &#123; echo \"Connect failed\\n\";&#125;);$client-&gt;on(\"close\", function ($cli) &#123; echo \"Connection close\\n\";&#125;); 这几个回调函数的作用基本和swoole_server类似，只有参数不同，因此不再赘述。 Timer计时器、心跳检测、Task进阶Timer定时器 在实际应用中，往往会遇到需要每隔一段时间重复做一件事，比如心跳检测、订阅消息、数据库备份等工作。通常，我们会借助PHP的time()以及相关函数自己实现一个定时器，或者使用crontab工具来实现。但是，自定义的定时器容易出错，而使用crontab则需要编写额外的脚本文件，无论是迁移还是调试都比较麻烦。 因此，Swoole提供了一个内置的Timer定时器功能,通过函数addtimer即可在Swoole中添加一个定时器，该定时器会在建立之后，按照预先设定好的时间间隔，每到对应的时间就会调用一次回调函数onTimer通知Server。 1234567891011121314151617181920212223242526272829303132&lt;?php$this-&gt;serv-&gt;on('Timer', array($this, 'onTimer'));public function onWorkerStart($serv, $worker_id)&#123; // 在Worker进程开启时绑定定时器 // 只有当worker_id为0时才添加定时器,避免重复添加 if ($worker_id == 0) &#123; $serv-&gt;addTimer(500); $serv-&gt;addTimer(1000); $serv-&gt;addTimer(1500); &#125;&#125;public function onTimer($serv, $interval)&#123; switch ($interval) &#123; case 500: &#123; echo \"Do Thing A at interval 500\\n\"; break; &#125; case 1000: &#123; echo \"Do Thing B at interval 1000\\n\"; break; &#125; case 1500: &#123; echo \"Do Thing C at interval 1500\\n\"; break; &#125; &#125;&#125; 可以看到，在onWorkerStart回调函数中，通过addtimer添加了三个定时器，时间间隔分别为500、1000、1500。而在onTimer回调中，正好通过间隔的不同来区分不同的定时器回调，从而执行不同的操作。 需要注意的是，在上述示例中，当1000ms的定时器被触发时，500ms的定时器同样会被触发，但是不能保证会在1000ms定时器前触发还是后触发，因此需要注意，定时器中的操作不能依赖其他定时器的执行结果。 心跳检测使用Timer定时器功能可以实现发送心跳包的功能。事实上，Swoole已经内置了心跳检测功能，能自动close掉长时间没有数据来往的连接。而开启心跳检测功能，只需要设置heartbeat_check_interval和heartbeat_idle_time即可。如下: 123456$this-&gt;serv-&gt;set( array( &apos;heartbeat_check_interval&apos; =&gt; 60, &apos;heartbeat_idle_time&apos; =&gt; 600, )); Task进阶:MySQL连接池 在PHP中，访问MySQL数据库往往是性能提升的瓶颈。而MySQL连接池我想大家都不陌生，这是一个很好的提升数据库访问性能的方式。传统的MySQL连接池，是预先申请一定数量的连接，每一个新的请求都会占用其中一个连接，请求结束后再将连接放回池中，如果所有连接都被占用，新来的连接则会进入等待状态。 知道了MySQL连接池的实现原理，那我们来看如何使用Swoole实现一个连接池。首先，Swoole允许开启一定量的Task Worker进程，我们可以让每个进程都拥有一个MySQL连接，并保持这个连接，这样，我们就创建了一个连接池。 其次，设置swoole的dispatch_mode为抢占模式(主进程会根据Worker的忙闲状态选择投递，只会投递给处于闲置状态的Worker)。这样，每个task都会被投递给闲置的Task Worker。这样，我们保证了每个新的task都会被闲置的Task Worker处理，如果全部Task Worker都被占用，则会进入等待队列。 下面直接上关键代码: 123456789101112131415161718public function onWorkerStart($serv, $worker_id)&#123; echo \"onWorkerStart\\n\"; // 判定是否为Task Worker进程 if ($worker_id &gt;= $serv-&gt;setting['worker_num']) &#123; $this-&gt;pdo = new PDO( \"mysql:host=localhost;port=3306;dbname=Test\", 'root', '123456', array( PDO::MYSQL_ATTR_INIT_COMMAND =&gt; \"SET NAMES 'UTF8';\", PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_PERSISTENT =&gt; true ) ); &#125;&#125; 首先，在每个Task Worker进程中，创建一个MySQL连接。这里我选用了PDO扩展。 123456789public function onReceive(swoole_server $serv, $fd, $from_id, $data) &#123; $sql = array( 'sql' =&gt; 'select * from Test where pid &gt; ?', 'parm' =&gt; array(0), 'fd' =&gt; $fd ); $serv-&gt;task(json_encode($sql));&#125; 其次，在需要的时候，通过task函数投递一个任务（也就是发起一次SQL请求） 123456789101112public function onTask($serv,$task_id,$from_id, $data)&#123; $sql = json_decode( $data , true ); $statement = $this-&gt;pdo-&gt;prepare($sql['sql']); $statement-&gt;execute($sql['param']); $result = $statement-&gt;fetchAll(PDO::FETCH_ASSOC); $serv-&gt;send( $sql['fd'],json_encode($result)); return true;&#125; 最后，在onTask回调中，根据请求过来的SQL语句以及相应的参数，发起一次MySQL请求，并将获取到的结果通过send发送给客户端（或者通过return返回给Worker进程）。而且，这样的一次MySQL请求还不会阻塞Worker进程，Worker进程可以继续处理其他的逻辑。 Swoole多端口监听、热重启以及Timer进阶:简单crontab多端口监听1234$serv = new swoole_server(\"192.168.1.1\", 9501); // 监听外网的9501端口$serv-&gt;addlistener(\"127.0.0.1\", 9502 , SWOOLE_TCP); // 监听本地的9502端口$serv-&gt;start(); // addlistener必须在start前调用 此时，swoole_server就会同时监听两个host下的两个端口。这里要注意的是，来自两个端口的数据会在同一个onReceive中获取到，这时就要用到swoole的另一个成员函数connection_info，通过这个函数获取到fd的from_port，就可以判定消息的类型 123456789$info = $serv-&gt;connection_info($fd, $from_id);//来自9502的内网管理端口if($info['from_port'] == 9502) &#123; $serv-&gt;send($fd, \"welcome admin\\n\");&#125;//来自外网else &#123; $serv-&gt;send($fd, 'Swoole: '.$data);&#125; 服务器热重启 所谓热重启，就是当服务器相关代码有所变动之后，无需停止服务，而是在服务器仍然运行的状态下更新文件。 Swoole通过内置的reload函数以及两个自定义信号量实现了这一功能 Swoole可用的三个信号:SIGTERM，SIGUSR1，SIGUSR2 SIGTERM用于停止服务器 SIGUSR1用于重启全部的Worker进程 SIGUSR2用于重启全部的Task Worker进程 那要如何实现热更新代码文件呢？Swoole的回调函数中有这个一个回调onWorkerStart;该回调会在Worker进程启动时被调用。因此，当swoole_server收到SIGUSR1信号并重启全部Worker进程后，onWorkerStart就会被调用。如果在onWorkerStart中require全部的代码文件，每次onWorkerStart后都会重新require一次php文件，这样就能实现代码文件的热更新。 123456789public function onStart( $serv )&#123; cli_set_process_title(\"reload_master\");&#125;public function onWorkerStart( $serv , $worker_id)&#123; require_once \"reload_page.php\"; Test(); // reload_page.php中定义的一个函数&#125; 首先，在onStart回调函数中通过php的cli_set_process_title函数设置进程名。在onWorkerStart中，require相关的php文件。 然后，新建一个reload.sh文件，输入如下内容: 12345echo \"Reloading...\"cmd=$(pidof reload_master)kill -USR1 \"$cmd\"echo \"Reloaded\" 这样，就可以通过执行这个脚本重启服务器了 Timer补充:after函数在swoole-1.7.7stable版本中，Timer新增了一个函数after。该函数的作用是在指定的时间间隔后执行回调函数，并且只执行一次。 1$serv-&gt;after( 1000 , array($this, 'onAfter') , $str ); 这里指定在1000ms后，执行onAfter回调函数，函数参数为$str Swoole的自定义协议功能的使用为什么要提供自定义协议 ?熟悉TCP通信的朋友都会知道，TCP是一个流式协议。客户端向服务器发送的一段数据，可能并不会被服务器一次就完整的收到;客户端向服务器发送的多段数据，可能服务器一次就收到了全部的数据。 而实际应用中，我们希望在服务器端能一次接收一段完整的数据，不多也不少 传统的TCP服务器中，往往需要由程序员维护一个缓存区，先将读到的数据放进缓存区中，然后再通过预先设定好的协议内容，来区分一段完整数据的开头、长度和结尾，并将一段完整的数据交给逻辑部分处理。这就是自定义协议的功能。 而在Swoole中，已经在底层实现了一个数据缓存区，并内置好了几个常用的协议类型，直接在底层做好了数据的拆分，保证了在onReceive回调函数中，一定能收到一个（或数个）完整的数据段。数据缓存区的大小可以通过配置选项package_max_length来控制。 下面我就将讲解如何使用这些内置协议。 EOF标记型协议 第一个比较常用的协议就是EOF标记协议。协议的内容是通过规定一个一定不会出现在正常数据中的字符或者字符串，用这个来标记一段完整数据的结尾这样，只要发现这个结尾，就可以认定之前的数据已经结束，可以开始接收一个新的数据段了。 在Swoole中，可以通过open_eof_check和package_eof两个配置项来开启。其中，open_eof_check指定开启了EOF检测，package_eof指定了具体的EOF标记 通过这两个选项，Swoole底层就会自动根据EOF标记来缓存和拆分收到的数据包 12345$this-&gt;serv-&gt;set(array( 'package_max_length =&gt; 8192, 'open_eof_check' =&gt; true, 'package_eof' =&gt; \"\\r\\n\")); 就这样，swoole就已经开启了EOF标记协议的解析。那么让我们来测试一下效果: 服务器 12345// serverpublic function onReceive(swoole_serve $serv, $fd, $from_id, $data)&#123; echo \"Get Message From Client &#123;$fd&#125;:&#123;$data&#125;\\n\";&#125; 客户端 1234567$msg_eof = \"This is a Msg\\r\\n\";$i = 0;while($i &lt; 100) &#123; $this-&gt;client-&gt;send($msg_eof); $i ++;&#125; 然后运行一下，你会发现:哎不对啊，为什么还是一次收到了好多数据啊！ 这是因为，在Swoole中，采用的不是遍历识别的方法，而只是简单的检查每一次接收到的数据的末尾是不是定义好的EOF标记。因此，在开启EOF检测后，onReceive回调中还是可能会一次收到多个数据包。 这要怎么办？你会发现，虽然是多个数据包，但是实际上收到的是N个完整的数据片段，那就只需要根据EOF把每个包再拆出来，一个个处理就好啦。 修改后的服务器端代码如下: 12345678910// serverpublic function onReceive(swoole_serve $serv, $fd, $from_id, $data)&#123; $data_list = explode(\"\\r\\n\", $data); foreach($data_list as $msg) &#123; if (!empty($msg) &#123; echo \"Get Message From Client &#123;$fd&#125;:&#123;$data&#125;\\n\"; &#125; &#125;&#125; 固定包头类型协议固定包头协议是在实际应用中最常用的协议。该协议的内容是规定一个固定长度的包头，在包头的固定位置有一个指定好的字段存放了后续数据的实际长度这样，服务器端可以先读取固定长度的数据，从中提取出长度，然后再读取指定长度的数据，即可获取一段完整的数据。 在Swoole中，同样提供了固定包头的协议格式。需要注意的是，Swoole只允许二进制形式的包头，因此，需要使用pack、unpack来打包、解包。 通过设置open_length_check选项，即可打开固定包头协议解析功能。此外还有package_length_offset，package_body_offset和package_length_type三个配置项用于控制解析功能。 package_length_offset规定了包头中第几个字节开始是长度字段， package_body_offset规定了包头的长度， package_length_type规定了长度字段的类型。 1234567$this-&gt;serv-&gt;set(array( 'package_max_length' =&gt; 8192, 'open_length_check' =&gt; true, 'package_length_offset' =&gt; 0, 'package_body_offset' =&gt; 4, 'package_length_type' =&gt; 'N')); 实例 服务器端 12345678public function onReceive(swoole_server $serv, $fd, $from_id, $data)&#123; $length = unpack(\"N\", $data)[1]; echo \"Length = &#123;$length&#125;\\n\"; $msg = substr($data, -$length); echo \"Get Message From Client &#123;$fd&#125;:&#123;$msg&#125;\\n\";&#125; 客户端 1234567$msg_lenght = pack(\"N\", strlen($msg_normal)).$msg_normal;$i = 0;while($i &lt; 100) &#123; $this-&gt;client-&gt;send($msg_lengt); $i++;&#125; 特别篇:Http协议-Swoole内置的http_server 从Swoole-1.7.7-stable开始，Swoole在内部封装并实现了一个Http服务器。 是的，没错，再也不用在PHP层缓存和解析http协议了，Swoole直接内置Http服务器了。 swoole_http_server 12345$http = new swoole_http_server(\"127.0.0.1\", 9501);$http-&gt;on('request', function (swoole_http_request $request, swoole_http_response $response) &#123; $response-&gt;end(\"&lt;h1&gt;Hello Swoole.&lt;/h1&gt;\");&#125;);$http-&gt;start(); 只需创建一个swoole_http_server对象并设置onRequest回调函数，即可实现一个http服务器。 在onRequest回调中，共有两个参数。 参数$request存放了来自客户端的请求，包括Http请求的头部信息、Http请求相关的服务器信息、Http请求的GET和POST参数以及HTTP请求携带的COOKIE信息。 参数$response用于发送数据给客户端，可以通过该参数设置HTTP响应的Header信息、cookie信息和状态码。 此外，swoole_http_server还提供WebSocket功能，使用此功能需要设置onMessage回调函数，如下: 1234$http_server-&gt;on('message', function(swoole_http_request $request, swoole_http_response $response) &#123; echo $request-&gt;message; $response-&gt;message(json_encode(array(\"data1\", \"data2\")));&#125;) 通过$request-&gt;message获取WebSocket发送来的消息，再通过$response-&gt;message()回复消息即可。 参考 Swoole文档 Swoole入门教程及文档 swoole_server配置选项","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"Swoole","slug":"Swoole","permalink":"http://blog.caoxl.com/tags/Swoole/"}]},{"title":"关于如何禁止谷歌浏览器强制转 HTTPS","slug":"Solve-a-pit-for-HttpToHttps","date":"2018-03-29T09:31:14.000Z","updated":"2019-08-22T03:45:09.000Z","comments":true,"path":"2018/03/29/Solve-a-pit-for-HttpToHttps/","link":"","permalink":"http://blog.caoxl.com/2018/03/29/Solve-a-pit-for-HttpToHttps/","excerpt":"Chrome 于 V63 版本起会将 .dev 域名强制转换为 HTTPS","text":"Chrome 于 V63 版本起会将 .dev 域名强制转换为 HTTPS 看了很多文章都没有什么实际作用，最后发现不适用 .dev 就解决了 简单来说 建议您使用以下域名开发： .localhost .invalid .test .example 开发环境下改域名后缀就好了。至少我是这么解决的。","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"HTTPs","slug":"HTTPs","permalink":"http://blog.caoxl.com/tags/HTTPs/"}]},{"title":"Mac下安装配置Redis","slug":"Install-redis-in-Mac","date":"2018-03-29T08:54:22.000Z","updated":"2019-08-22T06:36:07.000Z","comments":true,"path":"2018/03/29/Install-redis-in-Mac/","link":"","permalink":"http://blog.caoxl.com/2018/03/29/Install-redis-in-Mac/","excerpt":"一、准备工作 二、安装redis服务器 三、redis服务器的启动、使用和退出 四、配置php使用redis服务 五、常见问题","text":"一、准备工作 二、安装redis服务器 三、redis服务器的启动、使用和退出 四、配置php使用redis服务 五、常见问题 一 准备工作 安装homebrew 安装php、nginx（或apache）或集成环境 二 安装redis服务器 通过homebrew安装 1brew install redis 直接下载安装 12345678curl -O http://redis.googlecode.com/files/redis-2.8.7.tar.gzsudo tar -zxf redis-2.8.7.tar.gzmv redis-2.8.7 /usr/local/rediscd redissudo makesudo make testsudo make installmv redis.conf /etc/redis.conf 三 redis服务器的启动、使用和退出 1 启动redis服务 1/usr/local/bin/redis-server 2 查看redis服务是否启动 1ps aux | grep redis 3 使用redis服务 通过redis-cli命令可以启动redis客户端 1redis-cli 常用命令见：上一篇文章 4 退出redis服务 客户端退出 1redis-cli shutdown 关闭pid 1ps -u jim(替换成你的用户名) -o pid,rss,command | grep redis-server 如果你的电脑安装了oh my zsh 那么只需要在终端输入 1kill redis 按tab，会自动替换成对应的pid 再运行: 1kill -9 对应的pid 四 配置php使用redis服务 安装php的redis扩展 1brew install php71-redis --build-from-source php71是本机安装的php的版本（7.1）,--build-from-source是让安装的扩展与php的版本保持一致 查看phpinfo()，出现redis选项说明redis配置成功 在php代码中使用redis服务 123456$redis = new Redis();$redis-&gt;connect('127.0.0.1','host');//redis服务器ip及端口号$redis-&gt;set($key,$value,$timeout);//设置缓存:键-值-缓存时间$redis-&gt;get($key);//查找缓存$redis-&gt;del($key);//删除缓存$redis-&gt;delete($key);//删除缓存 五 常见问题 （1）Redis: Failed opening .rdb for saving: Permission denied redis服务器会生成dump.rdb文件存储缓存，如果文件权限不够则无法读写该文件 1cd /usr/loal/bin 在/usr/local/bin/（默认文件目录）下执行命令 1chmod 777 dump.rdb","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"}]},{"title":"Redis 命令","slug":"Learn-Redis-Command","date":"2018-03-28T06:55:33.000Z","updated":"2019-08-22T06:36:11.000Z","comments":true,"path":"2018/03/28/Learn-Redis-Command/","link":"","permalink":"http://blog.caoxl.com/2018/03/28/Learn-Redis-Command/","excerpt":"记录一些常用的Redis命令和例子。","text":"记录一些常用的Redis命令和例子。 Key (键)DEL 删除给定的一个或多个 key 。12345redis&gt; SET name huangzOKredis&gt; DEL name(integer) 1 DUMP 序列化给定 key ，并返回被序列化的值使用 RESTORE 命令可以将这个值反序列化为 Redis 键。 12345678redis&gt; SET greeting \"hello, dumping world!\"OKredis&gt; DUMP greeting\"\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde\"redis&gt; DUMP not-exists-key(nil) EXISTS 检查给定 key 是否存在。1234567891011redis&gt; SET db \"redis\"OKredis&gt; EXISTS db(integer) 1redis&gt; DEL db(integer) 1redis&gt; EXISTS db(integer) 0 EXPIRE 为给定 key 设置生存时间当 key 过期时(生存时间为 0 )，它会被自动删除。 1234567891011121314redis&gt; SET cache_page \"www.google.com\"OKredis&gt; EXPIRE cache_page 30 # 设置过期时间为 30 秒(integer) 1redis&gt; TTL cache_page # 查看剩余生存时间(integer) 23redis&gt; EXPIRE cache_page 30000 # 更新过期时间(integer) 1redis&gt; TTL cache_page(integer) 29996 EXPIREAT 用于为 key 设置生存时间12345678redis&gt; SET cache www.google.comOKredis&gt; EXPIREAT cache 1355292000 # 这个 key 将在 2012.12.12 过期(integer) 1redis&gt; TTL cache(integer) 45081860 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp) KEYS 查找所有符合给定模式 pattern 的 key 。 KEYS 匹配数据库中所有 key 。KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。KEYS h llo 匹配 hllo 和 heeeeello 等。KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。 123456789101112131415161718redis&gt; MSET one 1 two 2 three 3 four 4 # 一次设置 4 个 keyOKredis&gt; KEYS *o*1) \"four\"2) \"two\"3) \"one\"redis&gt; KEYS t??1) \"two\"redis&gt; KEYS t[w]*1) \"two\"redis&gt; KEYS * # 匹配数据库内所有 key1) \"four\"2) \"three\"3) \"two\" MIGRATE 将 key 原子性地从当前实例传送到目标实例的指定数据库上一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。 这个命令是一个原子操作，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生：迁移成功，迁移失败，等待超时。 12345678910111213$ ./redis-cliredis 127.0.0.1:6379&gt; flushdbOKredis 127.0.0.1:6379&gt; SET greeting \"Hello from 6379 instance\"OKredis 127.0.0.1:6379&gt; MIGRATE 127.0.0.1 7777 greeting 0 1000OKredis 127.0.0.1:6379&gt; EXISTS greeting # 迁移成功后 key 被删除(integer) 0 MOVE 将当前数据库的 key 移动到给定的数据库 db 当中。12345678910111213141516171819# key 存在于当前数据库redis&gt; SELECT 0 # redis默认使用数据库 0，为了清晰起见，这里再显式指定一次。OKredis&gt; SET song \"secret base - Zone\"OKredis&gt; MOVE song 1 # 将 song 移动到数据库 1(integer) 1redis&gt; EXISTS song # song 已经被移走(integer) 0redis&gt; SELECT 1 # 使用数据库 1OKredis:1&gt; EXISTS song # 证实 song 被移到了数据库 1 (注意命令提示符变成了\"redis:1\"，表明正在使用数据库 1)(integer) 1 OBJECT 命令允许从内部察看给定 key 的 Redis 对象。1234567891011121314151617181920212223242526272829redis&gt; SET game \"COD\" # 设置一个字符串OKredis&gt; OBJECT REFCOUNT game # 只有一个引用(integer) 1redis&gt; OBJECT IDLETIME game # 等待一阵。。。然后查看空闲时间(integer) 90redis&gt; GET game # 提取game， 让它处于活跃(active)状态\"COD\"redis&gt; OBJECT IDLETIME game # 不再处于空闲状态(integer) 0redis&gt; OBJECT ENCODING game # 字符串的编码方式\"raw\"redis&gt; SET big-number 23102930128301091820391092019203810281029831092 # 非常长的数字会被编码为字符串OKredis&gt; OBJECT ENCODING big-number\"raw\"redis&gt; SET small-number 12345 # 而短的数字则会被编码为整数OKredis&gt; OBJECT ENCODING small-number\"int\" PERSIST 移除给定 key 的生存时间将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key ) 1234567891011121314redis&gt; SET mykey \"Hello\"OKredis&gt; EXPIRE mykey 10 # 为 key 设置生存时间(integer) 1redis&gt; TTL mykey(integer) 10redis&gt; PERSIST mykey # 移除 key 的生存时间(integer) 1redis&gt; TTL mykey(integer) -1 PEXPIRE 以毫秒为单位设置 key 的生存时间，而不像 EXPIRE 命令那样，以秒为单位。1234567891011redis&gt; SET mykey \"Hello\"OKredis&gt; PEXPIRE mykey 1500(integer) 1redis&gt; TTL mykey # TTL 的返回值以秒为单位(integer) 2redis&gt; PTTL mykey # PTTL 可以给出准确的毫秒数(integer) 1499 PEXPIREAT 以毫秒为单位设置 key 的过期 unix 时间戳，而不是像 EXPIREAT 那样，以秒为单位。这个命令和 EXPIREAT 命令类似 1234567891011redis&gt; SET mykey \"Hello\"OKredis&gt; PEXPIREAT mykey 1555555555005(integer) 1redis&gt; TTL mykey # TTL 返回秒(integer) 223157079redis&gt; PTTL mykey # PTTL 返回毫秒(integer) 223157079318 PTTL 以毫秒为单位返回 key 的剩余生存时间，而不是像 TTL 命令那样，以秒为单位12345678910111213141516171819202122232425# 不存在的 keyredis&gt; FLUSHDBOKredis&gt; PTTL key(integer) -2# key 存在，但没有设置剩余生存时间redis&gt; SET key valueOKredis&gt; PTTL key(integer) -1# 有剩余生存时间的 keyredis&gt; PEXPIRE key 10086(integer) 1redis&gt; PTTL key(integer) 6179 RANDOMKEY 从当前数据库中随机返回(不删除)一个 key 。123456789101112131415161718192021222324# 数据库不为空redis&gt; MSET fruit \"apple\" drink \"beer\" food \"cookies\" # 设置多个 keyOKredis&gt; RANDOMKEY\"fruit\"redis&gt; RANDOMKEY\"food\"redis&gt; KEYS * # 查看数据库内所有key，证明 RANDOMKEY 并不删除 key1) \"food\"2) \"drink\"3) \"fruit\"# 数据库为空redis&gt; FLUSHDB # 删除当前数据库所有 keyOKredis&gt; RANDOMKEY(nil) RENAME 将 key 改名为 newkey 。当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。 当 newkey 已经存在时， RENAME 命令将覆盖旧值。 12345678910111213141516171819202122232425262728293031323334353637# key 存在且 newkey 不存在redis&gt; SET message \"hello world\"OKredis&gt; RENAME message greetingOKredis&gt; EXISTS message # message 不复存在(integer) 0redis&gt; EXISTS greeting # greeting 取而代之(integer) 1# 当 key 不存在时，返回错误redis&gt; RENAME fake_key never_exists(error) ERR no such key# newkey 已存在时， RENAME 会覆盖旧 newkeyredis&gt; SET pc \"lenovo\"OKredis&gt; SET personal_computer \"dell\"OKredis&gt; RENAME pc personal_computerOKredis&gt; GET pc(nil)redis:1&gt; GET personal_computer # 原来的值 dell 被覆盖了\"lenovo\" RENAMENX 当且仅当 newkey 不存在时，将 key 改名为 newkey 。当 key 不存在时，返回一个错误。 12345678910111213141516171819202122232425262728# newkey 不存在，改名成功redis&gt; SET player \"MPlyaer\"OKredis&gt; EXISTS best_player(integer) 0redis&gt; RENAMENX player best_player(integer) 1# newkey存在时，失败redis&gt; SET animal \"bear\"OKredis&gt; SET favorite_animal \"butterfly\"OKredis&gt; RENAMENX animal favorite_animal(integer) 0redis&gt; get animal\"bear\"redis&gt; get favorite_animal\"butterfly\" RESTOR 反序列化给定的序列化值，并将它和给定的 key 关联。123456789101112131415161718192021222324252627282930# 创建一个键，作为 DUMP 命令的输入redis&gt; SET greeting \"hello, dumping world!\"OKredis&gt; DUMP greeting\"\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde\"# 将序列化数据 RESTORE 到另一个键上面redis&gt; RESTORE greeting-again 0 \"\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde\"OKredis&gt; GET greeting-again\"hello, dumping world!\"# 在没有给定 REPLACE 选项的情况下，再次尝试反序列化到同一个键，失败redis&gt; RESTORE greeting-again 0 \"\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde\"(error) ERR Target key name is busy.# 给定 REPLACE 选项，对同一个键进行反序列化成功redis&gt; RESTORE greeting-again 0 \"\\x00\\x15hello, dumping world!\\x06\\x00E\\xa0Z\\x82\\xd8r\\xc1\\xde\" REPLACEOK# 尝试使用无效的值进行反序列化，出错redis&gt; RESTORE fake-message 0 \"hello moto moto blah blah\"(error) ERR DUMP payload version or checksum are wrong SORT 返回或保存给定列表、集合、有序集合 key 中经过排序的元素。1234567891011121314151617181920# 开销金额列表redis&gt; LPUSH today_cost 30 1.5 10 8(integer) 4# 排序redis&gt; SORT today_cost1) \"1.5\"2) \"8\"3) \"10\"4) \"30\"# 逆序排序redis 127.0.0.1:6379&gt; SORT today_cost DESC1) \"30\"2) \"10\"3) \"8\"4) \"1.5\" TTL 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。12345678910111213141516171819202122232425# 不存在的 keyredis&gt; FLUSHDBOKredis&gt; TTL key(integer) -2# key 存在，但没有设置剩余生存时间redis&gt; SET key valueOKredis&gt; TTL key(integer) -1# 有剩余生存时间的 keyredis&gt; EXPIRE key 10086(integer) 1redis&gt; TTL key(integer) 10084 TYPE 返回 key 所储存的值的类型。12345678910111213141516171819202122232425# 字符串redis&gt; SET weather \"sunny\"OKredis&gt; TYPE weatherstring# 列表redis&gt; LPUSH book_list \"programming in scala\"(integer) 1redis&gt; TYPE book_listlist# 集合redis&gt; SADD pat \"dog\"(integer) 1redis&gt; TYPE patset SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代 SCAN 命令用于迭代当前数据库中的数据库键。 SSCAN 命令用于迭代集合键中的元素。 HSCAN 命令用于迭代哈希键中的键值对。 ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。 String (字符串)APPEND 将 value 追加到 key 原来的值的末尾如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。 如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。 12345678910111213141516# 对不存在的 key 执行 APPENDredis&gt; EXISTS myphone # 确保 myphone 不存在(integer) 0redis&gt; APPEND myphone \"nokia\" # 对不存在的 key 进行 APPEND ，等同于 SET myphone \"nokia\"(integer) 5 # 字符长度# 对已存在的字符串进行 APPENDredis&gt; APPEND myphone \" - 1110\" # 长度从 5 个字符增加到 12 个字符(integer) 12redis&gt; GET myphone\"nokia - 1110\" BITCOUNT 计算给定字符串中，被设置为 1 的比特位的数量。1234567891011121314redis&gt; BITCOUNT bits(integer) 0redis&gt; SETBIT bits 0 1 # 0001(integer) 0redis&gt; BITCOUNT bits(integer) 1redis&gt; SETBIT bits 3 1 # 1001(integer) 0redis&gt; BITCOUNT bits(integer) 2 BITOP 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。1234567891011121314151617181920212223242526272829redis&gt; SETBIT bits-1 0 1 # bits-1 = 1001(integer) 0redis&gt; SETBIT bits-1 3 1(integer) 0redis&gt; SETBIT bits-2 0 1 # bits-2 = 1011(integer) 0redis&gt; SETBIT bits-2 1 1(integer) 0redis&gt; SETBIT bits-2 3 1(integer) 0redis&gt; BITOP AND and-result bits-1 bits-2(integer) 1redis&gt; GETBIT and-result 0 # and-result = 1001(integer) 1redis&gt; GETBIT and-result 1(integer) 0redis&gt; GETBIT and-result 2(integer) 0redis&gt; GETBIT and-result 3(integer) 1 DECR 将 key 中储存的数字值减一。12345678910111213141516171819202122232425# 对存在的数字值 key 进行 DECRredis&gt; SET failure_times 10OKredis&gt; DECR failure_times(integer) 9# 对不存在的 key 值进行 DECRredis&gt; EXISTS count(integer) 0redis&gt; DECR count(integer) -1# 对存在但不是数值的 key 进行 DECRredis&gt; SET company YOUR_CODE_SUCKS.LLCOKredis&gt; DECR company(error) ERR value is not an integer or out of range DECRBY 将 key 所储存的值减去减量 decrement 。12345678910111213141516# 对已存在的 key 进行 DECRBYredis&gt; SET count 100OKredis&gt; DECRBY count 20(integer) 80# 对不存在的 key 进行DECRBYredis&gt; EXISTS pages(integer) 0redis&gt; DECRBY pages 10(integer) -10 GET 返回 key 所关联的字符串值。12345678910111213141516171819202122# 对不存在的 key 或字符串类型 key 进行 GETredis&gt; GET db(nil)redis&gt; SET db redisOKredis&gt; GET db\"redis\"# 对不是字符串类型的 key 进行 GETredis&gt; DEL db(integer) 1redis&gt; LPUSH db redis mongodb mysql(integer) 3redis&gt; GET db(error) ERR Operation against a key holding the wrong kind of value GETBIT 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。12345678910111213141516# 对不存在的 key 或者不存在的 offset 进行 GETBIT， 返回 0redis&gt; EXISTS bit(integer) 0redis&gt; GETBIT bit 10086(integer) 0# 对已存在的 offset 进行 GETBITredis&gt; SETBIT bit 10086 1(integer) 0redis&gt; GETBIT bit 10086(integer) 1 GETRANGE 返回 key 中字符串值的子字符串字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。 1234567891011121314151617redis&gt; SET greeting \"hello, my friend\"OKredis&gt; GETRANGE greeting 0 4 # 返回索引0-4的字符，包括4。\"hello\"redis&gt; GETRANGE greeting -1 -5 # 不支持回绕操作\"\"redis&gt; GETRANGE greeting -3 -1 # 负数索引\"end\"redis&gt; GETRANGE greeting 0 -1 # 从第一个到最后一个\"hello, my friend\"redis&gt; GETRANGE greeting 0 1008611 # 值域范围不超过实际字符串，超过部分自动被符略\"hello, my friend\" GETSET 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。 1234567891011redis&gt; GETSET db mongodb # 没有旧值，返回 nil(nil)redis&gt; GET db\"mongodb\"redis&gt; GETSET db redis # 返回旧值 mongodb\"mongodb\"redis&gt; GET db\"redis\" INCR 将 key 中储存的数字值增一。12345678redis&gt; SET page_view 20OKredis&gt; INCR page_view(integer) 21redis&gt; GET page_view # 数字值在 Redis 中以字符串的形式保存\"21\" INCRBY 将 key 所储存的值加上增量 increment 。123456789101112131415161718192021222324252627282930# key 存在且是数字值redis&gt; SET rank 50OKredis&gt; INCRBY rank 20(integer) 70redis&gt; GET rank\"70\"# key 不存在时redis&gt; EXISTS counter(integer) 0redis&gt; INCRBY counter 30(integer) 30redis&gt; GET counter\"30\"# key 不是数字值时redis&gt; SET book \"long long ago...\"OKredis&gt; INCRBY book 200 INCRBYFLOAT 为 key 中所储存的值加上浮点数增量 increment 。12345678910111213141516171819202122232425262728293031323334353637383940414243# 值和增量都不是指数符号redis&gt; SET mykey 10.50OKredis&gt; INCRBYFLOAT mykey 0.1\"10.6\"# 值和增量都是指数符号redis&gt; SET mykey 314e-2OKredis&gt; GET mykey # 用 SET 设置的值可以是指数符号\"314e-2\"redis&gt; INCRBYFLOAT mykey 0 # 但执行 INCRBYFLOAT 之后格式会被改成非指数符号\"3.14\"# 可以对整数类型执行redis&gt; SET mykey 3OKredis&gt; INCRBYFLOAT mykey 1.1\"4.1\"# 后跟的 0 会被移除redis&gt; SET mykey 3.0OKredis&gt; GET mykey # SET 设置的值小数部分可以是 0\"3.0\"redis&gt; INCRBYFLOAT mykey 1.000000000000000000000 # 但 INCRBYFLOAT 会将无用的 0 忽略掉，有需要的话，将浮点变为整数\"4\"redis&gt; GET mykey\"4\" MGET 返回所有(一个或多个)给定 key 的值。1234567891011121314redis&gt; SET redis redis.comOKredis&gt; SET mongodb mongodb.orgOKredis&gt; MGET redis mongodb1) \"redis.com\"2) \"mongodb.org\"redis&gt; MGET redis mongodb mysql # 不存在的 mysql 返回 nil1) \"redis.com\"2) \"mongodb.org\"3) (nil) MSET 同时设置一个或多个 key-value 对12345678910111213141516171819 redis&gt; MSET date \"2012.3.30\" time \"11:00 a.m.\" weather \"sunny\" OK redis&gt; MGET date time weather 1) \"2012.3.30\" 2) \"11:00 a.m.\" 3) \"sunny\" # MSET 覆盖旧值例子 redis&gt; SET google \"google.hk\" OK redis&gt; MSET google \"google.com\" OK redis&gt; GET google\"google.com\" MSETNX 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。123456789101112131415161718192021# 对不存在的 key 进行 MSETNXredis&gt; MSETNX rmdbs \"MySQL\" nosql \"MongoDB\" key-value-store \"redis\"(integer) 1redis&gt; MGET rmdbs nosql key-value-store1) \"MySQL\"2) \"MongoDB\"3) \"redis\"# MSET 的给定 key 当中有已存在的 keyredis&gt; MSETNX rmdbs \"Sqlite\" language \"python\" # rmdbs 键已经存在，操作失败(integer) 0redis&gt; EXISTS language # 因为 MSET 是原子性操作，language 没有被设置(integer) 0redis&gt; GET rmdbs # rmdbs 也没有被修改\"MySQL\" SET 将字符串值 value 关联到 key 。12345678910111213141516# 对不存在的键进行设置redis 127.0.0.1:6379&gt; SET key \"value\"OKredis 127.0.0.1:6379&gt; GET key\"value\"# 对已存在的键进行设置redis 127.0.0.1:6379&gt; SET key \"new-value\"OKredis 127.0.0.1:6379&gt; GET key\"new-value\" Hash (哈希表)List (列表)Set (集合)SortedSet (有序集合)HyperLogLogGEO (地理位置)Pub/Sub (发布、订阅)Transaction (事务)Script (脚本)Connection (连接)Server (服务器)参考 Redis 命令参考","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.caoxl.com/tags/Redis/"}]},{"title":"Linux 基础","slug":"Learn-Linux","date":"2018-03-22T08:47:18.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/03/22/Learn-Linux/","link":"","permalink":"http://blog.caoxl.com/2018/03/22/Learn-Linux/","excerpt":"一个PHP瓜皮如何学习Linux?","text":"一个PHP瓜皮如何学习Linux? Linux 关机命令正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt sync 将数据由内存同步到硬盘中。 shutdown 机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机 shutdown -h 10 “this server will shutdown after 10 mins” 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。 Shutdown -h now 立马关机 Shutdown -h 20:35 系统会在今天20:25关机 Shutdown -h +10 十分钟后关机 Shutdown -r now 系统立马重启 Shutdown -r +10 系统十分钟后重启 reboot 就是重启，等同于 shutdown –r now halt 关闭系统，等同于shutdown –h now 和 poweroff 最后总结一下，不管是重启系统还是关闭系统，首先要运行 sync 命令，把内存中的数据写到磁盘中。 目录结构 /bin: bin是Binary的缩写, 这个目录存放着最经常使用的命令。 /boot: 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev: dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 /etc: 这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home: 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib: 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found: 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media: linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 mnt: 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。 /opt: 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc: 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器 echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all /root: 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin: s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /selinux: 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv: 该目录存放一些服务启动之后需要提取的数据。 /sys: 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp: 这个目录是用来存放一些临时文件的。 /usr: 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。 /usr/bin: 系统用户使用的应用程序。 /usr/sbin: 超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src: 内核源代码默认的放置目录。 /var: 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 Linux文件基本属性12345[root@www /]# ls -ltotal 64dr-xr-xr-x 2 root root 4096 Dec 14 2012 bindr-xr-xr-x 4 root root 4096 Apr 19 2012 boot…… 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 更改文件属性chgrp：更改文件属组1chgrp [-R] 属组名文件名 chown：更改文件属主，也可以同时更改文件属组12chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名 进入 /root 目录（~）将install.log的拥有者改为bin这个账号： 1234[root@www ~] cd ~[root@www ~]# chown bin install.log[root@www ~]# ls -l-rw-r--r-- 1 bin users 68495 Jun 25 08:53 install.log 将install.log的拥有者与群组改回为root： 123[root@www ~]# chown root:root install.log[root@www ~]# ls -l-rw-r--r-- 1 root root 68495 Jun 25 08:53 install.log chmod：更改文件9个属性每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 变更权限的指令chmod的语法是这样的： 1chmod [-R] xyz 文件或目录 xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 符号类型改变文件权限u +(加入) r chmod g -(除去) w 文件或目录 o =(设定) x a Linux 文件与目录管理处理目录的常用命令 ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 Linux 文件内容查看 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 Linux 用户和用户组管理Linux系统用户账号的管理添加新的用户账号1useradd 选项 用户名 删除帐号1userdel 选项 用户名 修改账号1usermod 选项 用户名 用户口令的管理1passwd 选项 用户名 Linux系统用户组的管理增加一个新的用户组1groupadd 用户组 删除一个用户组1groupdel 用户组 修改用户组1groupmod 选项 用户组 Linux 磁盘管理 df：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 fdisk：用于磁盘分区 df df [-ahikHTm] [目录或文件名] -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M=1000K 取代 M=1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 du du [-ahskm] 文件或目录名称 -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G/M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示 fdisk fdisk [-l] 装置名称 -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 磁盘检验 fsck [-t 文件系统] [-ACay] 装置名称 -t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数 -s : 依序一个一个地执行 fsck 的指令来检查 -A : 对/etc/fstab 中所有列出来的 分区（partition）做检查 -C : 显示完整的检查进度 -d : 打印出 e2fsck 的 debug 结果 -p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行 -R : 同时有 -A 条件时，省略 / 不检查 -V : 详细显示模式 -a : 如果检查有错则自动修复 -r : 如果检查有错则由使用者回答是否修复 -y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。 磁盘挂载与卸除 mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 Yum 命令yum常用命令 1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install &lt;package_name&gt; 4.仅更新指定的软件命令：yum update &lt;package_name&gt; 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove &lt;package_name&gt; 7.查找软件包 命令：yum search 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers Shell 教程Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 第一个shell脚本12#!/bin/bashecho \"Hello world!\" 运行 Shell 脚本有两种方法： 1、作为可执行程序 12chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本 2、作为解释器参数 12/bin/sh test.sh/bin/php test.php Shell变量使用变量使用一个定义过的变量，只要在变量名前面加美元符号即可，如： 123your_name=\"qinjx\"echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况： 123for skill in Ada Coffe Action Java; do echo \"I am good at $&#123;skill&#125;Script\"done 只读变量1234#!/bin/bashmyUrl=\"http://www.w3cschool.cc\"readonly myUrlmyUrl=\"http://www.runoob.com\" 删除变量1234#!/bin/shmyUrl=\"http://www.runoob.com\"unset myUrlecho $myUrl Shell 数组12345678#!/bin/bashmy_array=(A B \"C\" D)echo \"第一个元素为: $&#123;my_array[0]&#125;\"echo \"第二个元素为: $&#123;my_array[1]&#125;\"echo \"第三个元素为: $&#123;my_array[2]&#125;\"echo \"第四个元素为: $&#123;my_array[3]&#125;\" Shell 流程控制if else1234567if conditionthen command1 command2 ... commandN fi if else-if else123456789if condition1then command1elif condition2 then command2else commandNfi for 循环1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone while 语句1234while conditiondo commanddone 无限循环12345678910111213while :do commanddone// 或while truedo commanddone// 或者for (( ; ; )) until 循环1234until conditiondo commanddone case1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac 跳出循环break命令12345678910111213#!/bin/bashwhile :do echo -n \"输入 1 到 5 之间的数字:\" read aNum case $aNum in 1|2|3|4|5) echo \"你输入的数字为 $aNum!\" ;; *) echo \"你输入的数字不是 1 到 5 之间的! 游戏结束\" break ;; esacdone continue1234567891011121314#!/bin/bashwhile :do echo -n \"输入 1 到 5 之间的数字: \" read aNum case $aNum in 1|2|3|4|5) echo \"你输入的数字为 $aNum!\" ;; *) echo \"你输入的数字不是 1 到 5 之间的!\" continue echo \"游戏结束\" ;; esacdone Linux 命令大全 命令大全","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"前端框架 Vue.js","slug":"What-is-vue","date":"2018-03-22T01:22:40.000Z","updated":"2019-08-22T06:52:31.000Z","comments":true,"path":"2018/03/22/What-is-vue/","link":"","permalink":"http://blog.caoxl.com/2018/03/22/What-is-vue/","excerpt":"作为一个后端开发人员是需要了解一些前端框架，以便遇到前端问题的时候知道如何解决.","text":"作为一个后端开发人员是需要了解一些前端框架，以便遇到前端问题的时候知道如何解决. 安装使用独立版本我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 &lt;script&gt; 标签引入 使用 CDN 方法 BootCDN（国内） : https://cdn.bootcss.com/vue/2.2.2/vue.min.js unpkg：https://unpkg.com/vue/dist/vue.js, 会保持和 npm 发布的最新的版本一致。 cdnjs : https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js NPM 方法1npm install vue 命令行工具12345# 全局安装 vue-cli$ cnpm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 这里需要进行一些配置，默认回车即可 进入项目，安装并运行： 123$ cd my-project$ cnpm install$ cnpm run dev Listening at http://localhost:8080 目录结构 目录/文件 说明 build 项目构建(webpack)相关代码 config 配置目录，包括端口号等。我们初学可以使用默认的。 node_modules npm 加载的项目依赖模块 src 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件： static 静态资源目录，如图片、字体等。 test 初始测试目录，可删除 .xxxx文件 这些是一些配置文件，包括语法配置，git配置等。 index.html 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。 package.json 项目配置文件。 README.md 项目的说明文档，markdown 格式 src assets: 放置一些图片，如logo等。 components: 目录里面放了一个组件文件，可以不用。 App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。 App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。 模板语法HTML123456789101112&lt;div id=\"app\"&gt; &lt;div v-html=\"message\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: '&lt;h1&gt;菜鸟教程&lt;/h1&gt;' &#125;&#125;)&lt;/script&gt; 路由安装直接下载 / CDN1https://unpkg.com/vue-router/dist/vue-router.js NPM1cnpm install vue-router 简单实例HTML代码12345678910111213141516&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"&gt;&lt;/script&gt; &lt;div id=\"app\"&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=\"/bar\"&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; JavaScript 代码12345678910111213141516171819202122232425262728293031// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter) // 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125; // 2. 定义路由// 每个路由应该映射一个组件。 其中\"component\" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;] // 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;) // 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app') // 现在，应用已经启动了！ NPM 路由实例在 Github 上下载：https://github.com/chrisvfritz/vue-2.0-simple-routing-example 下载完后，解压该目录，重命名目录为 vue-demo，vu 并进入该目录，执行以下命令： 12345# 安装依赖，使用淘宝资源命令 cnpmcnpm install# 启动应用，地址为 localhost:8080cnpm run dev 如果你需要发布到正式环境可以执行以下命令： 1cnpm run build 参考 Vue.js教程","categories":[{"name":"加分技能","slug":"加分技能","permalink":"http://blog.caoxl.com/categories/加分技能/"}],"tags":[{"name":"前端，vue","slug":"前端，vue","permalink":"http://blog.caoxl.com/tags/前端，vue/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://blog.caoxl.com/tags/FrontEnd/"}]},{"title":"How to sell Yourself","slug":"How-to-make-good-resume","date":"2018-03-21T09:03:10.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/03/21/How-to-make-good-resume/","link":"","permalink":"http://blog.caoxl.com/2018/03/21/How-to-make-good-resume/","excerpt":"作为一个IT行业的ITer，面对跳槽就需要更新简历，人是一直在成长的，那么你如何让别人知道你已经成长到别人需要的那样？或者比别人想象中更好？ 你需要学会包装自己，推销自己。","text":"作为一个IT行业的ITer，面对跳槽就需要更新简历，人是一直在成长的，那么你如何让别人知道你已经成长到别人需要的那样？或者比别人想象中更好？ 你需要学会包装自己，推销自己。 先讲讲怎样才是一份好的技术简历首先，一份好的简历不光说明事实，更通过FAB模式来增强其说服力。 Feature：是什么 Advantage：比别人好在哪些地方 Benefit：如果雇佣你，招聘方会得到什么好处 其次，写简历和写议论文不同，过分的论证会显得自夸，反而容易引起反感，所以要点到为止。这里的技巧是，提供论据，把论点留给阅读简历的人自己去得出。放论据要具体，最基本的是要数字化，好的论据要让人印象深刻。 联系方式（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便） 手机: 13250729798 Email: code0809@163.com QQ/微信号: c973211480 个人信息 曹贤亮/男/1994 本科/海南热带海洋学院计算机系 工作年限：2年 技术博客：http://blog.caoxl.com Github：http://github.com/SoulMate94 期望职位：PHP开发工程师 期望薪资：税前月薪10k~15k，特别喜欢的公司可例外 期望城市：广州 工作经历（工作经历按逆序排列，最新的在最前边，按公司做一级分组，公司内按二级分组） ABC公司 （ 2017年5月 ~ 2018年4月 ）DEF项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 GHI项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 其他项目（每个公司写2~3个核心项目就好了，如果你有非常大量的项目，那么按分类进行合并，每一类选一个典型写出来。其他的一笔带过即可。 JKL公司 （ 2015年3月 ~ 2017年5月 ）MNO项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 PQR项目我在此项目负责了哪些工作，分别在哪些地方做得出色/和别人不一样/成长快，这个项目中，我最困难的问题是什么，我采取了什么措施，最后结果如何。这个项目中，我最自豪的技术细节是什么，为什么，实施前和实施后的数据对比如何，同事和领导对此的反应如何。 开源项目和作品（这一段用于放置工作以外的、可证明你的能力的材料） 开源项目对于程序员来讲，没有什么比Show me the code能有说服力了） STU：项目的简要说明，Star和Fork数多的可以注明 WXYZ：项目的简要说明，Star和Fork数多的可以注明 技术文章（挑选你写作或翻译的技术文章，好的文章可以从侧面证实你的表达和沟通能力，也帮助招聘方更了解你） 技能清单（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错） 以下均为我熟练使用的技能 PHP框架：Laravel/Lumen/ThinkPHP 前端框架：Bootstrap/HTML5/Vue.js 数据库相关：MySQL/MongoDB/PDO 版本管理、文档、任务流：Git/Svn/Composer/Showdoc/禅道 单元测试：PHPUnit 压力测试： AB 第三方：微信支付/支付宝支付/第三方登录/极光推送/阿里云通信/七牛云存储 参考技能关键字本技能关键字列表是从最近招聘PHP的数百份JD中统计出来的, 如果你的简历要投递给有机器（简历分选系统）和 不懂技术的HR 筛选简历环节的地方，请一定从下边高频关键词中选择5～10个适合你自己的 PHP5/PHP7 MySQL/MongoDB/SQL/noSQL Linux Javascript/JQuery/Ajax MVC/WVVM LAMP/LAMNP Apache/Nginx ThinkPHP/Laravel/Lumen/Laravel-admin Memcache/Redis Session/Cookie Git/SVN/Composer JSON/XML/JSONP HTML/HTML5/CSS/CSS3 Queue/Crontab/Shell Python HTTP/HTTPS/TCP/IP 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"简历","slug":"简历","permalink":"http://blog.caoxl.com/tags/简历/"},{"name":"Resume","slug":"Resume","permalink":"http://blog.caoxl.com/tags/Resume/"}]},{"title":"ThinkPHP5 「学习笔记」","slug":"Learn-ThinkPHP5","date":"2018-03-14T02:14:04.000Z","updated":"2019-08-22T06:43:28.000Z","comments":true,"path":"2018/03/14/Learn-ThinkPHP5/","link":"","permalink":"http://blog.caoxl.com/2018/03/14/Learn-ThinkPHP5/","excerpt":"很久以前一直用ThinkPHP 3.2的版本，又很长时间没有使用过ThinkPHP，使用Laravel、Lumen很久，所以需要重新学习下ThinkPHP5","text":"很久以前一直用ThinkPHP 3.2的版本，又很长时间没有使用过ThinkPHP，使用Laravel、Lumen很久，所以需要重新学习下ThinkPHP5 基础安装1composer create-project topthink/think=5.0.* tp5 --prefer-dist 目录结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546project 应用部署目录├─application 应用目录（可设置）│ ├─common 公共模块目录（可更改）│ ├─index 模块目录(可更改)│ │ ├─config.php 模块配置文件│ │ ├─common.php 模块函数文件│ │ ├─controller 控制器目录│ │ ├─model 模型目录│ │ ├─view 视图目录│ │ └─ ... 更多类库目录│ ├─command.php 命令行工具配置文件│ ├─common.php 应用公共（函数）文件│ ├─config.php 应用（公共）配置文件│ ├─database.php 数据库配置文件│ ├─tags.php 应用行为扩展定义文件│ └─route.php 路由配置文件├─extend 扩展类库目录（可定义）├─public WEB 部署目录（对外访问目录）│ ├─static 静态资源存放目录(css,js,image)│ ├─index.php 应用入口文件│ ├─router.php 快速测试文件│ └─.htaccess 用于 apache 的重写├─runtime 应用的运行时目录（可写，可设置）├─vendor 第三方类库目录（Composer）├─thinkphp 框架系统目录│ ├─lang 语言包目录│ ├─library 框架核心类库目录│ │ ├─think Think 类库包目录│ │ └─traits 系统 Traits 目录│ ├─tpl 系统模板目录│ ├─.htaccess 用于 apache 的重写│ ├─.travis.yml CI 定义文件│ ├─base.php 基础定义文件│ ├─composer.json composer 定义文件│ ├─console.php 控制台入口文件│ ├─convention.php 惯例配置文件│ ├─helper.php 助手函数文件（可选）│ ├─LICENSE.txt 授权说明文件│ ├─phpunit.xml 单元测试配置文件│ ├─README.md README 文件│ └─start.php 框架引导文件├─build.php 自动生成定义文件（参考）├─composer.json composer 定义文件├─LICENSE.txt 授权说明文件├─README.md README 文件├─think 命令行入口文件 如果是mac或者linux环境，请确保runtime目录有可写权限 1chmod -R 777 runtime/ 架构路由访问5.0的URL访问必须是PATH_INFO方式（包括兼容方式）的URL地址，例如： 1http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/参数/值… URL大小写123http://localhost/index.php/Index/BlogTest/read// 和下面的访问是等效的http://localhost/index.php/index/blogtest/read 如果希望URL访问严格区分大小写，可以在应用配置文件中设置： 12// 关闭URL中控制器和操作名的自动转换'url_convert' =&gt; false, 入口文件index.php 123456// 应用入口文件// 定义项目路径define('APP_PATH', __DIR__ . '/../application/');// 加载框架引导文件require __DIR__ . '/../thinkphp/start.php'; 隐藏入口文件Apache: 1、httpd.conf配置文件中加载了mod_rewrite.so模块 2、AllowOverride None 将None改为 All 3、在应用入口文件同级目录添加.htaccess文件，内容如下： 12345678&lt;IfModule mod_rewrite.c&gt;Options +FollowSymlinks -MultiviewsRewriteEngine onRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt; 命名空间特别注意的是，如果你需要调用PHP内置的类库，或者第三方没有使用命名空间的类库，记得在实例化类库的时候加上 \\，例如： 1234567// 错误的用法$class = new stdClass();$xml = new SimpleXmlElement($xmlstr);// 正确的用法$class = new \\stdClass();$xml = new \\SimpleXmlElement($xmlstr); 根命名空间（类库包） 名称 描述 类库目录 think 系统核心类库 thinkphp/library/think traits 系统Trait类库 thinkphp/library/traits app 应用类库 application API数据输出默认JSON输出 1'default_return_type'=&gt;'json' JSON12345678910111213141516namespace app\\index\\controller;class Index &#123; public function index() &#123; $data = ['name'=&gt;'thinkphp','url'=&gt;'thinkphp.cn']; // 指定json数据输出 return json([ 'data' =&gt; $data, 'code' =&gt; 1, 'message' =&gt; '操作完成' ]); &#125;&#125; XML123456789101112131415namespace app\\index\\controller;class Index &#123; public function index() &#123; $data = ['name'=&gt;'thinkphp','url'=&gt;'thinkphp.cn']; // 指定xml数据输出 return xml([ 'data' =&gt; $data, 'code' =&gt; 1, 'message' =&gt; '操作完成' ]); &#125;&#125; 核心支持的数据类型包括view、xml、json和jsonp，其他类型的需要自己扩展。 错误调试设置方式： 123456'app_trace' =&gt; true,'trace' =&gt; [ 'type' =&gt; 'socket', // socket服务器 'host' =&gt; 'slog.thinkphp.cn',], 配置默认配置定义格式1234567891011//项目配置文件return [ // 默认模块名 'default_module' =&gt; 'index', // 默认控制器名 'default_controller' =&gt; 'Index', // 默认操作名 'default_action' =&gt; 'index', //更多配置参数 //...]; 默认方式为PHP数组方式定义配置文件，你可以在入口文件定义CONF_EXT常量来更改为其它的配置类型： 12// 更改配置格式为ini格式define('CONF_EXT', '.ini'); ini格式配置示例：123default_module=Index ;默认模块default_controller=index ;默认控制器default_action=index ;默认操作 xml格式配置示例：12345&lt;config&gt;&lt;default_module&gt;Index&lt;/default_module&gt;&lt;default_controller&gt;index&lt;/default_controller&gt;&lt;default_action&gt;index&lt;/default_action&gt;&lt;/config&gt; json格式配置示例：12345&#123;\"default_module\":\"Index\",\"default_controller\":\"index\",\"default_action\":\"index\"&#125; 二级配置1234567891011121314151617$config = [ 'user' =&gt; [ 'type' =&gt; 1, 'name' =&gt; 'thinkphp', ], 'db' =&gt; [ 'type' =&gt; 'mysql', 'user' =&gt; 'root', 'password' =&gt; '', ],];// 设置配置参数Config::set($config);// 读取二级配置参数echo Config::get('user.type');// 或者使用助手函数echo config('user.type'); 配置加载应用配置文件是应用初始化的时候首先加载的公共配置文件，默认位于application/config.php 扩展配置扩展配置文件是由extra_config_list配置参数定义的额外的配置文件，默认会加载database和validate两个扩展配置文件。 V5.0.1开始，取消了该配置参数，扩展配置文件直接放入application/extra目录会自动加载 场景配置举个例子，你需要在公司和家里分别设置不同的数据库测试环境。那么可以这样处理，在公司环境中，我们在应用配置文件中配置： 1'app_status'=&gt;'office' 那么就会自动加载该状态对应的配置文件（默认位于application/office.php） 如果我们回家后，我们修改定义为： 1'app_status'=&gt;'home' 那么就会自动加载该状态对应的配置文件（位于application/home.php）。 读取配置1234567891011121314151617echo Config::get('配置参数1');echo config('配置参数1');// 读取所有的配置参数dump(Config::get());// Ordump(config());// 判定是否存在某个设置参数Config::has('配置参数2');// Orconfig('?配置参数2');// 读取二级配置echo Config::get('配置参数.二级参数');echo config('配置参数.二级参数'); 设置配置参数12345678910111213Config::set('配置参数', '配置值');config('配置参数'，'配置值');// 批量设置Config::set([ '配置参数1' =&gt; '配置值', '配置参数2' =&gt; '配置值',]);// 或者使用助手函数config([ '配置参数1'=&gt;'配置值', '配置参数2'=&gt;'配置值']); 配置作用域123456789101112131415161718192021// 导入my_config.php中的配置参数，并纳入user作用域Config::load('my_config.php','','user'); // 解析并导入my_config.ini 中的配置参数，读入test作用域Config::parse('my_config.ini','ini','test'); // 设置user_type参数，并纳入user作用域Config::set('user_type',1,'user'); // 批量设置配置参数，并纳入test作用域Config::set($config,'test'); // 读取user作用域的user_type配置参数echo Config::get('user_type','user'); // 读取user作用域下面的所有配置参数dump(Config::get('','user')); dump(config('',null,'user')); // 同上// 判断在test作用域下面是否存在user_type参数Config::has('user_type','test'); 可以使用range方法切换当前配置文件的作用域，例如： 1Config::range('test'); 环境变量配置在开发过程中，可以在应用根目录下面的.env来模拟环境变量配置，.env文件中的配置参数定义格式采用ini方式，例如： 12app_debug = trueapp_trace = true 如果你的部署环境单独配置了环境变量，那么请删除.env配置文件，避免冲突。 环境变量配置的参数会全部转换为大写，值为 null，no 和 false 等效于 &quot;&quot;，值为 yes 和 true 等效于 &quot;1&quot;。 注意，环境变量不支持数组参数，如果需要使用数组参数可以，使用下划线分割定义配置参数名： 1234567database_username = rootdatabase_password = 123456// 或者[database]username = rootpassword = 123456 获取环境变量123456789101112131415Env::get('database.username');Env::get('database.password');// 同时下面的方式也可以获取Env::get('database_username');Env::get('database_password');// 可以支持默认值// 获取环境变量 如果不存在则使用默认值rootEnv::get('database.username','root');// 直接在应用配置中使用环境变量return [ 'hostname' =&gt; Env::get('hostname','127.0.0.1'),]; 路由路由模式普通模式1'url_route_on' =&gt; false, 路由关闭后，不会解析任何路由规则，采用默认的PATH_INFO 模式访问URL： 1http://serverName/index.php/module/controller/action/param/value/... 混合模式开启路由，并使用路由定义+默认PATH_INFO方式的混合： 12'url_route_on' =&gt; true,'url_route_must'=&gt; false, 强制模式开启路由，并设置必须定义路由才能访问： 12'url_route_on' =&gt; true,'url_route_must' =&gt; true, 这种方式下面必须严格给每一个访问地址定义路由规则（包括首页），否则将抛出异常。 首页的路由规则采用/定义即可，例如下面把网站首页路由输出Hello,world! 123Route::get('/', function () &#123; return 'Hello TP5';&#125;); 路由定义动态注册路由定义采用\\think\\Route类的rule方法注册，通常是在应用的路由配置文件application/route.php进行注册，格式是： Route::rule(‘路由表达式’,’路由地址’,’请求类型’,’路由参数（数组）’,’变量规则（数组）’); 123use think\\Route;// 注册路由到index模块的News控制器的read操作Route::rule('new/:id','index/News/read'); 系统提供了为不同的请求类型定义路由规则的简化方法，例如： 12345Route::get('new/:id','News/read'); // 定义GET请求路由规则Route::post('new/:id','News/update'); // 定义POST请求路由规则Route::put('new/:id','News/update'); // 定义PUT请求路由规则Route::delete('new/:id','News/delete'); // 定义DELETE请求路由规则Route::any('new/:id','News/read'); // 所有请求都支持的路由规则 如果要定义get和post请求支持的路由规则，也可以用： 1Route::rule('new/:id','News/read','GET|POST'); 规则表达式规则表达式通常包含静态地址和动态地址，或者两种地址的结合，例如下面都属于有效的规则表达式： 12345'/' =&gt; 'index', // 首页访问路由'my' =&gt; 'Member/myinfo', // 静态地址路由'blog/:id' =&gt; 'Blog/read', // 静态地址和动态地址结合'new/:year/:month/:day' =&gt; 'News/read', // 静态地址和动态地址结合':user/:blog_id' =&gt; 'Blog/read',// 全动态地址 批量注册路由12345678910111213// 批量注册GET路由Route::get([ 'new/:id' =&gt; 'News/read', 'blog/:id' =&gt; ['Blog/edit',[],['id'=&gt;'\\d+']] ...]);// 效果等同于Route::rule([ 'new/:id' =&gt; 'News/read', 'blog/:id' =&gt; ['Blog/edit',[],['id'=&gt;'\\d+']] ...],'','GET'); 定义路由配置文件路由动态注册和配置定义的方式可以共存，例如： 12345678use think\\Route;Route::rule('hello/:name','index/index/hello');return [ 'new/:id' =&gt; 'News/read', 'blog/:id' =&gt; ['Blog/update',['method' =&gt; 'post|put'], ['id' =&gt; '\\d+']],]; 默认情况下，只会加载一个路由配置文件route.php，如果你需要定义多个路由文件，可以修改route_config_file配置参数，例如： 12// 定义路由配置文件（数组）'route_config_file' =&gt; ['route', 'route1', 'route2'], 变量规则全局变量规则12345678// 设置name变量规则（采用正则定义）Route::pattern('name','\\w+');// 支持批量添加Route::pattern([ 'name' =&gt; '\\w+', 'id' =&gt; '\\d+',]); 局部变量规则局部变量规则，仅在当前路由有效： 12// 定义GET请求路由规则 并设置name变量规则Route::get('new/:name','News/read',[],['name'=&gt;'\\w+']); 如果一个变量同时定义了全局规则和局部规则，局部规则会覆盖全局变量的定义 完整URL规则如果要对整个URL进行规则检查，可以进行__url__ 变量规则，例如： 12// 定义GET请求路由规则 并设置完整URL变量规则Route::get('new/:id','News/read',[],['__url__'=&gt;'new\\/\\w+$']); 资源路由5.0支持设置RESTFul请求的资源路由，方式如下： 1Route::resource('blog','index/blog'); 或者在路由配置文件中使用__rest__添加资源路由定义： 123456789return [ // 定义资源路由 '__rest__'=&gt;[ // 指向index模块的blog控制器 'blog'=&gt;'index/blog', ], // 定义普通路由 'hello/:id'=&gt;'index/hello',] 设置后会自动注册7个路由规则，如下： 标识 请求类型 生成路由规则 对应操作 index GET blog index create GET blog/create create save POST blog save read GET blog/:id read edit GET blog/:id/edit edit update PUT blog/:id update delete DELETE blog/:id delete 也可以在定义资源路由的时候限定执行的方法（标识），例如： 1234// 只允许index read edit update 四个操作Route::resource('blog','index/blog',['only'=&gt;['index','read','edit','update']]);// 排除index和delete操作Route::resource('blog','index/blog',['except'=&gt;['index','delete']]); 如果需要更改某个资源路由标识的对应操作，可以使用下面方法: 1Route::rest('create', ['GET', '/add', 'add']); 设置之后，URL访问变为： 123http://serverName/blog/create变成http://serverName/blog/add 支持批量更改，如下： 12345Route::rest([ 'save' =&gt; ['POST', '', 'store'], 'update' =&gt; ['PUT', '/:id', 'save'], 'delete' =&gt; ['DELETE', '/:id', 'destory'],]); 快捷路由12// 给User控制器设置快捷路由Route::controller('user','index/User'); User控制器定义如下： 1234567891011121314151617181920212223namespace app\\index\\controller;class User &#123; public function getInfo() &#123; &#125; public function getPhone() &#123; &#125; public function postInfo() &#123; &#125; public function putInfo() &#123; &#125; public function deleteInfo() &#123; &#125;&#125; 我们可以通过下面的URL访问 12345get http://localhost/user/infoget http://localhost/user/phonepost http://localhost/user/infoput http://localhost/user/infodelete http://localhost/user/info 路由别名12// user 别名路由到 index/User 控制器Route::alias('user','index/User'); 如果在路由配置文件route.php中定义的话，使用： 12345return [ '__alias__' =&gt; [ 'user' =&gt; 'index/User', ],]; 闭包支持闭包定义的时候支持参数传递，例如： 123Route::get('hello/:name',function($name)&#123; return 'Hello,'.$name;&#125;); 绑定模型12345678910Route::rule('hello/:id','index/index/hello','GET',[ 'ext' =&gt; 'html', 'bind_model' =&gt; [ 'user' =&gt; function($param)&#123; $model = new \\app\\index\\model\\User; return $model-&gt;where($param)-&gt;find(); &#125; ],]); 闭包函数的参数就是当前请求的URL变量信息。 在控制器中可以通过下面的代码或者使用依赖注入获取： 1request()-&gt;user; 控制器渲染输出12345678910111213141516171819namespace app\\index\\controller;class Index&#123; public function hello() &#123; return 'hello world!'; &#125; public function json() &#123; return json_encode($data); &#125; public function read() &#123; return view(); &#125;&#125; 跳转和重定向1234567891011public function index()&#123; $User = new User; $result = $User-&gt;save($data); if ($result) &#123; $this-&gt;success('新增成功', 'User/list'); &#125; else &#123; $this-&gt;error('新增失败'); &#125;&#125; 跳转地址是可选的，success方法的默认跳转地址是$_SERVER[&quot;HTTP_REFERER&quot;]，error方法的默认跳转地址是javascript:history.back(-1);。 默认的等待时间都是3秒 success和error方法都可以对应的模板，默认的设置是两个方法对应的模板都是： 1THINK_PATH . 'tpl/dispatch_jump.tpl' 改变默认的模板： 1234//默认错误跳转对应的模板文件'dispatch_error_tmpl' =&gt; APP_PATH . 'tpl/dispatch_jump.tpl',//默认成功跳转对应的模板文件'dispatch_success_tmpl' =&gt; APP_PATH . 'tpl/dispatch_jump.tpl', 也可以使用项目内部的模板文件 1234//默认错误跳转对应的模板文件'dispatch_error_tmpl' =&gt; 'public/error',//默认成功跳转对应的模板文件'dispatch_success_tmpl' =&gt; 'public/success', 重定向1234567891011121314//重定向到News模块的Category操作$this-&gt;redirect('News/category', ['cate_id' =&gt; 2]);//重定向到指定的URL地址 并且使用302$this-&gt;redirect('http://thinkphp.cn/blog/2',302);// 通过session闪存数据传值$this-&gt;redirect('News/category', ['cate_id' =&gt; 2], 302, ['data' =&gt; 'hello'])// 记住当前的URL后跳转redirect('News/category')-&gt;remember();// 需要跳转到上次记住的URL的时候使用：redirect()-&gt;restore(); Rest控制器RESTFul方法定义1234567891011121314151617181920212223&lt;?phpnamespace app\\index\\controller;use think\\controller\\Rest;class Blog extends Rest&#123; public function rest() &#123; switch ($this-&gt;method)&#123; case 'get': // get请求处理代码 if ($this-&gt;type == 'html')&#123; &#125; elseif ($this-&gt;type == 'xml')&#123; &#125; break; case 'put': // put请求处理代码 break; case 'post': // post请求处理代码 break; &#125; &#125;&#125; 在Rest操作方法中，可以使用$this-&gt;type获取当前访问的资源类型，用$this-&gt;method获取当前的请求类型 RESTFul 输出使用Rest类提供的 response 方法1$this-&gt;response($data, 'json', 200); 使用 think\\Response 类1Response::create($data, 'json')-&gt;code(200); 使用助手函数1json($data, 200); $data为需要输出的数据，第二个参数为输出数据的http状态码 12345678// 输出 json 格式数据json($data, 200);// 输出 jsonp 格式数据jsonp($data, 200);// 输出 xml 格式数据xml($data, 200); 资源控制器资源控制器可以让你轻松的创建RESTFul资源控制器，可以通过命令行生成需要的资源控制器，例如： 12345// 生成index模块的Blog资源控制器php think make:controller index/Blog// 或者使用完整的命名空间生成php think make:controller app\\index\\controller\\Blog 然后你只需要为资源控制器注册一个资源路由： 1Route::resource('blog', 'index/Blog'); 设置后会自动注册7个路由规则，如下： 请求类型 生成路由规则 对应操作方法 GET blog index GET blog/create create POST blog save GET blog/:id read GET blog/:id/edit edit PUT blog/:id update DELETE blog/:id delete 请求请求信息如果要获取当前的请求信息，可以使用\\think\\Request类，除了下文中的： 1234$request = Request::instance();// 助手函数$request = request(); 获取URL信息12345678910111213141516171819202122232425262728293031$request = Request::instance();// 获取当前域名echo 'domain: ' . $request-&gt;domain() . '&lt;br/&gt;';// 获取当前入口文件echo 'file: ' . $request-&gt;baseFile() . '&lt;br/&gt;';// 获取当前URL地址 不含域名echo 'url: ' . $request-&gt;url() . '&lt;br/&gt;';// 获取包含域名的完整URL地址echo 'url with domain: ' . $request-&gt;url(true) . '&lt;br/&gt;';// 获取当前URL地址 不含QUERY_STRINGecho 'url without query: ' . $request-&gt;baseUrl() . '&lt;br/&gt;';// 获取URL访问的ROOT地址echo 'root:' . $request-&gt;root() . '&lt;br/&gt;';// 获取URL访问的ROOT地址echo 'root with domain: ' . $request-&gt;root(true) . '&lt;br/&gt;';// 获取URL地址中的PATH_INFO信息echo 'pathinfo: ' . $request-&gt;pathinfo() . '&lt;br/&gt;';// 获取URL地址中的PATH_INFO信息 不含后缀echo 'pathinfo: ' . $request-&gt;path() . '&lt;br/&gt;';// 获取URL地址中的后缀信息echo 'ext: ' . $request-&gt;ext() . '&lt;br/&gt;'; 设置/获取 模块/控制器/操作名称1234$request = Request::instance();echo \"当前模块名称是\" . $request-&gt;module();echo \"当前控制器名称是\" . $request-&gt;controller();echo \"当前操作名称是\" . $request-&gt;action(); 获取请求参数1234567891011$request = Request::instance();echo '请求方法：' . $request-&gt;method() . '&lt;br/&gt;';echo '资源类型：' . $request-&gt;type() . '&lt;br/&gt;';echo '访问ip地址：' . $request-&gt;ip() . '&lt;br/&gt;';echo '是否AJax请求：' . var_export($request-&gt;isAjax(), true) . '&lt;br/&gt;';echo '请求参数：';dump($request-&gt;param());echo '请求参数：仅包含name';dump($request-&gt;only(['name']));echo '请求参数：排除name';dump($request-&gt;except(['name'])); 获取路由和调度信息12345$request = Request::instance();echo '路由信息：';dump($request-&gt;route());echo '调度信息：';dump($request-&gt;dispatch()); 设置请求信息123$request = Request::instance();$request-&gt;root('index.php');$request-&gt;pathinfo('index/index/hello'); 输入变量可以通过Request对象完成全局输入变量的检测、获取和安全过滤，支持包括$_GET、$_POST、$_REQUEST、$_SERVER、$_SESSION、$_COOKIE、$_ENV等系统变量，以及文件上传信息 检测变量是否设置123456Request::instance()-&gt;has('id','get');Request::instance()-&gt;has('name','post');// 助手函数input('?get.id');input('?post.name'); 获取PARAM变量123456789101112131415// 获取当前请求的name变量Request::instance()-&gt;param('name');// 获取当前请求的所有变量（经过过滤）Request::instance()-&gt;param();// 获取当前请求的所有变量（原始数据）Request::instance()-&gt;param(false);// 获取当前请求的所有变量（包含上传文件）Request::instance()-&gt;param(true);// 助手函数input('param.name');input('param.');// 或者input('name');input(''); 获取GET变量123456789Request::instance()-&gt;get('id'); // 获取某个get变量Request::instance()-&gt;get('name'); // 获取get变量Request::instance()-&gt;get(); // 获取所有的get变量（经过过滤的数组）Request::instance()-&gt;get(false); // 获取所有的get变量（原始数组）// 助手函数input('get.id');input('get.name');input('get.'); 获取POST变量1234567Request::instance()-&gt;post('name'); // 获取某个post变量Request::instance()-&gt;post(); // 获取经过过滤的全部post变量Request::instance()-&gt;post(false); // 获取全部的post原始变量// 助手函数input('post.name');input('post.'); 。。。其他几个类似。。。 变量过滤12// 默认全局过滤方法 用逗号分隔多个'default_filter' =&gt; 'htmlspecialchars', 设置全局变量过滤方法： 1Request::instance()-&gt;filter('htmlspecialchars'); 支持设置多个过滤方法，例如： 1Request::instance()-&gt;filter(['strip_tags','htmlspecialchars']), 也可以在获取变量的时候添加过滤方法，例如： 123Request::instance()-&gt;get('name','','htmlspecialchars'); // 获取get变量 并用htmlspecialchars函数过滤Request::instance()-&gt;param('username','','strip_tags'); // 获取param变量 并用strip_tags函数过滤Request::instance()-&gt;post('name','','org\\Filter::safeHtml'); // 获取post变量 并用org\\Filter类的safeHtml方法过滤 获取部分变量123456789101112// 只获取当前请求的id和name变量Request::instance()-&gt;only('id,name');// 或者使用数组方式// 只获取当前请求的id和name变量Request::instance()-&gt;only(['id','name']);// 默认获取的是当前请求参数，如果需要获取其它类型的参数，可以使用第二个参数，例如// 只获取GET请求的id和name变量Request::instance()-&gt;only(['id','name'],'get');// 只获取POST请求的id和name变量Request::instance()-&gt;only(['id','name'],'post'); 排除部分变量1234567891011// 排除id和name变量Request::instance()-&gt;except('id,name');// 排除id和name变量Request::instance()-&gt;except(['id','name']);// 同样支持指定变量类型获取：// 排除GET请求的id和name变量Request::instance()-&gt;except(['id','name'],'get');// 排除POST请求的id和name变量Request::instance()-&gt;except(['id','name'],'post'); 请求类型123456789101112131415161718192021222324252627282930313233343536373839// 是否为 GET 请求if (Request::instance()-&gt;isGet()) echo \"当前为 GET 请求\";// 是否为 POST 请求if (Request::instance()-&gt;isPost()) echo \"当前为 POST 请求\";// 是否为 PUT 请求if (Request::instance()-&gt;isPut()) echo \"当前为 PUT 请求\";// 是否为 DELETE 请求if (Request::instance()-&gt;isDelete()) echo \"当前为 DELETE 请求\";// 是否为 Ajax 请求if (Request::instance()-&gt;isAjax()) echo \"当前为 Ajax 请求\";// 是否为 Pjax 请求if (Request::instance()-&gt;isPjax()) echo \"当前为 Pjax 请求\";// 是否为手机访问if (Request::instance()-&gt;isMobile()) echo \"当前为手机访问\";// 是否为 HEAD 请求if (Request::instance()-&gt;isHead()) echo \"当前为 HEAD 请求\";// 是否为 Patch 请求if (Request::instance()-&gt;isPatch()) echo \"当前为 PATCH 请求\";// 是否为 OPTIONS 请求if (Request::instance()-&gt;isOptions()) echo \"当前为 OPTIONS 请求\";// 是否为 cliif (Request::instance()-&gt;isCli()) echo \"当前为 cli\";// 是否为 cgiif (Request::instance()-&gt;isCgi()) echo \"当前为 cgi\";// 助手函数// 是否为 GET 请求if (request()-&gt;isGet()) echo \"当前为 GET 请求\"; 请求类型伪装支持请求类型伪装，可以在POST表单里面提交_method变量，传入需要伪装的请求类型，例如： 12345&lt;form method=\"post\" action=\"\"&gt; &lt;input type=\"text\" name=\"name\" value=\"Hello\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"PUT\" &gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; AJAX/PJAX伪装12345678http://localhost/index?_ajax=1 http://localhost/index?_pjax=1 // 改变伪装请求的变量名，可以修改应用配置文件：// 表单ajax伪装变量'var_ajax' =&gt; '_a',// 表单pjax伪装变量'var_pjax' =&gt; '_p', 方法注入如果你需要在Request请求对象中添加自己的方法，可以使用Request对象的方法注入功能，例如： 12// 通过hook方法注入动态方法Request::hook('user','getUserInfo'); getUserInfo函数定义如下 12345function getUserInfo(Request $request, $userId)&#123; // 根据$userId获取用户信息 return $info;&#125; 接下来，我们可以直接在控制器中使用： 1234public function index()&#123; $info = Request::instance()-&gt;user($userId);&#125; 属性注入1234// 动态绑定属性Request::instance()-&gt;bind('user',new User);// 或者使用Request::instance()-&gt;user = new User; 获取绑定的属性使用下面的方式： 1Request::instance()-&gt;user; 如果控制器注入请求对象的话，也可以直接使用 123$this-&gt;request-&gt;user;// 助手函数request-&gt;user; 依赖注入架构方法注入12345678910111213141516171819namespace app\\index\\controller;use think\\Request;class Index&#123; protected $request; public function __construct(Request $request) &#123; $this-&gt;request = $request; &#125; public function hello() &#123; return 'Hello,' . $this-&gt;request-&gt;param('name') . '！'; &#125; &#125; 操作方法注入12345678910111213namespace app\\index\\controller;use think\\Request;class Index&#123; public function hello(Request $request) &#123; return 'Hello,' . $request-&gt;param('name') . '！'; &#125; &#125; invoke方法自动调用123456789101112namespace app\\index\\model;use think\\Model;class User extends Model&#123; public static function invoke(Request $request) &#123; $id = $request-&gt;param('id'); return User::get($id); &#125;&#125; 数据库基本使用123456Db::query('select * from think_user where id=?',[8]);Db::execute('insert into think_user (id, name) values (?, ?)',[8,'thinkphp']);// 支持命名占位符绑定Db::query('select * from think_user where id=:id',['id'=&gt;8]);Db::execute('insert into think_user (id, name) values (:id, :name)',['id'=&gt;8,'name'=&gt;'thinkphp']); 查询构造器查询数据123456789101112131415161718192021222324252627282930313233343536373839// 查询一个数据使用：// table方法必须指定完整的数据表名Db::table('think_user')-&gt;where('id',1)-&gt;find();// find 方法查询结果不存在，返回 null// 查询数据集使用：Db::table('think_user')-&gt;where('status',1)-&gt;select();// 助手函数db('user')-&gt;where('id',1)-&gt;find();db('user')-&gt;where('status',1)-&gt;select();// 使用Query对象或闭包查询$query = new \\think\\db\\Query();$query-&gt;table('think_user')-&gt;where('status',1);Db::find($query);Db::select($query);// 使用闭包函数查询Db::select(function($query)&#123; $query-&gt;table('think_user')-&gt;where('status',1);&#125;);// 值和列查询// 返回某个字段的值Db::table('think_user')-&gt;where('id',1)-&gt;value('name');// 查询某一列的值可以用// 返回数组Db::table('think_user')-&gt;where('status',1)-&gt;column('name');// 指定索引Db::table('think_user')-&gt;where('status',1)-&gt;column('name','id');Db::table('think_user')-&gt;where('status',1)-&gt;column('id,name');// 同tp3的getField// JSON类型数据查询// 查询JSON类型字段 （info字段为json类型）Db::table('think_user')-&gt;where('info$.email','thinkphp@qq.com')-&gt;find(); 添加数据12$data = ['foo' =&gt; 'bar', 'bar' =&gt; 'foo'];Db::table('think_user')-&gt;insert($data); 如果你在database.php配置文件中配置了数据库前缀(prefix)，那么可以直接使用 Db 类的 name 方法提交数据 1Db::name('user')-&gt;insert($data); 添加数据后如果需要返回新增数据的自增主键，可以使用getLastInsID方法： 12345Db::name('user')-&gt;insert($data);$userId = Db::name('user')-&gt;getLastInsID();// 直接使用insertGetId方法新增数据并返回主键值：Db::name('user')-&gt;insertGetId($data); 添加多条数据123456$data = [ ['foo' =&gt; 'bar', 'bar' =&gt; 'foo'], ['foo' =&gt; 'bar1', 'bar' =&gt; 'foo1'], ['foo' =&gt; 'bar2', 'bar' =&gt; 'foo2']];Db::name('user')-&gt;insertAll($data); 助手函数12345// 添加单条数据db('user')-&gt;insert($data);// 添加多条数据db('user')-&gt;insertAll($list); 更新数据1234Db::table('think_user')-&gt;where('id', 1)-&gt;update(['name' =&gt; 'thinkphp']);// 如果数据中包含主键，可以直接使用：Db::table('think_user')-&gt;update(['name' =&gt; 'thinkphp','id'=&gt;1]); 如果要更新的数据需要使用SQL函数或者其它字段，可以使用下面的方式： 123456Db::table('think_user')-&gt;where('id', 1)-&gt;update([ 'login_time' =&gt; ['exp','now()'], 'login_times' =&gt; ['exp','login_times+1'],]); 更新某个字段的值：1Db::table('think_user')-&gt;where('id',1)-&gt;setField('name', 'thinkphp'); 自增或自减一个字段的值1234567891011// score 字段加 1Db::table('think_user')-&gt;where('id', 1)-&gt;setInc('score');// score 字段加 5Db::table('think_user')-&gt;where('id', 1)-&gt;setInc('score', 5);// score 字段减 1Db::table('think_user')-&gt;where('id', 1)-&gt;setDec('score');// score 字段减 5Db::table('think_user')-&gt;where('id', 1)-&gt;setDec('score', 5);// 延迟更新Db::table('think_user')-&gt;where('id', 1)-&gt;setInc('score', 1, 10); 助手函数12345678// 更新数据表中的数据db('user')-&gt;where('id',1)-&gt;update(['name' =&gt; 'thinkphp']);// 更新某个字段的值db('user')-&gt;where('id',1)-&gt;setField('name','thinkphp');// 自增 score 字段db('user')-&gt;where('id', 1)-&gt;setInc('score');// 自减 score 字段db('user')-&gt;where('id', 1)-&gt;setDec('score'); 链式操作方法123456Db::table('data') -&gt;where('id',1) -&gt;inc('read') -&gt;dec('score',3) -&gt;exp('name','UPPER(name)') -&gt;update(); 删除数据1234567// 根据主键删除Db::table('think_user')-&gt;delete(1);Db::table('think_user')-&gt;delete([1,2,3]);// 条件删除 Db::table('think_user')-&gt;where('id',1)-&gt;delete();Db::table('think_user')-&gt;where('id','&lt;',10)-&gt;delete(); delete 方法返回影响数据的条数，没有删除返回 0 助手函数1234// 根据主键删除db('user')-&gt;delete(1);// 条件删除 db('user')-&gt;where('id',1)-&gt;delete(); 查询方法1234Db::table('think_user') -&gt;where('name','like','%thinkphp') -&gt;whereOr('title','like','%thinkphp') -&gt;find(); 混合查询12345$result = Db::table('think_user')-&gt;where(function ($query) &#123;$query-&gt;where('id', 1)-&gt;whereor('id', 2);&#125;)-&gt;whereOr(function ($query) &#123; $query-&gt;where('name', 'like', 'think')-&gt;whereOr('name', 'like', 'thinkphp');&#125;)-&gt;select(); getTableInfo方法12345678// 获取`think_user`表所有信息Db::getTableInfo('think_user');// 获取`think_user`表所有字段Db::getTableInfo('think_user', 'fields');// 获取`think_user`表所有字段的类型Db::getTableInfo('think_user', 'type');// 获取`think_user`表的主键Db::getTableInfo('think_user', 'pk'); 链式操作1234Db::table('think_user') -&gt;where('status',1) -&gt;order('create_time') -&gt;limit(10) 时间查询使用where方法123456// 大于某个时间where('create_time','&gt; time','2016-1-1');// 小于某个时间where('create_time','&lt;= time','2016-1-1');// 时间区间查询where('create_time','between time',['2015-1-1','2016-1-1']); 使用whereTime方法12345678// 大于某个时间Db::table('think_user')-&gt;whereTime('birthday', '&gt;=', '1970-10-1')-&gt;select();// 小于某个时间Db::table('think_user')-&gt;whereTime('birthday', '&lt;', '2000-10-1')-&gt;select();// 时间区间查询Db::table('think_user')-&gt;whereTime('birthday', 'between', ['1970-10-1', '2000-10-1'])-&gt;select();// 不在某个时间区间Db::table('think_user')-&gt;whereTime('birthday', 'not between', ['1970-10-1', '2000-10-1'])-&gt;select(); 时间表达式12345678910111213141516// 获取今天的博客Db::table('think_blog') -&gt;whereTime('create_time', 'today')-&gt;select();// 获取昨天的博客Db::table('think_blog')-&gt;whereTime('create_time', 'yesterday')-&gt;select();// 获取本周的博客Db::table('think_blog')-&gt;whereTime('create_time', 'week')-&gt;select(); // 获取上周的博客Db::table('think_blog')-&gt;whereTime('create_time', 'last week')-&gt;select(); // 获取本月的博客Db::table('think_blog')-&gt;whereTime('create_time', 'month')-&gt;select(); // 获取上月的博客Db::table('think_blog')-&gt;whereTime('create_time', 'last month')-&gt;select(); // 获取今年的博客Db::table('think_blog')-&gt;whereTime('create_time', 'year')-&gt;select(); // 获取去年的博客Db::table('think_blog')-&gt;whereTime('create_time', 'last year')-&gt;select(); 如果查询当天、本周、本月和今年的时间，还可以简化为： 12345678// 获取今天的博客Db::table('think_blog')-&gt;whereTime('create_time', 'd')-&gt;select();// 获取本周的博客Db::table('think_blog')-&gt;whereTime('create_time', 'w')-&gt;select(); // 获取本月的博客Db::table('think_blog')-&gt;whereTime('create_time', 'm')-&gt;select(); // 获取今年的博客Db::table('think_blog')-&gt;whereTime('create_time', 'y') -&gt;select(); 12// 查询两个小时内的博客Db::table('think_blog')-&gt;whereTime('create_time','-2 hours')-&gt;select(); 快捷查询1234Db::table('think_user') -&gt;where('name|title','like','thinkphp%') -&gt;where('create_time&amp;update_time','&gt;',0) -&gt;find(); 区间查询1234Db::table('think_user') -&gt;where('name',['like','thinkphp%'],['like','%thinkphp']) -&gt;where('id',['&gt;',0],['&lt;&gt;',10],'or') -&gt;find(); 生成的SQL语句为： 1SELECT * FROM `think_user` WHERE ( `name` LIKE 'thinkphp%' AND `name` LIKE '%thinkphp' ) AND ( `id` &gt; 0 OR `id` &lt;&gt; 10 ) LIMIT 1 批量查询12345678Db::table('think_user') -&gt;where([ 'name' =&gt; ['like','thinkphp%'], 'title' =&gt; ['like','%thinkphp'], 'id' =&gt; ['&gt;',0], 'status'=&gt; 1 ]) -&gt;select(); 闭包查询1234Db::table('think_user')-&gt;select(function($query)&#123; $query-&gt;where('name','thinkphp') -&gt;whereOr('id','&gt;',10);&#125;); 使用Query对象查询123456$query = new \\think\\db\\Query;$query-&gt;name('user') -&gt;where('name','like','%think%') -&gt;where('id','&gt;',10) -&gt;limit(10);Db::select($query); 混合查询123456Db::table('think_user') -&gt;where('name',['like','thinkphp%'],['like','%thinkphp']) -&gt;where(function($query)&#123; $query-&gt;where('id',['&lt;',10],['&gt;',100],'or'); &#125;) -&gt;select(); V5.0.4+开始，ThinkPHP支持对同一个字段多次调用查询条件，例如： 123456Db::table('think_user') -&gt;where('name','like','%think%') -&gt;where('name','like','%php%') -&gt;where('id','in',[1,5,80,50]) -&gt;where('id','&gt;',10) -&gt;find(); 子查询1、使用select方法1234$subQuery = Db::table('think_user') -&gt;field('id,name') -&gt;where('id','&gt;',10) -&gt;select(false); 2、使用fetchSql方法12345$subQuery = Db::table('think_user') -&gt;field('id,name') -&gt;where('id','&gt;',10) -&gt;fetchSql(true) -&gt;select(); 3、使用buildSql构造子查询1234$subQuery = Db::table('think_user') -&gt;field('id,name') -&gt;where('id','&gt;',10) -&gt;buildSql(); 4、使用闭包构造子查询12345Db::table('think_user') -&gt;where('id','IN',function($query)&#123; $query-&gt;table('think_profile')-&gt;where('status',1)-&gt;field('id'); &#125;) -&gt;select(); 原生查询query方法1Db::query(\"select * from think_user where status=1\"); query方法用于执行SQL查询操作，如果数据非法或者查询错误则返回false，否则返回查询结果数据集（同select方法）。 execute方法1Db::execute(\"update think_user set name='thinkphp' where status=1\"); execute用于更新和写入数据的sql操作，如果数据非法或者查询错误则返回false ，否则返回影响的记录数。 事务操作使用事务处理的话，需要数据库引擎支持事务处理。比如 MySQL 的 MyISAM 不支持事务处理，需要使用 InnoDB 引擎。 自动控制事务处理: 1234Db::transaction(function()&#123; Db::table('think_user')-&gt;find(1); Db::table('think_user')-&gt;delete(1);&#125;); 手动控制事务: 1234567891011// 启动事务Db::startTrans();try&#123; Db::table('think_user')-&gt;find(1); Db::table('think_user')-&gt;delete(1); // 提交事务 Db::commit(); &#125; catch (\\Exception $e) &#123; // 回滚事务 Db::rollback();&#125; 监听SQL123456Db::listen(function($sql, $time, $explain)&#123; // 记录SQL echo $sql. ' ['.$time.'s]'; // 查看性能分析结果 dump($explain);&#125;); 分布式数据库1234567891011121314151617//分布式数据库配置定义return [ // 启用分布式数据库 'deploy' =&gt; 1, // 数据库类型 'type' =&gt; 'mysql', // 服务器地址 'hostname' =&gt; '192.168.1.1,192.168.1.2', // 数据库名 'database' =&gt; 'demo', // 数据库用户名 'username' =&gt; 'root', // 数据库密码 'password' =&gt; '', // 数据库连接端口 'hostport' =&gt; '',] 模型模型定义12345// 设置主键protected $pk = 'uid';// 设置当前模型对应的完整数据表名称protected $table = 'think_user'; 模型调用1234567891011121314151617// 静态调用$user = User::get(1);$user-&gt;name = 'thinkphp';$user-&gt;save();// 实例化模型$user = new User;$user-&gt;name= 'thinkphp';$user-&gt;save();// 使用 Loader 类实例化（单例）$user = Loader::model('User');// 或者使用助手函数`model`$user = model('User');$user-&gt;name= 'thinkphp';$user-&gt;save(); 模型初始化模型的初始化是重写Model的initialize 1234567//自定义初始化protected function initialize()&#123; //需要调用`Model`的`initialize`方法 parent::initialize(); //TODO:自定义的初始化&#125; 也可以使用静态init方法 12345//自定义初始化protected static function init()&#123; //TODO:自定义的初始化&#125; CURD新增1234567891011121314// 添加一条数据$user-&gt;save();// 过滤post数组中的非数据表字段数据$user-&gt;allowField(true)-&gt;save();// 获取自增IDecho $user-&gt;id;// 第二次开始必须使用下面的方式新增$user-&gt;isUpdate(false)-&gt;save();// 添加多条数据$user-&gt;saveAll($list); 助手函数1234567891011121314151617// 使用model助手函数实例化User模型$user = model('User');// 模型对象赋值$user-&gt;data([ 'name' =&gt; 'thinkphp', 'email' =&gt; 'thinkphp@qq.com']);$user-&gt;save();// 批量新增$user = model('User');$list = [ ['name'=&gt;'thinkphp','email'=&gt;'thinkphp@qq.com'], ['name'=&gt;'onethink','email'=&gt;'onethink@qq.com']];$user-&gt;saveAll($list); 更新123456$user = new User;// save方法第二个参数为更新条件$user-&gt;save([ 'name' =&gt; 'thinkphp', 'email' =&gt; 'thinkphp@qq.com'],['id' =&gt; 1]); 删除12345678910111213141516171819202122// 删除当前模型$user = User::get(1);$user-&gt;delete();// 根据主键删除User::destroy(1);// 支持批量删除多个数据User::destroy('1,2,3');// 或者User::destroy([1,2,3]);// 条件删除// 删除状态为0的数据User::destroy(['status' =&gt; 0]);// 使用闭包删除User::destroy(function($query)&#123; $query-&gt;where('id','&gt;',10);&#125;);// 通过数据库类的查询条件删除User::where('id','&gt;',10)-&gt;delete(); 查询查询单个数据123456789101112// 取出主键为1的数据$user = User::get(1);echo $user-&gt;name;// 使用数组查询$user = User::get(['name' =&gt; 'thinkphp']);// 使用闭包查询$user = User::get(function($query)&#123; $query-&gt;where('name', 'thinkphp');&#125;);echo $user-&gt;name; 1234$user = new User();// 查询单个数据$user-&gt;where('name', 'thinkphp') -&gt;find(); 获取多个数据12345678910111213141516// 根据主键获取多个数据$list = User::all('1,2,3');// 或者使用数组$list = User::all([1,2,3]);foreach($list as $key=&gt;$user)&#123; echo $user-&gt;name;&#125;// 使用数组查询$list = User::all(['status'=&gt;1]);// 使用闭包查询$list = User::all(function($query)&#123; $query-&gt;where('status', 1)-&gt;limit(3)-&gt;order('id', 'asc');&#125;);foreach($list as $key=&gt;$user)&#123; echo $user-&gt;name;&#125; 动态查询12345// 根据name字段查询用户$user = User::getByName('thinkphp');// 根据email字段查询用户$user = User::getByEmail('thinkphp@qq.com'); 查询缓存get方法和all方法的第三个参数表示是否使用查询缓存，或者设置缓存标识。 12$user = User::get(1,'',true);$list = User::all('1,2,3','',true); 修改器修改器的作用是可以在数据赋值的时候自动进行转换处理，例如： 1234567class User extends Model &#123; public function setNameAttr($value) &#123; return strtolower($value); &#125;&#125; 也可以进行序列化字段的组装： 1234567class User extends Model &#123; public function setNameAttr($value,$data) &#123; return serialize($data); &#125;&#125; 时间戳第一种方式，是在数据库配置文件中添加全局设置： 12// 开启自动写入时间戳字段'auto_timestamp' =&gt; true, 第二种是直接在单独的模型类里面设置： 1protected $autoWriteTimestamp = true; 如果这两个地方设置为true，默认识别为整型int类型，如果你的时间字段不是int类型的话，例如使用datetime类型的话，可以这样设置： 12345// 开启自动写入时间戳字段'auto_timestamp' =&gt; 'datetime',// 或者protected $autoWriteTimestamp = 'datetime'; 软删除12345678910namespace app\\index\\model;use think\\Model;use traits\\model\\SoftDelete;class User extends Model&#123; use SoftDelete; protected $deleteTime = 'delete_time';&#125; 123456789// 软删除User::destroy(1);// 真实删除User::destroy(1,true);$user = User::get(1);// 软删除$user-&gt;delete();// 真实删除$user-&gt;delete(true); 默认情况下查询的数据不包含软删除数据，如果需要包含软删除的数据，可以使用下面的方式查询： 123456User::withTrashed()-&gt;find();User::withTrashed()-&gt;select();// 只看软删除User::onlyTrashed()-&gt;find();User::onlyTrashed()-&gt;select(); JSON序列化12$user = User::get(1);echo $user-&gt;toJson(); 可以设置无需输出的字段，例如： 12$user = User::get(1);echo $user-&gt;hidden(['create_time','update_time'])-&gt;toJson(); 或者追加其它的字段： 12$user = User::get(1);echo $user-&gt;append(['status_text'])-&gt;toJson(); 设置允许输出的属性： 12$user = User::get(1);echo $user-&gt;visible(['id','name','email'])-&gt;toJson(); 模型对象可以直接被JSON序列化，例如：1echo json_encode(User::get(1)); 追加关联模型的属性12$user = User::find(1);echo $user-&gt;appendRelationAttr('profile',['email','nickname'])-&gt;toJson(); 关联一对一关联定义一对一关联，例如，一个用户都有一个个人资料，我们定义User模型如下： 1234567891011namespace app\\index\\model;use think\\Model;class User extends Model&#123; public function profile() &#123; return $this-&gt;hasOne('Profile'); &#125;&#125; hasOne方法的参数包括： hasOne(‘关联模型名’,’外键名’,’主键名’,[‘模型别名定义’],’join类型’); 定义相对的关联我们可以在Profile模型中定义一个相对的关联关系，例如： 1234567891011namespace app\\index\\model;use think\\Model;class Profile extends Model &#123; public function user() &#123; return $this-&gt;belongsTo('User'); &#125;&#125; belongsTo的参数包括： belongsTo(‘关联模型名’,’外键名’,’关联表主键名’,[‘模型别名定义’],’join类型’); 一对多关联使用hasMany方法定义: hasMany(‘关联模型名’,’外键名’,’主键名’,[‘模型别名定义’]); 12345678910111213&lt;?phpnamespace app\\index\\model;use think\\Model;class Article extends Model &#123; public function comments() &#123; return $this-&gt;hasMany('Comment'); &#125;&#125; 定义相对的关联12345678910111213&lt;?phpname app\\index\\model;use think\\Model;class Comment extends Model &#123; public function article() &#123; return $this-&gt;belongsTo('article'); &#125;&#125; 多对多关联例如，我们的用户和角色就是一种多对多的关系，我们在User模型定义如下 12345678910111213&lt;?phpnamespace app\\index\\model;use think\\Model;class User extends Model &#123; public function roles() &#123; return $this-&gt;belongsToMany('Role'); &#125;&#125; belongsToMany方法的参数如下： belongsToMany(‘关联模型名’,’中间表名’,’外键名’,’当前模型关联键名’,[‘模型别名定义’]); 定义相对的关联我们可以在Role模型中定义一个相对的关联关系，例如： 12345678910111213&lt;?phpnamespace app\\index\\model;use think\\Model;class Role extends Model &#123; public function users() &#123; return $this-&gt;belongsToMany('User'); &#125;&#125; 多态关联12345678910111213141516&lt;?phpnamespace app\\index\\model;use think\\Model;class Article extends Model&#123; /** * 获取所有针对文章的评论。 */ public function comments() &#123; return $this-&gt;morphMany('Comment', 'commentable'); &#125;&#125; morphMany方法的参数如下： morphMany(‘关联模型名’,’多态字段信息’,’多态类型’); 延迟预载入如果你的数据集查询返回的是数据集对象，可以使用调用数据集对象的load实现延迟预载入： 123456789// 查询数据集$list = User::all([1,2,3]);// 延迟预载入$list-&gt;load('cards');foreach($list as $user)&#123; // 获取用户关联的card模型数据 dump($user-&gt;cards);&#125; 如果你的数据集查询返回的是数组，系统提供了一个load_relation助手函数可以完成同样的功能。 123456789// 查询数据集$list = User::all([1,2,3]);// 延迟预载入$list = load_relation($list,'cards');foreach($list as $user)&#123; // 获取用户关联的card模型数据 dump($user-&gt;cards);&#125; 视图视图实例化12 // 渲染模板输出return $this-&gt;fetch('hello',['name'=&gt;'thinkphp']); 助手函数1return view('hello',['name'=&gt;'thinkphp']); 模板赋值assign方法123456789101112131415161718namespace index\\app\\controller;class Index extends \\think\\Controller&#123; public function index() &#123; // 模板变量赋值 $this-&gt;assign('name','ThinkPHP'); $this-&gt;assign('email','thinkphp@qq.com'); // 或者批量赋值 $this-&gt;assign([ 'name' =&gt; 'ThinkPHP', 'email' =&gt; 'thinkphp@qq.com' ]); // 模板输出 return $this-&gt;fetch('index'); &#125;&#125; 助手函数1234return view('index', [ 'name' =&gt; 'ThinkPHP', 'email' =&gt; 'thinkphp@qq.com']); share方法123think\\View::share('name','value');// 或者批量赋值think\\View::share(['name1'=&gt;'value','name2'=&gt;'value2']); 模板渲染1234567891011// 不带任何参数 自动定位当前操作的模板文件return $this-&gt;fetch();// 指定模板输出return $this-&gt;fetch('edit'); // 渲染完整模板return $this-&gt;fetch('./template/public/menu.html');// 渲染内容return $this-&gt;display($content,$vars); 日志日志写入由于系统在请求结束后会自动调用Log::save方法，所以通常，你只需要调用Log::record记录日志信息即可。 方法 描述 Log::record() 记录日志信息到内存 Log::save() 把保存在内存中的日志信息 Log::write 实时写入一条日志信息 1Log::record('测试日志信息'); 默认的话记录的日志级别是INFO，也可以指定日志级别： 1Log::record('测试日志信息，这是警告级别','notice'); 采用record方法记录的日志信息不是实时保存的，如果需要实时记录的话，可以采用write方法，例如 1Log::write('测试日志信息，这是警告级别，并且实时写入','notice'); 日志级别 log 常规日志，用于记录日志 error 错误，一般会导致程序的终止 notice 警告，程序可以运行但是还不够完美的错误 info 信息，程序输出信息 debug 调试，用于调试信息 sql SQL语句，用于SQL记录，只在数据库的调试模式开启时有效 助手函数12trace('错误信息','error');trace('日志信息','info'); 支持指定级别日志的输入，需要配置信息： 12345'log' =&gt; [ 'type' =&gt; 'File', // 日志记录级别，使用数组表示 'level' =&gt; ['error'],], 单文件日志12345'log' =&gt; [ 'type' =&gt; 'File', // 日志记录级别，使用数组表示 'single' =&gt; true,], 独立日志为了便于分析，File类型的日志驱动还支持设置某些级别的日志信息单独文件记录，例如： 12345'log' =&gt; [ 'type' =&gt; 'file', // error和sql日志单独记录 'apart_level' =&gt; ['error','sql'],], 日志清空1Log::clear(); 写入授权首先需要在应用配置文件或者应用公共文件中添加当前访问的授权Key定义，例如： 12// 设置IP为授权KeyLog::key(Request::instance()-&gt;ip()); 然后在日志配置参数中增加allow_key参数，如下： 123456'log' =&gt; [ // 日志类型为File 'type' =&gt; 'File', // 授权只有202.12.36.89 才能记录日志 'allow_key' =&gt; ['202.12.36.89'],] 错误和调试调试模式.env文件的定义格式如下： 1234// 设置开启调试模式app_debug = true// 其它的环境变量设置// ... 定义了.env文件后，配置文件中定义app_debug参数无效。 一旦关闭调试模式，发生错误后不会提示具体的错误信息，如果你仍然希望看到具体的错误信息，那么可以如下设置： 12// 显示错误信息'show_error_msg' =&gt; true, 异常处理12// 异常错误报错级别,error_reporting(E_ERROR | E_PARSE ); 部署模式异常12// 显示错误信息'show_error_msg' =&gt; true, 异常捕获123456try&#123; Db::name('user')-&gt;find(); $this-&gt;success('执行成功!');&#125;catch(\\Exception $e)&#123; $this-&gt;error('执行错误');&#125; 应该改成: 1234567try&#123; Db::name('user')-&gt;find();&#125; catch (\\Exception $e) &#123; $this-&gt;error('执行错误');&#125;$this-&gt;success('执行成功!'); 抛出异常手动抛出异常可以使用 \\think\\Exception 类来抛出异常 12// 使用think自带异常类抛出异常throw new \\think\\Exception('异常消息', 100006); 如果不使用think异常类，也可以定义自己的异常类来抛出异常 1throw new \\foobar\\Exception('异常消息'); 也可以使用系统提供的助手函数来简化处理： 1234exception('异常消息', 100006);// 使用自定义异常类exception('异常消息', 100006, \\foobar\\Exceeption); 抛出 HTTP 异常12// 抛出 HTTP 异常throw new \\think\\exception\\HttpException(404, '异常消息', null, [参数]); 助手函数1abort(404, '异常消息', [参数]) Trace 调试Trace调试功能就是ThinkPHP提供给开发人员的一个用于开发调试的辅助工具。可以实时显示当前页面的操作的请求信息、运行情况、SQL执行、错误提示等，并支持自定义显示，5.0版本的Trace调试支持没有页面输出的操作调试。 开启 Trace 调试12// 开启应用Trace调试'app_trace' =&gt; true, 页面Trace显示12345// Trace信息'trace' =&gt; [ //支持Html,Console 'type' =&gt; 'html',] 浏览器Trace显示12345// Trace信息'trace' =&gt;[ // 使用浏览器console输出trace信息 'type' =&gt; 'console',] 性能调试123456Debug::remark('begin');// ...其他代码段Debug::remark('end');// ...也许这里还有其他代码// 进行统计区间echo Debug::getRangeTime('begin','end').'s'; 助手函数12345678debug('begin');// ...其他代码段debug('end');// ...也许这里还有其他代码// 进行统计区间echo debug('begin','end').'s';echo debug('begin','end',6).'s';echo debug('begin','end','m').'kb'; SQL调试监听SQL123456Db::listen(function($sql,$time,$explain)&#123; // 记录SQL echo $sql. ' ['.$time.'s]'; // 查看性能分析结果 dump($explain);&#125;); 调试执行的SQL语句12User::get(1);echo User::getLastSql(); 也可以使用fetchSql方法直接返回当前的查询SQL而不执行，例如： 1echo User::fetchSql()-&gt;find(1); 远程调试Socket调试12345678'log' =&gt; [ 'type' =&gt; 'socket', 'host' =&gt; 'slog.thinkphp.cn', //日志强制记录到配置的client_id 'force_client_ids' =&gt; [], //限制允许读取日志的client_id 'allow_client_ids' =&gt; [],] 404页面一旦抛出了HttpException异常，可以支持定义单独的异常页面的模板地址，只需要在应用配置文件中增加： 123456'http_exception_template' =&gt; [ // 定义404错误的重定向页面地址 404 =&gt; APP_PATH.'404.html', // 还可以定义其它的HTTP status 401 =&gt; APP_PATH.'401.html',] 一般来说HTTP异常是由系统自动抛出的，但我们也可以手动抛出 1throw new \\think\\exception\\HttpException(404, '页面不存在'); 助手函数1abort(404,'页面不存在'); 验证验证器独立验证1234567891011$validate = new Validate([ 'name' =&gt; 'require|max:25', 'email' =&gt; 'email']);$data = [ 'name' =&gt; 'thinkphp', 'email' =&gt; 'thinkphp@qq.com'];if (!$validate-&gt;check($data)) &#123; dump($validate-&gt;getError());&#125; 验证器123456789101112namespace app\\index\\validate;use think\\Validate;class User extends Validate&#123; protected $rule = [ 'name' =&gt; 'require|max:25', 'email' =&gt; 'email', ];&#125; 12345678910$data = [ 'name'=&gt;'thinkphp', 'email'=&gt;'thinkphp@qq.com'];$validate = Loader::validate('User');if(!$validate-&gt;check($data))&#123; dump($validate-&gt;getError());&#125; 使用助手函数实例化验证器 1$validate = validate('User'); 验证规则12345678910111213141516171819202122$rule = [ 'name' =&gt; 'require|max:25', 'age' =&gt; 'number|between:1,120', 'email' =&gt; 'email',];$msg = [ 'name.require' =&gt; '名称必须', 'name.max' =&gt; '名称最多不能超过25个字符', 'age.number' =&gt; '年龄必须是数字', 'age.between' =&gt; '年龄只能在1-120之间', 'email' =&gt; '邮箱格式错误',];$data = [ 'name' =&gt; 'thinkphp', 'age' =&gt; 10, 'email' =&gt; 'thinkphp@qq.com',];$validate = new Validate($rule, $msg);$result = $validate-&gt;check($data); 自定义验证规则12345// 自定义验证规则protected function checkName($value,$rule,$data)&#123; return $rule == $value ? true : '名称错误';&#125; 控制器验证12345678910111213$result = $this-&gt;validate( [ 'name' =&gt; 'thinkphp', 'email' =&gt; 'thinkphp@qq.com', ], [ 'name' =&gt; 'require|max:25', 'email' =&gt; 'email', ]);if(true !== $result)&#123; // 验证失败 输出错误信息 dump($result);&#125; 如果定义了验证器类的话，例如： 123456789101112131415161718192021namespace app\\index\\validate;use think\\Validate;class User extends Validate&#123; protected $rule = [ 'name' =&gt; 'require|max:25', 'email' =&gt; 'email', ]; protected $message = [ 'name.require' =&gt; '用户名必须', 'email' =&gt; '邮箱格式错误', ]; protected $scene = [ 'add' =&gt; ['name','email'], 'edit' =&gt; ['email'], ];&#125; 控制器中的验证代码可以简化为： 12345$result = $this-&gt;validate($data,'User');if(true !== $result)&#123; // 验证失败 输出错误信息 dump($result);&#125; 模型验证12345678910111213141516$User = new User;$result = $User-&gt;validate( [ 'name' =&gt; 'require|max:25', 'email' =&gt; 'email', ], [ 'name.require' =&gt; '名称必须', 'name.max' =&gt; '名称最多不能超过25个字符', 'email' =&gt; '邮箱格式错误', ])-&gt;save($data);if(false === $result)&#123; // 验证失败 输出错误信息 dump($User-&gt;getError());&#125; 内置规则 https://www.kancloud.cn/manual/thinkphp5/129356 静态调用123456789101112// 日期格式验证Validate::dateFormat('2016-03-09','Y-m-d'); // true// 验证是否有效的日期Validate::is('2016-06-03','date'); // true// 验证是否有效邮箱地址Validate::is('thinkphp@qq.com','email'); // true// 验证是否在某个范围Validate::in('a',['a','b','c']); // true// 验证是否大于某个值Validate::gt(10,8); // true// 正则验证Validate::regex(100,'\\d+'); // true 杂项Session赋值1234// 赋值（当前作用域）Session::set('name','thinkphp');// 赋值think作用域Session::set('name','thinkphp','think'); 判断是否存在1234// 判断（当前作用域）是否赋值Session::has('name');// 判断think作用域下面是否赋值Session::has('name','think'); 取值1234// 取值（当前作用域）Session::get('name');// 取值think作用域Session::get('name','think'); 删除1234// 删除（当前作用域）Session::delete('name');// 删除think作用域下面的值Session::delete('name','think'); 指定作用域12// 指定当前作用域Session::prefix('think'); 取值并删除12// 取值并删除Session::pull('name'); 清空1234// 清除session（当前作用域）Session::clear();// 清除think作用域Session::clear('think'); 助手函数123456789101112131415161718192021222324252627282930// 初始化sessionsession([ 'prefix' =&gt; 'module', 'type' =&gt; '', 'auto_start' =&gt; true,]);// 赋值（当前作用域）session('name', 'thinkphp');// 赋值think作用域session('name', 'thinkphp', 'think');// 判断（当前作用域）是否赋值session('?name');// 取值（当前作用域）session('name');// 取值think作用域session('name', '', 'think');// 删除（当前作用域）session('name', null);// 清除session（当前作用域）session(null);// 清除think作用域session(null, 'think'); Cookie初始化1234// cookie初始化Cookie::init(['prefix'=&gt;'think_','expire'=&gt;3600,'path'=&gt;'/']);// 指定当前前缀Cookie::prefix('think_'); 设置123456// 设置Cookie 有效期为 3600秒Cookie::set('name','value',3600);// 设置cookie 前缀为think_Cookie::set('name','value',['prefix'=&gt;'think_','expire'=&gt;3600]);// 支持数组Cookie::set('name',[1,2,3]); 获取123Cookie::get('name');// 获取指定前缀的cookie值Cookie::get('name','think_'); 助手函数1234567891011121314// 初始化cookie(['prefix' =&gt; 'think_', 'expire' =&gt; 3600]);// 设置cookie('name', 'value', 3600);// 获取echo cookie('name');// 删除cookie('name', null);// 清除cookie(null, 'think_'); 上传假设表单代码如下： 1234&lt;form action=\"/index/index/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"image\" /&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"上传\" /&gt; &lt;/form&gt; 12345678910111213141516171819202122public function upload()&#123; // 获取表单上传文件 例如上传了001.jpg $file = request()-&gt;file('image'); // 移动到框架应用根目录/public/uploads/ 目录下 if($file)&#123; $info = $file-&gt;move(ROOT_PATH . 'public' . DS . 'uploads'); if($info)&#123; // 成功上传后 获取上传信息 // 输出 jpg echo $info-&gt;getExtension(); // 输出 20160820/42a79759f284b767dfcb2a0197904287.jpg echo $info-&gt;getSaveName(); // 输出 42a79759f284b767dfcb2a0197904287.jpg echo $info-&gt;getFilename(); &#125;else&#123; // 上传失败获取错误信息 echo $file-&gt;getError(); &#125; &#125;&#125; 多文件上传123456&lt;form action=\"/index/index/upload\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"image[]\" /&gt; &lt;br&gt; &lt;input type=\"file\" name=\"image[]\" /&gt; &lt;br&gt; &lt;input type=\"file\" name=\"image[]\" /&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"上传\" /&gt; &lt;/form&gt; 控制器代码可以改成： 12345678910111213141516171819public function upload()&#123; // 获取表单上传文件 $files = request()-&gt;file('image'); foreach($files as $file)&#123; // 移动到框架应用根目录/public/uploads/ 目录下 $info = $file-&gt;move(ROOT_PATH . 'public' . DS . 'uploads'); if($info)&#123; // 成功上传后 获取上传信息 // 输出 jpg echo $info-&gt;getExtension(); // 输出 42a79759f284b767dfcb2a0197904287.jpg echo $info-&gt;getFilename(); &#125;else&#123; // 上传失败获取错误信息 echo $file-&gt;getError(); &#125; &#125;&#125; 验证码首先使用Composer安装think-captcha扩展包： 1composer require topthink/think-captcha; 使用TP5的内置验证功能，添加captcha验证规则即可: 123$this-&gt;validate($data,[ 'captcha|验证码'=&gt;'require|captcha']); 或者手动验证 123if(!captcha_check($captcha))&#123; //验证失败&#125;; 验证码的自定义用法如果项目未开启路由，或者有实际需求可自行调用Captcha类操作 验证码的生成： 12$captcha = new Captcha();return $captcha-&gt;entry(); 验证码刷新 写个onclick=&quot;this.src=this.src+&#39;?&#39;&quot; 就行 扩展函数扩展系统函数 1234567891011// 增加一个新的table助手函数function table($table, $config = [])&#123; return \\think\\Db::connect($config)-&gt;setTable($table);&#125;// 替换已有的db助手函数function db($name, $config= [])&#123; return \\think\\Db::connect($config)-&gt;name($name); &#125; 驱动以缓存驱动为例，如果我们扩展了一个自己的redis驱动，类名为app\\driver\\cache\\Redis，那么我们只需要设置缓存类型为： 12345678'cache' =&gt; [ // 驱动方式 'type' =&gt; '\\app\\driver\\cache\\Redis', // 缓存前缀 'prefix' =&gt; '', // 缓存有效期 0表示永久缓存 'expire' =&gt; 0,] 命令行自动生成目录结构首先需要定义一个用于自动生成的规则定义文件，通常命名为 build.php 1234567891011121314return [ // 生成运行时目录 '__file__' =&gt; ['common.php'], // 定义index模块的自动生成 'index' =&gt; [ '__file__' =&gt; ['common.php'], '__dir__' =&gt; ['behavior', 'controller', 'model', 'view'], 'controller' =&gt; ['Index', 'Test', 'UserType'], 'model' =&gt; [], 'view' =&gt; ['index/index'], ], // 。。。 其他更多的模块定义]; __dir__ 表示生成目录（支持多级目录） __file__ 表示生成文件（不定义默认会生成 config.php 文件） controller 表示生成controller类 model表示生成model类 view表示生成html文件（支持子目录） 快速创建类库文件快速生成控制器类1php think make:controller index/Blog 快速生成模型类1php think make:model index/Blog 优化 生成类库映射文件optimize:autoload 1php think optimize:autoload 生成路由缓存optimize:route 1php think optimize:route 清除缓存文件clear 1php think clear 生成配置缓存optimize:config 1php think optimize:config 生成数据表字段缓存optimize:schema 1php think optimize:schema 附录配置参考预定义常量12EXT 类库文件后缀（.php）THINK_VERSION 框架版本号 路径常量1234567891011121314DS 当前系统的目录分隔符THINK_PATH 框架系统目录 ROOT_PATH 框架应用根目录APP_PATH 应用目录（默认为application）CONF_PATH 配置目录（默认为APP_PATH）LIB_PATH 系统类库目录（默认为 THINK_PATH.'library/'）CORE_PATH 系统核心类库目录 （默认为 LIB_PATH.'think/'）TRAIT_PATH 系统trait目录（默认为 LIB_PATH.'traits/'）EXTEND_PATH 扩展类库目录（默认为 ROOT_PATH . 'extend/')VENDOR_PATH 第三方类库目录（默认为 ROOT_PATH . 'vendor/'）RUNTIME_PATH 应用运行时目录（默认为 ROOT_PATH.'runtime/'）LOG_PATH 应用日志目录 （默认为 RUNTIME_PATH.'log/'）CACHE_PATH 项目模板缓存目录（默认为 RUNTIME_PATH.'cache/'）TEMP_PATH 应用缓存目录（默认为 RUNTIME_PATH.'temp/'） 系统常量12345IS_WIN 是否属于Windows 环境 IS_CLI 是否属于命令行模式 THINK_START_TIME 开始运行时间（时间戳）THINK_START_MEM 开始运行时候的内存占用ENV_PREFIX 环境变量配置前缀 参考 ThinkPHP5.0完全开发手册","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"ThinkPHP5","slug":"ThinkPHP5","permalink":"http://blog.caoxl.com/tags/ThinkPHP5/"}]},{"title":"十个 Laravel 5 程序优化技巧","slug":"Ten-Laravel-5-Program-Optimization-Techniques","date":"2018-03-05T03:31:01.000Z","updated":"2019-08-22T03:55:23.000Z","comments":true,"path":"2018/03/05/Ten-Laravel-5-Program-Optimization-Techniques/","link":"","permalink":"http://blog.caoxl.com/2018/03/05/Ten-Laravel-5-Program-Optimization-Techniques/","excerpt":"说明性能一直是 Laravel 框架为人诟病的一个点，所以调优 Laravel 程序算是一个必学的技能。 接下来分享一些开发的最佳实践，还有调优技巧。","text":"说明性能一直是 Laravel 框架为人诟病的一个点，所以调优 Laravel 程序算是一个必学的技能。 接下来分享一些开发的最佳实践，还有调优技巧。 这里是简单的列表： 配置信息缓存 artisan config:cache 路由缓存 artisan route:cache 类映射加载优化 artisan optimize 自动加载优化 composer dumpautoload 使用 Memcached 来存储会话 config/session.php 使用专业缓存驱动器 config/cache.php 数据库请求优化 为数据集书写缓存逻辑 使用即时编译器（JIT），如：HHVM、OpCache 前端资源合并 Elixir 1. 配置信息缓存使用以下 Artisan 自带命令，把 config文件夹里所有配置信息合并到一个文件里，减少运行时文件的载入数量： 1php artisan config:cache 上面命令会生成文件 bootstrap/cache/config.php，可以使用以下命令来取消配置信息缓存： 1php artisan config:clear 此命令做的事情就是把 bootstrap/cache/config.php 文件删除。 注意：配置信息缓存不会随着更新而自动重载，所以，开发时候建议关闭配置信息缓存，一般在生产环境中使用，可以配合 Envoy 任务运行器 一起使用。 2. 路由缓存路由缓存可以有效的提高路由器的注册效率，在大型应用程序中效果越加明显，可以使用以下命令： 1php artisan route:cache 以上命令会生成 bootstrap/cache/routes.php 文件，需要注意的是，路由缓存不支持路由匿名函数编写逻辑，详见：文档 - 路由缓存。 可以使用下面命令清除路由缓存： 1php artisan route:clear 此命令做的事情就是把 bootstrap/cache/routes.php 文件删除。 注意：配置信息缓存不会随着更新而自动重载，所以，开发时候建议关闭配置信息缓存，一般在生产环境中使用，可以配合 Envoy 任务运行器 一起使用。 3. 类映射加载优化optimize 命令把常用加载的类合并到一个文件里，通过减少文件的加载，来提高运行效率： 1php artisan optimize --force 会生成 bootstrap/cache/compiled.php 和 bootstrap/cache/services.json 两个文件。 你可以可以通过修改 config/compile.php 文件来添加要合并的类。 在 production 环境中，参数 --force 不需要指定，文件就会自动生成。 要清除类映射加载优化，请运行以下命令： 1php artisan clear-compiled 此命令会删除上面 optimize 生成的两个文件。 注意：此命令要运行在 php artisan config:cache 后，因为 optimize 命令是根据配置信息（如：config/app.php 文件的 providers 数组）来生成文件的。 4. 自动加载优化此命令不止针对于 Laravel 程序，适用于所有使用 composer 来构建的程序。此命令会把 PSR-0 和 PSR-4 转换为一个类映射表，来提高类的加载速度。 1composer dumpautoload -o 注意：php artisan optimize --force 命令里已经做了这个操作。 5. 使用 Memcached 来存储会话每一个 Laravel 的请求，都会产生会话，修改会话的存储方式能有效提高程序效率，会话的配置信息是 config/session.php，建议修改为 Memcached 或者 Redis 等专业的缓存软件： 1'driver' =&gt; 'memcached', 6. 使用专业缓存驱动器「缓存」是提高应用程序运行效率的法宝之一，默认缓存驱动是 file 文件缓存，建议切换到专业的缓存系统，如 Redis 或者 Memcached，不建议使用数据库缓存。 1'default' =&gt; 'redis', 7. 数据库请求优化数据库请求优化 数据关联模型读取时使用 延迟预加载 和 预加载 ； 使用 Laravel Debugbar 或者 Clockwork 留意每一个页面的总数据库请求数量； 这里的篇幅只写到与 Laravel 相关的，其他关于数据优化的内容，请自行查阅其他资料。 8. 为数据集书写缓存逻辑合理的使用 Laravel 提供的缓存层操作，把从数据库里面拿出来的数据集合进行缓存，减少数据库的压力，运行在内存上的专业缓存软件对数据的读取也远远快于数据库。 1234$posts = Cache::remember('index.posts', $minutes = 30, function()&#123; return Post::with('comments', 'tags', 'author', 'seo')-&gt;whereHidden(0)-&gt;get();&#125;); remember 甚至连数据关联模型也都一并缓存了，多么方便呀。 9. 使用即时编译器HHVM 和 OpCache 都能轻轻松松的让你的应用程序在不用做任何修改的情况下，直接提高 50% 或者更高的性能，PHPhub 之前做个一个实验，具体请见：使用 OpCache 提升 PHP 5.5+ 程序性能。 10. 前端资源合并作为优化的标准，一个页面只应该加载一个 CSS 和 一个 JS 文件，并且文件要能方便走 CDN，需要文件名随着修改而变化。 Laravel Elixir 提供了一套简便实用的方案，详细请见文档：Laravel Elixir 文档。 参考 十个 Laravel 5 程序优化技巧","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"优化","slug":"优化","permalink":"http://blog.caoxl.com/tags/优化/"}]},{"title":"知乎神回复 「用于自省」","slug":"zhihu-god-reply","date":"2018-03-05T01:37:17.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/03/05/zhihu-god-reply/","link":"","permalink":"http://blog.caoxl.com/2018/03/05/zhihu-god-reply/","excerpt":"本文转载自网络, 用于生活中自省。","text":"本文转载自网络, 用于生活中自省。 1、交朋友的标准是什么？ 答：出世的智者，入世的强者，或者正常而阳光的普通人。 2、男性更看重女性的身材、脸蛋，还是思想？ 答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。 3、“别让孩子输在起跑线上”有道理吗？ 答：一辈子都要和别人去比较，是人生悲剧的源头。 4、做哪些事情可以提升生活品质？ 答：定期扔东西。 5、结婚以后两个人在一起最重要的是什么？ 答：就当这婚还没结。 6、怎么反驳“你行你上啊”的逻辑？ 答：“我评论个电冰箱，自己还得会制冷啊？” 7、把学费拿来念书还是环游世界更合适？为什么？ 答：读书, 在没有充分的知识作为前提的情况下，即使行了万里路也不过是邮差而已。 8、为什么部分人会产生“聪明智慧的姑娘都被憨憨的小伙儿搞定了”的印象？ 答：严肃地说，我觉得，要么姑娘只是看起来聪明，要么小伙儿只是看起来憨…… 9、你心中的完美爱情是怎么样的？ 答：可以有不完美。 10、异国长期生活，改变了你的哪些“是非观”？ 答：很多事情只是不同，并无是非。 11、是不是一个人越成熟就越难爱上一个人？ 答：不是越成熟越难爱上一个人。是越成熟，越能分辨那是不是爱。 12、如何让这个世界变得美好？ 答：把你自己变得更美好。 13、苦难有什么价值？ 答：永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。 14、如何反驳“现实点，这个社会就是这样”？ 答：“你是怎样，你的世界就是怎样。” 15、你对自由的理解是什么？ 答：说“不”的能力。 16、怎么看待励志的书籍？ 答：看再多，那都是别人的人生。 17、同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？ 答：远的崇拜，近的嫉妒；够不着的崇拜，够得着的嫉妒；有利益冲突的嫉妒，没利益冲突的崇拜。 18、为什么当看到好照片时人们通常的反应是“真不错，你用的是什么相机”，当看到烂照片时，则往往笑话拍摄者水平很臭？ 答：人习惯性地将自己的成功归因于自身，失败归因于环境；而将他人的成功归因于环境，失败归因于其自身。 19、怎样在有效提出推荐或建议的同时，避免给人灌输和强迫的感觉？ 答：说服他人不要诉诸理性，应求于利益。 20、哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？ 答：夸奖他人。 21、你是如何走出人生的阴霾的？ 答：多走几步。 22、二十六岁，工作三年却将留学三年，值得吗？ 答：普通玩家选择标准配置，高端玩家选择自定义配置。 23、如何看待“年轻时就释怀与淡泊，是没有希望的”这句话？ 答：试图用一句话就来总结复杂的人生，是没有希望的。 24、要怎样努力，才能成为很厉害的人？ 答：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里；如果你注定不是厉害的人，那你便只需要做好你自己。 25、前半生与后半生的分界线是在哪里？ 答：此时此刻。 26、你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念？ 答：天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。 27、人这一生为什么要努力？ 答：最痛苦的事，不是失败，是我本可以。 28、在一个足够小的星球上行走，我们是在上坡还是下坡？ 答：你感觉累就是上坡，感觉轻松就是下坡。 29、听过最落寞的一句话或诗句是什么？ 答：不如意事常八九，可与言者无二三。 30、世界上有那么多好书好电影好动漫注定看不完，我们对这个事实该持何种态度？ 答：怕什么真理无穷，进一寸有一寸的欢喜。——胡适 31、三十岁才开始学习编程靠谱吗？ 答：种一棵树最好的时间是十年前，其次是现在。 32、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？ 答：也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。 33、省钱的好办法有哪些？ 答：在买任何东西之前牢记九字箴言：你喜欢，你需要，你适合。PS：适用于很多事，包括感情也一样。 34、王阳明的“知行合一”到底如何理解？又怎样运用到实际生活中？ 答：知道做不到，等于不知道。 35、什么叫见过大世面？ 答：能享受最好的，能承受最坏的。 36、科学和迷信的分界点是哪里？ 答：我错了。 37、扎克伯格初期是怎么保护 Facebook 的最初创意？为什么Facebook 上线后没被其他大公司抄走？ 答：保护创意的最好方法，就是将其最好地执行。 38、员工辞职最主要的原因是什么？ 答：钱少事多离家远，位低权轻责任重。 39、你在生活中得到过的最好的建议是什么？ 答：“过度自我关注是万恶之源”、“永远不要为尚未发生的事儿拧巴”、“觉得为时已晚的时候，恰恰是最早的时候”。 40、哪些行为是浪费时间？ 答：思而不学+犹豫不决。 41、最能燃起你学习激情的一句话是什么？ 答：你不能把这个世界，让给你所鄙视的人。 42、如果好人没好报，我们为什么还要做好人？ 答：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔 43、恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办？ 答：所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。 44、为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、开饭馆、摆街边早餐小吃摊等“短平快”项目？ 答：“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”——龙应台 45、情商不高的例子有哪些？ 答：对陌生人毕恭毕敬，对亲近的人随意发怒…… 46、如何看待“年轻的时候需要的是朋友而不是人脉”？ 答：没有目的之交往，才能感动人。 47、有哪些道理是你读了不信，听不进去，直到你亲身经历方笃信不疑的？ 答：不要低估你的能力，不要高估你的毅力。 48、有哪些我们熟知的名言其实还有后半句？ 答：“人是生而自由的”，下一句是：“但无往不在枷锁之中”，再下一句是：“自以为是其他一切主人的人，反而比其他一切更是奴隶。”","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"知乎， 知乎","slug":"知乎，-知乎","permalink":"http://blog.caoxl.com/tags/知乎，-知乎/"}]},{"title":"Laravel/Lumen 安装器","slug":"Use-Laravel-Lumen-Installer","date":"2018-03-01T07:00:27.000Z","updated":"2019-08-22T03:55:29.000Z","comments":true,"path":"2018/03/01/Use-Laravel-Lumen-Installer/","link":"","permalink":"http://blog.caoxl.com/2018/03/01/Use-Laravel-Lumen-Installer/","excerpt":"Laravel and Lumen 快捷安装","text":"Laravel and Lumen 快捷安装 Laravel123composer global require \"laravel/installer=~1.1\"laravel new sites Lumen123456composer global require \"laravel/lumen-installer\"# orcomposer require laravel/lumen-installerlumen new sites 在Linux下全局使用 安装完laravel安装器后 设置laravel 的环境变量 这样 就可以 实现 laravel new 项目名 全局可用 1vi /etc/profile.d/laravel.sh 1export PATH=$PATH:/root/.config/composer/vendor/bin/ Lumen 相同 FAQ sh: command not found laravel or lumen 1export PATH=\"~/.composer/vendor/bin:$PATH\" vim ~/.zshrc 123alias laravel='~/.composer/vendor/bin/laravel' source ~/.zshrc 关闭终端输入 laravel new sites","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"}]},{"title":"Mac配置IP域名映射","slug":"Config-Domain-name-In-Mac","date":"2018-03-01T02:23:28.000Z","updated":"2019-08-22T06:23:46.000Z","comments":true,"path":"2018/03/01/Config-Domain-name-In-Mac/","link":"","permalink":"http://blog.caoxl.com/2018/03/01/Config-Domain-name-In-Mac/","excerpt":"使用Mac开发需要知道的一些小知识。","text":"使用Mac开发需要知道的一些小知识。 本地开发hosts文件修改： 1. 在应用程序里面打开终端(terminal) 2. 输入 sudo vi /etc/hosts 3. 接着输入 i 进入编辑模式 4. 将添加的域名,ip拷贝进去，我随便取了个域名：127.0.0.1 test.dev 5. 编辑完成之后,按esc,输入 &quot;: wq&quot; 可能有些朋友碰到hosts为只读，不能修改，解决方法如下： 1. 打开finder, 快捷键：shift+command+g 前往文件夹 “/etc” 2. 找到hosts文件托到桌面修改，再把/etc下源文件删除，把桌面修改好的拖进/etc。 最后在终端：ping test.dev ,如果能ping通到127.0.0.1，说明映射成功","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.caoxl.com/tags/Mac/"}]},{"title":"修改Sublime Text 图标","slug":"How-to-change-SublimeText-Icon","date":"2018-02-27T06:59:33.000Z","updated":"2019-08-22T03:27:50.000Z","comments":true,"path":"2018/02/27/How-to-change-SublimeText-Icon/","link":"","permalink":"http://blog.caoxl.com/2018/02/27/How-to-change-SublimeText-Icon/","excerpt":"看 Sublime Text 的应用程序图标不爽已经很久了，偶然看到一篇如何替换 App 图标的方法，便动手改了下，记录操作过程如下。","text":"看 Sublime Text 的应用程序图标不爽已经很久了，偶然看到一篇如何替换 App 图标的方法，便动手改了下，记录操作过程如下。 操作步骤下载新图标下载一个图标，推荐 Dribbble 最好就是 .icns的文件 打开图标文件夹可以执行以下命令： 1open /Applications/Sublime\\ Text.app/Contents/Resources/ 替换图标将下载的图标文件替换掉 Sublime Text.icns 文件 更新图标此时，因为缓存的原因，替换重新打开 Sublime Text App 后可能未即时生效，可执行以下命令强制刷新图标： 12touch /Applications/Sublime\\ Text.apptouch /Applications/Sublime\\ Text.app/Contents/Info.plist 重启即可看到新图标了。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/tags/开发工具/"},{"name":"Sublime","slug":"Sublime","permalink":"http://blog.caoxl.com/tags/Sublime/"}]},{"title":"Hexo 更换电脑后怎么继续使用博客","slug":"How-to-transfer-Hexo-ToMacBook","date":"2018-02-26T02:30:55.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/26/How-to-transfer-Hexo-ToMacBook/","link":"","permalink":"http://blog.caoxl.com/2018/02/26/How-to-transfer-Hexo-ToMacBook/","excerpt":"近期需要将Windows上的东西转移到Mac。 需要在mac上继续使用Hexo博客","text":"近期需要将Windows上的东西转移到Mac。 需要在mac上继续使用Hexo博客 将你原来电脑上已经配置好并生成的hexo目录拷到你的新电脑上，注意无需拷全部，只拷如下几个目录： 12345_config.ymlpackage.jsonscaffolds/source/themes/ 将这些目录放到一个目录下，如：hexo／ 在你的新电脑上首先配置hexo环境: 安装Node.js 安装hexo，执行命令： 1234npm install -g hexo// 仅到当前目录npm install hexo 安装好之后，进入hexo／目录 模块安装，执行命令: 1234npm installnpm install hexo-deployer-git --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --save 部署，执行命令: 1hexo g &amp;&amp; hexo d","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/tags/Hexo/"}]},{"title":"Laravel 执行流程","slug":"Laravel-Startup-Process-Notes","date":"2018-02-23T02:47:55.000Z","updated":"2019-08-22T03:55:34.000Z","comments":true,"path":"2018/02/23/Laravel-Startup-Process-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/02/23/Laravel-Startup-Process-Notes/","excerpt":"分析Laravel执行流程.","text":"分析Laravel执行流程. 一、自动加载定位 从 public/index.php 定位到 bootstrap/autoload.php 从 bootstrap/autoload.php 定位到 _vendor/autoload.php 从 vendor/autoload.php 定位到 __DIR__ . &#39;/composer&#39; . &#39;/autoload_real.php&#39;; 定位完毕, 你会看到这样的代码: 1return ComposerAutoloaderInitda859f5bf8329e41e463c784e73d3cdf::getLoader(); ComposerAutoloaderInitda859f5bf8329e41e463c784e73d3cdf 简称本类 那我们就从 getLoader() 方法入手。 getLoader()文件位于： __DIR__ . &#39;/composer&#39; . &#39;/autoload_real.php&#39;; 逻辑顺序： 一、如果静态变量 $loader 不为空则返回 $loader, 123if (null !== self::$loader) &#123; return self::$loader;&#125; 二、注册一个自动加载程序，加载程序为本类的 loadClassLoader() 方法, 123spl_autoload_register(array('ComposerAutoloaderInitda859f5bf8329e41e463c784e73d3cdf', 'loadClassLoader'), true, true);self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); [loadClassLoader 方法逻辑] 123456public static function loadClassLoader($class)&#123; if ('Composer\\Autoload\\ClassLoader' === $class) &#123; require __DIR__ . '/ClassLoader.php'; &#125;&#125; 静态方法，含有一个 $class 参数，判断如果 $class 等于 Composer\\Autoload\\ClassLoader，则载入当前目录下 的 ClassLoader.php 文件，实际上是在为这句代码工作： 1self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader(); 三、$loader 得到 ClassLoader 类（\\Composer\\Autoload\\ClassLoader）的一个实例，卸载自动加载程序 loadClassLoader， 123self::$loader = $loader = new \\Composer\\Autoload\\ClassLoader();spl_autoload_unregister(array('ComposerAutoloaderInit022a3829915a6a8f070076dbcb34819c', 'loadClassLoader')); 四、载入路径信息，设置路径信息， 五、载入一些 autoload_x.php 形式的文件， 分别有: autoload_namespaces.php autoload_psr4.php autoload_classmap.php 并进行各自的循环 set 操作，如 12345$loader-&gt;set($namespace, $path);$loader-&gt;setPsr4($namespace, $path);$loader-&gt;addClassMap($classMap); 【set 函数】2个参数，一个前缀，一个路径。如果前缀非真，将 paths 转为数组类型赋值给类成员变量fallbackDirsPsr0，如果前缀为真，则将路径赋值给 $this-&gt;prefixesPsr0[$prefix[0]][$prefix] ，这个写法的意思等同于字母索引，比如 phpDocumentor ，则数组就图所示： 六、执行一个 $loader-&gt;register(true);, [register 方法逻辑] 1$loader-&gt;register(true); 一个布尔值参数，将传给 spl_autoload_register 第三个参数中。 而自动加载程序为：array($this, &#39;loadClass&#39;)，也就是本类的 loadClass() 方法。 [loadClass 方法逻辑] 12345678public function loadClass($class)&#123; if ($file = $this-&gt;findFile($class)) &#123; includeFile($file); return true; &#125;&#125; 一个 $class 参数，用了 findFile() 方法判断文件是否存在，存在则调用函数 includeFile() 载入文件 1234function includeFile($file)&#123; include $file;&#125; 七、还载入了一个autoload_files.php，而里面也是一组文件数组，貌似预加载一些函数库文件吧，没有继续深入这里了。 verdor/composer/autoload_files.php 12345if ($useStaticLoader) &#123; $includeFiles = Composer\\Autoload\\ComposerStaticInit022a3829915a6a8f070076dbcb34819c::$files;&#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php';&#125; 八、最后返回一个 $loader 变量，也就是 ClassLoader 类的实例。 12345foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire022a3829915a6a8f070076dbcb34819c($fileIdentifier, $file);&#125;return $loader; 12345678function composerRequire022a3829915a6a8f070076dbcb34819c($fileIdentifier, $file)&#123; if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) &#123; require $file; $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true; &#125;&#125; 好了，现在看看 $loader 这个实例到此拥有些什么？部分截图所示： 可以看出类属性包含了具有字母索引的一些命名空间，文件路径等信息。这和刚才载入那几个文件进行 set 操作有关，想起来了吗？ 到此 getLoader() 方法逻辑结束。 总结实现自动化的关键代码是 vendor/autoload.php 的 ::getLoader() 静态方法， 利用此方法内部的 $loader-&gt;register(true); 方法注册自动化载入方法，这样，当 new 对象的时候自动触发 loadClass() 了，而上面提到的 set 一些路径信息，正是自动化的必备条. 如有兴趣可以自行查看 vendor/composer/ClassLoader.php 的 loadClass() 方法代码细节。 上面如果没懂的，请打开文件代码，跟着慢慢走，慢慢看，一定能懂。 再返回到 vendor/autoload.php，再把 return $loader 返回到上一层。 即 bootstrap/autoload.php， 这行的代码 require __DIR__.&#39;/../vendor/autoload.php‘; 我们 var_dump() 下 require 的返回值，和刚才 $loader 的部分截图完全一致。 其实有从 aotuload_real.php 文件开始，我尝试过删除 return，也没有任何报错，不知道这里的 return 意义为何 再看 index.php 定位到了 bootstrap/app.php 打开就看到第一个 123$app = new Illuminate\\Foundation\\Application( realpath(__DIR__.'/../')); 下面来详细介绍: Container 类定位 来到 bootstrap/app.php 发现一段英文注释: 12345678910/*|--------------------------------------------------------------------------| Create The Application|--------------------------------------------------------------------------|| The first thing we will do is create a new Laravel application instance| which serves as the \"glue\" for all the components of Laravel, and is| the IoC container for the system binding all of the various parts.|*/ 翻译过来: 12345678910/ *| --------------------------------------------------------------------------|创建应用程序| --------------------------------------------------------------------------||我们首先要做的是创建一个新的 laravel 应用实例|作为“胶水”用于 laravel 的所有组件，并|为系统结合各种零件的 IOC 容器。|* / 换句话说，把这个对象实例作为一个可依靠稳固的地基，来存放各种“建筑物（组件）”，So 地基= IOC 容器？ 好复杂有木有，不管它了，读代码去吧，读代码就像聊天，得用心倾听别人的心声。 紧接着 new 了一个对象。 123$app = new Illuminate\\Foundation\\Application( realpath(__DIR__.'/../')); new Illuminate\\Foundation\\Application() 构造函数做了什么？ Application 类还传入了当前 laravel 根目录的地址这样一个参数。如 “D:\\webSite\\Laravel” 123456789101112public function __construct($basePath = null)&#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases();&#125; 命名空间 Illuminate 的具体文件路径位于 Vendor/laravel/framework/src/Illuminate。 打开文件: Vendor/laravel/framework/src/Illuminate/Application.php 到这里: class Application extends Container implements ApplicationContract, HttpKernelInterface 继承 Container 类，对应上面的use：use Illuminate\\Container\\Container; 并且要实现2个接口: ApplicationContract，HttpKernelInterface 咱们先看看这个 Container 类到底是什么。 怎么找具体文件上面已经说过了，下面就直接略过，直接打开 Container.php。 Container 类 Vendor/laravel/framework/src/Illuminate/Container/Container.php The ArrayAccess interface 数据访问接口，PHP5的一个新接口，接口提供访问对象数组。 1class Container implements ArrayAccess, ContainerContract 需要实现四个方法: abstract public boolean offsetExists ( mixed $offset ) abstract public mixed offsetGet ( mixed $offset ) abstract public void offsetSet ( mixed $offset , mixed $value ) abstract public void offsetUnset ( mixed $offset ) 先不用懂这4个方法是什么意思，看看 Container 类怎么实现的就懂了。 offsetExists1234public function offsetExists($key)&#123; return $this-&gt;bound($key);&#125; 123456public function bound($abstract)&#123; return isset($this-&gt;bindings[$abstract]) || isset($this-&gt;instances[$abstract]) || $this-&gt;isAlias($abstract);&#125; 当外部使用 isset() 函数时触发此方法，而方法内部则也是使用一个 isset 来判断返回一个 bool 值。这个 bindings 先不管，我们主要知道这个方法做了什么事情。 offsetGet1234public function offsetGet($key)&#123; return $this-&gt;make($key);&#125; 当外部尝试获取 $key 的时候，如 echo ,print_r,var_dump，赋值等。 就会触发此方法，而方法内部也是直接一个 reutrn，简单！ offsetSet123456public function offsetSet($key, $value)&#123; $this-&gt;bind($key, $value instanceof Closure ? $value : function () use ($value) &#123; return $value; &#125;);&#125; 当外部尝试赋值的时候，则触发此方法。 此方法内部先进行一个 instanceof 判断 如果 value 参数不是一个闭包，则将 $value 封装成一个闭包，而闭包函数的内部直接一个 return。 offsetUnset1234public function offsetUnset($key)&#123; unset($this-&gt;bindings[$key], $this-&gt;instances[$key], $this-&gt;resolved[$key]);&#125; 当外部尝试使用 unset 函数的时候触发此方法， 方法内部是一个 unset 函数，那些变量看不懂，先不管。 这就是 ArrayAccess，一个类实现它的4个方法，在不同操作时触发4个方法，知道这些就够了，具体调用的示例这里我没有举出来，PHP 官网有，请自行翻阅,锻炼下动手能力。 好吧继续往下看; ReflectionMethod 针对类方法 ReflectionFunction 针对普通函数 ReflectionParameter 针对函数的参数 具体代码演示如下： 12345678910111213141516171819202122232425262728293031/* ReflectionMethod 示例$a = new ReflectionMethod('index\\index','a');var_dump($a-&gt;isAbstract()); //false*//* ReflectionParameter 示例$a = new ReflectionParameter('index\\b',2);var_dump($a-&gt;getName()); //string(1) \"d\"*//* ReflectionFunction 示例$a = new ReflectionFunction('index\\b');var_dump($a-&gt;getParameters());array(3) &#123; [0]=&gt; &amp;object(ReflectionParameter)#2 (1) &#123; [\"name\"]=&gt; string(1) \"b\" &#125; [1]=&gt; &amp;object(ReflectionParameter)#3 (1) &#123; [\"name\"]=&gt; string(1) \"c\" &#125; [2]=&gt; &amp;object(ReflectionParameter)#4 (1) &#123; [\"name\"]=&gt; string(1) \"d\" &#125;&#125;*/ 然后看到 Container 类还实现这个接口 ContainerContract。 对应 use Illuminate\\Contracts\\Container\\Container as ContainerContract; 提示：Contracts 翻译 “合同、契约”。 接口里面的方法有兴趣可自行查看，我们主要看 Container 的实现这些方法的细节。 最后我们简述下 Contracts 作为本章结束语： 我的理解是一系列组件服务的接口集合 探索 Application 构造函数定位 OK，从入口地址 public/index.php 看到如下代码： 12345678910111213/*|--------------------------------------------------------------------------| Turn On The Lights|--------------------------------------------------------------------------|| We need to illuminate PHP development, so let us turn on the lights.| This bootstraps the framework and gets it ready for use, then it| will load up this application so that we can run it and send| the responses back to the browser and delight our users.|*/$app = require_once __DIR__.'/../bootstrap/app.php'; 翻译: 注释很有趣，翻译凑合看吧。 则现在我们打开 bootstarp/app.php 文件，因为这是 $app 这个玩意儿的出生地。 1234567891011121314/*|--------------------------------------------------------------------------| Create The Application|--------------------------------------------------------------------------|| The first thing we will do is create a new Laravel application instance| which serves as the \"glue\" for all the components of Laravel, and is| the IoC container for the system binding all of the various parts.|*/$app = new Illuminate\\Foundation\\Application( realpath(__DIR__.'/../')); 翻译: Application.php咱们就从在这里摸索一下构造函数里面发生了什么，打开 Application.php 文件。 打开的 Application.php 是位于 vendor/laravel/framework/src/Illuminate/Foundation/Application.php，而命名空间是 Illuminate\\Foundation Application类的构造函数如下： 123456789101112public function __construct($basePath = null)&#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases();&#125; 因为代码量真的很多，如果每一点都要说，不仅会看得云里雾里，还不一定能理解，所以，我这里以总结的方式概述，特别值得学习的地方再单独提出来说。 一、registerBaseBindings() 注册一些基本的绑定到容器中。 简单点说，此方法内部进行3次赋值，赋值后的变量及变量内容形式如下： static::setInstance($this); $this-&gt;instance(&#39;app&#39;, $this); $this-&gt;instance(Container::class, $this); 借鉴: 12345Container::$instance = $this$this-&gt;instances['app'] = $this$this-&gt;instances['Illuminate\\Container\\Container'] = $this 变量名具体含义: $this，也就是 Application 类。 static::setInstance，之前说过 Application 是 Container 的子类，而 $instance 静态变量是在 Container 类中已经定义好的,： Application.php 123class Application extends Container implements ApplicationContract, HttpKernelInterface&#123;&#125; Container.php 1234class Container implements ArrayAccess, ContainerContract&#123; protected static $instance;&#125; $this-&gt;instances，也是在Container 中定义的，含义为存放容器的共享实例, 123456/** * The container's shared instances. * * @var array */protected $instances = []; 你可以在 registerBaseBindings 方法的最后面打印如下3个变量进行检测，得到的都是 application object， 123456789101112131415protected function registerBaseBindings()&#123; static::setInstance($this); $this-&gt;instance('app', $this); $this-&gt;instance(Container::class, $this); $this-&gt;instance(PackageManifest::class, new PackageManifest( new Filesystem, $this-&gt;basePath(), $this-&gt;getCachedPackagesPath() )); print_r(static::$instance);die; print_r($this-&gt;instances);die;&#125; 到此，所谓的基本绑定结束，还是云里雾里的，英文不好只能看代码了，反正你记住父类的2个成员属性已经得到了 application 对象。 二、registerBaseServiceProviders() 注册所有的基础服务提供商。 好吧，第二章提过的 ioc 容器=地基，开始买材料准备施工，找几个最基础的供应商商来进行合作，搞水泥的啊，砌砖的啊，以后有更多的需求，根据自己的需求在去找供应商谈。Laravel 现在注册了3个提供商，一个事件，一个是路由, 一个日志。 12345678protected function registerBaseServiceProviders()&#123; $this-&gt;register(new EventServiceProvider($this)); $this-&gt;register(new LogServiceProvider($this)); $this-&gt;register(new RoutingServiceProvider($this));&#125; 我们先意淫一下大概的意思，找到了供应商，准备合作签合同( register )，先和搞水泥的签( event )，在和砌砖的签( routing )，和谁签？I’m the boss( $this )。 既然我是老板，合同条款肯定得看清楚了，咱们去看看合同先( register方法 ) 嗯！合同说的很清楚，首先确定我和供应商是否签过合同了，签过了( getProvider() 来判断)就滚蛋，浪费时间；虽然我是老板，但不是法人，你打个电话叫他过来，名字叫狗蛋（resolveProvider 方法，如果 $provider 为 string 类型，则根据提供的类名帮供应商实例化并 return），如: 1234public function resolveProvider($provider)&#123; return new $provider($this);&#125; OK，差不多，狗蛋把字一签( $provider-&gt;register() )，供应商算是正式入驻施工团队了，当然了，合同还说明以后要是有其他要改的地方，直接填一份声明即可，$options 是 register方法 的第二个参数。 12345678910111213141516171819202122232425262728public function register($provider, $options = [], $force = false)&#123; if (($registered = $this-&gt;getProvider($provider)) &amp;&amp; ! $force) &#123; return $registered; &#125; // If the given \"provider\" is a string, we will resolve it, passing in the // application instance automatically for the developer. This is simply // a more convenient way of specifying your service provider classes. if (is_string($provider)) &#123; $provider = $this-&gt;resolveProvider($provider); &#125; if (method_exists($provider, 'register')) &#123; $provider-&gt;register(); &#125; $this-&gt;markAsRegistered($provider); // If the application has already booted, we will call this boot method on // the provider class so it has an opportunity to do its boot logic and // will be ready for any usage by this developer's application logic. if ($this-&gt;booted) &#123; $this-&gt;bootProvider($provider); &#125; return $provider;&#125; 既然签了合同，就要如公司档案，狗蛋屁颠屁颠的跑去档案室了（$this-&gt;markAsRegistered($provider) ）标记为已注册；好，大功告成( return $provider )。 三、registerCoreContainerAliases() 注册核心容器的别名。 嗯，这个简单的多，还有啥好说的呢，定义容器里面一些核心类的别名，有兴趣直接去看这个方法就行。 12345678910111213141516171819202122232425262728293031323334353637383940414243public function registerCoreContainerAliases()&#123; foreach ([ 'app' =&gt; [\\Illuminate\\Foundation\\Application::class, \\Illuminate\\Contracts\\Container\\Container::class, \\Illuminate\\Contracts\\Foundation\\Application::class, \\Psr\\Container\\ContainerInterface::class], 'auth' =&gt; [\\Illuminate\\Auth\\AuthManager::class, \\Illuminate\\Contracts\\Auth\\Factory::class], 'auth.driver' =&gt; [\\Illuminate\\Contracts\\Auth\\Guard::class], 'blade.compiler' =&gt; [\\Illuminate\\View\\Compilers\\BladeCompiler::class], 'cache' =&gt; [\\Illuminate\\Cache\\CacheManager::class, \\Illuminate\\Contracts\\Cache\\Factory::class], 'cache.store' =&gt; [\\Illuminate\\Cache\\Repository::class, \\Illuminate\\Contracts\\Cache\\Repository::class], 'config' =&gt; [\\Illuminate\\Config\\Repository::class, \\Illuminate\\Contracts\\Config\\Repository::class], 'cookie' =&gt; [\\Illuminate\\Cookie\\CookieJar::class, \\Illuminate\\Contracts\\Cookie\\Factory::class, \\Illuminate\\Contracts\\Cookie\\QueueingFactory::class], 'encrypter' =&gt; [\\Illuminate\\Encryption\\Encrypter::class, \\Illuminate\\Contracts\\Encryption\\Encrypter::class], 'db' =&gt; [\\Illuminate\\Database\\DatabaseManager::class], 'db.connection' =&gt; [\\Illuminate\\Database\\Connection::class, \\Illuminate\\Database\\ConnectionInterface::class], 'events' =&gt; [\\Illuminate\\Events\\Dispatcher::class, \\Illuminate\\Contracts\\Events\\Dispatcher::class], 'files' =&gt; [\\Illuminate\\Filesystem\\Filesystem::class], 'filesystem' =&gt; [\\Illuminate\\Filesystem\\FilesystemManager::class, \\Illuminate\\Contracts\\Filesystem\\Factory::class], 'filesystem.disk' =&gt; [\\Illuminate\\Contracts\\Filesystem\\Filesystem::class], 'filesystem.cloud' =&gt; [\\Illuminate\\Contracts\\Filesystem\\Cloud::class], 'hash' =&gt; [\\Illuminate\\Contracts\\Hashing\\Hasher::class], 'translator' =&gt; [\\Illuminate\\Translation\\Translator::class, \\Illuminate\\Contracts\\Translation\\Translator::class], 'log' =&gt; [\\Illuminate\\Log\\Writer::class, \\Illuminate\\Contracts\\Logging\\Log::class, \\Psr\\Log\\LoggerInterface::class], 'mailer' =&gt; [\\Illuminate\\Mail\\Mailer::class, \\Illuminate\\Contracts\\Mail\\Mailer::class, \\Illuminate\\Contracts\\Mail\\MailQueue::class], 'auth.password' =&gt; [\\Illuminate\\Auth\\Passwords\\PasswordBrokerManager::class, \\Illuminate\\Contracts\\Auth\\PasswordBrokerFactory::class], 'auth.password.broker' =&gt; [\\Illuminate\\Auth\\Passwords\\PasswordBroker::class, \\Illuminate\\Contracts\\Auth\\PasswordBroker::class], 'queue' =&gt; [\\Illuminate\\Queue\\QueueManager::class, \\Illuminate\\Contracts\\Queue\\Factory::class, \\Illuminate\\Contracts\\Queue\\Monitor::class], 'queue.connection' =&gt; [\\Illuminate\\Contracts\\Queue\\Queue::class], 'queue.failer' =&gt; [\\Illuminate\\Queue\\Failed\\FailedJobProviderInterface::class], 'redirect' =&gt; [\\Illuminate\\Routing\\Redirector::class], 'redis' =&gt; [\\Illuminate\\Redis\\RedisManager::class, \\Illuminate\\Contracts\\Redis\\Factory::class], 'request' =&gt; [\\Illuminate\\Http\\Request::class, \\Symfony\\Component\\HttpFoundation\\Request::class], 'router' =&gt; [\\Illuminate\\Routing\\Router::class, \\Illuminate\\Contracts\\Routing\\Registrar::class, \\Illuminate\\Contracts\\Routing\\BindingRegistrar::class], 'session' =&gt; [\\Illuminate\\Session\\SessionManager::class], 'session.store' =&gt; [\\Illuminate\\Session\\Store::class, \\Illuminate\\Contracts\\Session\\Session::class], 'url' =&gt; [\\Illuminate\\Routing\\UrlGenerator::class, \\Illuminate\\Contracts\\Routing\\UrlGenerator::class], 'validator' =&gt; [\\Illuminate\\Validation\\Factory::class, \\Illuminate\\Contracts\\Validation\\Factory::class], 'view' =&gt; [\\Illuminate\\View\\Factory::class, \\Illuminate\\Contracts\\View\\Factory::class], ] as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125;&#125; 当然了最后是存放在 $aliases 这个数组里面哟，在 container 定义的成员属性。 四、setBasePath() 设置基本路径 12345678public function setBasePath($basePath)&#123; $this-&gt;basePath = rtrim($basePath, '\\/'); $this-&gt;bindPathsInContainer(); return $this;&#125; 123456789101112protected function bindPathsInContainer()&#123; $this-&gt;instance('path', $this-&gt;path()); $this-&gt;instance('path.base', $this-&gt;basePath()); $this-&gt;instance('path.lang', $this-&gt;langPath()); $this-&gt;instance('path.config', $this-&gt;configPath()); $this-&gt;instance('path.public', $this-&gt;publicPath()); $this-&gt;instance('path.storage', $this-&gt;storagePath()); $this-&gt;instance('path.database', $this-&gt;databasePath()); $this-&gt;instance('path.resources', $this-&gt;resourcePath()); $this-&gt;instance('path.bootstrap', $this-&gt;bootstrapPath());&#125; 123456protected $basePath;public function path($path = '')&#123; return $this-&gt;basePath.DIRECTORY_SEPARATOR.'app'.($path ? DIRECTORY_SEPARATOR.$path : $path);&#125; 这个更简单了，这就是前面说 $app 出生地的地方，传了一个路径参数, 123$app = new Illuminate\\Foundation\\Application( realpath(__DIR__.'/../')); 至此，$app 终于生出来了，绑定了 application 对象，和3个供应商签了合同，给一些核心类起了别名，配置了 laravel 根目录地址 认识 Bind第三章的探索相信有很多学友只是知道一些基本流程，并未真正意义上知道其所以然，不过学习还需要循序渐进，先了解，在深入，最后总结，本章，咱们将要探秘 bind() 方法。 Bind方法位于Container.php 123456789101112/** * Register a binding with the container. * * @param string|array $abstract * @param \\Closure|string|null $concrete * @param bool $shared * @return void */public function bind($abstract, $concrete = null, $shared = false)&#123; //&#125; Bind 第一次被使用是在 EventServiceProvider 类的 register() 方法里 vendor/laravel/framework/src/Illuminate/Events/EventServiceProvider.php 第三章说到注册3个基本的服务提供商，分别是事件( event )和路由( route )还有日志(Log),都分别执行了各自的 $provider-&gt;register()。 首先看第一次执行 bind() 的代码上下文： 12345678910111213/** * Register the service provider. * * @return void */public function register()&#123; $this-&gt;app-&gt;singleton('events', function ($app) &#123; return (new Dispatcher($app))-&gt;setQueueResolver(function () use ($app) &#123; return $app-&gt;make(QueueFactoryContract::class); &#125;); &#125;);&#125; $this-&gt;app 怎么来的？这个成员属性是在抽象类 ServiceProvider 中定义好的，并在其构造函数中进行赋值： 1234567891011121314151617181920abstract class ServiceProvider&#123; /** * The application instance. * * @var \\Illuminate\\Contracts\\Foundation\\Application */ protected $app; /** * Create a new service provider instance. * * @param \\Illuminate\\Contracts\\Foundation\\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125;&#125; 大家可以查阅，所有的服务提供商都继承于这个类，而在 application 类中的 registerBaseServiceProviders() 传入了这个参数 $this： 1$this-&gt;register(new EventServiceProvider($this)); 接下来我们看见的是 singleton 并非 bind 方法，而 singleton 意为单例，在方法内部调用如下： vendor/laravel/framework/src/Illmiunate/Container/Container.php 1234567891011/** * Register a shared binding in the container. * * @param string|array $abstract * @param \\Closure|string|null $concrete * @return void */public function singleton($abstract, $concrete = null)&#123; $this-&gt;bind($abstract, $concrete, true);&#125; 只不过是把 bind 的第三个参数设置为共享状态。 好，结合现在的情况，在分析下参数，给了一个 events 字符串，还有一个闭包函数，闭包需要传入一个参数 $app ，这个参数无非就是 application 的实例。 好，把这个来龙去脉弄清楚了，我们才能更清晰的分析 bind 内部逻辑。 Bind 开头进行了一个数组判断，为了大家看的清楚，我简单的举了个例子： extractAlias 方法只是返回了这样一个数组： 很简单吧，提取后在重组别名： 代码带来的功能就是这样，具体的意义，我把注释翻译，大家尽量去理解： 123456789// If no concrete type was given, we will simply set the concrete type to the// abstract type. After that, the concrete type to be registered as shared// without being forced to state their classes in both of the parameters.// 如果没有具体类型($concrete), 我们将简单的将具体类型设置为抽象类型 (也就是$concrete = $abstract)// 这将允许具体的类型被注册为共享, 而无需在两个参数($concrete, $abstract)中说明其类.// 删除旧的实例$this-&gt;dropStaleInstances($abstract); dropStaleInstances 1234protected function dropStaleInstances($abstract)&#123; unset($this-&gt;instances[$abstract], $this-&gt;aliases[$abstract]);&#125; 删除以后，判断了如下： 123if (is_null($concrete)) &#123; $concrete = $abstract;&#125; 为了把这里弄懂，我们现在假设 $concrete 确实为 null，然后看往下是怎么发展的。 1234567// If the factory is not a Closure, it means it is just a class name which is// bound into this container to the abstract type and we will just wrap it// up inside its own Closure to give us more convenience when extending.if (! $concrete instanceof Closure) &#123; $concrete = $this-&gt;getClosure($abstract, $concrete);&#125; 如果 $concrete 不是一个闭包，就封装成一个闭包，刚才我们假设了为 null，并且 $concrete = $abstract，那么在看一下 getClosure 方法： 12345678910protected function getClosure($abstract, $concrete)&#123; return function ($container, $parameters = []) use ($abstract, $concrete) &#123; if ($abstract == $concrete) &#123; return $container-&gt;build($concrete); &#125; return $container-&gt;make($concrete, $parameters); &#125;;&#125; 我们以刚才的假设来虚拟场景，$concrete = $abstract,所以 $method=build，并且执行 $container-&gt;build($concrete) 方法， 接下来要认识一个新数组 bindings： 1$this-&gt;bindings[$abstract] = compact('concrete', 'shared'); Compact 创建一个由参数所带变量组成的数组。如果参数中存在数组，该数组中变量的值也会被获取，这里我们知道 $conrete 被封装成一个闭包了，而 $shared 是在 singleton 方法中传的 true，也就是1。所以现在bindings 数组形式如下： 这里有部分人可能会纠结，你刚才不是说 $concrete 为 null，怎么又变成了一个闭包对象；刚才仅仅只是用假设，来弄懂一个环节，所以正常来说这里就是这样。 123456789// If the abstract type was already resolved in this container we'll fire the// rebound listener so that any objects which have already gotten resolved// can have their copy of the object updated via the listener callbacks.// 如果$abstract 已经解析的话, 则反弹给监听者, 那么任何一个已经解析的对象 就能通过监听者的回调函数进行更新if ($this-&gt;resolved($abstract)) &#123; $this-&gt;rebound($abstract);&#125; Events 肯定没有解析过，所以这里的 rebound 反弹暂时不能过多讲解。 到现在为止，闭包内的代码依然没有执行，而 bind 方法也到此为止了。 总结Bind 方法不仅可以智能的创建快捷方式，还可以封装闭包函数，并把所有的对应绑定都存入到 bindings 数组中，如果一旦某个对象解析过了依然调用 bind 方法，那么就会 rebound 反弹，通过监听者的回调函数更新对象。 认识 Make上一章了解了 bind，bind 封装了一个闭包到数组 bindings，那绑定完了总需要使用吧，就好像生产零件，先规定了怎么生产( bind )，然后再生产( make )所以 make 出来了，咱们一起看看，make 在容器里面起到什么作用。 还是老办法，先找出第一次调用 make 的地方，之前第三章探索 application 构造函数还是很有必要的，因为若干的第一次 work，以及认识这些关键的方法都包含在内，如果对以下所说的方法比较模糊，自行回顾第三章，并打开代码走一遍。 我们知道 application 构造函数里面调用了 registerBaseServiceProviders （注册基本的服务提供商），内部调用了 register 方法，register 方法内部又调用了 markAsRegistered （标记为已注册），咱们现在看 markAsRegistered 方法： Application.php@markAsRegistered 123456protected function markAsRegistered($provider)&#123; $this-&gt;serviceProviders[] = $provider; $this-&gt;loadedProviders[get_class($provider)] = true;&#125; 1function get_class ($object = null) &#123;&#125; 正确执行 Make vendor/laravel/framework/src/Illuminate/Container@offsetGet offsetGet 1234public function offsetGet($key)&#123; return $this-&gt;make($key);&#125; make 1234public function make($abstract, array $parameters = [])&#123; return $this-&gt;resolve($abstract, $parameters);&#125; resolve 123protected function resolve($abstract, $parameters = [])&#123;&#125; 先是获取正确的别名 getAlias。 1$abstract = $this-&gt;getAlias($abstract); 接下来也是一个单例的判断，如果当前 instances 数组包含此类型，则直接 return 此单元。 123if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract];&#125; 接着执行了一个新玩意 getConcrete 并将结果赋值给 $concrete，咱们在跳过去看看 getConcrete ，这个方法的大概意思是得到一个给定的抽象的具体类型。 1$concrete = $this-&gt;getConcrete($abstract); getConcrete 123456789101112131415protected function getConcrete($abstract) &#123; if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123; return $concrete; &#125; // If we don't have a registered resolver or concrete for the type, we'll just // assume each type is a concrete name and will attempt to resolve it as is // since the container should be able to resolve concretes automatically. if (isset($this-&gt;bindings[$abstract])) &#123; return $this-&gt;bindings[$abstract]['concrete']; &#125; return $abstract; &#125; 先是来了个看不懂的方法 getContextualConcrete 不明觉厉: 12345678910111213141516171819protected function getContextualConcrete($abstract)&#123; if (! is_null($binding = $this-&gt;findInContextualBindings($abstract))) &#123; return $binding; &#125; // Next we need to see if a contextual binding might be bound under an alias of the // given abstract type. So, we will need to check if any aliases exist with this // type and then spin through them and check for contextual bindings on these. if (empty($this-&gt;abstractAliases[$abstract])) &#123; return; &#125; foreach ($this-&gt;abstractAliases[$abstract] as $alias) &#123; if (! is_null($binding = $this-&gt;findInContextualBindings($alias))) &#123; return $binding; &#125; &#125;&#125; findInContextualBindings 123456protected function findInContextualBindings($abstract)&#123; if (isset($this-&gt;contextual[end($this-&gt;buildStack)][$abstract])) &#123; return $this-&gt;contextual[end($this-&gt;buildStack)][$abstract]; &#125;&#125; 我们暂时还没看到 contextual 数组用过的地方，大家先看看就好。 并且输出 contextual 现在还是空数组，所以回到 getConcrete方法，判断不成立，继续往下走。 接着，判断我们上一章学过的 bindings 数组，我们知道数组已经包含了 events 这个单元了， 什么时候包含的？ 是在 application 类的 register 方法内执行的 $provider-&gt;register() ，而 events 服务商类的 register 方法执行了 $this-&gt;app-&gt;singleton，而 singleton 其实在执行 bind，只不过是共享绑定而已，我们再复习一遍吧。 那也就是说，这里判断不成立，events 已经绑定好了，直接跳过 if 块，最后直接 123if (isset($this-&gt;bindings[$abstract])) &#123; return $this-&gt;bindings[$abstract]['concrete'];&#125; 我们知道，这里的 concrete 在 events 单元内是一个闭包对象，在把上一章的截图重发一下 到此为止，getConcrete 理论上已经结束了，但是为了在弄清楚一点，我们继续把刚才 if 内没有执行的代码说一下： 咱们找到第一次能够执行此场景的代码，在入口文件 index.php ： 1$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class); 首先通过 getAlias 方法，知道现在 $abstract 参数是 app\\Http\\Kernel，app\\Http\\Kernel 到目前为止是没有经过 bind，所以判断成立，走 if 里面。 make 1234public function make($abstract, array $parameters = [])&#123; return $this-&gt;resolve($abstract, $parameters);&#125; resolve 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354protected function resolve($abstract, $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null( $this-&gt;getContextualConcrete($abstract) ); // If an instance of the type is currently being managed as a singleton we'll // just return an existing instance instead of instantiating new instances // so the developer can keep using the same objects instance every time. if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; $concrete = $this-&gt;getConcrete($abstract); // We're ready to instantiate an instance of the concrete type registered for // the binding. This will instantiate the types, as well as resolve any of // its \"nested\" dependencies recursively until all have gotten resolved. if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; // If we defined any extenders for this type, we'll need to spin through them // and apply them to the object being built. This allows for the extension // of services, such as changing configuration or decorating the object. foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; // If the requested type is registered as a singleton we'll want to cache off // the instances in \"memory\" so we can return it later without creating an // entirely new instance of an object on each subsequent request for it. if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; $this-&gt;fireResolvingCallbacks($abstract, $object); // Before returning, we will also set the resolved flag to \"true\" and pop off // the parameter overrides for this build. After those two things are done // we will be ready to return back the fully constructed class instance. $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; 有3个知识点，isBuildable , build ,还有一个 make 的递归。 isBuildable，确定给定的具体物是可信赖的。 1234protected function isBuildable($concrete, $abstract)&#123; return $concrete === $abstract || $concrete instanceof Closure;&#125; 要么具体物和抽象类型相等，要么具体物就是个闭包方法，至少要满足一样。 好，如果满足其中一样，我们现在场景的 events 是一个闭包，满足了，执行 build Build 方法注释大概的意思：为给定的类型实例化一个具体物的实例。 方法开头直接: 123if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride());&#125; 终于露出你的庐山真面目了，events 闭包原型，我们在截图确认一下： 嗯哼，$this 参数相当于闭包函数中的参数 $app，要注意的是 $this 是 application 类，不要认为是在 container 类定义的方法 $this 就是 container，它们是继承关系，而 new 的是 application 类，所以 $this 属于谁应该很清楚了。 然而就这样执行了闭包，里面的肯定是组件的一些功能，这也不是本章主题，所以略过。 至于这个 make 递归，暂时还不知道，等用到的时候在说，目前为止 $object 是一个实例了，我们截图看看是哪个类的实例即可，因为这些都是刚才闭包内执行的结果。 这个很简单，就是判断 bindings 数组单元内 shared 如果为共享状态（也就是1），则将 $object 进行赋值。 接下来有个 fireResolvingCallbacks 方法，我的理解是启动“具有解析过程”回调函数，目前没有执行到，我们也就不去说了，还是那句话，用的时候在具体来分析，更好理解。 Make 方法最后： 12345$this-&gt;resolved[$abstract] = true;array_pop($this-&gt;with);return $object; 将 true 赋值到 resolved ,意为已经解析过的，最后 return $object, make 结束。 总结就目前为止，我们知道， make 会借用 bindings(bind而来) 来获取具体的闭包对象，然后用 build 方法来调用闭包函数，所以说 bind 和 make 是具有紧密的联系的 启动 kernel前两章初步认识了 bind 和 make 使我们明白生成一个实例的步骤，接下来，我们要认识 kernel，这是与用户交互的关键，咱们打开入口文件 原文: 1234567891011121314151617/*|--------------------------------------------------------------------------| Run The Application|--------------------------------------------------------------------------|| Once we have the application, we can handle the incoming request| through the kernel, and send the associated response back to| the client's browser allowing them to enjoy the creative| and wonderful application we have prepared for them.|*/$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture()); 翻译: 12345678910111213141516/*|--------------------------------------------------------------------------| 运行 应用程序|--------------------------------------------------------------------------|| 一旦我们有了应用程序, 我们就可以 通过内核来处理传入的请求.| 并将相关的响应发送到客户端的浏览器| 让他们可以享受我们为他们准备的创意和精彩的应用程序|*/$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture()); 咱们根据这行代码和这个参数，具体来捋一捋 $kernel 是如何生成的，也当复习。 $app 这个不用解释即 application 类，之前说的 make 方法是位于 container 类中，其实 application 类中也有 make 方法，如下： 12345678910public function make($abstract, array $parameters = [])&#123; $abstract = $this-&gt;getAlias($abstract); if (isset($this-&gt;deferredServices[$abstract]) &amp;&amp; ! isset($this-&gt;instances[$abstract])) &#123; $this-&gt;loadDeferredProvider($abstract); &#125; return parent::make($abstract, $parameters);&#125; 我们现在还不知道具体的用意在哪，不过我们看见了内部调用了父类( container )的 make 方法， 所以执行过程是先通过子类的 make 调用到父类的 make ，根据参数咱们继续往下看，这里只传了一个 Illuminate\\Contracts\\Http\\Kernel 参数，所以 $parameters 可以无视了。 在继续分析父类 make 方法之前，我们要知道，在 bootstrap/app.php 里进行了3次 singleton 操作， singleton 前面也说过，也就是调用 bind 方法，如下： 1234567891011121314$app-&gt;singleton( Illuminate\\Contracts\\Http\\Kernel::class, App\\Http\\Kernel::class);$app-&gt;singleton( Illuminate\\Contracts\\Console\\Kernel::class, App\\Console\\Kernel::class);$app-&gt;singleton( Illuminate\\Contracts\\Debug\\ExceptionHandler::class, App\\Exceptions\\Handler::class); 我们看见第一个 singleton 一目了然，对应了我们今天要说的类，不过后面多了一个参数（app\\Http\\Kernel ），这个参数原型名字是 $concrete ，即具体物。 了解以上这些，我们才正式分析父类的 make 方法： Make 方法前一章单独说过了，所以略过没有执行到的代码。 这里我们知道，Illuminate\\Contracts\\Http\\Kernel 还没有生成实例，只是绑定了而已，说到绑定，不知道大家还记得 bind 方法是怎么执行的吗？其中有一步是判断如果 $concrete 这个参数不是一个闭包的，则调用 getClosure 方法来强制生成一个闭包给 $concrete ，如下： 12345678910protected function getClosure($abstract, $concrete)&#123; return function ($container, $parameters = []) use ($abstract, $concrete) &#123; if ($abstract == $concrete) &#123; return $container-&gt;build($concrete); &#125; return $container-&gt;make($concrete, $parameters); &#125;;&#125; 咱们继续看 container 类的 make 方法。 1$concrete = $this-&gt;getConcrete($abstract); 我们知道这个方法只能返回2种参数，一个是闭包对象，一个字符参数，这里 $concrete 自然是得到一个闭包对象，因为已经绑定过了。 接着直接执行了 build 方法，咱们看 build 方法内的关键代码： 123if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride());&#125; getLastParameterOverride 1234protected function getLastParameterOverride()&#123; return count($this-&gt;with) ? end($this-&gt;with) : [];&#125; 嗯看到这里，我们上一章也说过，一个闭包的调用，这里需要跳回 getClosure 继续分析了： $concrete($this, $parameters) 这里是传了一个 this 参数，即 application 类，所以 $container=application 类，那结合刚才说 getClosure 方法，这里闭包内部应该是执行一个 $container-&gt;make($concrete) 逻辑，注意参数 $concrete 是第一次传的 app\\Http\\ 字符串；那更直接一点，代码其实是这样 application-&gt;make(‘app\\Http\\Kernel’) 。 从 make(‘Illuminate\\Contracts\\Http\\Kernel’) 又转换到 make(‘app\\Http\\Kernel’) ，我们现在只需要知道这个顺序。 好，那再一次去看 make 如何实例化这个 app\\Http\\Kernel 类的，这次应该有不同的认识。 再次执行到 getConcrete 方法，我们说了要么是返回一个闭包对象，要么就是一个字符串，前面都是返回的闭包，而这次呢？转到 getConcrete 相关代码： 12345678910111213141516protected function getConcrete($abstract)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123; return $concrete; &#125; // If we don't have a registered resolver or concrete for the type, we'll just // assume each type is a concrete name and will attempt to resolve it as is // since the container should be able to resolve concretes automatically. if (isset($this-&gt;bindings[$abstract])) &#123; return $this-&gt;bindings[$abstract]['concrete']; &#125; return $abstract;&#125; Build 方法逻辑顺序：先是我们最熟悉的闭包实例判断，我们这里只是一个字符串，所以不成立，再见。 123if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride());&#125; 然后 new 了一个反射类 1$reflector = new ReflectionClass($concrete); 先是来了个 isInstantiable 判断， 123if (! $reflector-&gt;isInstantiable()) &#123; return $this-&gt;notInstantiable($concrete);&#125; PHP 官网解释： 只要你不能实例化，直接抛错。 接下来又学到一个新数组 1$this-&gt;buildStack[] = $concrete; 绑定栈，百度百科科普一下： app\\Http\\Kernel 进入了栈结构了 紧接着又继续用到反射方法 getConstructor ，继续 PHP 官网： 1$constructor = $reflector-&gt;getConstructor(); 这下清楚了，如果反射不存在的话就返回一个 null 。 接下来也是一个 is_null 判断 123456789/ If there are no constructors, that means there are no dependencies then// we can just resolve the instances of the objects right away, without// resolving any other types or dependencies out of these containers.if (is_null($constructor)) &#123; array_pop($this-&gt;buildStack); return new $concrete;&#125; 注释很明了，不需要多余的工作，先是出栈，弹出 $concrete ，然后直接返回对象实例。 这里 app\\Http\\Kernel 继承了父类 Illuminate\\Foundation\\Http\\Kernel ，并且有构造函数，这里先发一下构造函数原型，以便后面更容易理解： 那么现在我们还得继续往下分析，发一下 $constructor 调试截图，更清晰一点： OK，那么现在 $constructor 是一个 ReflectionMethod 对象，这个反射方法对象我们在第二章也演示过，是针对类的方法。 紧接着: 1$dependencies = $constructor-&gt;getParameters(); getParameters 方法示例： 一环扣一环，返回值依然是一个新对象，不过是针对参数。 调试截图: 嗯，确实匹配构造函数的参数，没什么大问题，每一个参数即是一个 ReflectionParameter 对象。 嗯哼，接下来也很关键： 123456789101112// Once we have all the constructor's parameters we can create each of the// dependency instances and then use the reflection instances to make a// new instance of this class, injecting the created dependencies in.// 一旦我们有了所以的构造函数的参数// 我们就可以创建一个依赖实例// 然后使用反射实例来创建这个类的一个新实例// 注入创建的依赖关系$instances = $this-&gt;resolveDependencies( $dependencies); 接着出栈: 1array_pop($this-&gt;buildStack); 最后很关键的地方来了: 123return $reflector-&gt;newInstanceArgs($instances);// 创建一个类的实例, 给出的参数将传递到类的构造函数 这个简单了吧，正好对应构造函数 1public function __construct(Application $app, Router $router) 这样解决的依赖关系. 总结本章关键点在于 build 方法利用反射解决依赖关系那里，还有也进一步学习了 getClosure 方法内部逻辑，","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"}]},{"title":"Laravel 数据库请求构建器","slug":"Laravel-Database-Query","date":"2018-02-11T08:30:04.000Z","updated":"2019-08-22T03:40:12.000Z","comments":true,"path":"2018/02/11/Laravel-Database-Query/","link":"","permalink":"http://blog.caoxl.com/2018/02/11/Laravel-Database-Query/","excerpt":"Laravel 的数据库查询构造器提供了一个方便的接口来创建及运行数据库查询语句。它能用来执行应用程序中的大部分数据库操作，且能在所有被支持的数据库系统中使用。 Laravel 的查询构造器使用 PDO 参数绑定来保护你的应用程序免受 SQL 注入的攻击。因此没有必要清理作为绑定传递的字符串。","text":"Laravel 的数据库查询构造器提供了一个方便的接口来创建及运行数据库查询语句。它能用来执行应用程序中的大部分数据库操作，且能在所有被支持的数据库系统中使用。 Laravel 的查询构造器使用 PDO 参数绑定来保护你的应用程序免受 SQL 注入的攻击。因此没有必要清理作为绑定传递的字符串。 获取结果从数据表中获取所有的数据123456789101112131415161718192021&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Support\\Facades\\DB;use App\\Http\\Controllers\\Controller;class UserController extends Controller&#123; /** * 显示所有应用程序用户的列表 * * @return Response */ public function index() &#123; $users = DB::table('users')-&gt;get(); return view('user.index', ['users' =&gt; $users]); &#125;&#125; get 方法会返回一个包含 Illuminate\\Support\\Collection 的结果，其中每个结果都是一个 PHP StdClass 对象的一个实例。你可以通过访问字段作为对象的属性来访问每列的值： 1get 方法会返回一个包含 Illuminate\\Support\\Collection 的结果，其中每个结果都是一个 PHP StdClass 对象的一个实例。你可以通过访问字段作为对象的属性来访问每列的值： 从数据表中获取单个列或行123$user = DB::table('users')-&gt;where('name', 'John')-&gt;first();echo $user-&gt;name; 如果你甚至不需要整行数据，就使用 value 方法从记录中取出单个值。该方法将直接返回字段的值： 1$email = DB::table('users')-&gt;where('name', 'John')-&gt;value('email'); 获取一列的值12345$titles = DB::table('roles')-&gt;pluck('title');foreach ($titles as $title) &#123; echo $title;&#125; 你也可以在返回的集合中指定字段的自定义键值： 12345$roles = DB::table('roles')-&gt;pluck('title', 'name');foreach ($roles as $name =&gt; $title) &#123; echo $title;&#125; 结果分块如果你需要操作数千条数据库记录，可以考虑使用 chunk 方法。这个方法每次只取出一小块结果传递给 闭包 处理，这对于编写数千条记录的 Artisan 命令 而言是非常有用的 12345DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) &#123; foreach ($users as $user) &#123; // &#125;&#125;); 你可以从 闭包 中返回 false 来阻止进一步的分块的处理： 12345DB::table('users')-&gt;orderBy('id')-&gt;chunk(100, function ($users) &#123; // Process the records... return false;&#125;); 聚合123$users = DB::table('users')-&gt;count();$price = DB::table('orders')-&gt;max('price'); 当然，你也可以将这些方法和其它语句结合起来： 123$price = DB::table('orders') -&gt;where('finalized', 1) -&gt;avg('price'); Selects指定一个 Select 语句1$users = DB::table('users')-&gt;select('name', 'email as user_email')-&gt;get(); distinct 方法允许你强制让查询返回不重复的结果： 1$users = DB::table('users')-&gt;distinct()-&gt;get(); 如果你已有一个查询构造器实例，并且希望在现有的 select 语句中加入一个字段，则可以使用 addSelect 方法： 123$query = DB::table('users')-&gt;select('name');$users = $query-&gt;addSelect('age')-&gt;get(); 原生表达式使用 DB::raw 方法可以创建原生表达式 12345$users = DB::table('users') -&gt;select(DB::raw('count(*) as user_count, status')) -&gt;where('status', '&lt;&gt;', 1) -&gt;groupBy('status') -&gt;get(); 原生表达式将会被当作字符串注入到查询中，所以要小心避免创建 SQL 注入漏洞。 原生方法可以使用以下的方法代替 DB::raw 将原生表达式插入查询的各个部分。 selectRaw1234// 第二个参数接受一个可选的绑定参数的数组：$orders = DB::table('orders') -&gt;selectRaw('price * ? as price_with_tax', [1.0825]) -&gt;get(); whereRaw / orWhereRaw1234// 这些方法接受一个可选的绑定数组作为他们的第二个参数：$orders = DB::table('orders') -&gt;whereRaw('price &gt; IF(state = \"TX\", ?, 100)', [200]) -&gt;get(); havingRaw / orHavingRaw123456// 可用于将原生字符串设置为 having 语句的值$orders = DB::table('orders') -&gt;select('department', DB::raw('SUM(price) as total_sales')) -&gt;groupBy('department') -&gt;havingRaw('SUM(price) &gt; 2500') -&gt;get(); orderByRaw1234// 可用于将原生字符串设置为 order by 语句的值$orders = DB::table('orders') -&gt;orderByRaw('updated_at - created_at DESC') -&gt;get(); JoinsInner Join 语句12345$users = DB::table('users') -&gt;join('contacts', 'users.id', '=', 'contacts.user_id') -&gt;join('orders', 'users.id', '=', 'orders.user_id') -&gt;select('users.*', 'contacts.phone', 'orders.price') -&gt;get(); Left Join 语句123$users = DB::table('users') -&gt;leftJoin('posts', 'users.id', '=', 'posts.user_id') -&gt;get(); Cross Join 语句使用 crossJoin 方法和你想要交叉连接的表名来做「交叉连接」。交叉连接在第一个表和连接之间生成笛卡尔积： 123$users = DB::table('sizes') -&gt;crossJoin('colours') -&gt;get(); 高级 Join 语句你也可以指定更高级的 join 语句。比如传递一个 闭包 作为 join 方法的第二个参数。此 闭包 接收一个 JoinClause 对象，从而在其中指定 join 语句中指定约束： 12345DB::table('users') -&gt;join('contacts', function ($join) &#123; $join-&gt;on('users.id', '=', 'contacts.user_id')-&gt;orOn(...); &#125;) -&gt;get(); 如果你想要在连接上使用「where」风格的语句，可以在连接上使用 where 和 orWhere 方法。这些方法可以用来比较值和对应的字段： 123456DB::table('users') -&gt;join('contacts', function ($join) &#123; $join-&gt;on('users.id', '=', 'contacts.user_id') -&gt;where('contacts.user_id', '&gt;', 5); &#125;) -&gt;get(); Unions查询构造器还提供了将两个查询「合并」起来的快捷方式 1234567$first = DB::table('users') -&gt;whereNull('first_name');$users = DB::table('users') -&gt;whereNull('last_name') -&gt;union($first) -&gt;get(); Where 语句简单的 Where 语句1234567891011121314151617181920212223$users = DB::table('users')-&gt;where('votes', '=', 100)-&gt;get();# Or$users = DB::table('users')-&gt;where('votes', 100)-&gt;get();# Or$users = DB::table('users') -&gt;where('votes', '&gt;=', 100) -&gt;get();$users = DB::table('users') -&gt;where('votes', '&lt;&gt;', 100) -&gt;get();$users = DB::table('users') -&gt;where('name', 'like', 'T%') -&gt;get(); # Or $users = DB::table('users')-&gt;where([ ['status', '=', '1'], ['subscribed', '&lt;&gt;', '1'], ])-&gt;get(); Or 语句1234$users = DB::table('users') -&gt;where('votes', '&gt;', 100) -&gt;orWhere('name', 'John') -&gt;get(); 其它 Where 语句whereBetween12$users = DB::table('users') -&gt;whereBetween('votes', [1, 100])-&gt;get(); whereNotBetween123$users = DB::table('users') -&gt;whereNotBetween('votes', [1, 100]) -&gt;get(); whereIn / whereNotIn1234567$users = DB::table('users') -&gt;whereIn('id', [1, 2, 3]) -&gt;get(); $users = DB::table('users') -&gt;whereNotIn('id', [1, 2, 3]) -&gt;get(); whereNull / whereNotNull1234567$users = DB::table('users') -&gt;whereNull('updated_at') -&gt;get(); $users = DB::table('users') -&gt;whereNotNull('updated_at') -&gt;get(); whereDate / whereMonth / whereDay / whereYear / whereTime12345678910111213141516171819$users = DB::table('users') -&gt;whereDate('created_at', '2016-12-31') -&gt;get();$users = DB::table('users') -&gt;whereMonth('created_at', '12') -&gt;get(); $users = DB::table('users') -&gt;whereDay('created_at', '31') -&gt;get(); $users = DB::table('users') -&gt;whereYear('created_at', '2016') -&gt;get(); $users = DB::table('users') -&gt;whereTime('created_at', '=', '11:20') -&gt;get(); whereColumnwhereColumn 方法用于验证两个字段是否相等： 123$users = DB::table('users') -&gt;whereColumn('first_name', 'last_name') -&gt;get(); 还可以将比较运算符传递给该方法： 123$users = DB::table('users') -&gt;whereColumn('updated_at', '&gt;', 'created_at') -&gt;get(); whereColumn 方法也可以传递一个包含多个条件的数组。这些条件将使用 and 运算符进行连接： 12345$users = DB::table('users') -&gt;whereColumn([ ['first_name', '=', 'last_name'], ['updated_at', '&gt;', 'created_at'] ])-&gt;get(); 参数分组1234567DB::table('users') -&gt;where('name', '=', 'John') -&gt;orWhere(function ($query) &#123; $query-&gt;where('votes', '&gt;', 100) -&gt;where('title', '&lt;&gt;', 'Admin'); &#125;) -&gt;get(); Where Exists 语句whereExists 方法允许你编写 where exists SQL 语句 1234567DB::table('users') -&gt;whereExists(function ($query) &#123; $query-&gt;select(DB::raw(1)) -&gt;from('orders') -&gt;whereRaw('orders.user_id = users.id'); &#125;) -&gt;get(); JSON where 语句Laravel 也支持查询 JSON 类型的字段（仅在对 JSON 类型支持的数据库上）。目前，本特性仅支持 MySQL 5.7+ 和 Postgres数据库。可以使用 -&gt; 运算符来查询 JSON 列数据： 1234567$users = DB::table('users') -&gt;where('options-&gt;language', 'en') -&gt;get();$users = DB::table('users') -&gt;where('preferences-&gt;dining-&gt;meal', 'salad') -&gt;get(); Ordering, Grouping, Limit, &amp; OffsetorderBy123$users = DB::table('users') -&gt;orderBy('name', 'desc') -&gt;get(); latest / oldestlatest 和 oldest 方法允许你轻松地按日期对查询结果排序。默认情况下是对 created_at 字段进行排序。或者，你可以传递你想要排序的字段名称： 123$user = DB::table('users') -&gt;latest() -&gt;first(); inRandomOrderinRandomOrder 方法可以将查询结果随机排序 123$randomUser = DB::table('users') -&gt;inRandomOrder() -&gt;first(); groupBy / having1234$users = DB::table('users') -&gt;groupBy('account_id') -&gt;having('account_id', '&gt;', 100) -&gt;get(); 可以将多个参数传递给 groupBy 方法，按多个字段进行分组： 1234$users = DB::table('users') -&gt;groupBy('first_name', 'status') -&gt;having('account_id', '&gt;', 100) -&gt;get(); skip / take1$users = DB::table('users')-&gt;skip(10)-&gt;take(5)-&gt;get(); 或者，你也可以使用 limit 和 offset 方法： 1234$users = DB::table('users') -&gt;offset(10) -&gt;limit(5) -&gt;get(); 条件语句有时你可能想要子句只适用于某个情况为真时才执行查询 1234567$role = $request-&gt;input('role');$users = DB::table('users') -&gt;when($role, function ($query) use ($role) &#123; return $query-&gt;where('role_id', $role); &#125;) -&gt;get(); 只有当 when 方法的第一个参数为 true 时，闭包里的 where 语句才会执行。如果第一个参数是 false，这个闭包将不会被执行。 你可以将另一个闭包当作第三个参数传递给 when 方法。如果第一个参数的值为 false 时，这个闭包将执行。为了说明如何使用此功能，我们将使用它配置查询的默认排序： 123456789$sortBy = null;$users = DB::table('users') -&gt;when($sortBy, function ($query) use ($sortBy) &#123; return $query-&gt;orderBy($sortBy); &#125;, function ($query) &#123; return $query-&gt;orderBy('name'); &#125;) -&gt;get(); Inserts查询构造器也提供了将记录插入数据库表的 insert 方法 123DB::table('users')-&gt;insert( ['email' =&gt; 'john@example.com', 'votes' =&gt; 0]); 你还可以在 insert 中传入一个嵌套数组向表中插入多条记录。每个数组代表要插入表中的行： 1234DB::table('users')-&gt;insert([ ['email' =&gt; 'taylor@example.com', 'votes' =&gt; 0], ['email' =&gt; 'dayle@example.com', 'votes' =&gt; 0]]); 自增 ID若数据表存在自增的 ID，则可以使用 insertGetId 方法来插入记录然后获取其 ID： 123$id = DB::table('users')-&gt;insertGetId( ['email' =&gt; 'john@example.com', 'votes' =&gt; 0]); Updates123DB::table('users') -&gt;where('id', 1) -&gt;update(['votes' =&gt; 1]); 更新 JSON 字段123DB::table('users') -&gt;where('id', 1) -&gt;update(['options-&gt;enabled' =&gt; true]); 自增 &amp; 自减1234567DB::table('users')-&gt;increment('votes');DB::table('users')-&gt;increment('votes', 5);DB::table('users')-&gt;decrement('votes');DB::table('users')-&gt;decrement('votes', 5); 你也可以在操作过程中指定要更新的字段 1DB::table('users')-&gt;increment('votes', 1, ['name' =&gt; 'John']); Deletes查询构造器也可使用 delete 方法从数据表中删除记录 123DB::table('users')-&gt;delete();DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;delete(); 如果你需要清空表，你可以使用 truncate 方法，这将删除所有行，并重置自动递增 ID 为零： 1DB::table('users')-&gt;truncate(); 悲观锁查询构造器也包含一些可以帮助你在 select 语句上实现「悲观锁定」的函数 。若要在查询中使用 「共享锁」，可以使用 sharedLock 方法。 共享锁可以防止选中的行被篡改，直到事务被提交为止： 1DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;sharedLock()-&gt;get(); 或者，你也可以使用 lockForUpdate 方法。使用「更新」锁 可避免行被其它共享锁修改或选取： 1DB::table('users')-&gt;where('votes', '&gt;', 100)-&gt;lockForUpdate()-&gt;get();","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Database","slug":"Database","permalink":"http://blog.caoxl.com/tags/Database/"},{"name":"Query","slug":"Query","permalink":"http://blog.caoxl.com/tags/Query/"}]},{"title":"Eloquent:ORM of Laravel","slug":"Eloquent-The-ORM-OF-Laravel","date":"2018-02-10T11:01:20.000Z","updated":"2019-08-22T03:55:43.000Z","comments":true,"path":"2018/02/10/Eloquent-The-ORM-OF-Laravel/","link":"","permalink":"http://blog.caoxl.com/2018/02/10/Eloquent-The-ORM-OF-Laravel/","excerpt":"In simple, it’s just the M layer in the MVC design pattern.","text":"In simple, it’s just the M layer in the MVC design pattern. 写给自己看的, 路人请转向 文档, 目前内容比较多,后续慢慢用自己的话总结. 简介 Laravel 的 Eloquent ORM 提供了漂亮、简洁的 ActiveRecord 实现来和数据库交互。每个数据库表都有一个对应的「模型」用来与该表交互。你可以通过模型查询数据表中的数据，并将新记录添加到数据表中。 在开始之前，请确保在 config/database.php 中配置数据库连接。 快速入门定义模型所有的 Eloquent 模型都继承了 Illuminate\\Database\\Eloquent\\Model 类。 创建模型实例的最简单方法是使用 Artisan 命令 make:model： 1php artisan make:model User 如果要在生成模型时生成 数据库迁移，可以使用 --migration 或 -m 选项： 123php artisan make:model User --migrationphp artisan make:model User -m 简单例子123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model&#123; /** * 与模型关联的数据表 * * @var string */ protected $table = 'my_flights'; protected $primaryKey = 'my_id'; /** * 该模型是否被自动维护时间戳 * * @var bool */ public $timestamps = false; /** * 模型的日期字段的存储格式 * * @var string */ protected $dateFormat = 'U'; // 自定义用于存储时间戳的字段名 const CREATED_AT = 'creation_date'; const UPDATED_AT = 'last_update'; /** * 此模型的连接名称。 * * @var string */ protected $connection = 'connection-name';&#125; 检索多个模型创建完模型 及其关联的数据表 之后，就可以开始从数据库中检索数据。可把每个 Eloquent 模型想像成强大的 查询构造器，它让你可以流畅地查询与该模型相关联的数据库表 123456789&lt;?phpuse App\\Flight;$flights = App\\Flight::all();foreach ($flights as $flight) &#123; echo $flight-&gt;name;&#125; 添加其他约束1234$flights = App\\Flight::where('active', 1) -&gt;orderBy('name', 'desc') -&gt;take(10) -&gt;get(); 集合使用 Eloquent 中的方法比如 all 和 get 可以检索多个结果，并且会返回一个 Illuminate\\Database\\Eloquent\\Collection 实例 Collection 类提供了 很多辅助函数 来处理Eloquent 结果。 123$flights = $flights-&gt;reject(function ($flight) &#123; return $flight-&gt;cancelled;&#125;); 你也可以像数组一样简单地来遍历集合： 123foreach ($flights as $flight) &#123; echo $flight-&gt;name;&#125; 分块结果chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存： 12345Flight::chunk(200, function ($flights) &#123; foreach ($flights as $flight) &#123; // &#125;&#125;); 传递到方法的第一个参数是希望每个「分块」接收的数据量。闭包则被作为第二个参数传递，它会在每次执行数据库查询传递每个块时被调用。 使用游标cursor 允许你使用游标来遍历数据库数据，该游标只执行一个查询。处理大量数据时，可以使用 cursor 方法可以大幅度减少内存的使用量： 123foreach (Flight::where('foo', 'bar')-&gt;cursor() as $flight) &#123; //&#125; 检索单个模型／集合除了从指定的数据表检索所有记录外，你也可以通过 find 或 first 方法来检索单条记录。这些方法不是返回一组模型，而是返回一个模型实例： 12345// 通过主键取回一个模型...$flight = App\\Flight::find(1);// 取回符合查询限制的第一个模型 ...$flight = App\\Flight::where('active', 1)-&gt;first(); 你也可以用主键数组为参数调用 find 方法，它将返回匹配记录的集合： 1$flights = App\\Flight::find([1, 2, 3]); 「找不到」异常如果你希望在找不到模型时抛出异常，可以使用 findOrFail 以及 firstOrFail 方法。这些方法会检索查询的第一个结果。如果没有找到相应结果，就会抛出一个 Illuminate\\Database\\Eloquent\\ModelNotFoundException： 123$model = App\\Flight::findOrFail(1);$model = App\\Flight::where('legs', '&gt;', 100)-&gt;firstOrFail(); 如果没有对异常进行捕获，则会自动返回 HTTP 404 响应给用户。也就是说，在使用这些方法时，不需要另外写个检查来返回 404 响应： 123Route::get('/api/flights/&#123;id&#125;', function ($id) &#123; return App\\Flight::findOrFail($id);&#125;); 检索集合使用 聚合函数 123$count = App\\Flight::where('active', 1)-&gt;count();$max = App\\Flight::where('active', 1)-&gt;max('price'); 插入 &amp; 更新模型插入123456789101112131415161718192021222324252627&lt;?phpnamespace App\\Http\\Controllers;use App\\Flight;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;class FlightController extends Controller&#123; /** * 创建一个新的航班实例。 * * @param Request $request * @return Response */ public function store(Request $request) &#123; // 验证请求... $flight = new Flight; $flight-&gt;name = $request-&gt;name; $flight-&gt;save(); &#125;&#125; 更新12345$flight = App\\Flight::find(1);$flight-&gt;name = 'New Flight Name';$flight-&gt;save(); 批量更新123App\\Flight::where('active', 1) -&gt;where('destination', 'San Diego') -&gt;update(['delayed' =&gt; 1]); 批量赋值123456789101112131415&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model&#123; /** * 可以被批量赋值的属性。 * * @var array */ protected $fillable = ['name'];&#125; 只有我们设置好可以被批量赋值的属性，才能通过 create 方法来为数据库添加新记录到。create 方法会返回已保存的模型实例： 1$flight = App\\Flight::create(['name' =&gt; 'Flight 10']); 如果你已经有一个模型实例，你可以传递数组给 fill 方法： 1$flight-&gt;fill(['name' =&gt; 'Flight 22']); 保护属性$fillable 可以作为设置被批量赋值的属性的「白名单」，同样的 $guarded 属性也可以实现这个需求。但不同的是，$guarded 属性包含的是不想被批量赋值的属性的数组 使用的时候，也要注意只能是 $fillable 或 $guarded 二选一 123456789101112131415&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model&#123; /** * 不可被批量赋值的属性。 * * @var array */ protected $guarded = ['price'];&#125; 如果想让所有的属性都可以被批量赋值，就把 $guarded 定义为空数组。 123456/** * 不可被批量赋值的属性。 * * @var array */protected $guarded = []; 其他创建方法firstOrCreate / firstOrNew firstOrCreate 方法会使用给定的字段及其值在数据库中查找记录。如果在数据库中找不到模型，则将使用第一个参数中的属性以及可选的第二个参数中的属性插入记录。 firstOrNew 方法就类似 firstOrCreate 方法，会在数据库中查找匹配给定属性的记录。如果模型未被找到，则会返回一个新的模型实例。请注意，在这里面，firstOrnew 返回的模型还尚未保存到数据库，必须要手动调用 save 方法才能保存它： 123456789101112131415// 通过 name 属性检索航班，当结果不存在时创建它...$flight = App\\Flight::firstOrCreate(['name' =&gt; 'Flight 10']);// 通过 name 属性检索航班，当结果不存在的时候用 name 属性和 delayed 属性去创建它$flight = App\\Flight::firstOrCreate( ['name' =&gt; 'Flight 10'], ['delayed' =&gt; 1]);// 通过 name 属性检索航班，当结果不存在时实例化...$flight = App\\Flight::firstOrNew(['name' =&gt; 'Flight 10']);// 通过 name 属性检索航班，当结果不存在的时候用 name 属性和 delayed 属性实例化$flight = App\\Flight::firstOrNew( ['name' =&gt; 'Flight 10'], ['delayed' =&gt; 1]); updateOrCreate12345// 如果不存在匹配的模型就创建一个$flight = App\\Flight::updateOrCreate( ['departure' =&gt; 'Oakland', 'destination' =&gt; 'San Diego'], ['price' =&gt; 99]) 删除模型123$flight = App\\Flight::find(1);$flight-&gt;delete(); 通过主键删除模型12345App\\Flight::destroy(1);App\\Flight::destroy([1, 2, 3]);App\\Flight::destroy(1, 2, 3); 通过查询删除模型1$deletedRows = App\\Flight::where('active', 0)-&gt;delete(); 软删除要启动模型上的软删除，则必须在模型上使用 Illuminate\\Database\\Eloquent\\SoftDeletes trait 并添加 deleted_at 字段到 $dates 属性上： 123456789101112131415161718&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Database\\Eloquent\\SoftDeletes;class Flight extends Model&#123; use SoftDeletes; /** * 需要被转换成日期的属性。 * * @var array */ protected $dates = ['deleted_at'];&#125; 你也应该添加 deleted_at 字段到数据表中。Laravel 结构生成器 包含了一个辅助函数用来创建此字段： 123Schema::table('flights', function ($table) &#123; $table-&gt;softDeletes();&#125;); 要给定模型实例是否已被软删除，可以使用 trashed 方法： 123if ($flight-&gt;trashed()) &#123; //&#125; 查询被软删除的模型包括被软删除的模型123$flights = App\\Flight::withTrashed() -&gt;where('account_id', 1) -&gt;get(); withTrashed 方法也可用于 关联 查询： 只检索被软删除的模型123$flights = App\\Flight::onlyTrashed() -&gt;where('airline_id', 1) -&gt;get(); 恢复被软删除的模型如果想「取消删除」被软删除的模型。可在模型实例上使用 restore 方法将一个被软删除的模型恢复到有效状态： 1$flight-&gt;restore(); 你也可以在查询上使用 restore 方法来快速地恢复多个模型。像其他「批量赋值」操作一样，这并不会触发任何模型事件： 123App\\Flight::withTrashed() -&gt;where('airline_id', 1) -&gt;restore(); 与 withTrashed 方法类似，restore 方法也可以被用在 关联 查询上: 1$flight-&gt;history()-&gt;restore(); 永久删除模型如果要真正地从数据库中永久删除软删除的模型，可以使用 forceDelete 方法： 12345// 强制删除单个模型实例...$flight-&gt;forceDelete();// 强制删除所有相关模型...$flight-&gt;history()-&gt;forceDelete(); 模型关联定义关联Eloquent 关联在 Eloquent 模型类中以方法的形式呈现。如同 Eloquent 模型本身，关联也可以作为强大的 查询语句构造器 使用，提供了强大的链式调用和查询功能。 一对一12345678910111213141516&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * 获得与用户关联的电话记录。 */ public function phone() &#123; return $this-&gt;hasOne('App\\Phone'); &#125;&#125; hasOne 方法的第一个参数是关联模型的类名, 可以像在访问模型中定义的属性一样，使用动态属性： 1$phone = User::find(1)-&gt;phone; 可以通过给 hasOne 方法传递第二个参数覆盖默认使用的外键名： 1return $this-&gt;hasOne('App\\Phone', 'foreign_key'); 此外，Eloquent 假定外键值是与父级 id（或自定义 ）列的值相匹配的。 换句话说，Eloquent 将在 Phone 记录的 user_id 列中查找与用户表的 id 列相匹配的值。 如果您希望该关联使用 id 以外的自定义键名，则可以给 hasOne 方法传递第三个参数： 1return $this-&gt;hasOne('App\\Phone', 'foreign_key', 'local_key'); 定义反向关联hasOne 方法对应的 belongsTo 方法： 12345678910111213141516&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Phone extends Model&#123; /** * 获得拥有此电话的用户。 */ public function user() &#123; return $this-&gt;belongsTo('App\\User'); &#125;&#125; 在上面的例子中，Eloquent 会尝试匹配 Phone 模型上的 user_id 至 User 模型上的 id。 它是通过检查关系方法的名称并使用 _id 作为后缀名来确定默认外键名称的。 但是，如果 Phone 模型的外键不是user_id，那么可以将自定义键名作为第二个参数传递给 belongsTo 方法： 1234567/** * 获得拥有此电话的用户。 */public function user()&#123; return $this-&gt;belongsTo('App\\User', 'foreign_key');&#125; 如果父级模型没有使用 id 作为主键，或者是希望用不同的字段来连接子级模型，则可以通过给 belongsTo 方法传递第三个参数的形式指定父级数据表的自定义键： 1234567/** * 获得拥有此电话的用户。 */public function user()&#123; return $this-&gt;belongsTo('App\\User', 'foreign_key', 'other_key');&#125; 默认模型1234567/** * 获得此文章的作者。 */public function user()&#123; return $this-&gt;belongsTo('App\\User')-&gt;withDefault();&#125; 您也可以通过传递数组或者使用闭包的形式，填充默认模型的属性： 12345678910111213141516171819/** * 获得此文章的作者。 */public function user()&#123; return $this-&gt;belongsTo('App\\User')-&gt;withDefault([ 'name' =&gt; '游客', ]);&#125;/** * 获得此文章的作者。 */public function user()&#123; return $this-&gt;belongsTo('App\\User')-&gt;withDefault(function ($user) &#123; $user-&gt;name = '游客'; &#125;);&#125; 一对多「一对多」关联用于定义单个模型拥有任意数量的其它关联模型。例如，一篇博客文章可能会有无限多条评论 12345678910111213141516&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * 获得此博客文章的评论。 */ public function comments() &#123; return $this-&gt;hasMany('App\\Comment'); &#125;&#125; 联关系定义好后，我们就可以通过访问 comments 属性获得评论集合。记住，因为 Eloquent 提供了「动态属性」，所以我们可以像在访问模型中定义的属性一样，访问关联方法： 12345$comments = App\\Post::find(1)-&gt;comments;foreach ($comments as $comment) &#123; //&#125; 形如 hasOne 方法，您也可以在使用 hasMany 方法的时候，通过传递额外参数来覆盖默认使用的外键与本地键。 123return $this-&gt;hasMany('App\\Comment', 'foreign_key');return $this-&gt;hasMany('App\\Comment', 'foreign_key', 'local_key'); 一对多（反向）12345678910111213141516&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * 获得此评论所属的文章。 */ public function post() &#123; return $this-&gt;belongsTo('App\\Post'); &#125;&#125; 关联关系定义好后，我们就可以在 Comment 模型上使用 post 「动态属性」获得 Post 模型了。 123$comment = App\\Comment::find(1);echo $comment-&gt;post-&gt;title; 如果 Comment 模型的外键不是 post_id，那么可以将自定义键名作为第二个参数传递给belongsTo方法： 1234567/** * 获得此评论所属的文章。 */public function post()&#123; return $this-&gt;belongsTo('App\\Post', 'foreign_key');&#125; 如果父级模型没有使用 id 作为主键，或者是希望用不同的字段来连接子级模型，则可以通过给 belongsTo方法传递第三个参数的形式指定父级数据表的自定义键： 1如果父级模型没有使用 id 作为主键，或者是希望用不同的字段来连接子级模型，则可以通过给 belongsTo方法传递第三个参数的形式指定父级数据表的自定义键： 多对多1return $this-&gt;belongsToMany('App\\Role', 'role_user', 'user_id', 'role_id'); 为了确定连接表表名，Eloquent 会按照字母顺序合并两个关联模型的名称。 当然，您可以自由地覆盖这个约定，通过给 belongsToMany 方法指定第二个参数实现： 第三个参数是定义此关联的模型在连接表里的键名 第四个参数是另一个模型在连接表里的键名： 定义反向关联12345678910111213141516&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Role extends Model&#123; /** * 获得此角色下的用户。 */ public function users() &#123; return $this-&gt;belongsToMany('App\\User'); &#125;&#125; 查询关联关联方法 Vs. 动态属性12345$user = App\\User::find(1);foreach ($user-&gt;posts as $post) &#123; //&#125; 动态属性是「懒加载」的，意味着它们的关联数据只在实际被访问时才被加载 基于存在的关联查询12345678910111213// 获得所有至少有一条评论的文章...$posts = App\\Post::has('comments')-&gt;get();// 获得所有有三条或三条以上评论的文章...$posts = Post::has('comments', '&gt;=', 3)-&gt;get();// 获得所有至少有一条获赞评论的文章...$posts = Post::has('comments.votes')-&gt;get();// 获得所有至少有一条评论内容满足 foo% 条件的文章$posts = Post::whereHas('comments', function ($query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;)-&gt;get(); 基于不存在的关联查询12345$posts = App\\Post::doesntHave('comments')-&gt;get();$posts = Post::whereDoesntHave('comments', function ($query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;)-&gt;get(); 关联数据计数1234567891011121314151617181920212223242526// 只想统计结果数而不需要加载实际数据$posts = App\\Post::withCount('comments')-&gt;get();foreach ($posts as $post) &#123; echo $post-&gt;comments_count;&#125;// 可以为多个关联数据「计数」，并为其查询添加约束条件：$posts = Post::withCount(['votes', 'comments' =&gt; function ($query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;])-&gt;get();echo $posts[0]-&gt;votes_count;echo $posts[0]-&gt;comments_count;// 可以为关联数据计数结果起别名，允许在同一个关联上多次计数：$posts = Post::withCount([ 'comments', 'comments as pending_comments_count' =&gt; function ($query) &#123; $query-&gt;where('approved', false); &#125;])-&gt;get();echo $posts[0]-&gt;comments_count;echo $posts[0]-&gt;pending_comments_count; 预加载当作为属性访问 Eloquent 关联时，关联数据是「懒加载」的。意味着在你第一次访问该属性时，才会加载关联数据。不过，是当你查询父模型时，Eloquent 可以「预加载」关联数据。预加载避免了 N + 1 查询问题。要说明 N + 1 查询问题 插入 &amp; 更新关联模型Eloquent CollectionEloquent 返回的所有多结果集都是 Illuminate\\Database\\Eloquent\\Collection 对象的实例， 大多数 Eloquent 集合方法会返回新的 Eloquent 集合实例，但是 pluck, keys, zip, collapse, flatten 和 flip 方法除外，它们会返回 集合基类 实例。同样，如果 map 操作返回的集合不包含任何 Eloquent 模型，那么它会被自动转换成集合基类。 可用的方法 https://d.laravel-china.org/docs/5.5/eloquent-collections#available-methods 修改器简介当你在 Eloquent 模型实例中获取或设置某些属性值的时候，访问器和修改器允许你对 Eloquent 属性值进行格式化。 访问器 &amp; 修改器定义一个访问器若要定义一个访问器，则须在你的模型上创建一个 getFooAttribute 方法。要访问的 Foo 字段需使用「驼峰式」来命名。 在这个例子中，我们将为 first_name 属性定义一个访问器。当 Eloquent 尝试获取 first_name 的值时，将会自动调用此访问器： 12345678910111213141516171819&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * 获取用户的名字。 * * @param string $value * @return string */ public function getFirstNameAttribute($value) &#123; return ucfirst($value); &#125;&#125; 123$user = App\\User::find(1);$firstName = $user-&gt;first_name; 当然，你也可以通过已有的属性，使用访问器返回新的计算值： 123456789/** * 获取用户名全称 * * @return string */public function getFullNameAttribute()&#123; return \"&#123;$this-&gt;first_name&#125; &#123;$this-&gt;last_name&#125;\";&#125; 定义一个修改器若要定义一个修改器，则须在模型上定义一个 setFooAttribute 方法。要访问的 Foo 字段需使用「驼峰式」来命名. 让我们再来定义 first_name 属性的修改器。当我们尝试在模型上设置 first_name 的值时，该修改器将被自动调用： 12345678910111213141516171819&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * 设定用户的名字。 * * @param string $value * @return void */ public function setFirstNameAttribute($value) &#123; $this-&gt;attributes['first_name'] = strtolower($value); &#125;&#125; 修改器会获取属性已经被设置的值，允许你操作该值并将其设置到 Eloquent 模型内部的 $attributes 属性上。 举个例子，如果我们尝试将 first_name 属性设置成 Sally： 123$user = App\\User::find(1);$user-&gt;first_name = 'Sally'; 日期转换器默认情况下，Eloquent 将会把 created_at 和 updated_at 字段转换成 Carbon 实例，它继承了 PHP 原生的 DateTime 类，并提供了各种有用的方法。 你可以通过重写模型的 $dates 属性，自行定义哪些日期类型字段会被自动转换，或者完全禁止所有日期类型字段的转换： 12345678910111213141516171819&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * 应被转换为日期的属性。 * * @var array */ protected $dates = [ 'created_at', 'updated_at', 'deleted_at' ];&#125; 当某个字段被认为是日期格式时，你或许想将其数值设置成一个 UNIX 时间戳、日期字符串（Y-m-d）、日期时间（ date-time ）字符串，当然还有 DateTime 或 Carbon 实例，并且让日期值自动正确地保存到你的数据库中： 12345$user = App\\User::find(1);$user-&gt;deleted_at = Carbon::now();$user-&gt;save(); 就如上面所说的，当获取到的属性包含在 $dates 属性时，都将会自动转换成 Carbon 实例，允许你在属性上使用任意的 Carbon 方法： 123$user = App\\User::find(1);return $user-&gt;deleted_at-&gt;getTimestamp(); API 资源生成资源你可以使用 make:resource Artisan 命令来生成资源类。默认情况下生成的资源都会被放置在框架 app/Http/Resources 文件夹下。资源继承 Illuminate\\Http\\Resources\\Json\\Resource 类： 1php artisan make:resource User 资源集合123php artisan make:resource Users --collectionphp artisan make:resource UserCollection 序列化序列化模型 &amp; 集合序列化成数组123$user = App\\User::with('roles')-&gt;first();return $user-&gt;toArray(); 序列化成 JSON123$user = App\\User::find(1);return $user-&gt;toJson() 隐藏来自 JSON 的属性123456789101112131415&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The attributes that should be hidden for arrays. * * @var array */ protected $hidden = ['password'];&#125; 另外，你也可以使用 visible 属性来定义应该包含在你的模型数组和 JSON 表示中的属性白名单。白名单外的其他属性将隐藏，不会出现在转换后的数组或 JSON 中： 123456789101112131415&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The attributes that should be visible in arrays. * * @var array */ protected $visible = ['first_name', 'last_name'];&#125; 临时修改属性的可见度1return $user-&gt;makeVisible('attribute')-&gt;toArray(); 相应的，你可以在模型实例后使用 makeHidden 方法来隐藏通常显示的属性： 1return $user-&gt;makeHidden('attribute')-&gt;toArray(); 添加参数到 JSON 中首先你需要为这个值定义一个 访问器： 123456789101112131415161718&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * Get the administrator flag for the user. * * @return bool */ public function getIsAdminAttribute() &#123; return $this-&gt;attributes['admin'] == 'yes'; &#125;&#125; 访问器创建成功后，只需添加该属性到该模型的 appends 属性中。注意，属性名称通常遵循 「Snake Case」, 的命名方式，即是访问器的名称是基于 「Camel Case」 的命名方式。 123456789101112131415&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The accessors to append to the model's array form. * * @var array */ protected $appends = ['is_admin'];&#125;","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"ELoquent","slug":"ELoquent","permalink":"http://blog.caoxl.com/tags/ELoquent/"},{"name":"ORM","slug":"ORM","permalink":"http://blog.caoxl.com/tags/ORM/"}]},{"title":"如何上手新框架「基础篇」","slug":"How-To-Learn-New-Framework","date":"2018-02-09T09:17:47.000Z","updated":"2019-08-22T03:40:30.000Z","comments":true,"path":"2018/02/09/How-To-Learn-New-Framework/","link":"","permalink":"http://blog.caoxl.com/2018/02/09/How-To-Learn-New-Framework/","excerpt":"不知不觉, 2018都已经到了2月份了,放假前总结一波 不同的框架就是PHP不同的衣服, 外表不同, 内在一样","text":"不知不觉, 2018都已经到了2月份了,放假前总结一波 不同的框架就是PHP不同的衣服, 外表不同, 内在一样 常用文档框架 Laravel 中文， 英文 Lumen 中文， 英文 Laravel-admin 中文, 英文 ThinkPHP 5 中文, API Laravel API 英文 Dingo API 中文，英文 要做什么? 怎么做? 为什么?What ? 对于一个新框架, 我们要学习什么? 对于一个框架,我们需要知道: 必知 项目入口 配置文件 (config/ENV) 环境要求 (PHP/MySQL版本等) MVC (Controller, Model, View) Route (路由) ORM/Eloquent (对象关系映射) 扩展 访问权限 (OAuth, JWT) 缓存 (Redis/Memcache) Session/Cookie Composer 任务调度/定时任务 (Schedule/Crontab) 第三方 第三方登录 (微信/QQ/微博/云联惠 等) 第三方支付 (微信/支付宝/快钱/网银 等) 短信服务 (阿里云通信/极光推送/腾讯信鸽/接口网 等) 地图服务 (百度地图/高德地图 等) 图片存储 (七牛云对象存储 等) 微信公众号 深入 网站优化 (CDN加速, SEO优化) 服务器部署 (Linux/Nginx/CentOS/Ubantu 等) 自动部署 (WebHook/Github/Gitlab) 网站加密 (HTTPS/SSL) Git 团队工作流 团队开发规范/测试流程规范/前后端分离规范 不同的框架 有不同的操作 当流程大体一致 How ?Laravel Laravel 使用笔记 深入理解 Laravel Laravel5.5 with DA - LA 项目入口public/index.php 注: 查看 public/index.php 和 bootstrap/app.php两个文件 配置文件 (config / ENV).env和config/ 目录下的各个文件 注: .env 加入 .gitignore中, 项目中使用.env.example方便团队开发 环境要求 (PHP/MySQL版本等)根据不同项目要求,选择不同的版本 如我工作中: 二次开发江湖外卖 需要 PHP 5.4-nts (nts 非线程安全) Lumen框架/Laravel-admin框架中 需要 PHP 7.1+ MySQL 5.7 MVC (Controller, Model, View) Controller Middleware Request Response Model DB Migrations Seeders Redis View Route (路由) routes 123456Route::get($uri, $callback);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback); ORM/Eloquent (对象关系映射) Eloquent Collection Resource Serialization Relationship 核心架构 Facades Contracts Container Providers 扩展 Passport Lumen 文档: https://lumen.laravel-china.org/docs/5.3 Lumen5.4-开发记录 JWT-Lumen5.4-自定义 Lumen 是简洁版的 Laravel 学习路线基本和官方文档一致,以下挑选几个开发必知. 基本功能 路由 中间件 控制器 请求 响应 更多功能 用户认证 用户授权 数据库 服务容器 服务提供者 数据验证 错误与日志 缓存 事件 队列 Laravel-admin http://laravel-admin.org/docs/#/zh/ Laravel-admin-开发记录 Laravel5.5 with DA - LA Laravel-admin 是一个基于Laravel的后台框架,用于开发后台很高效 基础使用 模型表单 Grid 模型表单 Form 帮助工具 自定义登陆 二次开发 二次开发之江湖外卖 二次开发主要问题是有很多坑, 并且没有文档告诉你如何解决.你需要自己去看代码依葫芦画瓢去解决 ThinkPHP 3.2/5.0 待更新,需要总结以前的工作,以及以前的笔记.2018一年主要是在前三个框架中度过的 Why ?每个框架都有各自的优点长处, 也因为不同公司的性质不一样, 要做的项目要求不一样. 总结对于工作:你主要是需要知道 How ? ,因为很多时候你需要考虑的是做出功能,好的程序员不仅仅是做出功能,而是做好功能 对于学习以及对编程:你需要知道 Why ?, 甚至更深层次的, 只有知道工具是怎么造的, 才能自己造出更好的工具 未完待续~~ 不定时更新","categories":[{"name":"框架相关","slug":"框架相关","permalink":"http://blog.caoxl.com/categories/框架相关/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://blog.caoxl.com/tags/ThinkPHP/"}]},{"title":"PHP 命令行模式","slug":"PHP-CLI-Command-Line-Interface","date":"2018-02-07T09:06:04.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/07/PHP-CLI-Command-Line-Interface/","link":"","permalink":"http://blog.caoxl.com/2018/02/07/PHP-CLI-Command-Line-Interface/","excerpt":"从版本 4.3.0 开始，PHP 提供了一种新类型的 CLI SAPI（Server Application Programming Interface，服务端应用编程端口）支持，名为 CLI，意为 Command Line Interface，即命令行接口","text":"从版本 4.3.0 开始，PHP 提供了一种新类型的 CLI SAPI（Server Application Programming Interface，服务端应用编程端口）支持，名为 CLI，意为 Command Line Interface，即命令行接口 内置Web ServerPHP 5.4.0起， CLI SAPI 提供了一个内置的Web服务器。 这个内置的Web服务器主要用于本地开发使用，不可用于线上产品环境。 URI请求会被发送到PHP所在的的工作目录（Working Directory）进行处理，除非你使用了-t参数来自定义不同的目录。 如果请求未指定执行哪个PHP文件，则默认执行目录内的 index.php 或者 index.html 。如果这两个文件都不存在，服务器会返回 404 错误。 启动Web服务器123$ cd ~/public_html$ php -S localhost:8000 终端窗口会显示: 1234PHP 7.1.10 Development Server started at Wed Feb 7 17:12:02 2018Listening on http://localhost:8888Document root is D:\\DeskTop\\public_htmlPress Ctrl-C to quit. 接着访问http://localhost:8000/和http://localhost:8000/info.php，窗口会显示： 12345678910PHP 7.1.10 Development Server started at Wed Feb 7 17:12:02 2018Listening on http://localhost:8888Document root is D:\\DeskTop\\public_htmlPress Ctrl-C to quit.[Wed Feb 7 17:12:13 2018] ::1:53519 [404]: / - No such file or directory[Wed Feb 7 17:12:13 2018] ::1:53520 [404]: /favicon.ico - No such file or directory[Wed Feb 7 17:12:18 2018] ::1:53528 [200]: /info.php[Wed Feb 7 17:12:42 2018] ::1:53529 Invalid request (Unexpected EOF)[Wed Feb 7 17:12:42 2018] ::1:53530 Invalid request (Unexpected EOF)[Wed Feb 7 17:12:42 2018] ::1:53531 Invalid request (Unexpected EOF) 启动时指定根目录123$ cd ~/public_html$ php -S localhost:8000 -t test/ 终端窗口显示 1234PHP 7.1.10 Development Server started at Wed Feb 7 17:14:26 2018Listening on http://localhost:8888Document root is D:\\DeskTop\\public_html\\testPress Ctrl-C to quit. 使用路由（Router）脚本请求图片直接显示图片，请求HTML则显示“Welcome to PHP” 12345678&lt;?php// router.phpif (preg_match('/\\.(?:png|jpg|jpeg|gif)$/', $_SERVER[\"REQUEST_URI\"])) return false; // 直接返回请求的文件else &#123; echo \"&lt;p&gt;Welcome to PHP&lt;/p&gt;\";&#125;?&gt; 1$ php -S localhost:8000 router.php 执行之后终端显示： 1234567891011121314PHP 7.1.10 Development Server started at Wed Feb 7 17:16:56 2018Listening on http://localhost:8000Document root is D:\\DeskTop\\public_htmlPress Ctrl-C to quit.[Wed Feb 7 17:17:33 2018] ::1:53688 Invalid request (Unexpected EOF)[Wed Feb 7 17:17:33 2018] ::1:53689 Invalid request (Unexpected EOF)[Wed Feb 7 17:17:47 2018] ::1:53695 Invalid request (Unexpected EOF)[Wed Feb 7 17:18:04 2018] ::1:53713 Invalid request (Unexpected EOF)[Wed Feb 7 17:18:04 2018] ::1:53723 [404]: /logo.jpg - No such file or directory[Wed Feb 7 17:18:08 2018] ::1:53725 [404]: /logo.png - No such file or directory[Wed Feb 7 17:18:17 2018] ::1:53730 [404]: /mylogo.png - No such file or directory[Wed Feb 7 17:18:26 2018] ::1:53744 [404]: /mylogo.jpg - No such file or directory[Wed Feb 7 17:18:44 2018] ::1:53747 Invalid request (Unexpected EOF)[Wed Feb 7 17:18:47 2018] ::1:53754 [200]: /logo.png","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"CLI","slug":"CLI","permalink":"http://blog.caoxl.com/tags/CLI/"},{"name":"SAPI","slug":"SAPI","permalink":"http://blog.caoxl.com/tags/SAPI/"}]},{"title":"Composer 「使用笔记」","slug":"Composer-Tips","date":"2018-02-07T07:46:30.000Z","updated":"2019-08-22T03:28:04.000Z","comments":true,"path":"2018/02/07/Composer-Tips/","link":"","permalink":"http://blog.caoxl.com/2018/02/07/Composer-Tips/","excerpt":"Composer 中文镜像 / Packagist 『Composer 中国全量镜像』是由 Laravel China 社区联合 又拍云 与 优帆远扬 共同合作推出的公益项目，旨在为广大 PHP 用户提供稳定和高速的 Composer 国内镜像服务。","text":"Composer 中文镜像 / Packagist 『Composer 中国全量镜像』是由 Laravel China 社区联合 又拍云 与 优帆远扬 共同合作推出的公益项目，旨在为广大 PHP 用户提供稳定和高速的 Composer 国内镜像服务。 使用 Composer 镜像加速有两种选项： 选项一：全局配置，这样所有项目都能惠及（推荐）； 1$ composer config -g repo.packagist composer https://packagist.laravel-china.org 选项二：单独项目配置； 如果仅限当前工程使用镜像，去掉 -g 即可，如下： 1$ composer config repo.packagist composer https://packagist.laravel-china.org 取消镜像 1composer config -g --unset repos.packagist 遇到问题？composer命令后面加上 -vvv （是3个v）可以打印出调错信息，命令如下： 12$ composer -vvv create-project laravel/laravel blog$ composer -vvv require psr/log FAQ 已存在 composer.lock 文件，先删除，再运行 composer install 重新生成。 原因：composer.lock 缓存了之前的配置信息，从而导致新的镜像配置无效。 使用 laravel new 命令创建工程， 这个命令会从 这里 下一个zip包，里面自带了 composer.lock，和上面原因一样，也无法使用镜像加速，解决方法： 方法一（推荐）：不使用 laravel new，直接用 composer create-project laravel/laravel xxx 新建工程。 方法二运行 laravel new xxx，当看见屏幕出现 - Installing doctrine/inflector 时，Ctrl + C 终止命令，cd xxx 进入，删除 composer.lock，再运行 composer install。 缓存多久更新一次？ 0时 - 早上7时，这个时间段考虑使用人数不会太频繁，间隔为15分钟 其余时间，间隔为5分钟 正常更新速度可在1分内完成 ，但更新太快，会降低CDN命中率，如果总有新文件让CDN去缓存，反而拖慢了速度，所以故意加了些延迟。我们每次采集中还会删减掉数千个僵尸包，以加快传输速度。 安装 ComposerLinux/Mac：12wget https://dl.laravel-china.org/composer.phar -O /usr/local/bin/composerchmod a+x /usr/local/bin/composer Windows： 直接下载 composer.phar，地址：https://dl.laravel-china.org/composer.phar 把下载的 composer.phar 放到 PHP 安装目录 新建 composer.bat, 添加如下内容，并保存 @php “%~dp0composer.phar” %* 查看当前版本1$ composer -V 升级版本1$ composer selfupdate 注意 selfupdate 升级命令会连接官方服务器，速度很慢。建议直接下载我们的 composer.phar 镜像，每天都会更新到最新。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Composer","slug":"Composer","permalink":"http://blog.caoxl.com/tags/Composer/"}]},{"title":"Linux 的启动流程","slug":"Linux-Boot-Process","date":"2018-02-07T06:58:32.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/07/Linux-Boot-Process/","link":"","permalink":"http://blog.caoxl.com/2018/02/07/Linux-Boot-Process/","excerpt":"原文地址: http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html 今天，探讨操作系统接管硬件以后发生的事情，也就是操作系统的启动流程。","text":"原文地址: http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html 今天，探讨操作系统接管硬件以后发生的事情，也就是操作系统的启动流程。 这个部分比较有意思。因为在BIOS阶段，计算机的行为基本上被写死了，程序员可以做的事情并不多；但是，一旦进入操作系统，程序员几乎可以定制所有方面。所以，这个部分与程序员的关系更密切。 我主要关心的是Linux操作系统，它是目前服务器端的主流操作系统。下面的内容针对的是 Debian 发行版，因为我对其他发行版不够熟悉。 第一步、加载内核操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。 以我的电脑为例，/boot 目录下面大概是这样一些文件： 1234567891011 $ ls /boot config-3.2.0-3-amd64 config-3.2.0-4-amd64 grub initrd.img-3.2.0-3-amd64 initrd.img-3.2.0-4-amd64 System.map-3.2.0-3-amd64 System.map-3.2.0-4-amd64 vmlinuz-3.2.0-3-amd64 vmlinuz-3.2.0-4-amd64 第二步、启动初始化进程内核文件加载以后，就开始运行第一个程序 /sbin/init，它的作用是初始化系统环境。 由于init是第一个运行的程序，它的进程编号（pid）就是1。其他所有进程都从它衍生，都是它的子进程 第三步、确定运行级别许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做 “守护进程”（daemon）。 init进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做 “运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。 Linux预置七种运行级别（0-6）。一般来说，0是关机，1是单用户模式（也就是维护模式），6是重启。运行级别2-5，各个发行版不太一样，对于Debian来说，都是同样的多用户模式（也就是正常模式）。 init进程首先读取文件 /etc/inittab ，它是运行级别的设置文件。如果你打开它，可以看到第一行是这样的： 1id:2:initdefault: initdefault的值是2，表明系统启动时的运行级别为2。如果需要指定其他级别，可以手动修改这个值。 那么，运行级别2有些什么程序呢，系统怎么知道每个级别应该加载哪些程序呢？……回答是每个运行级别在/etc目录下面，都有一个对应的子目录，指定要加载的程序。 1234567 /etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d /etc/rc5.d /etc/rc6.d 上面目录名中的”rc”，表示 run command（运行程序），最后的d表示directory（目录）。下面让我们看看 /etc/rc2.d 目录中到底指定了哪些程序。 123456789101112 $ ls /etc/rc2.d README S01motd S13rpcbind S14nfs-common S16binfmt-support S16rsyslog S16sudo S17apache2 S18acpid ... 可以看到，除了第一个文件README以外，其他文件名都是“字母S+两位数字+程序名”的形式。字母S表示Start，也就是启动的意思（启动脚本的运行参数为start），如果这个位置是字母K，就代表Kill（关闭），即如果从其他运行级别切换过来，需要关闭的程序（启动脚本的运行参数为stop）。后面的两位数字表示处理顺序，数字越小越早处理，所以第一个启动的程序是motd，然后是rpcbing、nfs……数字相同时，则按照程序名的字母顺序启动，所以rsyslog会先于sudo启动。 这个目录里的所有文件（除了README），就是启动时要加载的程序。如果想增加或删除某些程序，不建议手动修改 /etc/rcN.d 目录，最好是用一些专门命令进行管理（参考这里和这里）。 第四步、加载开机启动程序前面提到，七种预设的”运行级别”各自有一个目录，存放需要开机启动的程序。不难想到，如果多个”运行级别”需要启动同一个程序，那么这个程序的启动脚本，就会在每一个目录里都有一个拷贝。这样会造成管理上的困扰：如果要修改启动脚本，岂不是每个目录都要改一遍？ Linux的解决办法，就是七个 /etc/rcN.d 目录里列出的程序，都设为链接文件，指向另外一个目录 /etc/init.d ，真正的启动脚本都统一放在这个目录中。init进程逐一加载开机启动程序，其实就是运行这个目录里的启动脚本。 下面就是链接文件真正的指向。 123456789101112 $ ls -l /etc/rc2.d README S01motd -&gt; ../init.d/motd S13rpcbind -&gt; ../init.d/rpcbind S14nfs-common -&gt; ../init.d/nfs-common S16binfmt-support -&gt; ../init.d/binfmt-support S16rsyslog -&gt; ../init.d/rsyslog S16sudo -&gt; ../init.d/sudo S17apache2 -&gt; ../init.d/apache2 S18acpid -&gt; ../init.d/acpid ... 这样做的另一个好处，就是如果你要手动关闭或重启某个进程，直接到目录 /etc/init.d 中寻找启动脚本即可。比如，我要重启Apache服务器，就运行下面的命令： 1$ sudo /etc/init.d/apache2 restart /etc/init.d 这个目录名最后一个字母d，是directory的意思，表示这是一个目录，用来与程序 /etc/init 区分。 第五步、用户登录开机启动程序加载完毕以后，就要让用户登录了。 一般来说，用户的登录方式有三种： （1）命令行登录 （2）ssh登录 （3）图形界面登录 这三种情况，都有自己的方式对用户进行认证。 （1）命令行登录：init进程调用getty程序（意为get teletype），让用户输入用户名和密码。输入完成后，再调用login程序，核对密码（Debian还会再多运行一个身份核对程序/etc/pam.d/login）。如果密码正确，就从文件 /etc/passwd 读取该用户指定的shell，然后启动这个shell。 （2）ssh登录：这时系统调用sshd程序（Debian还会再运行/etc/pam.d/ssh），取代getty和login，然后启动shell。 （3）图形界面登录：init进程调用显示管理器，Gnome图形界面对应的显示管理器为gdm（GNOME Display Manager），然后用户输入用户名和密码。如果密码正确，就读取/etc/gdm3/Xsession，启动用户的会话。 第六步、进入 login shell所谓shell，简单说就是命令行界面，让用户可以直接与操作系统对话。用户登录时打开的shell，就叫做login shell。 Debian默认的shell是 Bash，它会读入一系列的配置文件。上一步的三种情况，在这一步的处理，也存在差异。 （1）命令行登录：首先读入 /etc/profile，这是对所有用户都有效的配置；然后依次寻找下面三个文件，这是针对当前用户的配置。 123 ~/.bash_profile ~/.bash_login ~/.profile 需要注意的是，这三个文件只要有一个存在，就不再读入后面的文件了。比如，要是 ~/.bash_profile 存在，就不会再读入后面两个文件了。 （2）ssh登录：与第一种情况完全相同。 （3）图形界面登录：只加载 /etc/profile 和 ~/.profile。也就是说，~/.bash_profile 不管有没有，都不会运行。 第七步，打开 non-login shell老实说，上一步完成以后，Linux的启动过程就算结束了，用户已经可以看到命令行提示符或者图形界面了。但是，为了内容的完整，必须再介绍一下这一步。 用户进入操作系统以后，常常会再手动开启一个shell。这个shell就叫做 non-login shell，意思是它不同于登录时出现的那个shell，不读取/etc/profile和.profile等配置文件。 non-login shell的重要性，不仅在于它是用户最常接触的那个shell，还在于它会读入用户自己的bash配置文件 ~/.bashrc。大多数时候，我们对于bash的定制，都是写在这个文件里面的。 你也许会问，要是不进入 non-login shell，岂不是.bashrc就不会运行了，因此bash 也就不能完成定制了？事实上，Debian已经考虑到这个问题了，请打开文件 ~/.profile，可以看到下面的代码： 12345 if [ -n \"$BASH_VERSION\" ]; then if [ -f \"$HOME/.bashrc\" ]; then . \"$HOME/.bashrc\" fi fi 上面代码先判断变量 $BASH_VERSION 是否有值，然后判断主目录下是否存在 .bashrc 文件，如果存在就运行该文件。第三行开头的那个点，是source命令的简写形式，表示运行某个文件，写成 &quot;source ~/.bashrc&quot; 也是可以的。 因此，只要运行 ～/.profile 文件，～/.bashrc 文件就会连带运行。但是上一节的第一种情况提到过，如果存在 ～/.bash_profile 文件，那么有可能不会运行 ～/.profile 文件。解决这个问题很简单，把下面代码写入 .bash_profile 就行了。 123 if [ -f ~/.profile ]; then . ~/.profile fi 这样一来，不管是哪种情况，.bashrc 都会执行，用户的设置可以放心地都写入这个文件了。 Bash的设置之所以如此繁琐，是由于历史原因造成的。早期的时候，计算机运行速度很慢，载入配置文件需要很长时间，Bash的作者只好把配置文件分成了几个部分，阶段性载入。系统的通用设置放在 /etc/profile，用户个人的、需要被所有子进程继承的设置放在 .profile，不需要被继承的设置放在.bashrc。 顺便提一下，除了Linux以外， Mac OS X 使用的shell也是 Bash。但是，它只加载.bash_profile，然后在.bash_profile里面调用.bashrc。而且，不管是ssh登录，还是在图形界面里启动shell窗口，都是如此。 参考 Linux 的启动流程,By 阮一峰","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Systemd 入门教程:「实战篇」","slug":"Systemed-Tutorial-Actual-Combat","date":"2018-02-07T02:36:36.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/07/Systemed-Tutorial-Actual-Combat/","link":"","permalink":"http://blog.caoxl.com/2018/02/07/Systemed-Tutorial-Actual-Combat/","excerpt":"上一篇文章，我介绍了 Systemd 的主要命令，今天介绍如何使用它完成一些基本的任务。 原文地址: http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html","text":"上一篇文章，我介绍了 Systemd 的主要命令，今天介绍如何使用它完成一些基本的任务。 原文地址: http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html 一、开机启动对于那些支持 Systemd 的软件，安装的时候，会自动在 /usr/lib/systemd/system 目录添加一个配置文件。 如果你想让该软件开机启动，就执行下面的命令（以 httpd.service 为例）。 1$ sudo systemctl enable httpd 上面的命令相当于在 /etc/systemd/system 目录添加一个符号链接，指向/usr/lib/systemd/system 里面的 httpd.service 文件。 这是因为开机时，Systemd只执行 /etc/systemd/system 目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。 二、启动服务设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行 systemctl start 命令。 1$ sudo systemctl start httpd 执行上面的命令以后，有可能启动失败，因此要用 systemctl status 命令查看一下该服务的状态。 123456789101112131415161718$ sudo systemctl status httpdhttpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled) Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago Main PID: 4349 (httpd) Status: \"Total requests: 1; Current requests/sec: 0; Current traffic: 0 B/sec\" CGroup: /system.slice/httpd.service ├─4349 /usr/sbin/httpd -DFOREGROUND ├─4350 /usr/sbin/httpd -DFOREGROUND ├─4351 /usr/sbin/httpd -DFOREGROUND ├─4352 /usr/sbin/httpd -DFOREGROUND ├─4353 /usr/sbin/httpd -DFOREGROUND └─4354 /usr/sbin/httpd -DFOREGROUND12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server. 上面的输出结果含义如下。 Loaded行：配置文件的位置，是否设为开机启动 Active行：表示正在运行 Main PID行：主进程ID Status行：由应用本身（这里是 httpd ）提供的软件当前状态 Status行：由应用本身（这里是 httpd ）提供的软件当前状态 日志块：应用的日志 三、停止服务终止正在运行的服务，需要执行 systemctl stop 命令。 1$ sudo systemctl stop httpd.service 有时候，该命令可能没有响应，服务停不下来。这时候就不得不”杀进程”了，向正在运行的进程发出 kill 信号。 1$ sudo systemctl kill httpd.service 此外，重启服务要执行 systemctl restart 命令。 1$ sudo systemctl restart httpd.service 四、读懂配置文件一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。 前面说过，配置文件主要放在 /usr/lib/systemd/system 目录，也可能在/etc/systemd/system 目录。找到配置文件以后，使用文本编辑器打开即可。 systemctl cat命令可以用来查看配置文件，下面以sshd.service文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。 12345678910111213141516171819$ systemctl cat sshd.service[Unit]Description=OpenSSH server daemonDocumentation=man:sshd(8) man:sshd_config(5)After=network.target sshd-keygen.serviceWants=sshd-keygen.service[Service]EnvironmentFile=/etc/sysconfig/sshdExecStart=/usr/sbin/sshd -D $OPTIONSExecReload=/bin/kill -HUP $MAINPIDType=simpleKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target 可以看到，配置文件分成几个区块，每个区块包含若干条键值对。 下面依次解释每个区块的内容。 五、[Unit] 区块：启动顺序与依赖关系。Unit 区块的 : Description 字段给出当前服务的简单描述， Documentation 字段给出文档位置。 接下来的设置是启动顺序和依赖关系，这个比较重要。 After字段：表示如果 network.target 或 sshd-keygen.service 需要启动，那么 sshd.service 应该在它们之后启动。 相应地，还有一个 Before字段，定义sshd.service应该在哪些服务之前启动。 注意: After和Before字段只涉及启动顺序，不涉及依赖关系。 举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。 设置依赖关系，需要使用Wants字段和Requires字段。 Wants字段：表示sshd.service与sshd-keygen.service之间存在”弱依赖”关系，即如果&quot;sshd-keygen.service&quot;启动失败或停止运行，不影响sshd.service继续执行。 Requires字段则表示”强依赖”关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。 注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。 六、[Service] 区块：启动行为Service 区块定义如何启动当前服务。 启动命令许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。 EnvironmentFile 字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。 上面的例子中，sshd 的环境参数文件是 /etc/sysconfig/sshd。 配置文件里面最重要的字段是 ExecStart。 ExecStart字段：定义启动进程时执行的命令。 上面的例子中，启动 sshd ，执行的命令是 /usr/sbin/sshd -D $OPTIONS ，其中的变量 $OPTIONS 就来自 EnvironmentFile 字段指定的环境参数文件。 与之作用相似的，还有如下这些字段。 ExecReload字段：重启服务时执行的命令 ExecStop字段：停止服务时执行的命令 ExecStartPre字段：启动服务之前执行的命令 ExecStartPost字段：启动服务之后执行的命令 ExecStopPost字段：停止服务之后执行的命令 请看下面的例子。 123456[Service]ExecStart=/bin/echo execstart1ExecStart=ExecStart=/bin/echo execstart2ExecStartPost=/bin/echo post1ExecStartPost=/bin/echo post2 上面这个配置文件，第二行 ExecStart 设为空值，等于取消了第一行的设置，运行结果如下。 123execstart2post1post2 所有的启动设置之前，都可以加上一个连词号（-），表示 “抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile=-/etc/sysconfig/sshd（注意等号后面的那个连词号），就表示即使 /etc/sysconfig/sshd 文件不存在，也不会抛出错误。 启动类型Type 字段定义启动类型。它可以设置的值如下。 simple（默认值）：ExecStart字段启动的进程为主进程 forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程 oneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务 dbus：类似于simple，但会等待 D-Bus 信号后启动 notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务 idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合 下面是一个 oneshot 的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。 123456789[Unit]Description=Switch-off Touchpad[Service]Type=oneshotExecStart=/usr/bin/touchpad-off[Install]WantedBy=multi-user.target 上面的配置文件，启动类型设为 oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。 如果关闭以后，将来某个时候还想打开，配置文件修改如下。 1234567891011[Unit]Description=Switch-off Touchpad[Service]Type=oneshotExecStart=/usr/bin/touchpad-off startExecStop=/usr/bin/touchpad-off stopRemainAfterExit=yes[Install]WantedBy=multi-user.target 上面配置文件中，RemainAfterExit字段设为 yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用 systemctl stop 命令停止服务，ExecStop 指定的命令就会执行，从而重新开启触摸板。 重启行为Service 区块有一些字段，定义了重启行为。 KillMode 字段：定义 Systemd 如何停止 sshd 服务。 上面这个例子中，将 KillMode 设为process，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。 KillMode 字段可以设置的值如下。 control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉 process：只杀主进程 mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号 none：没有进程会被杀掉，只是执行服务的 stop 命令。 接下来是Restart字段。 Restart字段：定义了 sshd 退出后，Systemd 的重启方式。 上面的例子中，Restart设为on-failure，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。 Restart 字段可以设置的值如下。 no（默认值）：退出后不会重启 on-success：只有正常退出时（退出状态码为0），才会重启 on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启 on-abnormal：只有被信号终止和超时，才会重启 on-abort：只有在收到没有捕捉到的信号终止时，才会重启 on-watchdog：超时退出，才会重启 always：不管是什么退出原因，总是重启 对于守护进程，推荐设为 on-failure。对于那些允许发生错误退出的服务，可以设为 on-abnormal。 最后是RestartSec字段。 RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。 七、[Install] 区块Install区块，定义如何安装这个配置文件，即怎样做到开机启动。 WantedBy字段：表示该服务所在的 Target。 Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd 所在的 Target 是multi-user.target。 这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在/etc/systemd/system目录下面的multi-user.target.wants子目录之中。 Systemd 有默认的启动 Target。 123$ systemctl get-defaultmulti-user.target 上面的结果表示，默认的启动 Target 是 multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么 systemctl enable 命令能设置开机启动的原因。 使用 Target 的时候，systemctl list-dependencies 命令和 systemctl isolate 命令也很有用。 123456# 查看 multi-user.target 包含的所有服务$ systemctl list-dependencies multi-user.target# 切换到另一个 target# shutdown.target 就是关机状态$ sudo systemctl isolate shutdown.target 一般来说，常用的 Target 有两个： 一个是multi-user.target，表示多用户命令行状态； 另一个是graphical.target，表示图形用户状态，它依赖于multi-user.target。 官方文档有一张非常清晰的 Target 依赖关系图 。 八、Target 的配置文件Target 也有自己的配置文件。 123456789$ systemctl cat multi-user.target[Unit]Description=Multi-User SystemDocumentation=man:systemd.special(7)Requires=basic.targetConflicts=rescue.service rescue.targetAfter=basic.target rescue.service rescue.targetAllowIsolate=yes 注意，Target 配置文件里面没有启动命令。 上面输出结果中，主要字段含义如下。 Requires字段：要求basic.target一起运行。 Conflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。 After：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话 AllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。 九、修改配置文件后重启修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。 12345# 重新加载配置文件$ sudo systemctl daemon-reload# 重启相关服务$ sudo systemctl restart foobar","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Systemd","slug":"Systemd","permalink":"http://blog.caoxl.com/tags/Systemd/"}]},{"title":"Systemd 入门教程:「命令篇」","slug":"Systemed-Tutorial-Commands","date":"2018-02-07T02:34:22.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/07/Systemed-Tutorial-Commands/","link":"","permalink":"http://blog.caoxl.com/2018/02/07/Systemed-Tutorial-Commands/","excerpt":"Systemd 是 Linux 系统工具，用来启动 守护进程，已成为大多数发行版的标准配置。 本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。","text":"Systemd 是 Linux 系统工具，用来启动 守护进程，已成为大多数发行版的标准配置。 本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。 原文地址: http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html 一、由来历史上，Linux 的启动一直采用init进程。 下面的命令用来启动服务。 1234$ sudo /etc/init.d/apache2 start# 或者$ service apache2 start 这种方法有两个缺点。 一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。 二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。 二、Systemd 概述Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。 根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。 使用了 Systemd，就不需要再用init了。Systemd 取代了initd`，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。 1$ systemctl --version 上面的命令查看 Systemd 的版本。 Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的 Unix 哲学。 三、系统管理Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。 systemctlsystemctl 是 Systemd 的主命令，用于管理系统。 1234567891011121314151617181920# 重启系统$ sudo systemctl reboot# 关闭系统，切断电源$ sudo systemctl poweroff# CPU停止工作$ sudo systemctl halt# 暂停系统$ sudo systemctl suspend# 让系统进入冬眠状态$ sudo systemctl hibernate# 让系统进入交互式休眠状态$ sudo systemctl hybrid-sleep# 启动进入救援状态（单用户状态）$ sudo systemctl rescue systemd-analyzesystemd-analyze命令用于查看启动耗时。 1234567891011# 查看启动耗时$ systemd-analyze # 查看每个服务的启动耗时$ systemd-analyze blame# 显示瀑布状的启动过程流$ systemd-analyze critical-chain# 显示指定服务的启动流$ systemd-analyze critical-chain atd.service hostnamectlhostnamectl命令用于查看当前主机的信息。 12345# 显示当前主机的信息$ hostnamectl# 设置主机名。$ sudo hostnamectl set-hostname rhel7 localectllocalectl 命令用于查看本地化设置。 123456# 查看本地化设置$ localectl# 设置本地化参数。$ sudo localectl set-locale LANG=en_GB.utf8$ sudo localectl set-keymap en_GB timedatectltimedatectl 命令用于查看当前时区设置。 12345678910# 查看当前时区设置$ timedatectl# 显示所有可用的时区$ timedatectl list-timezones # 设置当前时区$ sudo timedatectl set-timezone America/New_York$ sudo timedatectl set-time YYYY-MM-DD$ sudo timedatectl set-time HH:MM:SS loginctlloginctl 命令用于查看当前登录的用户。 12345678# 列出当前session$ loginctl list-sessions# 列出当前登录用户$ loginctl list-users# 列出显示指定用户的信息$ loginctl show-user ruanyf 四、Unit含义Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。 Unit 一共分成12种。 12345678910111213141516171819202122231. Service unit：系统服务2. Target unit：多个 Unit 构成的一个组3. Device Unit：硬件设备4. Mount Unit：文件系统的挂载点5. Automount Unit：自动挂载点6. Path Unit：文件或路径7. Scope Unit：不是由 Systemd 启动的外部进程8. Slice Unit：进程组9. Snapshot Unit：Systemd 快照，可以切回某个快照10. Socket Unit：进程间通信的 socket11. Swap Unit：swap 文件12. Timer Unit：定时器 systemctl list-units命令可以查看当前系统的所有 Unit 。 1234567891011121314# 列出正在运行的 Unit$ systemctl list-units# 列出所有Unit，包括没有找到配置文件的或者启动失败的$ systemctl list-units --all# 列出所有没有运行的 Unit$ systemctl list-units --all --state=inactive# 列出所有加载失败的 Unit$ systemctl list-units --failed# 列出所有正在运行的、类型为 service 的 Unit$ systemctl list-units --type=service Unit 的状态systemctl status命令用于查看系统状态和单个 Unit 的状态。 12345678# 显示系统状态$ systemctl status# 显示单个 Unit 的状态$ sysystemctl status bluetooth.service# 显示远程主机的某个 Unit 的状态$ systemctl -H root@rhel7.example.com status httpd.service 除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。 12345678# 显示某个 Unit 是否正在运行$ systemctl is-active application.service# 显示某个 Unit 是否处于启动失败状态$ systemctl is-failed application.service# 显示某个 Unit 服务是否建立了启动链接$ systemctl is-enabled application.service Unit 管理对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。 1234567891011121314151617181920212223242526# 立即启动一个服务$ sudo systemctl start apache.service# 立即停止一个服务$ sudo systemctl stop apache.service# 重启一个服务$ sudo systemctl restart apache.service# 杀死一个服务的所有子进程$ sudo systemctl kill apache.service# 重新加载一个服务的配置文件$ sudo systemctl reload apache.service# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 显示某个 Unit 的所有底层参数$ systemctl show httpd.service# 显示某个 Unit 的指定属性的值$ systemctl show -p CPUShares httpd.service# 设置某个 Unit 的指定属性$ sudo systemctl set-property httpd.service CPUShares=500 依赖关系Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。 systemctl list-dependencies命令列出一个 Unit 的所有依赖。 1$ systemctl list-dependencies nginx.service 上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用--all参数。 1$ systemctl list-dependencies --all nginx.service 五、Unit 的配置文件概述每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。 Systemd 默认从目录 /etc/systemd/system/ 读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 /usr/lib/systemd/system/，真正的配置文件存放在那个目录。 systemctl enable 命令用于在上面两个目录之间，建立符号链接关系。 1234$ sudo systemctl enable clamd@scan.service# 等同于$ sudo ln -s '/usr/lib/systemd/system/clamd@scan.service' '/etc/systemd/system/multi-user.target.wants/clamd@scan.service' 如果配置文件里面设置了开机启动，systemctl enable 命令相当于激活开机启动。 与之对应的，systemctl disable 命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。 1$ sudo systemctl disable clamd@scan.service 配置文件的后缀名，就是该 Unit 的种类，比如 sshd.socket 。如果省略，Systemd 默认后缀名为 .service ，所以sshd会被理解成sshd.service 。 配置文件的状态systemctl list-unit-files 命令用于列出所有配置文件。 12345# 列出所有配置文件$ systemctl list-unit-files# 列出指定类型的配置文件$ systemctl list-unit-files --type=service 这个命令会输出一个列表。 123456$ systemctl list-unit-filesUNIT FILE STATEchronyd.service enabledclamd@.service staticclamd@scan.service disabled 这个列表显示每个配置文件的状态，一共有四种。 enabled：已建立启动链接 disabled：没建立启动链接 static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖 masked：该配置文件被禁止建立启动链接 注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。 1$ systemctl status bluetooth.service 一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。 12$ sudo systemctl daemon-reload$ sudo systemctl restart httpd.service 配置文件的格式配置文件就是普通的文本文件，可以用文本编辑器打开。 systemctl cat命令可以查看配置文件的内容。 1234567891011$ systemctl cat atd.service[Unit]Description=ATD daemon[Service]Type=forkingExecStart=/usr/bin/atd[Install]WantedBy=multi-user.target 从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如 [Unit] 。 注意，配置文件的区块名和字段名，都是大小写敏感的。 每个区块内部是一些等号连接的键值对。 12345[Section]Directive1=valueDirective2=value. . . 注意，键值对的等号两侧不能有空格。 配置文件的区块[Unit] 区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。 Description：简短描述 Documentation：文档地址 Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败 Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败 BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行 Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动 After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动 Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行 Condition…：当前 Unit 运行必须满足的条件，否则不会运行 Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败 [Install] 通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。 WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中 RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中 Alias：当前 Unit 可用于启动的别名 Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit [Service] 区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。 Type：定义启动时的进程行为。它有以下几种值。 Type=simple：默认值，执行ExecStart指定的命令，启动主进程 Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出 Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行 Type=dbus：当前服务通过D-Bus启动 Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行 Type=idle：若有其他任务执行完毕，当前服务才会运行 ExecStart：启动当前服务的命令 ExecStartPre：启动当前服务之前执行的命令 ExecStartPost：启动当前服务之后执行的命令 ExecReload：重启当前服务时执行的命令 ExecStop：停止当前服务时执行的命令 ExecStopPost：停止当其服务之后执行的命令 RestartSec：自动重启当前服务间隔的秒数 Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数 Environment：指定环境变量 Unit 配置文件的完整字段清单，请参考 官方文档。 六、Target启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。 简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。 传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。 12345678910111213141516# 查看当前系统的所有 Target$ systemctl list-unit-files --type=target# 查看一个 Target 包含的所有 Unit$ systemctl list-dependencies multi-user.target# 查看启动时的默认 Target$ systemctl get-default# 设置启动时的默认 Target$ sudo systemctl set-default multi-user.target# 切换 Target 时，默认不关闭前一个 Target 启动的进程，# systemctl isolate 命令改变这种行为，# 关闭前一个 Target 里面所有不属于后一个 Target 的进程$ sudo systemctl isolate multi-user.target Target 与 传统 RunLevel 的对应关系如下。 123456789Traditional runlevel New target name Symbolically linked to...Runlevel 0 | runlevel0.target -&gt; poweroff.targetRunlevel 1 | runlevel1.target -&gt; rescue.targetRunlevel 2 | runlevel2.target -&gt; multi-user.targetRunlevel 3 | runlevel3.target -&gt; multi-user.targetRunlevel 4 | runlevel4.target -&gt; multi-user.targetRunlevel 5 | runlevel5.target -&gt; graphical.targetRunlevel 6 | runlevel6.target -&gt; reboot.target 它与 init 进程的主要差别如下。 （1）默认的 RunLevel（在 /etc/inittab 文件设置）现在被默认的 Target 取代，位置是 /etc/systemd/system/default.target，通常符号链接到 graphical.target（图形界面）或者multi-user.target（多用户命令行）。 （2）启动脚本的位置，以前是 /etc/init.d 目录，符号链接到不同的 RunLevel 目录 （比如 /etc/rc3.d、/etc/rc5.d 等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。 （3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。 七、日志管理Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用 journalctl 一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是 /etc/systemd/journald.conf 。 journalctl 功能强大，用法非常多。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 查看所有日志（默认情况下 ，只保存本次启动的日志）$ sudo journalctl# 查看内核日志（不显示应用日志）$ sudo journalctl -k# 查看系统本次启动的日志$ sudo journalctl -b$ sudo journalctl -b -0# 查看上一次启动的日志（需更改设置）$ sudo journalctl -b -1# 查看指定时间的日志$ sudo journalctl --since=\"2012-10-30 18:17:16\"$ sudo journalctl --since \"20 min ago\"$ sudo journalctl --since yesterday$ sudo journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"$ sudo journalctl --since 09:00 --until \"1 hour ago\"# 显示尾部的最新10行日志$ sudo journalctl -n# 显示尾部指定行数的日志$ sudo journalctl -n 20# 实时滚动显示最新日志$ sudo journalctl -f# 查看指定服务的日志$ sudo journalctl /usr/lib/systemd/systemd# 查看指定进程的日志$ sudo journalctl _PID=1# 查看某个路径的脚本的日志$ sudo journalctl /usr/bin/bash# 查看指定用户的日志$ sudo journalctl _UID=33 --since today# 查看某个 Unit 的日志$ sudo journalctl -u nginx.service$ sudo journalctl -u nginx.service --since today# 实时滚动显示某个 Unit 的最新日志$ sudo journalctl -u nginx.service -f# 合并显示多个 Unit 的日志$ journalctl -u nginx.service -u php-fpm.service --since today# 查看指定优先级（及其以上级别）的日志，共有8级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debug$ sudo journalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出$ sudo journalctl --no-pager# 以 JSON 格式（单行）输出$ sudo journalctl -b -u nginx.service -o json# 以 JSON 格式（多行）输出，可读性更好$ sudo journalctl -b -u nginx.serviceqq -o json-pretty# 显示日志占据的硬盘空间$ sudo journalctl --disk-usage# 指定日志文件占据的最大空间$ sudo journalctl --vacuum-size=1G# 指定日志文件保存多久$ sudo journalctl --vacuum-time=1years","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Systemd","slug":"Systemd","permalink":"http://blog.caoxl.com/tags/Systemd/"}]},{"title":"Unix 哲学","slug":"About-UNIX-Philosophy","date":"2018-02-07T02:23:19.000Z","updated":"2019-08-22T03:45:18.000Z","comments":true,"path":"2018/02/07/About-UNIX-Philosophy/","link":"","permalink":"http://blog.caoxl.com/2018/02/07/About-UNIX-Philosophy/","excerpt":"原文地址: http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html 我在看Unix，发现很多人在谈”Unix哲学”，也就是开发Unix系统的指导思想。 Wikipedia上列出了好几个版本，不同的人有不同的总结。发明管道命令的Doug McIlroy总结了三条，而Eric S. Raymond则在The Art of Unix Programming一书中，一口气总结了17条（英文版，中文版）。","text":"原文地址: http://www.ruanyifeng.com/blog/2009/06/unix_philosophy.html 我在看Unix，发现很多人在谈”Unix哲学”，也就是开发Unix系统的指导思想。 Wikipedia上列出了好几个版本，不同的人有不同的总结。发明管道命令的Doug McIlroy总结了三条，而Eric S. Raymond则在The Art of Unix Programming一书中，一口气总结了17条（英文版，中文版）。 但是我发现，所有人都同意，“简单原则”—-尽量用简单的方法解决问题—-是”Unix哲学”的根本原则。这也就是著名的KISS（keep it simple, stupid），意思是”保持简单和笨拙”。 下面就是我对”简单原则”的笔记。如果你想最简单地完成一项编程任务，我认为可以从四个方面入手： 一、清晰原则。代码要写得尽量清晰，避免晦涩难懂。清晰的代码不容易崩溃，而且容易理解和维护。重视注释。不为了性能的一丁点提升，而大幅增加技术的复杂性，因为复杂的技术会使得日后的阅读和维护更加艰难。 二、模块原则。每个程序只做一件事，不要试图在单个程序中完成多个任务。在程序的内部，面向用户的界面（前端）应该与运算机制（后端）分离，因为前端的变化往往快于后端。 三、组合原则。不同的程序之间通过接口相连。接口之间用文本格式进行通信，因为文本格式是最容易处理、最通用的格式。这就意味着尽量不要使用二进制数据进行通信，不要把二进制内容作为输出和输入。 四、优化原则。在功能实现之前，不要考虑对它优化。最重要的是让一切先能够运行，其次才是效率。“先求运行，再求正确，最后求快。”（Make it run, then make it right, then make it fast.）90%的功能现在能实现，比100%的功能永远实现不了强。先做出原型，然后找出哪些功能不必实现，那些不用写的代码显然无需优化。目前，最强大的优化工具恐怕是Delete键。","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"Unix","slug":"Unix","permalink":"http://blog.caoxl.com/tags/Unix/"}]},{"title":"SSL延迟有多大？","slug":"SSL-Latency","date":"2018-02-06T06:47:27.000Z","updated":"2019-08-22T03:46:04.000Z","comments":true,"path":"2018/02/06/SSL-Latency/","link":"","permalink":"http://blog.caoxl.com/2018/02/06/SSL-Latency/","excerpt":"据说，Netscape公司当年设计SSL协议的时候，有人提过，将互联网所有链接都变成HTTPs开头的加密链接。 这个建议没有得到采纳，原因之一是HTTPs链接比不加密的HTTP链接慢很多。（另一个原因好像是，HTTPs链接默认不能缓存。） 自从我知道这个掌故以后，脑袋中就有一个观念：HTTPs链接很慢。但是，它到底有多慢，我并没有一个精确的概念。直到今天我从一篇文章中，学到了测量HTTPs链接耗时的方法。","text":"据说，Netscape公司当年设计SSL协议的时候，有人提过，将互联网所有链接都变成HTTPs开头的加密链接。 这个建议没有得到采纳，原因之一是HTTPs链接比不加密的HTTP链接慢很多。（另一个原因好像是，HTTPs链接默认不能缓存。） 自从我知道这个掌故以后，脑袋中就有一个观念：HTTPs链接很慢。但是，它到底有多慢，我并没有一个精确的概念。直到今天我从一篇文章中，学到了测量HTTPs链接耗时的方法。 原文地址: http://www.ruanyifeng.com/blog/2014/09/ssl-latency.html 首先我解释一下，为什么HTTPs链接比较慢。 HTTPs链接和HTTP链接都建立在TCP协议之上。HTTP链接比较单纯，使用三个握手数据包建立连接之后，就可以发送内容数据了。 上图中，客户端首先发送SYN数据包，然后服务器发送SYN+ACK数据包，最后客户端发送ACK数据包，接下来就可以发送内容了。这三个数据包的发送过程，叫做TCP握手。 再来看HTTPs链接，它也采用TCP协议发送数据，所以它也需要上面的这三步握手过程。而且，在这三步结束以后，它还有一个SSL握手。 总结一下，就是下面这两个式子。 123HTTP耗时 = TCP握手HTTPs耗时 = TCP握手 + SSL握手 所以，HTTPs肯定比HTTP耗时，这就叫SSL延迟。 命令行工具curl有一个w参数，可以用来测量TCP握手和SSL握手的具体耗时，以访问支付宝为例。 123$ curl -w \"TCP handshake: %&#123;time_connect&#125;, SSL handshake: %&#123;time_appconnect&#125;\\n\" -so /dev/null https://www.alipay.comTCP handshake: 0.022, SSL handshake: 0.064 上面命令中的w参数表示指定输出格式，time_connect变量表示TCP握手的耗时，time_appconnect变量表示SSL握手的耗时（更多变量请查看文档和实例），s参数和o参数用来关闭标准输出。 从运行结果可以看到，SSL握手的耗时（64毫秒）大概是TCP握手（22毫秒）的三倍。也就是说，在建立连接的阶段，HTTPs链接比HTTP链接要长3倍的时间，具体数字取决于CPU的快慢和网络状况。 所以，如果是对安全性要求不高的场合，为了提高网页性能，建议不要采用保密强度很高的数字证书。一般场合下，1024位的证书已经足够了，2048位和4096位的证书将进一步延长SSL握手的耗时。","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"http://blog.caoxl.com/tags/SSL/"}]},{"title":"HTTPS的七个误解","slug":"Top-7-Myths-About-HTTPS","date":"2018-02-06T06:16:18.000Z","updated":"2019-08-22T03:45:41.000Z","comments":true,"path":"2018/02/06/Top-7-Myths-About-HTTPS/","link":"","permalink":"http://blog.caoxl.com/2018/02/06/Top-7-Myths-About-HTTPS/","excerpt":"HTTPS的七个误解 原文网址：http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/ 翻译文网址: http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html","text":"HTTPS的七个误解 原文网址：http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/ 翻译文网址: http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html 误解七：HTTPS无法缓存许多人以为，出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。 微软的IE项目经理 Eric Lawrence写道： “说来也许令人震惊，只要HTTP头允许这样做，所有版本的IE都缓存HTTPS内容。比如，如果头命令是Cache-Control: max-age=600，那么这个网页就将被IE缓存10分钟。IE的缓存策略，与是否使用HTTPS协议无关。（其他浏览器在这方面的行为不一致，取决于你使用的版本，所以这里不加以讨论。）” Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。下面的图片显示，Firefox的硬盘缓存中有HTTPS内容，头命令正是Cache-Control:Public。 误解六：SSL证书很贵如果你在网上搜一下，就会发现很多便宜的SSL证书，大概10美元一年，这和一个.com域名的年费差不多。而且事实上，还能找到免费的SSL证书。 在效力上，便宜的证书当然会比大机构颁发的证书差一点，但是几乎所有的主流浏览器都接受这些证书。 误解五：HTTPS站点必须有独享的IP地址由于IPv4将要分配完毕，所以很多人关心这个问题。每个IP地址只能安装一张SSL证书，这是毫无疑问的。但是，如果你使用子域名通配符SSL证书（wildcard SSL certificate，价格大约是每年125美元），就能在一个IP地址上部署多个HTTPS子域名。比如，https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。 另外， UCC（统一通信证书，Unified Communications Certificate）支持一张证书同时匹配多个站点，可以是完全不同的域名。 SNI（服务器名称指示，Server Name Indication）允许一个IP地址上多个域名安装多张证书。 服务器端，Apache和Nginx支持该技术，IIS不支持；客户端，IE 7+、Firefox 2.0+、Chrome 6+、Safari 2.1+和Opera 8.0+支持。 误解四：转移服务器时要购买新证书部署SSL证书，需要这样几步： 12345 1. 在你的服务器上，生成一个CSR文件（SSL证书请求文件，SSL Certificate Signing Request）。 2. 使用CSR文件，购买SSL证书。 3. 安装SSL证书。 这些步骤都经过精心设计，保证传输的安全，防止有人截取或非法获得证书。结果就是，你在第二步得到的证书不能用在另一台服务器上。如果你需要这样做，就必须以其他格式输出证书。 比如，IIS的做法是生成一个可以转移的.pfx文件，并加以密码保护。 将这个文件传入其他服务器，将可以继续使用原来的SSL证书了。 误解三：HTTPS太慢使用HTTPS不会使你的网站变得更快（实际上有可能，请看下文），但是有一些 技巧可以大大减少额外开销。 首先，只要压缩文本内容，就会降低解码耗用的CPU资源。不过，对于当代CPU来说，这点开销不值一提。 其次，建立HTTPS连接，要求额外的TCP往返，因此会新增一些发送和接收的字节。但是，从下图可以看到，新增的字节是很少的。 第一次打开网页的时候，HTTPS协议会比HTTP协议慢一点，这是因为读取和验证SSL证书的时间。下面是一张HTTP网页打开时间的瀑布图。 同一张网页使用HTTPS协议之后，打开时间变长了。 建立连接的部分，大约慢了10%。但是，一旦有效的HTTPS连接建立起来，再刷新网页，两种协议几乎没有区别。先是HTTP协议的刷新表现： 然后是HTTPS协议： 某些用户可能发现，HTTPS比HTTP更快一点。这会发生在一些大公司的内部局域网，因为通常情况下，公司的网关会截取并分析所有的网络通信。但是，当它遇到HTTPS连接时，它就只能直接放行，因为HTTPS无法被解读。正是因为少了这个解读的过程，所以HTTPS变得比较快。 误解二：有了HTTPS，Cookie和查询字符串就安全了虽然无法直接从HTTPS数据中读取Cookie和查询字符串，但是你仍然需要使它们的值变得难以预测。 比如，曾经有一家英国银行，直接使用顺序排列的数值表示session id: 黑客可以先注册一个账户，找到这个cookie，看到这个值的表示方法。然后，改动cookie，从而劫持其他人的session id。至于查询字符串，也可以通过类似方式泄漏。 误解一：只有注册登录页，才需要HTTPS这种想法很普遍。人们觉得，HTTPS可以保护用户的密码，此外就不需要了。Firefox浏览器新插件Firesheep，证明了这种想法是错的。我们可以看到，在Twitter和Facebook上，劫持其他人的session是非常容易的。 咖啡馆的免费WiFi，就是一个很理想的劫持环境，因为两个原因： 1231. 这种WiFi通常不会加密，所以很容易监控所有流量。2. WiFi通常使用NAT进行外网和内网的地址转换，所有内网客户端都共享一个外网地址。这意味着，被劫持的session，看上去很像来自原来的登录者。 以Twitter为例，它的登录页使用了HTTPS，但是登录以后，其他页面就变成了HTTP。这时，它的cookie里的session值就暴露了。 也就是说，这些cookie是在HTTPS环境下建立的，但是却在HTTP环境下传输。如果有人劫持到这些cookie，那他就能以你的身份在Twitter上发言了。","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://blog.caoxl.com/tags/HTTPS/"},{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"}]},{"title":"SSL/TLS协议 运行机制","slug":"SSL-TLS-Protocol-Operating-Mechanism","date":"2018-02-06T03:20:13.000Z","updated":"2019-08-22T03:45:47.000Z","comments":true,"path":"2018/02/06/SSL-TLS-Protocol-Operating-Mechanism/","link":"","permalink":"http://blog.caoxl.com/2018/02/06/SSL-TLS-Protocol-Operating-Mechanism/","excerpt":"互联网的通信安全，建立在SSL/TLS协议之上。 本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅 RFC文档。","text":"互联网的通信安全，建立在SSL/TLS协议之上。 本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅 RFC文档。 一、作用不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。 （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。 （2） 篡改风险（tampering）：第三方可以修改通信内容。 （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS协议是为了解决这三大风险而设计的，希望达到： （1） 所有信息都是加密传播，第三方无法窃听。 （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。 （3） 配备身份证书，防止身份被冒充。 互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。 二、历史互联网加密通信协议的历史，几乎与互联网一样长。 1234567891994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。1996年，SSL 3.0版问世，得到大规模应用。1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。 目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。 TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。 三、基本的运行过程SSL/TLS协议的基本思路是采用公钥加密法，也就是说， 客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密 但是，这里有两个问题。 （1）如何保证公钥不被篡改？ 解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。 （2）公钥加密计算量太大，如何减少耗用的时间？ 1解决方法：每一次对话（session），客户端和服务器端都生成一个\"对话密钥\"（session key），用它来加密信息。由于\"对话密钥\"是对称加密，所以运算速度非常快，而服务器公钥只用于加密\"对话密钥\"本身，这样就减少了加密运算的消耗时间。 因此，SSL/TLS协议的基本过程是这样的： （1） 客户端向服务器端索要并验证公钥。 （2） 双方协商生成”对话密钥”。 （3） 双方采用”对话密钥”进行加密通信。 上面过程的前两步，又称为“握手阶段”（handshake）。 四、握手阶段的详细过程 “握手阶段”涉及四次通信，我们一个个来看。需要注意的是，”握手阶段”的所有通信都是明文的。 客户端发出请求（ClientHello）首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。 在这一步，客户端主要向服务器提供以下信息。 1234567（1） 支持的协议版本，比如TLS 1.0版。（2） 一个客户端生成的随机数，稍后用于生成\"对话密钥\"。（3） 支持的加密方法，比如RSA公钥加密。（4） 支持的压缩方法。 这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。 对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。 服务器回应（SeverHello）服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。 1234567（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。（2） 一个服务器生成的随机数，稍后用于生成\"对话密钥\"。（3） 确认使用的加密方法，比如RSA公钥加密。（4） 服务器证书。 除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。 客户端回应客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 12345（1） 一个随机数。该随机数用服务器公钥加密，防止被窃听。（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。 上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称&quot;pre-master key&quot;。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。 至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好： “不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。 对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。 pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。” 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。 123（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。 参考 SSL/TLS协议运行机制的概述","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"http://blog.caoxl.com/tags/SSL/"},{"name":"TLS","slug":"TLS","permalink":"http://blog.caoxl.com/tags/TLS/"}]},{"title":"图解SSL/TLS协议","slug":"SSL-TLS-Protocol","date":"2018-02-06T03:19:44.000Z","updated":"2019-08-22T03:45:51.000Z","comments":true,"path":"2018/02/06/SSL-TLS-Protocol/","link":"","permalink":"http://blog.caoxl.com/2018/02/06/SSL-TLS-Protocol/","excerpt":"Internet,这一分类的内容,均是从各个大神博客转载而来,本想自己总结一番,不过发现前人已经做得足够好了,就不重复造轮子了 原文地址: http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html","text":"Internet,这一分类的内容,均是从各个大神博客转载而来,本想自己总结一番,不过发现前人已经做得足够好了,就不重复造轮子了 原文地址: http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html CloudFlare宣布，开始提供Keyless服务，即你把网站放到它们的CDN上，不用提供自己的私钥，也能使用SSL加密链接。 我看了CloudFlare的说明（这里和这里），突然意识到这是绝好的例子，可以用来说明SSL/TLS协议的运行机制。它配有插图，很容易看懂。 一、SSL协议的握手过程开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。 假定客户端叫做爱丽丝，服务器叫做鲍勃，整个握手过程可以用下图说明（点击看大图）。 握手阶段分成五步。 123456789第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成\"对话密钥\"（session key），用来加密接下来的整个对话过程。 上面的五步，画成一张图，就是下面这样。 二、私钥的作用握手阶段有三点需要注意。 12345（1）生成对话密钥一共需要三个随机数。（2）握手之后的对话使用\"对话密钥\"加密（对称加密），服务器的公钥和私钥只用于加密和解密\"对话密钥\"（非对称加密），无其他作用。（3）服务器公钥放在服务器的数字证书之中。 从上面第二点可知，整个对话过程中（握手阶段和其后的对话），服务器的公钥和私钥只需要用到一次。这就是CloudFlare能够提供Keyless服务的根本原因。 某些客户（比如银行）想要使用外部CDN，加快自家网站的访问速度，但是出于安全考虑，不能把私钥交给CDN服务商。这时，完全可以把私钥留在自家服务器，只用来解密对话密钥，其他步骤都让CDN服务商去完成。 三、DH算法的握手阶段整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。 虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的RSA算法，改为 Diffie-Hellman算法（简称DH算法）。 采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。 上图中，第三步和第四步由传递Premaster secret变成了传递DH算法所需的参数，然后双方各自算出Premaster secret。这样就提高了安全性。 四、session的恢复握手阶段用来建立SSL连接。如果出于某种原因，对话中断，就需要重新握手。 这时有两种方法可以恢复原来的session： 一种叫做session ID，另一种叫做session ticket。 session ID的思想很简单，就是每一次对话都有一个编号（session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。 上图中，客户端给出session ID，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信。 session ID是目前所有浏览器都支持的方法，但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。 上图中，客户端不再发送session ID，而是发送一个服务器在上一次对话中发送过来的session ticket。这个session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。 参考 图解SSL/TLS协议 ,By 阮一峰","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"SSL","slug":"SSL","permalink":"http://blog.caoxl.com/tags/SSL/"},{"name":"TLS","slug":"TLS","permalink":"http://blog.caoxl.com/tags/TLS/"}]},{"title":"跨域资源共享 CORS 详解","slug":"CORS-Cross-Origin-Resource-Sharing","date":"2018-02-06T02:33:08.000Z","updated":"2019-08-22T03:46:15.000Z","comments":true,"path":"2018/02/06/CORS-Cross-Origin-Resource-Sharing/","link":"","permalink":"http://blog.caoxl.com/2018/02/06/CORS-Cross-Origin-Resource-Sharing/","excerpt":"CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出 XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。","text":"CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出 XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。 原文地址: http://www.ruanyifeng.com/blog/2016/04/cors.html 一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 1234567891011121314(1) 请求方法是以下三种方法之一： HEAD GET POST (2) HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 三、简单请求基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段： Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。 如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)`可以返回FooBar字段的值 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开 withCredentials 属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的 document.cookie 也无法读取服务器域名下的Cookie。 四、非简单请求预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为“预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是 X-Custom-Header。 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号(*)，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin 字段是每次回应都必定包含的。 五、与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。 JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"CORS","slug":"CORS","permalink":"http://blog.caoxl.com/tags/CORS/"}]},{"title":"DNS 原理入门","slug":"DNS-Principles-Intro","date":"2018-02-05T08:19:11.000Z","updated":"2019-08-22T03:46:44.000Z","comments":true,"path":"2018/02/05/DNS-Principles-Intro/","link":"","permalink":"http://blog.caoxl.com/2018/02/05/DNS-Principles-Intro/","excerpt":"DNS 是互联网核心协议之一。不管是上网浏览，还是编程开发，都需要了解一点它的知识。 本文详细介绍DNS的原理，以及如何运用工具软件观察它的运作。我的目标是，读完此文后，你就能完全理解DNS。","text":"DNS 是互联网核心协议之一。不管是上网浏览，还是编程开发，都需要了解一点它的知识。 本文详细介绍DNS的原理，以及如何运用工具软件观察它的运作。我的目标是，读完此文后，你就能完全理解DNS。 原文地址: http://www.ruanyifeng.com/blog/2016/06/dns.html 一、DNS 是什么？DNS （Domain Name System 的缩写）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。 Domain Name System 域名系统 举例来说，如果你要访问域名math.stackexchange.com，首先要通过DNS查出它的IP地址是151.101.129.69。 如果你不清楚为什么一定要查出IP地址，才能进行网络通信，建议先阅读我写的 《互联网协议入门》。 二、查询过程虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。 工具软件dig可以显示整个查询过程。 1dig math.stackexchange.com 上面的命令会输出六段信息。 第一段是查询参数和统计。 第二段是查询内容。 上面结果表示，查询域名math.stackexchange.com的A记录，A是address的缩写。 第三段是DNS服务器的答复。 上面结果显示，math.stackexchange.com有四个A记录，即四个IP地址。600是TTL值（Time to live 的缩写），表示缓存时间，即600秒之内不用重新查询。 第四段显示stackexchange.com的NS记录（Name Server的缩写），即哪些服务器负责管理stackexchange.com的DNS记录。 上面结果显示stackexchange.com共有四条NS记录，即四个域名服务器，向其中任一台查询就能知道math.stackexchange.com的IP地址是什么。 第五段是上面四个域名服务器的IP地址，这是随着前一段一起返回的。 第六段是DNS服务器的一些传输信息。 上面结果显示，本机的DNS服务器是192.168.1.253，查询端口是53（DNS服务器的默认端口），以及回应长度是305字节。 如果不想看到这么多内容，可以使用+short参数。 123456dig +short math.stackexchange.com151.101.129.69151.101.65.69151.101.193.69151.101.1.69 上面命令只返回math.stackexchange.com对应的4个IP地址（即A记录）。 三、DNS服务器下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名math.stackexchange.com的IP地址。 首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。 DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。 上例的DNS服务器是192.168.1.253，这是一个内网地址。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的8.8.8.8和Level 3的4.2.2.2。 本机只向自己的DNS服务器查询，dig命令有一个@参数，显示向其他DNS服务器查询的结果。 1dig @4.2.2.2 math.stackexchange.com 上面命令指定向DNS服务器4.2.2.2查询。 四、域名的层级DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。 请仔细看前面的例子，每个域名的尾部都多了一个点。 比如，域名math.stackexchange.com显示为math.stackexchange.com.。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。 举例来说，www.example.com真正的域名是www.example.com.root，简写为www.example.com.。因为，根域名.root对于所有域名都是一样的，所以平时是省略的。 根域名的下一级，叫做 “顶级域名” （top-level domain，缩写为TLD），比如.com、.net；再下一级叫做 “次级域名” （second-level domain，缩写为SLD），比如www.example.com里面的`.example`，这一级域名是用户可以注册的；再下一级是主机名（host），比如`www.example.com`里面的`www`，又称为 “三级域名” ，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。 总结一下，域名的层级结构如下。 12345主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root 五、根域名服务器DNS服务器根据域名的层级，进行分级查询。 需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。 所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下。 12345从\"根域名服务器\"查到\"顶级域名服务器\"的NS记录和A记录（IP地址）从\"顶级域名服务器\"查到\"次级域名服务器\"的NS记录和A记录（IP地址）从\"次级域名服务器\"查出\"主机名\"的IP地址 仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道”根域名服务器”的IP地址。回答是”根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。 下面是内置的根域名服务器IP地址的一个例子。 上面列表中，列出了根域名（.root）的三条NS记录A.ROOT-SERVERS.NET、B.ROOT-SERVERS.NET和C.ROOT-SERVERS.NET，以及它们的IP地址（即A记录）198.41.0.4、192.228.79.201、192.33.4.12。 另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。 目前，世界上一共有十三组根域名服务器，从A.ROOT-SERVERS.NET一直到M.ROOT-SERVERS.NET。 六、分级查询的实例dig命令的+trace参数可以显示DNS的整个分级查询过程。 1dig +trace math.stackexchange.com 上面命令的第一段列出根域名.的所有NS记录，即所有根域名服务器。 根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问math.stackexchange.com的顶级域名服务器com.的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。 接着是第二段。 上面结果显示.com域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。 然后，DNS服务器向这些顶级域名服务器发出查询请求，询问math.stackexchange.com的次级域名stackexchange.com的NS记录。 上面结果显示stackexchange.com有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。 然后，DNS服务器向上面这四台NS服务器查询math.stackexchange.com的主机名。 上面结果显示，math.stackexchange.com有4条A记录，即这四个IP地址都可以访问到网站。并且还显示，最先返回结果的NS服务器是ns-463.awsdns-57.com，IP地址为205.251.193.207。 七、NS 记录的查询dig命令可以单独查看每一级域名的NS记录。 123dig ns comdig ns stackexchange.com +short参数可以显示简化的结果。 123dig +short ns comdig +short ns stackexchange.com 八、DNS的记录类型域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，”记录”可以分成不同的类型（type），前面已经看到了有A记录和NS记录。 常见的DNS记录类型如下。 123456789（1） A：地址记录（Address），返回域名指向的IP地址。（2） NS：域名服务器记录（Name Server），返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。（3）MX：邮件记录（Mail eXchange），返回接收电子邮件的服务器地址。（4）CNAME：规范名称记录（Canonical Name），返回另一个域名，即当前查询的域名是另一个域名的跳转，详见下文。（5）PTR：逆向查询记录（Pointer Record），只用于从IP地址查询域名，详见下文。 一般来说，为了服务的安全可靠，至少应该有两条NS记录，而A记录和MX记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。 CNAME记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，facebook.github.io这个域名就是一个CNAME记录。 1234567dig facebook.github.io...;; ANSWER SECTION:facebook.github.io. 3370 IN CNAME github.map.fastly.net.github.map.fastly.net. 600 IN A 103.245.222.133 本博客也可以访问: SoulMate94.github.io 上面结果显示，facebook.github.io的CNAME记录指向github.map.fastly.net。也就是说，用户查询facebook.github.io的时候，实际上返回的是github.map.fastly.net的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改github.map.fastly.net这个域名就可以了，用户的facebook.github.io域名不用修改。 由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录以后，就不能再设置其他记录了（比如A记录和MX记录），这是为了防止产生冲突。举例来说，foo.com指向bar.com，而两个域名各有自己的MX记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置CNAME记录。 PTR记录用于从IP地址反查域名。dig命令的-x参数用于查询PTR记录。 123456dig -x 192.30.252.153...;; ANSWER SECTION:153.252.30.192.in-addr.arpa. 3600 IN PTR pages.github.com. 上面结果显示，192.30.252.153这台服务器的域名是pages.github.com。 逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名。 dig命令可以查看指定的记录类型。 12345dig a github.comdig ns github.comdig mx github.com 九、其他DNS工具除了dig，还有一些其他小工具也可以使用。 （1）host 命令host命令可以看作dig命令的简化版本，返回当前请求域名的各种记录。 12345678910111213$ host github.comgithub.com has address 192.30.252.121github.com mail is handled by 5 ALT2.ASPMX.L.GOOGLE.COM.github.com mail is handled by 10 ALT4.ASPMX.L.GOOGLE.COM.github.com mail is handled by 10 ALT3.ASPMX.L.GOOGLE.COM.github.com mail is handled by 5 ALT1.ASPMX.L.GOOGLE.COM.github.com mail is handled by 1 ASPMX.L.GOOGLE.COM.$ host facebook.github.comfacebook.github.com is an alias for github.map.fastly.net.github.map.fastly.net has address 103.245.222.133 host命令也可以用于逆向查询，即从IP地址查询域名，等同于dig -x &lt;ip&gt;。 123$ host 192.30.252.153153.252.30.192.in-addr.arpa domain name pointer pages.github.com. （2）nslookup 命令nslookup命令用于互动式地查询域名记录。 123456789101112$ nslookup&gt; facebook.github.ioServer: 192.168.1.253Address: 192.168.1.253#53Non-authoritative answer:facebook.github.io canonical name = github.map.fastly.net.Name: github.map.fastly.netAddress: 103.245.222.133&gt; （3）whois 命令whois命令用来查看域名的注册情况。 1$ whois github.com 参考 DNS 原理入门, by 阮一峰 DNS: The Good Parts, by Pete Keen","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/tags/计算机专业必备/"},{"name":"DNS","slug":"DNS","permalink":"http://blog.caoxl.com/tags/DNS/"}]},{"title":"自适应网页设计","slug":"Responsive-Web-Design","date":"2018-02-05T03:51:53.000Z","updated":"2019-08-22T03:46:34.000Z","comments":true,"path":"2018/02/05/Responsive-Web-Design/","link":"","permalink":"http://blog.caoxl.com/2018/02/05/Responsive-Web-Design/","excerpt":"一、”自适应网页设计”的概念2010年，Ethan Marcotte提出了 “自适应网页设计”（Responsive Web Design）这个名词，指可以自动识别屏幕宽度、并做出相应调整的网页设计。 他制作了一个 范例，里面是《福尔摩斯历险记》六个主人公的头像。如果屏幕宽度大于1300像素，则6张图片并排在一行。","text":"一、”自适应网页设计”的概念2010年，Ethan Marcotte提出了 “自适应网页设计”（Responsive Web Design）这个名词，指可以自动识别屏幕宽度、并做出相应调整的网页设计。 他制作了一个 范例，里面是《福尔摩斯历险记》六个主人公的头像。如果屏幕宽度大于1300像素，则6张图片并排在一行。 原文地址: http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html mediaqueri.es上面有更多这样的例子。 这里还有一个 测试小工具，可以在一张网页上，同时显示不同分辨率屏幕的测试效果，我推荐安装。 二、允许网页宽度自动调整“自适应网页设计”到底是怎么做到的？其实并不难。 首先，在网页代码的头部，加入一行 viewport元标签。 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。 所有主流浏览器都支持这个设置，包括IE9。对于那些老式浏览器（主要是IE6、7、8），需要使用 css3-mediaqueries.js。 123 &lt;!--[if lt IE 9]&gt; &lt;script src=\"http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt; 三、不使用绝对宽度由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。 具体说，CSS代码不能指定像素宽度： 1width:xxx px; 只能指定百分比宽度： 1width: xx%; 或者 1width:auto; 四、相对大小的字体字体也不能使用绝对大小（px），而只能使用相对大小（em）。 123 body &#123; font: normal 100% Helvetica, Arial, sans-serif;&#125; 上面的代码指定，字体大小是页面默认大小的100%，即16像素。 123 h1 &#123; font-size: 1.5em; &#125; 然后，h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。 123 small &#123; font-size: 0.875em; &#125; small元素的大小是默认大小的0.875倍，即14像素（14/16=0.875）。 五、流动布局（fluid grid）“流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 123456789.main &#123; float: right; width: 70%;&#125;.leftBar &#123; float: left; width: 25%;&#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。 另外，绝对定位（position: absolute）的使用，也要非常小心。 六、选择加载CSS“自适应网页设计”的核心，就是CSS3引入的 Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 123 &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-device-width: 400px)\" href=\"tinyScreen.css\" /&gt; 上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。 123 &lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (min-width: 400px) and (max-device-width: 600px)\" href=\"smallScreen.css\" /&gt; 如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件。 除了用html标签加载CSS文件，还可以在现有CSS文件中加载。 1 @import url(\"tinyScreen.css\") screen and (max-device-width: 400px); 七、CSS的@media规则同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 123456789101112 @media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125; &#125; 上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）。 八、图片的自适应（fluid image）除了布局和文本，”自适应网页设计”还必须实现 图片的自动缩放。 这只要一行CSS代码： 1img &#123; max-width: 100%;&#125; 这行代码对于大多数嵌入网页的视频也有效，所以可以写成： 1img, object &#123; max-width: 100%;&#125; 老版本的IE不支持max-width，所以只好写成： 1img &#123; width: 100%; &#125; 此外，windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的专有命令： 1img &#123; -ms-interpolation-mode: bicubic; &#125; 或者，Ethan Marcotte的 imgSizer.js。 1234567 addLoadEvent(function() &#123; var imgs = document.getElementById(\"content\").getElementsByTagName(\"img\"); imgSizer.collate(imgs); &#125;); 不过，有条件的话，最好还是根据不同大小的屏幕，加载不同分辨率的图片。有 很多方法可以做到这一条，服务器端和客户端都可以实现。 参考 自适应网页设计（Responsive Web Design）","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://blog.caoxl.com/tags/Web/"},{"name":"Design","slug":"Design","permalink":"http://blog.caoxl.com/tags/Design/"}]},{"title":"理解 OAuth 2.0","slug":"Dig-OAuth-2-0","date":"2018-02-05T03:18:41.000Z","updated":"2019-08-22T03:46:48.000Z","comments":true,"path":"2018/02/05/Dig-OAuth-2-0/","link":"","permalink":"http://blog.caoxl.com/2018/02/05/Dig-OAuth-2-0/","excerpt":"OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。 本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为RFC 6749。","text":"OAuth是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。 本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为RFC 6749。 一、应用场景为了理解OAuth的适用场合，让我举一个假设的例子。 有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。 问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？ 传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。 123456789（1）\"云冲印\"为了后续的服务，会保存用户的密码，这样很不安全。（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。（3）\"云冲印\"拥有了获取用户储存在Google所有资料的权力，用户没法限制\"云冲印\"获得授权的范围和有效期。（4）用户只有修改密码，才能收回赋予\"云冲印\"的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。 OAuth就是为了解决上面这些问题而诞生的。 二、名词定义在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。 （1）Third-party application：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。 （2）HTTP service：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。 （3）Resource Owner：资源所有者，本文中又称”用户”（user）。 （4）User Agent：用户代理，本文中就是指浏览器。 （5）Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。 （6）Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。 三、OAuth的思路OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。 “客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。 四、运行流程OAuth 2.0的运行流程如下图，摘自RFC 6749。 1234567891011（A）用户打开客户端以后，客户端要求用户给予授权。（B）用户同意给予客户端授权。（C）客户端使用上一步获得的授权，向认证服务器申请令牌。（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（E）客户端使用令牌，向资源服务器申请获取资源。（F）资源服务器确认令牌无误，同意向客户端开放资源。 不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。 下面一一讲解客户端获取授权的四种模式。 五、客户端的授权模式客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。 授权码模式（authorization code） 简化模式（implicit） 密码模式（resource owner password credentials） 客户端模式（client credentials） 六、授权码模式授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。 它的步骤如下： 123456789（A）用户访问客户端，后者将前者导向认证服务器。（B）用户选择是否给予客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的\"重定向URI\"（redirection URI），同时附上一个授权码。（D）客户端收到授权码，附上早先的\"重定向URI\"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。 下面是上面这些步骤所需要的参数。 A步骤中，客户端申请认证的 URI ，包含以下参数： response_type：表示授权类型，必选项，此处的值固定为”code” client_id：表示客户端的ID，必选项 redirect_uri：表示重定向URI，可选项 scope：表示申请的权限范围，可选项 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 下面是一个例子: 123GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1Host: server.example.com C步骤中，服务器回应客户端的URI，包含以下参数： code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。 state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 下面是一个例子。 12HTTP/1.1 302 FoundLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数： grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。 code：表示上一步获得的授权码，必选项。 redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。 client_id：表示客户端ID，必选项。 下面是一个例子。 1234567POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb E步骤中，认证服务器发送的HTTP回复，包含以下参数： access_token：表示访问令牌，必选项。 token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。 expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。 scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 下面是一个例子。 123456789101112HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123; \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\", \"token_type\":\"example\", \"expires_in\":3600, \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\", \"example_parameter\":\"example_value\"&#125; 从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。 七、简化模式简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。 它的步骤如下： 12345678910111213（A）客户端将用户导向认证服务器。（B）用户决定是否给于客户端授权。（C）假设用户给予授权，认证服务器将用户导向客户端指定的\"重定向URI\"，并在URI的Hash部分包含了访问令牌。（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。（F）浏览器执行上一步获得的脚本，提取出令牌。（G）浏览器将令牌发给客户端。 下面是上面这些步骤所需要的参数。 A步骤中，客户端发出的HTTP请求，包含以下参数： response_type：表示授权类型，此处的值固定为”token”，必选项。 client_id：表示客户端的ID，必选项。 redirect_uri：表示重定向的URI，可选项。 scope：表示权限范围，可选项。 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 下面是一个例子。 123GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1Host: server.example.com C步骤中，认证服务器回应客户端的URI，包含以下参数： access_token：表示访问令牌，必选项。 token_type：表示令牌类型，该值大小写不敏感，必选项。 expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。 下面是一个例子。 123HTTP/1.1 302 FoundLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA&amp;state=xyz&amp;token_type=example&amp;expires_in=3600 在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。 根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。 八、密码模式密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。 在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。 它的步骤如下： 12345（A）用户向客户端提供用户名和密码。（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。（C）认证服务器确认无误后，向客户端提供访问令牌。 B步骤中，客户端发出的HTTP请求，包含以下参数： grant_type：表示授权类型，此处的值固定为”password”，必选项。 username：表示用户名，必选项。 password：表示用户的密码，必选项。 scope：表示权限范围，可选项。 下面是一个例子。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=password&amp;username=johndoe&amp;password=A3ddj3w C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。 123456789101112HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123; \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\", \"token_type\":\"example\", \"expires_in\":3600, \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\", \"example_parameter\":\"example_value\"&#125; 上面代码中，各个参数的含义参见《授权码模式》一节。 整个过程中，客户端不得保存用户的密码。 九、客户端模式客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。 它的步骤如下： 123（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。（B）认证服务器确认无误后，向客户端提供访问令牌。 A步骤中，客户端发出的HTTP请求，包含以下参数： granttype：表示授权类型，此处的值固定为”clientcredentials”，必选项。 scope：表示权限范围，可选项。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=client_credentials 认证服务器必须以某种方式，验证客户端身份。 B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。 1234567891011HTTP/1.1 200 OKContent-Type: application/json;charset=UTF-8Cache-Control: no-storePragma: no-cache&#123; \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\", \"token_type\":\"example\", \"expires_in\":3600, \"example_parameter\":\"example_value\"&#125; 上面代码中，各个参数的含义参见《授权码模式》一节。 十、更新令牌如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。 客户端发出更新令牌的HTTP请求，包含以下参数： granttype：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。 refresh_token：表示早前收到的更新令牌，必选项。 scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。 下面是一个例子。 123456POST /token HTTP/1.1Host: server.example.comAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JWContent-Type: application/x-www-form-urlencodedgrant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA 参考 理解OAuth 2.0","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"OAuth 2.0","slug":"OAuth-2-0","permalink":"http://blog.caoxl.com/tags/OAuth-2-0/"}]},{"title":"Linux 守护进程","slug":"Linux-Daemon-Start-Up","date":"2018-02-05T02:48:53.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/05/Linux-Daemon-Start-Up/","link":"","permalink":"http://blog.caoxl.com/2018/02/05/Linux-Daemon-Start-Up/","excerpt":"“守护进程”（daemon）就是一直在后台运行的进程（daemon）。 本文介绍如何将一个 Web 应用，启动为守护进程。","text":"“守护进程”（daemon）就是一直在后台运行的进程（daemon）。 本文介绍如何将一个 Web 应用，启动为守护进程。 一、问题的由来Web应用写好后，下一件事就是启动，让它一直在后台运行。 这并不容易。举例来说，下面是一个最简单的Node应用 server.js，只有6行。 123456var http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('Hello World');&#125;).listen(5000); 你在命令行下启动它。 1node server.js 看上去一切正常，所有人都能快乐地访问 5000 端口了。但是，一旦你退出命令行窗口，这个应用就一起退出了，无法访问了。 怎么才能让它变成系统的守护进程（daemon），成为一种服务（service），一直在那里运行呢？ 二、前台任务与后台任务上面这样启动的脚本，称为”前台任务”（foreground job）。它会独占命令行窗口，只有运行完了或者手动中止，才能执行其他命令。 变成守护进程的第一步，就是把它改成”后台任务”（background job）。 1node server.js &amp; 只要在命令的尾部加上符号&amp;，启动的进程就会成为”后台任务”。如果要让正在运行的”前台任务”变为”后台任务”，可以先按 ctrl + z，然后执行 bg 命令（让最近一个暂停的”后台任务”继续执行）。 “后台任务”有两个特点。 123继承当前 session （对话）的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。不再继承当前 session 的标准输入（stdin）。你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行（halt）。 可以看到，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。 三、SIGHUP信号变为”后台任务”后，一个进程是否就成为了守护进程呢？或者说，用户退出 session 以后，”后台任务”是否还会继续执行？ Linux系统是这样设计的。 用户准备退出 session 系统向该 session 发出SIGHUP信号 session 将SIGHUP信号发给所有子进程 子进程收到SIGHUP信号后，自动退出 上面的流程解释了，为什么”前台任务”会随着 session 的退出而退出：因为它收到了 SIGHUP 信号。 那么，”后台任务”是否也会收到SIGHUP信号？ 这由 Shell 的 huponexit 参数决定的。 1shopt | grep huponexit 执行上面的命令，就会看到huponexit参数的值。 大多数Linux系统，这个参数默认关闭（off）。因此，session 退出的时候，不会把SIGHUP信号发给”后台任务”。所以，一般来说，”后台任务”不会随着 session 一起退出。 四、disown 命令通过”后台任务”启动”守护进程”并不保险，因为有的系统的huponexit参数可能是打开的（on）。 更保险的方法是使用disown命令。它可以将指定任务从”后台任务”列表（jobs命令的返回结果）之中移除。一个”后台任务”只要不在这个列表之中，session就肯定不会向它发出SIGHUP信号。 123node server.js &amp;disown 执行上面的命令以后，server.js 进程就被移出了”后台任务”列表。你可以执行jobs 命令验证，输出结果里面，不会有这个进程。 disown的用法如下。 123456789101112131415# 移出最近一个正在执行的后台任务$ disown# 移出所有正在执行的后台任务$ disown -r# 移出所有后台任务$ disown -a# 不移出后台任务，但是让它们不会收到SIGHUP信号$ disown -h# 根据jobId，移出指定的后台任务$ disown %2$ disown -h %2 五、标准 I/O使用 disown 命令之后，还有一个问题。那就是，退出 session 以后，如果后台进程与标准 I/O 有交互，它还是会挂掉。 还是以上面的脚本为例，现在加入一行。 1234567var http = require('http');http.createServer(function(req, res) &#123; console.log('server starts...'); // 加入此行 res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('Hello World');&#125;).listen(5000); 启动上面的脚本，然后再执行disown命令。 12node server.js &amp;disown 接着，你退出 session，访问5000端口，就会发现连不上。 这是因为”后台任务”的标准 I/O 继承自当前 session，disown命令并没有改变这一点。一旦”后台任务”读写标准 I/O，就会发现它已经不存在了，所以就报错终止执行。 为了解决这个问题，需要对”后台任务”的标准 I/O 进行重定向。 12node server.js &gt; stdout.txt 2&gt; stderr.txt &lt; /dev/null &amp;disown 上面这样执行，基本上就没有问题了。 六、nohup 命令还有比disown更方便的命令，就是nohup。 1nohup node server.js &amp; nohup命令对server.js进程做了三件事。 阻止SIGHUP信号发到这个进程。 关闭标准输入。该进程不再能够接收任何输入，即使运行在前台。 重定向标准输出和标准错误到文件nohup.out。 也就是说，nohup 命令实际上将子进程与它所在的 session 分离了。 注意，nohup 命令不会自动把进程变为”后台任务”，所以必须加上&amp;符号。 七、Screen 命令与 Tmux 命令另一种思路是使用 terminal multiplexer （终端复用器：在同一个终端里面，管理多个session），典型的就是 Screen 命令和 Tmux 命令。 它们可以在当前 session 里面，新建另一个 session。这样的话，当前 session 一旦结束，不影响其他 session。而且，以后重新登录，还可以再连上早先新建的 session。 Screen 的用法如下。 1234# 新建一个 session$ screen$ node server.js 然后，按下 ctrl + A 和 ctrl + D，回到原来的 session，从那里退出登录。下次登录时，再切回去。 1screen -r 如果新建多个后台 session，就需要为它们指定名字。 12345678screen -S name# 切回指定 sessionscreen -r namescreen -r pid_number# 列出所有 sessionscreen -ls 如果要停掉某个 session，可以先切回它，然后按下 ctrl + c 和 ctrl + d。 Tmux 比 Screen 功能更多、更强大，它的基本用法如下。 12345$ tmuxnode server.js# 返回原来的sessiontmux detach 除了tmux detach，另一种方法是按下Ctrl + B和d ，也可以回到原来的 session。 123# 下次登录时，返回后台正在运行服务sessiontmux attach 如果新建多个 session，就需要为每个 session 指定名字。 1234567891011121314# 新建 sessiontmux new -s session_name# 切换到指定 sessiontmux attach -t session_name# 列出所有 sessiontmux list-sessions# 退出当前 session，返回前一个 session tmux detach# 杀死指定 sessiontmux kill-session -t session-name 八、Node 工具对于 Node 应用来说，可以不用上面的方法，有一些专门用来启动的工具：forever，nodemon 和 pm2。 forever 的功能很简单，就是保证进程退出时，应用会自动重启。 1234567891011121314151617181920# 作为前台任务启动$ forever server.js# 作为服务进程启动 $ forever start app.js# 停止服务进程$ forever stop Id# 重启服务进程$ forever restart Id# 监视当前目录的文件变动，一有变动就重启$ forever -w server.js# -m 参数指定最多重启次数$ forever -m 5 server.js # 列出所有进程$ forever list nodemon 一般只在开发时使用，它最大的长处在于 watch 功能，一旦文件发生变化，就自动重启进程。 12345# 默认监视当前目录的文件变化$ nodemon server.js＃ 监视指定文件的变化 $ nodemon --watch app --watch libs server.js pm2 的功能最强大，除了重启进程以外，还能实时收集日志和监控。 123456789101112131415161718192021222324252627282930313233343536# 启动应用$ pm2 start app.js# 指定同时起多少个进程（由CPU核心数决定），组成一个集群$ pm2 start app.js -i max# 列出所有任务$ pm2 list# 停止指定任务$ pm2 stop 0＃ 重启指定任务$ pm2 restart 0# 删除指定任务$ pm2 delete 0# 保存当前的所有任务，以后可以恢复$ pm2 save# 列出每个进程的统计数据$ pm2 monit# 查看所有日志$ pm2 logs# 导出数据$ pm2 dump# 重启所有进程$ pm2 kill$ pm2 resurect# 启动web界面 http://localhost:9615$ pm2 web 十、Systemd除了专用工具以外，Linux系统有自己的守护进程管理工具 Systemd 。它是操作系统的一部分，直接与内核交互，性能出色，功能极其强大。我们完全可以将程序交给 Systemd ，让系统统一管理，成为真正意义上的系统服务。 Systemd。 参考 Linux 守护进程的启动方法","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"守护进程","slug":"守护进程","permalink":"http://blog.caoxl.com/tags/守护进程/"}]},{"title":"RESTful API 「设计指南」","slug":"RESTful-API-Design-Guide","date":"2018-02-05T02:10:07.000Z","updated":"2019-08-22T03:46:30.000Z","comments":true,"path":"2018/02/05/RESTful-API-Design-Guide/","link":"","permalink":"http://blog.caoxl.com/2018/02/05/RESTful-API-Design-Guide/","excerpt":"网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。 因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现 “API First” 的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。我以前写过一篇《理解RESTful架构》，探讨如何理解这个概念。","text":"网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）。 因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现 “API First” 的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。我以前写过一篇《理解RESTful架构》，探讨如何理解这个概念。 原文地址: http://www.ruanyifeng.com/blog/2014/05/restful_api.html 今天，我将介绍RESTful API的设计细节，探讨如何设计一套合理、好用的API。我的主要参考了两篇文章（1，2） 一、协议API与用户的通信协议，总是使用 HTTPs协议。 二、域名应该尽量将API部署在专用域名之下。 1https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 1https://example.org/api/ 三、版本（Versioning）应该将API的版本号放入URL。 1https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 四、路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 12345https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees 五、HTTP动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的HTTP动词。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 下面是一些例子。 123456789101112131415GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 六、过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 123456789?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 七、状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 1234567891011121314151617181920212223200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）204 NO CONTENT - [DELETE]：用户删除数据成功。400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。 状态码的完全列表参见 这里。 八、错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 123&#123; error: \"Invalid API key\"&#125; 九、返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 1234567891011GET /collection：返回资源对象的列表（数组）GET /collection/resource：返回单个资源对象POST /collection：返回新生成的资源对象PUT /collection/resource：返回完整的资源对象PATCH /collection/resource：返回完整的资源对象DELETE /collection/resource：返回一个空文档 十、Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 12345678&#123; \"link\": &#123; \"rel\": \"collection https://www.example.com/zoos\", \"href\": \"https://api.example.com/zoos\", \"title\": \"List of zoos\", \"type\": \"application/vnd.yourformat+json\" &#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问 api.github.com 会得到一个所有可用API的网址列表。 12345&#123; \"current_user_url\": \"https://api.github.com/user\", \"authorizations_url\": \"https://api.github.com/authorizations\", // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问 api.github.com/user，然后就得到了下面结果。 1234&#123; \"message\": \"Requires authentication\", \"documentation_url\": \"https://developer.github.com/v3\"&#125; 上面代码表示，服务器给出了提示信息，以及文档的网址。 其他 API的身份认证应该使用 OAuth 2.0框架。 服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 参考 RESTful API 设计指南 By 阮一峰","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"RESTful","slug":"RESTful","permalink":"http://blog.caoxl.com/tags/RESTful/"},{"name":"设计指南","slug":"设计指南","permalink":"http://blog.caoxl.com/tags/设计指南/"}]},{"title":"理解「RESTful」架构","slug":"Dig-RESTful","date":"2018-02-04T07:22:51.000Z","updated":"2019-08-22T03:47:02.000Z","comments":true,"path":"2018/02/04/Dig-RESTful/","link":"","permalink":"http://blog.caoxl.com/2018/02/04/Dig-RESTful/","excerpt":"越来越多的人开始意识到，网站即软件，而且是一种新型的软件。 这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。 网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。 原文地址： http://www.ruanyifeng.com/blog/2011/09/restful.html","text":"越来越多的人开始意识到，网站即软件，而且是一种新型的软件。 这种”互联网软件”采用客户端/服务器模式，建立在分布式体系上，通过互联网通信，具有高延时（high latency）、高并发等特点。 网站开发，完全可以采用软件开发的模式。但是传统上，软件和网络是两个不同的领域，很少有交集；软件开发主要针对单机环境，网络则主要研究系统之间的通信。互联网的兴起，使得这两个领域开始融合，现在我们必须考虑，如何开发在互联网环境中使用的软件。 原文地址： http://www.ruanyifeng.com/blog/2011/09/restful.html RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。 一、起源REST这个词，是 Roy Thomas Fielding在他2000年的博士论文中提出的。 Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。 他这样介绍论文的写作目的： “本文研究计算机科学两大前沿—-软件和网络—-的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。” (This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. ) 二、名称Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是“表现层状态转化”。 如果一个架构符合REST原则，就称它为RESTful架构。 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。 Representational State Transfer表述性状态转移 三、资源（Resources）REST的名称”表现层状态转化”中，省略了主语。“表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 四、表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 五、状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作： GET用来获取资源， POST用来新建资源（也可以用于更新资源）， PUT用来更新资源， DELETE用来删除资源。 六、综述综合上面的解释，我们总结一下什么是RESTful架构： 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 七、误区RESTful架构有一些典型的设计误区。 最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。 举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。 如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是： 1POST /accounts/1/transfer/500/to/2 正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务： 1234 POST /transaction HTTP/1.1 Host: 127.0.0.1 from=1&amp;to=2&amp;amount=500.00 另一个设计误区，就是在URI中加入版本号： 12345 http://www.example.com/app/1.0/foo http://www.example.com/app/1.1/foo http://www.example.com/app/2.0/foo 因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services）： 12345 Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0 参考 理解RESTful架构","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"RESTful","slug":"RESTful","permalink":"http://blog.caoxl.com/tags/RESTful/"}]},{"title":"Git 使用规范流程","slug":"Git-Use-Process","date":"2018-02-04T07:05:39.000Z","updated":"2019-08-22T03:42:29.000Z","comments":true,"path":"2018/02/04/Git-Use-Process/","link":"","permalink":"http://blog.caoxl.com/2018/02/04/Git-Use-Process/","excerpt":"团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。 否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。","text":"团队开发中，遵循一个合理、清晰的Git使用流程，是非常重要的。 否则，每个人都提交一堆杂乱无章的commit，项目很快就会变得难以协调和维护。 下面是 ThoughtBot 的Git使用规范流程。我从中学到了很多，推荐你也这样使用Git。 第一步：新建分支首先，每次开发新功能，都应该新建一个单独的分支（这方面可以参考 《Git分支管理策略》）。 123456# 获取主干最新代码git checkout mastergit pull# 新建一个开发分支myfeaturegit checkout -b myfeature 第二步：提交分支commit分支修改后，就可以提交commit了。 123git add --allgit statusgit commit --verbose git add 命令的all参数，表示保存所有变化（包括新建、修改和删除）。从Git 2.0开始，all是 git add 的默认参数，所以也可以用 git add . 代替。 git status 命令，用来查看发生变动的文件。 git commit 命令的verbose参数，会列出 diff 的结果。 第三步：撰写提交信息提交commit时，必须给出完整扼要的提交信息，下面是一个范本。 123456Present-tense summary under 50 characters* More information about commit (under 72 characters).* More information about commit (under 72 characters).http://project.management-system.com/ticket/123 第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、以及需要注意的问题。最后，提供对应的网址（比如 Bug ticket）。 第四步：与主干同步分支的开发过程中，要经常与主干保持同步。 123git fetch origingit rebase origin/master 第五步：合并commit分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个（或最多两三个）commit，这样不仅清晰，也容易管理。 那么，怎样才能将多个commit合并呢？这就要用到 git rebase 命令。 1git rebase -i origin/master git rebase命令的i参数表示互动（interactive），这时git会打开一个互动界面，进行下一步操作。 下面采用 Tute Costa的例子，来解释怎么合并commit。 12345678910111213141516171819202122pick 07c5abd Introduce OpenPGP and teach basic usagepick de9b1eb Fix PostChecker::Post#urlspick 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend# Rebase 8db7e8b..fa20af3 onto 8db7e8b## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like \"squash\", but discard this commit's log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 上面的互动界面，先列出当前分支最新的4个commit（越下面越新）。每个commit前面有一个操作命令，默认是pick，表示该行commit被选中，要进行rebase操作。 4个commit的下面是一大堆注释，列出可以使用的命令。 1234567891011pick：正常选中reword：选中，并且修改提交信息；edit：选中，rebase时会暂停，允许你修改这个commit（参考这里）squash：选中，会将当前commit与上一个commit合并fixup：与squash相同，但不会保存当前commit的提交信息exec：执行其他shell命令 上面这6个命令当中，squash和fixup可以用来合并commit。先把需要合并的commit前面的动词，改成squash（或者s）。 1234pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlss 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend 这样一改，执行后，当前分支只会剩下两个commit。第二行和第三行的commit，都会合并到第一行的commit。提交信息会同时包含，这三个commit的提交信息。 123456789# This is a combination of 3 commits.# The first commit's message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:Hey kids, stop all the highlighting 如果将第三行的squash命令改成fixup命令。 1234pick 07c5abd Introduce OpenPGP and teach basic usages de9b1eb Fix PostChecker::Post#urlsf 3e7ee36 Hey kids, stop all the highlightingpick fa20af3 git interactive rebase, squash, amend 运行结果相同，还是会生成两个commit，第二行和第三行的commit，都合并到第一行的commit。但是，新的提交信息里面，第三行commit的提交信息，会被注释掉。 123456789# This is a combination of 3 commits.# The first commit's message is:Introduce OpenPGP and teach basic usage# This is the 2nd commit message:Fix PostChecker::Post#urls# This is the 3rd commit message:# Hey kids, stop all the highlighting Pony Foo提出另外一种合并commit的简便方法，就是先撤销过去5个commit，然后再建一个新的。 1234git reset HEAD~5git add .git commit -am \"Here's the bug fix that closes #28\"git push --force squash和fixup命令，还可以当作命令行参数使用，自动合并commit。 123git commit --fixup git rebase -i --autosquash 这个用法请参考 这篇文章，这里就不解释了。 第六步：推送到远程仓库合并commit后，就可以推送当前分支到远程仓库了。 1git push --force origin myfeature git push命令要加上force参数，因为rebase以后，分支历史改变了，跟远程分支不一定兼容，有可能要强行推送（参见这里） 第七步：发出Pull Request提交到远程仓库以后，就可以发出 Pull Request 到 master 分支，然后请求别人进行代码 review，确认可以合并到master。 参考 Git 使用规范流程","categories":[{"name":"Git / Svn","slug":"Git-Svn","permalink":"http://blog.caoxl.com/categories/Git-Svn/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"http://blog.caoxl.com/tags/GIT/"},{"name":"流程","slug":"流程","permalink":"http://blog.caoxl.com/tags/流程/"}]},{"title":"HTTPS「升级指南」","slug":"Update-HTTP-To-HTTPS","date":"2018-02-04T05:07:30.000Z","updated":"2019-08-22T03:46:52.000Z","comments":true,"path":"2018/02/04/Update-HTTP-To-HTTPS/","link":"","permalink":"http://blog.caoxl.com/2018/02/04/Update-HTTP-To-HTTPS/","excerpt":"昨天我介绍了 HTTP/2 协议 ，它只有在 HTTPS 环境才会生效。 为了升级到 HTTP/2 协议，必须先启用 HTTPS。如果你不了解 HTTPS 协议（学名 TLS 协议），可以参考以下文章。 《SSL/TLS协议运行机制的概述》 《图解SSL/TLS协议》 《HTTPS 协议的七个误解》 《SSL延迟有多大?》 本文介绍如何将一个 HTTP 网站升级到 HTTPS 。","text":"昨天我介绍了 HTTP/2 协议 ，它只有在 HTTPS 环境才会生效。 为了升级到 HTTP/2 协议，必须先启用 HTTPS。如果你不了解 HTTPS 协议（学名 TLS 协议），可以参考以下文章。 《SSL/TLS协议运行机制的概述》 《图解SSL/TLS协议》 《HTTPS 协议的七个误解》 《SSL延迟有多大?》 本文介绍如何将一个 HTTP 网站升级到 HTTPS 。 获取证书升级到 HTTPS 协议的第一步，就是要获得一张证书。 证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，要从经销商购买。 GoGetSSL SSLs.com SSLmate.com 证书有很多类型，首先分为三种认证级别。 域名认证（Domain Validation）：最低级别认证，可以确认申请人拥有这个域名。对于这种证书，浏览器会在地址栏显示一把锁。 公司认证（Company Validation）：确认域名所有人是哪一家公司，证书里面会包含公司信息。 扩展认证（Extended Validation）：最高级别的认证，浏览器地址栏会显示公司名。 还分为三种覆盖范围。 单域名证书：只能用于单一域名，foo.com的证书不能用于www.foo.com 通配符证书：可以用于某个域名及其所有一级子域名，比如*.foo.com的证书可以用于foo.com，也可以用于www.foo.com 多域名证书：可以用于多个域名，比如foo.com和bar.com 认证级别越高、覆盖范围越广的证书，价格越贵。 还有一个免费证书的选择。为了推广HTTPS协议，电子前哨基金会EFF成立了 Let’s Encrypt，提供免费证书（教程和工具）。 可以参考本网站中的: Let’s Encrypt 简单使用 拿到证书以后，可以用 SSL Checker 检查一下，信息是否正确。 安装证书证书可以放在/etc/ssl目录（Linux 系统），然后根据你使用的Web服务器进行配置。 证书配置文件生成器，by Mozilla 配置文件模板，by SSLMate 如果使用 Let’s Encrypt 证书，请使用自动安装工具 Certbot。 安装成功后，使用 SSL Server Test 检查一下证书是否生效。 修改链接下一步，网页加载的 HTTP 资源，要全部改成 HTTPS 链接。因为加密网页内如果有非加密的资源，浏览器是不会加载那些资源的。 这也是为什么SSL配置成功后,小绿锁不显示的原因之一 1&lt;script src=\"http://foo.com/jquery.js\"&gt;&lt;/script&gt; 上面这行加载命令，有两种改法。 12345&lt;!-- 改法一 --&gt;&lt;script src=\"https://foo.com/jquery.js\"&gt;&lt;/script&gt;&lt;!-- 改法二 --&gt;&lt;script src=\"//foo.com/jquery.js\"&gt;&lt;/script&gt; 其中，改法二会根据当前网页的协议，加载相同协议的外部资源，更灵活一些。 另外，如果页面头部用到了rel=&quot;canonical&quot;，也要改成HTTPS网址。 1&lt;link rel=\"canonical\" href=\"https://foo.com/bar.html\" /&gt; 301重定向下一步，修改 Web 服务器的配置文件，使用 301 重定向，将 HTTP 协议的访问导向 HTTPS 协议。 Nginx 的写法 123456server &#123; listen 80; server_name domain.com www.domain.com; return 301 https://domain.com$request_uri;&#125; Apache 的写法（.htaccess文件）。 123RewriteEngine OnRewriteCond %&#123;HTTPS&#125; offRewriteRule (.*) https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; [R=301,L] 安全措施以下措施可以进一步保证通信安全。 HTTP Strict Transport Security (HSTS)访问网站时，用户很少直接在地址栏输入https://，总是通过点击链接，或者3xx重定向，从HTTP页面进入HTTPS页面。攻击者完全可以在用户发出HTTP请求时，劫持并篡改该请求。 另一种情况是恶意网站使用自签名证书，冒充另一个网站，这时浏览器会给出警告，但是许多用户会忽略警告继续访问。 “HTTP严格传输安全”（简称 HSTS）的作用，就是强制浏览器只能发出HTTPS请求，并阻止用户接受不安全的证书。 它在网站的响应头里面，加入一个强制性声明。以下例子摘自 维基百科。 1Strict-Transport-Security: max-age=31536000; includeSubDomains 上面这段头信息有两个作用。 123（1）在接下来的一年（即31536000秒）中，浏览器只要向example.com或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。用户点击超链接或在地址栏输入`http://www.example.com/`，浏览器应当自动将http转写成https，然后直接向`https://www.example.com/`发送请求。（2）在接下来的一年中，如果`example.com`服务器发送的证书无效，用户不能忽略浏览器警告，将无法继续访问该网站。 HSTS 很大程度上解决了 SSL 剥离攻击。只要浏览器曾经与服务器建立过一次安全连接，之后浏览器会强制使用HTTPS，即使链接被换成了HTTP。 该方法的主要不足是，用户首次访问网站发出HTTP请求时，是不受HSTS保护的。 如果想要全面分析网站的安全程度，可以使用 Mozilla 的 Observatory。 Cookie另一个需要注意的地方是，确保浏览器只在使用 HTTPS 时，才发送Cookie。 网站响应头里面，Set-Cookie 字段加上 Secure 标志即可。 1Set-Cookie: LSID=DQAAAK...Eaem_vYg; Secure 参考 HTTPS 升级指南, By 阮一峰 How To Migrate To HTTPS, by Chris Palmer","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://blog.caoxl.com/tags/HTTPS/"},{"name":"HTTP","slug":"HTTP","permalink":"http://blog.caoxl.com/tags/HTTP/"}]},{"title":"TCP 协议简介","slug":"TCP-Protocol-Intro","date":"2018-02-03T09:51:17.000Z","updated":"2019-08-22T03:47:04.000Z","comments":true,"path":"2018/02/03/TCP-Protocol-Intro/","link":"","permalink":"http://blog.caoxl.com/2018/02/03/TCP-Protocol-Intro/","excerpt":"TCP 是互联网核心协议之一，本文介绍它的基础知识。","text":"TCP 是互联网核心协议之一，本文介绍它的基础知识。 原文地址: http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html TCP 协议的作用互联网由 一整套协议构成。TCP 只是其中的一层，有着自己的分工 最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。 但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。 IP 协议定义了一套自己的地址规则，称为 IP 地址。它实现了路由功能，允许某个局域网的 A 主机，向另一个局域网的 B 主机发送消息。 路由的原理很简单。市场上所有的路由器，背后都有很多网口，要接入多根网线。路由器内部有一张路由表，规定了 A 段 IP 地址走出口一，B 段地址走出口二，……通过这套”指路牌”，实现了数据包的转发。 IP 协议只是一个地址协议，并不保证数据包的完整。如果路由器丢包（比如缓存满了，新进来的数据包就会丢失），就需要发现丢了哪一个包，以及如何重新发送这个包。这就要依靠 TCP 协议。 简单说，TCP 协议的作用是，保证数据通信的完整性和可靠性，防止丢包。 TCP 数据包的大小以太网数据包（packet）的大小是固定的，最初是1518字节，后来增加到1522字节。其中， 1500 字节是负载（payload），22字节是头信息（head）。 IP 数据包在以太网数据包的负载里面，它也有自己的头信息，最少需要20字节，所以 IP 数据包的负载最多为1480字节。 TCP 数据包在 IP 数据包的负载里面。它的头信息最少也需要20字节，因此 TCP 数据包的最大负载是 1480 - 20 = 1460 字节。由于 IP 和 TCP 协议往往有额外的头信息，所以 TCP 负载实际为1400字节左右。 因此，一条1500字节的信息需要两个 TCP 数据包。HTTP/2 协议的一大改进， 就是压缩 HTTP 协议的头信息，使得一个 HTTP 请求可以放在一个 TCP 数据包里面，而不是分成多个，这样就提高了速度。 TCP 数据包的编号(SEQ)个包1400字节，那么一次性发送大量数据，就必须分成多个包。比如，一个 10MB 的文件，需要发送7100多个包。 发送的时候，TCP 协议为每个包编号（sequence number，简称 SEQ），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。 第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：自身的编号，以及下一个包的编号。接收方由此知道，应该按照什么顺序将它们还原成原始文件。 TCP 数据包的组装收到 TCP 数据包以后，组装还原是操作系统完成的。应用程序不会直接处理 TCP 数据包。 对于应用程序来说，不用关心数据通信的细节。除非线路异常，收到的总是完整的数据。应用程序需要的数据放在 TCP 数据包里面，有自己的格式（比如 HTTP 协议）。 TCP 并没有提供任何机制，表示原始文件的大小，这由应用层的协议来规定。比如，HTTP 协议就有一个头信息Content-Length，表示信息体的大小。对于操作系统来说，就是持续地接收 TCP 数据包，将它们按照顺序组装好，一个包都不少。 操作系统不会去处理 TCP 数据包里面的数据。一旦组装好 TCP 数据包，就把它们转交给应用程序。TCP 数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。 应用程序收到组装好的原始数据，以浏览器为例，就会根据 HTTP 协议的Content-Length字段正确读出一段段的数据。这也意味着，一次 TCP 通信可以包括多个 HTTP 通信。 慢启动和 ACK服务器发送数据包，当然越快越好，最好一次性全发出去。但是，发得太快，就有可能丢包。带宽小、路由器过热、缓存溢出等许多因素都会导致丢包。线路不好的话，发得越快，丢得越多。 最理想的状态是，在线路允许的情况下，达到最高速率。但是我们怎么知道，对方线路的理想速率是多少呢？答案就是慢慢试。 TCP 协议为了做到效率与可靠性的统一，设计了一个慢启动（slow start）机制。开始的时候，发送得较慢，然后根据丢包的情况，调整速率：如果不丢包，就加快发送速度；如果丢包，就降低发送速度。 Linux 内核里面设定了（常量TCP_INIT_CWND），刚开始通信的时候，发送方一次性发送10个数据包，即”发送窗口”的大小为10。然后停下来，等待接收方的确认，再继续发送。 默认情况下，接收方每收到两个 TCP 数据包，就要发送一个确认消息。”确认”的英语是 acknowledgement，所以这个确认消息就简称 ACK。 ACK 携带两个信息。 123期待要收到下一个数据包的编号接收方的接收窗口的剩余容量 发送方有了这两个信息，再加上自己已经发出的数据包的最新编号，就会推测出接收方大概的接收速度，从而降低或增加发送速率。这被称为”发送窗口”，这个窗口的大小是可变的。 注意，由于 TCP 通信是双向的，所以双方都需要发送 ACK。两方的窗口大小，很可能是不一样的。而且 ACK 只是很简单的几个字段，通常与数据合并在一个数据包里面发送。 (图片说明：上图一共4次通信。第一次通信，A 主机发给B 主机的数据包编号是1，长度是100字节，因此第二次通信 B 主机的 ACK 编号是 1 + 100 = 101，第三次通信 A 主机的数据包编号也是 101。同理，第二次通信 B 主机发给 A 主机的数据包编号是1，长度是200字节，因此第三次通信 A 主机的 ACK 是201，第四次通信 B 主机的数据包编号也是201。) 即使对于带宽很大、线路很好的连接，TCP 也总是从10个数据包开始慢慢试，过了一段时间以后，才达到最高的传输速率。这就是 TCP 的慢启动。 数据包的遗失处理TCP 协议可以保证数据通信的完整性，这是怎么做到的？ 前面说过，每一个数据包都带有下一个数据包的编号。如果下一个数据包没有收到，那么 ACK 的编号就不会发生变化。 举例来说，现在收到了4号包，但是没有收到5号包。ACK 就会记录，期待收到5号包。过了一段时间，5号包收到了，那么下一轮 ACK 会更新编号。如果5号包还是没收到，但是收到了6号包或7号包，那么 ACK 里面的编号不会变化，总是显示5号包。这会导致大量重复内容的 ACK。 如果发送方发现收到三个连续的重复 ACK ，或者超时了还没有收到任何 ACK，就会确认丢包，即5号包遗失了，从而再次发送这个包。通过这种机制，TCP 保证了不会有数据包丢失。 参考 TCP 协议简介","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"TCP","slug":"TCP","permalink":"http://blog.caoxl.com/tags/TCP/"}]},{"title":"互联网协议入门（二）","slug":"Internet-Protocol-Intro-2","date":"2018-02-03T08:40:24.000Z","updated":"2019-08-22T03:47:07.000Z","comments":true,"path":"2018/02/03/Internet-Protocol-Intro-2/","link":"","permalink":"http://blog.caoxl.com/2018/02/03/Internet-Protocol-Intro-2/","excerpt":"上一篇文章分析了互联网的总体构思，从下至上，每一层协议的设计思想。 这是从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。","text":"上一篇文章分析了互联网的总体构思，从下至上，每一层协议的设计思想。 这是从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。 原文地址: http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html 一个小结先对前面的内容，做一个小结。 我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样： 发送这个包，需要知道两个地址： 123对方的MAC地址 对方的IP地址 有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过 网关（gateway）转发。 上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。 1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况： 场景 数据包地址 同一个子网络 对方的MAC地址，对方的IP地址 非同一个子网络 网关的MAC地址，对方的IP地址 发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。 用户的上网设置静态IP地址你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？ 通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了： 1234 * 本机的IP地址 * 子网掩码 * 网关的IP地址 * DNS的IP地址 下图是Windows系统的设置窗口。 这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作 “静态IP地址上网”。 但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。 动态IP地址所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。 这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。 前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？ DHCP协议做了一些巧妙的规定。 DHCP协议首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的： （1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。 （2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。 （3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。 这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。 新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。 上网设置：小结这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍： 1234 * 本机的IP地址 * 子网掩码 * 网关的IP地址 * DNS的IP地址 有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。 一个实例：访问网页本机参数我们假定,经过上一节的步骤，用户设置好了自己的网络参数： 1234 * 本机的IP地址：192.168.1.100 * 子网掩码：255.255.255.0 * 网关的IP地址：192.168.1.1 * DNS的IP地址：8.8.8.8 然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。 这意味着，浏览器要向Google发送一个网页请求的数据包。 DNS协议我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。 DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。 然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。 子网掩码接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。 已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。 因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。 应用层协议浏览网页用的是HTTP协议，它的整个数据包构造是这样的： HTTP部分的内容，类似于下面这样： 123456789 GET / HTTP/1.1 Host: www.google.com Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 6.1) ...... Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Encoding: gzip,deflate,sdch Accept-Language: zh-CN,zh;q=0.8 Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3 Cookie: ... ... 我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。 TCP协议TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。 TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。 IP协议然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。 IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。 以太网协议最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。 以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。 服务器端响应经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。 根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。 本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。 这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。 参考 互联网协议入门(二)","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"}]},{"title":"互联网协议入门（一）","slug":"Internet-Protocol-Intro-1","date":"2018-02-03T08:39:47.000Z","updated":"2019-08-22T03:47:10.000Z","comments":true,"path":"2018/02/03/Internet-Protocol-Intro-1/","link":"","permalink":"http://blog.caoxl.com/2018/02/03/Internet-Protocol-Intro-1/","excerpt":"我们每天使用互联网，你是否想过，它是如何实现的？ 全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？ 互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。","text":"我们每天使用互联网，你是否想过，它是如何实现的？ 全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？ 互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。 原文地址: http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html 一、概述五层模型互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。 用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。 如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。 如上图所示，最底下的一层叫做 &quot;实体层&quot;（Physical Layer），最上面的一层叫做&quot;应用层&quot;（Application Layer），中间的三层（自下而上）分别是 &quot;链接层&quot;（Link Layer）、&quot;网络层&quot;（Network Layer）和&quot;传输层&quot;（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。 它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。 层与协议每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。 大家都遵守的规则，就叫做”协议”（protocol）。 互联网的每一层，都定义了很多协议。这些协议的总称，就叫做 &quot;互联网协议&quot;（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。 二、实体层我们从最底下的一层开始。 电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。 这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 三、链接层定义单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？ 这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。 以太网协议早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做 “以太网”（Ethernet）的协议，占据了主导地位。 以太网规定，一组电信号构成一个数据包，叫做 &quot;帧&quot;（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。 “标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等； “数据”则是数据包的具体内容。 “标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。 MAC地址上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？ 以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。 每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示 前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。 广播定义地址只是第一步，后面还有更多的步骤。 首先，一块网卡怎么会知道另一块网卡的MAC地址？ 回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。 其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？ 回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。 上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做 &quot;广播&quot;（broadcasting）。 有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。 四、网络层网络层的由来以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。 但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。 互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。 因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。 这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 IP协议规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。 目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。 习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。 互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。 比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。 但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。 那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数 “子网掩码” （subnet mask）。 所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。 总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 IP数据包根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。 但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？ 回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。 具体来说，IP数据包也分为&quot;标头&quot;和&quot;数据&quot;两个部分。 IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。 ARP协议关于”网络层”，还有最后一点需要说明。 因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址得到MAC地址。 这里又可以分成两种情况。 第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。 ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 五、传输层传输层的由来有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。 接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做 &quot;端口&quot;（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 “端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。 “传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流 因此，Unix系统就把 主机+端口，叫做 “套接字”（socket）。有了它，就可以进行网络应用程序开发了。 UDP协议现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。 UDP数据包，也是由&quot;标头&quot;和&quot;数据&quot;两部分组成。 “标头”部分主要定义了发出端口和接收端口， “数据”部分就是具体的内容。 然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样： UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。 TCP协议UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。 为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。 TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 六、应用层应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。 “应用层”的作用，就是规定应用程序的数据格式。 举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。 这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。 至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。下一篇，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。 参考 互联网协议入门（一）","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"}]},{"title":"HTTP 协议入门","slug":"HTTP-Protocol-Intro","date":"2018-02-03T07:43:59.000Z","updated":"2019-08-22T03:47:23.000Z","comments":true,"path":"2018/02/03/HTTP-Protocol-Intro/","link":"","permalink":"http://blog.caoxl.com/2018/02/03/HTTP-Protocol-Intro/","excerpt":"HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。 本文介绍 HTTP 协议的历史演变和设计思路。","text":"HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。 本文介绍 HTTP 协议的历史演变和设计思路。 原文地址: http://www.ruanyifeng.com/blog/2016/08/http.html HTTP/0.9HTTP 是基于 TCP/IP 协议的 应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。 最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。 1GET /index.html 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。 协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。 123&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 服务器发送完毕，就关闭TCP连接。 HTTP/1.0简介1996年5月，HTTP/1.0 版本发布，内容大大增加。 首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。 其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。 再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。 请求格式下面是一个1.0版的HTTP请求的例子。 123GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */* 可以看到，这个格式与0.9版有很大变化。 第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。 回应格式服务器的回应如下。 12345678910HTTP/1.0 200 OK Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 回应的格式是 “头信息 + 一个空行（\\r\\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。 Content-Type 字段关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type 字段的作用。 下面是一些常见的Content-Type字段的值。 123456789101112text/plaintext/htmltext/cssimage/jpegimage/pngimage/svg+xmlaudio/mp4video/mp4application/javascriptapplication/pdfapplication/zipapplication/atom+xml 这些数据类型总称为MIME type，每个值包括一级类型和二级类型，之间用斜杠分隔。 除了预定义的类型，厂商也可以自定义类型。 1application/vnd.debian.binary-package 上面的类型表明，发送的是Debian系统的二进制数据包。 MIME type 还可以在尾部使用分号，添加参数。 1Content-Type: text/html; charset=utf-8 上面的类型表明，发送的是网页，而且编码是UTF-8。 客户端请求的时候，可以使用Accept字段声明自己可以接受哪些数据格式。 1Accept: */* 上面代码中，客户端声明自己可以接受任何格式的数据。 MIME type不仅用在HTTP协议，还可以用在其他地方，比如HTML网页。 123&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;!-- 等同于 --&gt;&lt;meta charset=\"utf-8\" /&gt; Content-Encoding 字段由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。 123Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflate 客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。 1Accept-Encoding: gzip, deflate 缺点HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。 TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。 为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。 1Connection: keep-alive 一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 HTTP/1.11997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。 持久连接1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。 1Connection: close 目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。 管道机制1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。 举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求 Content-Length 字段一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。 1Content-Length: 3495 上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。 在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。 分块传输编码使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。 对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用&quot;流模式&quot;（stream）取代 &quot;缓存模式&quot;（buffer）。 因此，1.1版规定可以不使用Content-Length字段，而使用“分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。 1Transfer-Encoding: chunked 每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。 1234567891011121314151617HTTP/1.1 200 OKContent-Type: text/plainTransfer-Encoding: chunked25This is the data in the first chunk1Cand this is the second one3con8sequence0 其他功能1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。 另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。 1Host: www.example.com 有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。 缺点虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为“队头堵塞”（Head-of-line blocking）。 为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。 SPDY 协议2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。 这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。 HTTP/22015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。 二进制协议HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。 二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。 多工HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。 举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。 这样双向的、实时的通信，就叫做多工（Multiplexing）。 数据流因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。 数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。 客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。 头信息压缩HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。 HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。 服务器推送HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。 常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。 本网页 General 12345Request URL:http://blog.caoxl.com/2018/02/03/HTTP-Intro/Request Method:GETStatus Code:304 Not ModifiedRemote Address:151.101.229.147:80Referrer Policy:no-referrer-when-downgrade Response Headers 12345678910111213141516171819202122232425262728# view parsedAge:5Cache-Control:max-age=600Connection:keep-aliveDate:Sat, 03 Feb 2018 08:33:03 GMTExpires:Sat, 03 Feb 2018 08:42:58 GMTVary:Accept-EncodingVia:1.1 varnishX-Cache:HITX-Cache-Hits:1X-Fastly-Request-ID:b770852001fc1f36ee2b4c9fab1904a373276975X-Served-By:cache-hnd18734-HNDX-Timer:S1517646784.873803,VS0,VE0# view sourceHTTP/1.1 304 Not ModifiedDate: Sat, 03 Feb 2018 08:33:03 GMTVia: 1.1 varnishCache-Control: max-age=600Expires: Sat, 03 Feb 2018 08:42:58 GMTAge: 5Connection: keep-aliveX-Served-By: cache-hnd18734-HNDX-Cache: HITX-Cache-Hits: 1X-Timer: S1517646784.873803,VS0,VE0Vary: Accept-EncodingX-Fastly-Request-ID: b770852001fc1f36ee2b4c9fab1904a373276975 Request Headers 1234567891011121314151617181920212223242526# view parsedAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Encoding:gzip, deflateAccept-Language:zh-CN,zh;q=0.9Cache-Control:max-age=0Connection:keep-aliveCookie:UM_distinctid=160b6164b84670-0374eeda1906ff-7b1030-1fa400-160b6164b8580c; CNZZDATA1266840871=1026085704-1517393344-null%7C1517393344; CNZZDATA1260716016=1583935213-1514879926-%7C1517642812Host:blog.caoxl.comIf-Modified-Since:Sat, 03 Feb 2018 08:32:32 GMTReferer:http://blog.caoxl.com/archives/Upgrade-Insecure-Requests:1User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.119 Safari/537.36# view sourceGET /2018/02/03/HTTP-Intro/ HTTP/1.1Host: blog.caoxl.comConnection: keep-aliveCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.119 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Referer: http://blog.caoxl.com/archives/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: UM_distinctid=160b6164b84670-0374eeda1906ff-7b1030-1fa400-160b6164b8580c; CNZZDATA1266840871=1026085704-1517393344-null%7C1517393344; CNZZDATA1260716016=1583935213-1514879926-%7C1517642812If-Modified-Since: Sat, 03 Feb 2018 08:32:32 GMT 参考 HTTP 协议入门 Journey to HTTP/2 Hypertext Transfer Protocol HTTP/1.0 Specification HTTP/2 Specification","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.caoxl.com/tags/HTTP/"},{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"}]},{"title":"cURL 「使用笔记」","slug":"cURL-Notes","date":"2018-02-02T09:23:57.000Z","updated":"2019-08-22T03:47:26.000Z","comments":true,"path":"2018/02/02/cURL-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/02/02/cURL-Notes/","excerpt":"curl是利用URL语法在命令行方式下工作的开源文件传输工具。它被广泛应用在Unix、多种Linux发行版中，并且有DOS和Win32、Win64下的移植版本。","text":"curl是利用URL语法在命令行方式下工作的开源文件传输工具。它被广泛应用在Unix、多种Linux发行版中，并且有DOS和Win32、Win64下的移植版本。 cURL 常用命令Download a Single File下载单个文件，默认将输出打印到标准输出中(STDOUT)中 1234curl http://www.centos.org# 同样可以使用转向字符\"&gt;\"对输出进行转向输出curl http://www.centos.org &gt; centos-org.html Save the cURL Output to a file通过-o/-O选项保存下载的文件到指定的文件中： -o：将文件保存为命令行中指定的文件名的文件中 -O：使用URL中默认的文件名保存文件到本地 12345# 将文件下载到本地并命名为mygettext.htmlcurl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html# 将文件保存到本地并命名为gettext.htmlcurl -O http://www.gnu.org/software/gettext/manual/gettext.html Fetch Multiple Files at a time同时获取多个文件 123curl -O URL1 -O URL2curl -O http://www.gnu.org/software/gettext/manual/html_node/index.html -O http://www.gnu.org/software/gettext/manual/gettext.html Follow HTTP Location Headers with -L option 默认情况下CURL不会发送 HTTP Location headers(重定向).当一个被请求页面移动到另一个站点时，会发送一个 HTTP Loaction header 作为请求，然后将请求重定向到新的地址上。 123456789curl http://www.google.com&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;H1&gt;302 Moved&lt;/H1&gt;The document has moved&lt;A HREF=\"http://www.google.co.in/\"&gt;here&lt;/A&gt;# 通过-L选项进行重定向curl -L http://www.google.com Continue/Resume a Previous Download断点续传 通过使用-C选项可对大文件使用断点续传功能，如： 1234567# 当文件在下载完成之前结束该进程curl -O http://www.gnu.org/software/gettext/manual/gettext.html############## 20.1%# 通过添加-C选项继续对该文件进行下载，已经下载过的文件不会被重新下载curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html############### 21.1% Limit the Rate of Data Transfer对CURL使用网络限速 通过–limit-rate选项对CURL的最大网络使用进行限制 123# 下载速度最大不会超过1000B/secondcurl --limit-rate 1000B -O http://www.gnu.org/software/gettext/manual/gettext.html Download a file only if it is modified before/after the given time下载指定时间内修改过的文件 123curl -z 31-Dec-18 http://www.example.com/yy.htmlcurl -z -31-Dec-18 http://www.example.com/yy.html Pass HTTP Authentication in cURLCURL授权 在访问需要授权的页面时，可通过-u选项提供用户名和密码进行授权 1234curl -u username:password URL# 通常的做法是在命令行只输入用户名，之后会提示输入密码，这样可以保证在查看历史记录时不会将密码泄露curl -u username URL Download Files from FTP server从FTP服务器下载文件 CURL同样支持FTP下载，若在url中指定的是某个文件路径而非具体的某个要下载的文件名，CURL则会列出该目录下的所有文件名而并非下载该目录下的所有文件 123456# 列出public_html下的所有文件夹和文件curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/ # 下载xss.php文件 curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/xss.php List/Download using Ranges1curl ftp://ftp.uk.debian.org/debian/pool/main/[a-z]/ Upload Files to FTP Server上传文件到FTP服务器 通过 -T 选项可将指定的本地文件上传到FTP服务器上 12345678# 将myfile.txt文件上传到服务器curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com# 同时上传多个文件curl -u ftpuser:ftppass -T \"&#123;file1,file2&#125;\" ftp://ftp.testserver.com# 从标准输入获取内容保存到服务器指定的文件中curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt More Information using Verbose and Trace Option获取更多信息 通过使用 -v 和 -trace获取更多的链接信息 1curl -v http://google.co.in Get Definition of a Word using DICT Protocol通过字典查询单词 12345678# 查询bash单词的含义curl dict://dict.org/d:bash# 列出所有可用词典curl dict://dict.org/show:db# 在foldoc词典中查询bash单词的含义curl dict://dict.org/d:bash:foldoc Use Proxy to Download a File为CURL设置代理 -x 选项可以为CURL添加代理功能 1curl -x proxysever.test.com:3128 http://google.co.in Send Mail using SMTP Protocol1curl --mail-from blah@test.com --mail-rcpt foo@test.com smtp://mailserver.com 其他保存/使用网站cookie信息12345# 将网站的cookies信息保存到sugarcookies文件中curl -D sugarcookies http://localhost/sugarcrm/index.php# 使用上次保存的cookie信息curl -b sugarcookies http://localhost/sugarcrm/index.php 传递请求数据默认curl使用GET方式请求数据，这种方式下直接通过URL传递数据 可以通过 --data/-d 方式指定使用POST方式传递数据 12345678# GETcurl -u username https://api.github.com/user?access_token=XXXXXXXXXX# POSTcurl -u username --data \"param1=value1&amp;param2=value\" https://api.github.com# 也可以指定一个文件，将该文件中的内容当作数据传递给服务器端curl --data @filename https://github.api.com/authorizations 注：默认情况下，通过POST方式传递过去的数据中若有特殊字符，首先需要将特殊字符转义在传递给服务器端，如value值中包含有空格，则需要先将空格转换成%20，如： 1curl -d \"value%201\" http://hostname.com 在新版本的CURL中，提供了新的选项 --data-urlencode，通过该选项提供的参数会自动转义特殊字符。 1curl --data-urlencode \"value 1\" http://hostname.com 除了使用GET和POST协议外，还可以通过 -X 选项指定其它协议，如： 1curl -I -X DELETE https://api.github.cim 上传文件 1curl --form \"fileupload=@filename.txt\" http://hostname/resource curl网站开发指南一、查看网页源码直接在curl命令后加上网址，就可以看到网页源码。我们以网址www.sina.com为例（选择该网址，主要因为它的网页代码较短）： 1curl www.sina.com 如果要把这个网页保存下来，可以使用-o参数，这就相当于使用wget命令了。 1curl -o [文件名] www.sina.com 二、自动跳转有的网址是自动跳转的。使用-L参数，curl就会跳转到新的网址。 1curl -L www.sina.com 键入上面的命令，结果就自动跳转为www.sina.com.cn。 三、显示头信息-i参数可以显示http response的头信息，连同网页代码一起。 1curl -i www.sina.com -I参数则是只显示http response的头信息。 四、显示通信过程-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。 1curl -v www.sina.com 如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。 1curl --trace output.txt www.sina.com 或者 1curl --trace-ascii output.txt www.sina.com 运行后，请打开output.txt文件查看。 五、发送表单信息发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。 1curl example.com/form.cgi?data=xxx POST方法必须把数据和网址分开，curl就要用到--data参数。 1curl -X POST --data \"data=xxx\" example.com/form.cgi 如果你的数据没有经过表单编码，还可以让curl为你编码，参数是--data-urlencode。 1curl -X POST--data-urlencode \"date=April 1\" example.com/form.cgi 六、HTTP动词curl默认的HTTP动词是GET，使用-X参数可以支持其他动词。 1curl -X POST www.example.com 1curl -X DELETE www.example.com 七、文件上传假定文件上传的表单是下面这样： 1234&lt;form method=\"POST\" enctype='multipart/form-data' action=\"upload.cgi\"&gt; &lt;input type=file name=upload&gt; &lt;input type=submit name=press value=\"OK\"&gt;&lt;/form&gt; 你可以用curl这样上传文件： 1curl --form upload=@localfilename --form press=OK [URL] 八、Referer字段有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。 1curl --referer http://www.example.com http://www.example.com 九、User Agent字段这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。 iPhone4的User Agent是 1Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7 curl可以这样模拟： 1curl --user-agent \"[User Agent]\" [URL] 十、cookie使用--cookie参数，可以让curl发送cookie。 1curl --cookie \"name=xxx\" www.example.com 至于具体的cookie的值，可以从http response头信息的Set-Cookie字段中得到。 -c cookie-file可以保存服务器返回的cookie到文件，-b cookie-file可以使用这个文件作为cookie信息，进行后续的请求。 12 curl -c cookies http://example.com curl -b cookies http://example.com 十一、增加头信息有时需要在http request之中，自行增加一个头信息。--header参数就可以起到这个作用。 1curl --header \"Content-Type:application/json\" http://example.com 十二、HTTP认证有些网域需要HTTP认证，这时curl需要用到--user参数。 1curl --user name:password example.com 参考 curl网站开发指南 15 Practical Linux cURL Command Examples CURL常用命令 Using curl to automate HTTP jobs CURL 百度百科 Linux curl命令详解 command line tool and library for transferring data with URLs","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Internet","slug":"Internet","permalink":"http://blog.caoxl.com/tags/Internet/"},{"name":"cURL","slug":"cURL","permalink":"http://blog.caoxl.com/tags/cURL/"}]},{"title":"云通信 「开发日志」","slug":"Aliyun-Sms-Dev-Log","date":"2018-02-02T05:28:55.000Z","updated":"2019-08-22T06:45:35.000Z","comments":true,"path":"2018/02/02/Aliyun-Sms-Dev-Log/","link":"","permalink":"http://blog.caoxl.com/2018/02/02/Aliyun-Sms-Dev-Log/","excerpt":"阿里云通信, 原阿里大于. 大神直接绕路,本文乃小学生式教学. 本文只是使用了一个短信通知服务,如需要别的服务可:查看文档","text":"阿里云通信, 原阿里大于. 大神直接绕路,本文乃小学生式教学. 本文只是使用了一个短信通知服务,如需要别的服务可:查看文档 简单来说就下下图: 准备 阿里云账号, 毫无疑问. 开通 短信服务 下载SDk 我使用的是PHP,当然下载PHP SDK 申请阿里云的访问密钥 Access Key 获取参数 短信签名 短信模板 短信签名,个人只能拥有一个,需要多个需要升级为企业.短信模板可以申请多个. 入参列表/出参列表 详见文档 使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 代码节选，详见api_demo/SmsDemo.php...class SmsDemo&#123; ... * 短信服务API产品的DEMO程序,工程中包含了一个SmsDemo类，直接通过 * 执行此文件即可体验语音服务产品API功能(只需要将AK替换成开通了云通信-短信服务产品功能的AK即可) * 备注:Demo工程编码采用UTF-8 *//** * 发送短信 * @return stdClass */ public static function sendSms() &#123; // 初始化SendSmsRequest实例用于设置发送短信的参数 $request = new SendSmsRequest(); // 必填，设置短信接收号码 $request-&gt;setPhoneNumbers(\"12345678901\"); // 必填，设置签名名称，应严格按\"签名名称\"填写，请参考: https://dysms.console.aliyun.com/dysms.htm#/develop/sign $request-&gt;setSignName(\"短信签名\"); // 必填，设置模板CODE，应严格按\"模板CODE\"填写, 请参考: https://dysms.console.aliyun.com/dysms.htm#/develop/template $request-&gt;setTemplateCode(\"SMS_0000001\"); // 可选，设置模板参数, 假如模板中存在变量需要替换则为必填项 $request-&gt;setTemplateParam(json_encode(Array( // 短信模板中字段的值 \"code\"=&gt;\"12345\", \"product\"=&gt;\"dsd\" ))); // 可选，设置流水号 $request-&gt;setOutId(\"yourOutId\"); // 选填，上行短信扩展码（扩展码字段控制在7位或以下，无特殊需求用户请忽略此字段） $request-&gt;setSmsUpExtendCode(\"1234567\"); // 发起访问请求 $acsResponse = static::getAcsClient()-&gt;getAcsResponse($request); return $acsResponse; &#125; // 调用示例：set_time_limit(0);header('Content-Type: text/plain; charset=utf-8');$response = SmsDemo::sendSms();echo \"发送短信(sendSms)接口返回的结果:\\n\";print_r($response); 阿里云的服务,文档都很人性化,花点时间看看即可上手 进阶将代码上传到服务器,使用Crontab 定时任务,每天定时发短信~~ FAQ记得充钱,云通信短信服务是收费的,不过巨便宜~~ 参考 短信发送API(SendSms) 签名申请手册 模板申请手册 Crontab Is So Easy","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"},{"name":"阿里云","slug":"阿里云","permalink":"http://blog.caoxl.com/tags/阿里云/"},{"name":"Aliyun","slug":"Aliyun","permalink":"http://blog.caoxl.com/tags/Aliyun/"},{"name":"云通信","slug":"云通信","permalink":"http://blog.caoxl.com/tags/云通信/"}]},{"title":"正则表达式 「学习笔记」","slug":"Regex-Dev-Notes","date":"2018-02-01T09:57:07.000Z","updated":"2019-08-22T07:06:53.000Z","comments":true,"path":"2018/02/01/Regex-Dev-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/02/01/Regex-Dev-Notes/","excerpt":"正则表达式 是字符串搜索与匹配的神器。","text":"正则表达式 是字符串搜索与匹配的神器。 正则表达式最初起源并不是计算机科学家的成果，而是自动控制理论和形式语言的研究者开始提出并使用的。 最早将正则表达式引入计算机领域的是 肯·汤普逊，即 UNIX 的联合创始人。随着 UNIX 的流行和 Linux 的诞生，正则表达式被广泛应用到各种类 UNIX 系统和工具中。熟悉 Linux 命令的人都知道 Linux 有个查找字符串的神器指令：grep。 如今，正则表达式已经无孔不入了，无论是程序员还是用户，都经常接触正则表达式，比如手机输入法，比如 Windows 里面的文件搜索，比如 Linux 的 ls，网站的登录和注册等等。 在用户注册验证的常见 3 种实现思路中，都用到了正则表达式，这也就是说各种编程语言都支持正则表达式。 前面写过 Ajax 登录验证时使用到了正则表达式，但是只是简单是使用了几句正则表达式，使用到的 PHP 正则函数就一个 preg_match()，而非系统的理论学习。现在将学习 正则表达式的基本语法 比较全面地总结一下。 不过,能不用正则的情况,尽量不用正则 界定符表示一个正则表达式的开始和结束，通常有 3 种界定符：/.../ 、 #...# 、{...} 。 一般使用最多的是 /.../，比如：/[0-9a-zA-Z]/。 原子原子分为可见原子和不可见原子。 可见原子指的是 Unicode 编码表中用键盘输出后 肉眼可见 的字符。主要有： 标点符号： &quot; 、 _ 、? 等。 英文字母和数字。 汉字、英语和其他语言文字。 这些可见原子在进行正则匹配的时候不能直接使用实际的语言词汇，而是要转换成 Unicode 编码。 数理化公式符号。等其他可见字符。 不可见原子指的是 Unicode 编码表中用键盘输出后 肉眼不可见 的字符。主要有： 换行符 \\n 回车符 \\r 制表符 \\t 空格。等其他不可见符号。 原子的集合 .：匹配除换行符之外的任意字符。 \\d：匹配任意一个十进制数字，即 [0-9]。 \\D：匹配任意一个非十进制数字，即 [^0-9]。 \\s：匹配一个不可见原子，即 [\\f\\n\\r\\t\\v]。 \\S：匹配一个可见原子，即 [^\\f\\n\\r\\t\\v]。 \\w：匹配任意一个数字、字母或下划线，即 [0-9a-zA-Z] 。 \\W：匹配任意一个非数字、字母或下划线，即 [0-9a-zA-Z] 。 元字符元字符指定了原子的筛选方式。主要有： |：匹配两个或者多个分支选择。 []：匹配方括号中的任意一个原子。 [^]：匹配除方括号中的原子之外的任意字符。 量词 {n}：表示其前面的原子恰好出现 n 次。 {n,}：表示其前面的原子最少出现 n 次 {n, m}：表示其前面的原子最少出现 n 次最出 m 次。 *: 匹配 0 次、1 次 或者多次其之前的原 子 ， 即 { 0, } 。 +：匹配 1 次或者多次其之前的原子，即 { 1, } 。 ?：匹配 0 次或者 1 次其之前的原子，即 { 0, 1 } 边界控制 ^：匹配字符串开始的位置。 $: 匹配字符串结束的位置。 ()：匹配其中的整体为一个原子。 模式单元总模式每个 pattern 可以看作是一个总模式。 子模式pattern 的每个模式单元 (...) 称为子模式，包含在总模式中。 常见修正模式 U：懒惰匹配，即是：只匹配最近的一个字符串，不重复匹配。 i：忽略英文字母大小写。 x：忽略空白。 s：让元字符 . 匹配包括换行符在内所有字符，即将字符串视为单行，换行符作为普通字符。 e：e 配合函数 preg_replace() 使用, 可以把匹配来的字符串当作正则表达式执行 D：如果使用 $ 限制结尾字符,则不允许结尾有换行。 A：强制从目标字符串开头匹配。 m：将字符串视为多行,不管是那行都能匹配。 g：表示全局匹配。 贪婪匹配匹配结果存在歧义时取其长。 懒惰匹配匹配结果存在歧义时取其短。 参考 Regex Tester 站长之家编码转换","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"Regex","slug":"Regex","permalink":"http://blog.caoxl.com/tags/Regex/"}]},{"title":"Linux 系统中的目录","slug":"Linux-Catalog","date":"2018-02-01T09:41:52.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/01/Linux-Catalog/","link":"","permalink":"http://blog.caoxl.com/2018/02/01/Linux-Catalog/","excerpt":"了解 Linux 目录的解释对高效使用 Linux 来说很有用。下列解释摘自 The Linux Command Line 一书，同时我补充了一些对应的英文全称。","text":"了解 Linux 目录的解释对高效使用 Linux 来说很有用。下列解释摘自 The Linux Command Line 一书，同时我补充了一些对应的英文全称。 目录 / 根目录，万物起源。 /bin 包含系统启动和运行所必须的二进制程序。 /boot 包含 Linux 内核，最初的 RAM 磁盘映像（系统启动时，由驱动程序所需），和 启动加载程序。有趣的文件。 /boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。 /boot/vmlinuz，Linux 内核。 /dev 这是一个包含设备结点的特殊目录。“一切都是文件”，也使用于设备。 在这个目录里，内核维护着它支持的设备。 /etc 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本，在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。 有意思的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件： 12345- /etc/crontab， 定义自动运行的任务。- /etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。- /etc/passwd，包含用户帐号列表。 /home：在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。 /lib：包含核心系统程序所需的库文件。这些文件与 Windows 中的动态链接库相似。 /lost+found：每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统，都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文件系统 真正的损坏了，那么这个目录会是个空目录。 /media：在现在的 Linux 系统中，/media 目录会包含可移除媒体设备的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些设备连接到计算机之后，会自动地挂载到这个目录结点下。 /mnt：在早些的 Linux 系统中，/mnt 目录包含可移除设备的挂载点。 /opt：这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 /proc：这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 反而，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 /root root 帐户的家目录。 /sbin 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 /tmp 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置，导致系统每次 重新启动时，都会清空这个目录。 /usr：UNIX Share Resources。在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 /usr/bin：/usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 /usr/lib：包含由/usr/bin 目录中的程序所用的共享库。 /usr/local：这个/usr/local 目录，是非系统发行版自带，却打算让系统使用的程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中，会存在这个目录， 但却是空目录，直到系统管理员放些东西到它里面。 /usr/sbin：包含许多系统管理程序。 /usr/share：/usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 - 其中包括像默认的配置文件，图标，桌面背景，音频文件等等。 /usr/share/doc：大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 /var：除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录是可能需要改动的文件存储的地方。各种数据库，假脱机文件， 用户邮件等等，都驻扎在这里。 /var/log：这个/var/log 目录包含日志文件，各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中，你必须是超级用户才能查看这些日志文件。 部分目录的英语全称 参考 The Linux Command Line 《开源世界旅行手册》","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"PHP 中的空元素和 NULL","slug":"PHP-NULL-AND-Empty","date":"2018-02-01T08:56:52.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/01/PHP-NULL-AND-Empty/","link":"","permalink":"http://blog.caoxl.com/2018/02/01/PHP-NULL-AND-Empty/","excerpt":"变量为空和值为 NULL 的变量是各大编程语言中都容易混淆的概念，今天就总结一下 PHP 中的空元素和 NULL 常量。","text":"变量为空和值为 NULL 的变量是各大编程语言中都容易混淆的概念，今天就总结一下 PHP 中的空元素和 NULL 常量。 运行1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php/** * 测试 PHP 中的 null, false, '0', '', 0, array(), var $var 是否：相等、全等、为空、为 NULL * 没有任何属性的元素都为空 * NULL 类型只有一个值，就是不区分大小写的特殊常量 NULL，表示变量没有值 * 在下列情况下一个变量被认为是 NULL：被赋值为 NULL；尚未被赋值；被 unset() * 使用 `(unset) $var` 将一个变量转换为 null 不会删除该变量或 unset 其值，仅是返回 NULL 值而已 */$cpr = array( 'null' =&gt; null, 'false' =&gt; false, '0' =&gt; 0, \"''\" =&gt; '', \"'0'\" =&gt; '0', 'array()' =&gt; array(), '$var' =&gt; @$var);$len = count( $cpr ) ;foreach ( $cpr as $k=&gt;$v ) &#123; $keys[] = $k ; $vals[] = $v ;&#125;echo '在 PHP 中:'.\"\\n\\n\" ;for ( $i=0; $i&lt;$len; ++$i ) &#123; echo \"\\n\", $keys[ $i ] ; echo ( empty( $vals[ $i ] ) ) ? ' 为空' : ' 不为空' ; echo ( is_null( $vals[ $i ] ) ) ? ' 且为 NULL' : ' 但不为 NULL' ; echo \"\\n\" ; for ( $j=$i+1; $j&lt;$len; ++$j ) &#123; if ( $vals[ $i ] == $vals[ $j ] ) &#123; if ( !($vals[ $i ] === $vals[ $j ]) ) &#123; echo \"\\n\\t\", $keys[ $i ], ' 和 ', $keys[ $j ], ' 的值相等, 但是类型不相等', \"\\n\" ; &#125; &#125; else &#123; echo \"\\n\\t\", $keys[ $i ], ' 和 ', $keys[ $j ], ' 不相等', \"\\n\" ; &#125; echo \"\\n\" ; &#125;&#125; 总结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677在 PHP 中:null 为空 且为 NULL null 和 false 的值相等, 但是类型不相等 null 和 0 的值相等, 但是类型不相等 null 和 '' 的值相等, 但是类型不相等 null 和 '0' 不相等 null 和 array() 的值相等, 但是类型不相等false 为空 但不为 NULL false 和 0 的值相等, 但是类型不相等 false 和 '' 的值相等, 但是类型不相等 false 和 '0' 的值相等, 但是类型不相等 false 和 array() 的值相等, 但是类型不相等 false 和 $var 的值相等, 但是类型不相等0 为空 但不为 NULL 0 和 '' 的值相等, 但是类型不相等 0 和 '0' 的值相等, 但是类型不相等 0 和 array() 不相等 0 和 $var 的值相等, 但是类型不相等'' 为空 但不为 NULL '' 和 '0' 不相等 '' 和 array() 不相等 '' 和 $var 的值相等, 但是类型不相等'0' 为空 但不为 NULL '0' 和 array() 不相等 '0' 和 $var 不相等array() 为空 但不为 NULL array() 和 $var 的值相等, 但是类型不相等$var 为空 且为 NULL","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"Programmer VS Coder 「Who You Want To Be」","slug":"Be-Precautional-When-People-Call-You-Niubier","date":"2018-02-01T08:07:15.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/01/Be-Precautional-When-People-Call-You-Niubier/","link":"","permalink":"http://blog.caoxl.com/2018/02/01/Be-Precautional-When-People-Call-You-Niubier/","excerpt":"这篇文章转载自一位我所认同的 “大神”,学习他的 “大神危机论”以自勉","text":"这篇文章转载自一位我所认同的 “大神”,学习他的 “大神危机论”以自勉 作为一名普通程序员，如果你周围有人开始称你为所谓的 “大神”，那么你应当警惕了。 除非你是公认的天才，有傲人的经历，有超群的智商，那么大家称呼你为 “大神” 你勉强可以“自以为是”。但是，如果你天资普通，并没有过人的经历，却有人也开始称呼你为“大神”，作为一个有自知之明和上进心的程序员，这时候你不应该沉浸在这种满足感中，而是应该“冷静”下来想想你和你周围的环境有什么不太对的地方。 Calm Down是否太爱表现自己粗俗地说就是：是不是太爱装 B。 喜欢装的人往往会刻意在别人注意你的时候把玩一些比较高大上的东西，吸引别人来问你这是什么东西，以及如何使用之类的。如果你本来就会用到这些高大上的东西到无可厚非，但是如果你根本不怎么会使用这些东西，却为了把别人”比下去“而亮出来，为了装而装，这样的心理，迟早会害了你。 因为爱显摆的人往往比较虚荣、骄傲自负、华而不实，这样的人经不起打击，也听不得不顺耳的话，既不能听进去别人友善的建议，更不论虚心交流了，也不能静下心来研究细节，最终只能有个自我臭美的空架子罢了。 是否不会说“不”我就有点属于这种人，对我来说，拒绝别人需要一点勇气，但是如果不论别人请求自己能不能做好都不知道的事情都拍拍胸脯 “自信” 地保证下来，这样其实是不太好的，因为容易给人留下你”无所不能”的假象。 学会拒绝你没时间去做，没必要去做，没能力做好的事情，专业的人做专业的事，效率和质量最重要。生活不是总想着要证明自己，也要把时间”浪费”自己的生活上。 此外，家里总会有人在等你。 是否过早进入「Comfort Zone」如果你只是处于职业生涯早期，但周围的环境不能带给你动力和激情，你总觉得你仅用你会的一部分就能完成好工作，那么你多半是进入了舒适区的假象。 一万小时理论还是很具有说服力的，因此，如果作为不是天才的你，过早觉得一切问题仅凭你目前的技能储备都能游刃有余，那么很可能说明你目前所在的平台不太适合你，你可以尝试去挑战一些能带来进步的机会，更应该主动向比你厉害很多的人学习。 千万不要在正值年轻气盛的岁数去享受这种舒适的感觉，年轻就应该不断超越现在的自己，总要经历无数个拼搏之夜才能心安理得地享受技术带给你的自由。 没有什么捷径之说，我想尽管是那些公认的天才，也必然经历过很长的积累的过程，只是他们积累的速度比普通人快一些罢了。 Coder vs ProgrammerCoder 他们写出机器可以理解的代码。 他们的代码依靠注释读懂。 他们只在工作时间写代码。 他们不喜欢看书，但偶尔会看看视频。 他们只会阅读别人的博客，自己从来不写。 他们关注的仅仅是进度。 他们仅仅是复制代码。 遇到问题他们会直接问同伴。 他们总是认为自己会的很多，喜欢用海量的“精通”来装点自己的简历，假装高手。 他们每天沉寂在C+V的死循环中，并不断地抱怨需求变更。 他们会因为学会了某种代码的写法，而骄傲自满。 他们一边在被动地接受需求，一边在抱怨不合理的需求。 他们不会检查自己的代码，在测试暴露缺陷之前，他们往往难以发现。 他们不认为自己要为代码质量负责，那应该是管理者和测试的事情。 他们在拿到任务后会直接开始工作。 他们往往具有文档恐惧症。 他们并不崇拜专业人士。 他们擅长推卸责任。 他们对编译警告弃之不理。 他们只是在写可以运行的程序。 他们会拖延不喜欢的任务。 他们更容易放弃自己的设计。 他们的编程往往止步于编码的表象。 Programmer 他们写出人可以读懂的代码。 他们的代码风格统一并具有自描述性。 他们不仅在工作时间，在业余时间也会写代码。 他们会看大量的书籍，阅读大量技术资料，当然也会看视频。 他们不仅阅读别人的博客，他们自己也会写博客，他们认为分享知识是快乐的。 他们不仅关注进度而且更关注代码的质量，提供现实的进度方案，在上司面前坚持自己的意见。 他们复用代码而不是复制代码。 遇到问题他们会尝试自己解决，访问社区，然后才会询问同伴。 他们总是认为自己还能做的更好，并对那些巨人由衷地敬佩，在不是高手时不假装高手。 他们经常在思索如何能够解耦，用灵动的设计应对突然到来的变更。 当掌握某种代码的写法，他们看到的往往是背后深层次的问题，并向专业水准看齐。 他们会对不合理的需求说不，并在工作中尝试影响他们的领导。 他们会经常重构自己的代码，并维护自己的缺陷核对表。 他们认为提高代码质量是自己的责任，并为自己的过失而负责 他们在拿到任务后，会在行动之前，进行分析和计划，而不是马上编码。 他们往往会认真阅读项目文档。 他们和希望提高软件开发技能的人为伍，参加交流会，加入某个社区参与技术讨论。 他们敢于承认错误。 他们将警告与错误同等对待。 他们在构建自己彻底理解的程序。 他们将不喜欢的任务认为是对自身的磨砺。 他们往往坚持自己的设计。 他们的编程往往深入语言，触及思想。 其他程序的价值 快速完成大规模计算，计算量小的时候价值显示不出来，但往往可以用于测试。 狼与哈士奇 你说你喜欢程序，想做程序员。对不起，同学，你说错了，你搞错概念了。你现在去做的只能叫“编码者（coder）”，不能叫“程序员（Programmer）”，连背包问题都不知为何，连模式都不知是啥，连最起码的链堆栈都搞不清楚，你说什么程序员，对不起你差远了，你所学到的，所运用的，只是某种语言的语法，而这对于一位有经验的程序员来说，不过三五天的事儿。 狼和哈士奇的隐喻意味着 Coder 难以在技术实战中战胜Programmer，但现实是，往往 Coder 更受欢迎，如同哈士奇更讨人喜欢一样。 原因很简单，Programmer 在众多Coder之中显得格格不入。Programmer 能更快更高效地完成任务，他们讨厌加班，抵制低效的流程，他们对自己的能力深信不疑，并经常坚持自己的意见，对不合理的需求说不。这些，在雇主的眼里就是叛逆。 而 Coder 就低调很多，他们甘于加班，对设计没有意见，不会对需求说不，出了问题他们总在说，这是别人的问题。他们两者的代码，在外行看来没有差别。在雇主眼中，往往那些闭嘴加班的员工更应该重用。 也许，Programmer 们并不想让自己被孤立，但现实却是残酷的。人们缺少包容，善意的提醒，也可能会被认为是卖弄，是对权威的挑战。狼只有在狼群中，才能得到自身的认同感。软件的构建者是 Programmer 而不是 Coder。如果你是一匹狼，而你有感受不到团队的认同感，那你不妨换一换环境，因为，和臭棋篓子下棋，永远无法进步。 如果你是位开明的领导者，当你读到这篇文章时，我真切地希望你能留意那些“带刺”的员工，因为很可能，他比你团队中的其他人都看的更远。 如果你是名程序员，那么你一定要选择到底是做狼还是哈士奇。狼可能没有安稳的生活，没有丰盛的午餐，但却拥有强大的力量，自由，以及尊严。 算法 算法是程序的灵魂，为什么有些网站能够在高并发，和海量吞吐情况下依然坚如磐石？ 大家可能会说：网站使用了服务器群集技术、数据库读写分离和缓存技术（比如 memcahced 和 redis 等）。那如果我再深入的问一句，这些优化技术又是怎样被那些天才的技术高手设计出来的呢? 我在上大学的时候就在想，究竟是什么让不同的人写出的代码从功能看是一样的，但从运行效率上却有天壤之别，就拿以前在软件公司工作的实际经历来说吧，我是做服务器的，环境是UNIX系统，功能是要支持上千万人同时在线，并保证数据传输的稳定，在服务器上线前，做过内测，一切 OK，可实际上线后，服务器就支撑不住了，公司的 CTO（首任 sina CTO）花了 3 天时间对我的代码进行优化，再次上线，坚如磐石。 那一瞬间，我认识到程序是有灵魂的，就是算法。 如果你不想永远都是一个代码工人，不想当孬种程序员，那么你就要看算法。 参考 “大神” 危机：Programmer vs Coder","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/tags/Caoxl/"},{"name":"Programmer","slug":"Programmer","permalink":"http://blog.caoxl.com/tags/Programmer/"},{"name":"Coder","slug":"Coder","permalink":"http://blog.caoxl.com/tags/Coder/"}]},{"title":"MySQL「性能优化」","slug":"MySQL-Performance-Optimization","date":"2018-02-01T07:17:44.000Z","updated":"2019-08-22T06:29:05.000Z","comments":true,"path":"2018/02/01/MySQL-Performance-Optimization/","link":"","permalink":"http://blog.caoxl.com/2018/02/01/MySQL-Performance-Optimization/","excerpt":"数据库优化与检查是一项比较艰难的任务，必须借助于一些工具，而且往往问题比较隐蔽，多是在部署在生产环境一段时间之后，因为数据库的性能瓶颈，导致一系列问题的产生。","text":"数据库优化与检查是一项比较艰难的任务，必须借助于一些工具，而且往往问题比较隐蔽，多是在部署在生产环境一段时间之后，因为数据库的性能瓶颈，导致一系列问题的产生。 常用参数 查看mysql是否开启慢查询日志 12show variables like 'slow_query_log';set global slow_query_log=on; //开启慢查日志 设置没有索引的记录到慢查询日志 1set global log_queries_not_using_indexes=on; 查看超过多长时间的sql进行记录到慢查询日志 12show variables like 'long_query_time';set global long_query_time=1; 慢查日志分析工具mysqldumpslow使用mysqldumpslow -h来查看帮助信息使用mysqldumpslow -t 3 /home/mysql/data/mysql-slow.log | more来对日志进行分析。 pt-query-digest输出到文件： 1pt-query-digest show.log &gt; slow_log.repor 如何通过慢查日志发现有问题的SQL？查询次数多且每次查询占用时间长的SQL通常为pt-query-digest分析的前几个查询 IO大的SQL，数据库的主要瓶颈就在于IO注意pt-query-digest分析中的 Rows examine 项。扫描行数多，占用io大 未命中索引的sql注意pt-query-digest分析中Rows examine（扫描行数）和Rows send（发送行数）的对比如果这个比值比较大，说明索引命中率不高 怎么优化有问题的sql使用explain查询SQL的执行计划1explain select * from user; table：表名； type：连接的类型，const、eq_reg、ref、range、index和ALL； const：主键、索引; eq_reg：主键、索引的范围查找; ref：连接的查找（join）; range：索引的范围查找; index：索引的扫描; All：表扫描 possible_keys：可能用到的索引； key：实际使用的索引； key_len：索引的长度，越短越好；因为mysql每次的读取都是以页为单位，一页中的索引越大，查询的效率就越高 ref：索引的哪一列被使用了，常数较好； rows：mysql认为必须检查的用来返回请求数据的行数； extra：using filesort、using temporary（常出现在使用order by时）时需要优化，因为都是用了外部文件或者临时表的存储 选择合适的索引列 在where，group by，order by，on从句中出现的列 索引字段越小越好(因为数据库的存储单位是页，一页中能存下的数据越多越好 )索引字段越小越好，是因为数据库的存储是以页为单位，一页数据存储越大，获取的数据也越多，对我们io的效率也更好 离散度大得列放在联合索引前面 计算离散度: 1select count(distinct customer_id), count(distinct staff_id) from payment; 查找字段的唯一值（不同数的个数）来确定count（distinct customer_id）离散度的大小来确定索引建立在哪一个列上. 离散度，我的理解就是唯一性了，比如主键，绝对是离散度最大的，而一些用来标识状态标识的列，基本只有几个可选项，离散度就很小 index(col1,col2) 在建立联合索引时，离散度高的列放到前面 冗余索引检查索引存在的目的是为了加快查询的效率，不过不是索引越多越好，建立索引要适当才好。 过多的索引会增加数据库判断使用什么索引来查询的开销，所以，有时候也会出现以去掉重复或者无效的索引为优化手段的优化方式。 冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，下面这个例子中key(name, id)就是一个冗余索引 1create table test(id int not null primay key,name varchar(10) not null,title varchar(50) not null, key(name,id))engine=innodb; 主键索引本来就是唯一索引 索引检查语句123456789101112use information_schema;SELECT a.TABLE_SCHEMA AS 'db' ,a.TABLE_NAME AS 'table' ,a.INDEX_NAME AS 'index1' ,b.INDEX_NAME AS 'index2' ,a.COLUMN_NAME AS 're_col'FROM STATISTICS a JOIN STATISTICS b ON a.TABLE_SCHEMA = b.TABLE_SCHEMAAND a.TABLE_NAME = b.TABLE_NAME AND a.SEQ_IN_INDEX = b.SEQ_IN_INDEX AND a.COLUMN_NAME = b.COLUMN_NAMEWHERE a.SEQ_IN_INDEX = 1 AND a.INDEX_NAME &lt;&gt; b.INDEX_NAME 索引检查工具 pt-duplicate-key-checker查询冗余索引工具 pt-duplicate-key-checker -uroot -p &#39;123456&#39; -h 127.0.0.1 字段类型优化 可以使用int类型存储时间类型： int类型转时间类型函数：from_unixtime() 时间类型转int类型：unix_timestemp() 可以使用bigint存储ip地址 bigint类型转ip函数：inet_aton() ip转bigint类型：inet_ntoa() 参考 Mysql性能优化笔记","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"优化","slug":"优化","permalink":"http://blog.caoxl.com/tags/优化/"}]},{"title":"Sublime Text","slug":"Sublime-Text-Notes","date":"2018-02-01T06:54:53.000Z","updated":"2019-08-22T03:29:10.000Z","comments":true,"path":"2018/02/01/Sublime-Text-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/02/01/Sublime-Text-Notes/","excerpt":"免责声明：本文绝无引战之意，也不进行对比，只总结 Sublime 开发配置。","text":"免责声明：本文绝无引战之意，也不进行对比，只总结 Sublime 开发配置。 插件编辑器自身 Package Control PackageResourceViewer auto-save All Autocomplete AdvancedNewFile File Rename 主题 + 侧栏 Material Themes colorsublime SideBarEnhancements SideBarSeparator SyncedSideBar SyncedSidebarBg A File Icon Hide Sidebar When Not Focussed：使用 Cmd+B, Cmd+K 切换。 补全+智能提示 SublimeCodeIntel sublimelint SublimeLinter BracketHighlighter ColorHighlighter Statusbar Path JSON Lint Pretty JSON JSON Comma 小工具+MD Inc-Dec-Value ColorPicker Convert case MarkdownHighlighting Markdown Preview Build with: markdown 生成 html Git 集成 Git GitGutter DiffView GitDiffHelper Gitignore SublimeGit 前端 Emmet HTML-CSS-JS Prettify HTML5 Javascript Completions Javascript Console jQuery SublimeLinter-jshint PHP 开发 SublimeLinter-php SublimeLinter-phplint PHPIntel DocBlockr PHP Getters and Setters PHP Companion PHP Completions Kit PHP Code Sniffer(Phpcs) 123456brew search php-code-snifferbrew install homebrew/php/php-code-snifferbrew search php-cs-fixerbrew install homebrew/php/php-cs-fixerwhich phpcswhich php-cs-fixer 然后在 phpcs.sublime-settings 需要手动设置的选项如下： 123\"phpcs_show_errors_on_save\": false; // 关闭保存时弹出提示框\"php_cs_fixer_executable_path\": \"/usr/local/bin/php-cs-fixer\",\"phpcs_php_path\": \"/usr/local/bin/phpcs\", 如果提示找不到文件，则需要手动创建默认配置文件 phpcs.sublime-settings。 Laravel Blade Highlighter Laravel Blade Spacer 终端 VIM Navigation Terminal 快捷键有些快捷键是需要先安装相应的插件后才有用的，下面为常用的默认快捷键： cmd + p：搜索并打开文件，行跳转 cmd + shift + p：打开命令 太 tm 有用了，可以免去记忆很多并不是很快捷的快捷键，安装的插件基本上都可以通过这个命令搜索并打开。 cmd + r：当前文件内查找函数 cmd + f：当前文件内查找 cmd+alt+f：当前文件内查找并替换 cmd+shift+f：指定路径中查找并替换 cmd + enter：无格式换行 cmd + option + 1/2/3/…：设置窗口分组 ctrl + 1/2/3/…：在窗口分组间切换 enter／shift+enter：从搜索结果中向下／上切换 cmd + f &amp;&amp; alt + enter: 从搜索结果中多行修改 cmd+k &amp;&amp; cmd+b: 隐藏／显示左侧文件树 cmd + shift + v:无格式粘贴 如果在 sublime text 中直接使用 cmd + v 粘贴一段代码的话，会连同复制源的格式一同复制下来，结果基本上都是很丑的。使用无格式粘贴能确保格式统一。 ctrl + &#39;：打开控制台输出（python） 编程字体 consolas for powerline mononoki fira-code inconsolata dejavu-sans-mono-for-powerline roboto-mono 安装方式参考：Mac 流#字体。 附录主要配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; \"always_show_minimap_viewport\": true, \"show_encoding\": true, \"bold_folder_labels\": true, \"color_scheme\": \"Packages/Material Theme/schemes/Material-Theme-Palenight.tmTheme\", \"fade_fold_buttons\": false, \"find_selected_text\": true, \"font_face\": \"dejavu sans mono for powerline\", // inconsolata // mononoki // fira code // roboto mono // consolas for powerline \"font_options\": [ // \"bold\", \"gray_antialias\", \"subpixel_antialias\" ], \"font_size\": 18, \"highlight_line\": true, \"highlight_modified_tabs\": true, \"ignored_packages\": [ ], \"indent_guide_options\": [ \"draw_normal\", \"draw_active\" ], \"line_padding_bottom\": 3, \"line_padding_top\": 3, \"match_selection\": true, \"material_theme_accent_bright-teal\": true, \"material_theme_accent_lime\": true, \"material_theme_big_fileicons\": true, \"overlay_scroll_bars\": \"enabled\", \"rulers\": [ 80, 100, 120 ], \"scroll_past_end\": true, \"show_full_path\": true, \"smart_indent\": true, \"tab_completion\": false, \"tab_size\": 4, \"theme\": \"Material-Theme-Palenight.sublime-theme\", \"translate_tabs_to_spaces\": true, \"trim_trailing_white_space_on_save\": true, \"vintage_start_in_command_mode\": true, \"word_wrap\": true, \"wrap_width\": 80&#125; PHP Code Sniffer 配置示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&#123; // Plugin settings // Turn the debug output on/off \"show_debug\": false, // Which file types (file extensions), do you want the plugin to // execute for \"extensions_to_execute\": [\"php\"], // Do we need to blacklist any sub extensions from extensions_to_execute // An example would be [\"twig.php\"] \"extensions_to_blacklist\": [], // Execute the sniffer on file save \"phpcs_execute_on_save\": true, // Show the error list after save. \"phpcs_show_errors_on_save\": false, // Show the errors in the gutter \"phpcs_show_gutter_marks\": true, // Show outline for errors \"phpcs_outline_for_errors\": true, // Show the errors in the status bar \"phpcs_show_errors_in_status\": true, // Show the errors in the quick panel so you can then goto line \"phpcs_show_quick_panel\": true, // The path to the php executable. // Needed for windows, or anyone who doesn't/can't make phars // executable. Avoid setting this if at all possible \"phpcs_php_prefix_path\": \"\", // Options include: // - Sniffer // - Fixer // - Mess Detector // // This will prepend the application with the path to php // Needed for windows, or anyone who doesn't/can't make phars // executable. Avoid setting this if at all possible \"phpcs_commands_to_php_prefix\": [], // What color to stylise the icon // https://www.sublimetext.com/docs/3/api_reference.html#sublime.View // add_regions \"phpcs_icon_scope_color\": \"comment\", // PHP_CodeSniffer settings // Do you want to run the phpcs checker? \"phpcs_sniffer_run\": true, // Execute the sniffer on file save \"phpcs_command_on_save\": true, // It seems python/sublime cannot always find the phpcs application // If empty, then use PATH version of phpcs, else use the set value \"phpcs_executable_path\": \"/usr/local/bin/phpcs\", // Additional arguments you can specify into the application // // Example: // &#123; // \"--standard\": \"PEAR\", // \"-n\" // &#125; \"phpcs_additional_args\": &#123; \"--standard\": \"PSR2\", \"-n\": \"\" &#125;, // PHP-CS-Fixer settings // Fix the issues on save \"php_cs_fixer_on_save\": false, // Show the quick panel \"php_cs_fixer_show_quick_panel\": false, // Path to where you have the php-cs-fixer installed \"php_cs_fixer_executable_path\": \"/usr/local/bin/php-cs-fixer\", // Additional arguments you can specify into the application \"php_cs_fixer_additional_args\": &#123; &#125;, // phpcbf settings // Fix the issues on save \"phpcbf_on_save\": false, // Show the quick panel \"phpcbf_show_quick_panel\": false, // Path to where you have the phpcbf installed \"phpcbf_executable_path\": \"\", // Additional arguments you can specify into the application // // Example: // &#123; // \"--level\": \"all\" // &#125; \"phpcbf_additional_args\": &#123; \"--standard\": \"PSR2\", \"-n\": \"\" &#125;, // PHP Linter settings // Are we going to run php -l over the file? \"phpcs_linter_run\": true, // Execute the linter on file save \"phpcs_linter_command_on_save\": true, // It seems python/sublime cannot always find the php application // If empty, then use PATH version of php, else use the set value \"phpcs_php_path\": \"/usr/local/bin/phpcs\", // What is the regex for the linter? Has to provide a named match for 'message' and 'line' \"phpcs_linter_regex\": \"(?P&lt;message&gt;.*) on line (?P&lt;line&gt;\\\\d+)\", // PHP Mess Detector settings // Execute phpmd \"phpmd_run\": false, // Execute the phpmd on file save \"phpmd_command_on_save\": true, // It seems python/sublime cannot always find the phpmd application // If empty, then use PATH version of phpmd, else use the set value \"phpmd_executable_path\": \"\", // Additional arguments you can specify into the application // // Example: // &#123; // \"codesize,unusedcode\" // &#125; \"phpmd_additional_args\": &#123; \"codesize,unusedcode,naming\": \"\" &#125;, // PHP Scheck settings // Execute scheck \"scheck_run\": false, // Execute the scheck on file save \"scheck_command_on_save\": false, // It seems python/sublime cannot always find the scheck application // If empty, then use PATH version of scheck, else use the set value \"scheck_executable_path\": \"\", // Additional arguments you can specify into the application // //Example: //&#123; // \"-php_stdlib\" : \"/path/to/pfff\", // \"-strict\" : \"\" //&#125; \"scheck_additional_args\": &#123; \"-strict\" : \"\" &#125;&#125; 一键清空 PHP 调试代码正则 123^[( )((//)?)]+ *(print_r|var_dump)(.;\\s?(//)? *(die;)?$\\/\\/ *[(print_r)(var_dump)]+ *(.;$ FAQ Sublime Text 3 插件配置文件 在 Mac 上设置文件保存失败问题？ 需要在 ~/Library/Application\\ Support/Sublime\\ Text\\ 3/Packages/ 路径下手动创建与 Package 同名目录。 Sublime Text 不能将 $ 当作 PHP 变量的一部分？ Cmd + Shift + P：Preference:Browse Packages。选择 User，新建配置文件 PHP.sublime-settings，内容如下： 123&#123; \"word_separators\": \"./\\\\()\\\"'-:,.;&lt;&gt;~!@#%^&amp;*|+=[]&#123;&#125;`~?\"&#125; 其作用就是：当编辑 PHP 文件的时候，覆盖 Sublime 默认配置，使 $ 成为单词的一部分。 参考 Sublime Text 3 快捷键汇总 Sublime Text 个人经验 80-characters / right margin line in Sublime Text 3 Fix PHP variable selection in Sublime Text Sublime Sublime Text","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://blog.caoxl.com/tags/Sublime/"},{"name":"编辑器","slug":"编辑器","permalink":"http://blog.caoxl.com/tags/编辑器/"}]},{"title":"Git「开发日志」","slug":"Git-Common-Commands","date":"2018-02-01T02:18:38.000Z","updated":"2019-08-22T03:42:36.000Z","comments":true,"path":"2018/02/01/Git-Common-Commands/","link":"","permalink":"http://blog.caoxl.com/2018/02/01/Git-Common-Commands/","excerpt":"持续记录使用Git开发过程中常用命令/常见问题等等.. 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。","text":"持续记录使用Git开发过程中常用命令/常见问题等等.. 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 Git常用命令清单新建代码库12345678# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url] 配置Git的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置） 123456789# 显示当前的Git配置git config --list# 编辑Git配置文件git config -e [--global]# 设置提交代码时的用户信息git config [--global] user.name \"[name]\"git config [--global] user.email \"[email address]\" 增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交时显示所有diff信息git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]# 删除分支git branch -d [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 其他12# 生成一个可供发布的压缩包git archive Git 设置邮箱和密码123git config --global user.email \"code0809@163.com\"git config --global user.name \"SoulMate94\" 需要注意的是，如果以前全局配置后，再次执行该操作会覆盖原用户名。 如果配置了全局账号，多个 Git 账号的情况下执行 remote、pull、push 的时候会出现问题，因为要 pull 的时候识别的是邮箱，多个 git 账号，必然对应多个邮箱，那自然就不能使用 global 的 user.email 了。 这时候可以为每个 repo 设置自己的 user.email。 1234567# 取消 globalgit config --global --unset user.namegit config --global --unset user.email# 设置每个项目 repo 的 user.emailgit config user.email \"xxx@xxx.com\"git config user.name \"username\" SSH key1ssh-keygen -t rsa -C \"code0809@163.com\" 一直回车，成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key，然后进入 GitHub 的 Account Settings，选择 SSH Keys -&gt; Add SSH Key，粘贴在你电脑上生成的 key。（title 随便填） 验证是否成功： 1234$ ssh -T git@github.com成功:Hi tianqixin! You've successfully authenticated, but GitHub does not provide shell access. 配置多个 Git 远程仓库的 SSH-Key我机器上的 Git 会在 GitHub、GitCafe、Coding.NET 、以及树莓派上的私有 Git 仓库之间来回切换，所以如果不配置 SSH-Key 光输入密码就得浪费不少时间。 在默认情况下，ssh 总是使用 id_rsa 密钥文件进行链接，即是第一次执行 ssh-keygen 后默认生成的，这样对于多个账号的认证肯定是不行的。 因此，要实现多帐号下的 SSH Key 的切换需要在客户端做一些配置： 12345cd ~/.ssh # 必须进入这个路径否则生成的密钥路径容易遗忘ssh-keygen -t rsa -C 'username@github.com' -f id_rsa_github # -C 后面跟的是注释ssh-keygen -t rsa -C 'username@gitcafe.com' -f id_rsa_gitcafessh-keygen -t rsa -C 'username@coding.net' -f id_rsa_coding # 如果还有多个 Git 远程仓库地址就继续执行 ... 然后复制 ~/.ssh/ 下面的相应的公钥到你的 Git 远程仓库服务器上即可，这个步骤和 GitHub 上的操作是一样的。 然后在 ~/.ssh/ 下面创建一个 config 文件，填入你刚刚配置的 SSH 密钥信息，内容应类似于如下： 1234567891011121314151617Host github.com HostName github.com User SoulMate94 Port 22 IdentityFile ~/.ssh/id_rsa_githubHost gitcafe.com HostName gitcafe.com User SoulMate94 Port 22 IdentityFile ~/.ssh/id_rsa_gitcafeHost git.coding.net # 注意 Coding.NET 的 HostName 是 git.coding.net HostName git.coding.net User SoulMate94 Port 22 IdentityFile ~/.ssh/id_rsa_coding 然后可以测试一下是否配置 OK： 1234ssh -T git@github.comssh -T git@gitcafe.comssh -T git@git.coding.netssh -T git@git.keensword.net 如果没有提示错误就说明 SSH 配置好了。 然后克隆 SSH 协议的 Git 仓库即可，此后便不用每次输入用户名密码了，比如： 12git clone git@gitcafe.com:SoulMate94/soulmate94.gitgit clone git@git.coding.net:SoulMate94/SoulMate94.git 然后还可以为不同远程 Git 仓库起不同的别名，就算是为同一内容的不同 Git 仓库提交代码，也可以通过别名来区分，比如： 12git remote add gitcafe git@gitcafe.com:SoulMate94/soulmate94.gitgit remote add coding git@git.coding.net:SoulMate94/SoulMate94.git 这样修改了同一个仓库后就算已经 push 到了一个远程仓库地址，也可以继续 push 到另一个的同一分支或不同分支，其区别就是别名： 12git push gitcafe mastergit push coding master 注意 只有克隆 SSH 协议的 Git 仓库才能使 SSH 密钥机制生效，如果克隆的是 HTTPS 协议的则每次依然需要输入用户名和密码。 GIT 分支操作添加远程仓库地址和推送到远程仓库123git remote add origin git@github.com:SoulMate94/blog.gitgit push -u origin master origin 是为远程仓库地址起的别名。 -u 只在第一次推送时使用，作用是把本地的 master 分支和远程的 master 分支关联起来，之后的推送不再需要这个参数。 为远程仓库起别名12345 移除现有分支别名git remote rm origin# 为远程仓库地址重新起别名git remote add caoxl git@github.com:SoulMate94/SM94.git 创建分支如果 clone 了一个空仓库，那么在执行 git branch master 的时候会报错： fatal: Not a valid object name: ‘master’. 这时候只需添加一些文件 commit 就行了, 比如： 123git add README.mdgit commit -m \"test\"git branch dev 切换分支12git checkout --orphan gh-pagesgit checkout -b test # 从当前分支中分出一个 test 分支并切换到新 test 分支 查看分支123git branch -a # 查看远程分支git branch # 查看本地分支git remote show origin 删除分支12345git branch -d branch_name # 删除本地分支git push origin --delete &lt;branch_name&gt; # 删除远程分支版本( 类似的有删除标签：git push origin --delete tag &lt;tagname&gt; )git push origin :&lt;branchName&gt; # 推送一个空分支到远程分支, 其实就相当于删除远程分支git remote prune origin # 删除不存在对应远程分支的本地分支git fetch -p #在 fetch 之后删除掉没有与远程分支对应的本地分支 重命名本地分支1git branch -m devel develop Git 移除已经 add 的文件1git reset --hard 需要回退的那次 commit 的哈希值 每次 commit 的哈希值可以通过 git log 命令查看 上述命令执行成功之后，会彻底返回到回退到的版本状态，新发生的变更将会丢失。 对于部分发生了变更，但是变更部分的文件夹存在未提交的文件可能导致目录非空而删除失败，此时需要自行处置 完成之后，使用 –force 或 -f 参数强制 push： 1234git push origin HEAD --force- `HEAD` 最近一个提交。- `HEAD^` 上一次。 查看远程 Git 仓库1git remote -v FAQ为什么删不了 master 分支？需要先更改默认分支为非 master 分支。再执行删除操作： 12345678删除本地分支git branch -d [branch-name]git branch -D master删除远程分支git push origin :master git push origin --delete [branch-name]git branch -dr [remote/branch] 将 .gitignore.txt 修改为 .gitignore 时提示 “必须键入文件名” 怎么办？1rename .gitignore.txt .gitignore Git忽略规则及 .gitignore 规则不生效的解决办法已知在 git 中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如无，则需自己手工建立此文件）。 这个文件每一行保存了一个匹配的规则例如： 123456# 此为注释 – 将被 Git 忽略*.a # 忽略所有 .a 结尾的文件!lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是 .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 123git rm -r --cached .git add .git commit -m 'update .gitignore' 如果 cache 暂存区的内容和 HEAD 不一致，请使用： git rm rf --cache . 强制删除 Git 停止追踪文件权限12git config core.filemode falsecat .git/config .gitkeep 有什么用 ? “.gitkeep” isn’t documented, because it’s not a feature of Git. Git cannot add a completely empty directory. People who want to track empty directories in Git have created the convention of putting files called “.gitkeep” in these directories. The file could be called anything; Git assigns no special significance to this name. There is a competing convention of adding a “.gitignore” file to the empty directories to get them tracked, but some people see this as confusing since the goal is to keep the empty directories, not ignore them; “.gitignore” is also used to list files that should be ignored by Git when looking for untracked files. or you can use like this to except for this one: !.gitignore. git fetch repo 和 git fetch repo branch 的区别 ?git fetch, 理解 fetch 的含义, 是远程协作的关键，而理解 fetch 的关键, 是理解 FETCH_HEAD。 FETCH_HEAD 指的是: 某个 branch 在服务器上的最新状态。 每一个执行过 fetch 操作的项目，都会存在一个 FETCH_HEAD 列表，这个列表保存在 .git/FETCH_HEAD 文件中, 其中每一行对应于远程服务器的一个分支。 当前分支指向的 FETCH_HEAD, 就是这个文件第一行对应的那个分支。 一般来说, 存在两种情况: 如果没有显式的指定远程分支, 则远程分支的 master 将作为默认的 FETCH_HEAD。 .如果指定了远程分支, 就将这个远程分支作为 FETCH_HEAD。 常见的 git fetch 使用方式包含以下四种: git fetch 这一步其实是执行了两个关键操作: 1.创建并更新所有远程分支的本地远程分支。 2.设定当前分支的 FETCH_HEAD 为远程服务器的 master 分支 (上面说的第一种情况)。 需要注意的是，和 push 不同, fetch 会自动获取远程 新加入的分支。 git fetch origin 同上, 只不过手动指定了 remote。 git fetch origin branch1 设定当前分支的 FETCH_HEAD 为远程服务器的 branch1 分支。 注意: 在这种情况下, 不会在本地创建本地远程分支, 这是因为: 这个操作是 git pull origin branch1 的第一步, 而对应的 pull 操作,并不会在本地创建新的 branch。 一个附加效果是：这个命令可以用来测试远程主机的远程分支 branch1 是否存在, 如果存在, 返回0, 如果不存在, 返回128, 抛出一个异常。 git fetch origin branch1:branch2 只要明白了上面的含义, 这个就很简单了: 1.首先执行上面的 fetch 操作2.使用远程 branch1 分支在本地创建 branch2 (但不会切换到该分支)，如果本地不存在branch2分支, 则会自动创建一个新的 branch2 分支。 如果本地存在 branch2 分支, 并且是 fast forward，则自动合并两个分支, 否则, 会阻止以上操作. git fetch origin :branch2 等价于: git fetch origin master:branch2。 git pull 只要理解了 git fetch, git pull就太简单了。 git pull 等价于以下两步: 1.经命令中的pull换成fetch, 执行之。 2.git merge FETCH_HEAD 唯一需要提及的一点是: 我认为 pull 操作, 不应该涉及三方合并 或 衍合 操作。 换个说法: pull 应该总是 fast forward 的. 为了达到这样一个效果, 在真正 push 操作之前, 我倾向于使用衍合, 在本地对代码执行合并操作。 关于 git 不区分文件名大小写的处理处理办法： windows 下在 git 中修改文件的大小写 1234git mv --force myfile MyFile# 或者git mv -f myfile MyFile 然后 commit 就好了。当然也可以配置一下 git： 1Add ignorecase = false to [core] in .git/config; 其他 创建版本号为 1 的 master 分支 1git push sina master:1 删除 master 分支上版本号为 1 的 代码 1234git push sina :1# 或git push sina master :1 有空格则为删除版本，无空格则为新建版本。 1git push origin :branch 表示将一个内容为空的同名分支推送到远程的分支，说白了, 即删除远程主机的 branch 分支, 但是这并不会消除之前的 comment 内容, 而且你一旦提交了一些大的文件(例如: 图片之类的), 通过这个操作, 是不会将这些文件占用的空间消除的. 如果要真正的删除一个文件, 除了删除整个项目, Github网站也有提供办法。 参考 Git 命令无需记忆 常用 Git 命令清单 Git查看、删除、重命名远程分支和tag What are the differences between .gitignore and .gitkeep?","categories":[{"name":"Git / Svn","slug":"Git-Svn","permalink":"http://blog.caoxl.com/categories/Git-Svn/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.caoxl.com/tags/Git/"},{"name":"CheatSheet","slug":"CheatSheet","permalink":"http://blog.caoxl.com/tags/CheatSheet/"}]},{"title":"CentOS7 「操作日志」","slug":"CentOS-7-Operation-Log","date":"2018-02-01T01:32:29.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/02/01/CentOS-7-Operation-Log/","link":"","permalink":"http://blog.caoxl.com/2018/02/01/CentOS-7-Operation-Log/","excerpt":"这篇文章不定期更新在使用 CentOS 7 过程中的操作日志。 说明：下列大部分操作都是在阿里云 ECS 进行的。","text":"这篇文章不定期更新在使用 CentOS 7 过程中的操作日志。 说明：下列大部分操作都是在阿里云 ECS 进行的。 最小化安装之后网络管理12nmcli dnmtui 激活网卡即可 无法重启 networknetwork.service - LSB: Bring up/down networking this error pops up with any issue while setting up network: IP conflict, routing issues, etc. Can’t start CentOS 7 “network” service 解决办法： 暂时移除 /etc/sysconfig/network-scripts/ifcfg-*中用不到的网络接口配置。 软件包管理查看某个软件包的安装信息12345# 查看是否安装某个软件包rpm -qa &#123;package&#125;# 列表展示所有相关信息rpm -ql &#123;package&#125; 正确地更换 SSH 端口新增端口 !!! 不要直接干掉 22 端口 12345# 注意不是修改 /etc/ssh/ssh_config !!!vim /etc/ssh/sshd_config# 重启 sshdsystemctl restart sshd Selinux123yum install policycoreutils-pythonsemanage port -a -t ssh_port_t -p tcp 1024semanage port -l | grep ssh 防火墙CentOS 6 =&gt; iptables1234# 安全起见iptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A INPUT -p tcp --dport 12345 -j ACCEPTservice iptables save CentOS 7 =&gt; fireware123456789systemctl stop iptables.servicesystemctl unmask firewalld.servicesystemctl enable firewalld.servicesystemctl start firewalld.service# 安全起见firewall-cmd --add-port=22/tcp --permanentfirewall-cmd --add-port=10101/tcp --permanentfirewall-cmd --reload 查看已开放端口12firewall-cmd --list-ports/etc/init.d/iptables status 查看 sshd 是否监听了新端口123ss -tnlp | grep sshdyum install -y net-toolsnetstat -tulpn | grep :4444 测试新端口并删除默认端口 !!! 一定要先试试新端口是否可以连接 若能才删除默认 22 端口 否则就等只有恢复磁盘和快照了… 1234vim /etc/ssh/sshd_configfirewall-cmd --permanent --zone=public --remove-port=22/tcpfirewall-cmd --reload ssh 取消监听 22 端口，就已经配置好了，防火墙只不过是在 ssh 外多一层访问限制。 此时若使用 22 端口连接则会提示：ssh: connect to host {ip} port 22: Connection refused。 如果要做的更好还可以将 22 端口的访问流量转向访问者本地： 1firewall-cmd --permanent --zone=public --add-forward-port=port=22:proto=tcp:toport=22:toaddr=127.0.0.1 此时若使用 22 端口连接则会提示：_ssh_exchangeidentification: read: Connection reset by peer。 另外，使用一个未监听或未放行的端口连接的提示是：_ssh_exchangeidentification: read: Operation timed out。 撤销重定向： 1firewall-cmd --permanent --zone=public --remove-forward-port=port=22:proto=tcp:toport=22:toaddr=127.0.0.1 说明：阿里云 ECS 默认没有对端口进行特殊限制，因此可以不用设置安全组规则 阿里云 ECS／CentOS 7 启用 IPv6（6in4）获取免费 IPv4 + IPv6 地址到 https://www.tunnelbroker.net 注册即可，详情略。 只需要注意一点，要用阿里云 ECS 的「公网」 IPv4 才能换 IPv6。换取成功 IPv6 同时还会有一个国外 IPv4。 配置 CentOS 7启用 IPv612345678910111213141516171819202122vim /etc/modprobe.d/disable_ipv6.conf# ...options ipv6 disable=0 # 默认是 1# ...vim /etc/sysconfig/network# ...NETWORKING_IPV6=yes# ...vim /etc/sysctl.conf # 有则改 无则追加# ...net.ipv6.conf.all.disable_ipv6 = 0net.ipv6.conf.default.disable_ipv6 = 0net.ipv6.conf.lo.disable_ipv6 = 0# 测试lsmod | grep ipv6ifconfig | grep -i inet6 配置 IPv6 代理下面命令根据上面网址创建 IPv6 成功后选择示例配置中的 Linux-route2 模版改动如下： 123456789modprobe ipv6ip tunnel add he-ipv6 mode sit remote &lt;国外代理 IPv4&gt; local &lt;CentOS 7 内网 IPv4&gt; ttl 255ip link set he-ipv6 upip addr add &lt;国外代理 IPv6&gt; dev he-ipv6 # 例如：2001:xxx:xxxx:xx::2/64ip -6 route add ::/0 dev he-ipv6# 测试ip -f inet6 addrifconfig he-ipv6 注意这里的 CentOS 7 内网 IPv4 并不是阿里云提供的弹性公网 IP，而是系统内的 IPv4 地址。用 ip -f inet addr 查看得到的那个，否则会出现 ping6 失败。（根阿里云 ECS 的网络类型、安全组什么的都无关） NOTE: When behind a firewall appliance that passes protocol 41, use the IPv4 address you get from your appliance’s DHCP service instead of the IPv4 endpoint you provided to our broker. 监听 IPv6 地址1234567891011# nginx# ...listen 80;listen [::]:80 ipv6only=off;listen [::]:443 ssl;listen 443 ssl http2;# ...# 测试是否监听成功 (`State` 为 LISTEN 的记录是否有 `tcp6` 的 Proto)netstat -tuln 配置 IPv6 DNS不配置 IPv6 DNS 服务器，直接在 CentOS 7 使用 ping6 命令（Windows ping -6）ping IPv6 地址是 ping 不通的。 123456789vi /etc/resolv.confoptions timeout:1 attempts:1 rotate single-request-reopen; generated by /usr/sbin/dhclient-script; ...; Google IPv6 DNSnameserver 2001:4860:4860::8888nameserver 2001:4860:4860::8844 然后测试是否能够解析 IPv6，如果有正常输出则表示 DNS64 配置成功。 1ping6 -c 3 ipv6.google.com 防火墙放行 41 端口 When using 6to4, you do not transmit IPv6 packets. Instead, special IPv4 packets are wrapped around IPv6 payloads. These packets have IPv4 protocol 41, as defined by RFC 2473. 1234567# firewall-cmdfirewall-cmd --add-port=41/tcp --permanentfirewall-cmd --reload# iptablesiptables -t filter -I INPUT -p 41 -j ACCEPTiptables -t filter -I OUTPUT -p 41 -j ACCEPT 域名解析新增 AAAA 记录到域名解析处分别添加主机为 www 和 @，值为上面获取到的 IPv6 地址的 AAAA 记录。 测试网址 IPv6 连接情况访问：Is Your Site IPv6 ready?，输入自己的网站域名即可检测。 FAQ 为什么手机测试依然不能连接 IPv6 地址? 请确保手机网络环境支持 IPv6 解析。 rsync每小时同步数据库备份 10 */1 * * * /usr/bin/rsync -zrtopg --progress -e ssh user@example.com:/data/to/be/synced/ /path/to/store/backup 防火墙 拒绝某个 IP 访问 123456789firewall-cmd --permanent --add-rich-rule=\"rule family='ipv4' source address='118.89.37.80' reject\"firewall-cmd --permanent --add-rich-rule=\"rule family='ipv4' source address='47.52.149.164' reject\"firewall-cmd --reloadfirewall-cmd --list-rich-rules# 取消已拒绝的对某个 IP 的访问限制firewall-cmd --permanent --remove-rich-rule=\"rule family='ipv4' source address='118.89.37.80' port protocol='tcp' port='80' reject\" 参考 How to configure a static IP address on CentOS 7 / RHEL 7 crontab.guru Features/FirewalldRichLanguage 阿里云centos添加ipv6隧道 注册Tunnel broker 阿里云服务器如何设置IPV6通过appstore的审核 ipv6审核被拒绝的解决方案 IPv6 连接测试 IPv6 test - web site reachability Supporting IPv6 DNS64/NAT64 Networks-developer.apple","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://blog.caoxl.com/tags/CentOS/"}]},{"title":"PHP HTTP客户端-Guzzle原理解析","slug":"PHP-HTTP-Client-Guzzle","date":"2018-01-31T09:33:51.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/31/PHP-HTTP-Client-Guzzle/","link":"","permalink":"http://blog.caoxl.com/2018/01/31/PHP-HTTP-Client-Guzzle/","excerpt":"本文适合寻找PHP HTTP客户端库，或者对于Guzzle的使用和实现原理比较感兴趣的同学阅读，需要具备一定的PHP基础知识。 Guzzle是一个PHP的HTTP客户端，用来轻而易举地发送请求，并集成到我们的WEB服务上。","text":"本文适合寻找PHP HTTP客户端库，或者对于Guzzle的使用和实现原理比较感兴趣的同学阅读，需要具备一定的PHP基础知识。 Guzzle是一个PHP的HTTP客户端，用来轻而易举地发送请求，并集成到我们的WEB服务上。 背景在PHP后台开发过程中，经常会遇到模块间需要通过HTTP通信的情形。PHP语言本身只提供了socket操作的接口，并未提供HTTP相关操作的接口。许多现有的实现采用curl扩展充当 HTTP Client 与 HTTP Server 通信，但仍需自己封装curl的接口。有鉴于此，本文介绍一款流行的 PHP HTTP Client客户端—Guzzle的用法，深入分析其底层实现原理。 Guzzle基础需求 PHP 5.5.0+ 使用PHP的流， allow_url_fopen 必须在php.ini中启用。 要使用cURL，你必须已经有版本 cURL &gt;= 7.19.4，并且编译了 OpenSSL 与 zlib 安装你可以使用composer.phar客户端将Guzzle作为依赖添加到项目： 1php composer.phar require guzzlehttp/guzzle:~6.0 或者，你可以编辑项目中已存在的composer.json文件，添加Guzzle作为依赖： 12345&#123; \"require\": &#123; \"guzzlehttp/guzzle\": \"~6.0\" &#125;&#125; 安装完毕后，你需要引入Composer的自动加载文件： 1require 'vendor/autoload.php'; 测试12git clone https://github.com/guzzle/guzzle.gitcd guzzle &amp;&amp; curl -s http://getcomposer.org/installer | php &amp;&amp; ./composer.phar install --dev Guzzle is unit tested with PHPUnit. Run the tests using the Makefile: 1make test Guzzle用法例如使用Guzzle访问 http://www.baidu.com 的代码： 12345678910&lt;?php$client = new \\GuzzleHttp\\Client();$response = $client-&gt;request('GET', 'http://www.baidu.com', [ \"timeout\" =&gt; 3000]);echo $response-&gt;getStatusCode(), \"\\n\";echo $response-&gt;getBody(); 接口封装是不是十分简单？只需要关心请求方法，目标url和请求的选项即可快速上手。同时，Guzzle还支持异步请求方式： 123456789101112131415161718&lt;?phpuse GuzzleHttp\\Exception\\RequestException;use Psr\\Http\\Message\\ResponseInterface;$client = new \\GuzzleHttp\\Client();$promise = $client-&gt;requestAsync('GET', 'http://www.baidu.com');$promise-&gt;then( function (ResponseInterface $res) &#123; echo $res-&gt;getStatusCode() . \"\\n\"; echo $res-&gt;getBody(); return $res; &#125;, function (RequestException $e) &#123; echo $e-&gt;getMessage() . \"\\n\"; echo $e-&gt;getRequest()-&gt;getMethod(); &#125;)-&gt;wait(); 基于异步请求，Guzzle还实现了并发请求，关于Guzzle的具体使用方法可以参考其 Guzzle中文文档 Guzzle实现原理1.client构造GuzzleHttp\\Client类构造函数声明为： 1public function __construct(array $config = []) $config配置使得用户可以根据需要配置一切可以配置的选项，包括allowredirects、auth、connecttimeout、proxy等。除此之外，还可以自定义请求的处理函数handler，方便应用程序扩展，handler接口规范为： 1function handler($request, array $options); 处理成功时，接口返回 Psr\\Http\\Message\\ResponseInterface；失败时返回 GuzzleHttp\\Exception\\RequestException异常。 默认情形下，GuzzleHttp\\HandlerStack::create会创建请求处理函数 12345678910public static function create(callable $handler = null)&#123; $stack = new self($handler ?: choose_handler()); $stack-&gt;push(Middleware::httpErrors(), 'http_errors'); $stack-&gt;push(Middleware::redirect(), 'allow_redirects'); $stack-&gt;push(Middleware::cookies(), 'cookies'); $stack-&gt;push(Middleware::prepareBody(), 'prepare_body'); return $stack;&#125; create函数以堆栈的形式创建了一系列的处理函数，包括 http异常、重定向、cookie和prepare_body。处理函数返回的函数闭包为： 12345return function (callable $handler) &#123; return function ($request, array $options) use ($handler) &#123; ... &#125;;&#125;; 函数入参为handler，返回一个新的handler，这样可以将所有的处理函数链接在一起，最终生成一个符合handler接口规范的函数. choose_handler函数选择stack中的起始handler，选择策略为： 扩展自带curl_multi_exec和curl_exec函数则根据$options中的synchronous选项决定，empty(synchronous)为 false则使用CurlHandler，否则使用CurlMultiHandler 扩展只有curl_exec函数则使用CurlHandler 扩展只有curl_multi_exec函数则使用CurlMultiHandler 最后，如果 php.ini 中开启了allow_url_fopen，则根据$options中的stream选项决定，empty(stream)为false则使用StreamHandler 2.client调用request方法request方法实现为： 12345public function request($method, $uri = '', array $options = [])&#123; $options[RequestOptions::SYNCHRONOUS] = true; return $this-&gt;requestAsync($method, $uri, $options)-&gt;wait();&#125; 由此可见，request事实上是采用了requestAsync异步方法+wait来完成的，也就是异步转同步。 requestAsyncrequestAsync将请求信息包装成 Psr7\\Request 对象，然后调用 1transfer(RequestInterface $request, array $options) transfer函数最终返回Promise\\promise_for($handler($request, $options)); 其中$handler即为构造函数中所设置的stack，stack中存放一系列的请求处理函数。 HandlerStack的处理函数为: 123456public function __invoke(RequestInterface $request, array $options)&#123; $handler = $this-&gt;resolve(); return $handler($request, $options);&#125; resolve方法解析整个stack，返回一个包装后的handler，包装策略为按照出栈顺序包装，也就是 123foreach (array_reverse($this-&gt;stack) as $fn) &#123; $prev = $fn[0]($prev);&#125; 典型的中间件模型，所有的处理函数串接在一起了。请求经由http_errors、allow_redirects等处理之后到达Curl，执行真正的网络交互。 对于同步的handler如CurlHandler，在此处会执行curl_exec发起请求，最终返回的是FulfilledPromise对象或RejectedPromise对象，代表请求已经处理完毕。 对于异步的handler比如CurlMultiHandler，在此处并不会执行curl_multi_exec，而是返回一个promise对象，里面注册了需要等待执行的curl_multi_exec。 wait请求发送完毕，进入promise的wait操作，最终会执行promise的$waitFn函数。 对于CurlMultiHandler，$waitFn即执行curl_multi_exec进行网络交互，然后调用resolve方法将response对象传递到then方法的$onFulfilled函数。 对于CurlHandler，直接利用resolve将response对象传递到$onFulfilled函数。 这样，异步的then方法设置的回调就可以接收到response了。 then方法最终返回response，这个对象又可以作为返回值返回，这样同步的wait就可以通过返回值来获取response对象了。 总结本文重点介绍了 Guzzle 同步和异步请求的实现原理，除此之外，Guzzle还提供了并行请求，请求pool等实现，读者可以在此基础上继续深入。 参考 Guzzle中文文档 Guzzle, PHP HTTP client Guzzle 快速入门","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"HTTP","slug":"HTTP","permalink":"http://blog.caoxl.com/tags/HTTP/"},{"name":"Client","slug":"Client","permalink":"http://blog.caoxl.com/tags/Client/"},{"name":"Guzzle","slug":"Guzzle","permalink":"http://blog.caoxl.com/tags/Guzzle/"}]},{"title":"Hexo 文章置顶功能","slug":"Hexo-Set-Article-Top","date":"2018-01-31T07:26:17.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/31/Hexo-Set-Article-Top/","link":"","permalink":"http://blog.caoxl.com/2018/01/31/Hexo-Set-Article-Top/","excerpt":"使用Hexo博客中,想使用文章置顶功能,所以倒腾了下","text":"使用Hexo博客中,想使用文章置顶功能,所以倒腾了下 期望在Hexo Hiker 主题下让某些文章置顶 原理在Hexo生成首页HTML时，将top值高的文章排在前面，达到置顶功能。 修改Hexo文件夹下的 node_modules/hexo-generator-index/lib/generator.js，在生成文章之前进行文章top值排序。 实操需添加的代码： 12345678910111213posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排&#125;); 其中涉及Javascript的比较函数： 123cmp(var a, var b) &#123; return a - b; // 升序，降序的话就 b - a&#125; 修改完成后，只需要在front-matter中设置需要置顶文章的top值，将会根据top值大小来选择置顶顺序top值越大越靠前。需要注意的是，这个文件不是主题的一部分，也不是Git管理的，备份的时候比较容易忽略。 如:1234567---title: PHP 必备date: 2018-01-31 15:03:04categories: PHPtags: PHPtop: 9999--- 上面的废话都可以不用看,直接修改下面的内容即可 以下是最终的 generator.js 内容 1234567891011121314151617181920212223242526272829303132333435363738'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; // 修改部分-start //var posts = locals.posts.sort(config.index_generator.order_by); var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; &#125;); // 修改部分-end var paginationDir = config.pagination_dir || 'page'; // 修改部分-start // var path = config.index_generator.path || ''; return pagination('', posts, &#123; // 修改部分-end perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/tags/Hexo/"}]},{"title":"PHP 必备","slug":"PHP-Necessary","date":"2018-01-31T07:03:04.000Z","updated":"2019-01-21T02:39:13.000Z","comments":true,"path":"2018/01/31/PHP-Necessary/","link":"","permalink":"http://blog.caoxl.com/2018/01/31/PHP-Necessary/","excerpt":"PHP官网 PHP 之道「中文」 / 「英文」 PHP 5.5+最佳实践参考","text":"PHP官网 PHP 之道「中文」 / 「英文」 PHP 5.5+最佳实践参考 Composer https://getcomposer.org/doc/ Packagist / 组件 Dingo-API「英文」 Dingo-API「中文」 Laravel-Admin「英文」 Laravel-Admin「中文」 Guzzle Documentation LaravelCheatsheet https://learninglaravel.net/cheatsheet/ http://cheats.jesse-obrien.ca/ Laravel 5.1 LTS 速查表 API 文档 https://laravel.com/api/5.5/ 主要文档 Laravel 5.5 「英文」 Laravel 5.5 「中文」","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"Laravel 5.5 with DA - LA","slug":"Laravel-5-5-With-Dingo-API-And-LaravelAdmin","date":"2018-01-31T03:42:34.000Z","updated":"2019-08-22T03:56:54.000Z","comments":true,"path":"2018/01/31/Laravel-5-5-With-Dingo-API-And-LaravelAdmin/","link":"","permalink":"http://blog.caoxl.com/2018/01/31/Laravel-5-5-With-Dingo-API-And-LaravelAdmin/","excerpt":"本文主要总结使用 Laravel 5.5，及配套的一些组件在进行开发遇到的一些值得记录的东西，以及坑。 Laravel 5.5 - Dingo API - Laravel admin","text":"本文主要总结使用 Laravel 5.5，及配套的一些组件在进行开发遇到的一些值得记录的东西，以及坑。 Laravel 5.5 - Dingo API - Laravel admin Laravel 5.5重拾 Tinker这货真的很好用，Laravel 引入的所有类有很多方法名我们其实是不知道的，但是在 tinker 中可以被全部补全出来。 当然除了补全 Laravel 中的类方法和全局函数，也可以和 php -a 一样补全 PHP 内置的函数，且能少些不少语法。 总之，对开发期间帮助性很强，十分推荐。 路由自定义 API 路由文件为了方便管理 API，希望把 API 的路由文件分离到不同的文件，期望 Laravel 自动载入 routes/api/ 目录下的所有路由文件。 修改 App\\Providers\\RouteServiceProvider，新增 $apiRoutesPath 属性并修改 mapApiRoutes() 方法如下： 123456789101112131415protected $apiRoutesPath = 'api';protected function mapApiRoutes()&#123; $routeRegistrar = Route::prefix('api') -&gt;middleware('api') -&gt;namespace($this-&gt;namespace); load_phps( route_path($this-&gt;apiRoutesPath), function ($file) use ($routeRegistrar) &#123; $routeRegistrar-&gt;group($file); &#125; );&#125; 其中 load_phps 是我自定义的全局辅助函数，在 Laravel 启动时已经载入，定义如下： 12345678910111213141516171819202122function load_phps(string $path, \\Closure $callable) &#123; if (! file_exists($path)) &#123; excp(\"PHP files path not exists: &#123;$path&#125;\"); &#125; $result = []; $fsi = new \\FilesystemIterator($path); foreach ($fsi as $file) &#123; if ($file-&gt;isFile()) &#123; if ('php' == $file-&gt;getExtension()) &#123; $result[$file-&gt;getPathname()] = $callable($file); &#125; &#125; elseif ($file-&gt;isDir()) &#123; $_path = $path.'/'.$file-&gt;getBasename(); load_phps($_path, $callable); &#125; &#125; unset($fsi); return $result;&#125; 模型自定义模型属性在一个模型控制器获取一个主要的模型数据后，往往还需要和其他接口或模型或计算结果进行聚合，为了方便直接返回一个模型，可以考虑动态地往模型现有数据中添加其他数据。 创建一个 AttrCustomable trait 123456789101112131415161718&lt;?php// Make Model capable to add custom attributes in Laravel 5.5namespace App\\Traits;trait AttrCustomable&#123; private $customAttributes = []; public function addCustomAttribute(string $key, $value) &#123; $this-&gt;customAttributes[$key] = $value; return $this; &#125; public function toArray() &#123; $data = parent::toArray(); $data = array_filter(array_merge($data, $this-&gt;customAttributes)); return $data; &#125;&#125; 在模型里使用该 trait 1234567&lt;?phpnamespace App\\Models; class User extends Model&#123; use AttrCustomable;&#125; 在控制器里添加聚合数据 12345678910111213&lt;?phpnamespace App\\Http\\Controllers\\Api\\V1;class User&#123; public function show() &#123; return $this-&gt;user() -&gt;addCustomAttribute('pionts', 10000) -&gt;addCustomAttribute('foo', 'bar'); &#125;&#125; 获取隐藏属性假设在 User 模型的某个方法内，要访问 hidden 过的属性 password，有如下几种方式： 通过模型的 makeVisible 方法 (5.1 是 withHidden) 123$this-&gt;makeVisible('password'); // 使 password 属性可见echo $this-&gt;password; // 输出用户密码$this-&gt;makeHidden('password'); // 使 password 属性隐藏 源码入下: makeVisible 12345678910public function makeVisible($attributes)&#123; $this-&gt;hidden = array_diff($this-&gt;hidden, (array) $attributes); if (! empty($this-&gt;visible)) &#123; $this-&gt;addVisible($attributes); &#125; return $this;&#125; makeHidden 12345678910public function makeHidden($attributes)&#123; $attributes = (array) $attributes; $this-&gt;visible = array_diff($this-&gt;visible, $attributes); $this-&gt;hidden = array_unique(array_merge($this-&gt;hidden, $attributes)); return $this;&#125; 通过模型的 getAttributes 方法 12$allAttrs = $this-&gt;getAttributes(); // 直接获得模型所有属性（无视可见性设置）echo $allAttrs['password']; // 输出用户密码 如果模型实现了 Illuminate\\Contracts\\Auth\\Authenticatable 接口，则还可以通过该接口提供的 getAuthPassword 方法只获取密码属性 1234567class User extends Model implements \\Illuminate\\Contracts\\Auth\\Authenticatable&#123; public function index() &#123; echo $this-&gt;getAuthPassword(); // 输出用户密码 &#125;&#125; 如何判断模型是否存在1$mode-&gt;exists; // !!! 属性调用而非方法 定义资源路由后控制器模型注入失效？ 路由定义： 12345678$router-&gt;group([ 'prefix' =&gt; 'members', 'middleware' =&gt; [ 'api.auth', ],], function ($router) &#123; $router-&gt;resource('address', 'MemberAddress');&#125;); 生成路由定义如下： 12345- GET|HEAD /members/address MemberAddress@index- POST /members/address MemberAddress@store- GET|HEAD /members/address/&#123;address&#125; MemberAddress@show- PUT|PATCH /members/address/&#123;address&#125; MemberAddress@update- DELETE /members/address/&#123;address&#125; MemberAddress@destroy 以对应的 MemberAddress 控制器的 show 方法举例： 请求 GET /members/address/1，其中 1 号的记录在数据库是实际存在的，可在方法中不是期望的输出： 12345678910111213use App\\Models\\MemberAddress as Address;public function show(Address $address)&#123; dd($address-&gt;exists); // 输出 false !!! dd(func_get_args()); // 输出如下： array:2 [▼ 0 =&gt; MemberAddress &#123;#365 ▶&#125; 1 =&gt; \"1\" ]&#125; 结果显示，这里在向控制器方法自动注入模型的时候，参数和模型没有对应上，导致 $address 只是个空模型，这当然不是我们想要的。 在 dingo api GitHub 的这个 issue 的提示下，去翻了 bindings 这个中间件的源码后找到了我想要的解决办法： 参见：Illuminate\\Routing\\ImplicitRouteBinding@resolveForRoute。 修改 MemberAddress 控制器的构造方法如下： 12345678public function __construct()&#123; $this -&gt;middleware('id_filter:address,\\App\\Models\\MemberAddress') -&gt;only([ 'show', 'update', 'destroy' ]);&#125; 新增中间件并注册到 App\\Http\\Kernel： 1234protected $routeMiddleware = [ // ... 'id_filter' =&gt; \\App\\Http\\Middleware\\IDFilter::class,]; IDFilter 中间件内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php// Filter ID for resource routes// - 1. Check if has given id key// - 2. Check id value illegality// - 3. Implicit bind route parameters segment (id key) with given modelnamespace App\\Http\\Middleware;class IDFilter&#123; // TODO // !!! Find a better way to handle method params count public function handle( $request, \\Closure $next, string $idkey, string $class = null, string $abortOn404 = 'no', string $forget = 'no' ) &#123; $route = $request-&gt;route(); $id = ($route-&gt;parameters[$idkey] ?? false); if (empty_safe($id) || (! ispint($id)) || ($id &lt; 1)) &#123; abort(403, \"Bad id value of `&#123;$idkey&#125;`: &#123;$id&#125;\"); &#125; if ($class) &#123; if (! class_exists($class)) &#123; abort(503, 'Model class not exists: '.$class); &#125; $model = app($class); $_model = $model-&gt;where($model-&gt;getRouteKeyName(), $id)-&gt;first(); if (ci_equal('yes', $abortOn404) &amp;&amp; (! $_model)) &#123; abort(404, 'Model object not found: '.get_class($model)); &#125; if (ci_equal('yes', $forget)) &#123; $route-&gt;forgetParameter($idkey); &#125; else &#123; $route-&gt;setParameter($idkey, $_model ?? $model); &#125; &#125; return $next($request); &#125;&#125; 其中，getRouteKeyName 默认返回 id 可以在相应模型中重写这个方法实现自定义。 之所以不直接用 Laravel 提供的默认 bindings 中间件，原因有两点： 没有提供（或者我暂时未找到） route segment 过滤的东西，默认找不到直接返回了 404，而我要的是既能正确提示路由参数格式不对，以及在参数格式正确但找不到数据库记录时，仍然要注入一个空模型到控制器方法。 使用了模型的 resolveRouteBinding() 方法，该方法在关联不上路由参数时返回 null 导致进入控制器后还需要再实例化一遍。 使用锁的场景通常在并发场景下，为了防止某个资源被重复创建／更新，在同时存在查询-更新／创建操作的时候必要使用悲观锁： 1234567891011$amount = 100;\\DB::beginTransction();$user = \\App\\Models\\User::lockForUpdate()-&gt;find(1); // 锁住该用户对应的行记录，防止并发中的其他请求修改该用户状态$log = \\App\\Models\\BalanceLog::insert([ 'before' =&gt; $user-&gt;balance, 'create_at' =&gt; time(), 'amount' =&gt; $amount,]);$user-&gt;balance += $amount;$user-&gt;save();\\DB::commit(); 如果不使用 lockForUpdate() 来锁住该用户对应的记录，那么在多个相同请求到来时，该用户的余额和日志会被更新／创建多条，这明显不是我们想要的。 lockForUpdate() 创建的锁将在本次事务结束后释放，且如果记录不存在，lockForUpdate() 则不会起到什么作用。 Laravel-Admin 不需要前端、UI, 后端就可以开发整个后台 这是个专门写后台管理系统的轮子。简而言之，是用 PHP 同时写后台页面和后端逻辑。 优点是将 Web 前端组件很好地封装到后端，使后端人员可以不用操心页面上的东西，要什么页面元素按照文档照做就行了，这么一来，写一个后台只需要后端就够了。 Dingo API虽然对于 Laravel 5.5 来说，要实现 Dingo API 的所有功能易如反掌，但之所以选择 Dingo API，主要是因为已经有很多的人用它，相信它封装得更标准，更简便，更稳定，不想花时间重复造轮子罢了。 如果使用过程发现并不好用，或者不太适合我们的项目，这样改造起来也有针对性。 优缺点 优点：可以自动生成文档 Dingo API 使用提供了 api:docs 这个 artisan 命令，可以自动为 API 生成版本文档。 缺点：文档生成不够智能，代码中注释量增多 虽然在定义 API 端点的时候指已经明了版本号和路由，但是为了生成更好看的 API 文档，仍然需要在类和方法前面重新定义路由的类型和路径，已经版本号。这样一来，代码中要添加很多额外的注释。 缺点：api:cache 会缓存除了 API 以外的所有路由。 期望:只缓存通过 Dingo API 定义好的路由。 FAQ version 为 group 的别名 12// 获得版本号为 v1 的路由列表dd(version('v1')); 如何访问指定版本的接口？在配置 Dingo API 的时候，有个配置项叫做 API_VERSION 的配置，这个配置的作用是作为默认版本号，即客户端当没有指定。 在 HTTP 请求头中添加 Accept 字段，举例说明： 123curl -X GET http://api.example.com/user \\-H 'Authorization: Bearer ??TOKEN??' \\-H 'Accept: application/vnd.&#123;API_SUBTYPE&#125;.&#123;VERSION_NUMBER&#125;+json' \\ 其中，API_SUBTYPE 就是 .env 中配置的 API_SUBTYPE ，VERSION_NUMBER 就是使用 version() 方法定义过的版本号，vnd 是 API_STANDARDS_TREE 推荐的值，json 代表客户端期望服务器返回的数据格式。 如何正确使用自动刷新 Token 机制？需要前后端协作好：后端要根据当此请求携带的 Token 自动生成一条新 Token，并返回给前端；前端要做好自动使用后端每次返回的更新 Token 来作为下次 API 请求的 Token。 以 tymon/jwt-auth 认证驱动为例，在 Tymon\\JWTAuth\\Providers\\AbstractServiceProvider 中已经定义好 $middlewareAliases 中间件别名如下： 123456protected $middlewareAliases = [ 'jwt.auth' =&gt; Authenticate::class, 'jwt.check' =&gt; Check::class, 'jwt.refresh' =&gt; RefreshToken::class, // 重新刷新 TOKEN 'jwt.renew' =&gt; AuthenticateAndRenew::class,]; 可以直接在路由定义或控制器构造函数中使用： 123456789101112131415// 路由中使用dingo()-&gt;version('v1', [ 'namespace' =&gt; 'App\\Http\\Controllers\\Api\\V1', 'middleware' =&gt; [ 'jwt.refresh', ],], function ($router) &#123; // ...&#125;);// 在控制器中使用public function __construct()&#123; $this-&gt;middleware('jwt.refresh');&#125; 每次请求 API 成功后，均会在响应头中的 Authorization字段，其值便是刷新后的 Token。 如何使用 dingo Router 中 name() 定义过的 API 路由？Dingo 定义过的的命名路由是不能用 Laravel 自带的 route 方法获取完整 URL 的，只能用 Dingo 的 URL 生成器。 举例说明： 123456789101112// 定义微信授权登录回调路由$router -&gt;post('&#123;user&#125;/wechat', 'Passport@oauthloginFromWechat') -&gt;name('callback.oauth.wechat'); // 错误写法route('callback.oauth.wechat'); // 提示找不到路由// 正确写法app('Dingo\\Api\\Routing\\UrlGenerator') -&gt;version('v1') -&gt;route('callback.oauth.wechat', ['user' =&gt; 1]); 参考 liyu001989/lumen-api-demo Laravel 多用户认证 Where to write transformers ? · Issue #341 · dingo/api Test Driven API Development using Laravel, Dingo and JWT with Documentation","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"LaravelAdmin","slug":"LaravelAdmin","permalink":"http://blog.caoxl.com/tags/LaravelAdmin/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"DingoAPI","slug":"DingoAPI","permalink":"http://blog.caoxl.com/tags/DingoAPI/"}]},{"title":"Laravel核心之IOC和Facade","slug":"Ioc-And-Facade-In-Laravel","date":"2018-01-24T10:17:20.000Z","updated":"2019-08-22T03:58:41.000Z","comments":true,"path":"2018/01/24/Ioc-And-Facade-In-Laravel/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/Ioc-And-Facade-In-Laravel/","excerpt":"这两个概念对于 Laravel 的使用者来说应该并不陌生，尤其是当你希望扩展或者替换 Laravel 核心库的时候，理解和合理使用它们可以极大提升 Laravel 的战斗力。这里以创建一个自己的 ServiceProvider 为例理解 Inversion of Control 和 Facade 在 Laravel 中的应用。 这是写于2014年的老文章,只是为了从远古时期了解下Laravel的核心,基础好的可以略过 直接看最新文档即可: Laravel 让我们书写优雅的代码","text":"这两个概念对于 Laravel 的使用者来说应该并不陌生，尤其是当你希望扩展或者替换 Laravel 核心库的时候，理解和合理使用它们可以极大提升 Laravel 的战斗力。这里以创建一个自己的 ServiceProvider 为例理解 Inversion of Control 和 Facade 在 Laravel 中的应用。 这是写于2014年的老文章,只是为了从远古时期了解下Laravel的核心,基础好的可以略过 直接看最新文档即可: Laravel 让我们书写优雅的代码 控制反转（Inversion of Control）什么是 IoC ? 控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。 — 维基百科 简单说来，就是一个类把自己的的控制权交给另外一个对象，类间的依赖由这个对象去解决。依赖注入属于依赖的显示申明，而依赖查找则是通过查找来解决依赖。 Laravel 中的使用注入一个类： 1234App::bind('foo', function($app)&#123; return new FooBar;&#125;); 这个例子的意思是创建一个别名为 foo 的类，使用时实际实例化的是 FooBar。 使用这个类的方法是 1$value = App::make('foo'); $value 实际上是 FooBar 对象。 这样的话每次实例化后的都是同一个对象。 注入类的更多例子可以看 Laravel 官网 你可能会疑问上面的代码应该写在哪儿呢？答案是你希望他们在哪儿运行就写在哪儿。知道写哪儿还用来看这种基础文章么！ 服务提供器 (Service Providers)为了让依赖注入的代码不至于写乱，Laravel 搞了一个 服务提供器（Service Provider）的东西，它将这些依赖聚集在了一块，统一申明和管理，让依赖变得更加容易维护。 Laravel 中的使用定义一个服务提供器： 12345678910111213use Illuminate\\Support\\ServiceProvider;class FooServiceProvider extends ServiceProvider &#123; public function register() &#123; $this-&gt;app-&gt;bind('foo', function() &#123; return new Foo; &#125;); &#125;&#125; 这个代码也不难理解，就是申明一个服务提供器，这个服务提供器有一个 register 的方法。这个方法实现了我们上面讲到的依赖注入。 当我们执行下面代码： 1App::register('FooServiceProvider'); 我们就完成一个注入了。但是这个还是得手动写，所以怎么让 Laravel 自己来做这事儿呢？ 我们只要在 app/config/app.php 中的 providers 数组里面增加一行： 1234'providers' =&gt; [ … ‘FooServiceProvider’,], 这样我们就可以使用 App::make(‘foo’) 来实例化一个类了。 你不禁要问了，这么写也太难看了吧？不要慌，有办法。 门面模式（Facade）为了让 Laravel 中的核心类使用起来更加方便，Laravel实现了门面模式。 外觀模式（Facade pattern），是軟件工程中常用的一種軟件設計模式，它為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。 — 维基百科 Laravel 中的使用我们使用的大部分核心类都是基于门面模式实现的。例如： 1$value = Cache::get('key'); 这些静态调用实际上调用的并不是静态方法，而是通过 PHP 的魔术方法 __callStatic() 将请求转到了相应的方法上。 那么如何讲我们前面写的服务提供器也这样使用呢？方法很简单，只要这么写： 1234567use Illuminate\\Support\\Facades\\Facade;class Foo extends Facade &#123; protected static function getFacadeAccessor() &#123; return ‘foo’; &#125;&#125; 这样我们就可以通过 Foo::test() 来调用我们之前真正的 FooBar 类的方法了。 别名（Alias）有时候我们可能将 Facade 放在我们扩展库中，它有比较深的命名空间，如：\\Library\\MyClass\\Foo。这样导致使用起来并不方便。Laravel 可以用别名来替换掉这么长的名字。 我们只要在 app/config/app.php 中 aliases 下增加一行即可： 1234'aliases' =&gt; [ … 'Foo' =&gt; ‘Library\\MyClass\\Foo’,], 这样它的使用就由 \\Library\\MyClass\\Foo::test() 变成 Foo::test() 了。 总结所以有了控制反转（Inversion of Control）和 门面模式（Facade），实际还有 服务提供器（Service Providers）和别名（Alias），我们创建自己的类库和扩展 Laravel 都会方便很多。 这里总结一下创建自己类库的方法： 1.在 app/library/MyFoo 下创建类 MyFoo.php 2.在 app/library/MyFoo/providers 下创建 MyFooServiceProvider.php 3.在 app/library/MyFoo/facades 下创建 MyFooFacade.php 4.在 app/config/app.php 中添加 providers 和 aliases 参考 Laravel核心之IOC和Facade Laravel 文档","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Ioc","slug":"Ioc","permalink":"http://blog.caoxl.com/tags/Ioc/"},{"name":"Facade","slug":"Facade","permalink":"http://blog.caoxl.com/tags/Facade/"}]},{"title":"Docker 使用总结","slug":"Docker-Summary-Notes","date":"2018-01-24T09:39:03.000Z","updated":"2019-08-22T03:31:10.000Z","comments":true,"path":"2018/01/24/Docker-Summary-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/Docker-Summary-Notes/","excerpt":"Docker 基本概念镜像 Image镜像是一些打包好的已有的环境，可以被用来启动和创建容器，本身不能被直接修改。 容器 Container容器是镜像的实例化，是可以修改的，但是都是临时修改。","text":"Docker 基本概念镜像 Image镜像是一些打包好的已有的环境，可以被用来启动和创建容器，本身不能被直接修改。 容器 Container容器是镜像的实例化，是可以修改的，但是都是临时修改。 容器启动过程1.检查本地是否存在指定的镜像，不存在就从公有仓库下载 2.利用镜像创建并启动一个容器 3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 5.从地址池配置一个 ip 地址给容器 6.执行用户指定的应用程序 7.执行完毕后容器被终止 Docker 常用命令Image「镜像」 操作基本操作 显示本地所有镜像 1docker images 搜索镜像 1docker search image_name 下载镜像 1docker pull image_name 删除镜像 1docker rmi image_name 显示镜像历史 1docker history image_name 制作镜像1docker build -t image_name DockerfilePath 这里DockerfilePath是Context上下文目录，在创建的时候会全部上传到Docker Server端，所以这个目录不要太大 迁移镜像 保存镜像到文件 1docker save image_name -o file.tar 加载一个tar包的镜像 1docker load -i file.tar Container「容器」操作显示相关 查看运行中的容器 12345678910docker ps# 一行显示全部容器docker ps | less -S# 最近一次启动docker ps -l# 列出所有容器docker ps -a 显示一个运行的容器里面的进程信息 1docker top cid 显示容器详细信息 1docker inspect cid 查看容器日志 1234docker logs cid# 实时查看日志输出docker logs -f cid 查看容器更改 1docker diff cid 查看容器root用户密码 1docker logs cid 2&gt;&amp;1 | grep '^User: ' | tail -n1 运行相关 启动容器并执行一个命令（交互） 123456789101112131415161718192021222324# -t 终端# -i 交互操作docker run -it ubuntu /bin/bash# 运行一个hello word然后就自动关闭docker run image_name echo \"hello word\"# 命名并启动容器docker run --name test ubuntu# 后台运行一个容器docker run -d -it ubuntu# 映射端口docker run -p 8080:8080 ubuntu# 挂载volumndocker run -v ./test:/var/www# container 内 root 拥有真正root权限docker run --privileged=false# 启动完镜像后自动删除docker run -it --rm ubuntu bash 附着到正在运行的容器, 附着完以后退出会导致容器也终止 1docker attach cid 进入正在运行的 container 并且执行 1docker exec -it 839a6cfc9496 /bin/bash 在容器中运行一段程序 1docker run ubuntu apt-get update 拷贝文件出来 1docker cp cid:/container_path to_path 修改容器image相当于类，container相当于实例，不过可以动态给实例安装新软件，然后把这个container用commit命令固化成一个image 提交一个commit 1docker commit cid new_image_name 删除容器 1234567docker rm cid# 强制删除docker rm -f cid# 删除所有容器docker rm `docker ps -a -q` 状态修改 1docker start/stop/kill/restart cid 更改名字 1docker rename old new 链接容器sonar容器连接到mysql容器，并将mysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。 1docker run -it --name sonar -d -link mysql:db tpires/sonar-server 仓库操作 登录到docker仓库 1docker login 上传镜像 1docker push new_image_name Dockerfile 常用命令有了 Dockerfile 可以自定义一些自己需要的镜像，在熟悉了 Docker 基本操作，然后使用过一些别人提供好的镜像以后，难免需要自己修改一部分。 FROM指定基础镜像。例如： ubuntu nginx redis … 1FROM nginx RUN执行一些命令 1RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html 每个RUN命令都会在容器中建立一层，所以尽量合并多个命令。例如 1234RUN buildDeps='gcc libc6-dev make' \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ ... COPY复制文件到指定目录 source -&gt; target 1COPY ./package.json /usr/src/app CMD容器的启动命令 1CMD [\"nginx\", \"-g\", \"daemon off;\"] 这个命令可以在启动时被覆盖,另外它也可以为 ENTRYPOINT 提供参数。 CMD 理论上只能执行一次，如果想要执行两个命令，需要使用 &amp; 来连接两个命令，或者使用一个bash文件。更为高级一点的方法是用supervisor来管理 ENTRYPOINTENTRYPOINT 和 CMD 有一部分重复工作，但是 ENTRYPOINT 可以让容器像软件一样执行。例如 1ENTRYPOINT /bin/echo 在容器启动时，之后增加的内容都属于这个命令的参数 ENV设置环境变量。 1ENV key value ARG构建参数，在容器启动后不会存在。 VOLUME定义匿名卷，以免用户忘了挂载 volumn，导致大量写入。这个 Volume在容器启动前可以添加内容，但是并不是实际操作用户挂载的内容。在用户挂载完 volume 后，原来写在这里的内容会被复制到用户挂载的目录。 注意：在 VOLUME 命令之后对这个目录的所有操作，将被忽略。 EXPOSE申明端口，可以用来默认映射端口，以及容器间互通。 1EXPOSE 22 80 WORKDIR指定工作目录。不仅是当前 docker 中的目录，同时也是运行容器时刚刚登录以后的目录。 USER指定当前用户。 123RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ \"redis-server\" ] HEALTHCHECK健康检查 ONBUILD当此容器作为别的容器的基础容器时操作内容 1234567FROM node:slimRUN \"mkdir /app\"WORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN [ \"npm\", \"install\" ]ONBUILD COPY . /app/CMD [ \"npm\", \"start\" ] Docker-compose 常用指令depends_on这个不仅可以保证build的先后顺序，还可以省去links的设置 links和docker run命令一致，主要原因是在每次新开启container的时候，port可能会变，所以有了这个设置可以保证每次都可以绑定到正确的值。 实例操作创建一个LAMP的项目首先是目录结构 123456789101112├── README.md├── apache│ └── virtualhost.conf├── docker-compose.yml├── mysql│ ├── Dockerfile│ └── my.cnf├── php│ ├── Dockerfile│ └── php.ini└── src └── index.php 创建 docker-compose.yml 123456789101112131415161718192021222324252627282930313233343536373839version: '2'services: mysql: image: mysql ports: - \"3306:3306\" environment: MYSQL_ROOT_PASSWORD: password MYSQL_DATABASE: phpdata MYSQL_USER: user MYSQL_PASSWORD: password volumes: - dbdata:/var/lib/mysql php: build: ./php ports: - '8080:80' volumes: - ./src:/var/www/html - ./apache:/etc/apache2/sites-enabled/ depends_on: - mysql phpmyadmin: image: phpmyadmin/phpmyadmin ports: - '8081:80' links: - mysql:db environment: PMA_USER: root PMA_PASSWORD: password volumes: - adminsessions:/sessions depends_on: - mysql - phpvolumes: dbdata: adminsessions: FAQMysql 挂载 volume 后启动时显示无权限设置mysql的启动模式 privileged:true 另外这个问题一般不会发生，我之前遇到主要原因是我把多个 volume 都映射到了一个上面，导致目录内部读写发生冲突。 参考 Docker 使用总结","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.caoxl.com/tags/Docker/"},{"name":"DevTool","slug":"DevTool","permalink":"http://blog.caoxl.com/tags/DevTool/"}]},{"title":"CentOS After Minimal","slug":"CentOS-After-Minimal","date":"2018-01-24T09:17:07.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/24/CentOS-After-Minimal/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/CentOS-After-Minimal/","excerpt":"这里对 CentOS 作为服务器个人需要做的事务列举出来。 说明： 由于 CentOS 多做服务器，服务器一般很少为了支持新硬件去更新内核，再加上现如今常用的阿里云之类的云服务器不能更新内核，所以这里暂时忽略内核的升级过程。","text":"这里对 CentOS 作为服务器个人需要做的事务列举出来。 说明： 由于 CentOS 多做服务器，服务器一般很少为了支持新硬件去更新内核，再加上现如今常用的阿里云之类的云服务器不能更新内核，所以这里暂时忽略内核的升级过程。 resolv.conf &amp; hosts123456789101112131415161718192021222324252627282930# resolv.confvi /etc/resolv.conf ; Google nameserver 8.8.8.8 nameserver 8.8.4.4 ; DNSPod nameserver 119.29.29.29 nameserver 182.254.116.116 ; OpenDNS nameserver 208.67.222.222 nameserver 208.67.220.220 ; V2EX nameserver 178.79.131.110 ; 114 114.114.114.114service network restartping github.comping baidu.com# hosts (Just in case)vi /etc/hosts #207.97.227.239 github.com 204.232.175.78 documentcloud.github.com 204.232.175.94 gist.github.com 107.21.116.220 help.github.com 207.97.227.252 nodeload.github.com 199.27.76.130 raw.github.com 107.22.3.110 status.github.com 204.232.175.78 training.github.co 207.97.227.243 www.github.com 开启 EPEL/IUS/Remi Repos1234567891011121314151617181920212223242526272829# !!! ensure root permission first# 1. EPELyum install epel-release# Orwget https://dl.fedoraproject.org/pub/epel/epel-release-latest-[5|6|7].noarch.rpmrpm -Uvh epel-release-*.rpm# 2. IUSwget https://centos[5|6|7].iuscommunity.org/ius-release.rpmrpm -Uvh ius-release*.rpm# Upgrade installed packages to IUS versionsyum install -y yum-plugin-replace# eg: yum replace php --replace-with php53# 3. Remiwget http://rpms.famillecollet.com/enterprise/remi-release-[5|6|7].rpmrpm -Uvh remi-release-*.rpm# Enable Remivim /etc/yum.repos.d/remi.repo # enabled=1# Oryum --enablerepo=remi install php-tcpdf# update and checkyum -y updateyum groupinstall -y 'development tools'yum repolist# fastestmirroryum install fastestmirror 编译安装最新版 Git CentOS 6.8 使用 yum 安装 git 总是 1.7，要使用最新 Git 必须编译安装。 12345678910111213141516171819# 1. Install Required Packagesyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker# 2. Download and Install Gitcd /usr/srcwget https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gztar xzf git-2.10.0.tar.gzcd git-2.10.0make prefix=/usr/local/git allmake prefix=/usr/local/git install# 3. Setup Environmentexport PATH=$PATH:/usr/local/git/binsource /etc/bashrc# Or zsh etc.ln -s /usr/local/git/bin/git /usr/local/bin# 4. Checkgit --version Vim123456yum remove viyum install -y vimgit clone https://github.com/amix/vimrc.git ~/.vim_runtimesh ~/.vim_runtime/install_awesome_vimrc.sh# Include your staff like thisgit clone git@github.com:uguu-org/vim-matrix-screensaver.git ~/.vim_runtime/sources_non_forked/vim-matrix-screensaver zsh &amp; oh-my-zsh &amp;&amp; zsh-users123456789101112yum install -y zshsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"# Or# sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"cd ~/.oh-my-zsh/pluginsgit clone git://github.com/zsh-users/zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-syntax-highlighting.gitvim ~/.zshrcplugins=(git, zsh-autosuggestions, zsh-syntax-highlighting)source ~/.zshrc LEMPA使用 oneinstack 快速搭建 LEMPA 环境即可。 选择当前最新组合：php7.1.^ + mysql^5.7. + nginx^1.11. + Apache^2. + phpMyAdmin^4.6.*。 选择合适的版本即可 其中，如果想自定义每个项目的版本，可以在 oneinstack/versions.txt 里面指定你想要通过 oneinstack 安装的软件版本。 phpMyAdmin 高级功能设置方法1.首次登录 phpMyAdmin 后导入 sql/create_tables.sql，即创建 phpmyadmin 这个数据库 2.取消 config.inc.php 中关于 phpmyadmin 的注释，搜索 /* Storage database and tables */，其下十几张表全部打开 Python由于依赖这货的东西太多了，为了减少麻烦，请保留 centos6.8 上原有的 python2.6 版本，要使用高版本的 python 请命名为 python2（表示最新 python2. 版本，python3（表示最新 python 3. 版本），然后 link 到 $PATH。 12345678910111213141516171819202122232425262728293031# 更新 &amp; 依赖安装# yum groupinstall -y 'development tools'yum install -y zlib-devel bzip2-devel openssl-devel xz-libs wget# 下载 &amp; 解压wget http://www.python.org/ftp/python/2.7.9/Python-2.7.9.tar.xzxz -d Python-2.7.9.tar.xztar -xvf Python-2.7.9.tar# 编译 &amp; 安装cd Python-2.7.8./configure --prefix=/usr/localmake &amp;&amp; make altinstall# PATHexport PATH=\"/usr/local/bin:$PATH\"# or ln -s /usr/local/bin/python2.7 /usr/bin/python# setuptoolswget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-1.4.2.tar.gztar -xvf setuptools-1.4.2.tar.gzcd setuptools-1.4.2python2.7 setup.py install# pipcurl https://bootstrap.pypa.io/get-pip.py | python2.7 -# 修复 yum [如果非要用 `python` 覆盖 2.6 版本的话]vim /usr/bin/yum#!/usr/bin/python =&gt; #!/usr/bin/python2.6 NodeJS12345wget https://nodejs.org/dist/v4.5.0/node-v4.5.0-linux-x64.tar.xzxz -d node-v4.5.0-linux-x64.tar.xztar -xf node-v4.5.0-linux-x64.tar /usr/local/src/node4.5ln -s /usr/local/src/node4.5/bin/node /usr/local/bin/rm -rf node-v4.5.0-linux-x64.tar.xz Ruby123456wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gztar -zxvf ruby-2.3.1.tar.gzcd ruby-2.3.1# default installed to /usr/local, use `./configure --prefix=DIR` to change./configuremake &amp;&amp; make install 其他安装清单1yum install tmux lsof htop alias12345678910111213141516alias vi=\"vim\"alias cls=\"clear\"alias clshis=\"echo ''&gt;~/.zshrc_history &amp;&amp; echo '' &gt; ~/.bash_history\"alias chmd=\"chown -R www:www /data/wwwroot/\"alias vzshrc=\"vim ~/.zshrc\"alias szsh=\"source ~/.zshrc\"alias sbash=\"source ~/.bash_profile\"alias gad=\"git add . -A\"alias gcmt='read comments &amp;&amp; git commit -m \"$comments\"'alias gcm=\"git checkout master\"alias gpullm=\"git pull origin master\"alias vssh=\"vagrant ssh\"alias vre=\"vagrant reload\"alias vup=\"vagrant up\"alias vgs=\"vagrant global-status\"alias vhalt=\"vagrant halt\" $PATH12export PATH=\"/usr/local/bin:/usr/local/sbin:$PATH\"export PATH=\"/root/.composer/vendor/bin:$PATH\" FAQ Could not retrieve mirrorlist Your dns isn’t working. Check /etc/resolv.conf for valid and accessible nameserver lines. Use 8.8.8.8 if needs be. Can’t locate ExtUtils/MakeMaker.pm” while compile git 123yum install perl-devel# if the above not work, try also install the CPAN# yum install perl-CPAN error: There was a problem with the editor ‘vi’ 12345# Usuallygit config --global core.editor /usr/bin/vim# Orgit config --global core.editor $(which vim) 登录 phpMyAdmin 后提示：The secret passphrase in configuration (blowfish_secret) is too short. 123vim /path/to/phpMyAdmin/config.inc.php$cfg['blowfish_secret'] = '32位字符串'; # 默认不是 32 位长度 改为 32 位长度即可 yum Error:rpmdb open failed 123456789mkdir /root/backups.rpm.mm_dd_yyyy/cp -avr /var/lib/rpm/ /root/backups.rpm.mm_dd_yyyy/rm -f /var/lib/rpm/__db*db_verify /var/lib/rpm/Packagesrpm --rebuilddbyum clean allyum update 参考 Install EPEL, IUS, and Remi repositories on CentOS and Red Hat How to Install Git 2.8.1 on CentOS/RHEL 7/6/5 &amp; Fedora https://github.com/robbyrussell/oh-my-zsh zsh-users Python包管理工具setuptools详解 yum Error:rpmdb open failed","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://blog.caoxl.com/tags/CentOS/"}]},{"title":"Nginx Access Log日志统计分析常用命令","slug":"Nginx-Access-Log-Count-Anaysis","date":"2018-01-24T08:57:43.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/24/Nginx-Access-Log-Count-Anaysis/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/Nginx-Access-Log-Count-Anaysis/","excerpt":"IP相关统计统计IP访问量1awk '&#123;print $1&#125;' access.log | sort -n | uniq | wc -l","text":"IP相关统计统计IP访问量1awk '&#123;print $1&#125;' access.log | sort -n | uniq | wc -l 查看某一时间段的IP访问量(4-5点)1grep \"07/Apr/2018:0[4-5]\" access.log | awk '&#123;print $1&#125;' | sort | uniq -c| sort -nr | wc -l 查看访问最频繁的前100个IP1awk '&#123;print $1&#125;' access.log | sort -n |uniq -c | sort -rn | head -n 100 查看访问100次以上的IP1awk '&#123;print $1&#125;' access.log | sort -n |uniq -c |awk '&#123;if($1 &gt;100) print $0&#125;'|sort -rn 查询某个IP的详细访问情况,按访问频率排序1grep '104.217.108.66' access.log |awk '&#123;print $7&#125;'|sort |uniq -c |sort -rn |head -n 100 页面访问统计查看访问最频的页面(TOP100)1awk '&#123;print $7&#125;' access.log | sort |uniq -c | sort -rn | head -n 10 查看访问最频的页面([排除php页面] (TOP100))1grep -v \".php\" access.log | awk '&#123;print $7&#125;' | sort |uniq -c | sort -rn | head -n 100 查看页面访问次数超过100次的页面1cat access.log | cut -d ' ' -f 7 | sort |uniq -c | awk '&#123;if ($1 &gt; 100) print $0&#125;' | less 查看最近1000条记录，访问量最高的页面1tail -1000 access.log |awk '&#123;print $7&#125;'|sort|uniq -c|sort -nr|less 请求量统计每秒请求量统计统计每秒的请求数,top100的时间点(精确到秒) 1awk '&#123;print $4&#125;' access.log |cut -c 14-21|sort|uniq -c|sort -nr|head -n 100 每分钟请求量统计统计每分钟的请求数,top100的时间点(精确到分钟) 1awk '&#123;print $4&#125;' access.log |cut -c 14-18|sort|uniq -c|sort -nr|head -n 100 每小时请求量统计统计每小时的请求数,top100的时间点(精确到小时) 1awk '&#123;print $4&#125;' access.log |cut -c 14-15|sort|uniq -c|sort -nr|head -n 100 性能分析在nginx log中最后一个字段加入$request_time 列出传输时间超过 3 秒的页面，显示前20条1cat access.log|awk '($NF &gt; 3)&#123;print $7&#125;'|sort -n|uniq -c|sort -nr|head -20 列出php页面请求时间超过3秒的页面，并统计其出现的次数，显示前100条1cat access.log|awk '($NF &gt; 1 &amp;&amp; $7~/\\.php/)&#123;print $7&#125;'|sort -n|uniq -c|sort -nr|head -100 蜘蛛抓取统计统计蜘蛛抓取次数1grep 'Baiduspider' access.log |wc -l 统计蜘蛛抓取404的次数1grep 'Baiduspider' access.log |grep '404' | wc -l TCP连接统计查看当前TCP连接数1netstat -tan | grep \"ESTABLISHED\" | grep \":80\" | wc -l 用tcpdump嗅探80端口的访问看看谁最高1tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F\".\" '&#123;print $1\".\"$2\".\"$3\".\"$4&#125;' | sort | uniq -c | sort -nr 参考","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"}]},{"title":"PHP 项目优化","slug":"PHP-Project-Optimizetion","date":"2018-01-24T08:44:34.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/24/PHP-Project-Optimizetion/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/PHP-Project-Optimizetion/","excerpt":"关于 PHP 性能分析、优化和实践总结在这里。 无论现在有没有遇到性能问题，但是这是迟早都会面临的问题。","text":"关于 PHP 性能分析、优化和实践总结在这里。 无论现在有没有遇到性能问题，但是这是迟早都会面临的问题。 性能优化概述影响 PHP 性能的可能性 语法使用不当 使用 PHP 做了它不擅长的事情 PHP 适合处理服务端业务逻辑、数据库处理、和视图渲染，不适合计算密集型业务，不适合表示复杂的算法。 通过 PHP 连接的服务有性能问题 数据库，第三方服务接口等等。 PHP 语言本身的缺点或特点 语法不严谨 严格来说也不叫缺点，而应该是特点 这个“缺点”会让经验不足、水平不够的程序员写出糟糕的代码。 原生对多线程支持不好 通常只能模拟实现简单的多线程场景。 原生不支持对象常驻内存PHP 所有变量都是页面级的，PHP 页面执行完毕就会被释放。 PHP 周边环境问题 比如操作系统、内存、磁盘I/O、网络环境、Web 服务器、DB 等本身的一些限制。 整个项目的性能问题不可能都是 PHP 的性能问题，因此优化 PHP 项目性能时，不要局限于优化 PHP。 网络问题 一些未知因素 优化 PHP 项目的方向 PHP 代码级别 PHP 周边问题 PHP 语言自身 从上往下，难度依次增加。 PHP 代码层优化PHP 内核标准的 PHP 内核简单说只有 3 个： 词法分析 语法分析 Zend Engine 从宏观上来看，PHP 内核的实现与世界上绝大多数的程序一样：接收输入数据， 做相应处理，然后输出计算结果。我们编写的代码就是 PHP 接收的输入数据，PHP 内核对我们编写的代码进行解释和运算， 最后返回相应的运算结果。 然而，PHP 与我们自己平时写的一般的 C 程序有所不同的是， 我们的程序一般用来解决某个具体问题， 而 PHP 本身实现了把用户的逻辑“翻译”为机器语言来执行的功能，这也是各种编译语言与承载具体业务逻辑的程序代码的一个明显区别。 Web 应用中 PHP 代码运行流程 之所以要加上 “Web 应用中” 这个前提，是因为 PHP 除了常用的处理 Web 请求外，还可以在 CLI 模式下运行，而两种运行方式的具体实现是不一样的。 从 HTTP 请求到达一个 PHP 脚本开始，到 PHP 处理结束返回结果之间，标准 PHP (https://php.net) 会经历以下过程： *.php 文件 PHP 内核接受 PHP 代码。 Scanner：词法分析 词法分析是把 PHP 代码分割成一个个的“单元”（TOKEN）：Zend 引擎逐行运行扫描、分析，结束后保存为 Zend 能识别的代码 Exprs。 Parser：语法分析 语法分析则将这些“单元”转化为 Zend Engine 可执行的操作：Exprs 被 Parser 解析为 Opcodes，即最终会被 PHP 内核第三个组成部分 Zend Engine VM，执行的代码 Exec Zend Engine VM 执行 Opcodes。 PHP 现有的很多缓存服务都是直接缓存的 Opcode，这也是为了提高 PHP 的性能。 Output 输出执行结果。 多用 PHP 自身能力能用 PHP 内置方法解决的就用内置方法，不要重复造轮子。 自写代码一般冗余较多，可读性不佳，主要是性能低。因为自写代码需要编译解析为底层语言才能被执行，这个过程每次请求 PHP 页面时都会发生，时间开销大。 因此，多使用 PHP 内置变量、常量、API、解决方案。 举例说明： 1vim -o bad.php good.php bad.php 12345678910111213141516171819202122232425&lt;?php$arr1 = array();$arr2 = array();for ( $i=0; $i&lt;rand(1000, 2000); ++$i ) &#123; $arr1[] = rand();&#125;for ( $i=0; $i&lt;rand(1000, 2000); ++$i ) &#123; $arr2[] = rand();&#125;$arr_merged = array() ;foreach ( $arr1 as $val ) &#123; $arr_merged[] = $v;&#125;foreach ( $arr2 as $val ) &#123; if(!in_array($val, $arr_merged))&#123; $arr_merged[] = $val ; &#125;&#125;var_dump( $arr1, $arr2, $arr_merged ) ; good.php 1234567&lt;?php$arr1 = $arr2 = range( 1000, 2000 ) ; shuffle( $arr1 ) ;shuffle( $arr2 ) ;$arr_merged = array_merge( $arr1, $arr2 ) ;var_dump( $arr1, $arr2, $arr_merged ) ; bad.php 和 good.php 都是为了完成合并数组，并要求重复的只出现一次这个操作。但是，两者的性能却差别巨大，可以使用压力测试： 12ab -n100 -c10 http://localhost/bad.phpab -n100 -c10 http://localhost/good.php 结果显示，good.php 比 bad.php 的性能高 &gt; 10 倍。 bad.php 和 good.php 相比，虽然在执行的时候虽然都会经历上面几个流程，但是，在逐行扫描的过程中，直接用 PHP 内置函数会节省更多的时间，因为 PHP 内置函数 Zend 引擎是理解的，就不会耗费时间进行分析，从而极大地提高了速度。 总之，使用 PHP 自身方法去实现一个功能，比用 PHP 自写代码自定义方法实现同样功能，性能要高很多，所以要尽可能使用 PHP 函数。 使用性能更好的 PHP 内置函数PHP 内置函数之间，仍然存在快和慢的差距。要从代码层优化 PHP 项目，多了解 PHP 内置函数的时间复杂度也是必不可少的。 以 isset() 和 array_key_exists() 方法对比说明： 123456789101112131415161718192021$start = getTime();$i = 0;$arr = range(1, 200000);while ($i &lt; 200000) &#123; ++$i; // 1. isset() // isset($arr[$i]); // 2. array_key_exists() array_key_exists($i, $arr);&#125;$end = getTime();echo 'Spent: ', number_format($end-$start, 3)*1000, 'ms', PHP_EOL;// 获得微秒级别的 UNIX 时间戳function getTime() &#123; list($usecs, $secs) = explode(' ', microtime()); return (float)$usecs + (float)$secs;&#125; 运行后发现：isset() 比 array_key_exists() 效率更高大约 10 ms。 尽可能少用魔术方法这是因为 PHP 提供的魔术方法性能都不怎么好。 至于为什么不好，这个理性地解释应该是，为了省事，PHP 为了程序员做了很多。举例说明： 12345678910111213141516171819202122232425// test.php// 1. 使用魔术方法class Test&#123; private $var = 1024 ; public function __get( $var ) &#123; return $this-&gt;var ; &#125; public $var = 1024;&#125;// 2. 不使用魔术方法class Test&#123; public $var = 1024;&#125;# 测试魔术方法$i=0;while ( $i &lt; 10000 ) &#123; $i ++; $test = new Test(); $test-&gt;var;&#125; 可以使用 time 命令来简单判断执行时间： 1time php test.php 测试结果显示，在相同测试条件下，不使用魔术方法比使用魔术方法效率更高（这个例子的规模下，相差近 3 倍）。 避免使用 @PHP 提供错误抑制符，也是为了方便懒人。 在每次”方便”之间，损失的是性能。 @ 的实际工作原理是： 先降低报错等级，再恢复报错等级。 在代码开始前，结束后，增加 Opcode，忽略报错。 可以使用 vld 工具（下面会说）测试。举例如下： test.php 12&lt;?php@file_get_contents( 'xxx' ); // wrong path vld 测试 12345# active=1 表示使用 vld# execute=0 表示不执行代码只是查看 Opcode# verbosity 代表输出VLD 生成内容的详细程度php -dvld.active=1 -dvld.execute=0 test.php 建议：尽量使用 try {} catch () 的方式控制错误而不要使用这种取巧的方式。 合理使用内存虽然 PHP 提供了 GC 机制，但是不意味着放心大胆地使用内存。 建议： 使用 unset() 及时释放不使用的内存。 尽量少用正则正则表达式的回溯开销大，且逻辑复杂，容易出错。 建议： 能用字符串函数等 PHP 内置 API 解决的问题就不要用正则表达式。 避免循环中动态计算动态计算指的就是函数调用。典型的坏例子： 1234$str = 'i am a bad example.';for ($i=0; $i&lt;strlen($str); $i++) &#123; // ...&#125; 这种情况，就算 strlen() 效率再高，也是无意义的浪费。 但是，也不是说循环内就不能调用函数了，一些不是重复的数据，在特定的使用场景下，也不得不在循环内调用函数计算，这和这个例子不一样。 PHP 不适合处理大数据，如果使用 PHP 处理大数据，那么很容易出现性能瓶。 PHP 配合模板引擎适合 UI 呈现。 PHP 的所有计算都将转换为 C 语言，很多代码实现都依赖 C 实现。 使用 PHP Generator PHP generators are an underutilized yet remarkably helpful feature introduced in PHP 5.5.0. Generators are simple iterators. Generators compute and yield iteration values on-demand. 123456789function myGenerator() &#123; yield 'value1'; yield 'value2'; yield 'value3';&#125;foreach (myGenerator() as $yieldedValue) &#123; echo $yieldedValue, PHP_EOL;&#125; 但是，PHP Generator 只能用于单方向迭代的、一次性的需求，但是这种需求的出现频率还是挺高的。关于用和不同的差距，可以举一个例子对比： bad.php 123456789101112function makeRange($length) &#123; $dataset = []; for ($i = 0; $i &lt; $length; $i++) &#123; $dataset[] = $i; &#125; return $dataset;&#125;$customRange = makeRange(900000);foreach ($customRange as $i) &#123; echo $i, PHP_EOL;&#125; good.php 123456789function makeRange($length) &#123; for ($i = 0; $i &lt; $length; $i++) &#123; yield $i; &#125;&#125;foreach (makeRange(900000) as $i) &#123; echo $i, PHP_EOL;&#125; 可以分析两者的执行结果，结论是：goods.php 比 bad.php 不仅提升性能，而且节约了内存，解决了迭代数据量过大时内存不够的问题。 在 bad.php 中，如果把规模调大，比如 100000000，那么执行 bad.php 时，其实是没有输出的，因为超过了 PHP 配置中分配给脚本所能使用的上限（memory_limit），但是使用 good.php 却能正常显示，这是因为 yield() 方法是按需生成数据的，占不了多少内存。 建议：能用 Generator 替换默认迭代的就使用 Generator。 数组键名为常量问题123456789define( 'key', 'value' );$arr = array( 'key' =&gt; 'hello' , 'value' =&gt; 'world');echo $arr[ key ], PHP_EOL;echo $arr[ 'key' ]; PHP 会把不带引号的数组键当作常量，从而先去常量表中查找该常量对应的值，只有找不到的时候才会在数组内部中找。 不过这种“习惯”既不有利于性能，也不有利于程序的健壮性。因此，尽量不要使用常量作为数组的键名。 PHP 周边环境优化PHP 的周边环境 操作系统性能（光是这一个就有很多影响因素：版本、文件系统、系统软件等等） 硬盘性能 内存 / 缓存 数据库软件（数据库基于文件系统） Web 服务器 网络状况（带宽、传输介质） PHP 开销和速度排序 开销由大到小 磁盘 I/O &gt; 数据库 I/O &gt; 内存 I/O &gt; 网络 I/O。 速度由快到慢 内存 I/O &gt; 数据库 I/O &gt; 磁盘 I/O &gt; 网络 I/O。 由于数据库软件既可以从内存中读写也可以从磁盘中读写，所以其性能介于内存和磁盘之间。 读写网络数据本质也是磁盘操作（操作 socket 文件句柄），但是网络都是有延迟的，延迟带来了隐性时间浪费。 总结：尽量减少对磁盘和网络数据的操作，尤其是慢速网络接口的大数据，尽量使用内存和数据库。 数据库性能是 Web 项目性能优化的重点PHP 脚本是串行执行的，而 PHP 脚本本身的执行时间是比较短的，因此大部分时间都在等待， 尤其往往是在等待网络另一端的数据库。 由于主要的耗时在数据库，因此优化的时候重心应该在对数据库自身操作的优化，而不是单单考 虑 PHP 语言自身的问题。（关于数据库性能，详见另一篇文章） 建议：把更多的计算任务交给 PHP 而不要在数据库中进行多余的计算。 网络请求优化网络请求的特点 对方接口的不确定因素 网络是否可达 网络稳定性 数据格式是否是期望的 如何优化网络请求 设置超时时间 连接超时：200ms 读超时：800ms 写超时：500ms 可根据情况稍微增大超时时间，但是再大不能大于 1 秒。 将串行请求并行化 使用 curl_multi_*() 但是 curlmulti 扩展依赖于最慢的请求响应时间，所以尽管并行化，但是最终的等待时间仍然是所有并发请求中最慢的那一个，一旦有个响应变慢就会拖慢整个响应。 使用 swoole 扩展 swoole 是一个 php 扩展，是从 C 语言层面实现并行化。 压缩 PHP 接口输出 如何压缩：一般服务器启用 gzip 即可。 压缩的利弊：利于数据输出，减少客户端获取数据速度；缺点是会产生额外的 CPU 开销（也会使客户端产生 CPU 开销，因为要解压）。 综合考虑，当接口数据小于几十 KB 时，压缩带来的效果并不明显，甚至比以前更大但是当大于 100 KB 时， Gzip 能够压缩到 30 KB / 40 KB 左右 此外，如果数据内容中重复的数据越多，压缩效率越高，反之越不明显。 缓存重复计算内容 什么时候需要缓存内容？ 多次请求同一内容时 缓存原理 请求某个页面时，首先从缓存中查找是否存在。如果命中，则直接从缓存中返回；如果缓存中没有，则重新计算，并把计算结果保存在缓存中，最后返回给客户端。 流程优化可以将一个串行的流程分解为以下两种并行流程： 重叠时间窗口只有在后一个任务不以前一个任务为强依赖的时候才采取这种思想。 旁路方案旁路方案和重叠时间窗口是非常类似的，因此也有相同的限制条件：前后任务不具有依赖关系。 前面网络请求的复用，就是采用了重叠时间窗口的思想。 Smarty 在模版渲染的时候就采用了缓存和旁路方案。 关于 PHP 语言自身瓶颈Opcode 优化优化思路是缓存 Opcod，因为 Opcode 是 PHP 代码在执行过程中最接近与机器码的代码。 这个可用 APC 扩展解决。不过 APC 从 2012 年开始就已经不再更新了，不过可以在上面搜索 Caching 查找相关缓存类扩展方案，比如知名的 memcache/memchached、vainish、vac (@Xinchen Hui @Wei Dai[蘑菇街]）。 共享内存自认为是替代 APC 和本地 Memcache 的方案 。 PHP 的扩展实现的目标：通过扩展代替原 PHP 代码中的高频逻辑。 Runtime 优化这个目前只能用 HHVM 和 PHP 7 解决。 HHVM 是由 FaceBook 开源的技术，火了一段时间，百度也使用过该技术。 总结： PHP 的性能优化思路不仅仅局限于 PHP 层面的优化，还包括许多内容，需要综合考虑，必 要时借助工具帮助分析，找到瓶颈所在，找出解决之道。 性能分析工具ABApache Benchmark 是经常用到的压力测试工具。一般安装 Apache 服务器时会自动安装好该工具。如果没有，可以手动安装：yum install httpd-tools。 使用方式举例如下： 12345# 使用 100 次并发模拟 1000 次请求ab -n1000 -c100 https://www.myapp.com/# 在 10 秒内模拟 1000 次并发请求ab -t 10 -c 1000 https://www.myapp.com/ 需要注意的是：URL 末尾一定要带上 /，否则会提示非法 URL。 测试结果中需要关注的参数有： requests per second 每秒接受的请求数，优化的方向是越多越好，并发能力要高。 time per request 响应每次请求的毫秒数，优化的方向是越短越好，响应时间要小。 本人测试 https://caoxl/com/ 后 使得网站https失效~~ XHProfXHProf 是 Facebook 开发的 PHP 性能分析工具，以 PHP PECL 扩展的形式安装使用。 下载&amp;安装1234567891011# 下载wget http://pecl.php.net/get/xhprof-0.9.4.tgz# 解压tar zxvf xhprof-0.9.4.tgz# 编译安装（确保 php5-dev 已经安装）cd xhprof-0.9.4/extension/./configure# ./configure --with-php- config=/usr/local/php/bin/php-configmake &amp;&amp; make install 注意，在 make 过程中，如果遇到 warning 和 error，只需找到出错的文件和位置，可以尝试注释，然后重新执行：make clean &amp;&amp; make。 安装成功后会看到提示：Installing shared extensions: /usr/lib/php5/20131226/。 如果是 64 位系统，则可能需要将 xhprof.so 拷贝到相关的 lib64 目录下。 配置 &amp; 重启12345678910cd /etc/php5/fpm/conf.dvim 20-xhprof.ini extension=xhprof.so xhprof.output_dir=/var/www/html/xhprof/ # 重启/etc/init.d/php5-fpm restart# 查看是否安装 xhprof 扩展php --ri xhprof xhprof web gui详细查看：https://github.com/phacility/xhprof。 XHPorf 使用举例 cpu：xhprof_enable(XHPROF_FLAGS_CPU) 内存：xhprof_enable(XHPROF_FLAGS_MEMORY) 如果两个一起：xhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY) 123456789101112131415161718// 1. enable xhprofxhprof_enable();// 2. code to be tested hererequire '/path/to/script';// 3. disable xhprof$data = xhprof_disable(); // 返回运行数据// 4. incloude lib (xhprof_lib 在下载的包里存在这个目录, 需要将目录包含到运行的 php 代码中)include_once '/path/to/xhprof_lib/utils/xhprof_lib.php';include_once '/path/to/xhprof_lib/utils/xhprof_runs.php';$xhprofObj = new XHProfRuns_Defatult();$run_id = $xhprofObj-&gt;save_run($data, 'test'); // 第一个参数是 xhprof_disable() 函数返回的运行信息; 第二个参数是自定义的命名空间字符串(任意)// 返回运行ID, 用这个 ID 查看相关的运行结果var_dump($run_id); 请求该页面，然后打开 xhprof 的 VIEW 层展现工具就可以看到详尽的报表和流程图信息。 报表信息说明： Incl. Wall Time 代表的是流程走到这个函数的时候，当前函数的执行时间，和当前函数之后所有函数的执行时间的总微秒数。 Excl. Wall Time 一个函数的执行时间（微秒）。 一个函数的执行时间（微秒）。 展示完整的项目请求流程图，黄色、红色和粗的路线代表的是耗时较多的操作和流程。 假设找到了最耗时的文件，比如为 _import_fromheader，就可以打开源码进行排查： 12cd /path/to/projgrep 'import_from_header' 然后阅读源码进行分析，debug，之后再次重复上述操作看优化是否生效，以及决定是否继续进行优化。 vld Vulcan Logic Dumper，是一个在 Zend引擎中，以挂钩的方式实现的，用于输出 PHP 脚本生成的中间代码（Opcode，执行单元）的扩展。 它可以在一定程度上查看 Zend 引擎内部的一些实现原理，是我们学习PHP源码的必备良器。 下载&amp;&amp;安装1234567891011121314151617# Centosyum search php5-develyum install php5-devel# Or Debian# apt-get search php5-dev# apt-get install php5-devgit clone https://github.com/derickr/vld.git vld# Or# wget http://pecl.php.net/package/vld/0.13.0tar zxvf vld-0.13.0.tgzcd vld-0-13.0phpize./configuremake &amp;&amp; make install 配置 Nginx 可以通过 phpinfo() 中的 Additional.inifilesparsed 属性来找到 PHP5-FPM 读取配置文件的路径，然后创建配置文件: 1234567cd /etc/php5/fpm/conf.d/vim 20-vld.ini extension=vld.so /etc/init.d/php5-fpm restart 这里是 20 指的是优先级。extension=vld.so，指的是 PHP 会从它的默认存放扩展库路径下去加载 vld.so 这个链接库文件，当然，也可以使用绝对路径的形式加载不位于 PHP 默认存放扩展库的路径下的扩展。 注意： 由于不是对 Nginx 服务器的修改，所以执行 nginx -s reload 不起作用，因为 Nginx 是通过 FPM 去处理 PHP 请求的。 Apache 1234567cd /path/to/httpd/conf/cp /etc/php5/fpm/conf.d/20-vld.ini .//etc/init.d/apache2 restart# Or CentOSservice httpd restart suggestion： Kali 安装好之后的路径在：/usr/lib/php5/20131226。 ps aux | grep nginx find / -name vld.so CLI 下简单使用1234567891011# 执行该 PHP 代码 并输出的中间代码php -dvld.active=1 test.php# 只看输出的中间代码而不执行该 PHP 代码php -dvld.active=1 -dvld.execute=0 test.php# 输出的详细程度（最大为 3）php -dvld.active=1 -dvld.verbosity=3 t.php# 将结果输出到 .dot 文件php -dvld.active=1 -dvld.save_dir='D:\\tmp' -dvld.save_paths=1 -dvld.dump_paths=1 t.php 输出说明： Branch analysis from position：这条信息多在分析数组时使用。 Return found：是否返回，这个基本上有都有。 filename：分析的文件名 function name：函数名，针对每个函数 VLD 都会生成一段如上的独立的信息，这里显示当前函数的名称 number of ops：生成的操作数 compiled vars：编译期间的变量，这些变量是在 PHP5 后添加的，它是一个缓存优化。这样的变量在 PHP 源码中以 IS_CV 标记。 op list：生成的中间代码的变量列表 Windows 安装 VLD 扩展库 下载 http://pecl.php.net/package/vld 注意，要根据 phpinfo() 中显示的是否线程安全下载相应的位数和版本(x64/TS/5.6)，然后解压其中的 php_vld.dll 文件到 /path/to/php/ext/ 下面。 修改配置文件 编辑：/path/to/php/php.ini。 找到 Windows Extensions 然后再后面添加如下语句引入 vld 扩展即可extension=php_vld.dll 重启 Apache 刷新 phpinfo()，然后搜索是否已经引入 vld 扩展。 在 Linux 中配置文件的惯用思路并不是像在 Windows 上那样直接修改主配置文件，而往往是配置独立的配置文件，甚至是单独创建简单 的配置文件。这样的好处是基本上不用去改动主要的配置文件。 通常，Linux 中同一个配置往往拆分成多个配置文件分开管理，甚至保存在专门的文件夹下，所以不要完全照搬 Windows 的配置思路， 以官方手册为准。 XDebug详见官方手册：https://xdebug.org/docs/all。 其他实践代码层面 尽可能避免在循环中做：调用函数；创建对象；查询数据库；文件 I/O 等耗时操作 从方便查询的角度创建数据库表 从性能的角度使用数据类型 优先使用单引号 Nginx 对文档类型资源启用2级压缩 不要压缩图片和音视频 对静态资源开启缓存 Laravel 配合七牛云 public 下面只留 assets/ 和 index.php 静态的 js css imags 全部放到 assets 方便利用七牛的镜像存储 上传的东西 全部放到 storage 下面 自己新建目录 图片 为不同页面需要显示的图片做一比一的缩略图 单页引用的图片数量较多且较大（1M为界限）时 将图片放在专门的服务器 并做 CDN 加速 不要滥用图片 图标类小图使用 CSS Sprite 以减少 HTTP 请求次数 节省带宽 服务器 对服务器等配置是灵活 从需求出发的 如果用户量上升明显 =&gt; 优先增加带宽 如果服务器软件完成的事情越多 要求越高 比如压缩等级提升 =&gt; 优先升级 CPU 如果服务端程序功能复杂度提升 =&gt; 优先增加内存 请求 合并请求：减少请求数，适用于请求数可能会超过浏览器限制的情景，类似： 12345// 前端资源请求合并http://example.com/?jses=a.js,b.js,c.js,d.js,e.js// 后端数据接口请求合并http://api.com?click=/click?k=1&amp;b=2&amp;answer=/answer/count?id=5&amp;topic=/topic/5&amp;tags=/tag?tid=10&amp;user=/u/5 其他经验 没有用的全部删掉 在针对资源（文件／网络／数据库等）的操作时，一定要进行异常处理。 参考 VLD扩展使用指南 深入理解PHP代码的执行的过程","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"优化","slug":"优化","permalink":"http://blog.caoxl.com/tags/优化/"}]},{"title":"Nginx 「通用日志」","slug":"Nginx-Dev-Notes","date":"2018-01-24T08:30:25.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/24/Nginx-Dev-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/Nginx-Dev-Notes/","excerpt":"Nginx 能做的事实在太多，先遇到什么记录下什么吧。 和本博客其他很多汇总性日志一样，本文内容也会不定期更新。 http://nginx.org/en/docs/","text":"Nginx 能做的事实在太多，先遇到什么记录下什么吧。 和本博客其他很多汇总性日志一样，本文内容也会不定期更新。 http://nginx.org/en/docs/ 泛域名配置自动关联子域名到目录名123456server &#123; # ... server_name ~^(?&lt;subdomain&gt;.+).example.com$; root /data/wwwroot/example.com/$subdomain; # ...&#125; 如果 nginx 后面是 PHP，只是这样配置会出现 $_SERVER[&#39;host&#39;] 一字不差的为 ~^(?&lt;subdomain&gt;.+).example.com$，因此还需要添加一个 fastcgi_param 的 SERVER_NAME 配置： 1234567location ~ [^/]\\.php(/|$) &#123; #fastcgi_pass remote_php_ip:9000; fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; fastcgi_param SERVER_NAME $host; # 重新赋值 SERVER_NAME 参数覆盖前面 `server_name` 的初始定义&#125; 安全IP 访问频率限制1234567891011121314151617181920212223242526272829geo $whitelist &#123; default 0; # CIDR in the list below are not limited 1.2.3.0/24 1; 9.10.11.12/32 1; 127.0.0.1/32 1;&#125;map $whitelist $limit &#123; 0 $binary_remote_addr; 1 \"\";&#125;# 2. The directives below limit concurrent connections from a # non-whitelisted IP address to fivelimit_conn_zone $limit zone=connlimit:10m;limit_conn connlimit 5;limit_conn_log_level warn; # logging level when threshold exceededlimit_conn_status 503; # the error code to return# 3. Limits the number requests from a non-whitelisted IP to# one every two seconds with up to 3 requests per IP delayed# until the average time between responses reaches the threshold. # Further requests over and above this limit will result # in an immediate 503 errorlimit_req_zone $limit zone=one:10m rate=30r/m;limit_req zone=one burst=3; # burst =&gt; 超过请求频率限制后最多允许多少次强制性访问limit_req_log_level warn;limit_req_status 503; 配置好后可以简单通过命令来测试结果：ab -n 5000 -c 100 http://www.example.com/，会显示绝大部分请求均返回 503。 注 ab是做压力测试的一种方法,如果显示没有这个命令,运行 1yum install httpd-tools 配置说明： geo 定义了白名单 $whitelist：默认值为 0；如果请求 IP 与白名单中的 IP 匹配，则$whitelist 值为 1 map 指令是将 $whitelist 值为 0 的，也就是受限制的 IP，映射为请求 IP。将 $whitelist 值为 1 的，也就是白名单 IP，映射为空的字符串。 limit_conn_zone 和 limit_req_zone 将忽略键值为空请求 IP，从而实现对白名单中的 IP 不限制而对其他 IP 做限制。 设置 nginx 密码认证1234location /path &#123; auth_basic \"Restricted\"; auth_basic_user_file /path/to/nginx/.htpasswd;&#125; IP 黑／白名单1234location /path &#123; allow whitelist; # whitelist 事先定义过 deny all;&#125; 被 deny 掉的 IP 会得到 403 状态码。可以制定一个拒绝访问的页面： 123456789location / &#123; error_page 403 = @deny; allow whitelist; deny all;&#125;localtion @deny &#123; return 301 http://site.com/cominglater;&#125; allow 和 deny 的顺序问题 先 allow 部分后 deny all，表示只允许部分 IP 访问 先 deny all 后 allow 部分，表示拒绝全部 禁止指定 IP 或 IP 段12345678910# /path/to/blacklist.ipdeny 192.168.33.111;deny 192.168.44.222;deny 192.168.55.0/24; # 禁止 192.168.10.1~192.168.10.254--------------------------# /path/to/nginx.confinclude /path/to/blacklist.ip # 绝对路径# include blacklist.ip # 相对于 nginx.conf 路径 限制特定目录访问123localtion ~ .*(config|cache)/.*\\.php$ &#123; deny all;&#125; 限制 UA12345location / &#123; if ($http_user_agent ~ * 'ApacheBench|bingbot/2.0|Spider/3.0') &#123; return 403; &#125;&#125; Rewrite 规则别忘了限制条件123if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php last;&#125; 如果不在限制条件下使用 rewrite 规则，容易造成死循环。 HTTP 重定向到 HTTPS 123456server &#123; listen 80; server_name www.example.com; rewrite ^/(.*) https://$server_name$1 permanent; # 301 # rewrite ^/(.*) https://$server_name$1 redirect; # 302&#125; PHP 项目常用 rewrite 规则 Laravel 123location / &#123; try_files $uri $uri/ /index.php?$query_string;&#125; 禅道项目管理系统 123456789101112131415161718server &#123; listen 80; server_name zentao.example.com; access_log /data/wwwlogs/zentao.example.com_nginx.log combined; index index.html index.htm index.php; root /data/wwwroot/zentao.example.com/www; charset utf-8; location / &#123; try_files $uri /index.php$uri; &#125; location ~ \\.php(/.+)?$ &#123; fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_param PATH_INFO $fastcgi_path_info; &#125;&#125; 日志配置关闭对 favicon 和 robot.txt 的日志记录12345678location = /favicon.ico &#123; access_log off; log_not_found off;&#125;location = /robot.txt &#123; access_log off; log_not_found off;&#125; 只记录特定状态的访问日志1234567891011121314151617181920http &#123; map $status $normal &#123; ~^2 1; default 0; &#125; map $status $abnormal &#123; ~^2 0; default 1; &#125; map $remote_addr $islocal &#123; ~^127 1; default 0; &#125; server &#123; access_log logs/access.log combined if=$normal; access_log logs/access_abnormal.log combined if=$abnormal; access_log logs/access_local.log combined if=$islocal; &#125; &#125; With PHPnginx 与 fastcgi／php-fpm 之间的关系 Nginx：Web 服务器。 FastCGI：同 cgi 一样只是一个协议，负责规范 Web 应用程序和 Web 服务器的连接，规定了传递给 PHP 等动态程序的有哪些参数以及通过什么形式传递。 php-fpm：PHP 官方采纳并使用的，实现了 FastCGI 协议的进程管理器，负责管理和调度 php-cgi 进程。 这里的「Web 应用程序」指的是 PHP 开放的应用程序，虽然我们常说 PHP 服务器后端开发，但是站在 Nginx 角度，PHP 开发的后端程序依然是应用程序的范畴。 HTTP 请求到达服务器之后，首先经过专门的 Web 服务器，然后 Web 服务器会将该请求简单处理后将按照 CGI／FastCGI 规定的标准数据格式交给 PHP-FPM 处理。 php-fpm 的安装，旧版本 PHP 中需要下载对应 PHP 版本的 php-fpm 源码以内核补丁的形式编译到 PHP 中，PHP 5.4 之后 PHP 核心已内置 php-fpm，只需在安装的时候启用 --enable-fpm 就行了。 nginx+fpm 高并发优化思路 启用 opcache（no zend guard loader） nginx 和 fpm 的通信方式使用 UNIX socket 替换 TCP 端口 123fastcgi_pass 127.0.0.1:9000;# 换为：fastcgi_pass unix:/dev/shm/php-fpm.sock; 其中，/dev/shm/php-fpm.sock 是在 php-fpm.conf 中配置的。 优化 Linux 内核参数 修改 /etc/sysctl.conf（_/proc/sys/net/core/_somaxconn）后使用 sysctl -p 重启： 123net.ipv4.tcp_max_syn_backlog = 16384net.core.netdev_max_backlog = 16384 net.core.somaxconn = 2048 优化 php-fpm 参数 12listen.backlog = 8192; ; 默认为 -1（由系统决定）listen 80 backlog = 8192; ; 默认为 511 反向代理1234567891011121314upstream service_a &#123; server 10.10.10.100:80; server 10.10.10.200:80;&#125;server &#123; listen 80; server_name _; location / &#123; proxy_pass http://service_a/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; FAQ客户端获得 403 原因 “403” is actually an HTTP status code that means that the web server has received and understood your request, but that it cannot take any further action. 客户端访问目录而 autoindex 设置成 off。 由于安全原因，目录索引默认是关闭的。打开方式： 1234location /path &#123; autoindex on; autoindex_exact_size_off;&#125; autoindx 必须出现在 location 块中。 客户端访问了只能在服务端内部访问的资源。 nginx 无需要的网站路径权限 文件要被能 nginx read，目录要能被 nginx execute。 目录索引文件未定义 以 PHP 为例，如果只定义 index index.html index.htm 则 nginx 会直接返回 403 而无论是否真实存在 index.php。 索引定义的文件名大小写弄错 index 指令使大小写区分的，如果 index.php 错写成 Index.php 依然会出现 403. nginx 屏蔽了指定的客户端／IP，通常通过 deny 等指令设置。 参考 Module ngx_http_limit_conn_module How to rate-limit in nginx, but including/excluding certain IP addresses? nginx定制header返回信息模块ngx_headers_more Nginx下禅道的伪静态(rewrite)规则 Nginx Access Log日志统计分析常用命令 nginx防止DDOS攻击配置（2） How to Secure Nginx Using Fail2ban on Centos-7] nginx通过云负载均衡后作反向代理并限制制定ip访问 IP.cn - 每日中国大陆 IP 列表, 电信 IP 列表，联通 IP 列表，移动 IP 列表","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"http://blog.caoxl.com/tags/配置/"}]},{"title":"Crontab Is So Easy","slug":"Crontab-Is-So-Easy","date":"2018-01-24T08:12:57.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/24/Crontab-Is-So-Easy/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/Crontab-Is-So-Easy/","excerpt":"Crontab是一个Unix/Linux系统下的常用的定时执行工具，可以在无需人工干预的情况下运行指定作业。","text":"Crontab是一个Unix/Linux系统下的常用的定时执行工具，可以在无需人工干预的情况下运行指定作业。 安装CentOS下 安装Crontab1234yum install vixie-cron crontabs //安装Crontabchkconfig crond on //设为开机自启动service crond start //启动 说明： vixie-cron软件包是cron的主程序；crontabs软件包是用来安装、卸装、 或列举用来驱动 cron 守护进程的表格的程序。 Debian下 安装Crontab123apt-get install cron //大部分情况下Debian都已安装。/etc/init.d/cron restart //重启Crontab 使用方法查看crontab定时执行任务列表1crontab -l 添加crontab定时执行任务1crontab -e 输入crontab任务命令时可能会因为crontab默认编辑器的不同。 如上图所示为 nano编辑器，使用比较简单，直接在文件末尾按crontab命令格式输入即可，Ctrl+x退出，再输y 回车保存。 另外一种是vi编辑器，首先按i键，在文件末尾按crontab命令格式输入，再按ESC键，再输入:wq 回车即可。 crontab 任务命令书写格式123格式： minute hour dayofmonth month dayofweek command解释： 分钟 小时 日期 月付 周 命令范围： 0-59 0～23 1～31 1～12 0～7，0和7都代表周日 在crontab中我们会经常用到* , - /n这4个符号，好吧还是再画个表格，更清楚些： 符号 解释 *(星号) 代表所有有效的值。 如：0 23 * backup 不论几月几日周几的23点整都执行backup命令。 ,(逗号) 代表分割开多个值。如：30 9 1,16,20 command 每月的1、16、20号9点30分执行command命令。 -(减号) 代表一段时间范围。如0 9-17 * checkmail 每天9点到17点的整点执行checkmail命令 /n 代表每隔n长时间。如 /5 * check 每隔5分钟执行一次check命令，与0-59/5一样。 下面举一些例子来加深理解： 123456789每天凌晨3:00执行备份程序：0 3 * * * /root/backup.sh每周日8点30分执行日志清理程序：30 8 * * 7 /root/clear.sh每周1周5 0点整执行test程序：0 0 * * 1,5 test每年的5月12日14点执行wenchuan程序：0 14 12 5 * /root/wenchuan每晚18点到23点每15分钟重启一次php-fpm：*/15 18-23 * * * /etc/init.d/php-fpm 参考 Linux VPS/服务器上用Crontab来定时执行实现VPS自动化 nano编辑器使用教程","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Linx","slug":"Linx","permalink":"http://blog.caoxl.com/tags/Linx/"},{"name":"Crontab","slug":"Crontab","permalink":"http://blog.caoxl.com/tags/Crontab/"}]},{"title":"LNMP 配置教程","slug":"LNMP-How-To-Add-Vhost","date":"2018-01-24T07:27:40.000Z","updated":"2019-08-22T03:47:42.000Z","comments":true,"path":"2018/01/24/LNMP-How-To-Add-Vhost/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/LNMP-How-To-Add-Vhost/","excerpt":"由于本人比较懒,使用LNMP搭建的个人网站,所以有必要写一下LNMP配置文档","text":"由于本人比较懒,使用LNMP搭建的个人网站,所以有必要写一下LNMP配置文档 版本差异一般情况下每个虚拟主机就是一个网站，网站一般通过域名进行访问。本文为教程适合LNMP 1.2+，各个版本的添加过程基本类似，按提示操作即可。1.4版添加了SSL选项可以选择Letsencrypt和自备SSL证书，多PHP版本选择等功能。1.3版增加了FTP和数据库的创建等。LNMP 1.4的跨目录同时增加在fastcgi.conf中进行管控，LNMP1.2的防跨目录也由原来在php.ini中设置移至网站根目录下的.user.ini 进行控制。 LNMP 1.1及之前的版本采用/root/vhost.sh 进行添加虚拟主机。 LNMP 1.2开始使用lnmp命令进行管理，具体可以参看更新记录 之前版本的LNMP都可以升级到新版的lnmp管理脚本，升级到1.4教程 网站搭建添加网站(虚拟主机)如果输入有错误需要删除时，可以按住Ctrl再按Backspace [←]键进行删除。 执行：lnmp vhost add 出现如下界面： 这里要输入要添加网站的域名，我们已添加www.vpser.net域名为例，如上图提示后输入域名 www.vpser.net 回车后提示 这里询问是否添加更多域名，直接再输入要绑定的域名，这里我们将 vpser.net 也绑上，多个域名空格隔开，如不需要绑其他域名就直接回车。 (注：带www和不带www的是不同的域名，如需带www和不带的www的域名都访问同一个网站需要同时都绑定)。 下面需要设置网站的目录 网站目录不存在的话会创建目录。也可以输入已经存在的目录或要设置的目录（注意如要输入必须是全路径即以/开头的完整路径！！！）。不输入直接回车的话，采用默认目录：/home/wwwroot/ 域名 伪静态可以使URL更加简洁也利于SEO，如程序支持并且需要设置伪静态的话，如启用输入 y ，不启用输入 n 回车(注意LNMPA或LAMP模式没有该选择项！)。 默认已经有了discuz、discuzx、discuzx2(Discuz X二级目录)、wordpress、wp2(WordPress二级目录)、typecho、typecho2(Typecho二级目录)、sablog、emlog、dabr、phpwind、、dedecms、drupal、ecshop、shopex等常用的Nginx伪静态配置文件，可以直接输入名称进行使用，如果是二级目录则需要对应配置文件里的二级目录的名称。 这一步是设置日志，如启用日志输入 y ，不启用输入 n 回车。 如果启用需要再输入要设置的日志的名称，默认日志目录为：/home/wwwlogs/ 默认文件名为：域名.log 回车确认后，会询问是否添加数据库和数据库用户。 如果需要添加数据库输入 y ，不添加数据库输入 n 回车。 如果要添加，需要先验证MySQL的 root 密码(注：输入密码将不显示)提示 Enter database name: 后输入要创建的数据库名称，要创建的数据库用户名会和数据库同名，回车确认。 提示 Please enter password for mysql user 数据库名: 后输入要设置的密码，回车确认。 如果安装了FTP服务器会询问是否添加FTP账号 如果需要添加输入 y ，不添加输入 n 回车。 提示Enter ftp account name: 后输入要创建的FTP账号名称，回车确认。提示Enter password for ftp account FTP账号: 后输入要设置的密码，回车确认。 接下来是1.4新增的添加SSL功能 如果需要添加输入 y ，不添加输入 n 回车。选择了添加SSL会提示 有两个选项 1 选项为使用自己准备好的SSL证书和key。 提示Please enter full path to SSL Certificate file 后输入要SSL证书的完整路径和文件名，回车确认。提示Please enter full path to SSL Certificate Key file: 后输入输入要key文件的完整路径和文件名，回车确认。 2 选项为使用免费SSL证书提供商Letsencrypt的证书，自动生成SSL证书等信息。 需要输入一个邮箱回车确认。 提示 Press any key to start create virtul host... 后，回车确认便会开始创建虚拟主机。 添加成功会提示添加的域名、目录、伪静态、日志、数据库、FTP等相关信息，如下图： 列出网站(虚拟主机)执行：lnmp vhost list 删除网站(虚拟主机)执行：lnmp vhost del 删除网站会先列出当前已有虚拟主机，按提示输入要删除的虚拟主机域名 回车确认。 这里只是删除虚拟主机配置文件，网站文件并不会删除需要自己删除。LNMP 1.2下需要执行：chattr -i /网站目录/.user.ini 后才能删除网站目录。 当执行chown或chmod对网站目录属主属组或权限进行操作时可能会提示chown: changing ownership of/home/wwwroot/default/.user.ini’: Operation not permitted，**不需要理会**，如果有强迫症可以参考前面先进行chattr -i`的操作。 配置文件(虚拟主机) LNMP默认网站配置文件：/usr/local/nginx/conf/nginx.conf LNMPA默认网站配置文件：/usr/local/nginx/conf/nginx.conf 和 /usr/local/apache/conf/extra/httpd-vhosts.conf LAMP默认网站配置文件：/usr/local/apache/conf/extra/httpd-vhosts.conf 网站优化伪静态管理LNMPA或LAMP可以直接使用网站根目录下放.htaccess 来设置伪静态规则(具体规则可以去程序官网网站找google百度)， 但是在LNMP下，需要使用Nginx伪静态规则。 伪静态可以随时添加或删除，如果添加完虚拟主机后忘记或没有添加伪静态，可以通过修改配置文件来添加伪静态。虚拟主机配置文件在：/usr/local/nginx/conf/vhost/域名.conf 如: /usr/local/nginx/conf/vhost/caoxl.com.conf 伪静态规则文件需要放在 /usr/local/nginx/conf/ 下面。编辑虚拟主机配置文件，可以使用 vi、nano或winscp，后2个工具对新手来说简单些。 例如前面我们添加的虚拟主机，打开后前半部分配置会显示如下： 在root /home/wwwroot/www.vpser.net;这一行下面添加： 1include wordpress.conf; 上面的wordpress.conf为伪静态文件，如需要其他伪静态文件自己创建个并上传到/usr/local/nginx/conf/ 下面并include 伪静态.conf; 加完保存，执行：/etc/init.d/nginx restart 重启生效，如果报错可能是添加有误或伪静态规则有误。 上传网站程序如果已经 安装FTP服务器可以直接使用ftp客户端通过你的FTP信息登录后上传网站或sftp等软件上传网站，设置好相关权限开始安装即可。 上传网站后建议执行：chown www:www -R /path/to/dir 对网站目录进行权限设置，/path/to/dir替换为你网站目录。为了安全可以将一些不需要PHP运行的上传文件之类的目录去掉执行权限，参考：http://www.vpser.net/security/lnmp-remove-nginx-php-execute.html 添加ssl证书开启https对于已存在的虚拟主机添加https站点，可以执行：lnmp ssl add 命令添加ssl证书 目前有两种方式:一种是使用自备的ssl证书，二是采用Let’s Encrypt的免费证书。 添加过程和前面的添加虚拟主机的过程是一样的，只是会多一项填写ssl证书和key的步骤或直接选择Let’sEncrypt自动生成证书。 防跨目录设置LNMP 1.1及之前的版本使用php.ini里面，open_basedir设置 LNMP 1.2及更高版本防跨目录功能使用.user.ini，该文件在网站根目录下，可以修改.user.ini 里面的open_basedir的值来设置限制访问的目录或删除来移除防跨目录的设置。 .user.ini文件无法直接修改，如要修或删除需要先执行：chattr -i /网站目录/.user.ini 可以使用winscp文件管理、vim编辑器或nano编辑器进行修改。 删除的话 rm -f /网站目录/.user.ini 就可以。修改完成后再执行：chattr +i /网站目录/.user.ini.user.ini不需要重启一般5分钟左右生效，也可以重启一下php-fpm立即生效。如果要更改网站目录必须要按上述方法修改防跨目录的设置，否则肯定报错！！ LNMP 1.4上如果不想用防跨目录或者修改.user.ini的防跨目录的目录还需要将 /usr/local/nginx/conf/fastcgi.conf 里面的 fastcgi_param PHP_ADMIN_VALUE &quot;open_basedir=$document_root/:/tmp/:/proc/&quot;; 在该行行前添加 # 或删除改行，需要重启nginx。 LNMP 1.4上也可以直接使用 lnmp1.4/tools/ 目录下的 ./remove_open_basedir_restriction.sh 进行移除。在Thinkphp、codeigniter、Laravel等框架下，网站目录一般是在public下，但是public下的程序要跨目录调用public上级目录下的文件，因为LNMP默认是不允许跨目录访问的，所以都是必须要将防跨目录访问的设置去掉，有时候这些框架类的程序提示500错误也可能是这个问题引起的。 LNMPA或LAMP 模式1.2版本以上的防跨目录的设置使用的对应apache虚拟主机配置文件（lnmp管理工具添加的话文件是 /usr/local/apache/conf/vhost/域名.conf ）里的 php_admin_value open_basedir 参数进行设置。如果不需要设置可以在前面加 # 进行注释，或自行修改目录的限制。重启apache生效。 pathinfo设置LNMP上各个版本pathinfo各个版本的设置基本一样： lnmp v1.1上，修改对应虚拟主机的配置文件(/usr/local/nginx/conf/vhost/域名.conf)去掉 #include pathinfo.conf前面的#，把try_files $uri =404; 前面加上 # 注释掉。 1.2,1.3上，修改对应虚拟主机的配置文件(/usr/local/nginx/conf/vhost/域名.conf)将include enable-php.conf;替换为include enable-php-pathinfo.conf; 修改 pathinfo 需要重启nginx生效。 数据库管理1.3以上版本，可以在添加虚拟主机时选择创建数据库，也可以单独使用 lnmp database add 按提示添加数据库，添加的用户名和数据库名是同名的。 基础命令: 添加数据库命令：lnmp database add 编辑数据库用户密码命令：lnmp database edit 删除数据库命令：lnmp database del 列出所有数据库命令：lnmp database list 其他更新Let’sEncrypt SSL证书续期规则因Let&#39;s Encrypt的certbot程序更新，参数发生些变化，可能导致SSL证书续期失败，建议8月23日前安装LNMP的用户更新一下crontab规则和lnmp管理脚本，自动更新命令： 1wget -O - http://soft.vpser.net/lnmp/ext/fix_renewssl.sh|bash 其他方法手动进行升级，执行： 1cd /tmp &amp;&amp; wget http://soft.vpser.net/lnmp/lnmp1.4.tar.gz -O lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./upgrade1.x-1.4.sh 升级lnmp管理脚本后再自行参考 crontab教程，删除原certbot的规则 LNMP/LNMPA模式添加上 10 3 */7 * * /bin/certbot renew --disable-hook-validation --renew-hook \"/etc/init.d/nginx reload\" LAMP模式添加上 10 3 */7 * * /bin/certbot renew --disable-hook-validation --renew-hook \"/etc/init.d/httpd restart\" 手动更新的话建议再执行： 1/bin/certbot renew --disable-hook-validation --renew-hook \"/etc/init.d/nginx reload\" LAMP模式执行： 1/bin/certbot renew --disable-hook-validation --renew-hook \"/etc/init.d/httpd restart\" 看一下能否正常更新。 参考 LNMP添加、删除虚拟主机及伪静态使用教程 建议用户更新Let’sEncrypt SSL证书续期规则","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/categories/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"LNMP","slug":"LNMP","permalink":"http://blog.caoxl.com/tags/LNMP/"}]},{"title":"深入理解「PHP代码」执行过程","slug":"Deep-Understand-PHP-Code-Execution-Process","date":"2018-01-24T03:31:10.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/24/Deep-Understand-PHP-Code-Execution-Process/","link":"","permalink":"http://blog.caoxl.com/2018/01/24/Deep-Understand-PHP-Code-Execution-Process/","excerpt":"前言语言是人们进行沟通和交流的表达符号，每种语言都有专属于自己的符号，表达方式和规则。 就编程语言来说，它也是由特定的符号，特定的表达方式和规则组成。语言的作用是沟通，不管是自然语言，还是编程语言，它们的区别在于自然语言是人与人之间沟通的工具， 而编程语言是人与机器之间的沟通渠道。","text":"前言语言是人们进行沟通和交流的表达符号，每种语言都有专属于自己的符号，表达方式和规则。 就编程语言来说，它也是由特定的符号，特定的表达方式和规则组成。语言的作用是沟通，不管是自然语言，还是编程语言，它们的区别在于自然语言是人与人之间沟通的工具， 而编程语言是人与机器之间的沟通渠道。 就PHP语言来说，它也是一组符合一定规则的约定的指令。 在编程人员将自己的想法以PHP语言实现后，通过PHP的虚拟机（确切的来说应该是PHP的语言引擎Zend）将这些PHP指令转变成C语言 （可以理解为更底层的一种指令集）指令，而C语言又会转变成汇编语言， 最后汇编语言将根据处理器的规则转变成机器码执行。这是一个更高层次抽象的不断具体化，不断细化的过程。 从一种语言到另一种语言的转化称之为编译，这两种语言分别可以称之为源语言和目标语言。 这种编译过程通过发生在目标语言比源语言更低级（或者说更底层）。 语言转化的编译过程是由编译器来完成， 编码器通常被分为一系列的过程：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成等。 前面几个阶段（词法分析、语法分析和语义分析）的作用是分析源程序，我们可以称之为编译器的前端。 后面的几个阶段（中间代码生成、代码优化和目标代码生成）的作用是构造目标程序，我们可以称之为编译器的后端。 一种语言被称为编译类语言，一般是由于在程序执行之前有一个翻译的过程， 其中关键点是有一个形式上完全不同的等价程序生成。 而PHP之所以被称为解释类语言，就是因为并没有这样的一个程序生成， 它生成的是中间代码Opcode，这只是PHP的一种内部数据结构。 实话实说, 这篇文章是我转载的,只是感觉写的好牛逼~(因为我看不懂),所以自己重新排版了下,以便以后自己能力提升了回来再看看. PHP代码的执行的过程比如我们写一个简单的程序 12345&lt;?php echo \"Hello World!\"; $a = 1 + 1; echo $a;?&gt; 这个简单的程序他执行过程是怎样的呢？其实，执行过程也正如我们前面所说分为4个步骤。（这里只是指PHP语言引擎Zend执行过程，不包含Web服务器的执行过程。） 12341.`Scanning(Lexing)` ,将PHP代码转换为语言片段(Tokens)2.`Parsing`, 将Tokens转换成简单而有意义的表达式3.`Compilation`, 将表达式编译成Opocdes4.`Execution`, 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能。 注: Opcode是一种PHP脚本编译后的中间语言，就像Java的ByteCode,或者.NET的MSL 现在有的Cache比如APC,可以使得PHP缓存住Opcodes，这样，每次有请求来临的时候，就不需要重复执行前面3步，从而能大幅的提高PHP的执行速度。 Scanning（Lexing）,将PHP代码转换为语言片段（Tokens）那什么是Lexing? 学过编译原理的同学都应该对编译原理中的词法分析步骤有所了解，Lex就是一个词法分析的依据表。 对于PHP在开始使用的是Flex，之后改为re2c， MySQL的词法分析使用的Flex，除此之外还有作为UNIX系统标准词法分析器的Lex等。 这些工具都会读进一个代表词法分析器规则的输入字符串流，然后输出以C语言实做的词法分析器源代码。 这里我们只介绍PHP的现版词法分析器，re2c。 在源码目录下的 Zend/zend_language_scanner.l 文件是re2c的规则文件， 如果需要修改该规则文件需要安装re2c才能重新编译，生成新的规则文件。Zend/zend_language_scanner.c会根据Zend/zend_language_scanner.l,来输入的 PHP代码进行词法分析，从而得到一个一个的“词”。 从PHP4.2开始提供了一个函数叫token_get_all,这个函数就可以将一段PHP代码 Scanning成Tokens； 我们用下面的代码使用token_get_all函数处理我们开头提到的PHP代码。 123456789101112131415161718192021&lt;?phpecho '&lt;pre/&gt;';$code = &lt;&lt;&lt; STR &lt;?php echo \"Hello World!\"; $a = 1 + 1; echo $a; ?&gt;STR; //$tokens = token_get_all($code); //print_r($tokens);die; $tokens = token_get_all($code); foreach ($tokens as $key =&gt; $token) &#123; $tokens[$key][0] = token_name($token[0]); &#125; print_r($tokens);?&gt; 注： 为了便于理解和查看，我使用token_name函数将解析器代号修改成了符号名称说明。 如果有的童鞋想要看原始的，可以将上面代码中的代码注释去掉 解释器代号列表详见：解析器代号列表 得到的结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129Array( [0] =&gt; Array ( [0] =&gt; T_INLINE_HTML [1] =&gt; [2] =&gt; 1 ) [1] =&gt; Array ( [0] =&gt; T_OPEN_TAG [1] =&gt; 1 ) [2] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 2 ) [3] =&gt; Array ( [0] =&gt; T_ECHO [1] =&gt; echo [2] =&gt; 2 ) [4] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 2 ) [5] =&gt; Array ( [0] =&gt; T_CONSTANT_ENCAPSED_STRING [1] =&gt; \"Hello World!\" [2] =&gt; 2 ) [6] =&gt; [7] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 2 ) [8] =&gt; [9] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 3 ) [10] =&gt; Array ( [0] =&gt; T_LNUMBER [1] =&gt; 1 [2] =&gt; 3 ) [11] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 3 ) [12] =&gt; [13] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 3 ) [14] =&gt; Array ( [0] =&gt; T_LNUMBER [1] =&gt; 1 [2] =&gt; 3 ) [15] =&gt; [16] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 3 ) [17] =&gt; Array ( [0] =&gt; T_ECHO [1] =&gt; echo [2] =&gt; 4 ) [18] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 4 ) [19] =&gt; [20] =&gt; Array ( [0] =&gt; T_WHITESPACE [1] =&gt; [2] =&gt; 4 ) [21] =&gt; Array ( [0] =&gt; T_CLOSE_TAG [1] =&gt; ?&gt; [2] =&gt; 5 )) 分析这个返回结果我们可以发现，源码中的字符串，字符，空格都会原样返回。 每个源代码中的字符，都会出现在相应的顺序处。 而其他的，比如标签，操作符，语句，都会被转换成一个包含三部分的 1、Token ID解释器代号 (也就是在Zend内部的改Token的对应码，比如:T_ECHO,T_STRING) 2、源码中的原来的内容 3、该词在源码中是第几行。 Parsing, 将Tokens转换成简单而有意义的表达式接下来，就是Parsing阶段了，Parsing首先会丢弃Tokens Array中的多余的空格， 然后将剩余的Tokens转换成一个一个的简单的表达式 1234567echo a constant stringadd two numbers togetherstore the result of the prior expression to a variableecho a variable Bison是一种通用目的的分析器生成器。它将LALR(1)上下文无关文法的描述转化成分析该文法的C程序。 使用它可以生成解释器，编译器，协议实现等多种程序。 Bison向上兼容Yacc，所有书写正确的Yacc语法都应该可以不加修改地在Bison下工作。 它不但与Yacc兼容还具有许多Yacc不具备的特性。 Bison分析器文件是定义了名为yyparse并且实现了某个语法的函数的C代码。 这个函数并不是一个可以完成所有的语法分析任务的C程序。 除此这外我们还必须提供额外的一些函数： 如词法分析器、分析器报告错误时调用的错误报告函数等等。 我们知道一个完整的C程序必须以名为main的函数开头，如果我们要生成一个可执行文件，并且要运行语法解析器， 那么我们就需要有main函数，并且在某个地方直接或间接调用yyparse，否则语法分析器永远都不会运行。 在PHP源码中，词法分析器的最终是调用re2c规则定义的lex_scan函数，而提供给Bison的函数则为zendlex。 而yyparse被zendparse代替。 Compilation, 将表达式编译成Opocdes之后就是Compilation阶段了，它会把Tokens编译成一个个op_array, 每个op_arrayd包含如下5个部分 在PHP实现内部，opcode由如下的结构体表如下： 123456789struct _zend_op &#123;opcode_handler_t handler; // 执行该opcode时调用的处理函数znode result;znode op1;znode op2;ulong extended_value;uint lineno;zend_uchar opcode; // opcode代码&#125;; 和CPU的指令类似，有一个标示指令的opcode字段，以及这个opcode所操作的操作数。 PHP不像汇编那么底层， 在脚本实际执行的时候可能还需要其他更多的信息，extended_value字段就保存了这类信息。 其中的result域则是保存该指令执行完成后的结果。 PHP脚本编译为opcode保存在op_array中，其内部存储的结构如下： 123456789101112131415161718192021struct _zend_op_array &#123; /* Common elements */ zend_uchar type; char *function_name; // 如果是用户定义的函数则，这里将保存函数的名字 zend_class_entry *scope; zend_uint fn_flags; union _zend_function *prototype; zend_uint num_args; zend_uint required_num_args; zend_arg_info *arg_info; zend_bool pass_rest_by_reference; unsigned char return_reference; /* END of common elements */ zend_bool done_pass_two; zend_uint *refcount; zend_op *opcodes; // opcode数组 zend_uint last，size; zend_compiled_variable *vars; int last_var，size_var; // ...&#125; 如上面的注释，opcodes保存在这里，在执行的时候由下面的execute函数执行： 1234ZEND_API void execute(zend_op_array *op_array TSRMLS_DC)&#123; // ... 循环执行op_array中的opcode或者执行其他op_array中的opcode&#125; 前面提到每条opcode都有一个opcode_handler_t的函数指针字段，用于执行该opcode。 PHP有三种方式来进行opcode的处理:CALL，SWITCH和GOTO。 PHP默认使用CALL的方式，也就是函数调用的方式， 由于opcode执行是每个PHP程序频繁需要进行的操作， 可以使用SWITCH或者GOTO的方式来分发， 通常GOTO的效率相对会高一些， 不过效率是否提高依赖于不同的CPU。 在我们上面的例子中，我们的PHP代码会被Parsing成: 12345* ZEND_ECHO 'Hello World%21'* ZEND_ADD ~0 1 1* ZEND_ASSIGN !0 ~0* ZEND_ECHO !0* ZEND_RETURN 1 你可能会问了，我们的$a去那里了？这个要介绍操作数了，每个操作数都是由以下俩个部分组成： 123a)op_type : 为IS_CONST, IS_TMP_VAR, IS_VAR, IS_UNUSED, or IS_CV b)u,一个联合体，根据op_type的不同，分别用不同的类型保存了这个操作数的值(const)或者左值(var) 而对于var来说，每个var也不一样 IS_TMP_VAR, 顾名思义，这个是一个临时变量，保存一些op_array的结果，以便接下来的op_array使用， 这种的操作数的u保存着一个指向变量表的一个句柄（整数），这种操作数一般用~开头。 比如~0,表示变量表的0号未知的临时变量 IS_VAR 这种就是我们一般意义上的变量了,他们以$开头表示 IS_CV 表示 ZE2.1/PHP5.1 以后的编译器使用的一种cache机制， 这种变量保存着被它引用的变量的地址，当一个变量第一次被引用的时候，就会被CV起来， 以后对这个变量的引用就不需要再次去查找active符号表了，CV变量以！开头表示。 这么看来，我们的$a被优化成!0了 比如我们使用VLD来查看opcodes显示如下： 从上面这个我们看到，是不是和我们之前分析的一样呢。 如上为VLD输出的PHP代码生成的中间代码的信息，说明如下： Branch analysis from position 这条信息多在分析数组时使用。 Return found 是否返回，这个基本上有都有。 filename 分析的文件名 function name 函数名，针对每个函数VLD都会生成一段如上的独立的信息，这里显示当前函数的名称 number of ops 生成的操作数 compiled vars 编译期间的变量，这些变量是在PHP5后添加的，它是一个缓存优化。 这样的变量在PHP源码中以IS_CV标记。 op list 生成的中间代码的变量列表 是不是和前面所说的一样呢。 Execution,Zend引擎顺次执行Opcodes最后一步，也就是Execution，Zend引擎 顺次执行Opcodes，每次一条，从而实现PHP脚本的功能，和机器指令运行相似。 参考 深入理解PHP内核 深入理解PHP代码的执行的过程 [这篇文章排版有些问题,估计不是原文]","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"「代码复用」PHP常用代码","slug":"PHP-Common-Code-Notes","date":"2018-01-23T09:16:54.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/23/PHP-Common-Code-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/PHP-Common-Code-Notes/","excerpt":"记录一些PHP常用方法/代码 以下方法 个人收集 转载做业务需求与本人无关~","text":"记录一些PHP常用方法/代码 以下方法 个人收集 转载做业务需求与本人无关~ 服务器相关获取服务器IP地址PHP获取服务器IP地址方法一：1234567if('/'==DIRECTORY_SEPARATOR)&#123; $server_ip=$_SERVER['SERVER_ADDR'];&#125;else&#123; $server_ip=@gethostbyname($_SERVER['SERVER_NAME']);&#125;echo $server_ip; php获取服务器ip地址方法二：12345678910111213141516171819/*** 获取服务器端IP地址 * @return string*/ function get_server_ip()&#123; if(isset($_SERVER))&#123; if($_SERVER['SERVER_ADDR'])&#123; $server_ip=$_SERVER['SERVER_ADDR']; &#125;else&#123; $server_ip=$_SERVER['LOCAL_ADDR']; &#125; &#125;else&#123; $server_ip = getenv('SERVER_ADDR'); &#125; return $server_ip;&#125; echo get_server_ip(); 获取访问用户的IP123456789101112131415161718private function getAccessUserIP()&#123; if (getenv(\"HTTP_X_FORWARDED_FOR\")) &#123; //这个提到最前面，作为优先级,nginx代理会获取到用户真实ip,发在这个环境变量上，必须要nginx配置这个环境变量HTTP_X_FORWARDED_FOR $ip = getenv(\"HTTP_X_FORWARDED_FOR\"); &#125; else if (getenv(\"REMOTE_ADDR\")) &#123; //在nginx作为反向代理的架构中，使用REMOTE_ADDR拿到的将会是反向代理的的ip，即拿到是nginx服务器的ip地址。往往表现是一个内网ip。 $ip = getenv(\"REMOTE_ADDR\"); &#125; else if ($_SERVER['REMOTE_ADDR']) &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; else if (getenv(\"HTTP_CLIENT_IP\")) &#123; //HTTP_CLIENT_IP攻击者可以伪造一个这样的头部信息，导致获取的是攻击者随意设置的ip地址。 $ip = getenv(\"HTTP_CLIENT_IP\"); &#125; else &#123; $ip = \"unknown\"; &#125; return $ip;&#125; 返回ip所在的区域 外国ip精确到国名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public function checkAccessIP()&#123; // 根据IP判断是否显示购买 header('Content-Type:text/html;charset=utf-8'); $AccessIP = $this-&gt;getAccessIP(); // 获取访问者IP地址 $CountryName = $this-&gt;getPosition($AccessIP); // 返回访问IP国家名称 //$notAllowArea = ['美国','加拿大','日本']; $AllowArea = ['中国']; if (in_array($CountryName,$AllowArea))&#123; $data = array( 'isShowButton' =&gt; '1', 'msg' =&gt; '允许访问', ); echo json_encode($data,JSON_UNESCAPED_UNICODE);exit(); &#125; else &#123; $data = array( 'isShowButton' =&gt; '0', 'msg' =&gt; '禁止访问', ); echo json_encode($data,JSON_UNESCAPED_UNICODE);exit(); &#125;&#125;//返回ip所在的区域 外国ip精确到国名protected function getPosition($ip)&#123; try &#123; $res = file_get_contents(\"http://ip.taobao.com/service/getIpInfo.php?ip=$ip\"); $res = json_decode($res,true); if ($res[ \"code\"]==0)&#123; //return $res['data'][\"country\"].$res1['data'][ \"region\"].$res1['data'][\"city\"].\"_\".$res1['data'][ \"isp\"]; return $res['data'][\"country\"]; &#125;else&#123; return \"未能获取\"; &#125; &#125;catch (Exception $e)&#123; return \"未能获取\"; &#125;&#125;private function getAccessIP()&#123; if (getenv(\"HTTP_X_FORWARDED_FOR\")) &#123; //这个提到最前面，作为优先级,nginx代理会获取到用户真实ip,发在这个环境变量上，必须要nginx配置这个环境变量HTTP_X_FORWARDED_FOR $ip = getenv(\"HTTP_X_FORWARDED_FOR\"); &#125; else if (getenv(\"REMOTE_ADDR\")) &#123; //在nginx作为反向代理的架构中，使用REMOTE_ADDR拿到的将会是反向代理的的ip，即拿到是nginx服务器的ip地址。往往表现是一个内网ip。 $ip = getenv(\"REMOTE_ADDR\"); &#125; else if ($_SERVER['REMOTE_ADDR']) &#123; $ip = $_SERVER['REMOTE_ADDR']; &#125; else if (getenv(\"HTTP_CLIENT_IP\")) &#123; //HTTP_CLIENT_IP攻击者可以伪造一个这样的头部信息，导致获取的是攻击者随意设置的ip地址。 $ip = getenv(\"HTTP_CLIENT_IP\"); &#125; else &#123; $ip = \"unknown\"; &#125; return $ip;&#125; 获取当前的域名12345678910111213&lt;?php //获取当前的域名: echo $_SERVER['SERVER_NAME']; //获取来源网址,即点击来到本页的上页网址 echo $_SERVER[\"HTTP_REFERER\"]; $_SERVER['REQUEST_URI'];//获取当前域名的后缀 $_SERVER['HTTP_HOST'];//获取当前域名 dirname(__FILE__);//获取当前文件的物理路径 dirname(__FILE__).\"/../\";//获取当前文件的上一级物理路径 ?&gt; 获取域名或主机地址 1echo $_SERVER['HTTP_HOST'].\"&lt;br /&gt;\"; 获取网页地址 1echo $_SERVER['PHP_SELF'].\"&lt;br /&gt;\"; 获取网址参数 1echo $_SERVER[\"QUERY_STRING\"].\"&lt;br /&gt;\"; 获取用户代理 1echo $_SERVER['HTTP_REFERER'].\"&lt;br /&gt;\"; 获取完整的url 12echo 'http://'.$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];echo 'http://'.$_SERVER['HTTP_HOST'].$_SERVER['PHP_SELF'].'?'.$_SERVER['QUERY_STRING']; 包含端口号的完整url 1echo 'http://'.$_SERVER['SERVER_NAME'].':'.$_SERVER[\"SERVER_PORT\"].$_SERVER[\"REQUEST_URI\"]; 只取路径 123456789101112$url='http://'.$_SERVER['SERVER_NAME'].$_SERVER[\"REQUEST_URI\"];echo dirname($url);echo 'SERVER_NAME：'.$_SERVER['SERVER_NAME']; //获取当前域名（不含端口号）echo '&lt;p&gt;'; echo 'HTTP_HOST：'.$_SERVER['HTTP_HOST'];//获取当前域名 （含端口号）echo '&lt;p&gt;'; echo 'REQUEST_URI：'.$_SERVER['REQUEST_URI'];//获取当前域名的后缀 日期相关获取日期获取本月日期：123456function getMonth($date)&#123; $firstday = date(\"Y-m-01\",strtotime($date)); $lastday = date(\"Y-m-d\",strtotime(\"$firstday +1 month -1 day\")); return array($firstday,$lastday);&#125; $firstday是月份的第一天，假如$date是2014-2这样的话，$firstday就会是2014-02-01，然后根据$firstday加一个月就是2014-03-01，再减一天就是2014-02-28 获取上月日期：123456function getlastMonthDays($date)&#123; $timestamp=strtotime($date); $firstday =date('Y-m-01',strtotime(date('Y',$timestamp).'-'.(date('m',$timestamp)-1).'-01')); $lastday =date('Y-m-d',strtotime(\"$firstday +1 month -1 day\")); return array($firstday,$lastday);&#125; 上月日期需要先获取一个时间戳，然后在月份上-1就OK了，超智能的date()会把2014-0-1这种东西转换成2013-12-01 获取下月日期：1234567891011121314function getNextMonthDays($date)&#123; $timestamp=strtotime($date); $arr=getdate($timestamp); if($arr['mon'] == 12)&#123; $year=$arr['year'] +1; $month=$arr['mon'] -11; $firstday=$year.'-0'.$month.'-01'; $lastday=date('Y-m-d',strtotime(\"$firstday +1 month -1 day\")); &#125;else&#123; $firstday=date('Y-m-01',strtotime(date('Y',$timestamp).'-'.(date('m',$timestamp)+1).'-01')); $lastday=date('Y-m-d',strtotime(\"$firstday +1 month -1 day\")); &#125; return array($firstday,$lastday);&#125; 下月日期的代码看起来比较长一点，因为date()转不了类似2014-13-01这种东西，它会直接回到1970，所以前面需要处理一下12月的问题，除了12月就直接月份+1就OK啦 计算两个时间戳之间相差的时间1234567891011121314151617181920212223242526272829303132//功能：计算两个时间戳之间相差的日时分秒//$begin_time 开始时间戳//$end_time 结束时间戳function timediff($begin_time,$end_time)&#123; if($begin_time &lt; $end_time)&#123; $starttime = $begin_time; $endtime = $end_time; &#125;else&#123; $starttime = $end_time; $endtime = $begin_time; &#125; //计算天数 $timediff = $endtime-$starttime; $days = intval($timediff/86400); //计算小时数 $remain = $timediff%86400; $hours = intval($remain/3600); //计算分钟数 $remain = $remain%3600; $mins = intval($remain/60); //计算秒数 $secs = $remain%60; $res = array(\"day\" =&gt; $days,\"hour\" =&gt; $hours,\"min\" =&gt; $mins,\"sec\" =&gt; $secs); return $res;&#125;print_r(timediff(strtotime(2016-09-12 12:00:00'),strtotime('2016-09-15 21:50:21'))); 判断是否 时间戳12345678public static function isTimestamp($timestamp): bool&#123; return ( is_integer($timestamp) &amp;&amp; ($timestamp &gt;= 0) &amp;&amp; ($timestamp &lt;= 2147472000) );&#125; :bool 是PHP7.1+ 的特性 判断是否 同一天123456789101112131415public function isSameDay($day1, $day2)&#123; if (!$day1 || !$day2) &#123; return false; &#125; $day1 = is_numeric($day1) ? date('Y-m-d H:i:s', $day1) : $day1; $day2 = is_numeric($day2) ? date('Y-m-d H:i:s', $day2) : $day2; return ( (new \\Datetime($day1))-&gt;format('Y-m-d') === (new \\Datetime($day2))-&gt;format('Y-m-d') );&#125; 距离/经纬度相关计算某个经纬度的周围某段距离的正方形的四个点123456789101112131415161718192021222324/** * 计算某个经纬度的周围某段距离的正方形的四个点 * 地球半径，平均半径为6371km * @param lng float 经度 * @param lat float 纬度 * @param distance float 该点所在圆的半径，该圆与此正方形内切，默认值为0.5千米 * @return array 正方形的四个点的经纬度坐标 */ function returnSquarePoint($lng, $lat,$distance = 0.5)&#123; $dlng = 2 * asin(sin($distance / (2 * 6371)) / cos(deg2rad($lat))); $dlng = rad2deg($dlng); $dlat = $distance/6371; $dlat = rad2deg($dlat); return array( 'left-top'=&gt;array('lat'=&gt;$lat + $dlat,'lng'=&gt;$lng-$dlng), 'right-top'=&gt;array('lat'=&gt;$lat + $dlat, 'lng'=&gt;$lng + $dlng), 'left-bottom'=&gt;array('lat'=&gt;$lat - $dlat, 'lng'=&gt;$lng - $dlng), 'right-bottom'=&gt;array('lat'=&gt;$lat - $dlat, 'lng'=&gt;$lng + $dlng) ); &#125; 返回值相关JSON123456789101112public static function jsonResp( $data, int $status = 200, bool $unicode = true) &#123; $unicode = $unicode ? JSON_UNESCAPED_UNICODE : null; $data = json_encode($data, $unicode); return response($data) -&gt;header('Content-Type', 'application/json; charset=utf-8');&#125; JSON Response12345678910111213public function jsonResponse($data)&#123; if (! headers_sent()) &#123; header('Content-Type: application/json; charset=UTF-8'); &#125; echo json_encode( $data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ); exit;&#125; 数据格式相关xmlToArray12345678public static function xmlToArray(string $xml)&#123; return json_decode(json_encode(simplexml_load_string( $xml, 'SimpleXMLElement', LIBXML_NOCDATA )), true);&#125; array2XML1234567891011121314public static function array2XML(array $array, string &amp;$xml): string&#123; foreach ($array as $key =&gt; &amp;$val) &#123; if (is_array($val)) &#123; $_xml = ''; $val = self::array2XML($val, $_xml); &#125; $xml .= \"&lt;$key&gt;$val&lt;/$key&gt;\"; &#125; unset($val); return $xml;&#125; strtodate123456789public static function strtodate($day)&#123; if (! is_numeric($day)) &#123; // Here we only need the `date` part only $day = strtotime(date('Y-m-d', strtotime($day))); &#125; return date('Y-m-d H:i:s', strtotime(date('Y-m-d', $day)));&#125; JWT 相关生成 JWT12345678910111213141516public function getJWTString($params = [])&#123; $header = base64_encode(json_encode([ 'typ' =&gt; 'JWT', 'alg' =&gt; 'SHA256', ])); $claims = [ 'exp' =&gt; __TIME+604800, // 1 week 'nbf' =&gt; __TIME, 'iat' =&gt; __TIME, ]; $payload = base64_encode(json_encode(array_merge($params, $claims))); $signature = base64_encode(hash_hmac('sha256', $header.'.'.$payload, __CFG::JWT_SECRET_KEY)); return implode('.', [$header, $payload, $signature]);&#125; issue JWT123456789101112131415161718192021222324public function issue($params = []) &#123; $header = base64_encode(json_encode([ 'typ' =&gt; 'JWT', 'alg' =&gt; 'SHA256', ])); $timestamp = time(); $claims = [ 'exp' =&gt; $timestamp+604800, // One week 'nbf' =&gt; $timestamp, 'iat' =&gt; $timestamp, ]; $payload = base64_encode(json_encode(array_merge( $params, $claims ))); $signature = base64_encode(hash_hmac( 'sha256', $header.'.'.$payload, $this-&gt;getSecureKeyOfOldSys() )); return implode('.', [$header, $payload, $signature]); &#125; check JWT1234567891011121314151617181920212223242526272829303132333435363738public function check($jwt) &#123; $jwtComponents = explode('.', $jwt); if (3 != count($jwtComponents)) &#123; return false; &#125; list($header, $payload, $signature) = $jwtComponents; if ($headerArr = json_decode(base64_decode($header), true)) &#123; if (is_array($headerArr) &amp;&amp; isset($headerArr['alg'])) &#123; $alg = strtolower($headerArr['alg']); if (in_array($alg, hash_algos())) &#123; if (base64_decode($signature) === hash_hmac( $alg, $header.'.'.$payload, $this-&gt;getSecureKeyOfOldSys()) ) &#123; $data = json_decode(base64_decode($payload), true); // Missing expire date or wrong JWT if (! isset($data['exp']) &amp;&amp; !$this-&gt;isTimestamp($data['exp']) ) &#123; return false; &#125; // JWT expired // !!! Make sure equal timezone were used both in JWT issuing and JWT checking if (time() &gt; $data['exp']) &#123; return false; &#125; return $data; &#125; &#125; &#125; &#125; return false; &#125; cURL相关HTTP1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public function http($url, $params=array(), $method='POST') &#123; if(!function_exists('curl_init'))&#123; throw new NotFoundHttpException('请安装curl扩展'); &#125; $http = curl_init(); /* Curl settings */ curl_setopt($http, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0); curl_setopt($http, CURLOPT_USERAGENT, $this-&gt;useragent); curl_setopt($http, CURLOPT_CONNECTTIMEOUT, $this-&gt;connect_timeout); curl_setopt($http, CURLOPT_TIMEOUT, $this-&gt;timeout); curl_setopt($http, CURLOPT_RETURNTRANSFER, TRUE); curl_setopt($http, CURLOPT_ENCODING, \"\"); curl_setopt($http, CURLOPT_SSL_VERIFYPEER, FALSE); curl_setopt($http, CURLOPT_HEADER, FALSE); $params = http_build_query($params); switch ($method) &#123; case 'POST': curl_setopt($http, CURLOPT_POST, TRUE); if (!empty($params)) &#123; curl_setopt($http, CURLOPT_POSTFIELDS, $params); &#125; break; case 'PUT' : curl_setopt($http, CURLOPT_PUT, true); if (!empty($params)) &#123; $url = strpos('?',$url)===false ? \"&#123;$url&#125;?&#123;$params&#125;\" : \"&#123;$url&#125;&amp;&#123;$params&#125;\"; &#125; break; case 'DELETE': curl_setopt($http, CURLOPT_CUSTOMREQUEST, 'DELETE'); if (!empty($params)) &#123; $url = strpos('?',$url)===false ? \"&#123;$url&#125;?&#123;$params&#125;\" : \"&#123;$url&#125;&amp;&#123;$params&#125;\"; &#125; break; case 'GET': curl_setopt($http, CURLOPT_CUSTOMREQUEST, 'GET'); if (!empty($params)) &#123; $url = strpos('?',$url)===false ? \"&#123;$url&#125;?&#123;$params&#125;\" : \"&#123;$url&#125;&amp;&#123;$params&#125;\"; &#125; &#125; $headers[] = \"API-ClientIP: \" . $_SERVER['REMOTE_ADDR']; curl_setopt($http, CURLOPT_URL, $url ); curl_setopt($http, CURLOPT_HTTPHEADER, $headers ); curl_setopt($http, CURLINFO_HEADER_OUT, TRUE ); $res = curl_exec($http); // 检查是否有错误发生 if(!curl_errno($http)) &#123; $info = curl_getinfo($http); &#125; curl_close($http); return $res; &#125; 模拟 POST 请求1234567891011121314151617181920212223public function postJsonApiByCurl($uri, $headers, $paramStr) &#123; $ch = curl_init(); curl_setopt_array($ch, [ CURLOPT_URL =&gt; $uri, CURLOPT_HTTPHEADER =&gt; $headers, CURLOPT_POST =&gt; true, CURLOPT_POSTFIELDS =&gt; $paramStr, CURLOPT_RETURNTRANSFER =&gt; true, ]); $res = curl_exec($ch); $errNo = curl_errno($ch); $errMsg = curl_error($ch); curl_close($ch); return [ 'errNo' =&gt; $errNo, 'errMsg' =&gt; $errMsg, 'res' =&gt; json_decode($res, true), ]; &#125; 或者: 1234567891011121314151617181920212223242526272829303132333435363738394041public function requestJsonApi( $uri, $type = 'POST', $params = [], $assoc = false ) &#123; $setOpt = [ CURLOPT_URL =&gt; $uri, CURLOPT_HTTPHEADER =&gt; [ 'Content-Type: application/json; Charset=UTF-8', ], CURLOPT_RETURNTRANSFER =&gt; true, CURLOPT_USERAGENT =&gt; 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36', CURLOPT_AUTOREFERER =&gt; true, CURLOPT_FOLLOWLOCATION =&gt; true, CURLOPT_VERBOSE =&gt; true, CURLOPT_CONNECTTIMEOUT =&gt; 10, CURLOPT_TIMEOUT =&gt; 10, CURLOPT_SSL_VERIFYPEER =&gt; false, CURLOPT_SSL_VERIFYHOST =&gt; false, ]; if ('POST' == $type) &#123; $setOpt[CURLOPT_POST] = true; $setOpt[CURLOPT_POSTFIELDS] = $params; &#125; $ch = curl_init(); curl_setopt_array($ch, $setOpt); $res = curl_exec($ch); $errNo = curl_errno($ch); $errMsg = curl_error($ch); curl_close($ch); return [ 'err' =&gt; $errNo, 'msg' =&gt; $errMsg, 'res' =&gt; json_decode($res, $assoc), ]; &#125; requestJsonApi123456789101112131415161718public function requestJsonApi( $uri, $type = 'POST', $params = [], $headers = [] ) &#123; $headers = [ 'Content-Type: application/json; Charset=UTF-8', ]; $res = $this-&gt;requestHTTPApi($uri, $type, $headers, $params); if (! $res['err']) &#123; $res['res'] = json_decode($res['res'], true); &#125; return $res; &#125; requestHTTPApi1234567891011121314151617181920212223242526272829303132333435public function requestHTTPApi( string $uri, string $type = 'GET', array $headers = [], $data ) &#123; $setOpt = [ CURLOPT_URL =&gt; $uri, CURLOPT_RETURNTRANSFER =&gt; true, ]; if ($headers) &#123; $setOpt[CURLOPT_HTTPHEADER] = $headers; &#125; if ('POST' == $type) &#123; $setOpt[CURLOPT_POST] = true; $setOpt[CURLOPT_POSTFIELDS] = $data; &#125; $ch = curl_init(); curl_setopt_array($ch, $setOpt); $res = curl_exec($ch); $errNo = curl_errno($ch); $errMsg = curl_error($ch); curl_close($ch); return [ 'err' =&gt; $errNo, 'msg' =&gt; ($errMsg ?: 'ok'), 'res' =&gt; $res, ]; &#125; 数据验证相关验证手机号码123456789public function mobileZhFormatIsWrong($mobile)&#123; // $ptn = '/^13[0-9]&#123;1&#125;[0-9]&#123;8&#125;$|'; // $ptn .= '14[1579]&#123;1&#125;[0-9]&#123;8&#125;$|'; // $ptn .= '15[0-9]&#123;1&#125;[0-9]&#123;8&#125;$|'; // $ptn .= '17[0135678]&#123;1&#125;[0-9]&#123;8&#125;$|'; // $ptn .= '18[25789]&#123;1&#125;[0-9]&#123;8&#125;$/'; return !preg_match('/^1[3-9]\\d&#123;9&#125;$/u', $mobile);&#125; 验证 HTTP_AUTHORIZATION1234567891011// Authorise in HTTP HEADER `AUTHORIZATION`public function authorise()&#123; if (! isset($_SERVER['HTTP_AUTHORIZATION']) || !is_string($_SERVER['HTTP_AUTHORIZATION']) ) &#123; return false; &#125; return $this-&gt;check($_SERVER['HTTP_AUTHORIZATION']);&#125; 其他生成交易号12345678910111213public static function tradeNo( $mid = 0, $mtype = '01', $domain = '00' ): string &#123; $domain = str_pad(($domain%42), 2, '0', STR_PAD_LEFT); $mid = str_pad(($mid%1024), 4, '0', STR_PAD_LEFT); $mtype = in_array($mtype, ['01', '02', '03']) ? $mtype : '00'; $postfix = mb_substr(microtime(), 2, 6); return date('YmdHis').$domain.$mtype.$mid.mt_rand(1000, 9999).$postfix; &#125; 计算两点骑行距离1234567891011121314151617181920212223public function getBicyclingDistanceInAmap($from, $to) &#123; if (empty(env('AMAP_KEY'))) &#123; throw new \\Exception('Missing AMAP KEY'); &#125; $key = env('AMAP_KEY'); $api = &lt;&lt;&lt; EOFhttp://restapi.amap.com/v4/direction/bicycling?origin=&#123;$from&#125;&amp;destination=&#123;$to&#125;&amp;key=&#123;$key&#125;EOF; $ret = $this-&gt;requestJsonApi($api, 'GET'); if ($ret = (isset($ret['res']) ? $ret['res'] : false)) &#123; if ($ret = (isset($ret['data']['paths'][0]) ? $ret['data']['paths'][0] : false )) &#123; if (isset($ret['distance']) &amp;&amp; is_numeric($ret['distance'])) &#123; return $ret['distance']; &#125; &#125; &#125; return false; &#125; 计算经纬度距离123456789101112131415public function getDistance($lng1, $lat1, $lng2, $lat2) &#123; //计算经纬度距离 //将角度转为狐度 $radLat1 = deg2rad($lat1);//deg2rad()函数将角度转换为弧度 $radLat2 = deg2rad($lat2); $radLng1 = deg2rad($lng1); $radLng2 = deg2rad($lng2); $a = $radLat1 - $radLat2; $b = $radLng1 - $radLng2; $s = 2 * asin( sqrt ( pow (sin($a / 2),2) + cos($radLat1) * cos($radLat2) * pow(sin($b / 2),2) ) ) * 6378.137 * 1000; $s = round($s,2); return ($s &lt; 1000) ? ( round($s, 2) . 'm') : round( intval($s / 1000).'.'.( $s % 1000), 2).'km'; &#125; 验证快钱支付12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// re-packing from kuaiqian demo for mobile public function kqPayCallbackSignVerify($params, $cert) &#123; // by rmb_demo_php @kuaiqian function kq_ck_null($kq_va, $kq_na) &#123; if ($kq_va == \"\") &#123; return $kq_va=\"\"; &#125; else &#123; return $kq_va=$kq_na.'='.$kq_va.'&amp;'; &#125; &#125; //人民币网关账号，该账号为11位人民币网关商户编号+01,该值与提交时相同。 $kq_check_all_para=kq_ck_null($params['merchantAcctId'], 'merchantAcctId'); //网关版本，固定值：v2.0,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['version'], 'version'); //语言种类，1代表中文显示，2代表英文显示。默认为1,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['language'], 'language'); //签名类型,该值为4，代表PKI加密方式,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['signType'], 'signType'); //支付方式，一般为00，代表所有的支付方式。如果是银行直连商户，该值为10,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['payType'], 'payType'); //银行代码，如果payType为00，该值为空；如果payType为10,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['bankId'], 'bankId'); //商户订单号，,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['orderId'], 'orderId'); //订单提交时间，格式：yyyyMMddHHmmss，如：20071117020101,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['orderTime'], 'orderTime'); //订单金额，金额以“分”为单位，商户测试以1分测试即可，切勿以大金额测试,该值与支付时相同。 $kq_check_all_para.=kq_ck_null($params['orderAmount'], 'orderAmount'); $kq_check_all_para.=kq_ck_null($params['bindCard'], 'bindCard'); $kq_check_all_para.=kq_ck_null($params['bindMobile'], 'bindMobile'); // 快钱交易号，商户每一笔交易都会在快钱生成一个交易号。 $kq_check_all_para.=kq_ck_null($params['dealId'], 'dealId'); //银行交易号 ，快钱交易在银行支付时对应的交易号，如果不是通过银行卡支付，则为空 $kq_check_all_para.=kq_ck_null($params['bankDealId'], 'bankDealId'); //快钱交易时间，快钱对交易进行处理的时间,格式：yyyyMMddHHmmss，如：20071117020101 $kq_check_all_para.=kq_ck_null($params['dealTime'], 'dealTime'); //商户实际支付金额 以分为单位。比方10元，提交时金额应为1000。该金额代表商户快钱账户最终收到的金额。 $kq_check_all_para.=kq_ck_null($params['payAmount'], 'payAmount'); //费用，快钱收取商户的手续费，单位为分。 $kq_check_all_para.=kq_ck_null($params['fee'], 'fee'); //扩展字段1，该值与提交时相同 $kq_check_all_para.=kq_ck_null($params['ext1'], 'ext1'); //扩展字段2，该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['ext2'], 'ext2'); //处理结果， 10支付成功，11 支付失败，00订单申请成功，01 订单申请失败 $kq_check_all_para.=kq_ck_null($params['payResult'], 'payResult'); //错误代码 ，请参照《人民币网关接口文档》最后部分的详细解释。 $kq_check_all_para.=kq_ck_null($params['errCode'], 'errCode'); $trans_body = mb_substr($kq_check_all_para, 0, mb_strlen($kq_check_all_para)-1); $MAC = base64_decode($params['signMsg']);// $fp = fopen(\"./99bill[1].cert.rsa.20140803.cer\", \"r\");// $cert = fread($fp, 8192);// fclose($fp); $pubkeyid = openssl_get_publickey($cert); return openssl_verify($trans_body, $MAC, $pubkeyid); &#125; 生成一个二维码图片12345678910public function generateQRCodeImage($content, $errorLevel = 'L', $pointSize = 10, $margin = 1)&#123; if (!class_exists('QRcode')) &#123; include_once __CORE_DIR.'libs/qrcode/phpqrcode.php'; &#125; QRcode::png($content, false, $errorLevel, $pointSize, $margin); exit;&#125; PHP 定时运行脚本1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env php&lt;?phpif ('cli' != php_sapi_name()) &#123; exit('cli only');&#125;@ini_set('display_errors', 'On');@date_default_timezone_set('Asia/Shanghai');set_time_limit(0);require(dirname(dirname(__FILE__)).'/system/home/index.php');$system = new Index('magic-shell');define('LOG_PATH', realpath(__DIR__.'/../').'/system/data/logs/');while (true) &#123; autoRunFunc(); //需要运行的方法 sleep(1);&#125;// 记录日志function log_script($filename, $content) &#123; $path = LOG_PATH.$filename.'.log'; if (file_exists(LOG_PATH) &amp;&amp; $filename &amp;&amp; $content) &#123; file_put_contents( $path, date('Y-m-d H:i:s') .' =&gt; ' .$content .PHP_EOL, FILE_APPEND ); &#125;&#125;function autoRunFunc()&#123; // do sth&#125; 参考","categories":[{"name":"代码复用","slug":"代码复用","permalink":"http://blog.caoxl.com/categories/代码复用/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Code","slug":"Code","permalink":"http://blog.caoxl.com/tags/Code/"}]},{"title":"Composer 小技巧","slug":"Composer-Skill","date":"2018-01-23T08:52:13.000Z","updated":"2019-08-22T03:28:24.000Z","comments":true,"path":"2018/01/23/Composer-Skill/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/Composer-Skill/","excerpt":"Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。 配合 Composer中文文档 使用","text":"Composer 是 PHP 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。 配合 Composer中文文档 使用 记录一些 Composer 使用小技巧 仅更新单个库只想更新某个特定的库，不想更新它的所有依赖，很简单： 1composer update foo/bar 此外，这个技巧还可以用来解决“警告信息问题”。你一定见过这样的警告信息： 12Warning: The lock file is not up to date with the latest changes in composer.json, you may be getting outdated dependencies, run update to update them. 那么我们该怎么办呢？update命令可以更新lock文件，但是如果仅仅增加了一些描述，应该是不打算更新任何库。这种情况下，只需update nothing： 1234567$ composer update nothingLoading composer repositories with package informationUpdating dependenciesNothing to install or updateWriting lock fileGenerating autoload files 这样一来，Composer不会更新库，但是会更新composer.lock。注意nothing并不是update命令的关键字。只是没有nothing 这个包导致的结果。如果你输入foobar，结果也一样如果你用的Composer版本足够新，那么你可以直接使用--lock选项： 1composer update --lock 不编辑composer.json的情况下安装库你可能会觉得每安装一个库都需要修改composer.json太麻烦，那么你可以直接使用require命令 1composer require \"foo/bar:1.0.0\" 这个方法也可以用来快速地新开一个项目。init命令有--require选项，可以自动编写composer.json：（注意我们使用-n，这样就不用回答问题） 12345678$ composer init --require=foo/bar:1.0.0 -n$ cat composer.json&#123; \"require\": &#123; \"foo/bar\": \"1.0.0\" &#125;&#125; 派生很容易初始化的时候，你试过create-project命令么？ 1composer create-project doctrine/orm path 2.2.0 这会自动克隆仓库，并检出指定的版本。克隆库的时候用这个命令很方便，不需要搜寻原始的URI了 考虑缓存，dist包优先最近一年以来的Composer会自动存档你下载的dist包。默认设置下，dist包用于加了tag的版本，例如 &quot;symfony/symfony&quot;: &quot;v2.1.4&quot;，或者是通配符或版本区间，&quot;2.1.*&quot;或&quot;&gt;=2.2,&lt;2.3-dev&quot;（如果你使用stable作为你的minimum-stability）。 dist包也可以用于诸如 dev-master 之类的分支，Github允许你下载某个git引用的压缩包。为了强制使用压缩包，而不是克隆源代码，你可以使用install和update的--prefer-dist选项。 下面是一个例子（我使用了–profile选项来显示执行时间）： 1234567891011121314151617181920212223$ composer init --require=\"twig/twig:1.*\" -n --profileMemory usage: 3.94MB (peak: 4.08MB), time: 0s$ composer install --profileLoading composer repositories with package informationInstalling dependencies - Installing twig/twig (v1.12.2) Downloading: 100%Writing lock fileGenerating autoload filesMemory usage: 10.13MB (peak: 12.65MB), time: 4.71s$ rm -rf vendor$ composer install --profileLoading composer repositories with package informationInstalling dependencies from lock file - Installing twig/twig (v1.12.2) Loading from cacheGenerating autoload filesMemory usage: 4.96MB (peak: 5.57MB), time: 0.45s 这里，twig/twig:1.12.2 的压缩包被保存在 ~/.composer/cache/files/twig/twig/1.12.2.0-v1.12.2.zip。重新安装包时直接使用。 若要修改，源代码优先当你需要修改库的时候，克隆源代码就比下载包方便了。你可以使用--prefer-source来强制选择克隆源代码。 1composer update symfony/yaml --prefer-source 接下来你可以修改文件： 12345composer status -vYou have changes in the following dependencies:/path/to/app/vendor/symfony/yaml/Symfony/Component/Yaml: M Dumper.php 当你试图更新一个修改过的库的时候，Composer会提醒你，询问是否放弃修改： 12345678$ composer updateLoading composer repositories with package informationUpdating dependencies - Updating symfony/symfony v2.2.0 (v2.2.0- =&gt; v2.2.0) The package has modified files: M Dumper.php Discard changes [y,n,v,s,?]? 其他为生产环境作准备最后提醒一下，在部署代码到生产环境的时候，别忘了优化一下自动加载： 1composer dump-autoload --optimize 安装包的时候可以同样使用 --optimize-autoloader 。不加这一选项，你可能会发现20%到25%的性能损失 参考 Composer中文文档 Composer Cheat Sheet for developers","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Composer","slug":"Composer","permalink":"http://blog.caoxl.com/tags/Composer/"}]},{"title":"接入云联惠 API「开发日志」","slug":"Access-YLH-API-In-Web-APP","date":"2018-01-23T08:21:14.000Z","updated":"2019-08-22T06:46:13.000Z","comments":true,"path":"2018/01/23/Access-YLH-API-In-Web-APP/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/Access-YLH-API-In-Web-APP/","excerpt":"云联惠授权登录完全就是模仿微信来的，比较简单，简述如下。","text":"云联惠授权登录完全就是模仿微信来的，比较简单，简述如下。 基本过程 获取 code 首先，需要引导用户去云联惠提供的 oauth2 登录入口，地址为： 1https://opentest.yunlianhui.cn/token/authorize?client_id=CLIENT_ID&amp;redirect_uri=REDIRECT_URI&amp;state=STATE&amp;response_type=code&amp;scope=SCOPE 如果用户在这个入口登录并授权之后，将会跳转到 REDIRECT_URI，并带上 GET 参数 code=XXXX&amp;state=test。 REDIRECT_URI 是我们的应用服务器提供的 URL，因此需要保存这个 code 值，用于下一步操作。 用 code 换 access_token（令牌） 12345curl --request POST \\--url https://opentest.yunlianhui.cn/token/authorize/accesstoken \\--header 'cache-control: no-cache' \\--header 'content-type: application/x-www-form-urlencoded' \\--data 'code=CODE&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET&amp;grant_type=authorization_code&amp;redirect_uri=REDIRECT_URI 注意，这里的 code 失效时间很短，因此需要尽快去换取 access_token。 用 access_token 获得用户基本信息/账户等信息 这里能获取到什么数据，首先是根据第一步获取 code 时的 scope 参数指定的。可以用 + 获得多种 scope 的信息，比如：scopte=basic_info+account_info。 其次，还有实际调用的接口来决定的，比如基本信息调用的是 /api/basic_info 接口，账户信息调用的是 /api/account_info 接口。 格式如下： 12345curl -X POST \\--url https://opentest.yunlianhui.cn/api/basic_info \\--header 'cache-control: no-cache' \\--header 'content-type: application/x-www-form-urlencoded' \\--data 'client_id=CLIENT_ID&amp;access_token=ACCESS_TOKEN&amp;timestamp=YYYY-MM-DD HH:ii:ss&amp;sign=SIGN_STRING' 或者通过 PHP 使用 cURL： 123456789101112function post(string $uri, array $headers = [], array $params = [])&#123; $ch = curl_init(); curl_setopt_array($ch, [ CURLOPT_URL =&gt; $uri, CURLOPT_HEADER =&gt; $headers, ]); $res = curl_exec($ch); curl_close($ch); return $res;&#125; 其中，这里的 sign 只需要 md5 + 转大写 就行了。如果成功则返回值如下： 1234567&#123; \"member_id\":\"FF1\", \"mobile\":\"15669714243\", \"rcm_id\":\"DD1\", \"email\":\"69524839@163.com\", \"error_code\":0&#125; FAQ 如何获得 client_id, appkey？ 设置一个回调地址（redirect_uri），技术人员给你：client_id，client_secret。 什么时候用 test 什么时候用正式？ 完成开发之后提交审核通过用正式。 完成开发之后提交审核通过用正式。 basic_info： 访问会员的基本信息，时效性为 1 个月。 account_info： 访问会员的账户信息，时效性为 1 个月。 points： 产生积分返还将会扣除会员的库存积分，时效性为 1 个月。 签名规则？ 将参数列表按名称的 ASCII 顺序排序 然后把所有参数按顺序拼接：参数1名参数1值`参数2名参数2值[…参数n名参数n值]` 在拼接得到的字符串前后再拼接上 client_secret 将上面的结果进行一次 md5 计算，最后全部转为大写 用 PHP 表示就是： 12345678910111213141516171819$params = [ 'p1' =&gt; 'v1', 'p2' =&gt; 'v2', 'p3' =&gt; 'v3',];$client_secret = 'secret';ksort($params);$strToBeSigned = $client_secret;foreach ($params as $pName =&gt; $pVal) &#123; $strToBeSigned .= $pName.$pVal;&#125;$strToBeSigned .= $client_secret;$sign = strtouppler(md5($strToBeSigned)); 参考 MD5-wikipedia RFC：RFC 6749 - The OAuth 2.0 Authorization Framework &amp;&amp; OAuth2 RFC6749中文翻译","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"API","slug":"API","permalink":"http://blog.caoxl.com/tags/API/"},{"name":"Web","slug":"Web","permalink":"http://blog.caoxl.com/tags/Web/"},{"name":"云联惠","slug":"云联惠","permalink":"http://blog.caoxl.com/tags/云联惠/"},{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"}]},{"title":"快钱支付 「开发日志」","slug":"Kuaiqian-Pay-In-JHWM","date":"2018-01-23T07:48:24.000Z","updated":"2019-08-22T06:46:04.000Z","comments":true,"path":"2018/01/23/Kuaiqian-Pay-In-JHWM/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/Kuaiqian-Pay-In-JHWM/","excerpt":"在二次开发江湖外卖中集成快钱支付 简单记录下步骤。","text":"在二次开发江湖外卖中集成快钱支付 简单记录下步骤。 说明开发相关 明确网关版本是移动端还是 PC 端 两者的 demo 和文档不同，为了集成时少遇到点问题，必须明确当时是在接入什么端，然后再去看对应的文档和demo。 签名 商户提交给快钱的参数需要被签名，使用商户的私钥；快钱返回给商户的参数需要被验签，使用快钱的公钥。 二次封装 快钱提供的 demo（PHP）写的很随意和简陋，也不规范，建议自己封装好再放入系统使用。 公钥配置需要登录快钱中心，上传商家的公钥，和下载快钱的公钥。 然后在项目中，使用商家的私钥来加密支付交易数据，使用快钱的公钥来解密回调数据。 对于生成商家公私钥，可以参考文档，使用快钱提供的工具来生成，这里就不细说了。 后台管理登录地址为 https://mrs.99bill.com，要登录需要先在系统／浏览器安装一个快钱的证书。 支付接口开发江湖外卖默认提供的支付方式是在后台设置中自行安装的，我在接入快钱的时候也想做成这样，因此在了解了江湖外卖支付插件开发的规范后，也实现了在后台可以自行安装块钱支付的功能。 没有文档，debug 源码例子后照葫芦画瓢来的。 首先，江湖外卖支付插件都是放在 system/plugins/payments目录下的。可以看到默认包含了：alipay/money/paypay/stripe/wxpay。 因此，我在这个目录下创建了一个 kuaiqian 的子目录。里面只有两个文件： config.php 这个配置文件每个支付方式都有，是用来在后台读取生成 HTML 的。内容如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpreturn [ 'code' =&gt; 'kuaiqian', 'name' =&gt; '快钱支付', 'content' =&gt; '中国领先的互联网金融平台', 'website' =&gt; 'https://www.99bill.com/', 'version' =&gt; '0.1', 'currency' =&gt; '人民币', 'config' =&gt; [ 'kq_merchant_id' =&gt; [ 'text' =&gt; '人民币网关账号', 'desc' =&gt; '该账号为11位人民币网关商户编号+01,该参数必填', 'type' =&gt; 'text', ], 'kq_gateway_mobile' =&gt; [ 'text' =&gt; '快钱移动网关', 'desc' =&gt; '&lt;span style=\"color:red;\"&gt;*&lt;/span&gt;和PC网关必填其一(默认)', 'type' =&gt; 'text', ], 'kq_gateway_pc' =&gt; [ 'text' =&gt; '快钱PC网关', 'desc' =&gt; '&lt;span style=\"color:red;\"&gt;*&lt;/span&gt;和移动网关必填其一', 'type' =&gt; 'text', ], 'kq_page_url' =&gt; [ 'text' =&gt; '接收支付结果的页面地址', 'desc' =&gt; '该参数一般置为空即可', 'type' =&gt; 'text', ], 'kq_bg_url' =&gt; [ 'text' =&gt; '服务器接收支付结果的后台地址', 'desc' =&gt; '该参数务必填写，不能为空', 'type' =&gt; 'text', ], ],]; 其中对于使用来说，最主要的就是「人民币网关账号」（配置时注意要加上 01）。最后两个接受地址可以不用配置，我在代码中写好了。 kuaiqian.php 这就是快钱支付接口的主要文件了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161&lt;?php// 注意类命名格式必须要这种class Payment_Kuaiqian&#123; private $code = 'kuaiqian'; private $gatewaySandboxPC = 'https://sandbox.99bill.com/gateway/recvMerchantInfoAction.htm'; private $gatewaySandboxMobile = 'https://sandbox.99bill.com/mobilegateway/recvMerchantInfoAction.htm'; private $gatewayPC = 'https://www.99bill.com/gateway/recvMerchantInfoAction.htm'; private $gatewayMobile = 'https://www.99bill.com/mobilegateway/recvMerchantInfoAction.htm'; private $pcarduserPEMFile = 'certs/pcarduser.pem.php'; private $payParamStr = ''; private $signMsg = ''; private $payParamsOfPC = [ 'inputCharset' =&gt; '1', 'pageUrl' =&gt; '', 'bgUrl' =&gt; '', 'version' =&gt; 'v2.0', 'language' =&gt; '1', 'signType' =&gt; '4', 'signMsg' =&gt; '', 'merchantAcctId' =&gt; '', 'payerName' =&gt; '', 'payerContactType' =&gt; '', 'payerContact' =&gt; '', 'orderId' =&gt; '', 'orderAmount' =&gt; '', 'orderTime' =&gt; '', 'productName' =&gt; '', 'productNum' =&gt; '', 'productId' =&gt; '', 'productDesc' =&gt; '', 'ext1' =&gt; '', 'ext2' =&gt; '', 'payType' =&gt; '', 'bankId' =&gt; '', 'redoFlag' =&gt; '', 'pid' =&gt; '', ]; private $payParamsOfMobile = [ 'inputCharset' =&gt; '1', 'pageUrl' =&gt; '', 'bgUrl' =&gt; '', 'version' =&gt; 'mobile1.0', 'language' =&gt; '1', 'signType' =&gt; '4', 'merchantAcctId' =&gt; '', 'payerName' =&gt; '', 'payerContactType' =&gt; '1', 'payerContact' =&gt; '', 'payerIdType' =&gt; '3', // 指定付款人 'payerId' =&gt; '', 'orderId' =&gt; '', 'orderAmount' =&gt; '', 'orderTime' =&gt; '', 'productName' =&gt; '', 'productNum' =&gt; '', 'productId' =&gt; '', 'productDesc' =&gt; '', 'ext1' =&gt; '', 'ext2' =&gt; '', 'payType' =&gt; '21', // 快捷支付 'bankId' =&gt; '', 'redoFlag' =&gt; '0', 'pid' =&gt; '', ]; public function __construct($config) &#123; date_default_timezone_set('Asia/Shanghai'); $this-&gt;payParamsOfPC['bgUrl'] = $this-&gt;payParamsOfMobile['bgUrl'] = $config['return_url']; $this-&gt;payParamsOfPC['pageUrl'] = $this-&gt;payParamsOfMobile['pageUrl'] = $config['notify_url']; $this-&gt;payParamsOfPC['productNum'] = $this-&gt;payParamsOfMobile['productNum'] = $config['goodsNum'] ? $config['goodsNum'] : 1; $this-&gt;payParamsOfPC['orderTime'] = $this-&gt;payParamsOfMobile['orderTime'] = date('YmdHis'); &#125; // by rmb_demo_php public function kq_ck_null($kq_va, $kq_na) &#123; if ($kq_va == \"\") &#123; return $kq_va=\"\"; &#125; else &#123; return $kq_va=$kq_na.'='.$kq_va.'&amp;'; &#125; &#125; public function buildPayParams($isMobile) &#123; $payParamsArr = $isMobile ? $this-&gt;payParamsOfMobile : $this-&gt;payParamsOfPC; $payParamStr = ''; foreach ($payParamsArr as $k =&gt; $v) &#123; $payParamStr .= $this-&gt;kq_ck_null($v, $k); &#125; $payParamStr = $isMobile ? rtrim($payParamStr, '&amp;') : mb_substr($payParamStr, 0, mb_strlen($payParamStr)-1); $this-&gt;payParamStr = $payParamStr; return $this-&gt;payParamStr; &#125; public function signPayParams() &#123; $priv_key = trim(require_once __CORE_DIR.$this-&gt;pcarduserPEMFile);// $fp = fopen(__CORE_DIR.$this-&gt;pcarduserPEMFile, 'r');// $priv_key = fread($fp, 123456);// fclose($fp); $pkeyid = openssl_get_privatekey($priv_key); openssl_sign($this-&gt;payParamStr, $signMsg, $pkeyid, OPENSSL_ALGO_SHA1); openssl_free_key($pkeyid); // free the key from memory $this-&gt;signMsg = base64_encode($signMsg); return $this-&gt;signMsg; &#125; public function build_url($params) &#123; if (!$params) &#123; return false; &#125; $isMobile = (!isset($params['gatewayType']) || (isset($params['gatewayType'])&amp;&amp;$params['gatewayType'] != 'pc')) ? true : false; $detail = K::M('payment/payment')-&gt;payment($this-&gt;code); if ($isMobile) &#123; $gateway = $detail['kq_gateway_mobile'] ? $detail['kq_gateway_mobile'] : $this-&gt;gatewayMobile; $payParamsType = 'payParamsOfMobile'; &#125; else &#123; $gateway = $detail['kq_gateway_pc'] ? $detail['kq_gateway_pc'] : $this-&gt;gatewayPC; $payParamsType = 'payParamsOfPC'; &#125; $payParamsTypeArr = &amp;$this-&gt;$payParamsType; $payParamsTypeArr['merchantAcctId'] = $detail['config']['kq_merchant_id']; $payParamsTypeArr['productName'] = $params['title']; $payParamsTypeArr['productDesc'] = $params['body']; $payParamsTypeArr['payerName'] = $params['payerName']; $payParamsTypeArr['payerId'] = $params['uid']; $payParamsTypeArr['orderAmount'] = $params['amount']; $payParamsTypeArr['orderId'] = $params['trade_no']; $this-&gt;buildPayParams($isMobile); $this-&gt;signPayParams(); $payParamsTypeArr['signMsg'] = $this-&gt;signMsg; $payParamsTypeArr['gateway'] = $gateway; $payParamsTypeArr['entry_url'] = '/trade/kuaiqian'; return $payParamsTypeArr; &#125; public function build_app($params) &#123; return $this-&gt;build_url($params); &#125; public function build_form($params) &#123; return $this-&gt;build_url($params); &#125;&#125; 其中，build_app 和 build_url 是为了和其他支付接口保持一致，这样才可以通过现有的代码来在控制器调用快钱支付。 支付由于快钱支付接口会检查 HTTP Referrer 字段，虽然可以通过在 CURL 中设置，但是我考虑到本来就要在浏览器页面发起支付请求，因此我用了最原始的表单方式来发起支付请求。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- themes/default/kuaiqian/send.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;正在使用快钱支付&lt;/title&gt;&lt;/head&gt;&lt;body style=\"display:none\"&gt;&lt;form method='GET' action=\"&lt;&#123;$gateway&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"inputCharset\" value=\"&lt;&#123;$inputCharset&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"pageUrl\" value=\"&lt;&#123;$pageUrl&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"bgUrl\" value=\"&lt;&#123;$bgUrl&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"version\" value=\"&lt;&#123;$version&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"language\" value=\"&lt;&#123;$language&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"signType\" value=\"&lt;&#123;$signType&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"merchantAcctId\" value=\"&lt;&#123;$merchantAcctId&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"payerName\" value=\"&lt;&#123;$payerName&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"payerContactType\" value=\"&lt;&#123;$payerContactType&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"payerContact\" value=\"&lt;&#123;$payerContact&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"payerIdType\" value=\"&lt;&#123;$payerIdType&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"payerId\" value=\"&lt;&#123;$payerId&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"orderId\" value=\"&lt;&#123;$orderId&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"orderAmount\" value=\"&lt;&#123;$orderAmount&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"orderTime\" value=\"&lt;&#123;$orderTime&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"productName\" value=\"&lt;&#123;$productName&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"productNum\" value=\"&lt;&#123;$productNum&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"productId\" value=\"&lt;&#123;$productId&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"productDesc\" value=\"&lt;&#123;$productDesc&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"ext1\" value=\"&lt;&#123;$ext1&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"ext2\" value=\"&lt;&#123;$ext2&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"payType\" value=\"&lt;&#123;$payType&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"bankId\" value=\"&lt;&#123;$bankId&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"redoFlag\" value=\"&lt;&#123;$redoFlag&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"pid\" value=\"&lt;&#123;$pid&#125;&gt;\"&gt; &lt;input type=\"hidden\" name=\"signMsg\" value=\"&lt;&#123;$signMsg&#125;&gt;\"&gt; &lt;input type=\"submit\" value=\"SUBMIT\" id=\"payNow\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; document.getElementById('payNow').click();&lt;/script&gt; 这样无论是什么业务需要使用快钱支付，只需要通过这个支付页面就行了，不需要像使用 CURL 时去判断到底是用哪个 URL 地址。 回调支付完成后，快钱会发起两种回调： 一个 REQUEST 到后台处理支付结果的回调URL，用于验签、根据支付结果逻辑处理； 注意事项这个回调处理完逻辑后，必须返回 result 和 redirecturl XML 标签对，否则快钱会一直请求。 此外，返回的 &lt;result&gt;&lt;/result&gt; 标签值必须是验签的结果：0 或 1。 一个 GET 支付结果页面，显示支付结果。 这个显示页面就是由上面 redirecturl 指定的，可含自定义参数用于定制提示信息。 验签除了这两个文件外，还有一些工具性方法，被我封装到了 system/models/tools/tool.mdl.php。相关方法是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// [快钱支付回调参数校验]// re-packing from kuaiqian demo for mobilepublic function kqPayCallbackSignVerify($params, $cert)&#123; // by rmb_demo_php @kuaiqian function kq_ck_null($kq_va, $kq_na) &#123; if ($kq_va == \"\") &#123; return $kq_va=\"\"; &#125; else &#123; return $kq_va=$kq_na.'='.$kq_va.'&amp;'; &#125; &#125; //人民币网关账号，该账号为11位人民币网关商户编号+01,该值与提交时相同。 $kq_check_all_para=kq_ck_null($params['merchantAcctId'], 'merchantAcctId'); //网关版本，固定值：v2.0,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['version'], 'version'); //语言种类，1代表中文显示，2代表英文显示。默认为1,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['language'], 'language'); //签名类型,该值为4，代表PKI加密方式,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['signType'], 'signType'); //支付方式，一般为00，代表所有的支付方式。如果是银行直连商户，该值为10,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['payType'], 'payType'); //银行代码，如果payType为00，该值为空；如果payType为10,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['bankId'], 'bankId'); //商户订单号，,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['orderId'], 'orderId'); //订单提交时间，格式：yyyyMMddHHmmss，如：20071117020101,该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['orderTime'], 'orderTime'); //订单金额，金额以“分”为单位，商户测试以1分测试即可，切勿以大金额测试,该值与支付时相同。 $kq_check_all_para.=kq_ck_null($params['orderAmount'], 'orderAmount'); $kq_check_all_para.=kq_ck_null($params['bindCard'], 'bindCard'); $kq_check_all_para.=kq_ck_null($params['bindMobile'], 'bindMobile'); // 快钱交易号，商户每一笔交易都会在快钱生成一个交易号。 $kq_check_all_para.=kq_ck_null($params['dealId'], 'dealId'); //银行交易号 ，快钱交易在银行支付时对应的交易号，如果不是通过银行卡支付，则为空 $kq_check_all_para.=kq_ck_null($params['bankDealId'], 'bankDealId'); //快钱交易时间，快钱对交易进行处理的时间,格式：yyyyMMddHHmmss，如：20071117020101 $kq_check_all_para.=kq_ck_null($params['dealTime'], 'dealTime'); //商户实际支付金额 以分为单位。比方10元，提交时金额应为1000。该金额代表商户快钱账户最终收到的金额。 $kq_check_all_para.=kq_ck_null($params['payAmount'], 'payAmount'); //费用，快钱收取商户的手续费，单位为分。 $kq_check_all_para.=kq_ck_null($params['fee'], 'fee'); //扩展字段1，该值与提交时相同 $kq_check_all_para.=kq_ck_null($params['ext1'], 'ext1'); //扩展字段2，该值与提交时相同。 $kq_check_all_para.=kq_ck_null($params['ext2'], 'ext2'); //处理结果， 10支付成功，11 支付失败，00订单申请成功，01 订单申请失败 $kq_check_all_para.=kq_ck_null($params['payResult'], 'payResult'); //错误代码 ，请参照《人民币网关接口文档》最后部分的详细解释。 $kq_check_all_para.=kq_ck_null($params['errCode'], 'errCode'); $trans_body = mb_substr($kq_check_all_para, 0, mb_strlen($kq_check_all_para)-1); $MAC = base64_decode($params['signMsg']); // $fp = fopen(\"./99bill[1].cert.rsa.20140803.cer\", \"r\"); // $cert = fread($fp, 8192); // fclose($fp); $pubkeyid = openssl_get_publickey($cert); return openssl_verify($trans_body, $MAC, $pubkeyid);&#125; 附录 快钱返回值 1234567891011121314151617181920212223&#123; \"dealTime\": \"20170623160809\", \"payAmount\": \"100\", \"bindMobile\": \"1593640\", \"signType\": \"4\", \"bindCard\": \"6214832276\", \"errCode\": \"\", \"merchantAcctId\": \"1020092607701\", \"orderTime\": \"20170623160616\", \"dealId\": \"2564166292\", \"version\": \"mobile1.0\", \"bankId\": \"CMB\", \"fee\": \"\", \"bankDealId\": \"170623732597\", \"ext1\": \"\", \"payResult\": \"10\", \"ext2\": \"\", \"orderAmount\": \"100\", \"signMsg\": \"U63zh45aT3qMBr9dA1QHTr9biG3+VvpVJgD0ZsPPKatLF6uFPkWgIA66ffqMRZYG+3w3jwajlwBhvq+2dHn0PL9+BM9ab6bhcLmRsuEvC93fsq3rQzcreEGQyyWKb5HFUQVqnVE7xgFEG\\/5ie\\/xywdtL0hQJl2yGzxjEjUXUtKSTH7+7nN2VaqLe69Z5yZP0il5G7FWcuahekfxDGUmG8n8yiqH9+f8TbJYLT0jNB9AXgrwfLwmidyrkp7Ar6pWpVXJ65CbwUrZ+JQP5Li1pMpHjhj\\/bCP2Xi8L8UzLZAwxbUxV+UN3RB5BzuK4kbE0\\/4tqlh9HoZAVu4rwP6aXEPA==\", \"payType\": \"21-1\", \"language\": \"1\", \"orderId\": \"1706233980\"&#125; FAQ 为什么快钱请求回调URL时原样输出两个标签了？ 被登录验证挡住了。 其他 json_decode() 会把 + 解码成空格 参考 快钱开放平台-接入中心","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"},{"name":"快钱","slug":"快钱","permalink":"http://blog.caoxl.com/tags/快钱/"},{"name":"支付","slug":"支付","permalink":"http://blog.caoxl.com/tags/支付/"}]},{"title":"支付宝/微信 「开发日志」","slug":"Wechat-Platform-And-Alipay-Dev-Log","date":"2018-01-23T07:13:19.000Z","updated":"2019-08-22T06:46:26.000Z","comments":true,"path":"2018/01/23/Wechat-Platform-And-Alipay-Dev-Log/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/Wechat-Platform-And-Alipay-Dev-Log/","excerpt":"调用第三方服务的时候总难一次性搞定的，下面把微信和支付宝服务集成到应用时遇到的“坑”简单总结下。 为啥要把支付宝和微信放到一起?? 因为他俩是基佬~~","text":"调用第三方服务的时候总难一次性搞定的，下面把微信和支付宝服务集成到应用时遇到的“坑”简单总结下。 为啥要把支付宝和微信放到一起?? 因为他俩是基佬~~ 支付宝 官方 PHP SDK 中公私钥的换行方式会影响公私钥校验 PHP 在支付宝开发后台填写公私钥时提示不匹配 服务端语言是 PHP，通过支付宝提供的 RSA 秘钥工具生成的私钥（应用私钥2048.txt）格式是一行连续的，已取出头尾部的，未换行的字符串。而在上传应用公钥的时候，如果点击了“验证公钥正确性”，并使用弹出页面中提供的验签工具生成签名时候，需要私钥的是 pkcs8（JAVA 适用）格式，而为 PHP 生成的秘钥是 pkcs1 格式，因此需要转换。 第一步： 将非 JAVA 适用的私钥文件转换为标准 PEM 格式（64个字符串换一行） 1234$raw_rsa_secret = file_get_contents('/path/to/应用私钥2048.txt');$secret_content = implode(\"\\n\", str_split($raw_rsa_secret, 64));$pem_key_pkcs1 = '-----BEGIN RSA PRIVATE KEY-----'.PHP_EOL.$secret_content.PHP_EOL.'-----END RSA PRIVATE KEY-----';file_put_contents('pkcs1.pem', $pem_key_pkcs1); 第二步： 将上一步转换后的标准 PEM 格式的 pkcs1 私钥 转换为 pkcs8 私钥 1openssl pkcs8 -topk8 -inform PEM -in pkcs1.pem -outform pem -nocrypt -out pkcs8.pem 第三步： 将上一部转换后的私钥（pkcs8.pem）复制到支付宝提供的验签工具对字符串 a=123 进行签名 第四步： 将签名结果复制的支付宝开发者后台进行确认公钥正确性 https://b.alipay.com/order/serviceIndex.htm 和 开放平台的支付宝公钥不一样。 开放平台的接口就用开放平台的支付宝公钥，mapi网关的接口就用mapi网关的支付宝公钥。前者是新接口 ，后者是老接口使用。 notify_url 和 return_url 默认不能带自定义参数的 即：http://example.com/index.php?trade/payment/notify-alipay-app 中 ? 后面的参数都会被支付宝忽略。从而请求的是 http://example.com/index.php。 reurn_url 和 notify_url 的区别？ 对于 notify_url de说明详见参考的 服务器异步通知参数说明，因此这里只说下 return_url： 交易完成后，一般情况支付宝会先通知 notify_url（POST方式），但是并不一定，因此不要以先后顺序来做判断，而要根据数据库的订单状态来判断。 买家在支付成功后会看到一个支付宝提示交易成功的页面，该页面会停留几秒，然后会自动跳转回商户指定的同步通知页面，即 GET return_url。 该方式仅仅在买家付款完成以后进行自动跳转，因此只会进行一次。 该方式不是支付宝主动去调用商户页面，而是支付宝的程序利用页面自动跳转的函数，使用户的当前页面自动跳转。 返回URL只有一分钟的有效期，超过一分钟该链接地址会失效，验证则会失败。 支付宝POST异步回调地址过来的数据，有的有 is_success 字段有的没有？ 移动支付接口，异步通知本来没有 is_success。手机网站支付接口，异步里也没有那个的参数的，但是同步是有的。 移动支付的文档 &amp;&amp; 快速查单 程序执行完后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。 一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）； 如何区分接口版本？ 接口文档中网关是 openapi.alipay.com 的是 2.0 接口； mapi（即时到账） 是 1.0 接口； 手机网站支付是 1.0 接口。 不同 API 版本公私钥不通用。 公私钥参考这篇文档即可：https://docs.open.alipay.com/291。 支付app_paySee: https://docs.open.alipay.com/60/104790 : app_pay=Y：尝试唤起支付宝客户端进行支付，若用户未安装支付宝，则继续使用wap收银台进行支付。商户若为APP，则需在APP的webview中增加alipays协议处理逻辑。 退款即时到账批量退款有密接口需要密码。可参考：即时到账批量退款有密接口 新版开放平台退款接口 alipay.trade.refund参考： alipay.trade.refund(统一收单交易退款接口)。 注意: alipay.trade.refund 的返回值中没有相关的ID来标识本次退款请求的。（微信有） 微信 access_token =&gt; 区分 「网页授权」 和「微信公众号」 JSSDK 支付 =&gt; 注意中英输入法分号之差 金额单位微信支付时使用的金额单位一律是分，对于 PHP 这种弱类型语言来说尤其需要注意。 一般而言，应用服务器数据库里面的金额都是存的浮点型。因此在转换成整数的时候尤其需要小心。如果出现订单金额和实际支付金额不同的情况，在调用诸如原路退款接口的时候会出现“退款金额无效”的提示。 这个问题很早有人在 PHP 一次 ‘bug’ 反馈中提到过，现象如下： Rasmus Lerdorf 的回答是：not a bug… 1echo intval(17.9 * 100); // 期望 1790 而实际输出 1789 解决办法是：调用 intval() 之前使用 round() 先将浮点数四舍五入，或者先当作字符串处理一次后在调用 intval()。 123456789101112131415echo intval(round(17.9 * 100, 0)); // output: 1790// Or:function getIntFee(float $float) : int&#123; $arr = explode('.', $float); if (! isset($arr[0])) &#123; return intval($arr[0]); &#125; return false;&#125;$amount = getIntFee(17.9 * 100); // output: 1790 参考 支付宝开发文档 支付宝 PHP SDK 支付宝-App支付DEMO&amp;SDK 支付宝-生成RSA密钥-签名工具 支付宝接口使用文档说明 支付宝异步通知(notify_url)与return_url 服务器异步通知参数说明 蚂蚁金服-开放平台：账户中心-PID和公钥管理 蚂蚁金服-开放平台：历史接口接入指南 Composer 支付组件：helei112g/payment、latrell/alipay","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"},{"name":"Wechat","slug":"Wechat","permalink":"http://blog.caoxl.com/tags/Wechat/"},{"name":"微信","slug":"微信","permalink":"http://blog.caoxl.com/tags/微信/"},{"name":"Alipay","slug":"Alipay","permalink":"http://blog.caoxl.com/tags/Alipay/"},{"name":"支付宝","slug":"支付宝","permalink":"http://blog.caoxl.com/tags/支付宝/"}]},{"title":"腾讯信鸽推送 「开发日志」","slug":"Tencent-XG-Push-Log","date":"2018-01-23T06:54:33.000Z","updated":"2019-08-22T06:45:57.000Z","comments":true,"path":"2018/01/23/Tencent-XG-Push-Log/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/Tencent-XG-Push-Log/","excerpt":"简单记录腾讯信鸽推送开发日志 腾讯信鸽推送 文档 iOS 推送工作原理APNsApple Push Notification Service，直译过来就是“苹果推送通知服务”，即苹果专门的推送服务器。 由于 Apple 对设备的控制非常严格，iOS 内应用消息的推送必须要经过 APNs。","text":"简单记录腾讯信鸽推送开发日志 腾讯信鸽推送 文档 iOS 推送工作原理APNsApple Push Notification Service，直译过来就是“苹果推送通知服务”，即苹果专门的推送服务器。 由于 Apple 对设备的控制非常严格，iOS 内应用消息的推送必须要经过 APNs。 被推送消息的转发顺序应用服务器（Provider）=&gt; APNs =&gt; iPhone／iOS =&gt; App。 工作原理说明 苹果利用自己专门的推送服务器（APNs）接收来自我们自己的应用服务器的需要被推送的信息，然后推送到指定的iOS设备上，然后由设备通知到我们的应用程序，设备以通知或者声音的形式通知用户有新的消息。 推送的前提是装有我们应用的设备需要向APNs服务器注册，注册成功后APNs服务器会返给我们一个device_token，拿到这个token后我们将这个token发给我们自己的应用服务器，当有需要被推送的消息时，我们的应用服务器会将消息按指定的格式打包，然后结合设备的device_token一并发给APNs服务器，由于我们的应用和APNs维持一个基于TCP的长连接，APNs将新消息推送到我们设备上，然后在屏幕上显示出新消息来。 推送数据格式JSON，且 APNs 限制了每个 notification 的 payload 最大长度是 256 字节。举例： 1234567891011&#123; \"aps\": &#123; \"alert\": \"老板赞了你\", \"sound\": \"default\", \"badge\": 1; &#125;, \"msg\": \"这里是额外消息，不显示在通知界面上。\" \"action\": &#123; \"type\": 2 &#125;&#125; alert 的内容就是会显示在用户手机上的推送信息，它的值可以是一个 String，也可以是一个 JSON。当它是文本消息的时候，系统就会把这些文字显示到一个 alertView中；如果它也是由一个 JSON 组成的话，其包含的字段如下： body action-loc-key loc-key loc-args launch-image body 部分就是 alertView 中将要展现出来的文本消息，loc-* 属性主要是用来实现本地化消息，launch-image 只是app 主 bundle 里的一个图片文件的名称，一般来说我们不指定这一属性。 badge 是会在应用 icon 右上角显示的数量（注意是整型），提示有多少条未读消息等。 sound 就是当推送信息送达是手机播放的声音，传 defalut 就标明使用系统默认声音，如果传比如 beep.wav 就会播放在我们应用工程目录下名称为 beep.wav 的音频文件。 aps 之外的可以自定义数据结构。 本地化 有两种办法可以实现推送消息的本地化： 1，在推送的payload中使用loc-key和loc-args来指定进行本地化，这样Provider方只需要按照统一的格式来发送即可，消息的解析和组装则由客户端来完成。 2，如果推送的payload里面不包含loc-key/loc-args信息，那么Provider方就需要自己做本地化处理，然后给不同的device发送不同的消息，为了做到这一点，还需要app在上传device token的时候也把用户的语言设置信息传回来。 腾讯信鸽接入客户端配置这个主要是 iOS 去完成的，这里略过，详见：iOS接入-腾讯信鸽。 服务端配置服务端接入及调用腾讯信鸽非常简单，可以通过提供的服务端 SDK，也可以直接使用提供的 RESTful API。下面以在 Lumen 中集成腾讯信鸽的 PHP SDK 为例说明。 引入类文件 腾讯信鸽的 PHP SDK 主要只有一个类文件 XingeApp.php。把它放在 app/Tools/XingeApp.php 下，命名空间为设置为：namespace App\\Tools。 配置 access_id 和 secret_key 相应的配置文件放在 config/txxg.php 中，内容只有以下两个： 12345678910111213&lt;?php/*|--------------------------------------------------------------------------| 腾讯信鸽配置|--------------------------------------------------------------------------|| Add this config file in .gitignore and put it on the prod server manually|*/return [ 'access_id' =&gt; '1024', 'secret_key' =&gt; 'xxxx', // 32 bit(md5)]; access_id 和 secret_key 在注册了腾讯信鸽后会提供，填在这里就行了。 在工具类中调用 SDK 中的方法 12345678910111213141516171819202122232425262728293031323334namespace App\\Tools;class Tol&#123; public static function iosPush($account, $msg, $msg_num) &#123; $txxg_path = base_path().'/config/txxg.php'; $txxg = false; if (file_exists($txxg_path)) $txxg = include_once $txxg_path; if (!$txxg || !$txxg['access_id'] || !$txxg['secret_key']) abort( 500, '腾讯信鸽配置不存在或不正确(config/txxg.php)' ); list( $accessId, $secretKey, ) = array_values($txxg); return XingeApp::PushAccountIos( $accessId, $secretKey, $msg, $account, XingeApp::IOSENV_PROD, $msg_num ); &#125;&#125; 之后在控制器中如果要给 App 发送推送消息，则只需要执行 Tol::iosPush() 就可以了。（注意引入该工具类先） 参考 信鸽开发者手册 下载 SDK-腾讯信鸽 苹果推送(APNs)ios push小结 细说 iOS 消息推送 移动手机消息推送机制 一步一步实现iOS应用PUSH功能 极光官方文档","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"},{"name":"信鸽","slug":"信鸽","permalink":"http://blog.caoxl.com/tags/信鸽/"},{"name":"推送","slug":"推送","permalink":"http://blog.caoxl.com/tags/推送/"},{"name":"腾讯","slug":"腾讯","permalink":"http://blog.caoxl.com/tags/腾讯/"}]},{"title":"接口网 短信接口「开发日志」","slug":"JieKou-Dev-Log","date":"2018-01-23T06:32:06.000Z","updated":"2019-08-22T06:46:09.000Z","comments":true,"path":"2018/01/23/JieKou-Dev-Log/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/JieKou-Dev-Log/","excerpt":"接口网短信接口 接口地址不同的编码方式请使用不同的接口地址，以 UTF-8 举例说明： 国内「非群发」类短信接口格式 1http://sms.106jiekou.com/utf8/sms.aspx?account=用户账号&amp;password=接口密码&amp;mobile=号码&amp;content=您的订单编码：888888。如需帮助请联系客服。 国内「群发」类短信接口格式（不支持单条频繁提交） 1http://sms.106jiekou.com/utf8/openapi.aspx?account=用户账号&amp;password=接口密码&amp;mobile=号码&amp;content=内容 国际「非群发」类短信接口格式 1http://sms.106jiekou.com/utf8/worldapi.aspx?account=用户账号&amp;password=接口密码&amp;mobile=号码&amp;content=内容","text":"接口网短信接口 接口地址不同的编码方式请使用不同的接口地址，以 UTF-8 举例说明： 国内「非群发」类短信接口格式 1http://sms.106jiekou.com/utf8/sms.aspx?account=用户账号&amp;password=接口密码&amp;mobile=号码&amp;content=您的订单编码：888888。如需帮助请联系客服。 国内「群发」类短信接口格式（不支持单条频繁提交） 1http://sms.106jiekou.com/utf8/openapi.aspx?account=用户账号&amp;password=接口密码&amp;mobile=号码&amp;content=内容 国际「非群发」类短信接口格式 1http://sms.106jiekou.com/utf8/worldapi.aspx?account=用户账号&amp;password=接口密码&amp;mobile=号码&amp;content=内容 短信接口都是 JSON 响应。 此外，GBK 接口地址和 UTF-8 的区别只是把上面的 utf-8 改为 gbk 即可。 查询余额（XML 响应） 1http://www.dxton.com/webservice/sms.asmx/GetNum?account=用户账号&amp;password=接口密码 接口参数接口账户和接口密码接口账户就是登录接口网的账户，但接口密码不是登录密码，需要自行在后台设置。 接收号码 频率限制 每个号码接收频率 5 次/天。 不然易引起运营商网关屏蔽数天，如果需要更高频率联系客服申请。 群发 当调用群发接口时，使用英文逗号 , 分隔不同的手机号码即可，比如：13333333333,15555555555。国际建议 100 个内，国内建议 1000 个内。 国际 需要注意带上国际区码和地区区码。比如 123国际区码：49地区区码：0179手机号码：233333 则正确的格式为：49179233333。注意，地区城市区码的 0或 00 不用加。 短信内容发送内容需要进行 URL 字符标准化转码。 有一个专用调试模版：您的订单编码：888888。如需帮助请联系客服。。 URL 字符编码说明：返回字符串，此字符串中除了 -/_/. 之外的所有非字母数字字符，都将被替换成百分号 % 后跟两位十六进制数，空格则编码为加号 +。 短信模版短信模版指的是发送到用户手机时看到的内容所采用的格式。 模版中含有「变量」，变量是在项目根据需要动态生成的不同内容。变量套用被允许使用的模版，生成最终发送给用户的短信内容，连同用户手机号码，通过参数的形式调用接口网接口，发送给目标用户。 短信模版举例如下： 未充值用户调试专用短信模板 1尊敬的用户您已经注册成功，用户名：`&lt;账号用户名&gt;` 密码：`&lt;账号密码&gt;` 感谢您的注册！ 专用调试模版 1您的订单编码：888888。如需帮助请联系客服。 普通模版 1您的订单编码：【变量】。如需帮助请联系客服。 其中， 「变量」可以自定义内容，其它都要和模板一致，包括空格、标点符号等。 限制 小批量调试或应用订购，短信内容只能用“系统公共模版”相对固定格式，否则会报错104（内容未审核） 自定义短信模版、签名，需要审批和备案 由于短信行业受运营商政策管制，只有政策允许且你的帐号级别够的时候，才支持。若帐号无权限或系统未开放时，只能选用系统默认的通用性短信签名和短信模版。如果都支持，编辑好签名、模板，后台提交，我们报备运营商，审批下来后就可以按贵公司的格式进行发送了。（以后台通告为准） 提交时，签名不用加 【】 号，模板中属于变量的地方用 【变量】代替，否则系统识别不出来。 短信签名短信末尾或前面跟的品牌签名。比如： 1您的订单编码：888888。如需帮助请联系客服。【会员验证通知】 其中，”会员验证通知” 就属于短信签名，一般是公司或产品简称。 小批量应用【部分自定义内容和签名】实现方法 可以把订单编码、客服热线、【店铺名称】，都融入到 一个【变量】里。 短信模板： 您的订单编码：【变量】。如需帮助请联系客服。 实际内容： 您的订单编码：20140208 客服热线4006668280【速度网络】。如需帮助请联系客服。【会员验证通知】 可以把验证码、网站或软件名称，都融入到 一个【变量】里。 短信模板： 您的订单编码：【变量】。如需帮助请联系客服。 实际内容： 您的订单编码：8888【速度网络】。如需帮助请联系客服。【会员验证通知】 返回状态码及其说明12345678910111213100 发送成功101 验证失败102 手机号码格式不正确103 会员级别不够104 内容未审核105 内容过多106 账户余额不足107 Ip受限108 手机号码发送太频繁，请换号或隔天再发109 帐号被锁定110 发送通道不正确111 当前时间段禁止短信发送120 系统升级 相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?phpnamespace App\\Tools;class DxtonSMS&#123; protected $send_api = 'http://sms.106jiekou.com/utf8/sms.aspx'; protected $sms_tpls = [ 'default' =&gt; '您的订单编码：CODE。如需帮助请联系客服。' ]; protected $account = null; protected $api_key = null; protected $mobiles = null; protected $code = null; protected $tpl = null; protected $api_url = null; protected $content = null; public function __construct( $mobiles, $code, $tpl = 'default', $account = null, $api_key = null ) &#123; list( $this-&gt;account, $this-&gt;api_key, $this-&gt;mobiles, $this-&gt;code, $this-&gt;tpl ) = [ $account, $api_key, $mobiles, $code, $tpl, ]; if (is_null($this-&gt;account) || is_null($this-&gt;api_key)) &#123; self::setDefaultAuth(); &#125; self::setApiUrl(); &#125; public static function getContent() &#123; // &#125; public static function setApiUrl( $account, $password, $mobile, $code, $tpl ) &#123; // account=帐号&amp;password=接口密码&amp;mobile=手机号码&amp;content=\".rawurlencode(self::getContent()); &#125; public static function setDefaultAuth() &#123; try &#123; $this-&gt;account = env('DXT_ACCOUNT'); $this-&gt;api_key = env('DXT_API_KEY'); &#125; catch (\\Exception $e) &#123; die($e-&gt;getMessage()); &#125; &#125; public static function getSendResBySock($data, $target) &#123; $url_info = parse_url($target); $httpheader = \"POST \" . $url_info['path'] . \" HTTP/1.0\\r\\n\"; $httpheader .= \"Host:\" . $url_info['host'] . \"\\r\\n\"; $httpheader .= \"Content-Type:application/x-www-form-urlencoded\\r\\n\"; $httpheader .= \"Content-Length:\" . strlen($data) . \"\\r\\n\"; $httpheader .= \"Connection:close\\r\\n\\r\\n\"; // $httpheader .= \"Connection:Keep-Alive\\r\\n\\r\\n\"; $httpheader .= $data; $fd = fsockopen($url_info['host'], 80); fwrite($fd, $httpheader); $gets = \"\"; while (!feof($fd)) &#123; $gets .= fread($fd, 128); &#125; fclose($fd); return $gets; &#125; public static function getSendResByCurl($api_url, $content) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $api_url); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_NOBODY, true); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_POSTFIELDS, $content); $send_res = curl_exec($ch); if (curl_errno($ch) !== 0) &#123; $send_res = false; &#125; curl_close($ch); return $send_res; &#125;&#125; FAQ 短信长度如何收费？ 70 字符按 1 条收费，超 70 字，按 65 /条，多条收费。(通道行业标准，部分通道 67 字符单条） 可以绑定IP吗？ 为了避免各种原因的帐号盗用情况，造成贵公司短信被滥用，所以我们的系统有ip验证功能，只发送您这边认可的ip地址提交的短信。 接口调试返回“104 内容未审核”错误？ 发送内容未按系统模板或备案的模板下发；或程序编码格式和接口不一致。 参考 接口网短信接口开发记录","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"},{"name":"接口网","slug":"接口网","permalink":"http://blog.caoxl.com/tags/接口网/"},{"name":"短信接口","slug":"短信接口","permalink":"http://blog.caoxl.com/tags/短信接口/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"}]},{"title":"七牛云 「开发日志」","slug":"Qiniu-Dev-Log","date":"2018-01-23T03:25:02.000Z","updated":"2019-08-22T06:46:00.000Z","comments":true,"path":"2018/01/23/Qiniu-Dev-Log/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/Qiniu-Dev-Log/","excerpt":"总结下使用七牛云 PHP SDK 和 JS SDK 的过程中经常使用的代码 demo，以及坑。 PHP-SDk安装123composer config -g repo.packagist composer https://packagist.phpcomposer.comcomposer require qiniu/php-sdk","text":"总结下使用七牛云 PHP SDK 和 JS SDK 的过程中经常使用的代码 demo，以及坑。 PHP-SDk安装123composer config -g repo.packagist composer https://packagist.phpcomposer.comcomposer require qiniu/php-sdk 操作的前提和对象 「前提」就是认证 acess_key 和 secret_key； 「对象」就是认证通过后的 $auth 对象。 在调用 PHP SDK 的时候，所有七牛云的操作都是通过这个通过认证的 $auth 对象来完成的。 123456use Qiniu\\Auth;$ak = env('QINIU_ACCESSKEY');$sk = env('QINIU_SECRETKEY');$auth = new Auth($ak, $sk); 简单地说，在 SDK 中调用七牛云的所有 API 都需要从获得 $auth 对象开始。 私有空间获得私有空间的下载链接想要操作私有空间的文件，首先必须对私有空间文件进行签名，然后把签名的结果当作公开文件外链那样再进行所需处理。 12345# 私有空间文件地址 = 私有空间域名+私有空间中的文件 key$prvt_url = 'http://prvt.eme168.com/00521276847c7dfc21981faaddb1881e14766870526616.jpg?attname='.$save_as; // $save_as 是下载后的文件名 可以不选echo $auth-&gt;privateDownloadUrl($prvt_url, 600); // 600 指的是该下载链接在公网上的失效时间 下载链接=访问链接简单的说，七牛云中私有空间的下载链接可以当做公开空间的外链使用。 这其实也是公共空间和私有空间调用七牛云 API 的主要区别。 下载链接要真正返回一个下载相应的话，请求参数中带上 ?attname=SAVE_AS 即可。 注意 对于中文文件名，为了更好的支持中文，将 attname= 后面的中文文件名部分要进行 URL encode 操作。 持久化七牛云中的「持久化（pfop）」就是用队列的形式处理一系列耗时操作。 上传时触发只需在构造上传凭证时，在上传策略中设置 persistentOps 和 persistentNotifyUrl 两个字段。 举例说明: 123456789101112131415161718$bucket = 'private';$origin_img = '00521276847c7dfc21981faaddb1881e14766870526616.jpg';$notify_url = 'http://www.eme168.com/api/cloudcapture/shrink_notify';$policy = [ 'persistentOps' =&gt; $pfop, 'persistentNotifyUrl' =&gt; $notify_url // 必须和 persistentOps 同时存在];$token = $auth-&gt;uploadToken( $bucket, null, 7200, $policy);$upload_res = $uploader-&gt;putFile( $token, // 上传 token $origin_img, // 上传后要重命名时需填 不需要时直接填 null 即可 base_path($save_path).'/'.$origin_img // 要上传文件的本地路径); pipeline 持久化操作期间使用的队列名称（pipeline）可选 可以不填或填 null 但不能乱填。举例说明： 12345use Qiniu\\Processing\\PersistentFop;$bucket = 'private'; // 资源空间名$pipeline = 'em-shrink-'.rand(1, 16); // 或者 $pipeline = null$pfop = new PersistentFop($auth, $bucket, $pipeline); 当 $pipeline 为 null 时，七牛云会默认为你的这个操作分配一个队列名。 pipeline 需要事先在控制台创建 保存持久化处理结果1234567891011$origin_img = '00521276847c7dfc21981faaddb1881e14766870526616';$shrink_name = 'shrink_'.(microtime(true)*10000).'.jpg';$save_as = base64_encode('yimai:'.$shrink_name);$fops = 'imageMogr2/thumbnail/!30p/crop/x500|saveas/'.$save_as;list($id, $err) = $pfop-&gt;execute($origin_img, $fops); // $pfop 是持久化操作对象echo \"\\n====&gt; pfop thumbnail result: \\n\";if ($err != null) print_r($err);else echo \"PersistentFop Id: $id\\n\"; 持久化处理通知回调持久化处理本质是对七牛云一些列 API 的请求，七牛云在自己的队列中处理，处理后通过在构造上传 token 时指定的 persistentNotifyUrl 来主动通知到业务服务器。 123456789101112// 处理七牛云持久化操作结束后的通知请求public function prstNotifyCallBack(CloudCaptureModel $ccm)&#123; $notify_body = file_get_contents('php://input'); $this-&gt;log('prstNotifyCallBack', $notify_body); if ($notify_body) &#123; $data = json_decode($notify_body, true); if ($data['code']===0 &amp;&amp; $data['items']) &#123; // 你的业务代码 &#125; &#125; else exit('empty php input flow');&#125; 查询持久化处理结果通过持久化处理 ID1http://api.qiniu.com/status/get/prefop?id=&lt;PersistentFop Id&gt; # z0.582b573845a2655db7679b5f 通过 PHP SDK12345678list($ret, $err) = $pfop-&gt;status($id); // $pfop 是持久化操作对象echo \"\\n====&gt; pfop xxxx status: \\n\";if ($err != null) print_r($err); else print_r($ret); 下载单文件下载 「公开」和「私有」下载链接的区别只是签名与否。 客户端1234567891011121314$.get('/get_down_link', &#123; 'id' : 1&#125;, function (res) &#123; if (res.status != '500') &#123; saveFile(res.link); &#125;&#125;);function saveFile(down_link)&#123; var a = document.createElement('a'); a.href = down_link; a.download = down_link; a.click();&#125;; 服务器123456789101112131415161718192021$this-&gt;validate($req, [ 'id' =&gt; 'required|integer|min:1']);$id = $req-&gt;get('id');// get the file key of this id in qiniu from db =&gt; $data if ($data) &#123; $uri = 'http://www.proj.com/' .$data['origin'] .'?attname=' .$save_as; // 下载时保存到本地的文件名（中文名等请强制使用 `urlencode()` 编码） // if store in private buket (assume here) $link = $private ? $auth-&gt;privateDownloadUrl($uri, 7200) : $uri; return [ 'status' =&gt; 200, 'link' =&gt; $link ]; // auto json response&#125;return ['status' =&gt; 500]; 多文件打包下载当出现批量下载的需求的时候，就得先调用 pfop 处理成一个压缩包，然后再走单文件下载的思路就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public $qiniu_prst_query_api = 'http://api.qiniu.com/status/get/prefop?id=';protected $origin_buket = 'private';// yield the compress file with the res origin keys// Array $originspublic function yieldQiniuCompressFile($origins)&#123; if (is_array($origins) and $origins) &#123; $ak = env('QINIU_ACCESSKEY'); $sk = env('QINIU_SECRETKEY'); $auth = new Auth($ak, $sk); // 指定 buket 中存在的 要压缩的文件名 $key = $origins[0]['origin']; $pfop = new PersistentFop($auth, $this-&gt;origin_buket); // 压缩后的文件名 $zip_key = date('YmdHis').'.zip'; $fops = 'mkzip/2'; // 需要进行 zip 压缩的文件名 uri（包含第一个 $key 指定的文件） foreach ($origins as $k =&gt; $val) &#123; $org_url = $this-&gt;prvt_domain .$val['cc_origin'].'?attname='.$val['name'].'.'.$val['format']; $prvr_url = $auth-&gt;privateDownloadUrl($org_url, 3600); $fops .= '/url/' .\\Qiniu\\base64_urlSafeEncode($prvr_url); $fops .= '/alias/'.\\Qiniu\\base64_urlSafeEncode( $val['name'].'_'.$k.'.'.$val['format'] ); &#125; // 指定压缩文件保存的路径 $fops .= '|saveas/' . \\Qiniu\\base64_urlSafeEncode($this-&gt;origin_buket.':'.$zip_key); list($id, $err) = $pfop-&gt;execute($key, $fops); if (!$err) &#123; return [ 'prstId' =&gt; $id, 'resUrl' =&gt; $this-&gt;qiniu_prst_query_api.$id ]; &#125; &#125; return 500;&#125;// query persistent process res statuspublic function getQiniuPrstStatus(Request $req)&#123; $this-&gt;validate($req, [ 'resUrl' =&gt; 'required' ]); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $req-&gt;get('resUrl')); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $res = curl_exec($ch); return curl_errno($ch) ? 500 : $res;&#125; 唯一需要注意的一点是，上面的 key = $origins[0][&#39;origin&#39;] 仅仅为符合 pfop 操作的接口规格而存在，并没有实际的意义，但需要是操作空间中存在的资源的 key。（其实我是有点费解为啥要把接口这样定义绕） JS SDK上传&amp;回调1bower install qiniu 然后在服务器上新建一个 qiniu.html，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;qiniu test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"container\"&gt; &lt;a class=\"btn btn-default btn-lg \" id=\"pickfiles\" href=\"#\" &gt; &lt;i class=\"glyphicon glyphicon-plus\"&gt;&lt;/i&gt; &lt;span&gt;选择文件&lt;/span&gt; &lt;/a&gt;&lt;/div&gt;&lt;input type=\"hidden\" id=\"upToken\"&gt;&lt;script src=\"/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"/bower_components/plupload/js/moxie.js\"&gt;&lt;/script&gt;&lt;script src=\"/bower_components/plupload/js/plupload.dev.js\"&gt;&lt;/script&gt;&lt;script src=\"/bower_components/qiniu/dist/qiniu.js\"&gt;&lt;/script&gt;&lt;script&gt;var uploader = Qiniu.uploader(&#123; runtimes: 'html5,flash,html4', // 上传模式，依次退化 browse_button: 'pickfiles', // 上传选择的点选按钮，必需 // 在初始化时，uptoken，uptoken_url，uptoken_func三个参数中必须有一个被设置 // 切如果提供了多个，其优先级为uptoken &gt; uptoken_url &gt; uptoken_func // 其中uptoken是直接提供上传凭证，uptoken_url是提供了获取上传凭证的地址，如果需要定制获取uptoken的过程则可以设置uptoken_func // uptoken : '', // uptoken是上传凭证，由其他程序生成 // uptoken_url: 'http://api.example.com/qiniu/up_ticket', // Ajax请求uptoken的Url，强烈建议设置（服务端提供） uptoken_func: function()&#123; // 在需要获取uptoken时，该方法会被调用 var jqxhr = $.ajax(&#123; url: 'http://api.example.com/qiniu/up_ticket', type: 'GET', dataType: 'json', async: false, cors: true , headers: &#123; 'Access-Control-Allow-Origin': '*', 'AUTHORIZATION': 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1aWQiOjF9.SscwZjqXAkp1gY3eVBiMBpdtQhyfcV7V67UDNeacJhc' &#125;, success: function (res) &#123; &#125;, error: function (xhr, status) &#123; &#125; &#125;); return jqxhr.responseJSON.upToken; &#125;, get_new_uptoken: false, // 设置上传文件的时候是否每次都重新获取新的uptoken // downtoken_url: '/downtoken', // Ajax请求downToken的Url，私有空间时使用，JS-SDK将向该地址POST文件的key和domain，服务端返回的JSON必须包含url字段，url值为该文件的下载地址 unique_names: true, // 默认false，key为文件名。若开启该选项，JS-SDK会为每个文件自动生成key（文件名） // save_key: true, // 默认false。若在服务端生成uptoken的上传策略中指定了sava_key，则开启，SDK在前端将不对key进行任何处理 domain: 'static.hcmchi.com', // bucket域名，下载资源时用到，必需 container: 'container', // 上传区域DOM ID，默认是browser_button的父元素 max_file_size: '100mb', // 最大文件体积限制 flash_swf_url: '/bower_components/plupload/js/Moxie.swf', //引入flash，相对路径 max_retries: 3, // 上传失败最大重试次数 dragdrop: true, // 开启可拖曳上传 drop_element: 'container', // 拖曳上传区域元素的ID，拖曳文件或文件夹后可触发上传 chunk_size: '4mb', // 分块上传时，每块的体积 auto_start: true, // 选择文件后自动上传，若关闭需要自己绑定事件触发上传 //x_vars : &#123; // 查看自定义变量 // 'time' : function(up,file) &#123; // var time = (new Date()).getTime(); // do something with 'time' // return time; // &#125;, // 'size' : function(up,file) &#123; // var size = file.size; // do something with 'size' // return size; // &#125; //&#125;, init: &#123; 'FilesAdded': function(up, files) &#123; plupload.each(files, function(file) &#123; // 文件添加进队列后，处理相关的事情 &#125;); &#125;, 'BeforeUpload': function(up, file) &#123; // 每个文件上传前，处理相关的事情 &#125;, 'UploadProgress': function(up, file) &#123; // 每个文件上传时，处理相关的事情 &#125;, 'FileUploaded': function(up, file, info) &#123; // 每个文件上传成功后，处理相关的事情 // 其中info是文件上传成功后，服务端返回的json，形式如： // &#123; // \"hash\": \"Fh8xVqod2MQ1mocfI4S4KpRL6D98\", // \"key\": \"gogopher.jpg\" // &#125; // 查看简单反馈 // var domain = up.getOption('domain'); // var res = parseJSON(info); // var sourceLink = domain +\"/\"+ res.key; 获取上传成功后的文件的Url &#125;, 'Error': function(up, err, errTip) &#123; //上传出错时，处理相关的事情 &#125;, 'UploadComplete': function() &#123; //队列文件处理完毕后，处理相关的事情 &#125;, 'Key': function(up, file) &#123; // 若想在前端对每个文件的key进行个性化处理，可以配置该函数 // 该配置必须要在unique_names: false，save_key: false时才生效 var key = \"\"; // do something with key here return key &#125; &#125;&#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JS-SDK 上传完成后七牛云回调参数中没有文件名需要在 JS-SDK 获取上传凭证的时候定制一下 callbackBody 的格式： 123456789101112131415$policy = [ 'callbackUrl' =&gt; route('qiniu_upload_callback'), # 1. 通过 JSON 格式 'callbackBody' =&gt; json_encode([ // 'name' =&gt; '$(fname)', // 'hash' =&gt; '$(etag)', 'fkey' =&gt; '$(key)', 'us_id' =&gt; $this-&gt;req-&gt;us_id, 'id' =&gt; $this-&gt;req-&gt;id, ]), # 2. 通过 URL 参数对形式 // 'callbackBody' =&gt; 'fkey=$(key)&amp;us_id='.$this-&gt;req-&gt;us_id.'&amp;id='.$this-&gt;req-&gt;id,]; 然后再回调中解析出来： 1$callbackBody = file_get_contents('php://input'); 注意回调这里收到的参数格式和上传策略（$policy）中定义的 callbackBody 是一样的，因此如果是使用 URL 参数的形式传过去的，接受的时候就不要用 json_decode来解析了。 三种方式指定上传后的文件名 JS-SDK 中指定 unique_names 为 true，由 JS-SDK 指定。 上传策略中指定 callbackFetchKey，然后在七牛回调应用服务器的时候由应用服务端指定。 服务端生成上传凭证的时候，在上传策略中指定 save_key，该 key 就是最终上传的文件名。 多个 uploader 返回值不一致问题png/jpg 和 rar/zip 格式的文件上传成功后，返回值不一致。 png/jpg 上传成功后其 key 为 JSON.parse(info.response).key ， 而 rar/zip 上传成功后其 key 在 file.target_name 中。 官方 API接口连贯操作同处理接口下的连贯操作12# 通过 K/Vhttp://static.eme168.com/12c8da59f1203ccc99beedd31d9dd02214759391349863.jpg?imageMogr2/thumbnail/!80p/crop/x300 不同处理接口下的连贯操作12# 通过管道符 |http://static.eme168.com/12c8da59f1203ccc99beedd31d9dd02214759391349863.jpg?imageMogr2/thumbnail/!30p|imageMogr2/crop/x300 和 PHP SDK 一致上面 URL 后面的参数，比如 imageMogr2/thumbnail/!80p/crop/x300，这个和在 PHP SDK 中触发持久化时传递的操作名是一致的。 可能遇到的坑获取含有空格文件名的图片信息这个坑在于，当使用 &lt;download_url?imageInfo&gt; 在浏览器实时测试时是发现不了的，因为浏览器（Chrome）默认已经处理过了，只有使用 SDK（PHP-SDK）时才能发现，这时候需要按照浏览器自动转换的格式，把空格编码成 %20 即可。 12$file = 'abcd 中文.png';$uri = rawurlencode($file).'?imageInfo'; -- not `urlencode()` FAQ PHP-SDK 上传文件时触发持久化操作，在文件大于 20M 后持久化操作失败 出现此情况的原始持久化操作为：imageslim|imageMogr2/crop/x1170。这是七牛暂时没有处理好的地方。 解决办法是，连个持久化顺序调换：imageMogr2/crop/x1170|imageslim。原因是： 这种方式 认为 imageslim 是异步，但是 imageMogr2 是同步了，导致 imageMogr2 处理失败了。 原本是同步处理的 imageMogr2 操作会不允许大于 20M 的文件直接处理，会允许异步的 imageMogr2 操作，这里看起来应该是系统将管道中的处理 也认为是 同步处理了。 换个顺序应该是 imageMogr2 被认为是异步的，大于 20M 可以处理，处理的结果应该会小于 20M，所以 imageslim 即使是同步也可以被处理成功。 参考 七牛开发者中心 处理结果另存(saveas) 上传文件七牛回调时没有传回文件名","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"},{"name":"Qiniu","slug":"Qiniu","permalink":"http://blog.caoxl.com/tags/Qiniu/"},{"name":"七牛","slug":"七牛","permalink":"http://blog.caoxl.com/tags/七牛/"}]},{"title":"微信公众号「开发日志」","slug":"WeChat-Subscription-Notes","date":"2018-01-23T00:59:13.000Z","updated":"2019-08-22T06:46:29.000Z","comments":true,"path":"2018/01/23/WeChat-Subscription-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/23/WeChat-Subscription-Notes/","excerpt":"简单总结下微信 Web 开发流程。 该博客配合微信公众号开发文档使用。","text":"简单总结下微信 Web 开发流程。 该博客配合微信公众号开发文档使用。 基本概念前提 熟悉服务器后端开发 有公网 IP 且 80 端口（http）或 443 端口（https）可访问的服务器 简介 基本认识 订阅号主要偏于为用户传达资讯（类似报纸杂志），认证前后都是每天只可以群发一条消息。 服务号主要偏于服务交互（类似银行，114，提供服务查询），认证前后都是每个月可群发4条消息。 企业号主要用于公司内部通讯使用，需要先有成员的通讯信息验证才可以关注成功企业号。 1、如果想简单的发送消息，达到宣传效果，建议可选择订阅号； 2、如果想进行商品销售，进行商品售卖，建议可申请服务号； 3、如果想用来管理内部企业员工、团队，对内使用，可申请企业号。 4、订阅号可通过微信认证资质审核通过后有一次升级为服务号的入口，升级成功后类型不可再变。 5、服务号不可变更成订阅号。 http://kf.qq.com/faq/120911VrYVrA130805byM32u.html 申请流程 到 https://mp.weixin.qq.com 点击「立即注册」后，按需求和流程注册即可。 工作原理 整个过程只有 3 个角色：用户、微信和公众号。 用户通过微信端入口，把各种请求发送到微信服务器，微信服务器将用户请求封装成一定格式的数据包，以 GET/POST 的方式转发到发到公众号所在的应用服务器，应用服务器解析数据包，以完成相应的逻辑，并将处理结果返回按照一定的格式返回给微信，微信再返回给用户。 API 介绍 微信公众平台API文档 微信界面交互接口/微信公众号的使用模式 有两种定义方式： 1、通过界面/编辑模式： 登录微信公众号后，选择 「功能」=&gt;「自定义菜单」2、通过开发者接口/开发者模式： 登录微信公众号后，选择 「开发」=&gt;「基本配置」=&gt; 「启用」 两种只能选择其一。要进入微信平台的编辑模式需要先关闭开发者模式，但是编辑模式的功能远不如开发者模式。 事件推送 推送类型介绍 关注和取消关注 订阅事件推送 如何响应事件推送 数据交互 XML。 模版消息：详见手册。 消息收发：详见手册。 网页授权：详见手册。 接入应用填写服务器配置 URL 是正在开发的应用，所运行的业务服务器上，用来接收微信消息和事件的接口地址。 必须是一个具体的接口地址，而不是只填写服务器 IP，比如：http://www.myapp.com/weixin.php。 Token 用于接入微信时，生成签名以验证安全性使用。内容可自定义。 该 Token 一般保存在应用服务器上，当微信服务器请求应用服务器接口 URL 时，连同请求中包含的 timestamp、nonce 一起生成一个签名，并和请求中的 signature 对比。 EncodingAESKey 是一个秘钥，用于加解密微信服务器和应用服务器之间传递的消息体。可自定义，也可由微信随机生成。 消息加解密方式 有三种选择，详见微信公众号设置，一般开发期选择「兼容模式」。 模式的选择，与服务器配置在提交后都会立即生效。 验证消息是否来自微信服务器这个是验证，对上一步服务器配置中的 URL 请求来源，是否是微信服务器。 服务器配置好提交后，微信服务器会发送一个 GET 请求到这个 URL。 这个请求中包含了 4 个参数，使用这 4 个参数校验的过程示例如下： 1234567891011121314151617181920function weixinSignatureCheck() &#123; $signature = $_GET['signature']; $timestamp = $_GET['timestamp']; $nonce = $_GET['nonce']; $echostr = $_GET['echostr']; $token = TOKEN; // 假设这个常量已经正确代表了上述配置中填写的 Token $tmp_arr = [$timestamp, $nonce, $token]; sort($tmp_arr) ; // 加密／校验流程 // 1. 将token、timestamp、nonce三个参数进行字典序排序 // 2. 将三个参数字符串拼接成一个字符串进行sha1加密 // 3. 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 $tmp_str = sha1(implode($tmp_arr)); // 若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败 if ($signature == $tmp_str) &#123; echo $echostr; &#125;&#125; 根据接口文档实现相应需求当开发者身份验证通过之后，即代表我们自己的应用服务器接入微信成功，下次请求就不会再传入 echostr 这个参数了。 之后，便可以使用开发者身份调用微信公众号提供的接口完成相应业务逻辑了。 通信格式微信服务器转发过来的消息包格式统一为 XML，我们的服务器需要自行解析数据包，根据数据包的不同内容完成相应的逻辑。 1234567891011121314151617181920212223242526272829303132/ 微信入口function index() &#123; if (isset($_GET['echostr'])) &#123; weixinSignatureCheck(); &#125; else &#123; response(); &#125;&#125;// 获得微信数据包并解析function response() &#123; # 1. get well-formed XML string // $raw_data = $GLOBALS[ 'HTTP_RAW_POST_DATA' ]; // before php5.6 $raw_data = file_get_contents('php://input'); // after php5.6 # 2. transform xml to php object $data = simplexml_load_string($raw_data); switch (strtolower($data-&gt;MsgType)) &#123; case 'event': responseEvent($data); break; case 'text': responseText($data); break; case 'image': responseNews($data); break; default: break; &#125;&#125; access_token是公众号调用微信各个接口都需要用到的「全局、唯一票据」。或者说，access_token 相当于一把钥匙，只有拥有这把钥匙才能获取微信的一些开放接口。 与 appid/appsecret 的关系access_token 由 appid 和 appsecret 生成，而 appid 和 appsecret 相当于是开发者在微信公众平台的唯一标识。 特点 唯一有效性 全局有效性 动态性 access_token 的值是动态的，有效时间为 2 小时，并以最新生成的为准。当access_token 过期之后，就需要通过 appid 和 appsecret 去重新调用微信公众平台的公共开放接口去重新生成。 当获取到新的 accees_token 的时候，旧的 access_token 的时候理论上已经 失效了，但是微信为了防止某些数据的丢失，在很短的时间内还是可以使用 旧的 access_token;但是尽量使用新的。 调用次数有限：2000次/天。 因此可以把它保存到 Session、Memcache 或者数据库中，而不用每次都去重新生成。 参考：手册 =&gt; 「中控服务器」。 常用 API API 最新变化以手册为准。 可以参考手册手写，也可以在项目中引入微信提供的 SDK（方法/函数的集合 可以形象地理解为装满了常用 方法/API/函数 的袋子），实现快速开发。如果是手写，也建议把自己写的逻辑封装为自己的 SDK，方便复用。 调用所有微信开发接口时，均使用 https 协议。 用户关注/取消 此事件发生时，微信会把转发该事件到开发者填写的 URL，方便开发者给用户下发欢迎消息，或做账号的解绑。 123456789101112131415161718192021222324252627282930313233343536373839404142// 接受事件推送并响应function responseEvent($post_obj)&#123; # 获得数据包中的数据 # !!! 注意角色转换 这里的发送者和接收者是相对的 $to_user = $post_obj-&gt;FromUserName ; $from_user = $post_obj-&gt;ToUserName ; # !!! 注意回复事件推送的 msg_type 也是文本, 不要写成 event 或直接 $post_obj-&gt;MsgType $msg_type = 'text' ; $create_time = time() ; // !!! 注意这里必须是整数 # 判断是否是关注事件 if (strtolower($post_obj-&gt;Event) == 'subscribe') &#123; # 自定义回复内容 $content = &lt;&lt;&lt; CTT Aha ... 真厉害 ! 我都被你捉住啦 @_@ 欢迎关注我的微信公众号 ( &#123;$from_user&#125; ) 哦 ^_^CTT; &#125; # 指定保存回复内容的模板( 参考微信开发者手册, 注意内容的替换 ) # !!! CDATA 节中的中括号不能多也不能少 $tpl = &lt;&lt;&lt; TPL &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;/xml&gt;TPL; # 使用 sprintf() 将内容替换并填充到模板 # !!! 注意 sprintf() 中第一个参数后面的参数顺序必须和模板中的一致 $info = sprintf($tpl, $to_user, $from_user, $create_time, $msg_type, $content) ; # 服务器本地调试 // file_put_contents( 'response.txt' , $info.\"\\n\", FILE_APPEND ) ; echo $info ;&#125; 回复文本消息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 回复文本消息function responseText($post_obj)&#123; # 获得数据包中的数据 # !!! 注意角色转换 这里的发送者和接收者是相对的 $to_user = $post_obj-&gt;FromUserName ; $from_user = $post_obj-&gt;ToUserName ; $msg_type = $post_obj-&gt;MsgType ; $create_time = time() ; // !!! 注意这里必须是整数 # 根据用户发送的文本消息作出不同的回复内容( 不区分大小写 ) # 对用户输入的不同文本进行不同的处理 $text = strtolower(trim($post_obj-&gt;Content)) ; switch ($text) &#123; case '天气': case 'weather': case 'beijing': case '北京': responseWeather($post_obj, 'beijing') ; break ; case 'chongqing': case '重庆': responseWeather($post_obj, 'chongqing') ; break ; case 'shanghai': case '上海': responseWeather($post_obj, 'shanghai') ; break ; case 'guangzhou': case '广州': responseWeather($post_obj, 'guangzhou') ; break ; case 'shenzhen': case '深圳': responseWeather($post_obj, 'shenzhen') ; break ; case 'news': responseNews($post_obj) ; break ; case 'whoareu': $content = 'I am Chuanjiang Li, your best friends here. ^_^' . \"\\n\\n\" ; $content .= '我的个人主页是 : &lt;a href=\"http://cjli.info\"&gt;http://cjli.info&lt;/a&gt; 欢迎浏览哦 @_@' ; break ; case 'whoami': $content = 'Your OpenID is : '.$to_user ; break ; case 'now': $content = '当前北京时间 ( CST ) :' . \"\\n\\n\" ; $content .= date('Y 年 m 月 d 日 H:i:s', time()) ; break ; case '我爱你': case 'I Love You': $content = '是吗 *_* 我更爱你哦~~~ $_$' ; break ; case 'SB': case 'sb': case 'wocao': case 'wc': $content = $text . ' 是什么 -_-' ; break ; case '笨蛋': case '傻逼': $content = $text . '骂谁呢 :(' ; break ; case '你真笨': case '你怎么这么笨': case '你好笨': case '笨死了你': $content = '555 ): 你才笨, 人家只是萌好嘛 -: -' ; break ; default: $content = '' ; if (is_numeric($text)) &#123; $content .= '你输入了一个数字, 嗯 ... 那 ' ; $content .= $text . ' 是什么意思呢 ·_·' ; break ; &#125; $content .= '哎呀 ... 人家没听懂你的意思嘛 -_-# 换个说法呗 @_@' ; break ; &#125; # 指定保存回复内容的模板( 参考微信开发者手册, 注意内容的替换 ) # !!! CDATA 节中的中括号不能多也不能少 $tpl = &lt;&lt;&lt; TPL &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;/xml&gt;TPL; # 使用 sprintf() 将内容替换并填充到模板 # !!! 注意 sprintf() 中第一个参数后面的参数顺序必须和模板中的一致 $info = sprintf($tpl, $to_user, $from_user, $create_time, $msg_type, $content) ; # 服务器本地调试 // file_put_contents( 'response.txt' , $info.\"\\n\", FILE_APPEND ) ; echo $info ;&#125; 回复图文消息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 回复图文消息 * !!! 注意 : 多条图文消息信息，默认第一个item为大图；如果图文数超过10，则将会无响应 * 多图文的 description 不起作用; 单图文靠 title 来区分 */function responseNews($post_obj)&#123; $to_user = $post_obj-&gt;FromUserName ; $from_user = $post_obj-&gt;ToUserName ; # 回复图文时 msg_type 必须是 news $msg_type = 'news' ; $desc = &lt;&lt;&lt; CTT 如果您看到了图文框架的输出表明本次测试成功如果没有看到图片, 可能是由于网络原因导致获取过慢或失败欢迎反馈 ! ^_^\"CTT; $arr = array( array( 'title' =&gt; '微信公众号 lamCJ-0 图文消息回复测试-1' , 'description' =&gt; $desc , 'pic_url' =&gt; 'http://cjli.coding.me/images/default_avatar.jpg' , 'url' =&gt; 'https://mp.weixin.qq.com' ) , array( 'title' =&gt; '微信公众号 lamCJ-0 图文消息回复测试-2' , 'description' =&gt; $desc , 'pic_url' =&gt; 'http://cjli.coding.me/images/default_avatar.jpg' , 'url' =&gt; 'https://mp.weixin.qq.com' ) , array( 'title' =&gt; '微信公众号 lamCJ-0 图文消息回复测试-3' , 'description' =&gt; $desc , 'pic_url' =&gt; 'http://cjli.coding.me/images/default_avatar.jpg' , 'url' =&gt; 'https://mp.weixin.qq.com' ) ) ; $tpl = '&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;ArticleCount&gt;'.count($arr).'&lt;/ArticleCount&gt; &lt;Articles&gt;' ; foreach ($arr as $k =&gt; $v) &#123; $tpl .= '&lt;item&gt; &lt;Title&gt;&lt;![CDATA['.$v['title'].']]&gt;&lt;/Title&gt; &lt;Description&gt;&lt;![CDATA['.$v['description'].']]&gt;&lt;/Description&gt; &lt;PicUrl&gt;&lt;![CDATA['.$v['pic_url'].']]&gt;&lt;/PicUrl&gt; &lt;Url&gt;&lt;![CDATA['.$v['url'].']]&gt;&lt;/Url&gt; &lt;/item&gt;' ; &#125; $tpl .= '&lt;/Articles&gt; &lt;/xml&gt;' ; $info = sprintf($tpl, $to_user, $from_user, time(), $msg_type) ; // !!! 回复图文消息不需要 Content 参数 echo $info ; // file_put_contents( 'image.log', $info, FILE_APPEND ) ; exit ;&#125; 基础接口获得 access_token12345678910111213141516171819202122232425262728293031/** * 通过 CURL 获得 access_token * access_token 相当于获得调用微信公众接口权限而必须的动态令牌 * @return String access_token */function getAccessTokenByCurl()&#123; # 1. 初始化 curl $ch = curl_init() ; $appid = APP_ID ; // appid 和 appsecret 在 mp.weixin.qq.com 中获得 $appsecret = APP_SECRET ; $url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid='.$appid.'&amp;secret='.$appsecret ; # 2. 设置 curl 的参数 curl_setopt($ch, CURLOPT_URL, $url) ; curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1) ; // 将 curl_exec() 获取的信息以文件流的形式返回, 而不是直接输出 # 3. 采集 $output = curl_exec($ch) ; # 4. 关闭 curl curl_close($ch) ; # 5. 数据处理 if (curl_errno($ch)) &#123; file_put_contents('access_token.log', curl_errno($ch).\"\\n\", FILE_APPEND) ; &#125; $arr = json_decode($output, true) ; return $arr[ 'access_token' ] ;&#125; 获得微信服务器地址123456789101112131415161718192021222324/** * 获取微信服务器 IP * 可以作为安全性验证, 判断数据来源是否是微信服务器 * @param String $access_token * @return Array $arr */function getWXServerIPByCurl($access_token)&#123; $url = 'https://api.weixin.qq.com/cgi-bin/getcallbackip?access_token='.$access_token ; $ch = curl_init() ; curl_setopt($ch, CURLOPT_URL, $url) ; curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1) ; $output = curl_exec($ch) ; curl_close($ch) ; if (curl_errno($ch)) &#123; file_put_contents('wxsercerip.log', curl_errno($ch).\"\\n\", FILE_APPEND) ; &#125; $arr = json_decode($output, true) ; // true 表示把 JSON 数据转换为 PHP 数组 return $arr ;&#125; 小实例 在微信公众号中也可以使用第三方的 API，比如：http://apistore.baidu.com。 天气查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 天气查询响应 * @param [type] $post_obj [description] * @param [type] $city [description] * @return [type] [description] */function responseWeather($post_obj, $city)&#123; # 获得数据包中的数据 # !!! 注意角色转换 这里的发送者和接收者是相对的 $to_user = $post_obj-&gt;FromUserName ; $from_user = $post_obj-&gt;ToUserName ; $msg_type = $post_obj-&gt;MsgType ; $create_time = time() ; // !!! 注意这里必须是整数 $ch = curl_init(); $url = 'http://apis.baidu.com/heweather/weather/free?city='.$city ; $header = array( 'apikey: 32_BIT_API_KEY', ); // 添加 apikey到 header curl_setopt($ch, CURLOPT_HTTPHEADER, $header); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); // 执行HTTP请求 curl_setopt($ch, CURLOPT_URL, $url); $res = curl_exec($ch); $arr = json_decode($res, true)['HeWeather data service 3.0'][0] ; print_r($arr) ; $cnty = $arr[ 'basic' ][ 'cnty' ] ; $city = $arr[ 'basic' ][ 'city' ] ; $id = $arr[ 'basic' ][ 'id' ] ; $update = $arr[ 'basic' ][ 'update' ][ 'loc' ] ; $lon = $arr[ 'basic' ][ 'lon' ] ; $lat = $arr[ 'basic' ][ 'lat' ] ; $status = $arr[ 'now' ][ 'cond' ][ 'txt' ] ; $tmp = $arr[ 'now' ][ 'tmp' ] ; $wind_deg = $arr[ 'now' ][ 'wind' ][ 'deg' ] ; $wind_dir = $arr[ 'now' ][ 'wind' ][ 'dir' ] ; $wind_sc = $arr[ 'now' ][ 'wind' ][ 'sc' ] ; $wind_spd = $arr[ 'now' ][ 'wind' ][ 'spd' ] ; $hum = $arr[ 'now' ][ 'hum' ] ; $vis = $arr[ 'now' ][ 'vis' ] ; echo '&lt;hr&gt;' ; $content = &lt;&lt;&lt; CNTT &#123;$cnty&#125; &#123;$city&#125; ( 经度&#123;$lon&#125; 维度&#123;$lat&#125; ) &#123;$status&#125; &#123;$tmp&#125; °C &#123;$wind_dir&#125;&#123;$wind_deg&#125;° &#123;$wind_sc&#125;级 &#123;$wind_spd&#125;kmph 相对湿度 &#123;$hum&#125;% ; 能见度 &#123;$vis&#125;km 更新时间 : &#123;$update&#125; CST ( &#123;$id&#125; )CNTT; # 指定保存回复内容的模板( 参考微信开发者手册, 注意内容的替换 ) # !!! CDATA 节中的中括号不能多也不能少 $tpl = &lt;&lt;&lt; TPL &lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%s&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;/xml&gt;TPL; # 使用 sprintf() 将内容替换并填充到模板 # !!! 注意 sprintf() 中第一个参数后面的参数顺序必须和模板中的一致 $info = sprintf($tpl, $to_user, $from_user, $create_time, $msg_type, $content) ; # 服务器本地调试 // file_put_contents( 'weather_data.txt' , $arr.\"\\n\", FILE_APPEND ) ; echo $info ;&#125; FAQ如何获取更多接口？ 1、可以在公众平台网站中申请微信认证，认证成功后，将获得更多接口权限，满足更多业务需求。 2、微信认证暂不支持个人类型的公众帐号申请微信认证。 3、微信公众号认证需要 300 RMB / 次的手续费。 Web 开发时微信支付开发过程很繁琐？强烈建议参考的手册优先参考 微信支付文档，而不是 微信公众平台技术文档 中那个 JS-SDK 说明文档。 参考 网页授权获取用户基本信息 微信商户平台-微信支付 SDK 下载 微信公众平台-JSSDK 下载","categories":[{"name":"第三方应用","slug":"第三方应用","permalink":"http://blog.caoxl.com/categories/第三方应用/"}],"tags":[{"name":"第三方","slug":"第三方","permalink":"http://blog.caoxl.com/tags/第三方/"},{"name":"ThirdParty","slug":"ThirdParty","permalink":"http://blog.caoxl.com/tags/ThirdParty/"},{"name":"微信","slug":"微信","permalink":"http://blog.caoxl.com/tags/微信/"},{"name":"WeChat","slug":"WeChat","permalink":"http://blog.caoxl.com/tags/WeChat/"},{"name":"公众号","slug":"公众号","permalink":"http://blog.caoxl.com/tags/公众号/"}]},{"title":"MongoDB 简介","slug":"MongoDB-Intro","date":"2018-01-22T10:03:16.000Z","updated":"2019-08-22T06:29:18.000Z","comments":true,"path":"2018/01/22/MongoDB-Intro/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/MongoDB-Intro/","excerpt":"MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 简介关键词 开源 NoSQL 免费 良好的技术支持 因此，国内外许多互联网公司都已经采用了 MongoDB。","text":"MongoDB 是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。 简介关键词 开源 NoSQL 免费 良好的技术支持 因此，国内外许多互联网公司都已经采用了 MongoDB。 概念数据库什么是数据库？ 有组织地存放数据 按照不同的需求进行查询 不同数据库的区别就是，对存放数据的组织不同，同时也提供了不同的查询方式根据需求选择不同的数据库。 数据库分类关系型支持 SQL 语言的数据库，MySQL，Oracle 等。具有如下特点： 实时一致性 事务 多表联合查询 NoSql不支持 SQL 语言的数据库，Redis, MongoDB 等。特点如下: 简单便捷 方便扩展 更好的性能 MongoDBWhy MongoDB ? 无数据结构的限制 没有表结构的概念，每条记录可以有完全不同的结构（JSON） 业务开发方便快捷 无需事先定义存储结构关系型数据库需要先定义好表结构才能使用。MongoDB 的这种特点非常适合快捷开发和多变的业务需求。 完全的索引支持 类似 redis 的键值存储 类似 hbase 的单索引，二级索引需要自己实现 支持：单键索引、多键索引、数组索引、全文索引、地理位置索引。 全文索引还不支持中文。 MongoDB 被称为最接近 SQL 的 NoSQL 数据库。 方便的冗余与扩展 复制集保证数据安全 分片扩展数据规模 良好的支持 完善的文档 齐全的驱动支持 学习方向 mongo 索引 集合 复制集 分片 数据均衡 学习方向基本使用 最基本的文档读写、增删改 各种不同类型的索引创建与使用 复杂的聚合查询 对数据集进行分片，在不同的分片间维持数据均衡 数据备份与恢复 数据迁移 部署数据库服务 搭建简单的单机服务 搭建具有冗余容错功能的复制集 搭建大规模数据集群 完成集群的自动部署 简单运维 部署 MongoDB 集群 处理常见故障 单节点失效后如何恢复工作 数据库意外停止如何恢复数据 数据库发生拒绝服务时如何排查原因 数据库磁盘快满时如何处理 安装和配置下载安装 软件版本命名格式：a.b.c a 是大版本，重大更新 b 是稳定版和非稳定版 c 是小版本，性能提升和 bug 修复 12345678910# download from mongodb websitetar xzvf mongodb.xxx.tgz# clone from githubapt-get install zipunzip mongodb.zipcd /mongodb.xxx/apt-get install scons # scons 是替代 make 的另一种编译方式scons all -j 4 # -j 选项后面跟上 CPU 核数以加速编译过程 如果多次编译都不能通过，也可以直接到官网去下载编译好的可执行二进制文件。 如果 Linux 是 32 位的，这时为了方便建议直接使用包管理器安装：apt-get install mongodb。 Starting in MongoDB 3.2, 32-bit binaries are deprecated and willbe unavailable in future releases. 32 bit builds are limited to less than 2GB of data (or less with ­­journal). 搭建简单的 MongoDB 服务器12345678910111213141516mkdir mongo_server cd mongo_server mkdir datamkdir logmkdir conf-fmkdir bincp /path/to/mongo-xxx/mongod ./bin cd confvi mongod.conf port = 12345 dbpath = data # 存储数据的路径 logpath = log/mongod.log fork = true # true 表示启动后台进程 cd .../bin/mongod -f conf/mongod.conf cd data/lstail ../log/mongod.log 运行 MongoDB 服务器： 1mongod -f /etc/mongod.conf 如果不修改默认配置文件，那么执行 mongo 就可以直接进入 MongoDB 服务器了，进入后默认选择的数据库是 test。 但是如果修改了默认配置，就需要指定到正确的配置文件，比如修改了端口为 12345，那么在就需要带上新指定的端口号才能进入： 1mongo localhost:12345 连接 MongoDB 服务器主要有 2 种方式： mongodb 自带的客户端 mongodb 为各种编程语言提供的驱动程序 12345/path/to/mongo ip:port/dbname # 默认进入不需要认证# 关闭 Mongodb 服务器use admindb.shutdownServer() Kali 32 树莓派 2 上的 MongoDB 使用 apt-get 安装好之后，配置文件 默认在 /etc/mongod.conf，日志文件在 ：/var/log/mongodb/mongodb.log。 基本使用创建数据库123show dbsuse db_name 使用 use 切换数据库的时候可以没有创建该数据库，mongodb 会在合适的时候自动创建数据库。 删除数据库选择了某个数据库后，就可以进行如下操作： 1db.dropDatabase() 关系型数据库中的表在 mongodb 中被称为「集合」。（show collections &lt;=&gt; show tables） 注意： 插入数据的时候注意使用 JSON 格式的数据结构，使用可嵌套的键值对存储数据 字符串需要用引号括起来，插入数据后会自动创建数据库和 system.indexes 文件 查找数据1db.dbname_collectionname.find( &#123;x:1&#125; ) db.dbname_collectionname.findOne() 会看到一个 _id 字段的键值对，这是 mongodb 自动生成的 id，在全局范围内不会重复。 插入数据1db.dbname_collectionname1.insert(&#123; x:1 &#125;) db.dbname_collectionname2.insert(&#123; 'gender':'male' &#125;) 也可以使用 JS 语法在循环中插入数据： 123for ( i=3; i&lt;100;++i ) &#123; db.collectionname.insert( &#123;y:i&#125; )&#125; find() 后也可以跟上一些方法和条件，比如： count() 计数 skip() 跳过 limit() 限制条数 sort() 排序 1db.collectionname.find().skip(5).limit(3).sort(&#123;x:1&#125;) 方法后面必须有括号 ()。 创建集合1db.createCollection( 'collection_name' ) 更新数据1db.collectionname.update( &#123; x:1&#125;, &#123;x:222&#125; ) 部分更新1234db.collectionname.insert( &#123;x:1&#125;, &#123;y:22&#125;, &#123;z:333&#125; )# 仅更新 y 字段db.collectionname.update( &#123;z:333&#125;, &#123;$set: &#123;y:2222&#125;&#125; ) // 这里的 z:333 必须和插入的数据值相同否则更新无效 更新不存在的数据设置如果更新的数据不存在就写入这条数据： 1db.collectionname.update( &#123;x:1&#125;, &#123;x:1111&#125;, true ) 如果不设置为 true 那么更新不存在的数据的时候是不会有任何影响的。 更新多条数据为了防止 update 误操作，mongodb 默认 update 只会更新第一条 找到的数据。 如果要多记录更新，需要指定 update() 的第二个参数为 set 操 作，并且第四个参数为 true。 1db.collectionname.update( &#123;test:1&#125;, &#123;$set:&#123;test:1024&#125;&#125;, false, true ) 删除数据1db.collectionname.remove() // 可以不指定参数 remove() 默认会删除所有指定的数据记录，比如： 1db.test.remove( &#123;test:1024&#125; ) # 会删除所有 test 为 1024 的记录 删除集合(表)1db.collection.drop() 创建集合的索引在数据量较小的时候查询速度还可以，但是当数据记录量较大时，没有相关字段的索引，查询的速度将变得非常慢，甚至没有结果。 查看索引1db.collection.getIndexes() 创建索引1db.collection.ensureIndex(&#123; key:1 &#125;) 其中，键 key 代表的是排序方向，1 为正向排序，-1 为逆向排序。 关于索引和性能如果记录太多，创建索引的时间会比较长。 如果系统负载较重，且有很多已经存在的文档，不能使用 ensureIndex() 来动态创建索引，因为这样会极大影响数据库的性能，这种情况需要事先预料，并创建好相关索引。 上面创建好 key 的索引后，再次使用查询 key 的时候性能会大幅度提高。对于常见的查询，对其字段创建索引是非常有必要的。 由于索引是在插入数据后再次构建，所以在创建索引的时候可能会对数据库写入操作造成影响，但是为了查询的高效性，这点影响是可以接受的。 常见索引_id 索引 _id 是绝大多数集合默认建立的索引 对于每个插入的数据，mongodb 都会自动生成一条唯一的 _id 字段 单键索引 单键索引是最普通的索引 与 _id 不同，单键索引不会自动创建 比如，一条记录如果为：{x:1,y:2,z:3}。 在 x 字段上创建索引后，就可以使用 x 字段为条件进行查询。索引可以重复创建，对于已经存在的索引，再次创建时会直接返回成功。 多键索引多键索引与单键索引的创建形式相同，区别在于字段的数量。 单键索引： 值为一个单一的值，例如字符串，数字或者日期。 多键索引： 值具有多个记录，例如数组。 比如，db.test.insert({x:[1,2,3,4,5]})，执行该命令后，mongDB 会为 x 字段创建多键索引。 复合索引当我们的查询条件不止一个时，就需要建立复合索引。 123db.collection.ensureIndex(&#123;x:1, y:1&#125;)db.test.ensureIndex(&#123;x:1,y:2&#125;)db.test.find(&#123;x:1,y:2&#125;) 过期索引是在一段时间后会过期的索引。具有如下特点： 在索引过期后，相应的数据会被删除。 适合存储一段时间后会失效的数据，比如用户的登录信息，存储的日志等。 建立方法： 1234567db.collection.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds:10&#125;)db.test.ensureIndex( &#123;time:1&#125;, &#123;expireAfterSeconds:30&#125; ) db.test.insert( &#123;time:new Date()&#125; )db.test.find()# 30 秒后再次执行db.test.find() 可以发现，即使设置了 30 秒的生存时间，也会在 60 秒之后才被删除。 这是因为删除过程是由后台程序每 60 秒执行一次，而且删除本身也需要一些时间，所以存在误差。 限制 存储在过期索引字段的值必须是指定的时间类型。 必须是 ISODate 或 ISODate 数组，不能使用时间戳，否则不能被自动删除。 如果制定了 ISODate 数组，则按照最小的时间进行删除。（最小时间删除原则） 过期索引不能是复合索引 删除时间不是精确时间 全文索引对字符串与字符串数组创建全文可搜索的索引。 举例说明： 1&#123;author:'', title:'', article:''&#125; 则为其建立全文索引的方法： 123db.articles.ensureIndex(&#123;key:'text'&#125;)db.articles.ensureIndex(&#123;key_1:'text', key_2:'text'&#125;)db.articles.ensureIndex(&#123;'$**':'text'&#125;) 最后一条方法代表的是为该集合的所有字段建立一个全文索引。 然后就可以使用全文索引进行查询了： 1234db.articles.find(&#123;$text &#123;$search: 'coffee'&#125;&#125;)db.articles.find(&#123;$text &#123;$search: 'a b c'&#125;&#125;)db.articles.find(&#123;$text &#123;$search: 'a b -c'&#125;&#125;)db.articles.find(&#123;$text &#123;$search: '\\'a\\' b -c'&#125;&#125;) 可见使用全文索引查询不用再指定字段名。 MongoDB 中每个数据集合只允许创建一个全文索引。 a b c 之间默认是’或’关系，如果需要’与’关系的查找，则需要将每个独立 的关键字用引号括起来。当然，需要注意转义。 -c 代表不包含 c。 全文索引相似度通过 $meta 操作符：{score: {$meta: &#39;textScore&#39;}} 写在查询条件后面可以返回结果的相似度。与 sort 一起使用，可以达到很好的实用效果。 score 是一个数字，表征的是查询结果的相似度。 也可以在查询结果后面带上排序： 1db.articles.find( &#123;$text: &#123;$search:\"xxxx aaaa\"&#125;&#125;, &#123;score:&#123;$meta:\"textScore\"&#125;&#125; ).sort(&#123;score:&#123;$meta:\"textScore\"&#125;&#125;) 限制 每次查询，只能指定一个 $text 查询 $text 查询不能出现在 $nor 查询中 查询中如果包含了 $text，hint 不再起作用（hint 用来手工强制指定索引来测试索引的性能） 暂不支持中文。 地理位置索引将一些点的位置存储在 MongoDB 中，创建索引后，可以按照位置来查找其他点 分类 2d 索引： 用于存储和查找平面上的点 2dsphere 索引： 用于存储和查找球面上的点 查找方式 查找距离某个点一定距离内的点 查找包含在某区域内的点 2D 索引平面地理位置索引。 1db.collection.ensureIndex(&#123;w: ' 2d'&#125;) 位置表示方式：经纬度。 取值范围：经度[-180, 180]；纬度 [-90, 90] 查询方式 $near：查询距离某个点最近的点 $geoWithin：查询某个形状内的点 12345db.location.ensureIndex( &#123;\"w\":\"2d\"&#125; )db.location.insert( &#123;w:[180, 100]&#125; ) // 这样的点虽然能被创建但是会带来不可预知的错误，因此不要插入这样的点db.location.remove( &#123;w:[180, 100]&#125; ) // 删除不合法的地点db.location.insert( &#123;w:[180, 10]&#125; )db.location.find( &#123;w:&#123;$near:[1,1]&#125;&#125;, $maxDistance:10 ) 持 $minDistance 默认会查询 100 条结果。 形状的表示 $box：矩形 $center：圆形 $polygon：多边形 123456db.location.find( &#123;w:&#123;$geoWithin:&#123;$box:[0,0], [3,3]&#125;&#125;&#125; )和右边界// 参数是 2 个边界:左边界 // 圆心 + 半径db.location.find( &#123;w:&#123;$geoWithin:&#123;$center:[0,0], 5&#125;&#125;&#125; )db.location.find( &#123;w:&#123;$geoWithin:&#123;$polygon:[0,0], [3,3], [2, 4], [1, 5]&#125;&#125;&#125; ) // 多个点组成的多边形 geoNear 查询 geoNear 使用 runCommand 命令进行使用，常用使用如下： 12db.runCommand(&#123; geoNear: \"location\", near:[1,2], maxDistance:10, num:1 &#125; ) minDistance 对 2D 索引无效但是对 2dsphere 有效，num 限制返回的数据数目。 可见，geoNear 比 简单的 near 能够返回更多的数据 2dsphere球面地理位置索引。创建方式： 1db.collection.ensureIndex(&#123;w:'2dsphere'&#125;) 位置表示方式：getJSON 描述一个点，一条直线，多边形等形状。 1&#123;type: ' ', coordinates:[&lt;coordinates&gt;]&#125; 查询方式和 2d 索引查询方式类似，支持 $minDistance 与 $maxDistance。 2dsphere 还可以查询几个多边形的相交点。 索引构建情况分析 索引好处： 加快索引相关的查询。 索引坏处： 增加磁盘空间消耗，降低写入性能。 如何评判当前索引构建情况 mongostat 工具 查看 mongodb 运行状态： 123./mongostat -- helpmongostat -h 127.0.0.1:12345 // idx miss 对于性能我们主要关心的是 qr 和 qw，分别代表的是读写队列。而 idx miss 代表的是查询的时候没有使用到索引的百分比，越高则越需要作相应的处理。 profile 集合 123db.getProfilingStatus()db.getProfilingLevel() // 结果为 0 则代表 profile 是关闭的;为 1 的时候会记录所有 slowms 的操作db.setProfilingLevel( 2 ) // 2 代表记录所有操作 开启 profile 后，数据库中就会创建一个 system.profile 的集合。 然后查询： 1db.system.profile.find().sort(&#123;$natural:-1&#125;).limit(1) 注意：profile 的使用场景是上线前的测试阶段以及刚上线时的观察阶段，仅仅作为了解 系统状态的工具，因为当数据较多的时候它会占用很多资源，从而影响 MongoDB 的性能。 日志 1vi /etc/mongod.conf 可以用 verbose = vvvvv 来配置日志的详细程度，v 越多记录的日志越详细。 explain 分析 1db.test.find( &#123;x:1&#125; ).explain() 会得到一次操作中使用到的参数信息，比如是否使用索引，耗时等。 索引属性即创建索引时的格式： 1db.collection.ensureIndex(&#123;param&#125;, &#123;param&#125;) 其中，第二个参数变色索引的属性。 比较重要的属性有： 名字 name 指定：db.collection.ensureIndex({}, {name: &#39; &#39;})。 MongoDB 对字段名有长度限制，目前是 125 字节，可以为复合索引设置 name 简化字段命名。 1db.test.ensureIndex(&#123;x:1, y:1, z:1, m:1&#125;, &#123;name:\"normal_index\"&#125;) 然后就可以使用设置的名字来删除复合索引： 1db.test.dropIndex( \"normal_index\" ) 唯一性 unique 指定：db.collection.ensureIndex({}, {unique:true/false})。 利用 unique 可以实现 MySQL 中如果存在则不插入如果不存在则插入的功能。 稀疏性 sparse 指定：db.collection.ensureIndex({}, {sparse: true/false})。 mongoDB 默认创建的索引都是不稀疏的。稀疏性的不同代表了 MongoDB 处理索引中存在但是文档中不存在的字段时，会采取怎样的方法。 设置稀疏性索引不必为不存在数据的，但是被创建了索引的字段上建立索引，可以减少磁盘占用，提高插入速度。 稀疏索引的使用可能会带来一些隐患，因此往往配合 exists 操作符。 123456db.test.insert(&#123;\"m\":1&#125;)db.test.insert(&#123;\"n\":2&#125;)db.test.find(&#123;m:&#123;$exists:true&#125;&#125;) // 为 true 代表查找的是存在 m 的记录 db.test.ensureIndex(&#123;m:1&#125;,&#123;sparse:true&#125;) // 在 m 字段上创建稀疏索引 db.test.find(&#123;m:&#123;exists:false&#125;&#125;) // 查找不存在 m 的记录db.test.find(&#123;m:&#123;exists:false&#125;&#125;).hint( \"m_1\" ) // 强制使用稀疏索引则不会再找到 n 所在的记录 由于 MongoDB 在选取索引时如果发现是在稀疏索引上查找不存在的记录的时候，不会使用创建过的稀疏索引，因此，这里仍然会看到结果为 n 的记录。 因此，不能在稀疏索引上查找不存在的记录。 是否定时删除 expireAfrerSeconds 指定。 安全相关概览 最安全的是物理隔离，但是不现实 网络隔离其次 防火墙、IP 白名单其次 用户名密码最后 权限设置 auth 开启 keyfile 开启 默认情况 MongoDB 没有开启权限验证 12345678vi /etc/mongod.conf auth = true ps -ef | grep mongod | grep 12345kill pidmongod -f /etc/mongod.conf 此时查看日志就能够发现鉴权已开启：/auth。 但仅仅开启鉴权，进入 MongoDB 仍然不需要用户名和密码，因为还需要为 MongoDB 服务器创建用户名和密码，只有创建用户之后才能激活鉴权机制。 创建用户MongoDB 内建用户类型有： read readWrite dbAdmin dbOwner userAdmin 除了内建类型，还可以自定义角色类型。 1db.createUser(&#123;user:\"li\", pwd:\"enter\", customData:\"示例\",roles: [&#123;role:\"userAdmin\", db:\"admin\"&#125;, &#123;role:\"read\",db:\"test\"&#125;]&#125;) 创建成功后，依然可以无密码登录，但是在执行相应的操作时候会提示没有操作权限这时需要使用用户名和密码登录 1mongo -ip:port -u root -p pwd 此外，即使使用了用户名和密码登录，在操作有些集合的时候也不一定一定能操作成功，这要根据对具体集合的权限分配。 用户角色 数据库角色 read readWrite dbAdmin dbOwner userAdmin 集群角色 clusterAdmin clusterManger 备份角色 backup restore 其他特殊权限 DBAdminAnyDatabase 此外，还有 2 种不对外开放的权限：root 和 __system。 12345678910111213141516171819202122&#123; _id : \"myapp.appUser\", role : \"appUser\", db : \"myapp\", privileges : [ &#123; resource : &#123;db: \"myApp\", collection : \" \"&#125;, actions : [\"find\", \"createCollection\", \"dbStats\", \"collStats\"]&#125;, &#123; resource : &#123;db: \"myApp\", collection : \" logs \"&#125;, actions : [\"insert\"]&#125;, &#123; resource : &#123;db: \"myApp\", collection : \" data \"&#125;, actions : [\"insert\", \"update\", \"remove\", \"compact\"]&#125;, &#123; resource : &#123;db: \"myApp\", collection : \" system.indexes \"&#125;, actions : [\"find\"]&#125;, &#123; resource : &#123;db: \"myApp\", collection : \" system.namespaces \"&#125;, actions : [\"find\"]&#125; ], roles : [],&#125; 这是使用 createRole() 方法对自定义权限的配置，这样的方式更灵活，也更 方便管理员掌控 参考 SQL vs Nosql ：优劣大对比 8 种 NoSQL 数据库系统对比","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://blog.caoxl.com/tags/Database/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.caoxl.com/tags/MongoDB/"}]},{"title":"PHP 设计模式 简介","slug":"PHP-Design-Pattern-Intro","date":"2018-01-22T09:06:09.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/22/PHP-Design-Pattern-Intro/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/PHP-Design-Pattern-Intro/","excerpt":"简单记录下关于设计模式第一篇学习笔记。 设计模式的学习需要在工程中实践并思考，只看概念是永远不会懂的。 但是，学习设计模式，并不意味着迷信模式，照葫芦画瓢，而是要学习每种设计模式解决的问题，以及为什么这样要这样设计，以及这样设计的好与坏。现有设计模式不可能是所有问题的最优解，但至少能提供思路。 要学习的其实在遇到问题时，如何设计软件解决问题。 预备知识 OOP： 类与对象，魔术方法，链式操作等。 PSR 规范： 命名空间，自动载入类，单入口等等。 PHP 中可以使用 ArrayAccess 实现配置文件的加载。","text":"简单记录下关于设计模式第一篇学习笔记。 设计模式的学习需要在工程中实践并思考，只看概念是永远不会懂的。 但是，学习设计模式，并不意味着迷信模式，照葫芦画瓢，而是要学习每种设计模式解决的问题，以及为什么这样要这样设计，以及这样设计的好与坏。现有设计模式不可能是所有问题的最优解，但至少能提供思路。 要学习的其实在遇到问题时，如何设计软件解决问题。 预备知识 OOP： 类与对象，魔术方法，链式操作等。 PSR 规范： 命名空间，自动载入类，单入口等等。 PHP 中可以使用 ArrayAccess 实现配置文件的加载。 三种基本设计模式工厂模式由工厂方法（专门的类）生成对象，而不是直接在代码中 new。 常见使用场景有：在工厂方法中读取配置，生成可配置化的对象。 单例模式某个类的对象，在一次生命周期中，只允许创建一个。（比如数据库操作对象） 注册模式全局共享和交换对象。 OOP 基本原则单一职责一个类，只需要做好一件事。 开放封闭一个类，应该是可以被扩展的，但不可以被外界轻易修改的。 依赖倒置一个类，不应该强依赖另一个类，每个类对另一个类的依赖都是可替换的。 具有依赖关系的两个类之间需要通过依赖注入的方式去实现，而不要直接在类里面使用另一个类。 可配置化尽可能地使用配置，而不是硬编码。即，类与类之间的依赖关系最好是写到配置文件当中去，而不要在具体的类中定义或者引入。 面向接口编程只需要关心接口，不需要关心实现。 MVC 设计结构模型-视图-控制器，一种 C/S，B/S 软件工程的组织方式。 模型数据和存储的封装。 视图展现层的封装。（如模版文件） 控制器逻辑层的封装。 常用设计模式适配器模式可以将截然不同的函数接口封装成统一的 API。 常见使用场景有： PHP 的数据库操作扩展有 mysql, mysqli, pdo 3 种，可以用适配器模式统一成一致调用。 将 memcache, redis, file, apc 等不同的缓存函数，统一成一致调用。 策略模式将一组特定的行为和算法封装成类，以适应某些特定的上下文环境。 常见使用场景有：有一个电商网站，针对男女性用户各自跳转到不同的商品类目，并为其展示不同的广告。 使用策略模式可以实现 IoC，DI。 数据对象映射模式 是指将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作。 在代码中常见的应用场景比如，实现一个 ORM 类，将复杂的 SQL 语句映射成对象属性的操作。 观察者模式 是指当一个对象状态发生改变时，依赖它的对象全部回收到通知，并自动更新。 要实现一个事件发生后，要执行一连串的更新操作，传统的编程方式，就是在事件的代码后面直接加入处理逻辑。当更新的逻辑增多后，代码就变得难以维护。 这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件主体的代码。 使用观察者模式后，可以实现低耦合，非侵入式的通知与更新机制。 常见使用场景有： 在观察者类中实现数据更新事件的一系列更新操作。 装饰器模式 指的是，可以动态地添加修改类的功能。 一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重新实现类的方法。 使用装饰器模式，仅需要在运行时添加一个装饰器对象即可实现，可以实现最大的灵活性。 常见使用场景有： 在装饰器中实现权限验证，模版渲染，JSON 串化等。 迭代器模式 指的是，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素。 相比于传统的编程模式，迭代器模式可以隐藏遍历元素所需要的操作。 代理模式 指的是，在客户端与实体之间，建立一个代理对象，客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节。所谓的实体指的是，数据库中的实体数据。 Proxy 还可以与业务代码分离，部署到另外的服务器。业务代码中通过 RPC 来委派任务。 常见使用场景有： 实现数据库的主从自动切换。 参考 Github 示例代码","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.caoxl.com/tags/设计模式/"}]},{"title":"PHP SPL 简介","slug":"PHP-SPL-Intro","date":"2018-01-22T09:03:29.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/22/PHP-SPL-Intro/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/PHP-SPL-Intro/","excerpt":"每种语言应该都有自己的标准库，而 SPL 是 PHP 的标准库，一般编码中用得比较少，但是其提供的基本数据结构实现在解决相对复杂的应用场景还是很重要的。 What ? 用于解决典型，常见问题的一组接口与类的集合。 所谓的常见问题指的有： 数据结构（数学建模）： 解决数据怎么存储的问题 元素遍历： 数据怎么查看的问题。 常用方法的统一调用： 通用方法（数组或集合的大小）、自定义遍历等。 类定义在自动装载： 让 php 适合大型项目的管理需求，把功能的实现分散到不同的文件中。 类定义的自动装载解决的是项目程序在运行的时候自动判断什么时候需要什么类文件。","text":"每种语言应该都有自己的标准库，而 SPL 是 PHP 的标准库，一般编码中用得比较少，但是其提供的基本数据结构实现在解决相对复杂的应用场景还是很重要的。 What ? 用于解决典型，常见问题的一组接口与类的集合。 所谓的常见问题指的有： 数据结构（数学建模）： 解决数据怎么存储的问题 元素遍历： 数据怎么查看的问题。 常用方法的统一调用： 通用方法（数组或集合的大小）、自定义遍历等。 类定义在自动装载： 让 php 适合大型项目的管理需求，把功能的实现分散到不同的文件中。 类定义的自动装载解决的是项目程序在运行的时候自动判断什么时候需要什么类文件。 Basic Framework 数据结构 基础接口 基础函数 迭代器 异常 其他 SPL 基础函数autoload为了初始化 PHP 中的类对象，需要通过一定的方法寻找到类的定义。通常情况下，类会定一个在一个单独的文件中。 Yii 的延迟加载就用到了这个特性。 类载入的基本流程 先在当前文件中查找，如果找到，则初始化类，然后结束。 如果没找到，就依次调用 spl_autoload_register() 注册的方法去找，如果找到，就初始化类，然后结束。 如果没找到，就调用文件的 __autoload() 函数去找，如果找到就初始化类，然后结束。 如果还是没找到，就会抛出一个类找不到的异常。 迭代器 iterator_apply：为迭代器中的每个元素调用一个用户自定义函数。 iterator_count：计算迭代器中元素的个数。 iterator_to_array：将迭代器中的元素拷贝到数组。 类信息 class_implements：返回指定类实现的所有接口。 可以用 instanceof 判断某个对象是够实现了某个接口活着是某个类的实例。 class_parents：返回指定类的父类，如果继承了多次，则会把所有的父类都打印出来。 SPL 基础接口Countable继承该接口的类可以直接调用 count() 得到元素个数。 OuterIterator如果想迭代器进行一定的处理之后再返回，可以用这个接口。 IteratorIterator 是 OuterIterator 的实现，扩展的时候，可以直接继承 IteratorIterator，就可以实现最基本的操作 了。 RecursiveIterator可以对多层结构的迭代器进行迭代，比如遍历一棵树。 所有具有文件层次结构特点的数据都可以用这个接口遍历，比如文件夹。 关键方法 hasChildren：用于判断当前节点是否存在子节点。 getChildren：用于得到当前节点子节点的迭代器。 SPL 中实现该接口的类 RecursiveArrayIterator RecursiveCachingIterator Recursive 开头的类都能够进行多层次结构化的遍历。 SeekableIterator可以通过 seek 方法定位到集合里面的某个特定元素。seek 方法的参数就是元素的位置，从 0 开始算。 实现该接口的类 ArrayIterator DirectoryIterator FilesystemIterator：遍历文件系统。 GlobIterator RecursiveArrayIterator RecursiveDirectoryIterator SAP 迭代器What is Iterator ?怎样获得链表中每个节点的信息？ 通过某种统一的方式遍历链表活着数组中的元素的过程，叫做迭代遍历，而这种统一的遍历工具，就叫做迭代器。 遍历数组的时候，如果使用 foreach，其背后也是通过迭代器对象去执行遍历的。 Why using Iterator ?使用迭代器的目的都是为了遍历。 常用迭代器ArrayIterator 用于遍历数组 用于跳过某些元素（seek） 用于排序 AppendIterator按顺序迭代访问几个不同的迭代器，例如，希望在一次循环中迭代访问两个或更多的组合。 MultipleIterator用于把多个 Iterator 里面的数据组合成为一个整体来访问。 SPL 常用数据结构数据结构是与语言无关的，因为它解决的是数据在计算机中是如何存储、组织以及展示的问题。学习 SPL 常用数据结构的目的就是会用 SPL 里面提供的方法去间接操作数据结构。 SPL 提供的数据结构有： 双向链表 堆栈 队列 堆 降序堆 升序堆 优先级队列 定长数组 对象容器 其实并不需要亲自实现，程序员作为编程语言的使用者只是调用这些实现而已。（大致所有高级语言皆如此） 双向链表 bottom： 最先添加到链表中的节点叫做 Bottom，也称为头部。 top： 最后添加到链表中的节点叫做 Top，也称为尾部 链表指针： 是一个当前关注节点的标识，可以指向任意节点。 当前节点： 链表指针指向的节点称为当前节点。 节点 节点名称： 可以在链表中唯一标识一个节点的名称，我们通常又称为节点的 Key 或 Offset。 节点数据： 存放在链表中的应用数据，即 Value。 SplDoublyLinkedList 类 操作当前节点： rewind：使链表的当前指针指向链表的底部（头部）。 current：指向链表当前节点的指针，必须在调用之前先调用 rewind，当前节点被删除后，会指向一个空节点。 使用时注意判断 current 的值是否指向一个空节点。 next：使链表当前节点的指针指向下一个节点，current 的返回值会改变。 prev 增加节点： push：向链表的顶部（尾部）插入一个节点。 unshift：向链表的底部插入一个节点。 删除节点 pop：获取链表中的顶部节点，并且从链表中删除这个节点；此操作不会改变当前指针的位置。 shift：删除一个链表底部节点。 定位操作 bottom：获得链表底部元素，当前指针位置不变。 top：获得链表顶部元素，当前指针位置不变。 特定节点操作 offsetExists offsetGet offsetSet offsetUnset 堆栈堆栈和队列刚好相反，具有后进先出（FILO）特点的连续型数据结构。 SplStack继承自 SplDoublyLinkedList，操作如下： push： 压入堆栈。 pop： 弹出堆栈。 SplQueue继承自 SplDoublyLinkedList，操作如下： enqueue： 进入队列 dequeue： 退出队列 其他 SPL 类库 文件处理类库 SplFileInfo：用于获得文件的基本信息，比如修改时间、大小、目录等信息。 SplFileObject：用于操作文件的内容。 SplFixedArray： 定长数组。 SplMinHeap： 堆栈。（insert、extract） 参考 PHP标准库 (SPL) PHP SPL笔记 Github 示例代码","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"SPL","slug":"SPL","permalink":"http://blog.caoxl.com/tags/SPL/"},{"name":"标准库","slug":"标准库","permalink":"http://blog.caoxl.com/tags/标准库/"}]},{"title":"PHP 团队开发规范和 Git 使用规范","slug":"PHP-Team-Develop-Standard-And-Git-Standard","date":"2018-01-22T08:05:45.000Z","updated":"2019-08-22T07:08:09.000Z","comments":true,"path":"2018/01/22/PHP-Team-Develop-Standard-And-Git-Standard/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/PHP-Team-Develop-Standard-And-Git-Standard/","excerpt":"PHP 开发规范为什么？ 因为每个程序员都有自己的写代码的习惯, 很不利于团队开发,所以，对一个团队而言之所以需要这么一个规范主要是为了在软件开发过程中大家便于交流和协作。 简单来说:就是让一群代码风格不一样的人,能互相明白对方在写些什么鬼~~~","text":"PHP 开发规范为什么？ 因为每个程序员都有自己的写代码的习惯, 很不利于团队开发,所以，对一个团队而言之所以需要这么一个规范主要是为了在软件开发过程中大家便于交流和协作。 简单来说:就是让一群代码风格不一样的人,能互相明白对方在写些什么鬼~~~ 关于我们要采用的 PHP 开发规范，是采用的 PHP 互操作性框架制定小组（FIG）制定的 PHP-PSR ，也就是传说中的 PHP 标准规范 下面我要讲的，就是在这个的基础上简单总结出来的要点。主要有下面这些： 程序文件层面文件编码可以在各编程语言间通用的。UTF-8、不带字节序标记（BOM）。因为 字节序标记 会阻止应用程序设置它的头信息，从而影响 PHP 的输出。 换行符使用 Unix 格式换行符（LF）。 因为 PHP 基本上都是跑在 Linux 上的（其实大部分网络服务都是跑在 Linux 上的），LAMP，LNMP 这些被广泛采用的流行 Web 架构都是运行在 Linux 服务器上，而 Linux 衍生于 UNIX，所以使用 UNIX 换行符能从脚本文件层面上杜绝不必要的麻烦 麻烦在于: Windows 换行使用的是 CR＋LF（回车和换行），UNIX/Linux 使用的是 LF，Mac OS X 使用的是 CR， 虽然大部分现代编辑器和 IDE 都具有自动转换这种差异的功能，但是如果被不小心弄错，导致本地开发的换行格式和 Linux 服务器上的不一致，比如在 Windows 上开发好后没问题，但是一放到 Linux 服务器上后却不能正常运行，这很可能就是因为 Windows 下的文件到 Linux 上后每次换行的地方都多了一个回车符号被显式地，以字符串 \\M 的形式输出到原本的 PHP 脚本中，而这个 \\M 是 PHP 解析器无法理解的语言结构，因此导致解析错误。 用空行代替 PHP 结束标签PHP 结束标签 ?&gt; 对于 PHP 解析器来说是可选的，但是只要使用了，结束标签之后的空格有可能会导致不想要的输出，这个空格可能是由开发者或者用户又或者 FTP 应用程序引入的，甚至可能导致出现 PHP 错误，就算通过修改配置抑制输出 PHP 错误，仍然会出现空白页面。基于这个原因， 所有的 PHP 文件将不使用结束标签，而是以一个空行代替。 文件命名类名必须以大写开头的驼峰法命名，比如：SiteController.php，或带 .class 的下划线加小写命名，比如：site_controller.class.php。但是，同一个项目中，只能选用其一（下面所有可以有2种选择的都必须这样）。 默认推荐第一种，因为可以少敲几次键盘。 其他文件，比如视图、配置、一般的脚本文件等等只能使用小写加下划线命名，比如：home.html，admin_login.js，article_footer.css，site_config.php 等等。 文件夹和前缀同一个逻辑下面的程序文件放在同一个有意义名称的文件夹下，如果不得不放在一个文件夹，那么使用前缀来区分。 比如：system 控制器下的所有视图必须放在 views 文件夹下的 system 目录下。如果非要放在 views 文件夹下，那么必须要带上 system_ 前缀。默认采用第一种，因为可以缩短文件名。 代码层面命名 所有命名都要 见名知意！ 类名必须大写是开头的驼峰法（匈牙利命名法），比如：SiteController。 常量名必须是全大写，并且单词之间使用下划线，比如：APP_ROOT。 函数/方法名必须是小写打头的驼峰法或下划线＋小写，比如：getVersion() 和 get_version()。默认使用第一种，因为为了和 PHP 系统函数区分。 变量/属性名必须使用 $ 打头的下划线＋小写，比如：$order_by， $is_same_key，或者 驼峰法：$orderBy，$OrderBy。 上面含有多种可选方式的规范中，无论遵循哪种命名方式，都应该在一定的范围内保持一致。最好是同一个项目中只使用默认的一套，函数名和变量名不能使用同一套。 注释 在写代码的那一刻，只有程序员和上帝能看懂，写完之后，如果没有注释，就只有上帝能看懂了。 函数或方法名的注释必须在函数定义的上方，使用多行注释风格，每个方法必须要写注释。形如： 1234567891011121314151617181920212223/** * what this function do? * @para1 Type, like String * @para2 Type, like Boolean * @return Type, like Array * by @caoxl */ public static function getVersion(&amp;$arr, $flag=false)&#123; # step 1 ... // what this variable means? # step 2 ... // what should be noticed here? # step 3 if ( $flag ) &#123; ... // what does this line do ? &#125; elseif ( $cond ) &#123; ... // do something here &#125;&#125; 关于上面的示例代码，有几点需要说明的： 过程/流程注释使用 # 号，因为 # 有代表数字顺序都含义，所以适合描述步骤。 每行代码的注释写在同一行的右边，使用双斜线，上下行对齐。 关键字使用 PHP所有 关键字必须全部小写。包括常量关键字 true 、false 和 null 也必须全部小写。 所有类方法都必须添加访问修饰符。 需要添加 abstract 或 final 声明时， 必须写在访问修饰符前，而 static 则必须写在其后。 比如： 123456789101112131415161718&lt;?phpnamespace Vendor\\Package ;use OtherVendor\\OtherPackage\\OtherClass ;class Site&#123; abstract protected function drink() ; /** * what this function do ? */ final public static function getVersion() &#123; // do sth here &#125; &#125; 空格、行和花括号 控制结构的开始花括号({)必须写在声明的同一行，而结束花括号(})必须写在主体后自成一行。 类和方法的起始花括号都要自成一行。 使用逗号的地方，逗号前不能有空格而逗号后必须有空格。 函数名与紧跟的括号之际要有空格，函数括号与相邻的参数不能有空格。 代码必须使用4个空格符的缩进，一定不能用 tab键 。 因为不同的编辑器、IDE对 tab 键的理解不一样，有的是 4 个空格有的是8个空格，严格使用空格缩进可以避免这种差异带来的排版混乱。 每行不应该多于80个字符，大于80字符的行应该折成多行。 非空行后一定不能有多余的空格符。 每行一定不能存在多于一条语句。 其他方面 新项目默认选择最新稳定版。 开发工具：PHPStrom + Sublime Text/Atom。 PHP 版本：5.5+ (根据项目要求: 如江湖外卖要求 5.4-nts版本, Lumen API要求 7.1+) MySQL版本: 5.5+ (同上: 如Lumen API要求 5.7+) 最后，用一句话总结关于开发规范的话题： 统一开发规范的价值在于我们都遵循这个编码风格，而不是在于它本身。 Git 项目管理规范Git 工作流程大概有三种： Git 工作流（含功能分支，补丁分支，和预发分支） GitHub 工作流（只有一个长期分支） Gitlab 工作流（上游优先；区分开发环境，预发环境和生产环境）。 Developer 将涉及到的 Git 操作将会有： 拉取项目源码到本地 1git clone git@git.keensword.net:hp-php/hpmall.git 在 dev 分支基础上创建新分支 12git checkout dev # 确保在 dev 分支上git checkout -b taskname-developername 开发完成提交任务代码 12345678910111213141516171819# 1. 添加git add -A# // 或者部分: git add file1 file2 ...# 2. 提交git commit -m \"comments for this commit that make sense\" # // 或者使用 git commit 进入 vim 编辑器书写详细注释# 3. 拉取最新 dev 分支代码并合并git fetch origin dev # 若使用的是别名请把 origin 改为你设置的别名git merge origin/dev # 若出现冲突请与其他开发者协商解决# // 也可以用 git pull origin dev 一步到位但是不推荐因为当代码出错很难 debug# 4. 查看当前是否存在没提交的文件git status# // 如果有则重复 1 和 2 然后到 5# 5. 确认无冲突后提交到 gitlabgit push origin taskname-developername 在 Gitlab 上发起 Merge Request Source Branch 一定是自己的任务分支，Target Branch 一定是项目的 dev 分支。 一次任务完成后删除上次创建的本地任务分支 1git branch -d taskname-developername 每次做任务的时候建议都删除旧的任务分支然后新建新任务分支。 项目负责人将涉及的额外工作 决定是否接受开发者的合并请求、拒绝未与 dev 最新代码合并的合并请求。 定期将 dev 分支上的最新代码给上面组长或技术总监 review，如果都满意后将合并到 master 分支。 将 master 分支的代码部署、并定期更新到服务器。 团队建设所以简单总结了以下几句话： 提交效率，减少加班。 加强沟通，取长补短。 研究技术，共同进步。 参考 PHP-The Right Way PHP 之道 PHP 标准规范 Git 使用规范流程 Git分支管理策略 常用 Git 命令清单 Book 《Clean Code》","categories":[{"name":"Caoxl","slug":"Caoxl","permalink":"http://blog.caoxl.com/categories/Caoxl/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.caoxl.com/tags/Git/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"规范","slug":"规范","permalink":"http://blog.caoxl.com/tags/规范/"}]},{"title":"PHP 「安装日志」","slug":"PHP-Install-Dev-Log","date":"2018-01-22T07:29:39.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/22/PHP-Install-Dev-Log/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/PHP-Install-Dev-Log/","excerpt":"总结一些和PHP有关的 「 安装 」 PECL PECL 的全称是 The PHP Extension Community Library ，是一个开放的并通过 PEAR(PHP Extension and Application Repository，PHP 扩展和应用仓库)打包格式来打包安装的 PHP扩展库仓库。通过 PEAR 的 Package Manager 的安装管理方式，可以对 PECL 模块进行下载和安装。 PHP Extension Community Library。提供了一个 PHP 所有已知扩展的下载和托管目录，比如 fileinfo, APC, Xdebug 等，采用 C 语言编写。","text":"总结一些和PHP有关的 「 安装 」 PECL PECL 的全称是 The PHP Extension Community Library ，是一个开放的并通过 PEAR(PHP Extension and Application Repository，PHP 扩展和应用仓库)打包格式来打包安装的 PHP扩展库仓库。通过 PEAR 的 Package Manager 的安装管理方式，可以对 PECL 模块进行下载和安装。 PHP Extension Community Library。提供了一个 PHP 所有已知扩展的下载和托管目录，比如 fileinfo, APC, Xdebug 等，采用 C 语言编写。 PEAR待更新:http://blog.cjli.info/2017/01/12/All-About-Installations-Relate-To-PHP/","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Install","slug":"Install","permalink":"http://blog.caoxl.com/tags/Install/"}]},{"title":"PHP 环境问题汇总","slug":"PHP-Env-FAQ","date":"2018-01-22T07:06:15.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/22/PHP-Env-FAQ/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/PHP-Env-FAQ/","excerpt":"在开发部署 PHP 项目过程中总会遇到一些环境相关的问题，这里简单记录下来。","text":"在开发部署 PHP 项目过程中总会遇到一些环境相关的问题，这里简单记录下来。 nginx 连接 php-fpm 的两种方式php-fpm 的启动方式有两种： TCP sockets就是常见的，也是 php-fpm 默认的启动方式：监听本机 9000 端口，通过 TCP 协议通信。 UNIX domain sockets Unix domain socket 或者 IPC socket是一种终端，可以使同一台操作系统上的两个或多个进程进行数据通信。与管道相比，Unix domain sockets 既可以使用字节流和数据队列，而管道通信则只能通过字节流。Unix domain sockets的接口和Internet socket很像，但它不使用网络底层协议来通信。Unix domain socket 的功能是POSIX操作系统里的一种组件。 Unix domain sockets 使用系统文件的地址来作为自己的身份。它可以被系统进程引用。所以两个进程可以同时打开一个 Unix domain sockets 来进行通信。不过这种通信方式是发生在系统内核里而不会在网络里传播。 TCP vs UNIX Socket When you are using TCP, you are also using the whole network stack. Even if you are on the same machine, this implies that packets are encapsulated and decapsulated to use the network stack and the related protocols. If you use unix domain sockets, you will not be forced to go through all the network protocols that are required otherwise. The sockets are identified solely by the inodes on your hard drive. Beware though that sockets are only reachable from programs that are running on the same server (there’s no network support, obviously) and that the programs need to have the necessary permissions to access the socket file. 在服务器压力不大的情况下，tcp 和 socket 差别不大，但在压力比较满的时候，用套接字方式，效果确实比较好。 php-fpm 配置修改 /usr/local/php/etc/php-fpm.conf 文件，换掉注释： 1234;listen = 127.0.0.1:9000listen = /dev/shm/php-cgi.socklisten.owner = wwwlisten.group = www 由于权限问题很多人使用路径 /tmp，但路径 /dev/shm 是个 tmpfs，速度比磁盘快得多。 至于权限问题，可以在 php-fpm.conf 中指定所有者和所有组决定。否则生成的 /dev/shm/php-cgi.sock 是 root 所有的，PHP 没有权限访问。 最后重启 php-fpm：service php-fpm restart。可以查看是否成功： 123lsof -i:9000 # nothingls -al /dev/shm nginx 配置可以对虚拟主机的 server 字段进行配置： 1234567891011121314location ~ [^/]\\.php(/|$) &#123; #fastcgi_pass 127.0.0.1:9000; fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf;&#125;# 或者创建一个配置文件 php5-fpm.confupstream php5-fpm-sock &#123; server unix:/var/run/php5-fpm.sock;&#125;# 引入 nginx 后在 nginx `Server` 字段中引入fastcgi_pass php5-fpm-sock; 最后重启 nginx：service nginx restart。 出现 “神奇的” 40x/50x 错误 ？ 安装的 php-fpm 版本和 php -v 是否一致？（500） Nginx 配置是否有误？路径是否存在？（403） CLI 下测试入口文件是否有报错？（502） composer vendor 目录是否安装完整？（autoload class） 检查错误日志（php.ini =&gt; php_errors） 扩展Xdebug xdebug must be loaded as a zend extension in unknown on line 0? 需要在 php.ini 中改变引入扩展的指令为 zend_extension： 1zend_extension = \"xdebug.so\" 然后重启 php-fpm 或者 apache。 12345service php-fpm restartor:apache httpd restart FAQ 如何查看操作系统字符集？ 在 Windows 平台下，命令提示符中输入 chcp 可以得到操作系统的代码页信息，你可以从控制面板的语言选项中查看代码页对应的详细的字符集信息。 例如：我的活动代码页为 936，它对应的编码格式为 GBK。（简体中文的 Windows 字符编码是 GBK） 参考 使用socket方式连接Nginx优化php-fpm性能 Performance of unix sockets vs TCP ports","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"http://blog.caoxl.com/tags/配置/"}]},{"title":"Nginx 优化","slug":"Nginx-Optimization","date":"2018-01-22T07:00:33.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/22/Nginx-Optimization/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/Nginx-Optimization/","excerpt":"关于 Nginx 优化实际实践记录在这里。 下列配置可以放在 nginx.conf 的 http 块中，也可以放到虚拟主机的 server 块中。根据情况配置。","text":"关于 Nginx 优化实际实践记录在这里。 下列配置可以放在 nginx.conf 的 http 块中，也可以放到虚拟主机的 server 块中。根据情况配置。 启用压缩1234567891011121314151617# 开启gzipgzip on;# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩gzip_min_length 1k;# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明gzip_comp_level 2;# 进行压缩的文件类型 (javascript有多种形式 其中的值可以在 mime.types 文件中找到)gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml;# 是否在 http header 中添加 Vary: Accept-Encoding，建议开启gzip_vary on;# 禁用IE 6 gzipgzip_disable \"MSIE [1-6]\\.\"; 响应与超时12345678910111213141516171819202122232425262728293031sendfile on;tcp_nopush on;keepalive_timeout 65;client_max_body_size 50m; # 缓冲区代理缓冲用户端请求的最大字节数,可以理解为保存到&gt;本地再传给用户client_body_buffer_size 256k;client_header_timeout 3m;client_body_timeout 3m;send_timeout 3m;proxy_connect_timeout 300s; # nginx跟后端服务器连接超时时间(代理连接超时)proxy_read_timeout 300s; # 连接成功后，后端服务器响应时间(代理接收超时)proxy_send_timeout 300s;proxy_buffer_size 64k; # 设置代理服务器（nginx）保存用户头信息的缓冲区大小proxy_buffers 4 32k; # proxy_buffers缓冲区，网页平均在32k以下的话，这样设置proxy_busy_buffers_size 64k; # 高负荷下缓冲大小（proxy_buffers*2）proxy_temp_file_write_size 64k; # 设定缓存文件夹大小，大于这个值，将从upstream服务器传递请求，而不缓冲到磁盘proxy_ignore_client_abort on; # 不允许代理端主动关闭连接","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/categories/Nginx/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.caoxl.com/tags/服务器/"},{"name":"优化","slug":"优化","permalink":"http://blog.caoxl.com/tags/优化/"},{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"}]},{"title":"Nginx 反向代理","slug":"Nginx-Reverse-Proxy","date":"2018-01-22T06:50:19.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/22/Nginx-Reverse-Proxy/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/Nginx-Reverse-Proxy/","excerpt":"或名：不同域名通过一台服务器上的 80 端口访问同一台服务器上的不同站点。 环境和需求 一台 CentOS 主机上同时运行着 3 台服务器：Nginx、Apache、Tomcat，分别监听 80、8000、8080 端口，其中 Apache 托管了一个 PHP 站点 A，Tomcat 托管了一个 Java 站点 B。 现有域名 test.com 和 demo.com，需要实现的是： 在浏览器中输入 test.com 后直接(不加额外端口号) 访问站点 A；输入 demo.com 后直接访问站点 B。","text":"或名：不同域名通过一台服务器上的 80 端口访问同一台服务器上的不同站点。 环境和需求 一台 CentOS 主机上同时运行着 3 台服务器：Nginx、Apache、Tomcat，分别监听 80、8000、8080 端口，其中 Apache 托管了一个 PHP 站点 A，Tomcat 托管了一个 Java 站点 B。 现有域名 test.com 和 demo.com，需要实现的是： 在浏览器中输入 test.com 后直接(不加额外端口号) 访问站点 A；输入 demo.com 后直接访问站点 B。 具体配置 vi /etc/nginx/nginx.conf 不全，但是都是会改动的地方，不同的环境下的配置可能会有些许不同。参考如下： 1234567891011121314151617181920212223242526272829303132333435363738worker_rlimit_nofile 1024;events &#123; use epoll; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; # reverse proxy configuration changed by @cjli in 2016-03-13 14:50:21# ----------------------------------------------- start ---------------------------------------------- client_max_body_size 50m; # 缓冲区代理缓冲用户端请求的最大字节数,可以理解为保存到本地再传给用户 client_body_buffer_size 256k; client_header_timeout 3m; client_body_timeout 3m; send_timeout 3m; proxy_connect_timeout 300s; # nginx跟后端服务器连接超时时间(代理连接超时) proxy_read_timeout 300s; # 连接成功后，后端服务器响应时间(代理接收超时) proxy_send_timeout 300s; proxy_buffer_size 64k; # 设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; # proxy_buffers缓冲区，网页平均在32k以下的话，这样设置 proxy_busy_buffers_size 64k; # 高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; # 设定缓存文件夹大小，大于这个值，将从upstream服务器传递请求，而不缓冲到磁盘 proxy_ignore_client_abort on; # 不允许代理端主动关闭连接# ----------------------------------------------- end ----------------------------------------------- # PHP conf here ... # Load config files from the /etc/nginx/conf.d directory include /etc/nginx/conf.d/*.conf;&#125; vi /etc/nginx/conf.d/reverse_proxy.conf 由于 nginx.conf 的末尾已经有include /etc/nginx/conf.d/*.conf 了，因此可以在 conf.d 目录下创建不同需求的配置文件，这样方便管理。 反向代理服务器的配置参考如下： 1234567891011121314151617181920212223242526server&#123; listen 80; server_name test.com; location / &#123; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8000; &#125; access_log /var/log/nginx/test.log;&#125;server&#123; listen 80; server_name demo.com; location / &#123; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; access_log /var/log/nginx/demo.log;&#125; 说明与注意事项 nginx -s reload 后报错？ 可能原因之一是：配置中指定的 log 路径不存在。 附录：CentOS 下 Tomcat 的配置 更改 Tomcat 默认端口 Tomcat 默认监听的是 8080，在这里并不影响，但是目前没怎么配置过 Linux 下的 Tomcat，所以当做个笔记。 12find / -name server.xmlvi /path/to/server.xml 找到 Connector 标签，更改其 port 属性值为所需端口号即可。 启动语关闭 Tomcat CentOS/Linux 下安装好 Tomcat 后，如果执行 service tomcat start 等相关命令如果提示找不到服务名的话，可能需要进入 Tomcat 的安装目录下的 bin/ 目录手动执行： 123./startup.sh./shutdown.sh# ... 参考 搭建nginx反向代理用做内网域名转发","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"}]},{"title":"Nginx 虚拟目录和虚拟主机的配置","slug":"Virtual-Directory-And-Virtual-Host-On-Nginx","date":"2018-01-22T03:56:21.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/22/Virtual-Directory-And-Virtual-Host-On-Nginx/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/Virtual-Directory-And-Virtual-Host-On-Nginx/","excerpt":"无论是在 Apache 上还是在 Nginx 上，虚拟主机和虚拟域名的配置都是我经常用到的功能。 nginx.conf 配置文件的几个常用命令nginx 配置文件主要分为六个区域： main: 全局设置 events: nginx工作模式 http: http设置 sever: 主机设置 location: URL 匹配 upstream: 负载均衡服务器设置 下面，就以在 Windows 上使用 phpStudy 集成开发环境举例说明下 Nginx 的虚拟目录和虚拟主机是如何配置的：","text":"无论是在 Apache 上还是在 Nginx 上，虚拟主机和虚拟域名的配置都是我经常用到的功能。 nginx.conf 配置文件的几个常用命令nginx 配置文件主要分为六个区域： main: 全局设置 events: nginx工作模式 http: http设置 sever: 主机设置 location: URL 匹配 upstream: 负载均衡服务器设置 下面，就以在 Windows 上使用 phpStudy 集成开发环境举例说明下 Nginx 的虚拟目录和虚拟主机是如何配置的： Nginx 虚拟目录配置 通俗地讲，虚拟目录的意思就是浏览器上输入的 URL 不一定就代表网站在文件系统中的绝对路径，而是可以在硬盘中的任意指定位置。 比如在浏览器上访问的是 http://localhost/test，在网站根目录 C:/htdocs/ 下不一定就有 test 这个目录，而是可以在其他位置, 比如 d:/not_test。 找到并打开 nginx.conf，然后在 location ~ //.ht {...} 字样下面添加即可： 12345location /test &#123; alias \"C:/Users/cjli/PhpstormProjects/test\"; index index.php; autoindex on;&#125; 这里 /test 中的 test 是一个别名( alias )，可以自定义，而 alias 指令后面跟的路径也可以随意指向文件系统中任何存在的目录。 重启 Nginx 后打开 http://localhost/test 就可以看到上面目录 C:/Users/caoxl/PhpstormProjects/test 下的网站了( 如果有的话 )。 注意: 虚拟目录路径的配置不能用 root 指令而必须用 alias 指令。 路径必须用双引号括起来。 index 指令和 autoindex 指令必须同时出现。 Nginx 虚拟主机配置通俗地讲，虚拟主机的意思就是，功能上力求和一台物理机实现得一致。 因此就很容易解释为什么多个虚拟主机中可以监听同一个端口号这样的问题了，因为虽然端口号是相同的，但是可以理解为是不同个主机上的同一个端口，这当然不影响了。 为了管理方便，对 Nginx 的配置文件都可以放在一个文件夹下，然后统一在主配置文件 nginx.conf 中使用 include 指令包含进来。可参考如下： conf.d/virtual-hosts.conf 1234567891011121314151617181920server &#123; listen 80; server_name localhost 192.168.1.174 zh.oc.com; charset utf-8; location / &#123; root \"D:\\WWW\\mycncart\"; index index.php index.html index.htm; autoindex on; &#125; location ~ \\.php(.*)$ &#123; root \"D:\\WWW\\mycncart\"; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; &#125;&#125; nginx.conf 12# ...include conf.d/virtual-hosts.conf 说明: 每个虚拟主机在 nginx.conf 中都是一个单独的 server{} 块，配置思路也大体相同。 虚拟主机的端口可以监听同一个端口。 server_name 可以是内网IP、域名，公网 IP 和域名，也可以一次性指向多个域名或 IP。 root 指令放在 location 指令在之外类似于全局变量，而每个 location 块中都可以使用该指令设置的路径。 在与 PHP 关联的时候，要么全局中指定过 root，否则在 location 中也必须指定根路径，否则重启 Nginx 后也无法找到文件，出现 404 或无法加载网页。 参考 nginx的配置、虚拟主机、负载均衡和反向代理 windows下搭建nginx+php+虚拟主机配置过程 PHP-FastCGI on Windows","categories":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/categories/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.caoxl.com/tags/Nginx/"},{"name":"VirtualHost","slug":"VirtualHost","permalink":"http://blog.caoxl.com/tags/VirtualHost/"}]},{"title":"Vi / Vim 基础知识","slug":"Vi-Vim-Notes","date":"2018-01-22T02:46:47.000Z","updated":"2019-08-22T03:28:30.000Z","comments":true,"path":"2018/01/22/Vi-Vim-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/Vi-Vim-Notes/","excerpt":"Vi 基础知识 三种模式：命令模式、输入模式、末行模式。","text":"Vi 基础知识 三种模式：命令模式、输入模式、末行模式。 命令模式vi 启动后默认进入的是命令模式。输入 i、a 都能进入编辑模式。无论在任何模式下要按 esc 都进入命令模式。 常用命令 : x:删除当前光标所在的字符 nx:删除当前行包含光标后n个字符 D:删除当前行光标后的所有的字符 dd:删除当前光标所在的行 ndd:删除当前行(包括当前行)后面的n行 yy:复制当前行 p:粘贴 u:撤销 末行模式命令模式下输入 : 即可进入末行模式。末行模式下可以执行的操作有： 常用命令 : :set nonu 取消行号:n 将光标定位到第n行:$ 回到文件的最末行:/string 把string字符串进行高亮显示:nohls 取消高亮显示:w 保存:q 退出:wq 保存并退出或输入 :x也行:wq! 强制保存并退出:q! 强制退出:[range]s/源字符串/目标字符串/[pattern] 替换字符串 vi或者vim的常用指令 vi filename ： 编辑一个文件（如果文件不存在则自动创建，否则打开） vi filename1 filename2：编辑多个文件 :next :n编辑下一个文件 :prev 编辑上一个文件 vi +n filename：编辑一个文件，光标位于第n行 +1：第一行 +$：最后一行 配置 Vi配置 Vi 就是对 ~/.vimrc 文件的配置，如下是我现在正常使用的配置内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 在启动 vim 时 当前用户家目录下的 .vimrc 文件会被自动读取# 所以一般情况下把 .vimrc 文件创建在当前用户的根目录下# 该文件可以包含一些设置甚至脚本# 去掉有关 vi 一致性模式 避免以前版本的一些 bug 和局限set nocompatible# 显示行号# set nummber# 检测文件的类型filetype on # 记录历史的行数set history=1000 # 背景使用黑色set background=dark # 语法高亮显示syntax on# 下面两行在进行编写代码时 在格式对齐上很有用# 自动对齐 也就是把当前行的对齐格式应用到下一行set autoindent# 依据上面的对齐格式 智能的选择对齐方式set smartindent# 第一行设置 tab 键为 4 个空格# 第二行设置当行之间交错时使用 4 个空格set tabstop=4set shiftwidth=4# 去除 vim 的 GUI 版本中的 toolbarset guioptions-=T# 设置匹配模式 类似当输入一个左括号时会匹配相应的那个右括号set showmatch# 在编辑过程中，在右下角显示光标位置的状态行set ruler# 关闭搜索匹配时的高亮显示# set nohls# 搜索提示set incsearch# 设置所在行提示set cul# 设置文件编码set fileencoding=utf-8 Vi 快捷键说明：快捷键在非编辑模式下有用。 vi 编辑器中ctrl+s 为终止屏幕输出，即是停止回显，ctrl+q 恢复屏幕输出。 dd 剪切某行内容到 VIM 缓冲区 yy 复制某行内容到 VIM 缓冲区 gg 跳至文件头 GG 跳至文件尾 P 向光标上粘贴 VIM 缓冲区中的 最新 内容 p 向光标下粘贴 VIM 缓冲区中的 最新 内容 ZZ 保存并退出 dd 剪切本行 参考 Vim Cheat Sheet","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.caoxl.com/tags/Linux/"},{"name":"Vi","slug":"Vi","permalink":"http://blog.caoxl.com/tags/Vi/"},{"name":"Vim","slug":"Vim","permalink":"http://blog.caoxl.com/tags/Vim/"}]},{"title":"VIM 流","slug":"VIM-Flow-Notes","date":"2018-01-22T02:42:16.000Z","updated":"2019-08-22T03:28:33.000Z","comments":true,"path":"2018/01/22/VIM-Flow-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/22/VIM-Flow-Notes/","excerpt":"没有用过VIM的程序员不是好程序员","text":"没有用过VIM的程序员不是好程序员 Buffer／缓冲区 查看缓冲区：:ls 或者 :buffers %a 代表当前缓冲区；# 代表上一个缓冲区 打开某个文件到缓冲区：:e[dit] &lt;path_to_file&gt; 安全退出缓冲区（需要先保存缓冲区内容）：:bd[elete] &lt;id&gt; 强制性退出缓冲区：:bd[elete]! &lt;id&gt; 缓冲区跳转： 快捷键：ctrl + ^ 命令 跳转到指定编号的缓冲区：b &lt;id, filename, expression&gt; 上一个缓冲区：bn[ext] 下一个缓冲区：bp[revious] 跳转到文件名最匹配给定字符串的缓冲区（模糊匹配并打开）：:b task Window／屏幕／窗口分屏／退出 水平分屏：:sp[lit] 水平分屏并打开多个文件：vim -O path/to/file1 path/to/file2 ... 水平分屏并以只读方式打开：sv[iew] path/to/file 新建窗口/垂直分屏：:new 或 :sb 或 vs[plit] 垂直分屏并打开指定编号的缓冲区：:sb 1 或 :vertical sb 1 垂直分屏并打开多个文件：vim -o path/to/file1 path/to/file2 ... 右下垂直分屏并打开指定文件：:vertical rightbelow sfind path/to/file 安全退出窗口：:q[uit] 或者 :clo[se] 快捷键123456789101112131415161718192021222324252627282930# 打开关闭Ctrl+w s 水平分割当前窗口Ctrl+w v 垂直分割当前窗口Ctrl+w q 关闭当前窗口Ctrl+w n 打开一个新窗口（空文件）Ctrl+w o 关闭出当前窗口之外的所有窗口Ctrl+w T 当前窗口移动到新标签页# 切换窗口 Ctrl+w h 切换到左边窗口Ctrl+w j 切换到下边窗口Ctrl+w k 切换到上边窗口Ctrl+w l 切换到右边窗口Ctrl+w w 遍历切换窗口Ctrl+w t 最上方的窗口Ctrl+w b 最下方的窗口# 移动窗口（注意大写）Ctrl+w H 向左移动当前窗口Ctrl+w J 向下移动当前窗口Ctrl+w K 向上移动当前窗口Ctrl+w L 向右移动当前窗口# 调整大小Ctrl+w + 增加窗口高度Ctrl+w - 减小窗口高度Ctrl+w = 统一窗口高度 Tab／标签打开关闭 VIM 外： vim -p path/to/file1 path/to/file2 ... VIM 内： 12345:tabe[dit] &#123;file&#125; edit specified file in a new tab:tabf[ind] &#123;file&#125; open a new tab with filename given, searching the 'path' to find it:tabc[lose] close current tab:tabc[lose] &#123;i&#125; close i-th tab:tabo[nly] close all other tabs (show only the current tab)s 移动1234:tabs list all tabs including their displayed window:tabm 0 move current tab to first:tabm move current tab to last:tabm &#123;i&#125; move current tab to position i+1 跳转 命令模式下： 1234:tabn go to next tab:tabp go to previous tab:tabfirst go to first tab:tablast go to last tab 正常模式下使用快捷键： 123gt go to next tabgT go to previous tab&#123;i&#125;gt go to tab in position i 其他 命令帮助：:h &lt;command&gt; 文件跳转 设置工作路径为当前 VIM 打开路径：:set path=$PWD/** 文件名大小写区分查找并跳转：:sfind filename 调用外部命令：:call system(&#39;date&#39;) 重载文件 放弃当前修改，强制重新载入：:e! 重新载入所有打开的文件：:bufdo e 或 :bufdo :e! :bufdo 命令表示把后面的命令应用到所有 buffer 中的文件 附录 参考 Vim 多文件编辑：缓冲区 如何用Vim搭建IDE？ Vim Cheat Sheet","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"VIM","slug":"VIM","permalink":"http://blog.caoxl.com/tags/VIM/"}]},{"title":"PHP  研究多一点","slug":"Dig-Into-PHP","date":"2018-01-19T10:29:22.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/19/Dig-Into-PHP/","link":"","permalink":"http://blog.caoxl.com/2018/01/19/Dig-Into-PHP/","excerpt":"对编程来说，技术是招式，基础是内功，对自己有要求的程序员，就不能对自己使用的技术只是知其然而不知其所以然。 知道怎么做，是一位合格开发者；知道为什么做，是一位优秀的程序员。 基础不稳，面对技术复杂的系统，如同盲人摸象、管中窥豹，只得其门不得其法。（@rango） 下面总结的是使用 PHP 开发过程中，在实现相应功能之后，多的那么一些思考和研究。 鉴于本文的话题较广，因此本文会肯定会随着我研究的继续而定期更新。","text":"对编程来说，技术是招式，基础是内功，对自己有要求的程序员，就不能对自己使用的技术只是知其然而不知其所以然。 知道怎么做，是一位合格开发者；知道为什么做，是一位优秀的程序员。 基础不稳，面对技术复杂的系统，如同盲人摸象、管中窥豹，只得其门不得其法。（@rango） 下面总结的是使用 PHP 开发过程中，在实现相应功能之后，多的那么一些思考和研究。 鉴于本文的话题较广，因此本文会肯定会随着我研究的继续而定期更新。 内核/底层SAPI In other words, SAPI is an application programming interface (API) provided by the web server to help other developers in extending the web server capabilities. PHP 常见的两种 SAPI Web/CGI SAPI 浏览器 =&gt; Web 服务器（Apache/Nginx）=&gt; Web/CGI SAPI =&gt; PHP =&gt; Zend。 CLI SAPI CLI SAPI =&gt; PHP =&gt; Zend。 CLI PHP 和 CGI PHPCLI PHP 曾（3.0+）基于 CGI PHP ，但是直到 PHP 4.2.0 才从 CGI PHP 中独立出来。 两者功能非常类似，主要的区别在于： CLI 是 PHP 功能的基础部分 CLI 没有只是 CGI 需要的和 Web 服务器相关的接口，不会导入 $_GET/$_POST 等变量，也不会输出 MIME 头信息 CLI PHP 的运行机制和 Linux Shell 基本一样 CLI PHP 有着和 CGI PHP 不同的默认值和 php.ini 设置 内存泄漏内存泄漏（Memory Leak），我个人简单的理解是： 内存中的一块空间 A，在程序的所有作用域中已经没有任何变量指向 A（理应被标记为垃圾），但是却存在作用域外的另一个内存空间 B 对它保持着引用状态，B 会阻止垃圾回收机制（GC）回收 A，这种现象是内存泄漏。 1234567891011$a = ['v']; // 产生一个变量容器$a[] = &amp;$a;xdebug_debug_zval('a');--&gt; Output:a:(refcount=2, is_ref=1)array (size=2) 0 =&gt; (refcount=2, is_ref=0)string 'v' (length=1) 1 =&gt; (refcount=2, is_ref=1) &amp;array&lt; 如果此时 unset 掉 $a，则会发生内存泄漏。 尽管不再有某个作用域中的任何符号指向这个结构(就是变量容器)，由于数组元素“1”仍然指向数组本身，所以这个容器不能被清除 。因为没有另外的符号指向它，用户没有办法清除这个结构，结果就会导致内存泄漏。 庆幸的是，php将在脚本执行结束时清除这个数据结构，但是在php清除之前，将耗费不少内存。 如果你要实现分析算法，或者要做其他像一个子元素指向它的父元素这样的事情，这种情况就会经常发生。 当然，同样的情况也会发生在对象上，实际上对象更有可能出现这种情况，因为对象总是隐式的被引用。 扩展Swoole/PHP-X/EasySwoole https://wiki.swoole.com/ https://www.easyswoole.com/ 扩展开发如果你有如下的应用需求，那么你可能会开始接触 PHP 扩展开发。 封装当前 PHP 尚不支持而有需要让 PHP 用到的 C/C++ 库 通过扩展重写一些性能较差的 PHP 代码 改善现有扩展 与其他语言编写的库交互 鉴于 PHP 扩展开发涉及到的东西较多，我会在其他的文章中再详细讨论，这里不详细讨论。 https://stackoverflow.com/questions/645814/reading-a-git-repository-without-git 语法可变函数参数 在 PHP 5.6 及以上的版本中，由 … 语法实现；在 PHP 5.5 及更早版本中，使用函数 func_num_args()，func_get_arg()，和 func_get_args() 。 使用 … 运算符定义变长参数函数 123456789101112131415function f($req, $opt = null, ...$params) &#123; // $params 是一个包含了剩余参数的数组 printf( '$req: %d; $opt: %d; number of params: %d'.\"\\n\", $req, $opt, count($params) );&#125;f(1);f(1, 2);f(1, 2, 3);f(1, 2, 3, 4);f(1, 2, 3, 4, 5); 使用 … 运算符进行参数展开 123456function add($a, $b, $c) &#123; return $a + $b + $c;&#125;$operators = [2, 3];echo add(1, ...$operators); 在其他编程语言，比如 Ruby中，这被称为连接运算符。 前期静态绑定与后期静态绑定12345678910111213141516171819202122232425class A&#123; public static function foo() &#123; self::who(); // PHP binds this to A::who() right away static::who(); // PHP waits to resolve `$this` (hence late) &#125; public static function who() &#123; echo __CLASS__, PHP_EOL; &#125;&#125;class B extends A&#123; public static function test() &#123; self::foo(); &#125; public static function who() &#123; echo __CLASS__, PHP_EOL; &#125;&#125;B::test(); nowdoc 和 heredoc nowdoc: PHP 5.3.0 两者用途都是为了给变量插入大段的字符串，语法基本相似，区别主要有两点： nowdoc 只是会单纯地输出大段字符串，而不会转换和解析字符串段中的任何变量。 nowdoc 的字符串段区分符需要用单引号包裹起来。 举例说明： 1234567891011121314 $var = 1024; $strNowdoc = &lt;&lt;&lt; 'STR' ... large string blocks &#123;$var&#125; ...STR; echo $strNowdoc; --&gt; Output: ... large string blocks &#123;$var&#125; ... $strHeredoc = &lt;&lt;&lt; STR ... large string blocks &#123;$var&#125; ...STR; echo $strHeredoc; --&gt; Output: ... large string blocks 1024 ... ?? 和 ?:?? 是从 PHP 7.0 开始引入的语法糖，而 ?: 是从 PHP 5.3 开始就有的。两者的区别是： ??：如果变量存在且值不为NULL， 它就会返回自身的值，否则返回它的第二个操作数。 ?:：表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。 PDOStatement bindValue VS bindParam12345678910111213// bindParam()$sex = 'male';$s = $dbh-&gt;prepare('SELECT name FROM students WHERE sex = :sex');$s-&gt;bindParam(':sex', $sex); // use bindParam to bind the variable$sex = 'female';$s-&gt;execute(); // executed with WHERE sex = 'female'// bindValue()$sex = 'male';$s = $dbh-&gt;prepare('SELECT name FROM students WHERE sex = :sex');$s-&gt;bindValue(':sex', $sex); // use bindValue to bind the variable's value$sex = 'female';$s-&gt;execute(); // executed with WHERE sex = 'male' 构造函数PHP 无默认构造函数PHP 没有默认构造函数。因此，如果调用类似 parent::__construct() 出现致命错误，可以先检查父类有无构造函数。 See: https://stackoverflow.com/questions/4650542/why-am-i-getting-fatal-error-when-calling-a-parents-constructor. exit/die如果在构造函数中使用了 exit或die，析构函数仍然会执行。 返回值除非构造对象后显式地再调用一次构造函数可以拿到其返回值外（不推荐，属性可能丢失），一般情况下，直接使用 new 创建一个对象时，构造函数则会表现出“没有返回值”的现象 抛异常来产生错误鉴于构造函数不能有返回值，因此如果在创建对象的时候如果因为一些初始化属性不合法想要产生错误，则最好使用抛异常的方式。 析构函数无参数析构函数不能有参数。 执行时机 对象被注销： 不再有任何变量引用该对象。 请求结束： PHP 执行引擎会在一个请求结束后调用析构函数。 用途 当对象被注销时记录一些日志信息。 链式调用时，为了保证链式调用的连贯性，可以在析构函数中执行一些默认行为。 举例说明： 12345678910111213141516171819202122232425262728293031323334class View&#123; protected $html = ''; protected $outputed = false; // render html only public function render(string $path) : View &#123; $this-&gt;html = include $path; return $this; &#125; // output html only public function output() : View &#123; $this-&gt;outputed = true; echo $this-&gt;html; return $this; &#125; // 如果对象销毁时候视图模版还没有输出 // 则在析构函数中默认执行已渲染模版的输出 public function __destruct() &#123; if (! $this-&gt;outputed) &#123; $this-&gt;output(); &#125; &#125;&#125;$view = new View;$view-&gt;render('/path/to/file.php'); // will render and output template 注意事项 PHP 不能准确给出对象析构函数被调用时的准确时间。对象被注销后，析构函数可能回延迟一段时间才被执行。 不要在析构函数中引用其他对象，因为其他对象的可用性不能保证，可能之前就被注销了。 浮点数精度问题12345678910111213141516171819// 问题示例：echo intval(17.9 * 100); // 期望 1790 而实际输出 1789// 解决办法：echo intval(round(17.9 * 100, 0)); // output: 1790// Or:function getIntFee(float $float) : int&#123; $arr = explode('.', $float); if (! isset($arr[0])) &#123; return intval($arr[0]); &#125; return false;&#125;$amount = getIntFee(17.9 * 100); // output: 1790 生成器判断命名空间是否存在可使用 class_exists() 来检查命名空间是否存在.但是，但如果某些情况下报错 ：undefined costant，可以检测命名空间开头是否有反斜线 \\，若有则去掉。 Trait http://php.net/manual/zh/language.oop5.traits.php 概念&amp;特点 Trait 是为了单继承语言而准备的一种代码复用机制。 Trait 和 Class 相似，它为传统的继承增加了水平的特性的组合，多个无关的 Class 之间不需要互相继承 Trait 使得无关的 Class 可以使用相同的属性和方法。 Trait 本身就是一个类的子集，不具备事先了解类成员是否冲突的能力。 PHP 5.4 以上便可以使用 Trait 特性。 优先级：当前类的成员高于 Trait 中的成员，而 Trait 则高于被继承的成员。 Trait 间冲突 如果某个类引入的多个 trait 都包含了同名的方法，则会产生致命错误： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phptrait B&#123; protected $name = 'cxl1'; public static $status = 1; function setName($name) &#123; $this-&gt;name = $name; &#125; public static function staticMethod() &#123; echo 'trait can define static method too.'; &#125; public function setStatus($val) &#123; self::$status = $val; &#125; public function getStatus() &#123; echo self::$status; &#125;&#125;trait C&#123; protected $name = 'cxl2'; function setName($name) &#123; $this-&gt;name = $name; &#125;&#125;class A&#123; use B,C; protected $name = 'cxl3'; // PHP 7.0.0 后没问题，之前版本是 E_STRICT 提醒 function getName() &#123; echo $this-&gt;name; &#125;&#125;$a = new A();$a-&gt;getName();// PHP Fatal error: B and C define the same property ($name) in the composition of A. However, the definition differs and is considered incompatible. ...$a-&gt;setName('cxl3');// PHP Fatal error: Trait method setName has not been applied, because there are collisions with other trait methods on A in ...$a-&gt;staticMethod(); // trait can define static method too.A::staticMethod(); // trait can define static method too.$a-&gt;getStatus(); // 1$a-&gt;setStatus(2);$a-&gt;getStatus(); // 2 Trait 定义了一个属性后，类就不能定义同样名称的属性，否则会产生 fatal error。 有种情况例外：属性是兼容的（同样的访问可见度、初始默认值）。(在 PHP 7.0 之前，属性是兼容的，则会有 E_STRICT 的提醒) 方法冲突解决办法示例： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phptrait B&#123; function setName() &#123; $this-&gt;name = 'b'; &#125;&#125;trait C&#123; function setName() &#123; $this-&gt;name = 'c'; &#125;&#125;class A&#123; use B,C &#123; // 将 trait B 中的 setName() 重命名为 setNameB() B::setName as setNameB; // 用 trait C 中的 setName() 替换掉 trait B 中的 setName() C::setName insteadof B; &#125; protected $name = 'a'; function getName() &#123; echo $this-&gt;name; &#125;&#125;$a = new A();$a-&gt;getName(); // a$a-&gt;setNameB();$a-&gt;getName(); // b$a-&gt;setName();$a-&gt;getName(); // c 修改 trait 内方法的访问修饰符 1234567891011121314151617181920212223242526272829303132&lt;?phptrait A&#123; public function echoTrait() &#123; echo 'trait'; &#125;&#125;class B&#123; use A &#123; echoTrait as private; &#125;&#125;class C&#123; use A &#123; echoTrait as protected printTrait; &#125;&#125;$b = new B;$c = new C;$b-&gt;echoTrait();// PHP Fatal error: Uncaught Error: Call to private method B::echoTrait() from context ...$c-&gt;echoTrait();// trait$c-&gt;printTrait();// PHP Fatal error: Uncaught Error: Call to protected method C::printTrait() from context ... trait with trait 123456789101112131415161718192021222324252627282930313233343536&lt;?phptrait A&#123; public function echoA() &#123; echo 'a'; &#125;&#125;trait B&#123; public function echoB() &#123; echo 'b'; &#125;&#125;trait C&#123; use A,B; public function echoC() &#123; echo 'c'; &#125;&#125;class Test&#123; use C;&#125;$test = new Test;$test-&gt;echoA(); // a$test-&gt;echoB(); // b$test-&gt;echoC(); // c trait 中使用抽象方法约束类行为 1234567891011121314151617&lt;?phptrait A&#123; abstract public function necessary();&#125;class B&#123; use A; // 如果 B 没有此方法则会报错: // PHP Fatal error: Class B contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (B::necessary) ... public function necessary() &#123; // something necessary ... &#125;&#125; #应用 防止重复提交表单 PRG：https://stackoverflow.com/questions/10827242/understanding-post-redirect-get 时间戳判断 过滤同一用户高频率的同一请求 执行非幂等操作前先判断数据是否已存在、已更新 客户端：点击提交表单后禁用按钮。 模版PHP 本身就是一门模版语言，因此可以这么使用： 123&lt;p&gt; &lt;?= $name, ' is ', $career ?&gt;&lt;/p&gt; 其中标签 &lt;?= ?&gt; 之中的 PHP 代码可以没有分号结尾，里面的所有变量默认会被当作字符串输出（&lt;?php echo），因此，如果不是标量类型的变量使用这种标签则会错误提示。 相反，&lt;?php ?&gt; 标签就是标准的 PHP 开始结束标签了，里面的 PHP 代码要完全符合正常 PHP 语法。 此外，PHP 还具有一个 short_tag 配置项，当它被设置为 On 时，可以使用更短的起始标签 &lt;? ?&gt; 来包裹 PHP 代码。不过不推荐，因为这种标签会和 XML 冲突。 时间日期 计算两个日期之间的天数 12345678$start = new Datetime('2017-01-01');$end = new Datetime('2017-01-11');$interval = $end-&gt;diff($start);if (7 == $interval-&gt;format('%a')) &#123; // do sth&#125; 计算时间日期等最好使用可靠的库，手动计算容易出错。 设计/思想 探索技术背后的原理，学习技术背后的设计思想，才是偷不走的不可替代性。 DDDDomain driven deign。 领域驱动设计。 微服务 PHP-MSF开发手册 环境CGI/FastCGI／PHP-FPM PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)是一个PHPFastCGI管理器 PHP 解释器实际上只有 php-cgi，即只是一个单纯的 CGI 程序，php-cgi 的工作原理很纯粹，能且只能干： 解析 php.ini 文件，初始化执行环境 解析请求 返回结果 其中，第一步中的“初始化执行环境”是 PHP 早期产生性能问题的主要原因，为了解决这个问题，fastcgi 协议改善了上述工作流程： “首先，Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理”。 修改 php.ini 之后，php-cgi 进程是没办法平滑重启的。php-fpm 能够实现“平滑重启”的原理也很简单：新的 php-cgi worker 用新的配置，已经存在的 php-cgi worker 处理完本次请求后就退出。 nginx+php-fpm 自定义 HTTP Header添加到 HTTP 请求中的自定义 Header 格式必须为 A-B-C（-／英文横线），而 PHP $_SERVER 变量得到的就会是：HTTP_A_B_C。 其他格式则不会被正确获取到，除非修改 nginx 配置 underscores_in_headers 为 On ，See：Module ngx_http_core_module#underscores_in_headers。 生产环境常用配置zend opcache（不能同时使用 zend guard loader） Zend OPcache 通过 opcode 缓存和优化提供更快的 PHP 执行过程。它将预编译的脚本文件存储在共享内存中供以后使用，从而避免了从磁盘读取代码并进行编译的时间消耗。同时，它还应用了一些代码优化模式，使得代码执行更快。 当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码（Operate Code，opcode）。Opcode cache 的目地是避免重复编译，减少 CPU 和内存开销。如果动态内容的性能瓶颈不在于 CPU 和内存，而在于 I/O 操作，比如数据库查询带来的磁盘 I/O 开销，那么 opcode cache 的性能提升是非常有限的。但是既然 opcode cache 能带来 CPU 和内存开销的降低，这总归是好事。 现代操作码缓存器（Optimizer+，APC2.0+，其他）使用共享内存进行存储，并且可以直接从中执行文件，而不用在执行前“反序列化”代码。这将带来显着的性能加速，通常降低了整体服务器的内存消耗，而且很少有缺点。 1234opcache.enable=1opcache.enable_cli=1 ; 是否在 CLI 模式下启用 opcacheopcache.memory_consumption=128 ; 共享内存的大小opcache.max_accelerated_files=2000 ; 最大缓存文件个数 php-fpm http://php.net/manual/zh/install.fpm.configuration.php 工作进程分配模式 在 fasgcgi 模式下，php-fpm 会启动多个子进程，来处理 nginx 发来的请求。 1pm = static | dynamic | ondemand static 模式： 表示启动时创建的 php-fpm 子进程数量是固定的，此时只有 pm.max_children 这个参数生效。 dynamic 模式： 表示启动的子进程数是有请求量动态变化的，受 pm.max_children／pm.start_servers/pm.min_spare_servers/pm.max_spare_servers 共同决定。 工作模式选择原则：小内存机选动态，省内存；大内存机选静态。 不过，动态模式下，进程的动态创建和回收本身也需要占用服务器资源。 如果你的内存很大，有8-20G，按照一个php-fpm进程20M算，100个就2G内存了，那就可以开启static模式。如果你的内存很小，比如才256M，那就要小心设置了，因为你的机器里面的其他的进程也算需要占用内存的，所以设置成 dynamic 是最好的，比如：pm.max_chindren = 8, 占用内存160M左右，而且可以随时变化，对于一般访问量的网站足够了。 慢日志 123slowlog = var/log/php-fpm.log.slow # 必须在 request_slowlog_timeout 前定义request_slowlog_timeout = 10s # 当一个请求时间超过 10 秒后 将对应的 PHP 调用栈写到慢日志 性能 TODO… FAQ How to Match A Backslash with preg_match() in PHP? use \\\\\\\\ instead of \\\\。（Regex Tester） headers already set https://stackoverflow.com/questions/8028957/how-to-fix-headers-already-sent-error-in-php. curl 工作不正常？ curl URI 中含有空格会请求失败。 参考Book PHP7内核剖析-pangudashu PHP Internals Book Link What is SAPI and when would you use it? Where can I learn about PHP internals? [closed] Zend API: Hacking the Core of PHP PHP7扩展开发教程[1] – 怎样导出一个模块？ motecshine/php-ext-design-patterns PHP The Right Way PHP Best Practices-A short, practical guide for common and confusing PHP tasks when using self, parent, static and how? php exec() is not executing the command Post/Redirect/Get-Wikipedia 腾讯PHP工程师面试题两份 PHP interfaces IteratorAggregate vs Iterator? PHP’s nowdoc strings What is the difference between bindParam and bindValue? Implementing Domain-Driven Design in Laravel php高并发知识栈 php-fpm参数优化 php-fpm.conf &amp; php.ini 安全优化实践 php-fpm的配置和优化 分析 PHP 应用程序以查找、诊断和加速运行缓慢的代码 PHP高效率写法（详解原因）","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"MySQL 坑","slug":"MySQL-Tricks","date":"2018-01-19T09:41:44.000Z","updated":"2019-08-22T06:29:28.000Z","comments":true,"path":"2018/01/19/MySQL-Tricks/","link":"","permalink":"http://blog.caoxl.com/2018/01/19/MySQL-Tricks/","excerpt":"持续记录使用 MySQL 过程中遇到过的偏冷知识点和坑。 CLIenable mysql command on mac12345678# 1. install mysql workbenchbrew cask install mysqlworkbench# 2. export environment variablesexport PATH=$PATH:/Applications/MySQLWorkbench.app/Contents/MacOS# 3. usemysql -h &#123;host&#125; -u &#123;user&#125; -p &#123;password&#125;","text":"持续记录使用 MySQL 过程中遇到过的偏冷知识点和坑。 CLIenable mysql command on mac12345678# 1. install mysql workbenchbrew cask install mysqlworkbench# 2. export environment variablesexport PATH=$PATH:/Applications/MySQLWorkbench.app/Contents/MacOS# 3. usemysql -h &#123;host&#125; -u &#123;user&#125; -p &#123;password&#125; mycli123pip install myclibrew install mycli 有语法提示，简直不能太赞。使用和普通 mysql 命令一样。 over SSH Tunnel12345678910111213# -f =&gt; background# -L =&gt; bind port between local and remote# -N =&gt; don't execute command just forwarding portsssh -f user@ssh.example.com -L 3307:mysql_server.example.com:3306 -Nmysql -h 127.0.0.1 -P 3307 -u&lt;mysql_user&gt; -p &lt;mysql_user_password&gt;# Kill SSH Tunnel progress# Get pidnetstat -vanp tcp | grep 3307lsoif -i:3307kill -9 &#123;pid&#125; 语法NULL vs NOT NULL除非真的要保存 NULL，否则尽量避免使用 NULL。 但把 NULL 列改为 NOT NULL 带来的性能提升很小，所以除非确定它引入了问题，否则就不要把它当作优先的优化措施。 index with nullable field当 where 条件是 column = cond ，column 是 is null，MySQL 也能对其进行优化，即 MySQL 可以使用索引来查找 nullable 字段。 但是，当 where 条件种包含如下情况时，该优化不会生效： 1SELECT * FROM user WHERE `name` IS NULL 其中，name 字段的定义是 NOT NULL。该情况通常出现在联合查询时。 https://dev.mysql.com/doc/refman/5.7/en/is-null-optimization.html FROM DUAL1SELECT DATABASE() FROM DUAL; There is much discussion over whether or not FROM DUAL should be included in this or not. On a technical level, it is a holdover from Oracle and can safely be removed. If you are inclined, you can use the following instead: SELECT DATABASE(); That said, it is perhaps important to note, that while FROM DUAL does not actually do anything, it is valid MySQL syntax. From a strict perspective, including braces in a single line conditional in JavaScript also does not do anything, but it is still a valid practice having vs where1234567create table `user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(16) NOT NULL, `gender` tinyint NOT NULL, `age` tinyint NOT NULL, PRIMARY KEY (`id`)); having 使用的是从已经筛选出来过的字段（包括别名），而 where 使用的是表中定义好的字段。 1234567891011select name from user where age &gt; 18; -- 不会报错select name from user having age &gt; 18; -- 会报错 `Unknown column 'age' in 'having clause'`select * from user having age &gt; 18; -- 不会报错, `*` 已包含了 `age`-- 不会报错select name, avg(age) as avg_age from user group by gender having avg_age &gt; 18;-- 报错，表 user 不存在 `avg_age` 字段select name, avg(age) as avg_age from user where avg_age &gt; 18 group by gender; where 性能高于 having，能写在 where 限定条件中的就尽量写在 where 中。 group by 的方便和坑 方便：统计不同性别的用户个数（同一列中不同值的个数）： 123456789101112131415161718192021-- 1. countselect count(gender = 1 OR NULL) as boy, count(gender = 2 OR NULL) as girl, count(gender = 3 OR NULL) as gay,from user-- 2. sumselect sum(if(gender = 1, 1, 0)) as boy, sum(if(gender = 2, 1, 0)) as girl, sum(if(gender = 3, 1, 0)) as gayfrom user;select sum(gender = 1) as boy, sum(gender = 2) as girl, sum(gender = 3) as gayfrom user;-- 4. group byselect gender, count(*) as cnt from user group by gender; 坑：性能 如果没有用到索引数据量一般大也会巨慢，甚至出现 MySQL CPU 爆高，超时等。 group by与 order by 的索引优化基本一样，group by 实质是先排序后分组，也就是分组之前必排序，遵照索引的最佳左前缀原则可以大大提高 group by 的效率。 隐式特性（坑）Implict Commit部分事务隐式强制性提交 Some databases, including MySQL, automatically issue an implicit COMMIT when a database definition language (DDL) statement such as DROP TABLE or CREATE TABLE is issued within a transaction. The implicit COMMIT will prevent you from rolling back any other changes within the transaction boundary. CREATE TABLE操作背后涉及到了大量的操作，不仅仅包括对核心表的操作，还包括大量内存数据结构的更新（如Schema），以及存储系统的变更（如创建相应的数据块），工程上很难把这些操作做成原子的。 那么，应该如何做呢？比较折中的方式就是跟用户做一个约定：CREATE TABLE操作总默认COMMIT它之前的事务，这就是implict commit。 详情可参考 这篇博客。 binlog查看 binlog1mysqlbinlog -vv --base64-output=decode-rows /path/to/mysql-bin-log 恢复成SQL12345678910111213141516# 恢复本地 binlogmysqlbinlog \\--no-defaults \\--base64-output=AUTO \\--verbose \\--set-charset=utf8 \\--start-datetime='2017-07-16 00:00:00' \\--stop-datetime='2017-07-17 00:00:00' \\./mysql-bin.000611 &gt; /data/restore.sql# 恢复远程服务器 binlogmysqlbinlog \\--no-defaults \\-uwaimai_o2o -p \\-hrm-wz93132ahz16ttyhq.mysql.rds.aliyuncs.com \\--read-from-remote-server \\mysql-bin.000618 &gt; restore.sql https://dev.mysql.com/doc/refman/5.7/en/mysqlbinlog.html 使用不小于 MySQL server 的版本如果 mysqlbinlog 版本太低，则会出现类似报错如下： 12ERROR: Error in Log_event::read_log_event(): 'Sanity check failed', data_len: 151, event_type: 35ERROR: Could not read entry at offset 120: Error in log format or read error. 版本有关问题 Specified key was too long; max key length is 767 bytes 767 bytes is the stated prefix limitation for InnoDB tables in MySQL version 5.6 (and prior versions). It’s 1,000 bytes long for MyISAM tables. In MySQL version 5.7 and upwards this limit has been increased to 3072 bytes. https://stackoverflow.com/questions/1814532/1071-specified-key-was-too-long-max-key-length-is-767-bytes 备份/恢复1mysqldump -hrm-wz93132ahz16ttyhq.mysql.rds.aliyuncs.com -uwaimai_o2o -p waimai_020 | gzip &gt; wz93132ahz16ttyhq-2017-11-23.sql.gz 主机连接127.0.0.1 vs localhost使用 mysql cli 客户端连接 docker 容器中的 mysql，使用 127.0.0.1 可以连接上，但是使用 localhost 却不能连： 123mysql -h 127.0.0.1 -uroot -p***** # Successmysql -h localhost -uroot -p***** # FailedERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2) 其实这个问题不属于 MySQL 范围内的问题，所有服务器程序（ssh, telnet…）都会遇到这些问题。 根本原因是由服务端程序实际上监听的地址是一个 IPv4 还是一个 hostname。 比如这里的 MySQL，如果 MySQL server 只是监听了 127.0.0.1 这个 IPv4 地址，那么客户端就只能使用 127.0.0.1 这个 IP 连接。 此外，从错误信息中还可以总结一点，unix-like 操作系统默认会把 localhost 当作 UNIX domain socket，而 windows 默认就认为是 TCP/IP，这样的结果是： 在 unix-like OS 上，如果指定地址为 localhost 那么 OS 会默认常识使用 Unix domain socket；如果指定地址为 127.0.0.1，那么 OS 才会使用 TCP/IP。 在 windows 上，无论指定 localhost 还是 127.0.0.1，OS 都会使用 TCP/IP。 UNIX socket is an inter-process communication mechanism that allows bidirectional data exchange between processes running on the same machine. IP sockets (especially TCP/IP sockets) are a mechanism allowing communication between processes over the network. In some cases, you can use TCP/IP sockets to talk with processes running on the same computer (by using the loopback interface). UNIX domain sockets know that they’re executing on the same system, so they can avoid some checks and operations (like routing); which makes them faster and lighter than IP sockets. So if you plan to communicate with processes on the same host, this is a better option than IP sockets. https://serverfault.com/questions/124517/whats-the-difference-between-unix-socket-and-tcp-ip-socket 参考 MySQL :: MySQL 5.7 Reference Manual :: B.5.4.3 Problems with NULL Values Are many NULL columns harmful in mysql InnoDB? how to know the date of insertion of record in SQL SQL How to replace values of select return? MySQL connection over SSH tunnel - how to specify other MySQL server? PDO: Transactions don’t roll back? Difference between SET autocommit=1 and START TRANSACTION in mysqls","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"Database","slug":"Database","permalink":"http://blog.caoxl.com/tags/Database/"}]},{"title":"Database 数据库设计概念","slug":"Database-Design-Notes","date":"2018-01-19T07:41:54.000Z","updated":"2019-08-22T06:29:45.000Z","comments":true,"path":"2018/01/19/Database-Design-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/19/Database-Design-Notes/","excerpt":"从概念上整理下数据库基本设计笔记。 数据是项目的核心 简介What ? 根据业务系统的具体需要，结合所选的 DBMS，为业务系统构造出最优的数据存储模型（建立好数据库中表结构、表与表之间关联），使之能高效的对应用系统中的数据进行存储和访问。 这个过程就是数据库设计。","text":"从概念上整理下数据库基本设计笔记。 数据是项目的核心 简介What ? 根据业务系统的具体需要，结合所选的 DBMS，为业务系统构造出最优的数据存储模型（建立好数据库中表结构、表与表之间关联），使之能高效的对应用系统中的数据进行存储和访问。 这个过程就是数据库设计。 Why ? 减少数据冗余 避免数据维护异常（插入、更新、删除） 节约存储空间 高效的访问 数据库设计的好坏会在用户量激增的时候体现出来，最典型的缺陷就是数据库设计之处没有一个良好的结构带来的 「慢查询」 问题，这种原因带来的慢查询也是非常难以维护的。 How ?数据库设计的基本步骤如下： 需求分析 逻辑设计 物理设计 维护优化 下面将对它们进行详细解释。 需求分析why ? 了解系统所要存储的数据 =&gt; 数据是什么 了解数据的存储特点 =&gt; 数据有哪些属性 了解数据的 lifetime =&gt; 数据和属性各自的特点有哪些 how ? 系统中有哪些实体、以及其用途 往往一个数据库实体对应一个应用功能模块。 实体包含的属性有什么 哪些属性或属性的集合可以唯一标识一个实体 实体有什么存储特点 比如： 用户模块／user 实体：规模随系统上线时间增加，需要永久存储 购物车模块／goodscar 实体：不用永久存储（需要设置归档、清理规则） 商品模块／ goods 实体：对于下线商品可以归档存储 订单模块／order 实体：永久存储，后期需要分表、分库 对于一些增长速度较快的实体，需要考虑分库、分表、归档。（如日志） 实体与实体之间的关系（1对1、1对多、多对多） 逻辑设计what ? 将需求转化为数据库的逻辑模型 使用 ER 图形式对数据库进行逻辑建模和展示 同选用的具体 DBMS 无关 逻辑概念 关系： 就是表。一个关系通车对应一张表。 元组： 表中的一行。 属性： 表中的一列。每个属性都有一个属性名。 选码/联合主键： 表中的某个属性组，可以唯一确定一个元组。 主码/主键： 一个关系有多个候选码，选定其中一个为主码。 域： 属性的取值范围。 分量： 元组中的一个属性值。 ER 图例说明 矩形： 表示实体集，矩形内写实体集的名字。属性名有下划线的表示主键。 菱形： 表示联系集。 联系集的两端连线指明几对几关系，内部文字填写具体的联系关系。 比如联系实体集订单和商品的联系集名称应该是“包含”，联系实体集商品和购物车的联系集名称应该是“选购”，等等。 椭圆： 表示实体的属性。 线段： 连接属性和实体集、实体集和联系集、实体集和实体集。 设计范式数据库设计范式，指的是：如何设计数据库，即如何存储实体之间的关系才更好。 一个好的设计范式代表了简洁、高效、结构清晰，同时最大限度地避免数据操作异常和数据冗余。 操作异常插入异常如果某实体随着另一个实体的存在而存在，即缺少某个实体时无法表示这个实体是，那么这个实体对应的表就存在插入异常。 更新异常如果更改表所对应的某个实体实例的单独属性时，需要将多行进行更新，那么该表就存在更新异常。 删除异常如果删除表的某一行来反映某个实体实例失效时，导致另一个不同实体实例信息丢失，那么这个表中就存在删除异常。 可见，如果一个表中存在插入异常，则必存在更新异常和删除异常。 数据冗余是指相同的数据在多个地方存在，或者说表中的某个列可以由其他列计算得到，那么这个表就存在数据冗余。 大量的数据冗余会给数据一致性的维护带来困难。 常用范式1NF要求： 表必须是二维表。 表的每个字段，都是只有一种原子类型的、不可再分的单一值。 数据库表中的所有字段都是单一属性、不可再分的。这个单一属性是由基本的数据类型所构成的。 第一范式是为了要排除 重复组 的出现，所采用的方法是要求数据库的每个列的值域都是由原子值组成；每个字段的值都只能是单一值。 2NF要求： 必须符合 1NF。 当表中主键为联合主键时，不存在 非关键字段，对联合主键的任一字段的部分函数依赖。（部分函数依赖指的是，存在某个非关键字，是由联合主键中的某个字段唯一决定，而不是联合主键同时决定的情况） 数据表里的所有数据都要和该数据表的键（主键与候选键）有完全依赖关系：每个非主键属性必须独立于任意一个候选键的任意一部分属性。如果有哪些属性只和一个主键的一部分有关的话，就得把它们独立出来变成另一个数据表。 如果一个数据表的主键只有单个字段的话，它就一定匹配第二范式。 检查数据表里的每个字段，确认它们是不是都和关键词（主键）完全相关， 这样才能知道这个数据表是不是匹配第二范式； 如果不是的话，就把那些不完全相关的字段移到独立的数据表里。 3NF要求： 必须符合 2NF。 确保所有不是主键的字段都和彼此没有相依关系。 如果表中，不存在非关键字段，对任意候选关键字段的传递函数依赖，则符合第三范式。 比如表 goods 中有字段 name, category, category_desc，name 是主键（即候选关键字段），category_desc 其实是由 category 决定的，而 category 又是由 name 决定的，因此 category_desc 间接依赖了 name，这种间接依赖关系就叫做传递函数依赖。 此外，两个非主键 category_desc 和 category 存在相依关系，因此该 goods 表不符合 3NF。 这个例子中，符合 3NF 的表设计应该是： goods 表：id, name category 表：id, name, desc category 表：id, name, desc BCNF要求： 必须满足 3NF。 当表的主键是联合主键时，联合关键字之间也不能存在函数依赖关系 数据间的关系是奠基在键上、以整个键为考量、而且除了键之外不考虑其他因素。 BCNF 是 3NF 的更严格版规范，3NF 只对非关键字段和候选关键字之间是够有传递依赖函数关系有限制，而 BCNF 新增了对联合关键字之间依赖关系的限制。 如何正确使用范式前 3 大范式，基本代表了大多数据库设计所要遵循的范式。不符合 2NF 和 3NF 的表，往往同时存在插入异常、删除异常、更新异常和数据冗余。 现在数据库设计最多满足 3NF，普遍认为范式过高，虽然具有对数据关系更好的约束性，但也导致数据关系表增加而令数据库 IO更易繁忙，原来交由数据库处理的关系约束现更多在数据库使用程序中完成。 物理设计根据数据库自身特点，把逻辑设计转换为物理设计。本过程需要完成以下任务： 选择合适的 DBMS不同的 DBMS 对数据库、表、字段等的命名可能有差别，因此需要先选择合适的 DBMS。 对于企业级项目来说，商业数据库，比如 Oracle/SQLServer 等更适合（根据服务器 CPU 核数收费）；而对于互联网项目来说，开源数据库，比如 MySQL/MariaDB/PgSQL 等更适合。 定义数据库、表及字段的命名规范统一大小写、表前缀、字段前缀，命名规则等。 注意有些 DBMS 是大小写敏感，MySQL 可以设置是否大小写敏感。 命名规范在团队开发中是很有必要的，甚至需要建立专用的数据字典和手册。 对象命名原则 可读性：合理使用大小写和下划线 goods_categtory 或者 GoodsCategory 总比 goodscategory 易读。 表意性：顾名思义 对于表，表名应该能够体现表中存储的数据内容；对于存储过程，存储过程名称应该能够体现存储过程的功能。 长名原则：避免歧义 一般来说，除了数据库名字之外，其他命名，尽可能少使用或者不使用缩写。 根据所选的 DBMS 系统选择合适的字段类型首先要熟悉所选 DBMS 的字段类型有哪些，使用场景，优劣。 字段/列的数据类型，一方面影响数据存储空间的开销，另一方面也会影响数据查询性能。 当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或者二进制类型，最后是字符类型。对于相同级别的数据库类型，应该优先考虑占用空间少的数据类型。 这是因为： 对数据进行比较操作（查询条件、join 条件、排序等）时，同样的数据，字符处理速度往往比数字慢 在数据库中，数据处理以页码为单位，列的长度越小，越利于性能提升。因为列越小，一个页中能存储的数据也就越多，在加载相同的数据的时候加载页的数量就会变少，从而提高 I/O 性能。 不同是 DBMS 中页的大小是不同的，MySQL 默认( Innodb ) 一页是 16 KB，SQLServer 默认是 8 KB。 对字符串的处理是需要根据数据字典中的排序规则有关的，即需要搜索字典中的排序规则，所以比数字的效率低。 常见考虑实例参考char 和 varchar在 char 和 varchar 之间如果性能优先则考虑 char。同时，存储等量数据 char 比 varchar 占用的空间更小。 如果列中的最大数据长度小于 50 Byte，则一般也考虑用 char。同时，在 MySQL 中，由于不同的字符集占用的字节数是不同的，因此，上面的 50 个字节需要根据不同的字符集来灵活计算字符数，比如是 UTF8 的时候 50 个字节大概只能存储 16 左右个字符。 当然，如果这个列很少用，则基于节省空间和减少 I/O 的角度，还是可以考虑 varchar。 varchar 需要额外的字节来存储变长数据的字典和起始位置(检索)，所以长度太小就不 适合使用 varchar 存储。 decimal 与 float选择原则： decimal 用于存储精确数据，而 float/double 只能用于存储非精确数据。 由于 float 的存储空间开销一般比 decimal 小（精确到 7 位小数只需要 4 个字节，到 15 位需要 8 字节），因此在非精确数据优先的情况下，优先选择 float 类型。 时间类型 使用 int 类型存储时间字段的优缺点 优点：字段长度比 datetime 小 缺点：使用不方便，要进行函数转换 限制：只能存储到 2038-01-19 11:14:07 秒 需要存储的时间粒度：年、月、日、时、分、秒、周。粒度要求不高则考虑节省空间的数据结构。 时间戳 timestamp 的不足之处，在于只能表示 1970 ~ 2038 年，因为 INT 只能表示 2^32 （2147483648）内的范围，此外，还有新旧版本零值不兼容的问题。 如何选择主键 区分业务主键和数据库主键 业务主键，用于标识业务数据，进行表与表之间的关联。 数据库主键，为了优化数据存储。（InnoDB 会生成 6 个字节的隐含主键） 根据数据库的类型，考虑主键是否要顺序增长 有些数据库是按主键的顺序逻辑存储的。 主键的字段类型所占空间要尽可能的小 对于使用聚合索引方式存储的表，每个索引后都会附加主键信息。因此为了节省空间最好是人为定义一个小于 6 个字节的主键。 避免使用外键约束外键的缺点： 降低数据库导入的效率 在数据导入的时候，会检查是否存在外键约束，检查外键约束是非常耗时的。所以，在高并发的应用场景下不要使用外键约束。 增加维护成本 虽然不建议使用外键约束，但是两张表相关联的列上一定要建立索引。建立索引的目的是为了提高检索速度。 避免使用触发器触发器的缺点： 降低数据导入的效率 可能会出现意想不到的数据异常 使业务逻辑变复杂 InnoDB 中每一种触发器支持的触发器个数（ 6种：before／after … ）是有限制的，如果使用其他的工具再次使用触发器的时候就可能出现不能创建触发器的情况此外，在业务逻辑变更而其他人员不知道的情况下就会影响业务逻辑的正常运行。 严禁使用预留字段有些时候为了提高扩展性，可能会预留一些字段，但是这样做弊大于利： 无法准确知道预留字段的类型 无法准确知道预留字段需要存储的内容 后期维护预留字段的成本，和增加一个字段需要的成本是相同的 在表中使用预留字段，是一种过度设计的行为，而正确的应该是按需设计。 反范式化设计 反范式化是为了性能和读取效率的考虑而适当地对 3NF 的要求进行违反，而允许存在少量的数据冗余。 数据操作异常、数据冗余不是说不能有，但是要可控。 大多数情况下遵循范式化设计是没有问题的，但是少数情况下，不得不或者说更好的做法是为了效率，采用「空间换时间」的做法，因为范式化设计毫无疑问会使表数量增多，大量的连表查询等等，增加 DBMS IO 负担，在一些追求效率的应用场景下或许并不适合，这时候可以考虑采用反范式化设计。 总的来说，进行反范式化设计的理由如下： 减少表的关联数量 增加数据的读取效率 反范式化一定要适度 什么时候可以反范式化？那么，实际项目中，什么情况下进行范式化设计才合理呢？ 先严格按照 3NF 设计好表，然后用一些复杂的业务查询逻辑来测试这些表，如果为了获得完整的业务数据，需要的连表次数超过 3 次，而该查询场景频率高、追求效率，那么，此时可以考虑反范式化设计。 DBMS 周边环境操作系统、开发语言、应用场景，谁更合适就用谁。 可参考的依据有：社区成熟度、社区活跃度、开发者数量、更新频率。 维护优化当数据库逻辑设计完成后，就是根据使用过程中的具体情况，选择进行维护和优化操作。 在维护和优化过程中需要做的事有以下几点： 数据字典数据字典是对表、列的描述，对于业务升级来说是重要的依据。 由于需求是经常变化的，所以先前的索引，表结构等可能后来不再适用于现在的场合，因此需要做一些维护操作以适应新的需求。 how ? 使用第三方工具，不同的 DBMS 有不同的三方工具 利用数据库本身的备注字段来维护 注意： 更改表备注的时候只能更改表备注而不要更改其他任何数据。 导出数据字典 比如 MySQL 就可以直接查询 information_schema 数据得到 123456select a.table_name, b.table_comment, a.column_name, a.column_type, a.column_commentfrom information_schema.COLUMNS ajoin information_schema.TABLES bon a.table_schema = b.table_schemaand a.table_name = b.table_namewhere a.table_name = 'users'; 索引如何选择合适的列建立索引 出现在 where、group by、order by 从句中的列 可选择性高的列要放到索引的前面 目前的 DBMS 中在执行 SQL 语句之前都会经过 SQL 优化器进行重新编译，这个过程会自动根据索引信息和统计信息来进行排序和优化从而自动选择出适合该 SQL 的索引，所以这点不是必须的。 索引中不要包含太长的数据类型 由于数据库是以页来存储数据的，比如 MySQL 一页就是 16 KB，一页中如果条数越多则索引查找速度越快，因此索引中的列就不要太长。 MySQL 支持对前缀进行索引，因此假如是 text 等大类型的数据要建立索引的话，就可以只对前 16 个字节的数据进行索引，或者是转换为 md5 后再建立索引。 如何维护索引 索引不是越多越好，过多的索引会同时降低读写效率。 如果一个 SQL 中索引太多， SQL 优化器在进行分析的时候就会耗费大量的时间。 定期维护索引碎片。 索引碎片就是零碎的小文件，类似磁盘碎片，碎片太多会减少每页的数据存储，从而影响查询效率。 在 SQL 语句中不要使用强制索引关键字 Oracle 中可以强制索引关键字，但是 MySQL 最好不要这样做，因为数据量是在不断变化的，原来的索引可能不再适用而被更名或删除，而如果开发人员不知道的话，原来的 SQL 语句就会出错。 表结构how ? 使用在线变更表结构的工具 mysql 5.5 之前的版本可以使用 pt-online-schema-change，mysql 5.6 之后本身支持在线表结构的变更。 5.5 之前的 MySQL 在使用 pt-online-schema-change 等三方工具的之前，表中尽量不要出现触发器，因为该工具本身就会为表加上 3 个触发器，比如增、删、改触发器，而 MySQL 对于一个表中的触发器类型只能有一个，如果原表已经使用了工具中将要使用到的触发器，那么就不能正常工作。 同时对数据字典进行维护 表结构变了，相应的字段功能、注释等一般也随着改变，因此需要同步更新。 控制表的宽度和大小 一页总存储的数据越多，I/O 效率更高。 当表结构随业务需求变宽，需要考虑垂直拆分。 大表拆分优化数据库表 I/O 两种方式： 水平拆分解决了表中数据量的问题， 垂直拆分解决了表的宽度问题。无论何种拆分，总的数据量是不能减少的，每一份小表中的数据是不同的。 垂直拆分为了控制表的宽度，可以进行表的垂直拆分。 所谓的垂直拆分，意思就是把一张表的多个字段分散到多张表中。 比如，表 t 有 10 个字段：c1, c2, …, c10。c1 是主键。那么可以将表 t 拆分为 t1 和 t2 子表，t1 含有的字段为：c1, c2, …, c9；t2 含有的字段为：c1, c10。 当表变宽后，势必导致一页中存储的数据越少，从而降低 I/O 效率，此时需要进行垂直拆分。 垂直拆分的拆分依据 经常一起查询的列放到一起，避免关联操作 text、blob 等二进制大字段拆分到附加表中 水平拆分为了控制表的大小，可以进行表的水平拆分。 当表中的数据量非常大的时候，对大表的主键进行哈希操作后，平均分配到多张小表中。 数据库中适合的操作 批量操作 VS 逐条操作 数据库中适合进行批量操作，逐条操作适合在程序中进行。 禁止使用 select * 查询 select * 的使用过多会造成 I/O 的浪费，因为有大量不需要的数据记录。 控制使用用户自定义函数 自定义函数过多会影响到索引的工作（函数会使列中的索引失效）。 不要使用 MySQL 中的全文索引 MySQL 中的全文索引需要建立额外的索引文件，以及对中文的支持不好，建议使用专业的搜索引擎工具，而不要使用数据库自带的全文索引功能。 数据库性能瓶颈是 I/O现在数据库的性能瓶颈不在于 CPU 而在于磁盘的 I/O，因此，在考虑性能优化的时候，优先考虑能够减少磁盘 I/O 数的措施。 FAQ 在表使用 JSON 类型字段是否破坏了 1NF ？ 参考 数据库规范化","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"Database","slug":"Database","permalink":"http://blog.caoxl.com/tags/Database/"}]},{"title":"MySQL 优化","slug":"MySQL-Optimization","date":"2018-01-19T04:58:48.000Z","updated":"2019-08-22T06:29:39.000Z","comments":true,"path":"2018/01/19/MySQL-Optimization/","link":"","permalink":"http://blog.caoxl.com/2018/01/19/MySQL-Optimization/","excerpt":"主要从概念上总结下 MySQL 优化的思路。 数据库优化简介Why ?避免出现页面访问错误 数据库连接 timeout 发生 50x 错误 由于慢查询造成页面无法加载 由于阻塞造成数据无法提交","text":"主要从概念上总结下 MySQL 优化的思路。 数据库优化简介Why ?避免出现页面访问错误 数据库连接 timeout 发生 50x 错误 由于慢查询造成页面无法加载 由于阻塞造成数据无法提交 增加数据库的稳定性很多数据库问题都是由低效的查询引起的。 优化用户体验 页面的流畅访问 网站功能的良好体验 How ?硬件CPU 核数、更多的内存和更快的 I/O(固态硬盘等)，但是 CPU 并不是越多越好，因为 MySQL 的有些查询只能是单核完成。 此外，I/O 越快也并不能保证减少数据库锁的问题，因为锁是 MySQL 等多数数据库内部为保证数据完整性的一种机制，因此无法完全避免掉阻塞。 可见，硬件的优化是成本最高但是效果最差的，如果底层的优化不够，产生了 太多的慢查询和阻塞，那么就会带来高并发， 高并发的场景下，再好的硬件也会有很高的 loading。 系统配置MySQL 的运行环境大部分都是 Linux 系统，所以会受到 Linux 系统本身的一些限制。 此外， TCP/IP 连接数、打开的文件数(I/O操作频率)，也是会对 MySQL 的性能造成限制。 数据库表结构良好的表结构是写出良好的 SQL 语句的基础，我们要根据数据库设计范式来设计表结构，尽量考虑如何设计表结构才有利于查询，尽量简洁明了，尽量减少数据的冗余。 SQL 及索引这是最常见的优化方式，我们需要根据需求写出结构良好的 SQL，然后写出结构良好的 SQL 语句。因为同一个业务可能可以用多种 SQL 来完成，但是尽量选择结构最好的 SQL。 以上的 4 个思路，从下往上，成本递增，但是效果却在递减。 服务器硬件优化 提示：由于成本和效率不太成正比，因此不是首选优化点。 如何选择 CPU 是选择更快的单核，还是选择核数更多的 CPU 可以参考的依据有： 对 MySQL 来说，有些工作只能用到单核 CPU。比如：Replicate, SQL 等。 MySQL 对 CPU 核心数的支持并不是越多越快，详见官方手册。 MySQL 5.5 使用的服务器不要超过 32 核。国外有人(Facebook工程师)测试过，MySQL 5.5 Community Version，CPU 超过 32 核心后性能不升反降。 频率高的单核同样能提高性能 Disk I/O 优化常用 RAID 级别RAID0也称“条带”，就是把多个磁盘连接成一个硬盘使用，这个级别的 IO 最好。 RAID1也称“镜像”，要求至少有两个磁盘，每组磁盘存储的数据相同。 RAID5即把多个（最少 3 个）的硬盘，合并成 1 个逻辑盘使用，数据读写时会建立奇偶校验信息，并且奇偶校验信息和相对应的数据分别存储在不同的磁盘上。 当 RAID5 的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被破坏的数据。 RAID1+0即 RAID1 和 RAID0 的结合，同时具备两个级别的优缺点。 由于 RAID0 安全性不好，RAID1 I/O 不好，因此，一般数据库都是使用这个级别。 SNA 和 NAT SNA 和 NAT 是否适合数据库？ SNA 和 NAT 的优点： 常用于高可用解决方案 顺序读写效率高（但是随机读写差） 这两种适合做磁盘矩阵，容灾性很好，但是从提升数据库 I/O 性能的角度来看，并不适合数据库读写的特点，因为数据库随机读写的比率很高。 因此，对于网络存储设备，需要测试后才决定是否采用。 系统配置优化操作系统配置优化数据库是基于 OS 的，所以 OS 的一些参数配置是影响 MySQL 性能的基础。 目前 MySQL 主要都安装在 GUN/Linux 上，因此下面说的都是在说 Linux，其常用的系统配置如下： 网络方面修改 /etc/sysctl.conf： 12345678# 增加 TCP 支持的队列数net.ipv4.tcp_max_syn_backlog = 65535# 减少断开连接时的资源回收net.ipv4.tcp_max_tw_buckets = 8000net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 10 打开文件数限制123456# 查看目录的各位限制ulimit -a# 修改 /etc/security/limits.conf 修改系统对打开文件数的限制* soft nofile 65535* hard nofile 65535 防火墙等安全工具1在 MySQL 服务器上最好关闭 iptables/selinux 等防火墙软件，因为对 MySQL 服务器来说，最好使用硬件防火墙来屏蔽而不是使用软件防火墙。 文件系统类型选择文件系统类型参考以下因素： I/O 操作性能 并发支持 多文件下工作 文件切片 崩溃恢复时间（最好选择日志文件系统） 安全 影响性能的可禁用选项 MySQL 配置配置文件有两种方式可以配置 MySQL 服务器： 启动时指定配置参数 使用配置文件启动 大多数情况下，MySQL 的配置文件位于 /etc/my.cnf、/etc/mysql/my.cnf、C:/windows/my.ini，可以手动查找配置文件顺序： 1/usr/sbin/mysqld --verbose --help | grep -A 'Default options' 配置文件顺序以最后的为准，即如果存在多个配置文件时，后面配置的会覆盖前面的配置。 Innodb 常用配置选项参数 innodb_buffer_pool_size 用于配置 Innodb 缓冲池。 如果数据库中只有 Innodb 表，则推荐配置量为总内存的 75%。 举例说明： 12345select engine,round(SUM(data_length + index_length)/1024/1024, 1) as 'Total MB',from information_schema.TABLESwhere table_schema not in ('information_schema', 'performance_schema')group by engine; innodb_buffer_pool_size 通常需要 &gt;= 这个查询结果中的 Total MB。 Total MB 代表的是所有 Innodb 表的大小+索引的大小之和，当系统内存有限时，该值需要尽可能的大。 innodb_buffer_pool_instances 这是 MySQL 5.5 中新增的参数，可以控制缓冲池的个数。（默认情况下只有一个） 在 MySQL 中有些资源是被独占的，比如缓冲池。增加缓冲池的个数有利于提高并发性能，降低阻塞的频率。 每个缓冲池实例的大小 = innodb_buffer_pool_size / innodb_buffer_pool_instances。 innodb_log_buffer_size 是 innodb log 缓冲的大小。由于日志最长每秒钟就会刷新，所以一般不用大大。 为了效率，Innodb 的日志是先写入缓冲区，然后再写入磁盘文件的 不用设置太大，只要能够存放下一秒内事物的日志就行了。 innodb_flush_log_at_trx_commit 该参数决定的是数据库多久把变更刷新到磁盘： 为 0：表示每次提交不进行刷新，每一秒才把变更刷新一次 为 1：表示每次提交都会把变更刷新到磁盘( 最安全 ) 为 2：表示每次提交只是把变更刷新到缓冲区，然后每一秒从缓冲区刷新到磁盘，最多丢失 1 秒的提交(为了 I/O 性能一般都是设置为 2) 关键参数之一，对于 Innodb 的 I/O 效率影响很大。 默认为 1，可以取 0、1、2 三个值，一般为 2，如果对数据安全性要求高则使用默认值 1。 innodb_read_io_threads 和 innodb_write_io_threads 这两个参数决定了 Innodb 表的读写 I/O 进程数，默认为 4。 该参数在 5.5 后可以人为地进行调整，当然也要考虑读写负载的实际情况考虑，以提高 Innodb 并发读写的线程数。 innodb_file_per_table 控制 Innodb 表的每个表使用的独立表空间，默认为 OFF，表示默认所有表都会建立在共享表空间中。关键参数之一。 虽然默认是没启用的，但是建议设置为 On。如果所有 Innodb 表都使用共享表空间，那么也会带来 I/O 瓶颈，因为是顺序读写共享表空间的其次，Innodb 的共享表空间是无法单独收缩的，所以如果删除了一个很大的表，这时 候如果想收缩该共享表空间的话，只能先导出所有数据再重新导入进去。 如果每张表使用的磁盘空间都是独立的，那么当对某张表进行了删除等操作，MySQL 就会马上回收这部分磁盘空间，另外，由于对多个表文件的读写分开了，也提高了读写 的并发性。 innodb_stats_on_metadata 决定了 MySQL 在什么情况下会刷新 Innodb 表的统计信息。 数据库优化器在使用表的索引的时候，会借助表的统计信息，定时刷新表的统计信息就能够确保优化器的正常读取，但是太高也会影响 MySQL 的性能。 默认情况，MySQL 在查询表结构的时候( show create table / show table status ) 都会刷新表的统计信息，而这是不必的，所以这种情况下是不必启用的，通常情况对该统计信息的刷新都是在数据库闲时进行手动刷新的，这样也可以保持数据库的性能。 为维护配置文件效率比较低，也可以借助第三方配置工具来完成的。 第三方配置工具 Percon Configuration Wizard 这里可以手动选择配置选项，然后根据你的选择为你生成一份配置文件，并发送到你的邮箱。 数据库结构优化如何选择合适的数据类型 使用可以存下数据的最小的数据类型（增加单页数据量，减少 I/O 次数） 使用简单的数据类型（mysql 处理 int 要比 char/varchar 简单） 尽可能使用 not null 定义字段（Innodb 表字段为 NULL 时会占用额外的高位，从而减少实际存储空间） 尽量少用 text 类型，非用不可时最好考虑分表（text 和 blob 类型往往专门存储在附加表中） 应用举例使用 int 存储日期和时间同时，使用 from_unixtime() 和 unix_timestamp() 来转换，两者往往配合使用。 1select from_unixtime(unix_timestamp()); 使用 bitint 来存 IP 地址同时，使用 inet_aton() 和 inet_ntoa() 来转换，两者往往互逆使用。 12select inet_aton('192.168.0.1'); -- 3232235521select inet_ntoa(3232235521); -- 192.168.0.1 一个 IPv4 地址最多占用 15 个字节，而 bigint 占用 8 个字节，还是很划算的。 使用 bigint 比 char/varchar 类型更高效，因为数字比字符计算速度快。 表的范式化和反范式化范式化范式化是指设计数据库时候需要遵从的规范，目前说到数据库范式大部分情况指的都是第三范式（3NF）： 首先必须满足 1NF 和 2NF 要求表中不存在非关键字段对任何候选关键字段的传递函数依赖，即，不是主键的字段之间不能互相依赖。 违背范式化设计带来的问题 数据冗余 插入异常 更新异常 删除异常 反范式化为了某些应用场景下查询效率的考虑，把原本符合 3NF 的表，以适当增加冗余的方式，减少多次连表查询的次数，达到优化查询效率的目的。反范式化可以理解为一种以空间换时间的行为。 表的拆分垂直拆分把原来有很多列的表拆分成多个表，解决的是表的宽度问题。 通常垂直拆分按以下原则进行： 把不常用的字段单独存放到一个表中 把大字段／二进制字段独立存放到一个表中 把经常一起使用的字段放到一个表中 垂直拆分是更应该在数据表设计之初就执行的步骤。 水平拆分把每一个过大数据量的表，拆分成结构完全相同的子表，解决的是单表数据量过大的问题。 举例说明: 假设 ID 递增的 100W 规模的表 tb 要水平拆分为 3 张表 tb0, tb_1, tb_2，则通常做法是： 创建 3 张结构完全一样的字表 123create table tb0 like tb;create table tb1 like tb;create table tb2 like tb; 对大表主键取余数，然后将余数相同的记录保存到同一张子表 123insert into tb0 (select * from tb where mod(id, 3) = 0);insert into tb1 (select * from tb where mod(id, 3) = 1);insert into tb2 (select * from tb where mod(id, 3) = 2); 也可以查询后直接创建子表 123create table tb0 (select * from tb where mod(id, 3) = 0);create table tb1 (select * from tb where mod(id, 3) = 1);create table tb2 (select * from tb where mod(id, 3) = 2); 对主键取余，获得拆分后的子表 1mod(1024, 3); // 1 =&gt; 代表 id 为 1024 的记录在拆分后的第 1 张子表 tb1 针对不同的余数 CRUD 不同的子表 12select * from tb1 where id = 1024;delete from tb1 where id = 1024; 为了区分业务，不至于造成影响，建议前台用拆分后的表，后台使用汇总表。 SQL 及索引优化索引如何选择合适的列建立索引？ 在 where、group by、order by、on 从句中出现的列 有些特殊情况下，select 从句中出现的字段也会建立索引。 大小越小的字段，最好是数字 同样是出于较少 I/O 次数的考虑：MySQL 中存储数据的单位是页，单页中存储的数据越多，查询效率更高。 离散度大的列放到联合索引的前面 举例说明: 如果要建立含有 2 个字段 a 和 b 的索引，如果 a 的离散度比 b 大，那么建立的索引应该为：index(a, b)，反之同理。 覆盖索引当一个索引中包含了查询中的所有数据列，那么这种索引就是覆盖索引。这种查询场景下不需要回表操作，因此效率很高。 当查询的频率很高，而且表中包含的列比较少的时候，往往采取覆盖索引来获取查询结果。 如何判断字段的离散度？1select count( distinct a ) as res_a, count(distinct b) as res_b from tb; 如果 res_a 大于 res_b 则说明字段 a 的离散度更大。 离散度越大，过滤的数据越多。 索引并非“银弹”通常情况下，创建索引能提升查询效率，但是却降低了写入效率( insert/update/delete)。但是，过多的索引，也会影响查询效率，因为索引过多会使分析更慢。所以，有时候有必要根据情况删除重复的、冗余的索引。 重复索引是指，相同的列以相同的顺序建立的同类型的索引。 比如，id 字在声明了主键索引 primary key 后已经是唯一类型，如果在手动增加一个索引 unique(id) 的话，和 primary key 就属于重复索引。 冗余索引指的是，多个索引的前缀列相同，或是在联合索引中包含了主键的索引。举例说明： 12345create table tb ( id int not null primary key, name varchar(10) not null, key(name, id)) engine = innodb; 这里由于主键默认情况下就是 id 字段上的索引，所以，没有必要再在主键上建立索引。 查找重复、冗余索引通过 SQL1234567891011121314use information_schema;select a.TABLE_SCHEMA as '数据名', a.table_name as '表名', a.index_name as '索引1', b.index_name as '索引2', a.column_name as '重复列名'from statistics ajoin statistics bon a.table_schema = b.table_schemaand a.table_name = b.table_nameand a.seo_in_index = b.seo_in_indexand a.column_name = b.column_namewhere a.seo_in_index = 1and a.index_name &lt;&gt; b.index_name; 通过工具 pt-duplicate-key-checker1234pt-duplicate-key-checker \\-h www.myapp.com-uroot \\-p 通过工具 pt-index-usage目前 MySQL 中没有记录索引的使用情况，只能通过慢查询日志配合 pt-index-usage 工具来分析索引使用情况。 123pt-index-usage \\-uroot -p ''\\mysql-slow.log PerconMySQL 和 MariaDB 中可以通过 INDEX_STATISTICS 表来查看哪些索引未使用。 删除无用索引1alter table tb drop index `useless`; 查询优化如何分析 SQL 查询？使用 explain查询 SQL 的执行计划。使用方式： 1explain select * from tb_name; explain 返回列解释 table： 显示这一行的数据是关于哪张表的 type： 显示连接使用了何种类型。从最好到最差的连接类型为：const =&gt; eq_reg =&gt; ref =&gt; range =&gt; index =&gt; all possible_keys： 显示可能应用在这张表中的索引，为空则可能没有索引。 key： 实际使用的索引，为 NULL，则没有使用索引。 key_len： 使用的索引的长度。在不损失精确性的情况下，长度越短越好。 ref： 显示索引的哪一列被使用了，如果可能的话，是一个常数。 rows： MySQL 认为必须检查的，用来返回请求数据的行数。 extra： 存放额外返回结果。当返回值为以下 2 种时，表示查询需要优化： Using filesort： MySQL 需要进行额外的步骤来发现对如何返回的行排序。它根据连接类型，以及存储排序键值和匹配条件的全部行的行指针来排序全部行。 Using temporary： MySQL 需要创建一个临时表来存储结果，这通常发生在对不同的列集进行 order by 上，而不是 group by 。 慢查询慢查询日志的设置MySQL 慢查询日志监控了有效率问题的 SQL。下面是对慢查询日志的设置： 12345678910111213show variables like 'slow_query_log';-- 开启慢查询set global slow_query_log = on;-- 指定了慢查询日 志文件的存储路径set global slow_query_log_file = '/data/mysql/log/mysql-slow.log';-- 设置是否开启把没有使用索引的 SQL 记录到慢查询日志中，由于通常情况下对数据库的优化主要就是优化索引和查询的 使用方式，因此这里必须开启，方便分析set global log_queries_not_using_indexes = on;-- 设置把超过多少秒的慢查询记录到日志中，实际应用中一般 100 msset global long_query_time = 1; 设置好后，可以进行查询测试，然后观察慢日志的监控： 1tail -10 /var/log/mysql/mysql-slow.log 慢查询日志包含的内容 执行 SQL 的主机信息 SQL 的执行信息 SQL 的执行时间 SQL 的内容 慢查询日志分析工具 mysqldumpslow：安装 MySQL 之后自带的分析工具。 12# 查询服务器中查询最慢的 3 条 SQLmysqldumpslow -t 3 /var/log/mysql/mysql-slow.log | more # more 是滚动符 pt-query-digest 12345678910111213# 下载安装apt-get install percona-tookit -ypt-query-digest --helppt-query-digest /var/log/mysql/mysql-slow.log | more# 输出到文件pt-query-digest slow-log &gt; slow_log.report# 输出到数据库pt-query-digest slow.log -review \\h=127.0.0.1, D=test, p=root, P=3306, u=root, t=query_review \\--create-reviewtable \\--review-history t = hostname_slow 在 pt-query-digest 的分析结果中，主要关注： 查询次数多且每次查询占用时间长的 SQL：通常为 pt-query-digest 分析的前几个查询。 IO 大的 SQL：注意 pt-query-digest 分析中的 ‘Rows examine’ 项目。 未命中的 SQL：注意 pt-query-digest 分析结果中的 ‘Rows examine’ 和 ‘Rows Send’ 的对比。 常见优化场景count()如何同时查询到两个条件下的记录图条数？ 错误的查询： 12345-- 无法分开计算select count(k1='v1' or k2='v2') from tb;-- 逻辑错误select count(*) from tb where k1='v1' and k2='v2'; 正确的查询： 12select count(k1='v1' or null) as 'res1', (k2='v2' or null) as 'res2' from tb; count(*) 和 count(字段)123456create table tb(id int);insert into tb values (1), (2), (null);select count(*), count(id) from tb;-- count(*): 3-- count(id): 2 可见，count(*) 会返回含 NULL 的记录，而 count(字段) 的结果是不包括 null 的结果。 max()对 max() 的优化可以体现在创建索引的基础上。 举例说明，为 max() 函数的求值字段创建覆盖索引前后的对比： 123explian select max(age) from user\\Gcreate idx_age on user(age);explian select max(age) from user\\G 对比创建索引前后，明显的差别是，Extra 字段中从空到 ‘Select tables optimized away’，type 从 all 到 null，表明创建索引后查询操作只是通过索引来得到结果的，而没有进行表的操作，从而减少了 I/O 操作。 根据索引来查询的效率是比较恒定的。 子查询通常情况下，需要把子查询优化为 join 查询，但是在优化时要注意关联键是否有一对多的关系，要注意重复记录。 举例说明: 12345678create table t1 (id int);create table t2 (id int);-- 子查询select * from t1 where id in (select id from t2);-- join 查询select t1.id from t1 join t2 on t1.id = t2.id; 当关联的字段有一对多的关系时，比如： 12insert into t1 values(1);insert into t2 values(1), (1); 这时 t1 的 id = 1 的情况下，使用子查询是由一条记录，而使用 join 查询有 2 条记录。因此，如果不想要重复记录，则需要使用 distinct 去重。 1select distinct t1.id from t1 join t2 on t1.id = t2.id; 注意：on 关联的左右字段不是一对一时，是一个比较出错的地方。 group by如果 explain 的结果 Extra 中使用了临时表和文件排序等 I/O 操作，则有必要进行这种优化( 也是使用索引的思想 )，尽量避免使用临时表和文件排序，group by 什么字段就 using 什么字段。 当然，也可以增加一些过滤条件实现同样的效果和性能，不过需要注意在子查询中增加过滤条件。 使用 sakila 数据库举例说明： 12345678910111213141516-- 优化前explainselect actor.first_name, actor.last_name, count(*)from sakila.film_actorinner join sakila.actor using(actor_id)group by film_actor.actor_id;-- 优化后( 减少连接表中不必要的字段 )explainselect actor.first_name, actor.last_name, c.cntfrom sakila.film_actorinner join ( select actor_id, count(*) as cnt from sakila.film_acotr group by actor_id) as c using(actor_id) limitlimit 常用语分页处理，和 order by 从句共同使用，因此经常使用 Filesorts 这样的，会造成大量的 I/O 操作的问题。 举例说明： 优化前 1234select film_id, descriptionfrom sakila.filmorder by titlelimit 50, 5; 优化后 12345678910111213-- 1. 使用有索引的列或者主键进行 order by 操作select film_id, descriptionfrom sakila.filmorder by film_idlimit 50, 5;-- 2. 记录上次返回的主键, 下次查询时使用主键过滤select film_id, descriptionfrom sakila.filmwhere film_id &gt; 55and film_id &lt;= 60order by film_idlimit 1, 5; 使用第二种优化方式时，可以避免数据量过大时扫描过多的记录。 不过，有个前提条件就是主键要是连续增长的，如果不是连续，那么很可能列出的记录数量不符合预期的情况。如果不满足这个前提条件，可以新增一个附加列（自增，并建立好索引），然后根据这个附加列查找。 其他MySQL 提供的测试数据库 查看 MySQL 版本是否大于 5.5：select @@version;（版本不同优化器有差别） 下载、导入 sakila 数据库 123456unzip sakila.zipmysql -uroot -psource sakila-db/sakila-schema.sqlsource sakila-db/sakila-data.sqluse sakila;show tables; -- 23 rows 可能用到的 Linux 命令123find / -name logtail -50 /path/to/file.logmysqldumpslow -h 参考 SAN vs. NAS: What Is the Difference? MySQL 优化","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"优化","slug":"优化","permalink":"http://blog.caoxl.com/tags/优化/"}]},{"title":"Let's Encrypt 简单使用","slug":"Lets-Encrypt-My-Homepage","date":"2018-01-17T06:37:53.000Z","updated":"2019-08-22T03:47:55.000Z","comments":true,"path":"2018/01/17/Lets-Encrypt-My-Homepage/","link":"","permalink":"http://blog.caoxl.com/2018/01/17/Lets-Encrypt-My-Homepage/","excerpt":"初次部署 https 使用 Let’s Encrypt给域名加把小绿锁 Let’s Encrypt 客户端安装1234567# yum install -y epel-release nginx gitgit clone https://github.com/letsencrypt/letsencryptcd letsencrypt./letsencrypt-auto --help","text":"初次部署 https 使用 Let’s Encrypt给域名加把小绿锁 Let’s Encrypt 客户端安装1234567# yum install -y epel-release nginx gitgit clone https://github.com/letsencrypt/letsencryptcd letsencrypt./letsencrypt-auto --help 获取 SSL 证书证书申请频率限制 IP 限制：每注册 IP 每 3 个小时不超过 10 次 域名数量限制：每个域名（包含子域名）每 7 天不超过 5 个 Let’s Encrypt 验证方式有很多种，我使用的服务器已经运行了 nginx 且不想终止 web 服务，因此使用 webroot 模式。 webroot 模式1./letsencrypt-auto certonly --webroot --webroot-path /home/wwwroot/default -d caoxl.com --agree-tos --email code0809@163.com 注意: /home/wwwroot/defaul 是项目根目录 certonly 模式当然，除了 webroot 模式，也可以是用先手动只获取证书，然后配置 nginx。 12345service nginx stop# Or: systemctl stop nginxss -tln./letsencrypt-auto certonly --standalone -d caoxl.com 唯一需要注意的一点就是，certonly 模式下获取证书需要先关闭 nginx。 获取成功后，会输出类似如下内容： 12345678910111213141516171819Saving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator standalone, Installer NoneObtaining a new certificatePerforming the following challenges:tls-sni-01 challenge for caoxl.comWaiting for verification...Cleaning up challengesIMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at: /etc/letsencrypt/live/caoxl.com/fullchain.pem Your key file has been saved at: /etc/letsencrypt/live/caoxl.com/privkey.pem Your cert will expire on 2017-05-08. To obtain a new or tweaked version of this certificate in the future, simply run letsencrypt-auto again. To non-interactively renew *all* of your certificates, run \"letsencrypt-auto renew\" - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let's Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 然后，注意上面成功提示信息中的证书和私钥文件的路径，用于接下来 nginx 的配置。 证书: /etc/letsencrypt/live/caoxl.com/fullchain.pem 私钥文件: /etc/letsencrypt/live/caoxl.com/privkey.pem 生成 dhparam为了进一步提高安全性，建议为 nginx 再生成 2048 位 DH parameters： 1openssl dhparam -out /etc/ssl/certs/dhparams.pem 2048 关于 DH Parameters 的解释，可以参考：What’s the purpose of DH Parameters?。 nginx 部署 ssl 证书为域名配置 443 端口的虚拟主机 我的LNMP环境, 打开 /usr/local/nginx/conf/vhost/caoxl.com.conf 1234567891011121314151617181920212223# caoxl.com.confserver &#123; listen 80; listen 443 ssl http2; server_name caoxl.com www.caoxl.com; ssl_certificate /etc/letsencrypt/live/caoxl.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/caoxl.com/privkey.pem; ssl_dhparam /etc/ssl/certs/dhparams.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; ssl_prefer_server_ciphers on; ssl_session_timeout 10m; ssl_session_cache builtin:1000 shared:SSL:10m; ssl_buffer_size 1400; add_header Strict-Transport-Security max-age=15768000; ssl_stapling on; ssl_stapling_verify on; server_name caoxl.com www.caoxl.com; location / &#123; root caoxl.com; index index.html index.htm; &#125;&#125; http 强跳转 https（为同样的域名配置 80 端口的虚拟主机）123456# caoxl.com.confserver &#123; listen 80; server_name caoxl.com www.caoxl.com; return 301 https://caoxl.com;&#125; 重载配置后测试12nginx -tnginx -s reload 然后访问 https://caoxl.com 和 http://caoxl.com，不出意外应该就能在浏览器地址栏最左端看到一把靠谱的小绿锁了。 点击此处输入域名查询SSL证书 证书续期由于 Let’s Encrypt 颁发的服务器证书有效期只有 90 天，因此如果需要长期使用，就有必要设置好自动续期。 通过 letsencrypt-auto 工具，手动续期命令为：1./letsencrypt-auto renew 而所谓的自动续期，就是自动定时执行上面手动获得证书的操作，对于 Linux 来说，可以使用 crontab。 1echo '@monthly root /path/to/letsencrypt-auto certonly --webroot --webroot-path /home/wwwroot/default -d caoxl.com --agree-tos --email code0809@163.com &gt;&gt; /var/log/letsencrypt/letsencrypt-auto-update.log' | tee --append /etc/crontab 其他姿势acme.sh以 nginx 为例：123456789101112131415161718192021# 0. 安装 acme.sh curl https://get.acme.sh | sh# 1. 获取证书acme.sh --issue -d www.example.com -w /path/to/webapp# 2. 生成 dhparam# 同上，略# 3. 拷贝证书到 WEB 服务器能正常读取的路径 (安装证书)acme.sh --installcert -d example.com \\--key-file /usr/local/nginx/conf/ssl/example.com.key \\--fullchain-file /usr/local/nginx/conf/ssl/fullchain.cer \\# --reloadcmd \"service nginx force-reload\" # 可选，我是安装证书完成后，手动改完配置再重启的# 4. 配置 nginxssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_prefer_server_ciphers on;listen 443 ssl;ssl_certificate /path/to/ssl/example.com.cer;ssl_certificate_key /path/to/ssl/example.com.key;ssl_dhparam /path/to/ssl/dhparam.pem;# 5. 强制重启 nginxnginx -tnginx -s reload # 如果证书配置不能被加载成功，请强制性重启 nginx FAQ 已经成功安装配置好证书，部分 URL 仍然显示非安全？ 显示非安全的 URL 页面里面含有 mixed content。 When you set a site to use SSL, all the contents, urls to load js, images, etc. should have https links instead of http. 简单来说:就是网站内包含不安全内容 使用 oneinstack 新建 vhost 时安装 let‘s Encrypt 提示：DNS problem: NXDOMAIN looking up A 这可能是因为在域名解析设置那里，给这个域名设置了 CDN 的 CNAME（出于加速静态文件和隐藏服务器真实地址的原因），而阿里云不能给相同主机头（RR）同时设置一个 CNAME 和 A 纪录，导致 Let’s Encrypt 检测不通过，只能删除 CNAME 纪录。 To fix these errors, please make sure that your domain name was entered correctly and the DNS A/AAAA record(s) for that domain contain(s) the right IP address. 查看域名解析中 A 记录中的IP地址是否指向自己的服务器IP地址,且只能指向自己的服务器IP地址,不可多个指向. 我刚开始一直遇到这个问题就是因为的我A记录指向了两个不同的IP 此外，对于所申请 Let’s Encrypt 证书的域名来说，其顶级域名对应的 www 子域名必须要有一个 A 记录。可参考 LE 的该社区讨论：No WWW Record in DNS Means Certficate Cannot Be Issued。 Problem binding to port 443: Could not bind to IPv4 or IPv6.. Skipping执行证书续期命令的时候先，暂停 nginx，续期成功后再启动 nginx 即可。 参考 如何获得Let’s Encrypt证书？Apache+Ubuntu Let’s Encrypt SSL证书配置 SSL Server Test 或者叫检测网站的证书 oneinstack自动部署Lets Encrypt实现多域名SSL 设置解析记录时提示冲突的原因 如何选购 SSL 证书","categories":[{"name":"计算机专业必备","slug":"计算机专业必备","permalink":"http://blog.caoxl.com/categories/计算机专业必备/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"http://blog.caoxl.com/tags/HTTPS/"},{"name":"Let's Encrypt","slug":"Let-s-Encrypt","permalink":"http://blog.caoxl.com/tags/Let-s-Encrypt/"},{"name":"服务器","slug":"服务器","permalink":"http://blog.caoxl.com/tags/服务器/"}]},{"title":"基于Lumen5.4 使用JWT","slug":"JWT-Lumen54-Custom","date":"2018-01-17T03:44:58.000Z","updated":"2019-08-22T06:20:56.000Z","comments":true,"path":"2018/01/17/JWT-Lumen54-Custom/","link":"","permalink":"http://blog.caoxl.com/2018/01/17/JWT-Lumen54-Custom/","excerpt":"JWT在Lumen5.4中的应用 在公司Lumen5.4框架中使用了JWT Lumen5.4开发记录另见: Lumen5.4-开发记录-转","text":"JWT在Lumen5.4中的应用 在公司Lumen5.4框架中使用了JWT Lumen5.4开发记录另见: Lumen5.4-开发记录-转 启用自定义 JWT 认证 composer.json中添加(推荐composer安装)123\"require\": &#123; \"firebase/php-jwt\": \"^5.0\",&#125; 首先在 bootstrap/app.php 中启用： 123$app-&gt;routeMiddleware([ 'auth_jwt' =&gt; App\\Http\\Middleware\\Auth\\JWT::class,]); 然后修改 app/Http/Middleware/Auth/JWT.php 为： 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\\Http\\Middleware\\Auth;use Closure;use Firebase\\JWT\\JWT as FirebaseJWT;class JWT&#123; protected $auth = false; public function __construct() &#123; try &#123; if (isset($_SERVER['HTTP_AUTHORIZATION'])) &#123; $this-&gt;auth = FirebaseJWT::decode( $_SERVER['HTTP_AUTHORIZATION'], env('APP_KEY'), ['HS256'] ); &#125; &#125; catch (\\Exception $e) &#123; &#125; finally &#123; &#125; &#125; public function handle($request, Closure $next) &#123; if (false === $this-&gt;auth) &#123; return response()-&gt;json([ 'error' =&gt; 'Unauthorized' ], 401); &#125; $request-&gt;attributes-&gt;add([ 'auth_jwt' =&gt; $this-&gt;auth, ]); return $next($request); &#125;&#125; 将中间件的值传递给控制器 Pass value from middleware to controller 1234567891011121314/ 1. Middlewarepublic function handle($request, Closure $next)&#123; $request-&gt;attributes-&gt;add([ 'key' =&gt; 'value' ]); return $next($request);&#125;// 2. Controllerpublic function getVauleFromMiddleware(Request $req)&#123; echo $req-&gt;get('key'); // output: value&#125; 通过这种方式，可以对不同的路由使用不同的认证（非常语义化），然后把各种认证的结果（jwt，七牛）传递到控制器，可以使控制器不用再操心认证逻辑，减少控制器代码量。 CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 如果是客户端是浏览器，则在调用 API 的时候，基本上无法避免跨域问题。 不过处理也很简单，需要浏览器和服务器同时配合：浏览器在发起 OPTIONS preflight 请求的时候，服务器返回认可的一些信息就行了。 具体如下： app/Http/Middleware/CORS.php12345678910111213141516171819202122&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CORS&#123; public function __construct() &#123; &#125; public function handle($request, Closure $next) &#123; $headers = [ 'Access-Control-Allow-Origin' =&gt; '*', 'Access-Control-Allow-Methods' =&gt; '*', 'Access-Control-Allow-Headers' =&gt; 'Access-Control-Allow-Origin, AUTHORIZATION', 'Access-Control-Max-Age' =&gt; 86400, ]; if ('OPTIONS' == $request-&gt;getMethod()) &#123; return response(null, 200, $headers); &#125; return $next($request)-&gt;withHeaders($headers); &#125;&#125; bootstrap/app.php 1234// 指定全局中间件$app-&gt;middleware([ 'cors' =&gt; App\\Http\\Middleware\\CORS::class,]); jQuery AJAX Demo 123456789101112131415$.ajax(&#123; url: 'http://api.example.com/path/to/resource', type: 'GET', dataType: 'json', async: false, cors: true , headers: &#123; 'Access-Control-Allow-Origin': '*', 'AUTHORIZATION': 'JWT_STRING' &#125;, success: function (res) &#123; &#125;, error: function (xhr, status) &#123; &#125;&#125;); Example1234567891011121314151617181920212223&lt;?phpuse \\Firebase\\JWT\\JWT;$key = \"example_key\";$token = array( \"iss\" =&gt; \"http://example.org\", \"aud\" =&gt; \"http://example.com\", \"iat\" =&gt; 1356999524, \"nbf\" =&gt; 1357000000);$jwt = JWT::encode($token, $key);$decoded = JWT::decode($jwt, $key, array('HS256'));print_r($decoded);$decoded_array = (array) $decoded;JWT::$leeway = 60; // $leeway in seconds$decoded = JWT::decode($jwt, $key, array('HS256'));?&gt; Example with RS256 (openssl)1234567891011121314151617181920212223242526272829303132333435363738394041424344 &lt;?php use \\Firebase\\JWT\\JWT; $privateKey = &lt;&lt;&lt;EOD -----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQC8kGa1pSjbSYZVebtTRBLxBz5H4i2p/llLCrEeQhta5kaQu/Rn vuER4W8oDH3+3iuIYW4VQAzyqFpwuzjkDI+17t5t0tyazyZ8JXw+KgXTxldMPEL9 5+qVhgXvwtihXC1c5oGbRlEDvDF6Sa53rcFVsYJ4ehde/zUxo6UvS7UrBQIDAQAB AoGAb/MXV46XxCFRxNuB8LyAtmLDgi/xRnTAlMHjSACddwkyKem8//8eZtw9fzxz bWZ/1/doQOuHBGYZU8aDzzj59FZ78dyzNFoF91hbvZKkg+6wGyd/LrGVEB+Xre0J Nil0GReM2AHDNZUYRv+HYJPIOrB0CRczLQsgFJ8K6aAD6F0CQQDzbpjYdx10qgK1 cP59UHiHjPZYC0loEsk7s+hUmT3QHerAQJMZWC11Qrn2N+ybwwNblDKv+s5qgMQ5 5tNoQ9IfAkEAxkyffU6ythpg/H0Ixe1I2rd0GbF05biIzO/i77Det3n4YsJVlDck ZkcvY3SK2iRIL4c9yY6hlIhs+K9wXTtGWwJBAO9Dskl48mO7woPR9uD22jDpNSwe k90OMepTjzSvlhjbfuPN1IdhqvSJTDychRwn1kIJ7LQZgQ8fVz9OCFZ/6qMCQGOb qaGwHmUK6xzpUbbacnYrIM6nLSkXgOAwv7XXCojvY614ILTK3iXiLBOxPu5Eu13k eUz9sHyD6vkgZzjtxXECQAkp4Xerf5TGfQXGXhxIX52yH+N2LtujCdkQZjXAsGdm B2zNzvrlgRmgBrklMTrMYgm1NPcW+bRLGcwgW2PTvNM= -----END RSA PRIVATE KEY-----EOD; $publicKey = &lt;&lt;&lt;EOD -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC8kGa1pSjbSYZVebtTRBLxBz5H 4i2p/llLCrEeQhta5kaQu/RnvuER4W8oDH3+3iuIYW4VQAzyqFpwuzjkDI+17t5t 0tyazyZ8JXw+KgXTxldMPEL95+qVhgXvwtihXC1c5oGbRlEDvDF6Sa53rcFVsYJ4 ehde/zUxo6UvS7UrBQIDAQAB -----END PUBLIC KEY-----EOD; $token = array( \"iss\" =&gt; \"example.org\", \"aud\" =&gt; \"example.com\", \"iat\" =&gt; 1356999524, \"nbf\" =&gt; 1357000000 ); $jwt = JWT::encode($token, $privateKey, 'RS256'); echo \"Encode:\\n\" . print_r($jwt, true) . \"\\n\"; $decoded = JWT::decode($jwt, $publicKey, array('RS256')); $decoded_array = (array) $decoded; echo \"Decode:\\n\" . print_r($decoded_array, true) . \"\\n\";?&gt; Lumen5.4-Example","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"JWT","slug":"JWT","permalink":"http://blog.caoxl.com/tags/JWT/"}]},{"title":"JWT 多用户认证","slug":"JWT-Laravel52-User-Auth","date":"2018-01-17T03:04:43.000Z","updated":"2019-08-22T03:59:13.000Z","comments":true,"path":"2018/01/17/JWT-Laravel52-User-Auth/","link":"","permalink":"http://blog.caoxl.com/2018/01/17/JWT-Laravel52-User-Auth/","excerpt":"Json Web Token JWT在Laravel5.2中的应用 JWT代表Json Web Token.JWT能有效地进行身份验证并连接前后端。 降地耦合性，取代session，进一步实现前后端分离 减少服务器的压力 可以很简单的实现单点登录","text":"Json Web Token JWT在Laravel5.2中的应用 JWT代表Json Web Token.JWT能有效地进行身份验证并连接前后端。 降地耦合性，取代session，进一步实现前后端分离 减少服务器的压力 可以很简单的实现单点登录 实现API安装扩展1composer require tymon/jwt-auth 之后打开config/app.php文件添加service provider 和 aliase config/app.php12345678'providers' =&gt; [ .... Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider::class, // 注意这里的名字,下文会提到],'aliases' =&gt; [ .... 'JWTAuth' =&gt; Tymon\\JWTAuth\\Facades\\JWTAuth::class], OK，现在来发布JWT的配置文件，比如令牌到期时间配置等1php artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\JWTAuthServiceProvider\" 最后一步需要生成JWT Key1php artisan jwt:generate 创建API路由我在创建Api路由的时候会用到一个“cors”中间件，虽然它不是强制性的，但是后面你会发现报类似这样的错 1Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://xxx.com/api/register. (Reason: CORS header 'Access-Control-Allow-Origin' missing) 大致翻译下，“跨源请求阻塞:同源策略不允许读取http://kylesean.com/api/register远程资源。(原因:CORS 头“Access-Control-Allow-Origin” 没有)。” 这就是跨域请求导致的错误消息，当然你可以自定义Header，Origin, Method来解决跨域问题,不过我这边推荐一个package：barryvdh/laravel-cors(最新稳定版是0.8.2)，这里安装过程省略。 创建中间件1php artisan make:middleware CORS 进入app/Http/Middleware，编辑CORS.php app/Http/Middleware/CORS.php12345678910111213141516171819202122namespace App\\Http\\Middleware;use Closure;class CORS&#123; public function handle($request, Closure $next) &#123; header('Access-Control-Allow-Origin: *'); $headers = [ 'Access-Control-Allow-Methods'=&gt; 'POST, GET, OPTIONS, PUT, DELETE', 'Access-Control-Allow-Headers'=&gt; 'Content-Type, X-Auth-Token, Origin' ]; if($request-&gt;getMethod() == \"OPTIONS\") &#123; return Response::make('OK', 200, $headers); &#125; $response = $next($request); foreach($headers as $key =&gt; $value) $response-&gt;header($key, $value); return $response; &#125;&#125; Ok,在app/Http/Kernel.php注册中间件 app/Http/Kernel.php1234567891011namespace App\\Http;use Illuminate\\Foundation\\Http\\Kernel as HttpKernel;class Kernel extends HttpKernel&#123; ... ... protected $routeMiddleware = [ ... 'cors' =&gt; \\App\\Http\\Middleware\\CORS::class, ];&#125; 有了这个中间件我们就解决了跨域问题。接下来回到路由 app/Http/routes.php1234567Route::group(['middleware' =&gt; ['api','cors'],'prefix' =&gt; 'api'], function () &#123; Route::post('register', 'ApiController@register'); // 注册 Route::post('login', 'ApiController@login'); // 登陆 Route::group(['middleware' =&gt; 'jwt.auth'], function () &#123; Route::post('get_user_details', 'APIController@get_user_details'); // 获取用户详情 &#125;);&#125;); 建议：过滤掉路由api/*下的csrf_token，方便测试开发 上面的jwt-auth中间件现在还是无效的，接着创建这个middleware1php artisan make:middleware authJWT 同样的我们需要编辑下这个authJWT.php app/Http/Middleware/authJWT.php1234567891011121314151617181920212223namespace App\\Http\\Middleware;use Closure;use Tymon\\JWTAuth\\Facades\\JWTAuth;use Exception;class authJWT&#123; public function handle($request, Closure $next) &#123; try &#123; // 如果用户登陆后的所有请求没有jwt的token抛出异常 $user = JWTAuth::toUser($request-&gt;input('token')); &#125; catch (Exception $e) &#123; if ($e instanceof \\Tymon\\JWTAuth\\Exceptions\\TokenInvalidException)&#123; return response()-&gt;json(['error'=&gt;'Token 无效']); &#125;else if ($e instanceof \\Tymon\\JWTAuth\\Exceptions\\TokenExpiredException)&#123; return response()-&gt;json(['error'=&gt;'Token 已过期']); &#125;else&#123; return response()-&gt;json(['error'=&gt;'出错了']); &#125; &#125; return $next($request); &#125;&#125; OK，接着注册该中间件 app/Http/Kernel.php1234567891011namespace App\\Http;use Illuminate\\Foundation\\Http\\Kernel as HttpKernel;class Kernel extends HttpKernel&#123; ... ... protected $routeMiddleware = [ ... 'jwt.auth' =&gt; \\App\\Http\\Middleware\\authJWT::class, ];&#125; 然后，我们创建控制器管理所有的请求 app/Http/Controllers/ApiController.php1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use App\\User;use Illuminate\\Support\\Facades\\Hash;use Tymon\\JWTAuth\\Facades\\JWTAuth;class ApiController extends Controller&#123; /*注册*/ public function register(Request $request) &#123; $input = $request-&gt;all(); $input['password'] = Hash::make($input['password']); User::create($input); return response()-&gt;json(['result'=&gt;true]); &#125; /*登陆*/ public function login(Request $request) &#123; $input = $request-&gt;all(); if (!$token = JWTAuth::attempt($input)) &#123; return response()-&gt;json(['result' =&gt; '邮箱或密码错误.']); &#125; return response()-&gt;json(['result' =&gt; $token]); &#125; /*获取用户信息*/ public function get_user_details(Request $request) &#123; $input = $request-&gt;all(); $user = JWTAuth::toUser($input['token']); return response()-&gt;json(['result' =&gt; $user]); &#125;&#125; 最后一步我们就来模拟一个请求来测试这个api,为了模拟本地跨域请求，我们简单的新建一个静态页面test.html1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script&gt;$.ajax(&#123; url: \"http://localhost/api/login\", dataType: \"json\", type: \"POST\", data: &#123;\"email\":kylesean@qq.com\",\"password\":\"123456\"&#125;, success: function (data) &#123; alert(data.result) &#125; // 这里我们用ajax请求测试，当然你也可以用Angular.js Vue.js&#125;);&lt;/script&gt;&lt;/html&gt; 这里我们要注意一下，以上测试我们仍是基于User table的,我们来模拟一下login过程，如果账号密码匹配成功，不出意外将会出现类似：123&#123; \"result\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOjEsImlzcyI6Imh0dHA6XC9cL2xvY2FsaG9zdFwvYXBpXC9sb2dpbiIsImlhdCI6MTQ3MzQ1MjUyNSwiZXhwIjoxNDczNDU2MTI1LCJuYmYiOjE0NzM0NTI1MjUsImp0aSI6IjA1M2IzNjliYzYyZjJiZjJmMGMxNjFiNzIxNzY4Y2MzIn0.4WeezpSgEKjNmDFxv1nMU9HxqJgBE7bPyaJDRK4iLeA\"&#125; 至此，我们已经实现了jwt的认证功能，那么我们接着完成下一半工作，实现jwt的多用户认证，即Jwt for Multi Auth.如果你的业务场景是的确需要多用户认证，比如为管理员admin单独生成一张表，恰好字段也是laravel auth user里面默认的name email password remember_token等，那么实现起来就方便的多，官方文档和网上的demo示例已经很多了，但是若结合这个laravel/jwt-auth扩展进行多用户认证，其实坑还是蛮多的，由于该扩展0.5.9似乎不支持多用户认证(反正不会帮我们自定义好guard，当然我们可以自己在AuthServiceProvider里用boot方法实现) 我在github issue里面看到好多人踩过此坑，结合我遇到的 总结一下，里面一个哥们说，得用^0.1@dev版本(什么鬼，what’s the fuck!),so 继续撸之： 实现JWT的多用户认证composer.json里修改为12345\"require\": &#123; ... \"tymon/jwt-auth\": \"^1.0@dev\", // 修改之前的,Or making a fresh start ...&#125; 同样app.php里进行配置12345678'providers' =&gt; [ .... Tymon\\JWTAuth\\Providers\\LaravelServiceProvider::class, // 上文已经提到过，这里的provider已经不是JWTauthServiceProvider],'aliases' =&gt; [ .... 'JWTAuth' =&gt; Tymon\\JWTAuth\\Facades\\JWTAuth::class], 发布配置文件1php artisan vendor:publish --provider=\"Tymon\\JWTAuth\\Providers\\LaravelServiceProvider\" 生成密钥1php artisan jwt:secret // 发现没 生成key的方法也变了，不是 php artisan jwt:generate了 接下来就是重点了，要设置好config/auth.php里面的配置项了，这里不能乱设置： config/auth.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 默认使用web这个guard */'defaults' =&gt; [ 'guard' =&gt; 'web', 'passwords' =&gt; 'users', ],'guards' =&gt; [ 'web' =&gt; [ 'driver' =&gt; 'session', 'provider' =&gt; 'users', ], 'api' =&gt; [ 'driver' =&gt; 'token', 'provider' =&gt; 'users', ], /** * 这里是我自定义的guard,这里我叫staffs，你也可以根据自己的业务需求设置admins等，并且我 * 需要实现json web token认证 */ 'staffs' =&gt; [ 'driver' =&gt; 'jwt', // 结合扩展这里定义即生效 'provider' =&gt; 'staffs' ] ],'providers' =&gt; [ 'users' =&gt; [ 'driver' =&gt; 'eloquent', 'model' =&gt; App\\User::class, // 这里注意修改命名空间 通常是'model' =&gt; App\\Models\\User::class, ], /** * 同样的这里定义自己的provider */ 'staffs' =&gt; [ 'driver' =&gt; 'eloquent', 'model' =&gt; App\\Models\\Staff::class, ] // 'users' =&gt; [ // 'driver' =&gt; 'database', // 'table' =&gt; 'users', // ],],'passwords' =&gt; [ 'users' =&gt; [ 'provider' =&gt; 'users', 'email' =&gt; 'auth.emails.password', 'table' =&gt; 'password_resets', 'expire' =&gt; 60, ], /** * 这里我并没有设置如下，因为我的staff表并没有email字段，默认的重置密码功能暂时没考虑 */ &lt;!-- 'staffs' =&gt; [ 'provider' =&gt; 'staffs', 'email' =&gt; 'auth.emails.password', 'table' =&gt; 'password_resets', 'expire' =&gt; 60, ],--&gt;] 下一步，创建我们的staff model Models\\staff.php123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace App\\Models;use Illuminate\\Auth\\Authenticatable;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Auth\\Passwords\\CanResetPassword;use Illuminate\\Foundation\\Auth\\Access\\Authorizable;use Illuminate\\Contracts\\Auth\\Authenticatable as AuthenticatableContract;use Illuminate\\Contracts\\Auth\\Access\\Authorizable as AuthorizableContract;use Tymon\\JWTAuth\\Contracts\\JWTSubject as AuthenticatableUserContract; class Staff extends Model implements AuthenticatableContract, AuthorizableContract, AuthenticatableUserContract&#123; use Authenticatable, Authorizable, CanResetPassword; protected $table = 'staffs'; protected $fillable = ['name', 'phone', 'password']; protected $hidden = ['password', 'remember_token']; public function getJWTIdentifier() &#123; return $this-&gt;getKey(); // Eloquent model method &#125; /** * @return array */ public function getJWTCustomClaims() &#123; return []; &#125;&#125; 好吧，接下来我们又要添加相关路由了 12Route::post('/api/login', 'StaffAuthController@login');Route::post('/api/register', 'StaffAuthController@register'); 控制器书写我们的业务逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849namespace App\\Http\\Controllers\\Staff;use App\\Models\\Staff;use Illuminate\\Http\\Request;use App\\Http\\Controllers\\Controller;use App\\Http\\Requests;use Illuminate\\Foundation\\Auth\\ThrottlesLogins;use Illuminate\\Foundation\\Auth\\AuthenticatesAndRegistersUsers;use Illuminate\\Support\\Facades\\Validator;use Tymon\\JWTAuth\\Facades\\JWTAuth;use Illuminate\\Support\\Facades\\Auth;class StaffAuthController extends Controller&#123; use AuthenticatesAndRegistersUsers, ThrottlesLogins; protected $guard = 'staffs'; /*注册*/ public function register(Request $request) &#123; $this-&gt;validate($request, [ 'phone' =&gt; 'required|max:16', 'password' =&gt; 'required|min:6', ]); $credentials = [ 'phone' =&gt; $request-&gt;input('phone'), 'password' =&gt; bcrypt($request-&gt;input('password')), ]; $id = Staff::create($credentials); if ($id) &#123; $token = Auth::guard($this-&gt;getGuard())-&gt;attempt($credentials); // 也可以直接guard('staffs') return response()-&gt;json(['result' =&gt; $token]); &#125; &#125; /*登录*/ public function login(Request $request) &#123; $credentials = $request-&gt;only('phone','password'); if ( $token = Auth::guard($this-&gt;getGuard())-&gt;attempt($credentials) ) &#123; return response()-&gt;json(['result' =&gt; $token]); &#125; else &#123; return response()-&gt;json(['result'=&gt;false]); &#125; &#125;&#123; 到现在，一个基于JWT的多用于认证系统雏形就建立就来了，这里面需要完善的东西很多，比如刷新token,退出登录，增加额外的中间件等， 参考 Laravel 5.2 使用 JWT 完成多用户认证 Feature: Laravel 5.2 Custom Authentication Guard and Driver","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"JWT","slug":"JWT","permalink":"http://blog.caoxl.com/tags/JWT/"}]},{"title":"JWT 基础知识","slug":"JWT-Basic-Notes","date":"2018-01-17T02:11:35.000Z","updated":"2018-08-28T03:28:12.000Z","comments":true,"path":"2018/01/17/JWT-Basic-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/17/JWT-Basic-Notes/","excerpt":"基于Token的身份验证——JWT 基于Token的身份验证用来替代传统的cookie+session身份验证方法中的session。","text":"基于Token的身份验证——JWT 基于Token的身份验证用来替代传统的cookie+session身份验证方法中的session。 JWT是啥？JWT就是一个字符串，经过加密处理与校验处理的字符串，形式为： 12A.B.Cheader.payload.secret A由JWT头部信息header加密得到 B由JWT用到的身份验证信息json数据加密得到 C由A和B加密得到，是校验部分 怎样生成A？ (header)header格式为： 1234&#123; \"typ\": \"JWT\", \"alg\": \"HS256\" &#125; 它就是一个json串，两个字段是必须的，不能多也不能少。alg字段指定了生成C的算法，默认值是 HS256将header用base64加密，得到A通常，JWT库中，可以把A部分固定写死，用户最多指定一个 alg 的取值 怎样计算B？ (payload)根据JWT claim set[用base64]加密得到的。claim set是一个json数据，是表明用户身份的数据，可自行指定字段很灵活，也有固定字段表示特定含义（但不一定要包含特定字段，只是推荐）。这里偷懒，直接用php中的代码来表示claim set了，重在说明字段含义: 1234567891011121314$token = array( \"iss\" =&gt; \"http://example.org\", #非必须。issuer 请求实体，可以是发起请求的用户的信息，也可是jwt的签发者。 \"iat\" =&gt; 1356999524, #非必须。issued at。 token创建时间，unix时间戳格式 \"exp\" =&gt; \"1548333419\", #非必须。expire 指定token的生命周期。unix时间戳格式 \"aud\" =&gt; \"http://example.com\", #非必须。接收该JWT的一方。 \"sub\" =&gt; \"jrocket@example.com\", #非必须。该JWT所面向的用户 \"nbf\" =&gt; 1357000000, # 非必须。not before。如果当前时间在nbf里的时间之前，则Token不被接受；一般都会留一些余地，比如几分钟。 \"jti\" =&gt; '222we', # 非必须。JWT ID。针对当前token的唯一标识 \"GivenName\" =&gt; \"Jonny\", # 自定义字段 \"Surname\" =&gt; \"Rocket\", # 自定义字段 \"Email\" =&gt; \"jrocket@example.com\", # 自定义字段 \"Role\" =&gt; [\"Manager\", \"Project Administrator\"] # 自定义字段); JWT遵循 RFC7519，里面提到claim set的json数据中，自定义字段的key是一个string，value是一个json数据。因此随意编写吧，很灵活。 个人初学，认为一个最基本最简单最常用的claim set为： 12345$token=array( \"user_id\" =&gt; 123456, #用户id，表明用户 \"iat\" =&gt; 1356999524, #token发布时间 \"exp\" =&gt; 1556999524, #token过期时间); 将claim set加密后得到B，学名payload 怎样计算C？ (secret)将A.B使用HS256加密（其实是用header中指定的算法），当然加密过程中还需要密钥（自行指定的一个字符串）。加密得到 C ，学名signature，其实就是一个字符串。作用类似于CRC校验，保证加密没有问题。 好了，现在A.B.C就是生成的token了。 怎样使用token？可以放到HTTP请求的请求头中，通常是Authorization字段。也有人说放到cookie。不过移动端app用cookie似乎不方便。 token应用流程？ 1.初次登录：用户初次登录，输入用户名密码 2.密码验证：服务器从数据库取出用户名和密码进行验证 3.生成JWT：服务器端验证通过，根据从数据库返回的信息，以及预设规则，生成JWT 4.返还JWT：服务器的HTTP RESPONSE中将JWT返还 5.带JWT的请求：以后客户端发起请求，HTTP REQUEST HEADER中的Authorizatio字段都要有值，为JWT","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://blog.caoxl.com/tags/JWT/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"JSON-WEB-TOKEN","slug":"JSON-WEB-TOKEN","date":"2018-01-16T10:41:39.000Z","updated":"2019-08-22T07:08:58.000Z","comments":true,"path":"2018/01/16/JSON-WEB-TOKEN/","link":"","permalink":"http://blog.caoxl.com/2018/01/16/JSON-WEB-TOKEN/","excerpt":"JSON-WEB-TOKEN JWT是什么?? 该文章转载自:简书:什么是JWT","text":"JSON-WEB-TOKEN JWT是什么?? 该文章转载自:简书:什么是JWT 什么是JWT? Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 起源说起JWT，我们应该来谈一谈基于token的认证和传统的session认证的区别。 传统的session认证我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。 但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来. 基于session认证所显露的问题Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。 扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。 CSRF: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。 基于token的鉴权机制基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。 流程上是这样的： 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持 CORS(跨来源资源共享) 策略，一般我们在服务端这么做就可以了 Access-Control-Allow-Origin: *。 那么我们现在回到JWT的主题上。 JWT长什么样？JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串。就像这样: 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ JWT的构成 第一部分我们称它为头部（header), 第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)， 第三部分是签证（signature). headerjwt的头部承载两部分信息： 声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256完整的头部就像下面这样的JSON： 1234&#123; 'typ': 'JWT', 'alg': 'HS256'&#125; 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 payload载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分 标准中注册的声明 公共的声明 私有的声明 标准中注册的声明 (建议但不强制使用) ： iss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明 ：公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密. 私有的声明 ：私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 定义一个payload:12345&#123; \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true&#125; 然后将其进行base64加密，得到Jwt的第二部分。1eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 signaturejwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 1234// javascriptvar encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);var signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 将这三部分用.连接成一个完整的字符串,构成了最终的jwt: 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。 如何应用一般是在请求头里加入Authorization，并加上 Bearer 标注： 12345fetch('api/user/1', &#123; headers: &#123; 'Authorization': 'Bearer ' + token &#125;&#125;) 服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的: 总结优点 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。 它不需要在服务端保存会话信息, 所以它易于应用的扩展 安全相关 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。 保护好secret私钥，该私钥非常重要。 如果可以，请使用https协议","categories":[{"name":"必备技能","slug":"必备技能","permalink":"http://blog.caoxl.com/categories/必备技能/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"http://blog.caoxl.com/tags/JWT/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"深入理解 Laravel","slug":"Dig-Into-Laravel","date":"2018-01-16T07:37:00.000Z","updated":"2019-08-22T06:05:07.000Z","comments":true,"path":"2018/01/16/Dig-Into-Laravel/","link":"","permalink":"http://blog.caoxl.com/2018/01/16/Dig-Into-Laravel/","excerpt":"理解Laravel 建议深入理解的时候，不要看中文翻译版。 在看 Laravel 手册的时候，关于系统架构的那几页篇幅始终看得懵懵懂懂的，今天得闲找了些资料看，把理解的成果记录一份在这里。","text":"理解Laravel 建议深入理解的时候，不要看中文翻译版。 在看 Laravel 手册的时候，关于系统架构的那几页篇幅始终看得懵懵懂懂的，今天得闲找了些资料看，把理解的成果记录一份在这里。 DI DI 依赖注入 作用 避免在代码中硬编码类依赖，使在 runtime 和 compile time 期间改变依赖成为可能。 由于实现了松耦合，项目变得： 易维护因为不用再担心依赖的实现改变后，依赖的类也要适应性修改。 方便单元测试当注入的是一个接口时，测试时可以很容易地创建一个实现该接口的测试类（mock）作为依赖传入，而不需要调用实际需要的类，避免一些单元测试期间并不希望做的实际操作。 模块化类与类之间各司其职，不再关心依赖的实现细节。 实现方式 通过 constructor12345678910111213class C&#123; // implementations...&#125;class A&#123; private $c; public function __construct(C $c) &#123; $this-&gt;c = $c; &#125;&#125; 因为构造方法只会在实例化类的时候被调用，因此可以确保依赖一旦注入到实例后，在这个实例的 lifetime 期间，依赖始终存在，且不会被改变。 通过 setter12345678910111213class C&#123; // implementations...&#125;class B&#123; private $c; public function setC(C $c) &#123; $this-&gt;c = $c; &#125;&#125; 通过 setter 注入依赖是发生在类被实例化之后，这样的好处有： 方便注入那些可选的依赖，本类可以用默认值先创建出来，增加了灵活性。 简化了注入新依赖的过程：只要新增一个 setter 方法就行了，这并不会破坏现有代码，增强了便捷性和扩展性。 缺点 如果通过构造方法注入依赖 则会强制性注入所有依赖，这不适合那些只是可选的依赖。（适合注入一些必须依赖） 继承父类后，子类想要扩展和重写构造方法变得困难。 当项目规模增大时，虽然依赖注入实现了松耦合，但是这个解耦过程是通过手动来完成的，当依赖增多，手动注入依赖变成一项繁琐的工程。 什么时候需要依赖注入大型项目。小项目使用过多设计模式反复杂化。 IoC An IoC Container provides a central location to instantiate the application’s objects and pass their dependencies. If an object’s dependencies changes, this only needs to be set in one place, keeping your code DRY. IoC 容器， laravel 的核心 OOP 的一种设计模式。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。 Laravel 的核心就是一个 IoC 容器，根据文档，称其为“服务容器”，顾名思义，该容器提供了整个框架中需要的一系列服务。作为初学者，很多人会在这一个概念上犯难，因此，我打算从一些基础的内容开始讲解，通过理解面向对象开发中依赖的产生和解决方法，来逐渐揭开“依赖注入”的面纱，逐渐理解这一神奇的设计理念。 本文一大半内容都是通过举例来让读者去理解什么是 IoC（控制反转） 和 DI（依赖注入），通过理解这些概念，来更加深入。更多关于 laravel 服务容器的用法建议阅读文档即可 和 DI 的关系 Dependency Injection is one and most used way to achieve IoC Pattern, another is Dependency Lookup. An IoC Container is a convenience mechanism for achieving Dependency Injection. (Taylor Otwell) 简单来说: DI(依赖注入是配角),IoC(控制反转是主角) IoC Container 核心原理1234567891011121314151617181920212223242526class Container&#123; protected $binds; protected $instances; public function bind($abstract, $concrete) &#123; if ($concrete instanceof Closure) &#123; $this-&gt;binds[$abstract] = $concrete; &#125; else &#123; $this-&gt;instances[$abstract] = $concrete; &#125; &#125; public function make($abstract, $parameters = []) &#123; if (isset($this-&gt;instances[$abstract])) &#123; return $this-&gt;instances[$abstract]; &#125; array_unshift($parameters, $this); return call_user_func_array($this-&gt;binds[$abstract], $parameters); &#125;&#125; 这是一个只有基础骨架的 IoC Container 实现，Laravel 的实现比这个更智能一点，但是基本原理是一样的。 Laravel 的特性和功能几乎全部是由 IOC Container 实现的，如果想要使用 Laravel 的 IOC Container，也就是说想要用 IOC 的机制去 make 某种对象，那么你就必须先 bind 这个对象的类到 Laravel 的 IOC Container 中，才能把这种对象 make 出来。 需要注意的有： IoC Container 可以不止一个，所有继承了该类的子类，都属于 IoC Container，比如 Laravel 的 Application 类。 Laravel 中的其他类都是先绑定到 IoC Container 之后，再通过 IoC Container 实例化，实现自动注入管理的。 Service Container 服务容器 ServiceContainer 实现Contracts,具体的逻辑实现 Laravel 的核心，Service Container，其实就是一个 IoC Container，而无论叫什么名字，归根到实现底层实现，它们的目的只有一个：找到指定的类并实例化。 其实，我个人认为，现代 PHP 的很多核心概念，namaspace，PSR，autoload，Composer 等等，都是为了使「找到指定的类并实例化」这个操作变得简单化，自动化。 那么既然叫做 IoC Container 了，不同之处只是实现「找到指定的类并实例化」这个操作，是通过 IoC 的机制去实现的。 何为 Laravel IoC Container？ A container is an object that, as you may expect, contains things. Laravel’s IoC container is used to contain many, many different bindings. Everything you do in Laravel will at some point have an interaction with the IoC container. This interaction is generally in the form of a binding being resolved. 所以我的简单理解就是，「服务容器」就是存放类绑定关系的容器。 Laravel 使用 IoC Container 的两种方式 不通过 Service Provider，直接使用现成的 IoC Container 这个所谓的 「现成的 IoC Container」就是 Application 类，在 Laravel 启动后，bootstrap/app.php 中实例化了这个类，保存到变量 $app 了。 先将类或接口手动绑定到 $app，通过 $app 中直接解析依赖并实例化对象。举例如下： 1234567891011121314&lt;?phpnamespace App;// 1. define a classclass A&#123; public $foo = 'bar';&#125;// 2. bind class A to IoC containerApp::bind('a', function ($app) &#123; return new A;&#125;);// 3. make instance from A with IoC container$a = App::make('a');echo $a-&gt;foo; // bar 其中，App 也是一个 Facade，是 Laravel 为了让我们在程序的各处都能方便的得到 $app，或者说 Application 类实例，或者说 Laravel 生命周期内的 IoC Container。 通过 Service Provider（下面马上讲） Service Provider 服务提供者 ServiceProvider ServiceContainer的服务提供者，返回ServiceContainer的实例化，供其他地方使用，可以把它加入到app/config的provider中，会被自动注册到容器中 对，一个类要被容器所能够提取，必须要先注册至这个容器。既然 laravel 称这个容器叫做服务容器，那么我们需要某个服务，就得先注册、绑定这个服务到容器，那么提供服务并绑定服务至容器的东西，就是 服务提供者（ServiceProvider） 服务提供者主要分为两个部分，register（注册） 和 boot（引导、初始化），具体参考文档。register 负责进行向容器注册“脚本”，但要注意注册部分不要有对未知事物的依赖，如果有，就要移步至 boot 部分。 什么是「服务提供者」？ 我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，Laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的『服务提供者』。 我自己的简单理解就是，自动管理类依赖绑定、注册的机制。 这下其实就好理解了，「服务容器」，无论事先还是 runtime，存放了大量的类别名到实际类的绑定关系，而「服务提供者」的作用，可以将绑定关系存储到「服务容器」，并在某个类需要某个依赖的时候返回该依赖的实例。 为什么要通过「服务提供者」来使用 IoC Container？上面讲到，完全可以不通过服务提供者来使用 IoC Container，为啥非要经过这么一个机制“饶一圈”呢？ 其实还是一个量变引起质变的道理，当项目中只有少数几个类的时候，手动处理这些依赖关系是完全没问题的，但是当项目变复杂，变庞大的时候，人工解决这些依赖关系已经变得既累又不靠谱了，而把处理类与类之间的依赖关系这个过程，从手动变成自动，正是服务提供者的用处。 如何通过「服务提供者」来使用 IoC Container？无论是否通过服务提供者来使用 IoC Container，都需要往服务容器中绑定好 key 和实际类的关系。只不过通过「服务提供者」是通过其的 register 系列方法完成了 bind，甚至是 make instance 的操作。 这些服务提供者，在 config/app.php 的 providers 数组中定义了一组服务提供者，在 app/Providers/ 目录下也定义了一些服务提供者，它们都有一个 register() 方法，通过服务提供者来使用服务容器就是通过这个 register() 方法来完成的。 比如，config/app.php =&gt; providers =&gt; Illuminate\\Routing\\RoutingServiceProvider： 12345678910111213141516171819// ...// Register the service providerpublic function register()&#123; $this-&gt;registerRouter(); $this-&gt;registerUrlGenerator(); $this-&gt;registerRedirector(); $this-&gt;registerPsrRequest(); $this-&gt;registerPsrResponse(); $this-&gt;registerResponseFactory();&#125;// Register the router instanceprotected function registerRouter()&#123; $this-&gt;app['router'] = $this-&gt;app-&gt;share(function ($app) &#123; return new Router($app['events'], $app); &#125;);&#125;// ... 在服务提供者中，通过 $this-&gt;app 获得服务容器，然后注册一个 key 和实际类绑定。这里对于 RoutingServiceProvider 来说，顺便也返回了一个实例，即同时完成了 bind 和 make 操作。 Contracts 直接翻译: 合同/契约 Contracts 合同，契约，也就是接口，定义一些规则，每个实现此接口的都要实现里面的方法 Contracts 就是 OOP 里的 Interfaces，功能和用途上没有任何区别，之所以叫 Contracts 只是因为在 Laravel 中，接口所在的命名空间是 Illuminate\\Contracts 而已。 Facades 直接翻译: 门面/外墙 Facades 简化ServiceProvider的调用方式，而且可以静态调用ServiceContainer中的方法 Facades 只是一些方便调用绑定在 IoC 容器内的类，的类。其作用我总结的是：简化调用方式，减少代码量。 具体解释在参考中解释的很清楚了，没必要重复。这里只以一条路由为例，简单总结下 Facade 的执行过程： 我们使用的 Route 类实际上是 Illuminate\\Support\\Facades\\Route 通过 class_alias() 函数创造的 别名 而已，这个类被定义在文件 vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php 。 Route::get(‘/‘, ‘Site@index’) app/config/app.php =&gt; alias =&gt; Route =&gt; Illuminate\\Support\\Facades\\Route::class1234567891011amespace Illuminate\\Support\\Facades;/** * @see \\Illuminate\\Routing\\Router */class Route extends Facade&#123; protected static function getFacadeAccessor() &#123; return 'router'; &#125;&#125; Route 类的这个方法会在后面「后期静态绑定」时用到。 调用了一个 Route／Facade 类中都不存在的静态 get() 方法 =&gt; 触发 Facade 的 __callStatic() 方法12345678910111213141516171819202122232425262728293031323334353637383940414243// namespace Illuminate\\Support\\Facades;// abstract class Facade// 1. trigger magic method `__callStatic` by call `get()`public static function __callStatic($method, $args)&#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException('A facade root has not been set.'); &#125; switch (count($args)) &#123; case 0: return $instance-&gt;$method(); case 1: return $instance-&gt;$method($args[0]); case 2: // `Route::get('/', 'Site@index')` 会执行到这里 return $instance-&gt;$method($args[0], $args[1]); case 3: return $instance-&gt;$method($args[0], $args[1], $args[2]); case 4: return $instance-&gt;$method($args[0], $args[1], $args[2], $args[3]); default: return call_user_func_array([$instance, $method], $args); &#125;&#125;// 2. get facade instancepublic static function getFacadeRoot() &#123; // 这里的 `static::getFacadeAccessor()` 属于后期静态绑定 return static::resolveFacadeInstance(static::getFacadeAccessor());&#125;// 3. get resolved instance from $app/IoC containerprotected static function resolveFacadeInstance($name)&#123; if (is_object($name)) &#123; return $name; &#125; if (isset(static::$resolvedInstance[$name])) &#123; return static::$resolvedInstance[$name]; &#125; return static::$resolvedInstance[$name] = static::$app[$name];&#125; 这里，在第一次执行该代码的情况下，resolveFacadeInstance() 方法将 static::$app[$name] 保存到解析过的实例数组中，并返回 static::$app[$name] 的值。 这里之所以 static::$app[$name] 可以返回一个对象，是因为 $app/Application 继承了 Container，而 Container 又继承并实现了 ArrayAccess 的 offsetGet 方法： 123456// namespace Illuminate\\Container;// class Containerpublic function offsetGet($key)&#123; return $this-&gt;make($key);&#125; __callStatic 将执行到 return $instance-&gt;$method($args[0], $args[1]); 这里，而 $instance 就是 offsetGet() 返回的路由类对象，而 $method 就是那个 Route／Facade 都不存在的 get() 方法。于是，最终相当于执行了如下代码： 1(new Illuminate\\Routing\\Router)-&gt;get('/', 'Site@index') 终于，执行到 Illuminate\\Routing\\Router 的 get() 方法： 1234public function get($uri, $action = null)&#123; return $this-&gt;addRoute(['GET', 'HEAD'], $uri, $action);&#125; suggestion: class_alias(). 总的来说，自定义了一个类，为了方便在其他别处使用，便可以使用服务提供者和门面 参考 laravel 学习笔记 —— 神奇的服务容器 Digging in to Laravel’s IoC Container 从 1 行代码开始，带你系统性的理解 Laravel Service Container 的核心概念 Laravel应用","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"},{"name":"依赖注入","slug":"依赖注入","permalink":"http://blog.caoxl.com/tags/依赖注入/"},{"name":"DI","slug":"DI","permalink":"http://blog.caoxl.com/tags/DI/"},{"name":"IoC","slug":"IoC","permalink":"http://blog.caoxl.com/tags/IoC/"}]},{"title":"Laravel 基础知识","slug":"Laravel-Basic-knowledge","date":"2018-01-16T07:06:24.000Z","updated":"2019-08-22T03:58:56.000Z","comments":true,"path":"2018/01/16/Laravel-Basic-knowledge/","link":"","permalink":"http://blog.caoxl.com/2018/01/16/Laravel-Basic-knowledge/","excerpt":"记录Laravel的一些基础知识… 原文地址: Head into Laravel","text":"记录Laravel的一些基础知识… 原文地址: Head into Laravel 准备全局安装 Composer123456curl -sS https://getcomposer.org/installer | php -- --install-dir=bin --filename=composer# Or# php -r \"readfile('https://getcomposer.org/installer');\" | php# Or manually rename composer.phar to composer and link the composer binary file to $PATH 安装 Laravel/Lumen12345678composer global require laravel/installercomposer global require \"laravel/lumen-installer=~1.0\"vim ~/.zshrc# add `~/.composer/vendor/bin` to the $PATHsource ~/.zshrc 自带服务器运行12345laravel new site# or Lumen: `lumen new site`cd sitephp artisan serve --port 8888 注意 安装指定版本的 Laravel/Lumen 1composer create-project laravel/laravel blog \"5.1.*\" Blade布局视图12345&lt;!-- layouts/main.blade.php --&gt;@yield('title')@yield('header')@yield('content')@yield('footer') 普通视图12345678910111213141516171819202122&lt;!-- index.blade.php --&gt;@extends('layouts.main')@section('title', 'PAGE NAME')@section('header') &lt;!-- header detail --&gt; &#123;&#123; $variable-&gt;attr &#125;&#125;&lt;!-- Include sub view --&gt;@include('shared.navbar')@section('content') &lt;!-- content detail --&gt; @if (...) &#123;&#123; time() &#125;&#125; @elseif (...) &#123;&#123; some php code here &#125;&#125; @else &#123;&#123; php &#125;&#125; or html all ok @endif @section('footer') &lt;!-- footer detail --&gt;@stop&lt;!-- or @endsection --&gt; 更多例子参照(这里, 这里) Data将数据传递到视图 数组格式 1234Route::get('/', function () &#123; $data = [1, 2, 3] ; return view('welcome', ['data' =&gt; $data]);&#125;); compact() 1234Route::get('/', function () &#123; $data = [1, 2, 3] ; return view('welcome', compact('data'));&#125;); with() 1234Route::get('/', function () &#123; $data = [1, 2, 3] ; return view('welcome')-&gt;with('data' =&gt; $data);&#125;); 动态方法 1234Route::get('/', function () &#123; $data = [1, 2, 3] ; return view('welcome')-&gt;withData($data);&#125;); 数据库驱动 config/database.php 找到 &#39;default&#39; =&gt; env(&#39;DB_CONNECTION&#39;, &#39;mysql&#39;) ,修改成需要的驱动就可以了. If use sqlite(file based database for small project), please comment the DB_* fields in .env file. Migration Migration: The Version Controll of Database 12345678910# 1. define the table we want to createphp artisan make:migration create_users_table --create=user# 2. custom the table structure in /database/migrations/DATATIME_create_user_table.php@up() function# 3. actual create the table we defined before into our configured databasephp artisan migrate# 4. delete tables if we want modify it, migrate it to others env, etc.php artisan migrate:rollback Tinker 你的项目的所有PHP laravel方法能够被执行在Tinker 123php artisan tinkerDB::table('users')-&gt;get(); 命名空间等于文件夹结构。 命名空间的回顾在像PHP这样的编程语言中 命名空间用于放置类，避免类名相同时的歧义。 在laravel，定位的两种方法的类： use use \\Path\\To\\Class; before the class defination. use \\Classname in the function block. 注意，当您不使用任何命名空间时，PHP将在当前命名空间中搜索您需要的类。 查询生成器这是Laravel一个传统与数据层交互方式。 按照这里的演示：这里 AND 这里 Eloquent: ORM of Laravel简单地说，它只是MVC设计模式中的M层。 不同的是，它是在PHP的活动记录实现与数据库表进行交互，而不是使用传统的查询生成器。 其结果是，每个表有一个模型，模型代表表和表的增删改查选项更方便和愉快的模型。 在Laravel中的使用步骤: 1.Create table via make:migration 2.Insert data into the table 3.Make a Model reference to the table 1php artisan make:model Models/User -m # --migration - m 选项仅用于我们没有创建此模型响应的表时。 注意这里有一条规则： Model name must be singular, but table name must be plurals. 模型名称必须是单数，但表名必须是复数。 For example, model name of table histories should be history. 4.Using Model in controller For example, we have created a table users, and a model User in namespace App\\Models\\User, contents of App\\Http\\routes.php like these: 在路由中使用: 12345678910Route::get('users', 'Users@index');# below two routes are same intend, just for explain here# use only one way if you like// Will show specific user by idRoute::get('users/&#123;id&#125;', 'Users@show');// Will show specific user by instanceRoute::get('users/&#123;user&#125;', 'Users@show'); 在控制器中使用: 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use App\\Models\\User;class Users extends Controller&#123; /** * get all users */ public function index() &#123; return User::all() ; // Automatically JSON Response &#125; /** * 1. show specific user by id * !!! param name `$id` don't have to response to the `&#123;id&#125;` in routes defination */ public function show($id) &#123; $user = User::find($id) ; // Also JSON if has the result return $user ? $user : 'user not found' ; &#125; /** * 2. show specific user by instance * !!! param name `$user` must response to the `&#123;user&#125;` in routes defination */ public function show(User $user) &#123; return $user ; // JSON &#125;&#125; 5.Pass the result data to blade views when necessary 只需要注意: .是连接/目录的意思, 比如 view(users.show) 意思是 resources/views/users/show.blade.php Eloquent举个简单的例子 我们创建表: users, cards, notes 123php artisan make:model Models\\User -mphp artisan make:model Models\\Card -mphp artisan make:model Models\\Note -m 我们所定义的每个up()方法： 在 database/migrations/ CreateUsersTable: 12345Schema::create('users', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;string('name'); $table-&gt;timestamps();&#125;); CreateCardsTable: 123456Schema::create('cards', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;integer('user_id')-&gt;unsigned()-&gt;index(); $table-&gt;string('title'); $table-&gt;timestamps();&#125;); CreateNotesTable: 123456Schema::create('notes', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;integer('card_id')-&gt;unsigned()-&gt;index(); $table-&gt;text('content'); $table-&gt;timestamps();&#125;); 显然, 他们之间的关系: user has cards, cards has notes. 测试前, 运行迁移: 1php artisan migrate Ok then. How to define the relationship with Eloquent are basically the same, so we take the cards has notes relationship to explain how it works. 好吧, 怎么使用Eloquent关联模型基本一致, 所以我们就使用 cards has notes 的关系来解释. Get/Query No Eloquent 123456789101112php artisan tinker# 1. Prepare one card whose id = 1$card = new App\\Models\\Card;$card-&gt;user_id = 1; // assume it's 1 here$card-&gt;title = '1st card';$card-&gt;save();# 2. Create a note with it's card_id = 1$note = new App\\Models\\Note;$note-&gt;card_id = 1;$note-&gt;content = '1st note';$note-&gt;save(); Yes, it just manually relate their relationship. It’s a little bit inelegant. With Eloquent define the notes() method in Card Model 12345678910public function notes()&#123; return $this-&gt;hasMany(Note::class); // either `Note::class` or `\\App\\Models\\Note`&#125; public function path()&#123; return '/cards/' . $this-&gt;id;&#125; 当我们使用 \\App\\Models\\Notes 将转化成对象, 使用 Notes::class将转化成类的字符串表示形式。 call the notes() method in Card Model instance 1234567891011php artisan tinker$card = App\\Models\\Card::first()$card-&gt;notes-&gt;first() # as collection# Or# $card-&gt;notes[0] # as array# Or# $card-&gt;notes()-&gt;first() # as object 集合和对象的不同在于最后的查询sql 通过一个测试证明下: 1234567891011121314151617181920212223242526272829303132333435php artisan tinker # refresh the modifications in project# Setup a listener when query event occurs&gt;&gt;&gt; DB::listen(function ($query)&#123; echo $query-&gt;sql; &#125;&gt;&gt;&gt; $card = new App\\Models\\Card::first()select * from \"cards\" limit 1;# First execute the get-card-notes query&gt;&gt;&gt; $card-&gt;notesselect * from \"notes\" where \"notes\".\"card_id\" = ? and \"note\".\"card_id\" is not null# Re-execute the same query&gt;&gt;&gt; $card-&gt;notes# You will see nothing here because the last query result is stored in the $card object and fetch them directly from object rather than the database# Check if the $card object has the notes relationships here&gt;&gt;&gt; $card# You will see the notes of this card here# Check if notes relationship still exists after we refresh the object&gt;&gt;&gt; $card-&gt;fresh()select * from \"cards\" where \"id\" = ? limit 1&gt;&gt;&gt; $card# You wil note see the notes of this card here any more because the resuls cache are erased after `fresh()`# If we use as collection, the sql of get first note record might be like this:&gt;&gt;&gt; $card-&gt;fresh()-&gt;notes-&gt;first()select * from \"cards\" where \"id\" = ? limit 1select * from \"notes\" where \"notes\".\"card_id\" = ? and \"notes\".\"card_id\" is not null# If we use as object method, the sql of get first note record might be like this:&gt;&gt;&gt; $card-&gt;fresh()-&gt;notes()-&gt;first()select * from \"cards\" where \"id\" = ? limit 1select * from \"notes\" where \"notes\".\"card_id\" = ? and \"notes\".\"card_id\" is not null limit 1 测试结果和上面的结论一致. hasMany and belongsTo Moreover, we can say that note also belongs to card. So here is how eloquent deal with this belongs-to relationship here. 简单来说:就是 谁拥有谁==谁属于谁 define the card() method in Note Model: 1234public function card()&#123; return $this-&gt;belongsTo(Card::class);&#125; call the card method in Note Model instance 12345php artisan tinker$note = App\\Models\\Note::first()$note-&gt;card Be aware that: hasMany() related method is notes(), which is resonable because one card can has many notes, and belongsTo() related method is card(), which is resonable because one note only belongs to one card. 注意到: hasMany() 对应的方法是 notes (复数),是因为 一张卡可以有很多笔记, belongTo 对应的方法是 card() (单数),是因为 一个笔记只属于一张卡 你不应该创建方法名为 note() 或 cards()，因为它没有任何意义，必须回应你叫它什么方法。 记住，hasmany() 和复数的方法有关，belongsto()和单数的方法相关。 Create/save123456789101112131415161718php artisan tinker# Create a new Note$note = new App\\Models\\Note$nots-&gt;content = 'second note'# Decide which card to associate with$card = App\\Models\\Card::first()# Save a exists note by `save()`$card-&gt;notes()-&gt;save($note) # we cann't use $card-&gt;notes-&gt;save() here# Or create a new note by `create()`$card-&gt;notes()-&gt;create(['content'=&gt;'third note']) # make sure that `content` is fillable in Note Model# See the new note associated with first card$card-&gt;notes# Yout will see new note was already in $card object Notice that here we didn’t set the card_id for $note, because eloquent automatically did this for us. When we creating new record, we cann’t use collections any more, because it is only used for query-like operations. 此外，当我们通过 create()直接创建一个新的记录, 需要某个字段批量赋值如:content, 需要在$fillable定义. 123456789class Note extends Model&#123; protected $fillable = ['content']; public function card() &#123; return $this-&gt;belongsTo(Card::class); &#125;&#125; $fillable 可以作为设置被批量赋值的属性的「白名单」, 这也是Laravel中避免攻击的方法之一. Form基于之前的例子:我们有 resources/views/cards/show.blade.php 123456789101112131415161718192021222324252627282930313233@extends('layouts.main')@section('title', 'show card')@section('content')&lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;h1&gt; &#123;&#123; $card-&gt;title &#125;&#125; &lt;/h1&gt; &lt;ul class=\"list-group\"&gt; @foreach ($card-&gt;notes as $note) &lt;li class=\"list-group-item\"&gt; &#123;&#123; $note-&gt;content &#125;&#125; &lt;/li&gt; @endforeach &lt;/ul&gt; &lt;hr&gt; &lt;h2&gt; Add More Notes Here &lt;/h2&gt; &lt;form method=\"POST\" action=\"/cards/&#123;&#123; $card-&gt;id &#125;&#125;/notes\"&gt; &lt;input type=\"hidden\" name=\"_token\" value=\"&#123;&#123; csrf_token() &#125;&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;textarea name=\"content\" class=\"form-control\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;button type=\"submit\" class=\"btn btn-primary\"&gt; Add Note &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;@stop 创建 routes.php: 1Route::post('cards/&#123;card&#125;/notes', 'Notes@store'); 创建控制器 Notes@store: 12345678910111213141516171819202122232425262728293031public function store(Request $request, Card $card)&#123; // return $request-&gt;all(); // return \\Request::all(); // return request()-&gt;all(); // return $card; # 1 // $note = new Note; // $note-&gt;content = $request-&gt;content; // $card-&gt;notes()-&gt;save($note); # 2 // $card-&gt;notes()-&gt;save([ // new Note([ // 'content' =&gt; $request-&gt;content // ]) // ]); # 3 // $card-&gt;notes-&gt;create([ // 'content' =&gt; $request-&gt;content // ]); # 4 $card-&gt;notes()-&gt;create(request()-&gt;all()); // return \\Request::to('path/to/new/uri'); // return redirect()-&gt;to('path/to/new/uri'); return back();&#125; 注意: If you want use eloquent as an instance, the param name $card must equals to the route catch name {card}, here card equals card. Or $card in method will be nothing, which is unexpected. When we use create() to insert an relationship, we must make sure that we had stipulated the $fillable in related model, as we talked before. Since card and note has relationship here, so we can add a method to describle more clearer what we want to do, we can add a method addNote() in model Card, like this: 1234public function addNote(Note $note)&#123; $this-&gt;notes()-&gt;save($note);&#125; 最后, 控制器中 Notes@store(): 12345678public function store(Request $request, Card $card)&#123; $card-&gt;addNote( new Note($request-&gt;all()) ); return back();&#125; RESTful Principles ReviewRESTful接口整个说明本表： 资源控制器 此外，由于浏览器只直接理解GET和POST方法，所以遵循REST约定可以像这样做: 123456&lt;form method=\"POST\"&gt; &#123;&#123; method_field('PATCH | DELETE | PUT') &#125;&#125; &lt;!-- which equals to: --&gt; &lt;!-- &lt;input type=\"hidden\" name=\"method\" value=\"PATCH\"&gt; --&gt; &lt;!-- more form elements --&gt;&lt;/form&gt; Update And Eager Loading预先加载是避免大量的数据库查询该对象的数据可以得到一个查询通过建立laravel模型关系的有效途径。 Before we using eager loading, if we want to get both the notes of one card, and the user this card belongs to, we may query N+1 times like this (notes table must has fileds named with user_id and card_id): 1234public function showByInstance(Card $card)&#123; return $card-&gt;notes[0]-&gt;user;&#125; 这里需要查询两次, 这是低效的 使用预加载,我们可以将两次查询合并成一次,就像: 1234567891011public function showByInstance(Card $card)&#123; return $card-&gt;load('notes.user'); // notes means Card@notes() user means Note@user() # Or // return $card-&gt;with('notes.user'); # Or only load notes of this card // return $card-&gt;load('notes'); // return $card-&gt;with('note')-&gt;find(1); // 1 means this id of the card we want to find&#125; Validation Form input 123456public function addNote(Request $request, Card $card)&#123; $this-&gt;validate($request,[ 'content' =&gt; 'required|min:10' ]); // Controller =&gt; ValidatesRequests@validate&#125; CSRF: See detail in FAQ. Middleware 1234567Route::group([ 'middleware' =&gt; ['web'],], function () &#123; Route::post('cards/&#123;card&#125;/notes', 'Cards@addNote'); // Route::post('cards/&#123;card&#125;/notes', 'Notes@store'); // More routes&#125;); Errors 每个视图都可以共享($errors)错误变量。 old(&#39;field_name&#39;) When form check fails, the preview wrong data are withInput() in the redirect, and we can put it into the right elements. 通过 old(),获取上一次输入的内容. FAQ php artisan migrate:reset failed to open stream: No such file or directory? 1composer dump-autoload TokenMismatchException in VerifyCsrfToken.php Line 67? 12345&lt;input type=\"hidden\" name=\"_token\" value=\"&#123;&#123; csrf_token() &#125;&#125;\"&gt;&lt;!-- Or --&gt;&#123;&#123; csrf_field() &#125;&#125;&lt;!-- Or set into meta tag --&gt;&lt;meta name=\"csrf-token\" content=\"&#123;&#123; csrf_token() &#125;&#125;\"&gt; What’s the differences between PUT and PATCH? 1234PUT = replace the ENTIRE RESOURCE with the new representation provided (no mention of related resources in the spec from what i can see)// 用所提供的新表示替换整个资源（在我所看到的规范中没有提到相关资源）PATCH = replace parts of the source resource with the values provided AND|OR other parts of the resource are updated that you havent provided (timestamps) AND|OR updating the resource effects other resources (relationships) 重置和刷新命令列表 php artisan clear-compiled: 删除已编译的类文件 php artisan auth:clear-resets: 刷新过期密码重置令牌 php artisan cache:clear: 刷新应用程序缓存 php artisan config:clear: 删除配置缓存文件 php artisan migrate:refresh: 重置并重新运行所有迁移 Same with migrate:rollback, they will erase the data in database. php artisan migrate:reset: 回滚所有数据库迁移 php artisan queue:flush: 刷新所有失败的队列作业 php artisan queue:forget: 删除失败的队列作业 php artisan route:clear: 删除路由缓存文件 php artisan view clear: 清除所有的编译文件 参考(References) Laracasts Laravel 5.6(英文) Laravel 5.5(中文) Laravel 维基百科 Laravel/Lumen Your One-Stop Guide to Laravel Commands","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"Laravel 使用笔记","slug":"Laravel-Dev-Notes","date":"2018-01-16T07:01:17.000Z","updated":"2019-08-22T03:58:58.000Z","comments":true,"path":"2018/01/16/Laravel-Dev-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/16/Laravel-Dev-Notes/","excerpt":"Laravel Dev Notes 学习别人的博客,并且转载的… 路由as 在路由定义中的作用？如何使用？如何向命名过的含参数的路由传递参数？ 命名路由让你可以更方便的「为特定路由生成 URL 」或「进行重定向」。","text":"Laravel Dev Notes 学习别人的博客,并且转载的… 路由as 在路由定义中的作用？如何使用？如何向命名过的含参数的路由传递参数？ 命名路由让你可以更方便的「为特定路由生成 URL 」或「进行重定向」。 12345678910111213141516171819202122# 1. 定义路由 并为其命名# 第一种 =&gt; 通过数组键 `as` 命名Route::get('user/profile/&#123;id&#125;', ['as' =&gt; 'profile', function () &#123; echo 'user/profile/&#123;id&#125;';&#125;]);# 命名路由群组和子路由Route::group(['as' =&gt; 'admin::'], function () &#123; Route::get('dashboard', ['as' =&gt; 'dashboard', function () &#123; // 路由名称为「admin::dashboard」 &#125;]);&#125;);# 第二种 =&gt; 通过链式调用 `name()` 方法命名Route::get('user/profile/&#123;id&#125;', 'UserController@showProfile')-&gt;name('profile');# 2. 使用命名过的路由Route::get('test_profile', function () &#123; return redirect()-&gt;route('profile', ['id' =&gt; 1]); // 这里的 `profile` 就是某条路由定义过的命名; `id` 就是该路由中的参数名 return redirect()-&gt;route('admin::dashboard'); // 重定向到路由群组命名过的子路由 # Or # return redirect()-&gt;to(route('profile'));&#125;); 路由参数限制 可选路由参数1234# 参数名后面 结束 `&#125;` 之前的 `?` 代表此路由参数为可选参数Route::get('user/&#123;name?&#125;', function ($name = 'John') &#123; return $name;&#125;); 正则过滤路由参数：未通过正则检查的路由参数将会出现 NotFoundHttpException 报错12345678910# 局部限制Route::get('user/&#123;id&#125;', function ($id) &#123; // ...&#125;)-&gt;where('id', '[0-9]+');# 全局限制 =&gt; boot()@/app/Providers/RouteServiceProvider.phppublic function boot(Router $router)&#123; $router-&gt;pattern('id', '[0-9]+'); // 模式一旦被定义，便会自动应用到所有使用该「参数名称」的路由上 parent::boot($router);&#125; url() 和 route() 的区别 url() 可以生成任意的 URL，不检查是否是合法路由。 route() 则会接受命名过的路由别名，然后生成 URL。如果路由别名不存在，则会报错。 关于子域名路由 子域名可以像路由 URIs 分配路由参数。 12345Route::group(['domain' =&gt; '&#123;account&#125;.myapp.com'], function () &#123; Route::get('user/&#123;id&#125;', function ($account, $id) &#123; // &#125;);&#125;); 这里需要额外说明的是，要使用上子域名这个功能，必须要在域名解析那里将所有具体的子域名指向和主域名同样的服务器（泛解析），同样的网站路径下，才有意义。 路由群组共用参数和嵌套群路由 在路由的第一个数组数组参数中的 prefix 键，代表的是「当前群路由」中共用的路由前缀，其值也可以包含参数： 1234567891011121314151617Route::group([ 'as' =&gt; 'admin::', 'prefix' =&gt; 'admin', ], function () &#123; Route::get('dashboard', ['as' =&gt; 'dashboard', function () &#123; // 路由名称为「admin::dashboard」 // URL =&gt; route('admin::dashboard'); &#125;]); // 嵌套群路由 Route::group([ 'prefix' =&gt; 'accounts/&#123;account_id&#125;' // 路由群组共用参数 ], function () &#123; Route::get('detail', function ($account_id) &#123; // URL =&gt; /admin/accounts/&#123;account_id&#125;/detail &#125;); &#125;);&#125;); 中间件POST API 中禁用 CSRF 中间件1234// App\\Http\\Middleware\\VerifyCsrfTokenprotected $except = [ '/api/*']; 自定义 Auth 中间件 创建类文件12php artisan make:middleware UserAuthphp artisan make:middleware AdminAuth 编写 handle() 方法12345678910111213141516// AdminAuthpublic function handle($request, Closure $next)&#123; if (!session()-&gt;has('admin')) &#123; return redirect()-&gt;to('/admin/login'); &#125; return $next($request);&#125;// UserAuthpublic function handle($request, Closure $next)&#123; if (!session()-&gt;has('user')) &#123; return redirect()-&gt;to('/login'); &#125; return $next($request);&#125; 注册／挂载到应用内核 $routeMiddleware123456// app\\Http\\Kernel.phpportected $routeMiddleware = [ // ... 'auth.admin' =&gt; \\App\\Http\\Middleware\\AdminAuth::class, 'auth.user' =&gt; \\App\\Http\\Middleware\\UserAuth::class,]; 路由中调用新中间件123456789101112Route::group([ 'prefix' =&gt; '/profile', 'middleware' =&gt; 'auth.user',], function () &#123; // ...&#125;Route::group([ 'prefix' =&gt; '/admin', 'middleware' =&gt; 'auth.admin',], function () &#123; // ...&#125; 数据库查询构造器distinct select必须 select 中指定之后 distinct 才有效。 模型也能使用其方法在 Laravel 模型中，也能使用和查询构造器一样的一些方法。 往数据库插入测试数据 通过 seeder =&gt; 直接修改 database/DatabaseSeeder.php12345678910111213public function run()&#123; Model::unguard(); DB::table('users')-&gt;insert([ [ 'name' =&gt; str_random(10), 'email' =&gt; str_random(10).'@gmail.com', 'password' =&gt; bcrypt('secret'), ], // more ... ]); Model::reguard();&#125; 通过调用 seeder: 生成独立的 seeder：php artisan make:seeder UsersTableSeeder 修改 UsersTableSeeder 中要填充的内容和数量 1234567891011public function run()&#123; DB::table('users')-&gt;insert([ [ 'name' =&gt; str_random(10), 'email' =&gt; str_random(10).'@gmail.com', 'password' =&gt; bcrypt('secret'), ], // more ... ]);&#125; DatabaseSeeder 中调用: call(UsersTableSeeder); 123456public function run()&#123; Model::unguard(); $this-&gt;call(UserTableSeeder::class); Model::reguard();&#125; 通过模型工厂： 将要填充数据的表对应的模型及其格式注册到 databse/factories/ModelFactory.php 12345678$factory-&gt;define(App\\Models\\User::class, function (Faker\\Generator $faker) &#123; return [ 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;safeEmail, 'password' =&gt; bcrypt(str_random(10)), 'remember_token' =&gt; str_random(10), ];&#125;); 然后在 DatabaseSeeder 中调用 factory()-&gt;times()-&gt;make() 最后通过模型类一次性插入生成的测试数据 12345678910111213public function run()&#123; Model::unguard(); # 默认的方式 但不推荐使用 `create()` // factory(App\\Models\\User::class, 50)-&gt;create()-&gt;each(function($u) &#123; // $u-&gt;posts()-&gt;save(factory(App\\Post::class)-&gt;make()); // &#125;); # 推荐使用 `make()` $users = factory(\\App\\Models\\User::class)-&gt;times(100)-&gt;make(); \\App\\Models\\User::insert($users-&gt;toArray()); Model::reguard();&#125; Migration--create=TABLE_NAME 和 --table=TABLE_NAME有什么区别？创建 migrations 时是否需要带上此参数？ 带 --create=TABLE_NAME 表示在运行 php artisan migrate 的时候会创建物理表（表名为 TABLE_NAME）到数据库，不带则只是创建该迁移文件。 带 --table=TABLE_NAME 表示在进行修改表操作的时候指定要修改的表名为 TABLE_NAME。 最后，对应到 migrations 文件中的 up() 方法，--create=TABLE_NAME 调用的是 Schema::create(&#39;TABLE_NAME&#39;)，而 --table=TABLE_NAME 则调用的是 Schema::table(&#39;TABLE_NAME&#39;)。 说明:如果要运行由不带 --create=TABLE_NAME 的命令创建的 migrations，只需要修改这些文件的 up 方法（看情况，已有内容的可以不用在修改，但是通常都需要修改），即使用 Schema 语法写入需要的数据库操作，最后重新执行以下操作即可： 12345678910# 1. 修改数据库 migrations 表中要运行的 migration 的 batch 值为当前最高值+1-- mysql command statartupdate `migrations`set `batch` = (batch + 1)where `migration` = '2014_10_12_000000_create_users_table';-- mysql command end# 2. 回滚已手动置新的 migration 最新批次php artisan rollback# 3. 重新执行迁移php artisan migrate 这里的 batch 代表的是执行 php artisan migrate 的批次，即是记录 laravel 是第几批运行某个具体的迁移的。 batch 值相同的 migrations 在执行 php artisan migrate:rollback 时都会被回滚。 关于 up() 和 down()这两个方法必须要是互逆的。 即使说，up() 里面写的是 create，down() 里面就必须写 drop，而不能写 renameColumn() 之类的，反之同理。 Eloquent 关于调用含有 hasMany() 和 belongsTo() 关系的方法 实际调用的时候不能当作方法调用，而要当作属性获取。 即不能写成类似 $user-&gt;tasks() 而要写成 $user-&gt;tasks。 此外，含有这些关联属性的方法名的单复数形式要和关系相对应，即如果是 belongs-to 关系，则模型中相应的方法名应该是单数，如果是 has-many 关系，则模型中相应的方法名应该是复数，举例说明： 12345678# App\\Models\\Task.phppublic function user() &#123; return $this-&gt;belongsTo(User::class);&#125;# App\\Models\\User.phppublic function tasks() &#123; return $this-&gt;hasMany(Task::class);&#125; 什么时候适合用 Eloquent？ Eloquent 在对常见数据库操作时是非常得心应手的，比如单表的增删改，表的查询（包括联表），都是 OK 的，首选 ORM 比较合适。 但是，在一些增删改完整性要求高的情况下，比如事务，这时候 Eloquent 是没办法做到的，这时候只能使用 DB Facade 提供的事务处理方法。 $fillable／$guarded and Mass Assignment？ Mass Assignment，或称批量复制，指的是在 Laravel 在创建 Model 时可以批量传入一个数组，一次性设置好要保存的属性，而不用一个个指定字段具体的值，比如可以直接快速创建一个用户： $user = new User(Input::all());。 $fillable 和 $guarded 都是在批量赋值过程中使用的， $fillable 相当于的白名单，$guarded 相当于黑名单，使用时只能使用其一。 白名单总能覆盖黑名单。 默认情况下，模型的所有属性都是黑名单，只有 $fillable 中的属性才能在批量赋值时被插入数据库。 但是，并不是说 $fillable 之外的属性都不能被赋值，只是，不能批量赋值，可以单独为一些特殊字段赋值，然后保存： 12$user-&gt;user_type = 'admin';$user-&gt;save(); 当要批量赋值 $fillable 中没有指定的属性时，可以使用 forceCreate() 硬性创建，只是需要确保特殊字段的安全性。 团队数据库开发的工作流简要说明此流程相关的元素有：migration &amp; seeder|factories &amp; git，下面举例说明： A 在其本机建新表 users，插入了一些测试数据，最后生成了 migrations，seeds 或者 factories 文件 12345678910# 1. 创建迁移php artisan make:migration create_users_table --create=users# 2. 根据需要修改 migrations 中的定义# 3. 运行迁移 =&gt; 插入该迁移中定义的表到数据库php artisan migrate# 4. 为该表插入测试数据（具体操作详见：@往数据库插入测试数据）# 5. 提交到 git 仓库git add -A &amp;&amp; git commit -m \"create table users\"git pull origin dev # 根据实际情况看是否需要合并冲突git push origin own_branch B 拉取到表 users 的结构和 seeder，然后同步新改动到本机 123456# 1. 拉取仓库最新改动git pull origin dev # 假设协作分支为 dev（根据情况看是否需要先提交本地改动）# 2. 迁移数据库更新（同步）php artisan migrate# 3. 同步测试数据（可选）php artisan db:seed B 为 users 表新增一个 gender 字段，也插入了一些测试数据，最后生成了 migrations, seeds 或者 factories 文件 123456# 1. 创建迁移php artisan make:migration add_gender_to_users_table --table=users# 2. 修改迁移定义 为表 users 表新增 gender 字段# 3. 运行迁移（同上）# 4. 为该表插入测试数据（同上）# 5. 提交到 git 仓库（同上） 最简单的工作流程就是这样，如果有更多的开发者，也是按照这个基本流程来同步数据库改动。 可以看出，通过 laravel，多人同步数据库版本的核心其实就只有 php artisan migrate 这一条命令，包括最后部署到服务器，也只需要 migrate 一下就可以了，个人认为是很简单。 说明:如果对数据库有新的改动，则必须要创建新的迁移。最好不要修改已经迁移过的 migrations，因为如果要同步这些已修改的迁移，则需要先将这个迁移手动置最新一批，然后回滚，再执行 php artisan migrate 才能生效。 但是，由于保存 migrations files 的迁移批次是存在数据库中的，而 A 的数据库表 migrations 并不会同步到 B 数据库的 migrations 表，因此如果 B 得到了 A 修改过已迁移过的 migrations files 也需要先将这个迁移手动置最新一批，然后回滚，再执行 php artisan migrate 才能生效 所以，数据库每发生一次改动，最好是新建一次迁移。 认证启用 auth 认证的前提Users 表必须字段 可以唯一标志一个用户的账号：至少有一个，可以是 username，也可以是 email，手机号码等。 password：&gt; 60 个字符。 remember_token：nullable 、100 个字符。（migration class: $table-&gt;rememberToken()） 表单 表单需要的 name 值具体是什么，取决于在 PHP 中所定义的接受 Key。比如，可以把 email 换成 account，并使用户无论输入邮箱还是用户名都可以登录成功。 12345678910111213/** * 获得登录凭证 * @overide */protected function getCredentials(Request $request)&#123; $login = $request-&gt;get('account'); $field = filter_var($login, FILTER_VALIDATE_EMAIL) ? 'email' : 'name'; return [ $field =&gt; $login, 'password' =&gt; $request-&gt;get('password'), ];&#125; 配置 默认规定的路由格式，重定向位置，认证相关视图路径（默认在 auth/ 下面）都是可以自定义的。 1234567891011121314151617# routes.phpRoute::post('login', 'Auth\\AuthController@postLogin');# AuthController Classprotected $username = 'account'; // 用户账户的唯一标志protected $redirectPath = '/home'; // 用户登录成功后的重定向路由# Authenticate Class =&gt; handle()public function handle($request, Closure $next)&#123; if ($this-&gt;auth-&gt;guest()) &#123; if ($request-&gt;ajax()) &#123; return response('Unauthorized.', 401); &#125; else &#123; return redirect()-&gt;guest('auth/login'); // 表单形式登录校验失败后重定向路由 &#125; &#125; return $next($request);&#125; 调用认证中间件 Auth 的几个地方 路由闭包 123456789101112# 普通路由Route::get('profile', [ 'middleware' =&gt; 'auth', function() &#123; // ... // 只有认证过的用户能进来这里&#125;]);# 群路由Route::group([ 'middleware' =&gt; 'auth'], function () &#123; // do something&#125;); 控制器构造器 123public function __construct() &#123; $this-&gt;middleware('auth');&#125; 自定义最大登录尝试次数、冻结登录时间和错误提示消息123456# App\\Http\\Controllers\\Auth\\AuthController.phpprotected $maxLoginAttempts = 10; // Amount of bad attempts user can makeprotected $lockoutTime = 300; // Time for which user is going to be blocked in seconds# resources/lang/en/auth.php'failed' =&gt; 'These credentials do not match our records.','throttle' =&gt; 'Too many login attempts. Please try again in :seconds seconds.', 授权授权的目的，是为了检查某个角色是否具备某个权限。 具体到代码层面，通常是去判断模型 A 是否与模型 B 有所属关系。 数据库表的关联字段是否相同，或者专门的权限表中是否有模型 A 和 B 的关联记录，等等。 Laravel （&gt;5.1.11）默认授权工作流程如下： 定义权限通过 Illuminate\\Auth\\Access\\Gate 类，在 AuthServiceProvider 文件中定义应用中的所有权限 1234567891011121314151617namespace App\\Providers;use Illuminate\\Contracts\\Auth\\Access\\Gate as GateContract;use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;class AuthServiceProvider extends ServiceProvider&#123; // 注册应用程序的认证或授权服务 public function boot(GateContract $gate) &#123; $this-&gt;registerPolicies($gate); // 1. 通过回调处理授权 $gate-&gt;define('edit-post', function ($user, $post) &#123; return $user-&gt;id === $post-&gt;user_id; &#125;); // 2. 通过类和方法名 // $gate-&gt;define('edit-post', 'ClassName@methodName'); &#125;&#125; 这里的闭包里不用手动检查 $user 是否存在，未登录用户或是没有用 forUser() 方法指定的用户，Gate 自动返回的权限值为 false。 定义拦截授权事件在判断所有已定义权限之前，可以为某些特殊用户，比如最高权限的超级管理员（或者最低权限的访客），中断其后的授权校验，直接判定为拥有最高权限。 12345$gate-&gt;before(function ($user, $ability) &#123; if ($user-&gt;isSuperAdmin()) &#123; return true; &#125;&#125;); 也可以使用 after() 方法定义一个在所有授权检查结束后会被运行的回调，但是无法修改 after 回调中授权检查的结果。 123$gate-&gt;after(function ($user, $ability, $result, $arguments) &#123; //&#125;); 检查权限各种权限定义好后，接下来就是进行权限检查。Laravel 有以下几种检查方式： 通过 Gate FacadeGate facade 包含 3 个方法：check、allows、denies。 以判断当前用户是否有刚刚创建的 edit-post 权限举例说明： 检查已登录用户权限123456789101112131415161718192021222324252627namespace App\\Http\\Controllers;use Gate;use App\\Modles\\User;use App\\Modles\\Post;use App\\Http\\Controllers\\Controller;class PostController extends Controller&#123; // 编辑指定的文章 public function edit($id) &#123; $post = Post::findOrFail($id); // 1.使用 denies if (Gate::denies('edit-post', $post)) &#123; abort(403); &#125; else &#123; // 更新文章... &#125; // 2.使用 allows 或 check (和 denies 相反) // cheak 是 allows 的别名 if (Gate::allows('edit-post', $post)) &#123; // 更新文章... &#125; else &#123; abort(403); &#125; &#125;&#125; 这里不需要传递当前登录用户至该方法内，因为 Gate 会自动加载当前登录用户。 检查指定用户的权限如果想要检查已登录用户之外的其他用户是否具有指定的权限，可以使用 forUser() 方法： 123if (Gate::forUser($user)-&gt;allows('edit-post', $post)) &#123; // do right thing&#125; 多参数情况12345678// 1.权限定义时回调的参数Gate::define('delete-comment', function ($user, $post, $comment) &#123; // ...&#125;);// 2.同时校验多个权限if (Gate::allows('delete-comment', [$post, $comment])) &#123; //&#125; 通过 User Model默认情况下，Laravel 的模型使用了 Authorizable trait，它提供了两个方法：can 及 cannot，类似于 Gate 的 allows和 denies。 还是用上面的例子说明： 1234567891011121314151617// 编辑指定的文章public function edit(Request $request, $id)&#123; $post = Post::findOrFail($id); if ($request-&gt;user()-&gt;cannot('edit-post', $post)) &#123; abort(403); &#125; else &#123; // 更新文章... &#125; // 或者使用 can 反回来 if ($request-&gt;user()-&gt;can('edit-post', $post)) &#123; // 更新文章... &#125; else &#123; abort(403); &#125;&#125; 通过 Blade 模版标签在 Blade 模板中，你还可以使用 @can 标签来快速检查当前登录用户是否有指定的权限。例子同上： 123456&lt;a href=\"/post/&#123;&#123; $post-&gt;id &#125;&#125;\"&gt;查看文章&lt;/a&gt;@can('edit-post', $post)&lt;!-- 当前登录用户可以编辑文章 --&gt;@else&lt;!-- 当前登录用户不可以编辑文章 --&gt;@endcan 通过表单请求授权表单请求 是一个自定义的请求类，里面包含着验证逻辑，需要先创建好表单请求类。 1php artisan make:request UpdatePostRequest 可以在 UpdatePostRequest 类中的的 authorize() 方法中调用 Gate 进行授权验证。 12345public function authorize()&#123; $postId = $this-&gt;route('post'); return Gate::allows('edit-post', Post::findOrFail($postId));&#125; 自定义请求类编写好后，就可以作为 Laravel 默认的 Request 类传入控制器使用了。 如果 authorize 方法返回 false，则会自动返回一个 HTTP 响应，其中包含 403 状态码，而你的控制器方法也将不会被运行。（这样也简化了控制器代码量） 视图Blade 标签的几种形态12345678# 1. 普通形态「实体转义过」&#123;&#123; $var &#125;&#125;# 2. 注释形态&#123;&#123;-- This is a comment, which will not be in the rendered HTML --&#125;&#125;# 3. 原样输出形态@&#123;&#123; whatever you write here will be output in HTML, rather than executed &#125;&#125;# 4. 原样执行形态「HTML 实体将不被转义」&#123;!! '&lt;script&gt;alert(\"will be executed\")&lt;/script&gt;' !!&#125; 队列Laravel 使用队列步骤 「创建」任务类1php artisan make:job SendNoticeEmail --queued 创建后，根据业务需求编写任务类，通常是某个模块所需的耗时功能。比如：发邮件、截图、生成压缩包、七牛云上传，等。 --queued 参数表示运行具有队列属性，即该任务类必须实现 ShouldQueue 接口。 「派发」任务 在某个业务逻辑处派发具体的任务，即「任务入队」：$this-&gt;dispatch($job)。 也支持使用 $this-&gt;dispatchFrom() 从请求中派发任务。 只要使用了 DispatchesJobs trait 的类都可以直接通过 $this-&gt;dispatch($job) 来派发任务到队列上。 在将任务入队的时候，可以用 onQueue(QUEUE_NAME) 指定任务所属的队列；也可以用 delay(secs) 来延迟多少秒后运行。 处理「回调」 所注册的队列任务，运行完成后会被执行的回调操作，比如：数据库状态更新、邮件通知，等。主要有两种： 完成通过：Queue::after($connection, $job, $data)。 失败通过：Queue::failing($connection, $job, $data)。 通常在 AppServiceProvider 类的 boot() 方法中处理队列回调，其中失败事件可以直接在任务类中重写 failed() 方法来处理任务运行失败后的操作。 这里的 $connection 指的是队列连接类型，比如 database。 $job 是指当前任务实例本身的完整信息，其对应的类定义是：Illuminate\\Queue\\Jobs\\DatabaseJob，其中有很多方法可以获取当前队列和任务对象的信息。 $data 是被序列化的 $job 对象属性对象，被存储在任务表的 payload 字段，可以通过 unserialize($data[‘data’][‘command’]) 来恢复该实例对象。 「侦听」任务 代码逻辑写好之后，只是单纯将任务入队操作，并不会执行。需要启动 Laravel 侦听器来处理这些队列任务： 1php artisan queue:listen --queue=default,capture --queue=default,capture 中代表此侦听器将处理哪些队列，排越靠左的队列，优先级越高。 释放和删除从队列中释放一个任务，只是把这个任务重新放回队列，并不是从队列中删除。 要删除一个队列，需要删除队列中相应的记录，比如是数据库驱动的队列，就需要删除任务表中相关的记录。 也可以用 Artisan 命令来删除失败任务: 123php artisan queue:forget 5 # 删除掉某个失败任务 php artisan queue:flush # 删除所有失败任务 非失败任务不能删除，因为任务成功后会自动删除。 Laravel 队列线上环境实践在实际应用（线上）中，往往不是使用 queue:listen 来处理队列任务，而是通过 queue:work 配合 –daemon 选项，再加上 supervisor 进程管理器，来处理线上环境的队列任务。 相关配置及脚本如下： 队列任务批量部署脚本12345678910111213141516171819202122232425262728293031323334353637383940414243#! /bin/env bash# deploy.shworkers=1worker_len=16sleep_secs=3#path=/data/wwwroot/eme.devpath=/data/wwwroot/www.eme168.comwhile (( $workers&lt;=$worker_len ))do echo \"deploying phjs-cc queue daemon... ($workers/$worker_len)\" php $path/artisan queue:work database --queue=phjs-cc-$workers --memory=256 --sleep=2 --tries=2 --daemon &amp; sleep $sleep_secs echo \"deploying shrinking-thumb queue daemon... ($workers/$worker_len)\" php $path/artisan queue:work database --queue=shrink-thumb-$workers --memory=256 --sleep=2 --tries=2 --daemon &amp; sleep $sleep_secs echo \"deploying qn-upload queue daemon... ($workers/$worker_len)\" php $path/artisan queue:work database --queue=qn-upload-$workers --memory=128 --sleep=2 --tries=2 --daemon &amp; sleep $sleep_secs let \"workers++\"doneecho 'deploy finished.'exit 0#! /bin/env bash# undeploy.shworkers=0worker_len=16sleep_secs=1while (( $workers&lt;=$worker_len ))do echo \"un-deploying phjs-cc queue daemon... ($workers/$worker_len)\" `tmux kill-session -t \"phjs-cc-$workers\"` sleep $sleep_secs echo \"un-deploying shrinking-thumb queue daemon... ($workers/$worker_len)\" `tmux kill-session -t \"shrink-thumb-$workers\"` sleep $sleep_secs echo \"un-deploying qn-upload queue daemon... ($workers/$worker_len)\" `tmux kill-session -t \"qn-upload-$workers\"` sleep $sleep_secs let \"workers++\"doneecho 'un-deploy finished.'exit 0# ps -ef | grep php | grep -v grep | awk '&#123;print $2&#125;' | xargs kill -9 这里部署的后台处理进程个数根据服务器配置情况而定，这里是在 4 核／16G／20M 的阿里云 ECS 机器上部署的。 安装&amp;使用 supervisor 1234567# 以 CentOS 6 为例yum info supervisoryum install -y supervisorservice supervisord start|stop|restartsupervisorctl rereadsupervisorctl start proj-worker:*vim /etc/supervisord.conf supervisor 对应配置 123456789101112131415161718192021222324252627[program:proj-phjs]process_name=%(program_name)s_%(process_num)02dcommand=php /data/wwwroot/www.proj.com/artisan queue:work database --queue=phjs-cc-%(process_num)2d --memory=256 --sleep=2 --tries=2 --daemonautostart=trueautorestart=trueuser=wwwnumprocs=16redirect_stderr=truestdout_logfile=/data/wwwroot/www.proj.com/storage/logs/sv-worker.log[program:proj-shrink]process_name=%(program_name)s_%(process_num)02dcommand=php /data/wwwroot/www.proj.com/artisan queue:work database --queue=shrink-thumb-%(process_num)2d --memory=256 --sleep=2 --tries=2 --daemonautostart=trueautorestart=trueuser=wwwnumprocs=16redirect_stderr=truestdout_logfile=/data/wwwroot/www.proj.com/storage/logs/sv-worker.log[program:proj-upload]process_name=%(program_name)s_%(process_num)02dcommand=php /data/wwwroot/www.proj.com/artisan queue:work database --queue=qn-upload-%(process_num)2d --memory=256 --sleep=2 --tries=2 --daemonautostart=trueautorestart=trueuser=wwwnumprocs=16redirect_stderr=truestdout_logfile=/data/wwwroot/www.proj.com/storage/logs/sv-worker.log 注意这里的 numprocs 数最好和 deploy.sh 里面的 workers 数量保持一致，因为确保每个后台运行的队列处理进程都能被 supervisor 监控到。 其中，%(process_num)2d 对应的是数 numprocs 内的序号。0 表示不足多少位（这里是2位）时填充。 其他Composer安装指定版本的 Laravel1composer create-project laravel/laravel laravel.dev 5.1 composer create-project 和 laravel new 安装方式的区别？前者会通过 Composer 的机制解析并获得 Laravel 的下载包地址后然后下载，再加上国内 packgist.org 的速度不行，不换源很可能打不开，因此导致很慢。 而后者是直接获得 cabinet.laravel.com/latest.zip，自然速度快很多。 dist/source/auto 的区别通过 Composer 下载的软件包，是由软件包的「名字+版本号」唯一定义的，实际上，Composer 会把每个版本都当作一个独立的软件包，这个差别在从使用 Composer 的角度来说是不关紧要的，但是当你想要改变源代码的时候就变的很重要了。 不过，除了「名字」+「版本号」之外，还有「元数据」。 The information most relevant for installation is the source definition, which describes where to get the package contents. The package data points to the contents of the package. And there are two options here: dist and source. dist The dist is a packaged version of the package data. Usually a released version, usually a stable release. sourceThe source is used for development. This will usually originate from a source code repository, such as git. You can fetch this when you want to modify the downloaded package. 在安装软件包的时候，dist 和 source 选项可以同时指定，默认是 auto。 FAQ [Doctrine\\DBAL\\DBALException] Unknown database type enum requested, Doctrine\\DBAL\\Platforms\\MySqlPlatform may not support 在含有 enum 属性字段的时候，如果进行重命名等操作，出现了次错误，有一个 workaround 可以解决，需要在具体的修改操作之前加上下面这段代码： 12345678910### 添加的代码 startSchema::getConnection() -&gt;getDoctrineSchemaManager() -&gt;getDatabasePlatform() -&gt;registerDoctrineTypeMapping('enum', 'string');### 添加的代码 end### 重命名操作Schema::table('users', function (Blueprint $table) &#123; $table-&gt;renameColumn('password', 'u_passwd');&#125;); 详细的讨论见：https://github.com/laravel/framework/issues/1186 明明存在类却提示找不到类？ 检查是否更改过类文件名，如果改过，则执行：composer dump-autoload 即可修复。 Class ‘Doctrine\\DBAL\\Driver\\PDOMySql\\Driver’ not found 在确认 composer.json 中 require 字段中含有 “doctrine/dbal”: “~2.3” 依赖后，重新执行下安装命令： 1composer require doctrine/dba session flash 无效？只在本此请求中有效。 Composer：Could not find package * at any version for your minimum-stability (stable). Check the package spelling or your min imum-stability: https://github.com/composer/composer/issues/5118 Composer：Composer install requires dev minimum-stability https://github.com/BGSU-LITS/learning-tools/issues/1 参考 Laravel 5.1 LTS 中文手册 &amp; Laravel 5.1 LTS Documentation 大批量假数据填充的正确方法","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"Mac 流","slug":"Mac-Flow-Dev","date":"2018-01-15T09:26:21.000Z","updated":"2019-08-22T06:23:24.000Z","comments":true,"path":"2018/01/15/Mac-Flow-Dev/","link":"","permalink":"http://blog.caoxl.com/2018/01/15/Mac-Flow-Dev/","excerpt":"Mac 流 关于使用 Mac 过程中值得记录的都写在这里。 文件系统 空格预览／cmd + Y： 几乎可以预览一切文件 文件关联： 针对当前文件：** 右键 =&gt; 打开方式 针对所有相同文件后缀的文件：右键 =&gt; 显示简介 =&gt; 打开方式 =&gt; 全部修改 上下左右： 当前路径中按顺序切换文件 command+上／下： 返回上层目录／进入当前选中目录 command+i： 显示文件信息 command + m + i： 同时显示多个文件信息 command+k： 连接到服务器 command+delete： 移动到废纸篓 command+shift+delete： 清空废纸篓 alt+command+delete： 彻底删除 文件／文件夹显示模式： command + 1~4 文件／文件夹排序模式： command + ctrl + 0~7","text":"Mac 流 关于使用 Mac 过程中值得记录的都写在这里。 文件系统 空格预览／cmd + Y： 几乎可以预览一切文件 文件关联： 针对当前文件：** 右键 =&gt; 打开方式 针对所有相同文件后缀的文件：右键 =&gt; 显示简介 =&gt; 打开方式 =&gt; 全部修改 上下左右： 当前路径中按顺序切换文件 command+上／下： 返回上层目录／进入当前选中目录 command+i： 显示文件信息 command + m + i： 同时显示多个文件信息 command+k： 连接到服务器 command+delete： 移动到废纸篓 command+shift+delete： 清空废纸篓 alt+command+delete： 彻底删除 文件／文件夹显示模式： command + 1~4 文件／文件夹排序模式： command + ctrl + 0~7 全局／相似 command + ,： 设置 command+w： 关闭窗口 command+q： 退出程序 command+n： 新建当前窗口副本 command+ m： 最小化当前窗口（按住 command 点 tab 选中目标窗口后按住 alt，然后松开 command 恢复 ） command+h： 隐藏当前窗口（用 command + tab 恢复 ） command + `： 在程序内未隐藏的子窗口中切换 command + alt + h: 隐藏当前窗口外的所有窗口 command + alt + m h: 隐藏当前所有窗口 ctrl + command + d: 查看鼠标选中／光标选中的英文单词含义；或着预览超链接 F11／fn+F11： 显示桌面 ctrl + left/right： 切换桌面 tab + space： 选择切换 + 确认 三指点按： 查询单词与数据检测 字体1234567brew tap caskroom/fontsbrew cask install font-fira-codebrew cask install font-roboto-monobrew cask install font-mononokibrew cask install font-inconsolatabrew cask install font-consolas-for-powerlinebrew cask install font-dejavu-sans-mono-for-powerline HomebrewmacOS 的软件包及其依赖管理工具。 12# 安装 Homebrew/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 常用命令： 查看已安装软件包12brew listbrew cask list 搜索软件包12brew search node# brew search --help 查看软件包安装选项1brew options node 安装1234brew install node # 从预编译二进制包中安装brew install --build-from-source node # 从源码编译安装brew reinstall licecap # 重装已删除的应用程序brew cask install chrome # 下载带 GUI 的软件包 如果有个软件包名是在 cask 仓库下，比如：caskroom/cask/mysql-shell，则既可以通过 brew install caskroom/cask/mysql-shell 安装也可以通过 brew cask install mysql-shell 安装。 完全卸载1brew uninstall node 只从环境变量中卸载1brew unlink node 恢复到环境变量1brew link node 查看当前 homebrew 概况1brew info 查看软件包属性123456brew info nodebrew cask info font-roboto# 格式化输出brew install jq # commandline JSON processorbrew info --json=v1 node | jqbrew info --json=v1 node | jq \"map(select(.linked_keg != null) | .name)\" 查看／切换软件仓库123brew tap # 查看当前 homebrew 使用到的软件仓库 (homebrew/core 为其主仓库)brew tap homebrew/nginx # 切换到某个功能仓库# 一些有趣的仓库：https://docs.brew.sh/Interesting-Taps-and-Forks.html 数据统计1234brew analytics # 查看 homebrew 数据统计状态brew analytics off # 关闭 homebrew 数据统计brew analytics regenerate-uuid # 重新生成 UUID# 可在这里查看：https://brew.sh/analytics/ 开发 Dash: API 即时搜索体验 到 https://kapeli.com/dash 下载安装即可。 安装结束可以根据需要下载 docset 和 cheatsheet，开发相关的，几乎都有。 在使用 Alfred/Spotlight 搜索 dash 时可以使用伪协议格式进行搜索关键词或快捷键，比如：dash://php: Docker: 引领容器时代。 https://docs.docker.com/docker-for-mac/。 Vagrant： 所有环境不一致“流浪汉们”的归属 制作和线上服务器相同的测试／开发环境，在团队间打包分发 快速创建／销毁同等环境，不再担心环境不小心被破坏 Sublime Text： 最爱的 GUI 编辑器。see: Sublime Sublime Text. PhpStorm： 可能是目前最专业最酷的 PHP IDE 配置远程编辑+自动同步代码配合 Vagrant Workflow 可以避免本地安装多余的开发环境。 最终想要实现的效果是：本地只编码／版本控制，Vagrant 管理的环境中测试代码，尽可能减少团队成员间环境不同带来的冲突，和本地与生产环境不同带来的问题等。 PhpStorm 开启远程编辑，流程根据版本不同，大致如下： 1234567891011121314151617181920212223242526# 1. 添加一个远程服务器路径 通常是测试环境全局虚拟主机所在的根路径 也可以配置为某个虚拟主机所在的跟路径File =&gt; Default Settings =&gt; Bsuild,Execution,Deployment =&gt; Deployment =&gt; `+`Name =&gt; centos.dev # 远程服务器的名字# 2. 配置好「连接选项」、「控制编码格式」 和 「根 URL」## 配置后可以点击【Test SFTP connection】测试配置是否有误###### 选择 Connection 子标签Type =&gt; SFTP # 假设 Vagrant 测试环境为 LinuxSFTP host =&gt; 虚拟机的 IP # 要求主机已安装好 host-only 网卡驱动Port =&gt; 22Root Path =&gt; /data/wwwroot/ # 测试环境中代码的根路径User name =&gt; rootAuth Type =&gt; Password # 这里也可以使用 OpenSSH 但是在可以记住密码的情况下 最终也不用每次都手动输入密码Password =&gt; ****** # 勾选【Save password】Advanced options =&gt; Control encoding =&gt; UTF-8# 可选## 如果填了 这里的根 URL 就是测试环境中所配虚拟主机的域名## 如果留空 则表示当前配置为多个虚拟主机公共的跟路径 可以在 Mappings 里为每个虚拟主机配置一个 Web URLWeb server root URL =&gt; http://sample.dev# 连接测试通过后 点击 【OK】保存此配置# 3. 配置本地项目和测试环境网站根目录的路径映射关系###### 选择 Mappings 子标签Local path =&gt; /www/sample.dev # 要同步的本地路径Deployment path on server 'centos.dev' =&gt; sample.dev # 要同步的远程路径Web path on server 'centos.dev' =&gt; /sample.dev # 远程服务器上的该同步项目的可访问的 Web URL# 如果还有该远程服务器还有其他项目 则可以点击【Add another mapping】继续新增 Mapping# ... 配置自动同步代码：Tools =&gt; Depolyment =&gt; 勾选上 Automatic upload (always)。 手动同步：alt + command + y。 说明:这里虽然可以通过配置共享文件来实现 Host 和 Client 系统的代码同步，但是实际操作中经常出现共享文件夹速度很慢，Windows(smb) 和 macOS（nfs）的配置文件不能共享等的现象。因此，为了节省开发时间，个人的最佳实践还是配置远程编辑。 Navicat： 强大的关系型数据库全能工具 将模型导出为 SQL 点击「文件」=&gt; 「导出 SQL」=&gt; 「导出到文件」=&gt; 「选择文件路径+填写导出的文件名+选择导出的选项」=&gt; 「确定」。 需要注意的一点是，在「导出 SQL」时，不能直接只输入一个文件名就完事了，而是要点击右侧的 … 按钮，然后选择路径和填写文件名才可以导出成功。否则会 Navicat 报错（11.2.10）。 录入Typora：简单高效 Markdown 文档大纲：shift + command + b 源码模式和预览模式：command + / Focus 模式：shift + command + r 图片：alt/option + command +i 高亮：shift+ command + h &lt;=&gt; ==TEXT== 插入表格：command+t 查找：command+f 查找并替换：command+alt+f 粘贴纯文本：shift + command + v 自带输入法：原配最好 中文输入法下调用符号：shift +alt/option + b 输入符号：alt+键盘符号／字母 显示字符键盘：ctrl + command + space （可更改） 打开关闭手写输入：ctrl + shift + space 打开 emoji 表情：cmd + ctrl + space 一些设置 开启 Capslock 切换输入法作为国人，中英切换的频率是很频繁的，而常用的快捷键 CMD／Space／Ctrl 等又给了 Spotlight 和 Alfred 等工具，后来在设置中偶然找到了可以使用 Capslock 键切换中英输入，试了几下居然操作挺 6。于是在这里安利出来了： 系统设置 =&gt; 键盘 =&gt; 输入法 =&gt; 勾选下方「使用大写锁定键切换“美国”输入模式（长按以启用全大写键入）」。 取消自动纠正拼写和大写字词的首字母系统设置 =&gt; 键盘 =&gt; 文本 =&gt; 取消右侧「自动纠正拼写」和「自动大写字词的首字母」。（个人觉得很烦而已 ):） 取消连按两下空格键插入句号系统设置 =&gt; 键盘 =&gt; 文本 =&gt; 取消右侧「连按两下空格键插入句号」。 终端移除 “Last login” 提示信息12cd ~touch .hushlogin 快捷键Terminal Command + K：清屏（真正的清屏） Command + T：新建标签 Command +W：关闭当前标签页 Command + S：保存终端输出 Command + D：水平分隔当前标签页 Command + Shift + D：取消水平分隔 Command + shift + {／}：向左/向右切换标签 Control + U／K：删除光标前/后 所有单词 Control + Y：撤销上个操作 iTerm2 新建标签：command+t 新建分屏：command+d（竖）；command + shift + d（横） 标签间切换：command+左／右 分屏间切换：command + [/] 全屏切换：command + enter 清除当前行：ctrl + u 前进后退（左右）：ctrl + f/b 跳至行首／行尾：fn+左／右；ctrl + a／ctrl+e 向光标左／右方向跳一个单词：esc + b／f 清屏：ctrl + l ；command + r（只是把光标重置到终端左上角） 剪切板历史：command+shift+ h 从光标处删至命令行尾：ctrl + k 从光标处删至命令行首：ctrl + h 粘贴至光标后：ctrl + y 搜索命令历史：ctrl + r 复制 选中即复制 搜索后使用 shift 往右选择或 shift + tab 往左选择 光标聚光灯：command + / zsh &amp; oh-my-zsh1sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" plugins=(git, thefuck, zsh-autosuggestions) alias1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950alias cls=\"clear\"alias ip=\"echo 'LAN :' `ipconfig getifaddr en0` &amp;&amp; echo 'WAN :' `dig +short myip.opendns.com @resolver1.opendns.com`\"alias chmd=\"chown -R www:www ./\"alias szsh=\"source ~/.zshrc\"alias idu=\"du -h -d 1 .\"alias cpssh=\"pbcopy &lt; ~/.ssh/id_rsa.pub\"alias rmf=\"rm -rf $1\"alias rmals=\"sudo rm /private/var/log/asl/*.asl\"alias lline='fc -ln -1 | awk '\\''&#123;$1=$1&#125;1'\\'' | pbcopy'# Devalias gs=\"git status | lolcat\"alias ga=\"git add $1\"alias gad=\"git add -A\"alias gb=\"git branch\"alias gbd=\"git branch -D $1\"alias gbb=\"git checkout -b $1\"alias gbbb=\"git checkout -b $1 $2\"alias gct='read comments &amp;&amp; git commit -m \"$comments\"'alias gcta=\"git commit --amend\"alias gplm=\"git pull origin master\"alias gplb=\"git pull origin $1\"alias gfb=\"git fetch origin $1\"alias gfm=\"git fetch origin master\"alias gfa=\"git fetch origin\"alias gpsm=\"git push origin master\"alias gpsb=\"git push origin $1\"alias gpsd=\"git push origin --delete $1\"alias gcm=\"git checkout master\"alias gcb=\"git checkout $1\"alias gmm=\"git merge master\"alias gmb=\"git merge $1\"alias gdev='git commit -a --amend -m \"deving at `date`\"'alias dg='git log --pretty=format:\"- %s\" --author=cxl --since=9am &gt; ~/.today.md &amp;&amp; subl ~/.today.md'vagrant_home=\"/dl/vagrant/\"alias vup=\"cd $vagrant_home &amp;&amp; vagrant up\"alias vssh=\"ssh root@centos.dev\"alias vh=\"vagrant halt\"alias vre=\"vagrant reload\"alias phpa=\"php -a\"alias phps7=\"php -S 0.0.0.0:7777\"alias phps8=\"php -S 0.0.0.0:8888\"alias phps9=\"php -S 0.0.0.0:9999\"alias phpat=\"php artisan tinker\"hexo_path=\"/dl/self/SoulMate94.github.io\"alias phexo=\"sh $hexo_path/auto.sh $hexo_path\"alias pswd=\"/dl/self/tellmepasswd/TellMePasswd.php\"alias ss=\"subl ~/.ss-in-bulk/ss.cnf\"alias sspac=\"subl ~/.ShadowsocksX/gfwlist.js\"alias ssupac=\"subl ~/.ShadowsocksX/user-rule.txt\"alias vps=\"ssh user@host\" VIMawesome vimrc懒人专用。自动配置 vim。 12345git clone https://github.com/amix/vimrc.git ~/.vim_runtimesh ~/.vim_runtime/install_awesome_vimrc.sh# updatecd ~/.vim_runtimegit pull --rebase plugins如果不用别人的，就需要手动安装需要的插件。 vim 插件一般是 .vba 或者 .vim 文件，一般拷贝到 ~/.vim/plugins 下面就行了，具体参考 http://www.vim.org/ 的插件安装说明。 个人认为常用且有趣的插件有： - Devlife - GuidedTour - NERD_tree - tortoiseTyping - SrcExpl - indentLine - markdown - taglist - matrix 命令行工具命令帮助：man 和 cheat 1234man htopbrew install cheatcheat -vcheat tar 解压缩 rar12345brew install unrar# 解压单压缩文件unrar x file.rar# 解压分卷压缩文件unrar x -o- -y file.part1.rar &lt;/path/to/save&gt; 7z12brew install p7zip7z e file.7z 统计 cloc：Count Lines of Code1cloc /path/to/proj gitstats1234brew install gnuplotbrew install libjpeghttps://github.com/hoxu/gitstats &amp;&amp; cd gitstats/.gitstats /path/to/proj /path/to/output fswatch 后台同步123/usr/bin/nohup fswatch -o /env/vagrant/www/eme.dev/ | xargs -n1 /env/vagrant/www/eme.dev/tools/deploy/rsync-start &gt; /dev/null 2&gt;&amp;1 &amp;# rsync-start/usr/local/bin/rsync -avz --progress --no-o --no-g -m --chmod=Du=rwx,Dgo=rx,Fu=rw,Fog=r -F --exclude='.git/' /env/vagrant/www/eme.dev/ root@eme.dev:/data/wwwroot/eme.dev 其他 1brew install lolcat cmatrix cowsay 常用指令 打开指定路径的 Finder：open /path/to/open 锁屏：1/System/Library/CoreServices/Menu\\ Extras/User.menu/Contents/Resources/CGSession -suspend 生产力Alfred带有「workflow」的超级 Spotlight 搜索，各种 workflow 需要自行安装仔细体会。个人使用的工作流有： Kill Progress：kill progress_name DevDocs Dynamic File Search Encode/Decode 12encode stringdecode string Colors：# GitHub Dict 1cc &#123;word&#125; @ &#123;dict&#125; # 注意如果修改 hot key 后 @ 实效 建议恢复默认热键 StackOverflow Sublime Text Douban 123book BOOK_NAMEmovie MOVIE_NAMEmusic MUSIC_NAME Timezones：tz Domainr Terminal Finder VirtualBox IP Address ：ip Emoji：emoji 若搜索 alfred 则打开 Alfred 偏好设置。 Moom键盘党最爱的窗口管理之一。 Cheatsheet快捷键作弊条。长按 command 键呼出快捷键列表。 1brew install caskroom/cask/cheatshee https://www.mediaatelier.com/CheatSheet/。 Spectacle开源的窗口管理工具，简单实用。我只在默认设置的基础上改了 6个快捷键： Center：shift + command + c Fullscreen: ctrl + shift + f Make Larger: command + = Make Smaller: command+ - Left Screen：shift + ctrl + Left Right Screen：shift + ctrl + Right 其他保持默认，个人使用过程中基本上没有冲突。其他快捷键如下： ctrl + command + left/right：以全屏1／4 窗口紧贴左／右上角 ctrl + shift + command + left/right：以全屏1／4 窗口紧贴左／右下角 alt + command + left/right/up/down：以全屏1／2 窗口紧贴左／右／上／下 Harmmerspoon源码级自定义全局快捷键。使用 lua 写配置，举例如下： 12345678910111213141516171819202122232425262728# init.luahs.hotkey.bind(&#123;\"cmd\", \"alt\", \"ctrl\"&#125;, \"H\", function() hs.notify.new(&#123;title=\"Hammerspoon\", informativeText=\"Hammerspoon is working.\"&#125;):send()end)hs.hotkey.bind(&#123;\"cmd\", \"alt\", \"ctrl\"&#125;, \"Left\", function() local win = hs.window.focusedWindow() local f = win:frame() f.x = f.x - 100 win:setFrame(f)end)hs.hotkey.bind(&#123;\"cmd\", \"alt\", \"ctrl\"&#125;, \"Right\", function() local win = hs.window.focusedWindow() local f = win:frame() f.x = f.x + 100 win:setFrame(f)end)hs.hotkey.bind(&#123;\"cmd\", \"alt\", \"ctrl\"&#125;, \"Up\", function() local win = hs.window.focusedWindow() local f = win:frame() f.y = f.y - 100 win:setFrame(f)end)hs.hotkey.bind(&#123;\"cmd\", \"alt\", \"ctrl\"&#125;, \"Down\", function() local win = hs.window.focusedWindow() local f = win:frame() f.y = f.y + 100 win:setFrame(f)end) 这样，按住 ctrl + alt + command + 上／下／左／右，当前窗口就可以进行 四个方向上每 100 像素／次的微调了。 InsomniaX 可以在不接交流电源（AC power）的情况下开启合盖模式。 ShortCat 系统级的 Vimium Chrome 有款插件叫 Vimium，作用是通过快捷键来跳转网页也链接。 ShortCat 的作用就像 Mac 系统内全局的 Vimium，可以通过快捷键来快速定义屏幕范围内指定的按钮。 Automator Mac 自带的工作流定义工具。 这玩意一直没怎么研究过，偶然间在网上看到有人介绍用这个完成一些批量命名的操作，顿时来了兴趣。 批量命名 Finder 文件 打开 Automator 文稿类型选择「文件夹操作」 找到「给 Finder 项目重新命名」工作流 添加到右侧工作区 (是否在副本上操作自行决定) 然后定义工作流（批量操作的格式）的细节 命名 &amp;&amp; 保存 然后在 Finder 里面选择多个文件或者文件夹 =&gt; 右键选择文件夹操作设置 =&gt; 找到刚刚定义的工作流 =&gt; 输入一些参数即可让此工作流开始工作。 此后，只要在 Finder 中选中多个文件夹，右键属性中都会出现 “给X个项目重新命名” 的选项了，确实非常方便 给 Finder 增加「在终端中打开」 打开 Automator 选择「服务」 右侧顶部的「“服务”收到选定的」 选择「文件或文件夹」，位于选择「Finder.app」 左侧顶部操作下找到「文件和文件夹」，拖到右边工作区，其右侧子项目选中「打开 Finder 项目」 右侧中部「打开 Finder 项目」下面的「打开方式」选择终端／iTerm 2.app 命名 &amp;&amp; 保存 系统设置重命名账户名称不得不说，Apple 设计的很多功能是一个需要你自己去体会的，我常常用着用着突然发现，原来这个功能是有的。 系统偏好设置 =&gt; 用户与群组 =&gt; 点按锁按钮以进行更改 =&gt; 鼠标移动到用户列表中的某个用户 =&gt; 右键高级 =&gt; 此页即可修改用户信息。 MacBook Pro 遇到过的问题别人遇到的问题: 插入 SD 卡后重启变卡，进入登录界面时键盘触摸屏不能使用 五国死机过 自动重启 键盘灯总是常亮，每次登录时亮度调整已经是 0，但是只有先增加再减少后才能生效 键盘一直开启大写设置无效 声音时大时小 自己遇到的问题: 暂无… 参考 Alfred 3 Workflows Alfred 2 Workflows List 程序员如何优雅地使用macOS？ 重置 Mac 上的系统管理控制器 (SMC) - Apple 支持 Mac OS X 配置指南 | Mac OS X Setup Guide","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.caoxl.com/tags/Mac/"}]},{"title":"MacBook Pro 初见","slug":"Macbook-Pro-First-Meeting","date":"2018-01-15T08:15:33.000Z","updated":"2019-08-22T06:23:28.000Z","comments":true,"path":"2018/01/15/Macbook-Pro-First-Meeting/","link":"","permalink":"http://blog.caoxl.com/2018/01/15/Macbook-Pro-First-Meeting/","excerpt":"MacBook 初见 2018-1-8 14:39PM 第一次看到属于我自己的MacBook Pro EI Capitan 系统设置触控板和手势 单指点按选中： 系统偏好设置 =&gt; 触控板 =&gt; 光标与点按 =&gt; 轻点来点按。相当于单击鼠标左键打开应用。 单指锁定： 系统偏好设置 =&gt; 辅助功能 =&gt; 鼠标与触控板 =&gt; 触控板选项 =&gt; 启用拖移 =&gt; 使用拖移锁定。点一下窗口后即可选中开始拖动 双指右侧滑动：左右滑动分别开关通知栏。 四指上下： 显示当前打开的窗口＋多桌面。 四指抓取： 打开 Launchpad，退出释放四指。 双指选中： 相当于鼠标右键属性。 左右滑动： 在浏览器历史纪录堆栈中前进后退。","text":"MacBook 初见 2018-1-8 14:39PM 第一次看到属于我自己的MacBook Pro EI Capitan 系统设置触控板和手势 单指点按选中： 系统偏好设置 =&gt; 触控板 =&gt; 光标与点按 =&gt; 轻点来点按。相当于单击鼠标左键打开应用。 单指锁定： 系统偏好设置 =&gt; 辅助功能 =&gt; 鼠标与触控板 =&gt; 触控板选项 =&gt; 启用拖移 =&gt; 使用拖移锁定。点一下窗口后即可选中开始拖动 双指右侧滑动：左右滑动分别开关通知栏。 四指上下： 显示当前打开的窗口＋多桌面。 四指抓取： 打开 Launchpad，退出释放四指。 双指选中： 相当于鼠标右键属性。 左右滑动： 在浏览器历史纪录堆栈中前进后退。 Dock Dock 居左： 系统偏好设置 =&gt; Dock =&gt; 置于屏幕上的位置 =&gt; 左边。 Dock 缩小： 系统偏好设置 =&gt; Dock =&gt; 大小 =&gt; 向左滑动。 Dock自动隐藏： Command + Alt + D。 全屏触发： 当鼠标向 Dock 所在方向滑动时自动弹出，同顶部菜单。 禁用与恢复: Dashboard： 1234# 禁用仪表盘defaults write com.apple.dashboard mcx-disabled -boolean YES &amp;&amp; killall Dock＃ 恢复仪表盘defaults write com.apple.dashboard mcx-disabled -boolean NO &amp;&amp; killall Dock Mac OS X 键盘符号解释⇧ = shift ⌃ = control ⌥ = option / alt Home = fn + ◄ End = fn + ► Page Up = fn + ▲ Page Down = fn + ▼ 快捷键 删除文件： Command + Delete（也是删除光标前整行内容）； 强制删除： Command + Alt + Delete。 删除光标前一个单词： Option + Delete。 删除光标后一个单词： fn + Command + delete。 删除光标后一个字符： fn + delete。 关闭窗口： Command + W。 查看所需单词定义： Control＋Command ＋D。 退出程序： Command +Q；Command + Alt + Esc（强制退出）。 F11： 显示桌面（启用标准功能键后），同四指张开。 连续两次 Command： QQ Swiftly 搜索，注意是在英文输入法的前提下。 最小化窗口： Command ＋ M；Command ＋空格。 **关闭已最小化的窗口：Command ＋H。 预览文件： 空格键。 新建文件夹： Command + Shift＋N。 打开新窗口： 选中应用程序后按 Command ＋ N，比如 QQ。 删除项目到废纸篓： Command + Delete。 清空废纸篓： Command + Shift + Delete。 截图保存整个屏幕到桌面： shift + command + 3。 保存整个屏幕到剪贴板： control + shift + command + 3。 截取指定屏幕区域到桌面： shift + command + 4。 保存指定屏幕区域到剪贴板： control + shift + command + 4。 新建程序： command + n【比如同时登陆2个QQ】。 输入法切换: command + space。 切换窗口： control + F4 或者command + tab。 最小化当前窗口： Command + m. 最小化所有窗口： Option + click minimize button。 适合屏幕： Option + click zoom button【在mac下没有窗口的最大化，而是适合屏幕】。 关闭当前窗口： Command + w。 关闭所有窗口： Option + click close button【比如说你打开了多个safari网页，这时想要关闭全部窗口，可以右击safari，然后退出；也可以按住option，然后点任意一个窗口的关闭按钮】 窗口的移动： 需要3指触控。第一，用中指和无名指作为一指点窗口的最顶端（类似windows标题栏），并按住不放；第二，用食指拖拽到目的位置；第三释放3指。【lion测试，小白们设置一下触控板，自己研究一下，esay】 选择相邻的图标 (列表显示)： Shift + click。 选择不相邻的图标 (列表显示)： Command + click。 重命名： 先选中，然后点 Return（enter）。 文件或文件夹复制： command + c 代表复制。 但是，注意！没有剪切的快捷键，要实现剪切功能，需要command和拖拽配合完成。具体操作：首先，选中文件，其次按住command，再次拖拽文件到目的位置后松手，最后，释放command。 原位复制： Command + d【mac下对于文件的复制不同于windows，与windows的复制相同功能的在mac下是拷贝】。 创建替身(拖拉方式)： Command + Option + 拖拉 创建替身(命令方式)： Command + l (L)【mac下的替身类似于windows下的快捷图标，但比其更富有人性化】。 强制退出应用程序： Command + Option + Escape。 强制重新启动： Command + Ctrl + 电源 key 注销： Command + Shift + q。 重置 Parameter RAM： Command + Option + p + r。 更多快捷键： Linux 很多按键操作 Mac 也适用，比如 ctrl+A（跳行首） 和 ctrl+E（跳行尾）等；把 Command 当作 Windows 的 Ctrl 或 Win，发现很多都是相同的。更多快捷键相见附录。 日常管理 清理 DNS 缓存12345sudo lookupd -flushcache # Tiger 或更低版本 Mac OS Xsudo dscacheutil -flushcache # Leopard 和 Snow Leopardsudo killall -HUP mDNSResponder # Lion、Mountain Lion 和 Mavericks(OS X v10.10.4 or later)sudo discoveryutil mdnsflushcache. # v10.10 through v10.10.3say cache flushed 终端邮件123$ mail&gt; delete *&gt; q 硬盘测速12time dd if=/dev/zero bs=1024k of=tstfile count=1024dd if=tstfile bs=1024k of=/dev/null count=1024 Mac OS X 查看磁盘空间1sudo du / -h -d 1 JPEG／PNG图片压缩命令行工具1http://blog.topspeedsnail.com/archives/2737 彻底卸载 Mac App12345# 查找mdfind -name \"APP_NAME\"# 更改权限# 删除sudo rm -rf filename 查看CPU-内存-耗电情况等终端工具12345# 实际命令以具体环境为准brew install htop # CPU 内存 进程htoppip3 install trackmac # 耗电应用统计tm list -m 粘贴到剪切板123456# Windowsclip &lt; text.txt# Macpbcopy &lt; text.txt# Linuxxclip Homebrew/Cask - MBP Dev 的开始简而言之，brew 类似于 yum 和 apt-get，都是平台下的软件包管理工具，强烈推荐优先使用 homebrew 在 Mac OS X 上搭建开发环境，自带的一些开发环境虽然也可以用但是不如 brew 专业，正所谓专业的人做专业的事，为了您的宝贵时间，so。 下载安装 Homebrew： 12＃ Mac OS X 内置 ruby 可直接使用 curl 下载后安装 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 如果没有安装过 Command Line Tools，安装过程中会下载 Xcode 。1brew doctor # 自检，成功则提示 \"Your system is ready to brew.\" 除了brew，Mac OS X 上还有一个更适合开发者的软件管理工具：cask。它的优点是：软件支持更全面＋更新速度快＋速度比App Store快。1brew tap phinze/homebrew-cask &amp;&amp; brew install brew-cask 好了，以后安装编程环境和开发工具什么的就 brew install 起来吧。 下面的软件都可以通过 brew 来安装。 终端：开发效率提升利器终端几剑客：iTerm2＋Zsh/Oh-My-Zsh+VIM＋Tmux。 没用 MacBook 以前在 Windows 上终端工具用的是 XShell，然后配合 Tmux，远程操作效率也还不错。 但是 iTerm2 使用起来真的我只能用一个字形容：爽。分屏太任性了，而且复制终端文本比 Tmux 方便。 123command + d : 水平分屏command + shift + d: 垂直分屏command + w : 关闭当前分屏 文本三巨头就不用多说了，和在 Linux 上操作是一致的。 其中，oh-my-zsh 安装配置：12345678910sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"＃或者sh -c \"$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)\"＃编辑 Zsh 配置文件vi ~/.zshrc# 选择随机主题ZSH_THEME=\"random\" ＃ 主题目录在：~/.oh-my-zsh/themes/ 下source ~/.zshrc # 使配置文件生效# 查看系统的 shellcat /etc/shells 我认为 Zsh 的最大的方便之处在于简化了文件系统中的跳转，比如进入 WWW 可以不输入 cd WWW 而是直接输入 WWW，此外还使在终端下查看文件变得简单快速，比如只输入 l 就可以查看文件详情。 其他方便之处还在于对 git 仓库对智能识别，非常人性化。 免密码远程连接 Linux不借助 SSH 工具直接在终端免密登录 Linux。 首先生成一个 SSH Key： 12cd ~ &amp;&amp; mkdir .ssh &amp;&amp; cd .sshssh-keygen -t rsa -C 'code0809@163.com' -f id_rsa_SoulMate94 注意：这里给 id_rsa_SoulMate94 的权限必须只能是某个特定用户可读可写，其他角色都不要给任何权限，比如要为 root 用户配置 ssh 远程登录则必须确保他的私钥文件权限是 chmod 0600 id_rsa_root，否则在执行 ssh -T git@git.HOSTNAME.ext 的时候警告你”私钥文件未受保护”（UNPROTECTED PRIVATE KEY FILE），从而导致 SSH 免密配置失败。 然后继续在本地用户的 .ssh 文件夹下新建配置文件：1234567vim config# 输入类似如下配置Host github.comHostName github.comUser SoulMate94Port 22IdentityFile ~/.ssh/id_rsa_SoulMate94 这里尤其需要注意的是用户名是否合法，比如检查：是否存在目标服务器上，名称是否含大小写等，用户名是否是 Git 注册邮箱。Host 和 HostName 也可以是 IP。 以后如果需要连接某台 Linux 服务器（包括 Git 服务器），只需要将生成色 id_rsa_cxl.pub 追加到服务器合法用户的 Home 目录下面的 .ssh 文件夹下的 authorized_keys 文件中即可，即要具备以下四个条件： 服务器上要存在 SoulMate94 这个用户。 在这个用户的 Home 目录下面的 .ssh 文件夹下的 authorized_keys 中含有该用户的 ssh 公钥。 在想要连接到目标服务器的本地／远程用户的 Home 目录下的 .ssh 文件夹下面存在 config 文件并配置正确。 主机地址正确解析，并且 config 文件中指定的私钥文件路径正确。 别名让终端操作更简单比如上面已经配置好了免密码 ssh 远程服务器了，然后每次登录的时候虽然不再需要输入用户名和密码，但是仍然要输入类似 ssh root@remote_host.ext 这样长的命令，这时候为这条命令起个别名就显得非常简单快捷了。比如：1234567891011# 本次终端会话期有效(暂时) alias aly=\"ssh root@YOUR_REMOTE_LINUX_IP_ADDR\"# 连接远程 Linuxaly＃使别名永久生效vim ~/.bash_profilevim ~/.zshrc# 添加上面的别名命令添加到 bash 和 zsh 配置文件的末尾即可# 使配置文件生效source ~/.bash_profilesource ~/.zshrc rzsz - 古老而简单粗暴上下载1brew install lrzsz 其中由于 rzsz 使用的协议在一些终端，比如在 iTerm 上并不原生支持，因此需要额外的配置，其中在 Tmux 上由于协议不同导致无法支持。 1234567# 下载 iTerm2 触发脚本git clone https://github.com/mmastrac/iterm2-zmodem.git# 将脚本 copy 到 /usr/local/bin 下面cp iterm2-zmodem/iterm2-recv-zmodem.sh /usr/local/bin/cp iterm2-zmodem/iterm2-send-zmodem.sh /usr/local/bin/# 赋予可执行权限chmod a+x /usr/local/bin/iterm2*.sh 注意： 假如 lrzsz 不是用 brew 安装，就必须修改脚本里面的 rz，sz 的安装路径了。 最后配置 iTerm2 里的 triggers：进入 iTerm =&gt; Preferences =&gt; Profiles =&gt; Default =&gt; Advanced =&gt; Triggers =&gt; Edit（也可使用快捷键 Command ＋,），然后新添两行内容如下： 12345678910# 上传文件的触发规则Regular expression: rz waiting to receive.\\*\\*B0100Action: Run Silent CoprocessParameters: /usr/local/bin/iterm2-send-zmodem.shInstant: checked# 下载文件的触发规则Regular expression: \\*\\*B00000000000000Action: Run Silent CoprocessParameters: /usr/local/bin/iterm2-recv-zmodem.shInstant: checked 注意脚本的路径一定要一致正确。然后只需记住 2 条命令即可： 1234# 上传文件rz# 下载文件sz file1 file2 ... 若 iTerm2 更新到 3.0.0+则需要到 GitHub 下载最新的触发脚本重新配置。 PHP+MySQL+Nginx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 服务先安装brew install mysql# MySQL 开机启动ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist# 安装成功后开启 MySQL 安全机制/usr/local/opt/mysql/bin/mysql_secure_installation# 然后输入密码和一些选项, 启动 MySQLsudo mysqld# 查看一下MySQL运行情况ps aux | grep mysql###### PHP 扩展先安装# 添加 PHP 扩展库brew updatebrew tap homebrew/dupesbrew tap josegonzalez/homebrew-php# 选择 PHP 安装选项brew install php55 --with-fpm --with-gmp --with-imap --with-tidy --with-debug --with-mysql --with-libmysql# // 由于 PHP5.4+ 后带有 php-fpm 了因此这里启用就好了# // 其中 PHP 选项可以通过 brew options php55 来查看# 安装 PHP 扩展库brew install php55-apcu\\php55-gearman\\php55-geoip\\php55-gmagick\\php55-imagick\\php55-intl\\php55-mcrypt\\php55-memcache\\php55-memcached\\php55-mongo\\php55-opcache\\php55-pdo-pgsql\\php55-phalcon\\php55-redis\\php55-sphinx\\php55-swoole\\php55-uuid\\php55-xdebug;# 安装 Nginxbrew install nginx --with-http_geoip_module# // brew 安装 nginx 后的网站目录在：# // /usr/local/Cellar/nginx/1.10.0/html# // 或 /usr/local/opt/nginx/html# 启动 nginxsudo nginx# Nginx 配置测试nginx -t# 重新加载配置|重启|停止|退出 nginxnginx -s reload|reopen|stop|quit# 也可以使用 Mac 的 launchctl 来启动|停止launchctl unload ~/Library/LaunchAgents/homebrew.mxcl.nginx.plistlaunchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist＃ Nginx 开机启动ln -sfv /usr/local/opt/nginx/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist# 监听 80 端口 (需要 root 权限)sudo chown root:wheel /usr/local/Cellar/nginx/1.10.0/bin/nginxsudo chmod u+s /usr/local/Cellar/nginx/1.10.0/bin/nginx 替换系统默认环境变量12345# 为了避免在使用 PHP 的时候执行系统默认的PHP版本需要替换环境变量echo 'export PATH=\"$(brew --prefix php55)/bin:$PATH\"' &gt;&gt; ~/.bash_profile #for phpecho 'export PATH=\"$(brew --prefix php55)/sbin:$PATH\"' &gt;&gt; ~/.bash_profile #for php-fpmecho 'export PATH=\"/usr/local/bin:/usr/local/sbib:$PATH\"' &gt;&gt; ~/.bash_profile #for other brew install softsource ~/.bash_profile 测试 brew 安装的 PHP 是否已优先启用1234567891011# brew 安装的php 他在/usr/local/opt/php55/bin/phpphp -v # Mac 自带的PHP/usr/bin/php -v # brew 安装的php-fpm 他在/usr/local/opt/php55/sbin/php-fpmphp-fpm -v# Mac 自带的php-fpm/usr/sbin/php-fpm -v# 开机启动 php-fpmln -sfv /usr/local/opt/php55/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.php55.plist 测试 php-fpm 是否运行在通过 brew 安装的版本上123456789101112131415161718# 测试 php-fpm 配置php-fpm -t# 启动 php-fpmphp-fpm -Dphp-fpm -c /usr/local/etc/php/5.5/php.ini -y /usr/local/etc/php/5.5/php-fpm.conf -D# 关闭 php-fpmkill -INT `cat /usr/local/var/run/php-fpm.pid`# 重启php-fpmkill -USR2 `cat /usr/local/var/run/php-fpm.pid`# 也可以用 brew 命令来重启 php-fpm，不过官方已不推荐brew services restart php55# 还可以用这个命令来启动 php-fpmlaunchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.php55.plist# 启动 php-fpm 之后，确保它正常运行监听 9000 端口lsof -Pni4 | grep LISTEN | grep php# PHP-FPM 开机启动ln -sfv /usr/local/opt/php55/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.php55.plist 关联 Nginx 和 PHP123456789101112131415161718vim /usr/local/etc/nginx/nginx.conf# ...location / &#123;root /Users/cxl/WWW;index index.php index.html index.htm;autoindex on;&#125;# ...# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \\.php$ &#123;root html;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;fastcgi_param SCRIPT_FILENAME /Users/cxl/WWW/$fastcgi_script_name;include /usr/local/etc/nginx/fastcgi_params;&#125;# ... 其中的 /Users/cxl/WWW/ 代表的是网站所在目录，建议都在用户家目录下操作，并更改目录所有者为当前用户，这样可以避免每次都要 sudo 。 然后修改 php-fpm 的配置文件： 1vim /usr/local/etc/php/5.5/php-fpm.conf 找到 pid ，去掉注释 pid = run/php-fpm.pid，此后 php-fpm 的 pid 文件就会自动产生在 /usr/local/var/run/php-fpm.pid，Nginx 的 pid 文件也在那。 别名为了后面管理方便，将命令 alias 下，vim ~/.bash_aliases 输入以下内容： 1234567891011121314151617181920alias nginx.start='launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist'alias nginx.stop='launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist'alias nginx.restart='nginx.stop &amp;&amp; nginx.start'alias php-fpm.start=\"launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.php55.plist\"alias php-fpm.stop=\"launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.php55.plist\"alias php-fpm.restart='php-fpm.stop &amp;&amp; php-fpm.start'alias mysql.start=\"launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\"alias mysql.stop=\"launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist\"alias mysql.restart='mysql.stop &amp;&amp; mysql.start'alias redis.start=\"launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.redis.plist\"alias redis.stop=\"launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.redis.plist\"alias redis.restart='redis.stop &amp;&amp; redis.start'alias memcached.start=\"launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist\"alias memcached.stop=\"launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist\"alias memcached.restart='memcached.stop &amp;&amp; memcached.start'# 让快捷命令生效echo \"[[ -f ~/.bash_aliases ]] &amp;&amp; . ~/.bash_aliases\" &gt;&gt; ~/.bash_profile source ~/.bash_profile# 创建站点目录到主目录，方便快捷访问ln -sfv /var/www ~/WWW 可能会遇到的问题 1.PHP 编译过程中如果遇到 configure: error: Cannot find OpenSSL’s错误，执行xcode-select –install 重新安装一下 Xcode Command Line Tools。2.如果 nginx 报 403 错误，请检查配置文件中的 root 指定的文件路径是否具有递归访问权限，如果终点路径可访问而父目录没有访问权限，那么同样会 403，赋予目录权限最好的方式是：更改所有者为将会访问目录的用户，然后设置为 0755。 MPV - 命令行播放器苹果自带的 QuickTime 播放器虽然很不错了，但是一些常见视频格式并不支持，比如 avi mpv 是一款具有程序员个性的播放器。但是通过 brew 安装也很简单： 1234567891011brew tap mpv-player/mpvbrew install --HEAD --with-bluray-support --with-libdvdread --with-little-cms2 --with-lua --with-bundle mpv＃ 播放命令mpv /path/to/vedio.avi＃ 将编译好的 mpv 链接到 Launchpadbrew linkapps MPV＃ 也可以自己配置 mpvvim ~/.config/mpv/mpv.conf# 比如调节音量加减的快捷键设置UP add volume 1DOWN add volume -1 其他1234567891011121314# 安装开发包brew install wget watch tmux cmake openssl imagemagick graphicsmagick gearman geoip readline autoconf multitail source-highlight autojump zsh-completions sshfs # 升级系统自带 vimbrew install ctags macvim --env-std --override-system-vim# brew cask install alfred appcleaner firefox google-chrome phpstorm sublime-text sequel-pro sketch mplayerx thunder qq# rar 格式的解压缩工具brew list | grep \"rar\"brew install unrarunrar x|e filename.rar # 主要用于解压从别处下载的文件, *x 系统建议使用 tar.gz# 7z 解压缩工具brew install p7zipp7zip x filename.7z# 科学上网利器 － shadowsocks&lt;https://github.com/shadowsocks/shadowsocks&gt; 总之，通过 Homebrew 安装的软件可以直接在终端通过命令来开启，比如通过 brew 安装的 sublime text 就可以直接使用 subl filename.ext 的方式在终端中快速打开，这对于我这种终端重度使用者来说很方便。 默认 Apache／PHP 配置 Apache 网站默认路径：/Library/WebServer/Documents Apache 配置默认路径：/private/etc/apache2/httpd.conf PHP 默认配置路径：/etc/php.ini.default Markdown 博客 － 不仅是一种知识管理方式我有两份博客：GitHub 上的 Hexo 和 Coding.NET 上的 Hexo，每次在不同的地方写完东西后都要手动提交两份，很是累人，因此必须借助 Shell 命令别名来一步到位： 1234567891011121314151617vim ~/.zshrcalias post=\"bash ~/WWW/li/autocmt.sh &amp;&amp; bash ~/WWW/SoulMate94.github.io/autocmt.sh\"# 其中 ~/WWW/hexo/autocmt.sh 的内容是：cd ~/WWW/hexogit add -Agit commit -m \"backup hexo\"git push origin master # 备份博客源码到 master 分支hexo cleanhexo ghexo d # 发布文章到 coding-pages 分支# ~/WWW/SoulMate94.github.io/autocmt.sh\" 的内容是：cd ~/WWW/SoulMate94.github.iogit add -Agit commit -m \"Github post\"git push origin master 于是我只需要输入 post 命令就可以提交两份博客了，虽然很简单，但是很实用。 注意上面必须先进入 hexo 博客所在目录，否则 hexo 命令执行会报错。 Markdown 工具也推荐 Typora，十分简洁，优雅，所见即所得却又并非传统双屏“书写＋预览”模式，多的不多说，体验一把就知道了。 附录：brew／cask 常用命令123456789101112131415161718brew update # 更新 brew 可安装包，建议每次执行一下brew search php55 # 搜索 php5.5brew tap josegonzalez/php # 安装扩展 &lt;gihhub_user/repo&gt; brew tap # 查看安装的扩展列表brew install php55 # 安装 php5.5brew remove php55 # 卸载 php5.5brew upgrade php55 # 升级 php5.5brew options php55 # 查看 php5.5 安装选项brew info php55 # 查看 php5.5 相关信息brew home php55 # 访问 php5.5 官方网站brew services list # 查看系统通过 brew 安装的服务brew services cleanup # 清除已卸载无用的启动配置文件brew services restart php55 # 重启 php-fpmbrew cask search # 列出所有可以被安装的软件brew cask search php # 查找所有和 php 相关的应用brew cask list # 列出所有通过 cask 安装的软件brew cask info phpstorm # 查看 phpstorm 的信息brew cask uninstall mpv # 卸载 参考 Homebrew ( GitHub ) 全新安装Mac OSX 开发者环境 同时使用homebrew搭建 PHP，Nginx ，MySQL，Redis，Memcache … … (LNMP开发环境) [Mac]安装和简单配置MPV播放器 如何重置 Mac 上的系统管理控制器 (SMC) Reset the DNS cache in OS X","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://blog.caoxl.com/tags/Mac/"}]},{"title":"MySQL 分析命令总结","slug":"MySQL-Analysis-Commands-Notes","date":"2018-01-05T10:32:41.000Z","updated":"2019-08-22T06:29:52.000Z","comments":true,"path":"2018/01/05/MySQL-Analysis-Commands-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/05/MySQL-Analysis-Commands-Notes/","excerpt":"MySQL 分析命令总结站在 MySQL Parser 的角度，describe, desc, explain 是完全等价的（synonym）。 只是通常情况，DESCRIBE/DESC 被用分析表结构，而 EXPLIAN 被用于分析 SQL 查询执行计划（how MySQL would execute a query）而已。 其中，DESCRIBE 又是 SHOW COLUMNS/SHOW FIELDS 的别名。 为了简单，下面涉及到上面 3 个命令的都在 MySQL 5.6 下以 DESC 进行示例。","text":"MySQL 分析命令总结站在 MySQL Parser 的角度，describe, desc, explain 是完全等价的（synonym）。 只是通常情况，DESCRIBE/DESC 被用分析表结构，而 EXPLIAN 被用于分析 SQL 查询执行计划（how MySQL would execute a query）而已。 其中，DESCRIBE 又是 SHOW COLUMNS/SHOW FIELDS 的别名。 为了简单，下面涉及到上面 3 个命令的都在 MySQL 5.6 下以 DESC 进行示例。 获取表结构信息获取表结构的语法为： desc 1&#123;EXPLAIN | DESCRIBE | DESC&#125; tbl_name [col_name | wild] 其中 col_name 代表列名，wild 代表通配符。 show 123SHOW [FULL] &#123;COLUMNS | FIELDS&#125; &#123;FROM | IN&#125; tbl_name[&#123;FROM | IN&#125; db_name][LIKE 'pattern' | WHERE expr] 举例说明： 获取完整表结构1234567DESC $tb_name;SHOW COLUMNS FROM $tb_name FROM $db_name;SHOW FIELDS FROM $tb_name FROM $db_name;SHOW FULL FIELDS FROM $tb_name FROM $db_name;SHOW FIELDS FROM $tb_name FROM $db_name WHERE 1;SHOW FIELDS FROM $tb_name FROM $db_name LIKE '%';SHOW CREATE TABLE $db_name.$tb_name; 获取某个字段结构123DESC $tb_name $col_name;SHOW FIELDS FROM $tb_name FROM $db_name WHERE `Field` = $col_name;SHOW FULL FIELDS FROM $tb_name IN $db_name WHERE `Field` = $col_name; 获取主键字段的结构 1SHOW FIELDS FROM $tb_name FROM $db_name WHERE `Key` = 'PRI'; 获取若干字段结构可以使用通配符 % 和 _ 。比如： 获取所有以 a 开头的字段结构 123DESC $tb_name 'a%';SHOW FIELDS FROM $tb_name FROM $db_name WHERE `Field` LIKE 'a%';SHOW FIELDS FROM $tb_name FROM $db_name LIKE 'a%'; 获取包含 a 的字段结构 123DESC $tb_name '%a%'SHOW FIELDS FROM $tb_name FROM $db_name WHERE `Field` LIKE '%a%';SHOW FIELDS FROM $tb_name FROM $db_name LIKE '%a%'; 获取包含 a，且字段名只有 3 个字符的字段结构 123DESC $tb_name 'a__';DESC $tb_name '_a_';DESC $tb_name 'a__' 获取属性值唯一的字段结构 1SHOW FIELDS FROM $tb_name FROM $db_name WHERE `Key` = 'UNI'; 获取类型为 int(11) 的字段结构 1SHOW FIELDS FROM $tb_name FROM $db_name WHERE `Type` = 'int(11)'; 获取为可以为 NULL 的字段结构 1SHOW FIELDS FROM $tb_name FROM $db_name WHERE `Null` = 'YES'; 分析查询计划分析 SQL 查询计划的语法为： 12345678910111213141516171819202122&#123;EXPLAIN | DESCRIBE | DESC&#125; [explain_type] explainable_stmt explain_type: &#123; EXTENDED | PARTITIONS | FORMAT = format_name&#125;format_name: &#123; TRADITIONAL | JSON&#125;explainable_stmt: &#123; SELECT statement | DELETE statement | INSERT statement | REPLACE statement | UPDATE statement&#125; 其中，explain_type 可以不指定，但同时只能选择一次。format_name 默认为 TRADITIONAL。 举例说明： 分析 SELECT不指定 explain_type1234567DESC SELECT * FROM $tb_name;--&gt; 输出示例：+----+-------------+-----------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+-----------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | $tb_name | ALL | NULL | NULL | NULL | NULL | 45 | NULL |+----+-------------+-----------+------+---------------+------+---------+------+------+-------+ 不指定 explain_type 或者指定为 FORMAT = TRADITIONAL 效果一样。 指定 explain_type EXTENDED 123456789101112131415DESC extended SELECT * FROM $tb_name\\G--&gt; 输出示例：id : 1select_type : SIMPLEtable : $tb_nametype : ALLpossible_keys: NULLkey : NULLkey_len : NULLref : NULLrows : 45filtered : 100.00Extra : NULL 可见，explain_type 为 extended 时，会多返回一个 filtered 属性值。 此外，当指定了 extended 参数时，DESC 会生成额外的提示信息，可以紧接着通过 SHOW WARNINGS 查看。 FORMAT = json 123456789101112131415DESC format = json SELECT * FROM $tb_name\\G--&gt; 输出示例：EXPLAIN: &#123; \"query_block\": &#123; \"select_id\": 1, \"table\": &#123; \"table_name\": \"$tb_name\", \"access_type\": \"ALL\", \"rows\": 45, \"filtered\": 100 &#125; &#125;&#125; 注意，explain_type 为 format = json 时，DESC 的输出已经自动地输出了 expain_type 既为 extened，又为 partition 的信息，可以看到，这里也返回了一个 filtered 属性值。（expain_type 为 extened 的输出） explain 输出解释下面以 列名/JSON NAME： 对应含义 的格式进行说明。JSON_NAME 指 format = json 时的输出字段名。 id/select_id 本次 SELECT 查询的序列号。 当本次查询为 UNION 类型时，可以为 NULL 。此时的 table 将显示 &lt;unionM,N,Q&gt;，select_type 将显示 UNION RESULT，M、N、Q 分别代表 UNION 中所有查询的序列号。 select_type/none SELECT 的类型 table/table_name：SELECT 的表名。​ 参考 MySQL :: MySQL 5.6 Reference Manual :: 13.8 Utility Statements","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"Database","slug":"Database","permalink":"http://blog.caoxl.com/tags/Database/"}]},{"title":"Docker 初见","slug":"Docker-First-Try","date":"2018-01-05T10:29:39.000Z","updated":"2019-08-22T03:31:10.000Z","comments":true,"path":"2018/01/05/Docker-First-Try/","link":"","permalink":"http://blog.caoxl.com/2018/01/05/Docker-First-Try/","excerpt":"Docker-First-Try 因为PHP开发环境需要多个环境,由此学习Docker 最近的一个项目使用了低版本的 PHP 5.4，而我主要用的 PHP5.6，又不时想体验最新的 PHP 7+，之前一直使用 vagrant 管理 `Linux 虚拟机，里面同一时刻只能使用一个版本的 PHP，虽然可以安装多个版本的虚拟机，但是每次都要更新环境变量，且同一时刻只能运行一个项目。","text":"Docker-First-Try 因为PHP开发环境需要多个环境,由此学习Docker 最近的一个项目使用了低版本的 PHP 5.4，而我主要用的 PHP5.6，又不时想体验最新的 PHP 7+，之前一直使用 vagrant 管理 `Linux 虚拟机，里面同一时刻只能使用一个版本的 PHP，虽然可以安装多个版本的虚拟机，但是每次都要更新环境变量，且同一时刻只能运行一个项目。 下面以在 macOS 上总结使用 Docker 运行 N 个版本项目的实际经历，以及学到的新东西。 安装 DockerDocker 可以直接安装在 Linux、macOS，甚至 Windows 上。 这里有一个 Docker Toolbox 的东西，如果安装的是这个，那么无论是在 macOS 还是 Windows 上，Docker 实际运行的系统还是 Linux，因为安装 Docker Toolbox 的时候会安装好 VirtualBox 和一个 Linux 虚拟机。 推荐直接安装 Docker for Mac，这样可以不用绕几个弯，直接让 Docker 运行在 macOS 上。 Docker 镜像 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资 源、配置等文件外，还包含了一些为运行时准备的一些配置参数(如匿名卷、环境 变量、用户等)。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 设置加速镜像至于为什么要先设置这个，因为不设置国内镜像下载速度真的过于感人，不方便后面的操作。（神秘的东方力量，大家都懂的） 国内有阿里云和 DaoCloud 等大厂提供的 Docker 加速镜像地址，我这里使用的是 DaoCloud，在配置 Docker 加速器这里，有文档说明在三大操作系统中镜像地址的配置。以 Docker For Mac 为例： 右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中加入下面的镜像地址: http://xxxx.m.daocloud.io。 下载镜像12# 完整命令格式：docker pull [OPTIONS] [DOCKER_REGISTRY] &lt;IMAGE_NAME&gt;[:TAG|@DIGEST]docker pull nginx DOCKER_REGISTRY 是镜像的来源，格式：&lt;域名/IP&gt;[:端口]，不指明则默认为 Docker Hub。 IMAGE_NAME 是镜像在镜像源上的仓库名，格式：[用户名/]&lt;软件名&gt;，如果不指定用户名则默认使用官方镜像用户名 Library。 这里将从 Docker Hub 下载 library/nginx:latest。 定制镜像定制镜像有两种方式： commit12345docker commit \\--author \"AUTHOR NAME\" \\--message \"COMMIT MESSAGE\" \\BASE_IMAGE \\NEW_IMAGE[:NEW_TAG] Dockerfile1docker build -t IMAGE[:TAG] . 但是，不建议使用 commit 方式定制镜像， 原因如下：使镜像非常庞大： 在构建镜像过程中，除了命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜 像极为臃肿。 不方便共享和维护： 此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎 么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间 后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索， 但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦 的。 镜像常用命令 删除所有未打 tag 的镜像：docker rmi $(docker images -q | awk ‘/^/ { print $3 }’) 删除所有镜像：docker rmi $(docker images -q) 上传一个自定义镜像到 Docker Hub：12docker tag IMAGE[:TAG] NAMESAPCE/IMAGE[:TAG]docker push NAMESAPCE/IMAGE[:TAG] 这里如果上传失败，则需要再 hub.docker.com 注册一个 namespace，然后使用 docker login 登录后，再试一下。 上传时如果已经 tag 存在，则会直接更新。 Docker 容器镜像和容器的关系？都是学过 OOP 的，我想关于 Docker 中镜像和容器的区别用 OOP 中的一句很基本的概念来类比就是：镜像相当于类，容器则相当于对象。我觉得够了，不多作解释。 启动容器1docker run --name nginx-container -d -p 8888:80 --rm=true nginx docker run 将从一个镜像中启动一个容器。 --name 为这个容器命名 -d 表示 后台运行 -p 指明端口映射关系，这里的 8888:80 代表的是将宿主系统上来自 8888 端口的数据转发到 nginx-container 这个容器的 80 端口。 --rm=true 表示容器运行结束时自动删除该容器。 nginx 表示要启动 nginx-container 这个容器的镜像名。 容器常用命令 启动容器并打开 Bash：docker run -it --rm=true IMAGE[:TAG] /bin/bash 删除所有 Docker 容器：docker rm $(docker ps -a -q) 删除所有已退出运行的容器：docker rm $(docker ps -qf status=exited) 注意事项路径问题可能大家在初次构建镜像的时候，都会遇到提示找不到文件或者路径的提示，导致构建失败。下面我把我遇到的几种情况简单总结一下： ADD比如：ADD ./build /root 是把当前路径下 build 文件夹下所有的文件和目录添加到容器的 root 路径中，是不再含 build 的。因此在容器或者 Dockerfile 中不能通过 /root/build/file 来引用，而是 /root/file。 WORKDIR这个指定了工作路径，在构建的时候所有的相对路径会以这个路径为基础进行引用，同时，构建结束之后，进入容器时默认也会进入这个路径。 实战：构建一个 CentOS 6+Apache+PHP 镜像下面就为最近做的那个低版本 PHP（5.4）项目来构建的一个专门的镜像。 准备好如下文件：123456789101112cd /path/to/php54tree ..├── Dockerfile├── README.md├── app│ └── index.php├── build│ ├── ZendGuardLoader-70429-PHP-5.4-linux-glibc23-x86_64.tar.gz│ └── zendguardloader.ini└── docker.run2 directories, 6 files Dockerfile 的内容：123456789101112131415161718192021222324252627282930313233343536FROM centos:6MAINTAINER Caoxl &lt;code0809@163.com&gt;ADD ./build /tmpWORKDIR /tmpRUN yum update -y \\ &amp;&amp; yum install -y wget\\ &amp;&amp; mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup \\ &amp;&amp; wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo \\ &amp;&amp; yum install -y epel-release \\ &amp;&amp; wget http://rpms.famillecollet.com/enterprise/remi-release-6.rpm \\ &amp;&amp; rpm -Uvh remi-release-6*.rpm \\ &amp;&amp; sed -i 's/enabled=0/enabled=1/g' /etc/yum.repos.d/remi-php54.repo \\ &amp;&amp; yum install -y php php-mysql php-pdo\\ # &amp;&amp; wget http://downloads.zend.com/guard/6.0.0/ZendGuardLoader-70429-PHP-5.4-linux-glibc23-x86_64.tar.gz \\ # &amp;&amp; tar zxf ZendGuardLoader-70429-PHP-5.4-linux-glibc23-x86_64.tar.gz \\ # &amp;&amp; cp ZendGuardLoader-70429-PHP-5.4-linux-glibc23-x86_64/php-5.4.x/ZendGuardLoader.so /usr/lib64/httpd/modules/ \\ # &amp;&amp; echo 'zend_extension=/usr/lib64/httpd/modules/ZendGuardLoader.so' &gt;&gt; /etc/php.ini \\ # &amp;&amp; echo 'zend_loader.enable=1' &gt;&gt; /etc/php.ini \\ # &amp;&amp; echo 'zend_loader.disable_licensing=0' &gt;&gt; /etc/php.ini \\ # &amp;&amp; echo 'zend_loader.obfuscation_level_support=3' &gt;&gt; /etc/php.ini \\ &amp;&amp; tar zxf ZendGuardLoader-70429-PHP-5.4-linux-glibc23-x86_64.tar.gz \\ &amp;&amp; cp ZendGuardLoader-70429-PHP-5.4-linux-glibc23-x86_64/php-5.4.x/ZendGuardLoader.so /usr/lib64/httpd/modules/ \\ &amp;&amp; cat zendguardloader.ini &gt;&gt; /etc/php.ini \\ &amp;&amp; echo 'ServerName localhost' &gt;&gt; /etc/httpd/conf/httpd.conf \\ &amp;&amp; yum clean all \\ &amp;&amp; rm -rf /tmp/* \\ &amp;&amp; rm -rf /root/* \\ &amp;&amp; rm -rf /var/tmp/*ADD ./app /var/www/htmlADD ./docker.run /rootRUN chmod 755 /root/docker.runWORKDIR /var/www/htmlEXPOSE 80CMD [\"/bin/bash\", \"/root/docker.run\"] README.md123456- build`docker build -t php54:v1 .`- run`docker run -it --name php54 --rm=true -d -p 80:80 php54:v1 /var/www/html/docker.run`- test&lt;http://localhost&gt; docker.run12#!/bin/bash/usr/sbin/apachectl -D FOREGROUND app/index.php123&lt;?phpecho '&lt;h1 style=\"text-align:center\"&gt;Hello Docker&lt;/h1&gt;';phpinfo(); build/ZendGuardLoader-70429-PHP-5.4-linux-glibc23-x86_64.tar.gz 从 http://downloads.zend.com/guard/6.0.0/ZendGuardLoader-70429-PHP-5.4-linux-glibc23-x86_64.tar.gz 下载而来。 build/zendguardloader.ini 1234zend_extension=/usr/lib64/httpd/modules/ZendGuardLoader.sozend_loader.enable=1zend_loader.disable_licensing=0zend_loader.obfuscation_level_support=3 最后构建： 12cd /path/to/php54docker build -t php54:v1 . 如果不出意外，build 结束之后在 docker images 中就可以看到新建的镜像了，便可以运行： 1docker run -it --name php54 --rm=true -d -p 80:80 php54:v1 然后打开浏览器：http://localhost 正常情况即可看到 app/index.php 的输出。 同理，如果需要使用 PHP5.6／7 版本的环境，可以按照同样的步骤 build 一个相应的镜像，启动后，可以通过本机的不同端口去访问，这样就实现了在一个系统上运行 N 个版本项目的需求。 Cool~ isn’t it ? (: 参考 Docker — 从入门到实践 PHP Web Development with Docker PHP 开发者的 Docker 之旅 Docker Documentation Oracle VM VirtualBox-User Manual Why docker container exits immediately Restart apache on Docker Centos/RedHat 7/6/5切换阿里云源并安装EPEL/IUS/REMI仓库 CentOS 安装 Zend Guard Loader Or Install Zend Guard 6.0 with PHP 5.4 on Centos CentOS Yum 命令详解 将Centos的yum源为国内的阿里云源 denied: requested access to the resource is denied : docker","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://blog.caoxl.com/tags/Docker/"},{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/tags/开发工具/"}]},{"title":"Markdown 基础语法","slug":"Markdown-Basic-Syntax","date":"2018-01-05T08:26:39.000Z","updated":"2019-08-22T03:28:53.000Z","comments":true,"path":"2018/01/05/Markdown-Basic-Syntax/","link":"","permalink":"http://blog.caoxl.com/2018/01/05/Markdown-Basic-Syntax/","excerpt":"Markdown 语法 Markdown 常用与书写博客,开发文档等 ‘.md’ 和 ‘.markdown’ 都是被普遍支持的扩展名，不过 ‘.md’ 更加简单和方便。","text":"Markdown 语法 Markdown 常用与书写博客,开发文档等 ‘.md’ 和 ‘.markdown’ 都是被普遍支持的扩展名，不过 ‘.md’ 更加简单和方便。 常用语法标题12# 表示一级标题## 表示二级标题 Setext 形式12345H1====H2---- = 和 - 的数量是没有限制的。通常的做法是使其和标题文本的长度相同，这样看起来比较舒服。或者可以像我一样，用四个 - 或 =。Setext 形式只支持 h1 和 h2 两种标题。 段落段落以自然回车作为标记 段落以自然回车作为标记 引用12写法: &gt; 这里就是采用了引用 12写法二: &gt; &gt; 这里是层次感的引用 12写法三: &gt; - 引用里面有序显示 1234写法四: &gt; 树 &gt; &gt; 二叉树 &gt; &gt; &gt; 多重树 树 二叉树 多重树 斜体,加粗123斜体写法： *内容*粗体写法： **内容**又粗又斜： ***内容*** 斜体粗体又斜又粗 有序/无序123456* + - 均可以需要有层次感 缩进即可如:* 第一层 + 第二层 - 第三层 第一层 第二层 第三层 超链接普通链接1写法: [显示的文字](链接地址) 曹贤亮的博客 指向本地的链接1[icon.png](./images/icon.png) 包含 &#39;title&#39; 的链接:1[Google](http://www.google.com/ \"Google\") Google title 使用 ‘ 或 “ 都是可以的。 图片1写法: ![](图片地址) 指定图片的显示大小1&lt;img src=\"http://blog.caoxl.com/css/images/logo.png\" alt=\"GitHub\" title=\"GitHub,Social Coding\" width=\"50\" height=\"50\" /&gt; 分割线1写法: ___ 或者 --- 分割线 表格 使用- |符号把内容分割为你认为合适的表格样式就好。 使用:符号标识对齐。 123表头1|表头2|表头3:----|:-----:|-----:左对齐|居中对齐|右对齐 表头1 表头2 表头3 左对齐 居中对齐 右对齐 保存 最后将markdown编写的文档存为 .md 格式，就可以用对应的工具查看效果和编辑了。 扩展下划线1&lt;u&gt;Underlined Text&lt;/u&gt; 效果 :为文字增加下划线 删除线1~~要划除的行内内容~~ 效果 :要划除的行内内容 标注重点1`重点` 效果 :这里是重点 兼容 HTML12345678910&lt;table&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;4&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 1 2 3 4 支持Markdown语法的工具 有道云笔记 Showdoc","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://blog.caoxl.com/categories/开发工具/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/tags/Hexo/"},{"name":"Markdown","slug":"Markdown","permalink":"http://blog.caoxl.com/tags/Markdown/"}]},{"title":"Lumen5.4 开发记录","slug":"Lumen54-Dev-Log-Reprint","date":"2018-01-05T07:16:14.000Z","updated":"2019-08-22T06:21:32.000Z","comments":true,"path":"2018/01/05/Lumen54-Dev-Log-Reprint/","link":"","permalink":"http://blog.caoxl.com/2018/01/05/Lumen54-Dev-Log-Reprint/","excerpt":"惠吃猫-重构-API接口 基于二次开发,无法继续开发后的一次重构,使用lumen重构API接口","text":"惠吃猫-重构-API接口 基于二次开发,无法继续开发后的一次重构,使用lumen重构API接口 引入多个 route 文件在 routes 文件夹下创建一个路由文件，比如 api.php，然后在 bootstrap/app.php 中找到并添加： 1234$app-&gt;group(['namespace' =&gt; 'App\\Http\\Controllers'], function ($app) &#123; require __DIR__.'/../routes/web.php'; require __DIR__.'/../routes/api.php'; // 新增的路由文件&#125;); 为路由定义可选参数Lumen 不支持。 在中间件中获取路由参数如下两种 Lumen 不支持但 Laravel 支持： 12345public function handle($request, Closure $next)&#123; $request-&gt;route()-&gt;parameters(); $request-&gt;route('parameter');&#125; Lumen 只能使用：$request-&gt;route()[2] 这个数组，里面就是路由参数。 路由定义和命名空间1234567891011121314151617181920212223&lt;?php$app-&gt;group([ 'namespace' =&gt; 'ThirdParty',], function () use ($app) &#123; $app-&gt;group([ 'prefix' =&gt; 'qiniu', 'middleware' =&gt; [ 'qiniu_auth', ] ], function () use ($app) &#123; $app-&gt;group([ 'middleware' =&gt; [ 'jwt_auth', ], ], function () use ($app) &#123; $app-&gt;get('up_ticket', 'Qiniu@getUploadTicket'); &#125;); $app-&gt;post('upload_cbk', [ 'as' =&gt; 'qiniu_upload_callback', 'uses' =&gt; 'Qiniu@uploadCallback', ]); &#125;);&#125;); 在这种路由定义方式中，因为路由文件中默认的命名空间是 App\\Http\\Controllers，因此如果需要给路由定义 namespace，比如这里的 ThirdParty，则无需再写成：App\\Http\\Controllers\\ThirdParty，因为它会自动在 App\\Http\\Controllers 命名空间下找 ThirdParty 这个路径，不会报错。 同理，上面的 Qiniu@getUploadTicket 也无需写成 App\\Http\\Controllers\\ThirdParty\\Qiniu@getUploadTicket，因为在这个群路由定义的开始已经指定为 ThirdParty 了，下级在找路由器的时候便会自动去 App\\Http\\Controllers\\ThirdParty 这个命名空间找，这样一层一层，以此类推。 重定向至命名路由并传递参数1return redirect()-&gt;route('admin', ['key' =&gt; 'value']); 启用自定义 JWT 认证 首先在 bootstrap/app.php 123$app-&gt;routeMiddleware([ 'auth_jwt' =&gt; App\\Http\\Middleware\\Auth\\JWT::class,]); 然后修改 app/Http/Middleware/Auth/JWT.php 为： 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace App\\Http\\Middleware\\Auth;use Closure;use Firebase\\JWT\\JWT as FirebaseJWT;class JWT&#123; protected $auth = false; public function __construct() &#123; try &#123; if (isset($_SERVER['HTTP_AUTHORIZATION'])) &#123; $this-&gt;auth = FirebaseJWT::decode( $_SERVER['HTTP_AUTHORIZATION'], env('APP_KEY'), ['HS256'] ); &#125; &#125; catch (\\Exception $e) &#123; &#125; finally &#123; &#125; &#125; public function handle($request, Closure $next) &#123; if (false === $this-&gt;auth) &#123; return response()-&gt;json([ 'error' =&gt; 'Unauthorized' ], 401); &#125; $request-&gt;attributes-&gt;add([ 'auth_jwt' =&gt; $this-&gt;auth, ]); return $next($request); &#125;&#125; Pass value from middleware to controller 将中间件的值传递给控制器 1234567891011121314// 1. Middlewarepublic function handle($request, Closure $next)&#123; $request-&gt;attributes-&gt;add([ 'key' =&gt; 'value' ]); return $next($request);&#125;// 2. Controllerpublic function getVauleFromMiddleware(Request $req)&#123; echo $req-&gt;get('key'); // output: value&#125; 通过这种方式，可以对不同的路由使用不同的认证（非常语义化），然后把各种认证的结果（jwt，七牛）传递到控制器，可以使控制器不用再操心认证逻辑，减少控制器代码量。 自定义配置文件 bootstrap/app.php 1$app-&gt;configure('custom'); 创建一个 config/custom.php 文件 1234&lt;?phpreturn [ 'key' =&gt; 'value']; 使用 123456dd(config('custom'));/* output: array:1 [▼ \"key\" =&gt; \"value\"]*/ CORS如果是客户端是浏览器，则在调用 API 的时候，基本上无法避免跨域问题。 不过处理也很简单，需要浏览器和服务器同时配合：浏览器在发起 OPTIONS preflight 请求的时候，服务器返回认可的一些信息就行了。 具体如下： app/Http/Middleware/CORS.php 12345678910111213141516171819202122232425&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CORS&#123; public function __construct() &#123; &#125; public function handle($request, Closure $next) &#123; $headers = [ 'Access-Control-Allow-Origin' =&gt; '*', 'Access-Control-Allow-Methods' =&gt; '*', 'Access-Control-Allow-Headers' =&gt; 'Access-Control-Allow-Origin, AUTHORIZATION', 'Access-Control-Max-Age' =&gt; 86400, ]; if ('OPTIONS' == $request-&gt;getMethod()) &#123; return response(null, 200, $headers); &#125; return $next($request)-&gt;withHeaders($headers); &#125;&#125; bootstrap/app.php 1234// 指定全局中间件$app-&gt;middleware([ 'cors' =&gt; App\\Http\\Middleware\\CORS::class,]); jQuery AJAX Demo 123456789101112131415$.ajax(&#123; url: 'http://api.example.com/path/to/resource', type: 'GET', dataType: 'json', async: false, cors: true , headers: &#123; 'Access-Control-Allow-Origin': '*', 'AUTHORIZATION': 'JWT_STRING' &#125;, success: function (res) &#123; &#125;, error: function (xhr, status) &#123; &#125;&#125;); migration 中给表加注释1234567public function up()&#123; Schema::create('table_name', function (Blueprint $table) &#123; // DDL (数据定义语言) &#125;); DB::statement('ALTER TABLE `table_name` comment \"table_comment\"');&#125; migration 设置 current_timestamp123$table-&gt;dateTime('create_at')-&gt;default( DB::raw('CURRENT_TIMESTAMP')); 连接多个数据库 初始化数据库配置对象 12# bootstrap/app.php$app-&gt;configure('database'); 创建并修改 config/database.php 123456789101112131415161718192021222324252627282930313233&lt;?phpreturn [ // ... 'default' =&gt; 'mysql_db1_rw', 'connections' =&gt; [ // ... 'mysql_db1_rw' =&gt; [ 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_HOST'), 'database' =&gt; 'db1_rw', // read and write 'username' =&gt; env('DB_USERNAME'), 'password' =&gt; env('DB_PASSWORD'), 'charset' =&gt; 'utf8', 'collation' =&gt; 'utf8_unicode_ci', ], 'mysql_db1_ro' =&gt; [ 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_HOST'), 'database' =&gt; 'db1_ro', // read only 'username' =&gt; env('DB_USERNAME'), 'password' =&gt; env('DB_PASSWORD'), 'charset' =&gt; 'utf8', 'collation' =&gt; 'utf8_unicode_ci', ], // ... ] // ...]; 注意： 一旦创建了 config/database.php 文件，系统默认的 vendor/laravel/lumen-framework/config/database.php 将失效。 因此，最好的做法是拷贝系统自带的配置文件到项目根目录，然后进行一些自定义的修改。 12rm -rf config/*.phpcp vendor/laravel/lumen-framework/config/database.php config/ 在控制器中使用不同的数据库连接 根据上面的配置默认会连接 mysql_db1_rw 这个数据库。那如果需要连接第二个数据库，使用示例如下： 123456// Use default connection =&gt; mysql_db1app('db')-&gt;connection()-&gt;select('show tables');DB::connection()-&gt;select('show tables');// Use mysql_db2 connectionapp('db')-&gt;connection('mysql_db1_ro')-&gt;select('show tables');DB::connection('mysql_db1_ro')-&gt;select('show tables'); 自定义日志文件名 Lumen 中默认的文件名是被硬编码在 Application 类中了的，要实现这样的效果，必须重写 Laravel\\Lumen\\Application@getMonologHandler() 方法。 新增文件：app/Application.php 123456789101112131415161718192021222324252627&lt;?php// Custom default or hard-coded behavior of lumen// hard-coded behavior 硬编码namespace App;use Laravel\\Lumen\\Application as LumenBase;use Monolog\\Formatter\\LineFormatter;use Monolog\\Handler\\StreamHandler;use Monolog\\Logger;class Application extends LumenBase&#123; // Rewrite log handler protected function getMonologHandler() &#123; return ( new StreamHandler(storage_path(env( 'APP_LOG_PATH', 'logs/'.date('Y-m-d').'.log' )), Logger::DEBUG )) -&gt;setFormatter(new LineFormatter(null, null, true, true)); &#125;&#125; 修改 bootstrap/app.php123$app = new App\\Application( realpath(__DIR__.'/../')); 自定义 artisan 命令 创建一个 command 类 1234567891011121314&lt;?php// app/Console/Commands/Hello.phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;class Hello extends Command&#123; protected $name = 'patch:hello'; protected $description = 'Balabalabala'; public function fire() &#123; $this-&gt;info('hello atisan cmd'); &#125;&#125; 创建一个 command service provider 1234567891011121314151617&lt;?php// app/Providers/CommandService.php namespace App\\Providers;use Illuminate\\Support\\ServiceProvider;class CommandService extends ServiceProvider&#123; public function register() &#123; $this-&gt;app-&gt;singleton('command.patch.hello', function () &#123; return new \\App\\Console\\Commands\\Hello; &#125;); $this-&gt;commands( 'command.patch.hello' ); &#125;&#125; 注册该 command service provider 12// bootstrap/app.php$app-&gt;register(App\\Providers\\CommandService::class); 测试 12php artisan patch:hello// output: hello atisan cmd 模型查询结果中隐藏部分字段123456protected $hidden = [ 'passwd',];protected $visible = [ 'uid']; 其中 $visible 的优先级比 $hidden 高。 FAQ docker 搭建的运行环境，macOS 下执行 php artisan migrate 提示：_php_networkgetaddresses: getaddrinfo failed: nodename nor servname provided, or not known？ 这是因为是在本地（macOS）执行的这条命令，而本地对 .env 中配置的 DB_HOST=db 是解析不了的。因此会出现这个错误。 解决这种问题也很简单，有两种办法： 修改主机 hosts 文件，使 db 指向 mysql 容器的 域名／IP。比如：127.0.0.1 db。（推荐） 进入 docker 容器再运行迁移。 Class ‘Memcache’ not found? 安装 memcached/memcache 扩展。 php artisan migrate PDOException: user not exist? 检查是主机地址是否填错。 检查配置中的数据库服务器是否存在该用户。 可能踩的坑 数据库事务操作时部分逻辑未生效？ 检查对象是否是有效的 Model 对象。举例说明，以下代码第一步将不会生效： 1234567891011121314151617$user = User::select('money')-&gt;whereUid(1)-&gt;first();\\DB::beginTransaction();// 第一步：减少用户余额$user-&gt;money -= 100;$decreased = $user-&gt;save();// 第二步：记录日志$loggedId = Log::insertGetId([ 'uid' =&gt; 1, 'amount' =&gt; -10, 'intro' =&gt; 'test',]);// 两步结果共同决定是否执行事务if ($decreased &amp;&amp; $loggedId) &#123; \\DB::commit();&#125; else &#123; \\DB::rollback();&#125; 这是因为，对模型对象调用了 select() 方法后，就不是一个完整的模型对象了（从结果来看）。 解决办法是，不使用 select() 或者使用 find()。 123$user = User::whereUid(1)-&gt;first();// Or$user = User::find(1); 参考 Laravel Middleware return variable to controller Documentation - Lumen 5.4 Documentation - Laravel 5.5 Laravel_API-Manual Laravel 5 Cheat Sheet Laravel 5.1 LTS速查表 Configuring Multiple Database Connections In Lumen Enable Custom Configuration Files in Lumen Lumen Recipes :: Creating a New Artisan Command DB:select toArray()","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"},{"name":"Lumen","slug":"Lumen","permalink":"http://blog.caoxl.com/tags/Lumen/"},{"name":"API","slug":"API","permalink":"http://blog.caoxl.com/tags/API/"}]},{"title":"Hexo 在Github/Coding中搭建","slug":"Hexo-Github-Coding","date":"2018-01-05T03:44:10.000Z","updated":"2019-08-22T02:41:54.000Z","comments":true,"path":"2018/01/05/Hexo-Github-Coding/","link":"","permalink":"http://blog.caoxl.com/2018/01/05/Hexo-Github-Coding/","excerpt":"在Github/Coding上部署Hexo 将hexo部署到代码库的同时指向自定义域名 博客部署 Github: http://blog.caoxl.com Coding: http://life.caoxl.com","text":"在Github/Coding上部署Hexo 将hexo部署到代码库的同时指向自定义域名 博客部署 Github: http://blog.caoxl.com Coding: http://life.caoxl.com 部署必备 服务器 (推荐阿里云) 域名 Github账号 Coding(码市)账号 部署过程 在服务器上添加域名解析 Github 1231. 添加一个CNAME记录类型 记录值为:SoulMate94.github.io2. 添加两个A记录类型(@) 记录值为:GithubIP地址:192.30.252.153 192.30.252.154 Coding 11. 添加一个CNAME记录类型 记录值为:soulmate94.coding.me 在Github/Coding上打开域名指向 Github 1在 项目SoulMate94.github.io中/Settings/GitHub Pages 添加一个Custom domain (如blog.caoxl.com) Coding 1在 我的项目/代码/Pages服务 中添加自定义域名 (如life.caoxl.com) FAQ 问题: hexo部署后，CNAME会被自动删除，怎么办？ 答: 将需要上传至github的内容放在source文件夹，例如CNAME、favicon.ico、images等。 问题: 怎么部署REDEME.md到github上又消失了 答: 在source文件夹创建后 ,在_config,yml中添加skip_render: README.md 即可 参考 Hexo开发详细另见:Hexo-Dec-Record","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://blog.caoxl.com/tags/博客/"}]},{"title":"Laravel-admin-开发记录","slug":"Laravel-admin-Dev-Notes","date":"2018-01-04T07:47:18.000Z","updated":"2019-08-22T03:59:37.000Z","comments":true,"path":"2018/01/04/Laravel-admin-Dev-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/04/Laravel-admin-Dev-Notes/","excerpt":"laravel-admin 是一个可以快速帮你构建后台管理的工具当前版本(1.6)需要安装PHP 7+和Laravel 5.5","text":"laravel-admin 是一个可以快速帮你构建后台管理的工具当前版本(1.6)需要安装PHP 7+和Laravel 5.5 开发必备 Laravel-Admin文档: https://laravel-admin.org/docs/zh/ Laravel文档: http://d.laravel-china.org/ 安装/快速开始 安装 1composer require encore/laravel-admin \"1.5.*\" 发布资源： 1php artisan vendor:publish --provider=\"Encore\\Admin\\AdminServiceProvider\" 完成安装： 1php artisan admin:install 添加路由器 1234php artisan admin:make UserController --model=App\\\\User// 在windows系统中php artisan admin:make UserController --model=App\\User 添加路由配置 1$router-&gt;resource('users', UserController::class); 快速上手 安装帮助工具 Helpers 使用里面的脚手架Scaffold, 创建表、控制器和模型 在/database/seeds/创建MenuSeeder.php并如下操作 12345678910111213141516171819202122232425&lt;?phpuse Illuminate\\Database\\Seeder;use Encore\\Admin\\Auth\\Database\\Menu;class MenuSeeder extends Seeder&#123; /** * Run the database seeds. * * @return void */ public function run() &#123; $Test = Menu::firstOrCreate([ 'uri' =&gt; 'test' ], [ 'parent_id' =&gt; 0, // 父级菜单ID 'order' =&gt; 99, // 排序 升序 'title' =&gt; 'Test', // 菜单名 'icon' =&gt; 'mdi-brightness-4', // 图标 http://icons.inkblot.cc/ 'uri' =&gt; 'test' // URI ]); &#125;&#125; 在在/database/seeds/创建DatabaseSeeder.php中调用 12345678910111213141516&lt;?phpuse Illuminate\\Database\\Seeder;class DatabaseSeeder extends Seeder&#123; /** * Seed the application's database. * * @return void */ public function run() &#123; $this-&gt;call(MenuSeeder::class); &#125;&#125; 在命令行使用 php artisan db:seed创建目录 创建资源路由如下: 1234567891011121314151617181920&lt;?phpuse Illuminate\\Routing\\Router;Admin::registerAuthRoutes();Route::group([ 'prefix' =&gt; config('admin.route.prefix'), 'namespace' =&gt; config('admin.route.namespace'), 'middleware' =&gt; config('admin.route.middleware'),], function (Router $router) &#123; $router-&gt;get('/', 'HomeController@index'); $router-&gt;resources([ // Test 'test' =&gt; TestController::class, ]);&#125;); 访问 http://admin.test/admin/test 即可 帮助工具 https://laravel-admin.org/extensions Helpers 12composer require laravel-admin-ext/helpersphp artisan admin:import helpers Redis管理工具 12composer require laravel-admin-ext/redis-managerphp artisan admin:import redis-manager 文件管理 12345678910composer require laravel-admin-ext/media-manager -vvvphp artisan admin:import media-manager# 配置# 打开config/admin.php指定你要管理的disk'extensions' =&gt; [ 'media-manager' =&gt; [ 'disk' =&gt; 'public' // 指向config/filesystem.php中设置的disk ],], API tester 12345composer require laravel-admin-ext/api-tester -vvvphp artisan vendor:publish --tag=api-tester# 导入菜单和权限php artisan admin:import api-tester 配置管理 12345678composer require laravel-admin-ext/configphp artisan migrate# 打开app/Providers/AppServiceProvider.php, 在boot方法中添加Config::load();Config::load(); // 加上这一行# 导入菜单和权限php artisan admin:import config 计划任务 1234567891011121314composer require laravel-admin-ext/scheduling -vvvphp artisan admin:import scheduling# 添加任务# 打开app/Console/Kernel.php， 试着添加两项计划任务：class Kernel extends ConsoleKernel&#123; protected function schedule(Schedule $schedule) &#123; $schedule-&gt;command('inspire')-&gt;everyTenMinutes(); $schedule-&gt;command('route:list')-&gt;dailyAt('02:00'); &#125;&#125; 模型表格 Grid1234567891011121314151617181920212223242526272829303132333435363738394041 &lt;?php use App\\Models\\Movie; use Encore\\Admin\\Grid; use Encore\\Admin\\Facades\\Admin; $grid = Admin::grid(Movie::class, function(Grid $grid)&#123; // 第一列显示id字段，并将这一列设置为可排序列 $grid-&gt;id('ID')-&gt;sortable(); // 第二列显示title字段，由于title字段名和Grid对象的title方法冲突，所以用Grid的column()方法代替 $grid-&gt;column('title'); // 第三列显示director字段，通过display($callback)方法设置这一列的显示内容为users表中对应的用户名 $grid-&gt;director()-&gt;display(function($userId) &#123; return User::find($userId)-&gt;name; &#125;); // 第四列显示为describe字段 $grid-&gt;describe(); // 第五列显示为rate字段 $grid-&gt;rate(); // 第六列显示released字段，通过display($callback)方法来格式化显示输出 $grid-&gt;released('上映?')-&gt;display(function ($released) &#123; return $released ? '是' : '否'; &#125;); // 下面为三个时间字段的列显示 $grid-&gt;release_at(); $grid-&gt;created_at(); $grid-&gt;updated_at(); // filter($callback)方法用来设置表格的简单搜索框 $grid-&gt;filter(function ($filter) &#123; // 设置created_at字段的范围查询 $filter-&gt;between('created_at', 'Created Time')-&gt;datetime(); &#125;);&#125;); 禁用相关操作 1234567891011121314151617181920禁用创建按钮$grid-&gt;disableCreation();禁用分页条$grid-&gt;disablePagination();禁用查询过滤器$grid-&gt;disableFilter();禁用导出数据按钮$grid-&gt;disableExport禁用行选择checkbox$grid-&gt;disableRowSelector();禁用行操作列$grid-&gt;disableActions();设置分页选择器选项$grid-&gt;perPages([10, 20, 30, 40, 50]); 内置方法: editable 直接编辑数据 12$grid-&gt;title()-&gt;editable();$grid-&gt;title()-&gt;editable('textarea'); switch 1$grid-&gt;is_show('显示/隐藏')-&gt;switch(config('const.article_list.IS_SHOW')); switchGroup 12345678910$states = [ 'on' =&gt; ['text' =&gt; 'YES'], 'off' =&gt; ['text' =&gt; 'NO'],];$grid-&gt;column('switch_group')-&gt;switchGroup([ 'hot' =&gt; '热门', 'new' =&gt; '最新' 'recommend' =&gt; '推荐',], $states); 帮助方法: 字符串操作 1$grid-&gt;title()-&gt;limit(30)-&gt;ucfirst()-&gt;substr(1, 10); 数组操作 1234567$grid-&gt;tags();// 调用Collection::pluck()方法取出数组的中的name列$grid-&gt;tags()-&gt;pluck('name');// 取出name列之后输出的还是数组，还能继续调用用Illuminate\\Support\\Collection的方法$grid-&gt;tags()-&gt;pluck('name')-&gt;map('ucwords');// 将数组输出为字符串$grid-&gt;tags()-&gt;pluck('name')-&gt;map('ucwords')-&gt;implode('-'); 混合使用 12345678910// 链式方法调用来显示多图$grid-&gt;images()-&gt;display(function ($images) &#123; return json_decode($images, true);&#125;)-&gt;map(function ($path) &#123; return 'http://localhost/images/'. $path;&#125;)-&gt;image(); 数据查询过滤12345678910$grid-&gt;filter(function($filter)&#123; // 去掉默认的id过滤器 $filter-&gt;disableIdFilter(); // 在这里添加字段过滤器 $filter-&gt;like('name', 'name'); ...&#125;); 查询类型 123456789101112131415$filter-&gt;equal('column', $label);$filter-&gt;notEqual('column', $label);$filter-&gt;like('column', $label);$filter-&gt;ilike('column', $label);$filter-&gt;gt('column', $label);$filter-&gt;lt('column', $label);$filter-&gt;between('column', $label);$filter-&gt;between('column', $label)-&gt;datetime();//设置datetime类型$filter-&gt;between('column', $label)-&gt;time(); //设置time类型$filter-&gt;in('column', $label)-&gt;multipleSelect(['key' =&gt; 'value']);$filter-&gt;notIn('column', $label)-&gt;multipleSelect(['key' =&gt; 'value']);$filter-&gt;date('column', $label);$filter-&gt;day('column', $label);$filter-&gt;month('column', $label);$filter-&gt;year('column', $label); 数据导出 安装 12composer require maatwebsite/excel:~2.1.0php artisan vendor:publish --provider=\"Maatwebsite\\Excel\\ExcelServiceProvider\" 新建自定义导出类，比如app/Admin/Extensions/ExcelExpoter.php: 123456789101112131415161718192021222324252627&lt;?phpnamespace App\\Admin\\Extensions;use Encore\\Admin\\Grid\\Exporters\\AbstractExporter;use Maatwebsite\\Excel\\Facades\\Excel;class ExcelExpoter extends AbstractExporter&#123; public function export() &#123; Excel::create('Filename', function($excel) &#123; $excel-&gt;sheet('Sheetname', function($sheet) &#123; // 这段逻辑是从表格数据中取出需要导出的字段 $rows = collect($this-&gt;getData())-&gt;map(function ($item) &#123; return array_only($item, ['id', 'title', 'content', 'rate', 'keywords']); &#125;); $sheet-&gt;rows($rows); &#125;); &#125;)-&gt;export('xls'); &#125;&#125; 在model-grid中使用这个导出类： 123use App\\Admin\\Extensions\\ExcelExpoter;$grid-&gt;exporter(new ExcelExpoter()); 模型表单 Form123456789101112131415161718192021222324252627282930313233343536use App\\Models\\Movie;use Encore\\Admin\\Form;use Encore\\Admin\\Facades\\Admin;$grid = Admin::form(Movie::class, function(Form $form)&#123; // 显示记录id $form-&gt;display('id', 'ID'); // 添加text类型的input框 $form-&gt;text('title', '电影标题'); $directors = [ 'John' =&gt; 1, 'Smith' =&gt; 2, 'Kate' =&gt; 3, ]; $form-&gt;select('director', '导演')-&gt;options($directors); // 添加describe的textarea输入框 $form-&gt;textarea('describe', '简介'); // 数字输入框 $form-&gt;number('rate', '打分'); // 添加开关操作 $form-&gt;switch('released', '发布？'); // 添加日期时间选择框 $form-&gt;dateTime('release_at', '发布时间'); // 两个时间显示 $form-&gt;display('created_at', '创建时间'); $form-&gt;display('updated_at', '修改时间');&#125;); 自定义工具1234567891011$form-&gt;tools(function (Form\\Tools $tools) &#123; // 去掉返回按钮 $tools-&gt;disableBackButton(); // 去掉跳转列表按钮 $tools-&gt;disableListButton(); // 添加一个按钮, 参数可以是字符串, 或者实现了Renderable或Htmlable接口的对象实例 $tools-&gt;add('&lt;a class=\"btn btn-sm btn-danger\"&gt;&lt;i class=\"fa fa-trash\"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;delete&lt;/a&gt;');&#125;); 其它方法 去掉提交按钮: 1$form-&gt;disableSubmit(); 去掉重置按钮: 1$form-&gt;disableReset(); 忽略掉不需要保存的字段: 1$form-&gt;ignore(['column1', 'column2', 'column3']); 设置宽度: 1$form-&gt;setWidth(10, 2); 设置表单提交的action: 1$form-&gt;setAction('admin/users'); 权限控制相关方法: 获取当前用户对象 1Admin::user(); 获取当前用户id 1Admin::user()-&gt;id; 获取用户角色 1Admin::user()-&gt;roles; 获取用户的权限 1Admin::user()-&gt;permissions; 用户是否某个角色 1Admin::user()-&gt;isRole('developer'); 是否有某个权限 1Admin::user()-&gt;can('create-post'); 是否没有某个权限 1Admin::user()-&gt;cannot('delete-post'); 是否是超级管理员 1Admin::user()-&gt;isAdministrator(); 是否是其中的角色 1Admin::user()-&gt;inRoles(['editor', 'developer']); 权限中间件:1234567891011121314151617181920212223242526272829// 允许administrator、editor两个角色访问group里面的路由Route::group([ 'middleware' =&gt; 'admin.permission:allow,administrator,editor',], function ($router) &#123; $router-&gt;resource('users', UserController::class); ...&#125;);// 禁止developer、operator两个角色访问group里面的路由Route::group([ 'middleware' =&gt; 'admin.permission:deny,developer,operator',], function ($router) &#123; $router-&gt;resource('users', UserController::class); ...&#125;);// 有edit-post、create-post、delete-post三个权限的用户可以访问group里面的路由Route::group([ 'middleware' =&gt; 'admin.permission:check,edit-post,create-post,delete-post',], function ($router) &#123; $router-&gt;resource('posts', PostController::class); ...&#125;); 自定义 自定义登录认证 http://laravel-admin.org/docs/#/zh/custom-authentication 自定义头部导航条 http://laravel-admin.org/docs/#/zh/custom-navbar 自定义图表 http://laravel-admin.org/docs/#/zh/custom-chart","categories":[{"name":"Laravel / Lumen","slug":"Laravel-Lumen","permalink":"http://blog.caoxl.com/categories/Laravel-Lumen/"}],"tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://blog.caoxl.com/tags/Laravel/"},{"name":"LaravelAdmin","slug":"LaravelAdmin","permalink":"http://blog.caoxl.com/tags/LaravelAdmin/"},{"name":"框架","slug":"框架","permalink":"http://blog.caoxl.com/tags/框架/"},{"name":"Framework","slug":"Framework","permalink":"http://blog.caoxl.com/tags/Framework/"}]},{"title":"Git 开发记录","slug":"Git-Dev-Notes","date":"2018-01-01T03:42:50.000Z","updated":"2019-08-22T03:42:45.000Z","comments":true,"path":"2018/01/01/Git-Dev-Notes/","link":"","permalink":"http://blog.caoxl.com/2018/01/01/Git-Dev-Notes/","excerpt":"总结Git操作 参考别人的记录 Git 命令无需记忆 Git 常见问题","text":"总结Git操作 参考别人的记录 Git 命令无需记忆 Git 常见问题 CentOS 更新 GIT12yum install -y http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpmyum update -y git .gitignore 从版本库中移除（停止追踪）某个文件／夹12345678# 停止追踪未修改且未放到暂存区的文件 filegit rm --cached file# 停止追踪未修改且未放到暂存区的目录 dirgit rm -r --cached dir# 停止追踪修改且已经放到暂存区的文件 filegit rm -f --cached file# 停止追踪修改且已经放到暂存区的目录 dirgit rm -rf --cached dir 说明: 一般情况下，项目最开始就需要在 .gitignore 中规定好哪些文件或者文件夹是不需要纳入 Git 控制的。但是难免会出现中途不想让 Git 控制某个文件的意图， 中途把文件／文件夹移除版本库的提交操作，仍然会存在于提交历史中。 gitignore 文件写法示例12345# `#` 开头为注释# `*` 表示忽略所有文件*# `!` 表示排除某个文件!.gitignore 保留子目录的某个文件注意，如果要 gitignore 目录的所有文件，但是要保留目录（包括子目录）名，这样写是无效的: 12web/!web/static/.gitkeep 这样依然会把 web 目录的所有文件忽略掉，要保留 web 及其子目录 static 的正确的写法如下:123web/*web/static/*!web/static/.gitkeep 或者:1234/vendor/*!/vendor/a!/vendor/a/b!/vendor/a/b/c git commit 修改最后的提交说明 1git commit --amend 添加新的更改 123git add . -Agit commit -a --amendgit commit -a --amend -m \"deving at `date`\" git fetch123git checkout mastergit fetch origin master:mater_tmpgit merge mater_tmp git rebase 使用 rebase 合并分支和 merge 直接合并分支相比，rebase 可以使提交历史变得线性。比如，要把 test 分支合并到 master。12345git checkout testgit rebase master # 这一步和 merge 相同，可能会遇到冲突，也需要人工解决，人工解决后继续 rebasegit rebase --continuegit checkout mastergit merge test 删除／合并没意义的提交内容123456789# rebase 最近 100 次提交记录git rebase -i HEAD~100# VIM 操作:%s/pick/fixup/g # 改为 fixup 模式:1 # 跳至第一行 修改 fixup 为 pick 或 reword 必须要保留一次提交 否则 git 会终止 rebase 进程# 终止 rebase 进程git rebase --abort# 继续 rebase 进程git rebase --continue rebase 操作的含义：1234567pick =&gt; use commit =&gt; 完整保留本次提交记录和信息reword =&gt; use commit, but edit the commit message =&gt; 会保留提交记录 但是会自动指引你到改变提交信息界面edit =&gt; use commit, but stop for amending =&gt; 保留提交记录 但是 rebase 进程会停止 需要手动 amend 后再 continuesquash =&gt; use commit, but meld into previous commit =&gt; 会保留选中的提交记录文本fixup =&gt; like \"squash\", but discard this commit's log message =&gt; 会丢弃选中的提交记录文本exec =&gt; run command (the rest of the line) using shelldrop =&gt; remove commit =&gt; 会删除提交时仓库对应的改动 rebase 进程是分支共享的意思是，你在 test 进行了一半的 rebase 操作，如果要在 dev 上执行新的 rebase 命令，则必须先执行 git rebase –abort 才可以，否则 git 会报错。 git cherry Apply the changes introduced by some existing commits.应用某些现有提交所引入的更改。 查看所有在 test 分支而不在 master 分支的提交1git cherry -v master test cherry-pick A cherry-pick in Git is like a rebase for a single commit. It takes the patch that was introduced in a commit and tries to reapply it on the branch you’re currently on. 在某个分支应用整个仓库中存在的提交 1git cherry-pick &lt;commit_hash&gt; git revertgit revert is the converse of git chery-pick。后者用于将某次 commit 应用到某个分支，前者用于将某次 commit 从某个分支中移除。 移除某次非 merge-commit 并自动创建一次新的 commit hash 1git revert &lt;commit-hash&gt; 移除某次非 merge-commit，不自动创建新的提交记录 12git revert -n &lt;commit-hash&gt;git revert --no-commit &lt;commit-hash&gt; 撤销当移除某次非 merge-commit 时自动创建了提交的记录的操作 1git reset HEAD~1 --soft 移除某次 merge-commit 并自动创建新的 commit hash 1234# 指定 mainline 为合并提交记录中的第 1 个分支git revert -m 1 &lt;commit-hash&gt;# 指定 mainline 为合并提交记录中的第 2 个分支git revert -mainline 2 &lt;commit-hash&gt; 在你合并两个分支并试图撤销时，Git 并不知道你到底需要保留哪一个分支上所做的修改。从 Git 的角度来看，master 分支和 dev 在地位上是完全平等的，只是在 workflow 中，master 被人为约定成了「主分支」。 于是 Git 需要你通过 m 或 mainline 参数来指定「主线」。merge commit 的 parents 一定是在两个不同的线索上，因此可以通过 parent 来表示「主线」。m 参数的值可以是 1 或者 2，对应着 parent 在 merge commit 信息中的顺序。 配置123# 查看当前配置git config --local -lgit config --help tag 获取远程 tag12345678# 允许 fetch 获取 taggit config --unset-all remote.origin.fetchgit config --add remote.origin.fetch '+refs/heads/*:refs/remotes/origin/*'git config --add remote.origin.fetch '+refs/tags/*:refs/tags/*'# 获取远程所有 tagsgit fetch --tags# 获取远程某个 taggit fetch origin +refs/tags/&lt;TAG_NAME&gt; 重置／撤销 重置单个已修改但未提交的文件（工作区）为上次提交时的状态12345678# 1. 有风险的写法git checkout /path/to/modified_file# 2. 安全写法git checkout -- /path/to/modified_file# 3. 或者：移除未被跟踪的文件和目录git clean -fd# OR 对其他分支中的文件进行这种操作# man git-checkout 由于 checkout 命令同样可以用于操作分支，因此，如果刚好出现要重置的文件名和某个存在的分支名同名的话，则最好使用第二种写法。 重置当前工作区的所有未提交的改动（谨慎使用）1git reset --hard 重置已提交到版本库中的提交12345git reset --hard HEAD^ # 回退到前 1 个版本git reset --hard HEAD^^ # 回退到前 2 个版本git reset --hard HEAD~10 # 回退到前 10 个版本git reset --hard &lt;hash_long&gt; # 通过完整 hash 回退到某个确定的版本git reset --hard &lt;hash_short&gt; # 通过短 hash 回退到某个确定的版本 重置已推送到远程仓库的提交：12git reset --hard &lt;commit-hash&gt;git push -f origin master 如果推送失败，只是 GitLab 或 GitHub 中设置了保护分支，可以暂时取消，会滚后。 将改动从暂存区撤销到工作区1git reset HEAD 暂存改动123git add -Agit stashgit stash clear 查看暂存内容1git stash show -p stash@&#123;1&#125; git diff12345git diff # Diff the working copy with the indexgit diff --cached # Diff the index with HEADgit diff HEAD # Diff the working copy with HEAD# 查看两次提交记录的区别git diff &lt;hash-1&gt; &lt;hash-2&gt; &gt; /path/to/file git branch 删除本地所有 master 和当前分支以外的分支12git branch | grep -v \"master\" | xargs git branch -Dgit branch | egrep -v \"(master|\\*)\" | xargs git branch -D Note that lowercase -d won’t delete a “non fully merged” branch.注意小写字母D不会删除“非完全合并”分支。 git show 查看某次提交的改动详情 1git show &lt;commit-hash&gt; 查看某次提交的改动简要统计 1git show &lt;commit-hash&gt; --stat git log 查看历史提交改动详情 1git log -p 统计某人代码量 1git log --author=\"$(git config --get user.name)\" --pretty=tformat: --numstat | awk '&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf \"added lines: %s removed lines : %s total lines: %s\\n\",add,subs,loc &#125;' - 统计仓库所有开发者代码量 1git log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$(git config --get user.name)\" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc &#125;' -; done 仓库提交者排名前 5（如果看全部，去掉 head 管道） 1git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 仓库提交者（邮箱）排名前 5 1git log --pretty=format:%ae | gawk -- '&#123; ++c[$0]; &#125; END &#123; for(cc in c) printf \"%5d %s\\n\",c[cc],cc; &#125;' | sort -u -n -r | head -n 5 这个统计可能不会太准，因为很多人有不同的邮箱，但会使用相同的名字。 贡献者统计 1git log --pretty='%aN' | sort -u | wc -l 提交数统计123456# 提交总数git log --oneline | wc -l# 每个作者的提交数git shortlog -sgit shortlog --numbered --summarygit log --author=\"cxl\" --oneline --shortstat 添加或修改的代码行数123git log --stat | perl -ne 'END &#123; print $c &#125; $c += $1 if /(\\d+) insertions/;'git log --shortstat --pretty=\"%cE\" | sed 's/\\(.*\\)@.*/\\1/' | grep -v \"^$\" | awk 'BEGIN &#123; line=\"\"; &#125; !/^ / &#123; if (line==\"\" || !match(line, $0)) &#123;line = $0 \",\" line &#125;&#125; /^ / &#123; print line \" # \" $0; line=\"\"&#125;' | sort | sed -E 's/# //;s/ files? changed,//;s/([0-9]+) ([0-9]+ deletion)/\\1 0 insertions\\(+\\), \\2/;s/\\(\\+\\)$/\\(\\+\\), 0 deletions\\(-\\)/;s/insertions?\\(\\+\\), //;s/ deletions?\\(-\\)//' | awk 'BEGIN &#123;name=\"\"; files=0; insertions=0; deletions=0;&#125; &#123;if ($1 != name &amp;&amp; name != \"\") &#123; print name \": \" files \" 个文件被改变, \" insertions \" 行被插入(+), \" deletions \" 行被删除(-), \" insertions-deletions \" 行剩余\"; files=0; insertions=0; deletions=0; name=$1; &#125; name=$1; files+=$2; insertions+=$3; deletions+=$4&#125; END &#123;print name \": \" files \" 个文件被改变, \" insertions \" 行被插入(+), \" deletions \" 行被删除(-), \" insertions-deletions \" 行剩余\";&#125;'git ls-files -z | xargs -0n1 git blame -w | ruby -n -e '$_ =~ /^.*\\((.*?)\\s[\\d]&#123;4&#125;/; puts $1.strip' | sort -f | uniq -c | sort -n 生成日报12alias dg='git log --pretty=format:\"- %s\" --author=\"$(git config --get user.name)\" --since=9am &gt; ~/.today.md &amp;&amp; subl ~/.today.md'git config alias.rb \"log --pretty=format:'- %s' --author='$(git config --get user.name)' --since=9am\" 核心概念branch／tag／ commit commitGit 中有且只有三大类型：blob、tree object、commit。 branchbranch 并不是 Git 中过的特殊类型，一个 branch 无非是对一个被命名 commit 的引用，一个 branch 只是一个名字。 因为一个提交可能有一个或者多个父代提交，而这些父代提交又有父代提交，这就允许将某一个提交就可以看作一个分支，因为它拥有全部的修改至它本身的历史。 tagtag 和 commit 本身也是相同的，唯一的不同是 tag 可以有自己的描述。（不然怎么能叫“标记”呢） 参考 How to install latest version of git on CentOS 6.x/7.x GIT pull/fetch from specific tag 统计本地Git仓库中不同贡献者的代码行数的一些方法 “git diff” does nothing Undo a particular commit in Git that’s been pushed to remote repos Git 撤销合并","categories":[{"name":"Git / Svn","slug":"Git-Svn","permalink":"http://blog.caoxl.com/categories/Git-Svn/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.caoxl.com/tags/Git/"}]},{"title":"MySQL  基础知识","slug":"MySQL-Basic-Knowledge","date":"2017-12-31T09:58:29.000Z","updated":"2019-08-22T06:29:57.000Z","comments":true,"path":"2017/12/31/MySQL-Basic-Knowledge/","link":"","permalink":"http://blog.caoxl.com/2017/12/31/MySQL-Basic-Knowledge/","excerpt":"MySQL 基础知识 记录MYSQL学习以及开发中的一些基础知识点","text":"MySQL 基础知识 记录MYSQL学习以及开发中的一些基础知识点 数据库基本概念分类关系型现实实体关系保存在一张张二维表内,每张表内的结果和定义是完全相同的。 表示记录的容器,数据库是表的容器。 NoSQL数据结构不一致的非关系型数据库。常用键值对存储。 对象型/ORM一般大型的框架里面都会封装 ORM,是为了解决数学模型和软件工程概念之间的矛盾而出现的一种中继数据层。 关系型数据库DB vs DBMS数据库（存储数据的物理实体）和数据库管理软件（管理数据库数据的软件系统）是两种东西 关系型数据库（SQL）操作分类DDL：数据库定义语言用于定义数据库的三级结构,包括外模式、概念模式、内模式及其相互之间的映像,定义数据的完整性、安全控制等约束。 DDL不需要 commit。 1CREATE / ALTER / DROP / TRUNCATE / COMMENT / RENAME DML：数据库操纵语言由 DBMS 提供,用于让用户或程序员使用,实现对数据库中数据的操作。DML 分成交互型 DML 和 嵌入型 DML两类。依据语言的级别,DML又可分成过程性DML 和 非过程性DML两种。 需要 commit。 1SELECT / INSERT / UPDATE / DELETE / MERGE / CALL / EXPLAIN / PLAN / LOCK TABLE DCL：数据库控制语言授权,角色控制等。 12# 授权 / 取消授权GRANT / REVOKE DTL：事务控制语言1234SAVEPOINT -- 设置保存点ROLLBACK [TO SAVEPOINT] -- 回滚START TRANSCATIONCOMMIT 设计和使用如何设计数据库？ 取决于业务经验多少。 如何设计一张表？关键在于设计表存储的结构,分析实体有哪些属性已经这些属性要怎样去存储。 如何分析和设计实体间的关系？实体间关系有哪些？主要分为以下三种： 1 对 1两张实体表存在结构相同的主键字段,并且记录的主键值等于另一个关系表内的主键值。 1 对 n(n 对 1)在多的那端增加一个字段,用于指向该实体所属的另一个实体的标识。 n 对 m利用一个中间表来表示实体之间的对应关系,中间表的每一条记录,表示一个关系。其实 M =&gt; N,可以分解成 M =&gt; 1, N =&gt; 1,其中那个 1 代表的就是中间表。 如何使用 MySQL 数据库？ 取决于对 MySQL 软件语法了解多少。 校对规则校对规则有何用？在当前编码下字符之间的比较顺序关系（排序条件）。 每一套编码字符集都有与之相关的一组或多组校对规则,每套字符集都有一套默认的校对规则。 校对规则可以规定不同的比较顺序（排序方式）,从而按需显示。 说明 校对规则不会影响数据的保存格式,只有字符集才影响。 校对规则的命名规范1字符集_地区名_比较规则 其中,ci,cs,bin,分别代表不区分大小写,区分大小写,字节比较。 存储引擎定义即表的数据类型，指的是数据表的存储机制，比如用什么数据结构进行管理，以及索引方案等配套的相关功能。 默认存储引擎可以在 my.ini 中修改 default-storage-engine=INNODB。 也可以通过以下命令指定表的存储引擎： 12alter table tb_name engine myisam;create table tb_name(...) engine myisam; 注意 从支持外键的存储引擎并且表内已经有外键的话，更换到不支持的存储引擎时这样修改不会成功。 MyISAM 和 InnoDB 可能会随着版本升级而有所改变 不同的存储引擎的存储文件后缀，以及创建一个表事创建的文件个数是不一样的如 InnoDB 创建一个表文件的后缀是 .frm。其为结构文件，InnoDB 的数据文件在data 目录下的名为 ibdata 字样的文件中，表空间内存储着表数据和表索引，一 个表一个文件。 而 MyISAM 创建一个表文件的后缀是 .myd（数据文件），一个表三个文件（还有 2 个是.frm , .myi =&gt; 索 引） MyISAM 比 InnoDB 快由于 MyISAM 文件分开存储，而索引文件可以被压缩，而 InnoDB 中索引和数据是绑定的，不能被压缩，体积大，所以 MyISAM 查询速度比 InnoDB 快。 并发和查询MyISAM 是 MySQL 5.5 之前默认的存储引擎，由于不支持事务所以读写速度较快，但是容易在进行写操作的时候进行全表加锁的问题，表级锁触发后，当对表有操作时整个表都不能被再同时修改，直到当前操作结束为止，这时候如果写频率很快就容易造成写阻塞，并发性表现低。 MyISAM 擅长查询，插入和检索。InnoDB 是行级锁，支持对表的多行操作，并发操作支持比较好。InnoDB 擅长更新和删除。 Innodb 是 5.5 之后默认的存储引擎，也是互联网项目中建议使用的存储引擎，在维护上和效率上都比较高效。 select 时是否整表全扫InnoDB 不保存表的具体行数，所以在执行 select count(*) from table 时，InnoDB 需要完整扫描一遍表，来计算有多少 行，而 MyISAM 只需读出保存好的行数即可。 但是在执行 select count(*) from table where … 时两种引擎效率相同。 联合索引对于 auto_increment 类型的字段， InnoDB 中必须包含只有该字段的索引，而 MyISAM 可以和其他字段一起建立联合索引 其他存储引擎 MRG_MYISAM 基于 MyISAM，可以把多个结构相同的基于 MYISAM 的表进行合并成一 个表进行处理(类似视图和分区) Archive 更趋向于存储日志类数据，存储容量相对较小。 Ndb cluster MySQL 集群中使用的。（内存型，如果数据大小大于内存则不使用该引擎） 选择存储引擎的原则 性能 功能 数据类型字段类型和列类型MySQL 使用字段保存数据的，而字段的结构是列。列的类型指的就是具体的「值」。 如何选择列类型？ 尽量精确 优先考虑应用语言的处理要求而不是先考虑对 MySQL 数据库怎么最好 考虑兼容性，数据库内数据的迁移问题 数值整数型采用补码存储，不取决于具体语言，而取决于计算机指令集结构。 tinyint =&gt; 1 Byte =&gt; -128~127 | 0~255 smallint =&gt; 2 Bytes =&gt; -32768~32767 | 0~65535 mediumint =&gt; 3 Bytes =&gt; -8388608~8388607 | 0~16777215 int =&gt; 4 Bytes =&gt; -2147483648~2147483647 | 0~4294967295 bigint =&gt; 8 Bytes =&gt; -9223372036854775808~9223372036854775807|0~18446744073709551615 浮点型永远会丢失精度。 float =&gt; 单精度 =&gt; 4 Bytes，默认精度 6 位左右 double =&gt; 双精度 =&gt; 8 Bytes，默认精度 16 位左右 decimal =&gt; 定点数（精度为指定） =&gt; 可变长存储，大致是每 9 个数字采用 4 字节存储；整数和小数分开算 浮点数科学计数法121.2e3 =&gt; 120012.E3 =&gt; 12000 说明 MySQL 没有布尔类型。通常使用 tinyint(1) 来替代。 当超过类型范围是会报错而不会像 PHP 那样自动类型转换。 什么叫“浮点”？如何控制浮点数的数值范围？小数点可以移动。控制数值范围的形式为 type(M,D)，其中 M 表示总位数，D 表示其中的小数点位数，因此整数位数=M-D。 当浮点数精度丢失不会报错。当小数点超过规定的值时不会报错，只是输出还是规定的位数，而整数位超出会报错。 关于浮点数的「无符号」浮点数虽然也支持无符号，但它的无符号只是从逻辑上告诉不能存储负数而已，而不能向整型一样改变小数所能表示的值的范围。（显示范围受幂的影响） 什么叫定点数？有什么特点？定点数是怎么保存数据的？怎么用？” 变长 “代表什么意思？ decimal，属于可变长不丢失精度的存储方式，是将数的所有位数都保存在计算机硬盘上，因此不会出现位数的丢失。通 常情况下，小数整数分开算，每 9 位 4 个字节存储。但也会根据具体情况优化，用于保存的位数够用就行，减少浪费这就是 “变长” 的含义。 decimal(M,D)，M 是最大总位数，D 依然是最大小数位数。默认情况，M 为 10，D 为 0。 当小数超过规定位数时 decimal 会自动四舍五入。而整数只允许在最大范围内而不能四舍五入。 手机号型数据选择 char 还是 int？ 用 char 表示，因为 int 整型主要是可以用于计算的，手机号虽然是数字但不用于运算操作，所以其本质也相当于字符串。 如果为了性能优先，又能确保手机号全是数字，则推荐使用 bigint 型。 时间日期 类型 =&gt; 显示格式 =&gt; 取值范围 =&gt; 存储空间 datetime =&gt; YYYY-MM-DD HH:MM:SS =&gt; 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 =&gt; 8 bytes timestamp =&gt; YYYY-MM-DD HH:MM:SS =&gt; 1970-01-01 00:00:00 ~ 2038-01-19 03:14:07 =&gt; 4 bytes date =&gt; YYYY-MM-DD =&gt; 1000-01-01~ 9999-12-31 =&gt; 3 bytes time =&gt; HH:MM:SS =&gt; -838:59:59~ 838-59-59 =&gt; 3 bytes year =&gt; YYYY =&gt; 1901~2155 =&gt; 1 byte 关于 timestamp，从 DBA 角度从 PHP 开发者的角度使用时间类型有什么区别?以整型存储(同 PHP 里时间戳的表示)，但表现形式依然是日期类型，截至日期为什么是那么多，是因为 4 个字节保存的范围只有那么多。 如果是 MySQL 的数据库管理员，则需要使用上面列出的所有时间日期类型，但是从一个 PHP 程序员的角度来看，最常用的是 PHP 自己的时间戳（UNIX 时间戳）而不是 MySQL 的时间戳，即直接用整形的形式将时间保存在数据库内。 因为整形保存数据基本上每种语言都支持，从这个角度讲，使用通用性比较好的 UNIX 时间戳，程序的兼容性将比较 好，也容易移植和升级。 关于分隔符支持任意形式的分隔符甚至不要分隔符，MySQL 是以范围自动区分，所以只要范围未溢出并且不太影响事实都能正常输 出，但最好是按标准输出不要总是使用特殊字符，因为有时候会造成误解。 比如只输入 2 位数表示日期时必须要明确 0-69 指的是 20xx 年，70-99 指的是 19xx 年，70-69 指的是 1970-2069 才能减少误解程度： 1234567insert into tb_name values( '14:28:30', '2015+04+21', '2015*04*21*14*57*30', '1994@03@09@00@00@01', 2015); 关于 0 值如 2015-5-0 代表的就是 5 月整个月。 关于 timetime 类型除了表示一天的时间外还可以表示时间间隔 “多少天多少小时多少分多少秒”，可用于表示过去了多久。 格式为：D HH:MM:SS。D 表示天数，范围大概 35 天内。比如： 1insert into tb_name cloumn_name values('8 5:23:56'); -- 表示 8 天 5 小时 23 分 56 秒 字符串 类型 =&gt; 最大长度 =&gt; 备注 char =&gt; 255 =&gt; char(M)（M 表示字符数） varchar =&gt; 65535，但需要 1～2 位来保存信息，同时由于记录的限制，因此最大为 65532 =&gt; 可存储的字符个数根据编码不同而不同： gbk =&gt; 0~32767; utf8 =&gt; 0~21845 tinytext/text/mediumtext/longtext =&gt; L-1（L 为最大长度）;分别为：2^8-1/2^16-1/2^24-1/2^32-1 =&gt; 定义时通常不用手动指定长度，MySQL 可以自动计算 enum =&gt; 1、2；枚举选项量：65535 =&gt; 内部存储也是整型 字段只能是枚举值中其一（单选） set =&gt; 1、2、3、4、8；元素数量：64 binary/varbinary/blob =&gt; char/varchar/text 类似 =&gt; 是存储二进制数据（字节而非字符） char(M) 和 varchar(M) 的区别？M 表示的是允许的字符串长度，注意不是字节数，但是总长度的使用还是按照字节来计算的，即存储的时候还是按照字节数来存储。这将导致不同字符集的字符采用相同的 char 或 varchar 占用的字 节数将不一样，反之也成立。 在 char 中 M 是严格固定的长度，在 varchar 中 M 是可变长的（即 var 代表的其实是 variable），表示的是允许的最大长度。这样的特点导致了 char 的执行速率将会比 varchar 要高一点，但是灵活性不如 varchar，因为 varchar 可以事先计算出字符串的长度，从而灵活分配存储空间，避免空间的浪费。 但这灵活性是建立在额外运算时间和额外的一个字节保存字符串长度为代价的。 varchar 的存储原理总长度 65535 ，当类型数据超过 255 个字符时，用 2 个字节来保存长度。此情况下如果字符可以为空，则还需要 1 个字节保存字符是否为空这个信息，即此时能用于保存字符的字节数为 65535-2-1=65532。 如果不能为空 (not null)，而且是表整个记录的所有的字段同时都非空，才不需要额外的一个字节来保存空信息，即这个字节的作用是保存所有字段是否为空，即此时能用于保存字符的字节数为 65535-2=65533。 text 和 varchartext 所有字节都能用于保存数据。 enum 和 set单选和多选(集合)的区别。对数据库而言可以节省空间，但对于 PHP 项目不一定最适用。 123456create table tb_name ( gender enum('female','male'));-- enum 起始值为 1 而不是 0insert into tb_name values('male'); &lt;=&gt; insert into tb_name values(2);select gender+0 from tb_name; -- 该查询结果根据最后一次 insert 操作动态变化 enum 支持 +0 检索。set 的 +0 检索做的是位运算，是对所选的几个选项顺序号的二进制表示相加。 12345678create table tb_name ( lang set('c','php','python','java'));-- 错误示例insert into tb_name values('c, php,python'); -- !!! 两个元素之间不能含有空格等其他符号-- 正确示例insert into tb_name values('c,php');select lang+0 from set_test; -- 该查询结果根据最后一次 insert 操作动态变化 binary（字节与）二进制数据没有编码的概念，始终都是字节而不能有效地转化为字符。 字符是有各种编码方案的，虽然在最底层都是二进制数据但在应用层时字符却能被编码而以人能理解的方式被解码输出。 数据库虽然可以存图片但是基本上没有这 么做，几乎都是保存二进制文件的文件路径，然后通过路径利用文件系统或浏览器去获取图片。但有些很特殊的情况如果确实需要保存二进制数据则 MySQL 也支持。 特殊类型 NULL 站在数据的角度怎么理解？ NULL 也代表一个数据，也会占有数据空间，因为它代表“什么都没有”这个信息，本身占空间。 关于数据类型的长度 CHAR、VARCAHR 的长度是指字符的长度，即字符串个数 例如 char(3) 则只能放字符串 “123”，如果插入数据 “1234”，则从高位截取，变为 “123”。 注意这里的字符串个数无论是什么语言都一视同仁，包括中文，即 char(3) 能存 ‘123’，也能存 ‘一二三’。 VARCAHR 同理。 TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT 的长度指的是显示宽度 其实和数据的大小无关，因为每种整型类型的可存储范围都是固定了的，指定长度是无法更改其存储范围的，只能改变 0 填充时整数的显示宽度。举例说明： 123456CREATE TABLE `t` ( `ui` int(20) unsigned zerofill DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8insert into t values(123456789);-- select 结果为00000000000123456789 FLOAT、DOUBLE 和 DECIMAL 的长度指的是全部数位 也包括小数点后面的小数个数，例如 decimal(4,1) 指的是全部位数为 4，小数点有且必须有 1 位，整数最长只能 3 位数。如果插入 1000（纯整数），则在高版本 mysql 中会报 out of range 错误，此时能插入的最大值是 999.9。 TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 的长度 tinytext/mediumtext/longtext 不能显示指定长度。 在 utf8 编码格式下（mysql 5.7），text 指定的长度如果是从 0~21845，则其就为 text 类型；如果指定长度为 21846~5592405，则自动增长至 mediumtext 类型；如果指定长度为 5592405 到 4294967295 则自动增长至 longtext 类型。 选项和属性zerofill - 定义数据的显示宽度123456alter table tb_name add `new_column` tinyint(3) zerofill;insert into tb_name (`new_column`) values(1), (10);select new_cloumn from tb_namel;-- 结果为001010 zerofill 不影响数据的存储范围。宽度大的不影响，不会截取显示。 字段的最大长度类型本身的限制和记录的总长度。不同字符集下也会影响。 not null 会影响字段长度，通常是占用 1 位。 列属性 是否为空：null/not null null 和空字符串谁占空间？（null） 默认值 当没有为字段设置值的时候自动启用，使用格式：default VALUE，默认值的设定需要固定值。 如果一个字段没有默认值而且为空，则会插入失败。举例说明： 123456create table tb_name ( a int(10) not null, b int(10) not null);insert into tb_name (a) values (10); -- 不会报错insert into tb_name (b) values (20); -- 会报错：\"Field 'a' doesn't have a default value\" 上面的语句插入不成功的原因是第二句插入语句没有 a 同时 a 也没有默认值，第一句没有报错是因为顺序问题： 当给字段赋值的时候如果不从首字段开始则前面不能省略，而是将需要赋值的字段名都要写出来然后写出字段对应的值。 主键 Primary Key。可以由唯一标识某条记录的字段或者是字段的集合组成（组合主键），不推荐组合主 键，因为比较麻烦。 此外，虽然主键可以是真实实体的属性，但也不推荐，最好的是用一个与实体不相关的属性作为唯一标识。主键最好不与业务发生关系而只做标识用。 主键不能相同，也不能为 null（默认），否则插入失败。 主键可以为负，但是否为负取决于主键的类型。 只能存在一个主键。常见的设计中，都存在字段，并且不是组合主键。 1234-- 定义主键primary key (cloumn_a, cloumn_b)-- 删除主键alter table tb_names drop primary key; 定义主键可以在字段类型后面马上定义，或者最后单独定义。 其中组合主键只能最后单独定义主键的时候将多个字段都写进去。 组合主键的含义是一个主键包含了多个字段而不是多个字段都是主键。 自动增长 为每条记录提供一个唯一的标识，将某个字段的值自动增加 1，一般是从 1 开始增长，但也不一定。可以修改表选项来设置增长的初始值。 如从想要从 n 开始自增： 1alter table tb_name auto_increment N; 这种情况，如果设置的值小于当前已自增的最大值，则会无视设置，继续以前的自增。 自动增长的条件：整型和有索引（通常是主键）。为主键设置自动增长通常有 2 种情况，一是在现有主键基础上设置自动增长，二是删除现有主键之后，重新在新建主键同时指定主键自动增长。自动增长遇到 NULL 会自动 +1。 强制自增： 具有 auto_increment 属性的字段，插入记录时无论该字段插入为 null 或是不插入值，都会强制自动增长。 如果删除最后一列后，从删除处开始继续增长；如果从中间删除，则依然从当前最大值开始自增。同一张表中删除过后的字段序号相当于作废，与当前最大值比较，如果大于当前最大值则继续使用，反之完全作废。 设置表存储引擎和字符集设置存储引擎可以使用等号也可以不适用，设置字符集可以使用 charset 也可以使用 character set 。为了统一都使用 character set。 约束/外键定义 实体间的关系需要一些限制才能确保逻辑正常，约束就是这么一些限制。 「外键」 用于约束处于关系内的实体，外键可以增加当前数据完整性，提高逻辑的可靠度。比如在增删改查子表或父表时，父表或子表应该如何处理相关记录。 如果实体 1 的某个字段，指向／引用实体 2 的主键，则该实体 1 的该字段就是外键（Foreign Key）。 被指向的实体 (表) 称为主实体（主表，父表），负责指向的实体，称之为从实体（从表，子表）。 举例说明： 1234-- TABLE_A 具有字段 `CLOUMN_A`-- TABLE_B 具有主键 `b_id`-- foreign key (外键字段) references 主表名 (关联字段)[主表记录删除时的动作][主表记录更新时的动作]CONSTRAINT `TABLE_A_ibfk_1` FOREIGN KEY (`CLOUMN_A`) REFERENCES `TABLE_B` (`b_id`) ON DELETE CASCADE 外键表实体间的关系，在实体外定义。主键表实体内部字段的关系，在实体内定义。 标志外键字段在使用 desc tb_name 时会是 MUL，代表 multiple，多个关联的意思。 创建外键的时候 ibfk_1 是系统默认提供的标志符。 主表和从表对子表的操作会收到主表的限制。比如，如果主表中没有记录，那么插入从表是不会成功的。 反过来没影响，即新增主表记录时不会收到从表记录的影响。 级联 主表更新时从表行为 123456主表行为 =&gt; on update从表级联=&gt; cascade =&gt; 跟随主表行为=&gt; set null =&gt; 从表不再指向任何主表【前提：主表中关联从表的那个字段属性不能设置成 not null，否则 set null 不会成功】=&gt; restrict =&gt; 拒绝，默认行为（因此执行 `show create table tb_name` 时不会显示） 主表删除时从表行为 12主表行为 =&gt; on delete从表级联 =&gt; 同主表更新 修改级联操作属性 1234-- 1. 先删除外键alter table slave_tb drop foreign key foreign_key_cloumn;-- 2. 重建外键alter table slave_tb add foreign key (foreign_key_cloumn) references master_tb(m_tb_primary_key) on update/delete cascade/set null/restrict; 注意: on update 和 on delete 可以同时出现，但允许的级联操作（cascade/set null/restrict）在每个 on update 或者 on delete 上只能出现一次。 外键只对支持外键的存储引擎起作用。 外键是否必须 作为 MySQL 系统管理员（即站在数据库的专业角度）必须会使用外键，但作为 PHP 程序员（即站在应用的角度）尽量少用外键而是用其他的方案替代，比如想办法通过字段之间的互相引用建立一个对应关系，而不必在增加表的时候设置 foreign key。 基本SQL语法插入一次性插入多条记录1insert into table_name( field0, field1 ) values( xxx, xxx ), ( aaa, aaa ) , (ddd, ddd ) ; 可以不将所有字段都插入数据，如果要完成部分字段的插入，则必须存在字段列表;没有插入的字段将使用默认值 set 语法在 insert 中的应用如果只插入部分字段，可以使用 set 更新数据。 1insert into tb_name set field1=value1, field2=value2, ...; -- 和 insert 基本用法功能相同 插入数据时主键冲突？因为默认有主键约束，所以这种情况不会插入成功。但是在使用 insert 语法时可以指定为更新主键值。 1234insert into tb_name (field1, field2, ...)values (value1, value2, ...)on duplicate keyupdate field1=new_value1, field2=new_value2, ...; 上述 on duplicate key update 的含义是如果主键冲突则更新字段值（insert 语法中的 update 后面没有 set）。此类语句执 行的流程为： 先判断是否插入成功，如果可以插入成功则不会执行更新操作；如果插入失败(主键冲突或是唯一索引冲突)，则执行更新操作。 蠕虫复制 就是将 select 本表的结果插入到同表中。 除了使用自定义数据外，还可以使用 select 语句查询到的结果作为插入数据的来源进行插入 123insert into tb_name (field1, field2, ...)select cloumn1, cloumn2, ...from ...; 这么使用要求插入字段，也就是 select 的对象，的类型和数量，要和插入字段列表里面一样。 插入数据时默认值的设置方式 在插入值的时候，可以直接在值列表中插入 null ，也可以直接将 default 关键字，或 default(field) 函数作为插入的值 列表中的一个 建议插入 default，因为如果插入 null ，当字段本身默认值不为 null 的时候会出现数据不一致。插入 default 关键字的时候，设置过的 default 值将自动被插入。 默认值可以保证数据的完整性。 replace 如果 insert 由于类似主键冲突，唯一索引等错误而插入失败时，使用 replace 替换 insert 可以将新插入的记录去替换， 而没有类似错误时功能同 insert 。但建议除非在十分确认的情况下才使用 replace ，因为如果失误，则原有数据会丢失。语法同 insert 。 导入数据 1load data infile '/path/to/file' into table tb_name 语法同 select into outfile，load data infile 专门倒入由 select into outfile 导出的文件，也有和 select into outfile 相同的配置命令。 注意： 导入时，涉及到数据的增加，此时需要考虑到数据是否冲突。通常，可以在导出时，将主键导出为 null ，利用自动 增长的特性，可以形成新的主键。 更新更新数据的方式 replace insert on duplicate key update update：update 也支持 order by/where/limit set 1set profiling=1; -- 设置允许记录 sql 精确的执行时间 多表更新 使用 join。 12345update table1join table2on table1.field1=table2.field2set field3=value1, field4=value2where field5=value3; 多表更新和多表删除的优点是可以一次性执行多步操作，缺点是复杂并容易忽略掉一些细节。 关于 rename 只有表存在 rename 操作，数据库不存在。 rename 支持跨数据库重命名表。使用举例： 1234567891011-- 修改表名rename tableold_tb_a to new_tb_a,old_tb_b to new_tb_b,...;-- 交换两个表名rename tabletable1 to tmp,table2 to table1,tmp to table2; 如果相对数据库进行重命名，可以参考的做法有： 123# 1. 直接修改文件夹名字 [不通用=&gt;不推荐]# 2. 先将旧数据库导出，在新建一个数据库，再导入，导入的过程中就完成了重命名操作，最后删除旧数据库# 3. 将旧数据库的表移动到新数据库（rename)，然后删除旧数据库 表的基本修改操作 123456789101112131415-- alter table tb_name add|modify|drop|change column_name ...-- 新增列／字段alter table tb_name add new_column column_defination [after|brefore column];-- 修改字段定义alter table tb_name modify column_name new_defination;-- 删除字段alter table tb_name drop column_name;-- 重命名某列alter table tb_name change old_column new_column new_defination;-- 修改表选项alter table tb_name new_tb_options; 修改字符编码 12345678-- 修改数据库字符编码alter database db_name character set names utf8;-- 修改表字符编码alter table tb_name character set utf8;-- 设置客户端编码set character_set_client = 'utf8'; 删除 if exists 是否必要？ 如果不写 if exists，当表或数据库不存在时，则会报错删除失败。 语句没错，但是仍然删除错误的原因可能是什么？ 有时候由于安全限制，可能操作系统不允许删除文件，则应该先在文件系统对文件操作的级别上删除 文件，然后再使用 drop 命令删除表。 如何有条件地删除数据？ delete + limit 1delete from teble limit n; -- 被删除的 n 条记录是 selete * from table; 中的前 n 条记录 delete + order by + limit 1delete from table order by field_name limit n; -- 只有 order by 没有 limit 没有意义 delete + join 连接删除，同时删除多个表内的记录（不使用外键技术，因此存储引擎不会限制在 innodb）。 需要先提供表名，再提供连接条件： 123delete from table1, table2using pub_fieldjoin table2 on field1=field2 where field3=value; 此命令可以拆分成： 12delete from table1 where field3=value;delete from table2 where filed3=value; truncate tb_name 清空表，作用同 delete from tb_name，两者区别在 truncate tb_name 不会返回记录数，并且会重建自动增长的主键（从 0 开始），本质是先删除表再重建表，同时不会具有原来表的属性。 而 delete from tb_name 会返回记录数，不会重建自动增长的主键，本质是逐行删除 查询show123456789show create dabatabse db_name; -- 查看数据库定义show create table tb_name; -- 查看表定义show databases; -- 查看当前数据库系统中存在的所有数据库名show tables; -- 查看当前数据库的所有表名show character set; -- 查看支持的字符集show collation like 'utf8%'; -- 查看支持的校对规则show variables like \"char%\"; -- 查看 MySQL 内置变量show full processlist; -- 查看 MySQL 进程show profiles; -- 查看历史 SQL 语句的执行精确时间 Duration*1000 为毫秒数 select多字段排序先按照第一个字段排序，如果不能区分，则按照第二个字段排序，以此类推。 123-- asc =&gt; ascending 升序 默认-- desc =&gt; descending 降序select * from tb_name order by cloumn_a asc, cloumn_b desc; 排序关系受校对规则和字符编码影响。 limit1234567-- 格式：limit OFFSET, ROW_COUNT-- OFFSET =&gt; 偏移量-- ROW_COUNT =&gt; 要截取的长度 不是指结束位置-- !!! OFFSET + ROW_COUNT 的索引位置从 0 开始而不是从 1 开始-- OFFSET 不是 MySQL 关键字而是具体的数字 =&gt; 内部索引值-- OFFSET 可以不设置 因为有默认值 0-- 若 ROW_COUNT 值超过索引最大值 则 MySQL 会自动截取 去重重复记录指的是字段值都相同的记录，而不是部分字段值相同的记录。 12-- 筛选 CLOUMN_NAME_A CLOUMN_NAME_B CLOUMN_NAME_C 都相等的值 只留一个select distinct CLOUMN_NAME_A, CLOUMN_NAME_B, CLOUMN_NAME_C from tb_name ; select distinct * 和 select * ／select all效果是一样的。 子查询有些时候查询的条件需要先使用另一个查询语句获得，因为有时如果不先获得一个中间的查询结果，再借助该结果来查询需要的信息，则可能会使查询结果不准确，比如被遗漏。 比如，查询代课天数最多老师的姓名和性别信息，如果用 select name, gender from teachers order by days limit 1，则当有多个带个天数相同的老师的时候，也只能获得一 个结果，由于事先并不知道代课天数相同的老师有多少个，所以 limit 在这个在这里并不好限制。此时可以换个思路：可以先通过查询获得最大的代课天数，然后再通过将这个最大的代课天数作为下次查询的条件，这样只要符合条件的记录都会出现在结果中而不会有遗落的情况发生。 像上面这种情况，如果分条写则显得有点啰嗦，刚好 MySQL 可以不用变量的方式而可以直接将中间查询语句的查询结果作为值，来作为另一条语句的限制条件。 如果一个查询语句出现在了另一个查询语句中， 即父语句内部有子语句，称为子查询。使用子查询，可以将一个比较复杂的逻辑分步进行管理，降低业务逻辑的复杂 度，同时使查询一步到位。 1select name, gender from teachers where days = (select max(days) from teachers); -- 这里的子语句需要使用括号包裹起来，否则 MySQL 不能解析 子查询的分类 根据 subquery 出现的位置 where 型： 详见返回形式为单一值，行和列的情况 from 型： 详见返回形式为表的情况 exists 型： 使用格式很简单 =&gt; exists(subquery)。返回的是布尔值，即如果子查询能够返回数据，则认为 exist 表达式返回真， 否则返回假。 举例说明: 1select * from tb_a where exists (select * from tb_b where tb_a.field_a = field_b); 其中，field_b 是 tb_b 里面的字段，所以不用指明表名。 exists 型查询的特点？ 类似于双重循环，普通查询只需要判断一次，符合即查询成功，不符合则查询失败。而 exists 查 询，每在父句（表1）中遍历一次获得每一个值，都需要在子句（表2）中遍历所有记录来检查有无符合条件的记录存在，即外部执行一次，内部执行多次，和双重循环有点类似。 exists 与 in 的联系与区别？ 都能完成相同的事情，但思维方式不一样。 in 是先获得表 2 中所有所需的字段，然后再与表 1 中所需查询的一个或多个字段进行对比，判断这一个或多个字段是否在 in 检索出来的集合内。两者没有谁有谁劣的说法，各有各的优点。 如 exists 的优点是不用把所有结果都保存起来，数据量大时比较节省空间，而 in 的优点是将所有符合条件的结果事先存储起 来，这样检索的时候速度会快很多，一个是空间效率高，一个是时间效率高。存在即有理，使用何种方式取决于具体业务使用哪种更加方便。 根据 subquery 的返回值 单一值 返回值是单一值的查询称为标量子查询。即获得一个值后，使用基本的关系运算符进行判断。 列（一列，多列） 称为列子查询。通常是获得多个行的一列值。可以是一个范围，也可以是一个集合。举例如下: 1234567-- 返回一列select name from teachers;-- 返回多列select name, gender, days from teachers where name in ( select name from teachers where class_name='php'); 行 返回值为一行的称为行子查询。要返回一行可以不使用子查询获得： 1select * from tb_name limit 1; 或者使用行子查询： 12345select name, gender, class_name from teachers where (gender, class_name) = ( select distinct gender, class_name from teachers where gender='male' and class_name = 'php'); 这里要返回一行则需要使用括号先构建出一行，并且构建行的结构要与子查询语句获得的信息结构一致，然后再使用逻辑运算符连接子查询。 表(多行，多列) 称为表子查询。举例说明: 1234select * from ( select name, gender, class_name from teachers where days &gt; 15) as tmp where name like '李%'; 如果表子查询用在 from 后面，则要求 from 后面跟着的是一个表而不是查询结果，所以需要将子句的查询结果用 as 起名使其成 为一个表，然后在被父句所检索。 表子查询的核心是将子句查询结果看作一个表。然后再从这个表中进行二次查询。这也导致了父查询使用字段名将由子句指定。 子查询的操作符集合操作符。常用 in 或 not in 表示。 =any(集合)等价于 in。等于集合中的任何一个即在集合中有则成立。 !=any(集合)表示不等于集合中的任何一个即可，也即只要与集合中的某些元素不相等则成立。 !=all(集合)等价于 not in。不等于集合中所有元素即不存在于当前集合中。 some(集合)和 any (集合) 在 MySQL 中没有区别。兼顾英语水平高的程序员的理解，无需多做解释。 注意： all，any，some 比 in 和 not in 要强大，可以使用除了 =, != 之外的运算符，不过要复杂些，用得不多。 !=any(集合) 实际开发基本上不用而面试时却常考。 联合查询当需要查找同时符合多个条件的记录时，联合查询可以一步到位而不需要分几个步骤来执行，这样可以同时输出符合条件的 多条记录。 当获得数据的条件出现逻辑冲突或者很难在一个逻辑内表示，就可以拆分成多个逻辑，分别实现最后将结果合并到一 起。 将多条 select 语句的结构合并到一起，而多条 select 语句的语法并没有发生变化的操作，就是联合查询。 12(select c1, c2 from tb_name where c3=val1 order by c4 desc limit 3) union(select c1, c2 from tb_name where c3=val2 order by c5 asc limit 4) -- 为了可读性和可维护性 子查询推荐使用 `()` 包裹起来 注意: 由 union 联合起来的多个 select 语句检索到的字段数要一致，数据类型上也应该严格一致。虽然 MySQL 内部会做类型转换处理，但在数据类型差异比较大的时候不一定能转换成功。比如： 1select 1 + 'a'; -- 结果为 1 但是检索的具体的字段名却可以不同。此外，检索结果中的列名称由第一条 select 语句的列名而定。 如果 union 查询的结果存在重复的记录，那么默认会自动消除重复。使用 union all 代替 union，可以将包括重复记录的符合条件的记录全部输出。 使用 union 对所有结果进行统一排序的特点 子语句的 order by 只有在配合 limit 时才能生效，原因是 union 在做子语句时，会对没有 limit 的子句的 order by 优化。（忽略） 只需在最后一个 select 语句后面增加排序规则，因为 union 的特点就是将多个 select 语句处理后对用户显示出只有一条 select 语句的结果。举例： 12(select c1, c2 from tb_name where c3 = val1) union(select c1, c2 from tb_name where c3 = val2 order by c4 limit 5) 这里，第一个子查询不需要使用 order by，而第二个如果需要就必须配合 limit 才有效。因为由 union 连接的多条 select 语句可以看作一条 select 语句对待 连接查询如果将一个表设计的比较复杂，则违背数据库设计的三范式原则，所以如果一个业务逻辑需要使用多个实体的数据时（一个 实体一张表），尽量不要将多个实体的数据设计在一张表内，将一个比较复杂的表分割成多个简单的表，这样可以减少依赖。 但仅仅是分割而不连接则业务所要使用的数据是不完整的，所以需要将多张表的记录连接起来一起使用。使用连接查询，可以想象成数据库用一些特定的方式（即连接查询的实现方法）去维护了一张实际上并未存在的大表，这张大表就是由要连接的多张实体表组成的。 连接查询总体思路： 将所有的数据按照某种条件连接起来，再进行筛选处理。 连接查询有时候也被称为连结查询。根据连接条件的不同，可以分为： 内连接（Inner） 交叉连接： cross join，也称为或笛卡尔积连接。在 MySQL 中，cross join 和 inner join 相同，但在数据库的定义上，交叉连接就是笛卡儿积，是没有查询条件的 inner join。 内连接： inner join，MySQL 默认，等价于 join。真实存在的数据内部的连接。要求连接的多个数据都必须同时存在才能进行连接。 使用格式：select ... from left_tb inner join right_tb on 连接条件。 左表和右表的区分： 在 join 左边的就是左表，在 join 右边的就是右表，属于逻辑上的概念，谁左谁右并不影响。 省略连接条件的内连接： 内连接可以省略连接条件，这意味着左表的每一条记录都要与右表的每一条记录进行一次连接，假设左表有 M 条记录，右表有 N 条记录，则将有 M * N 个连接。这种情况下，通常使用 cross join 代替 inner join 来避免获得过多记录。 当需要找出所有的可能性的时候多使用这种查询方式。 有条件的内连接： 会在连接时过滤非法的连接。指明条件的关键词有 on, where, using。虽然它们的连接结果是一样的，但是逻辑含义不一样。它们的区别和使用场景是： 123456789101112on =&gt; 连接过程中对数据进行判断时使用的条件，在通用条件下使用。where =&gt; 交叉连接成功后在新表数据中的过滤条件，在数据过滤时使用。using =&gt; 负责连接的两个实体之间的字段名一致。是一个快捷语法，需要在同名字段的环境下使用。使用格式是：using (两个实体表的同名字段)。using 会去掉重复字段并将 using()括号中的字段放在列前。 -- 举例说明select id, name, days from teachers inner join teachers using(id);-- 说明这里虽然可以通过 id 字段查询到记录，但是记录是不准确的。最好不要用 id 作为两张实体表的同名字段，也不能写成类似 `using(a_id=b_id)`，因为 using() 里面只能是一个字段。而不是表达式 逗号：, 可以不使用 where，而直接使用多表查询，来实现笛卡儿积，比如： 12345select tb_a.c1, tb_a.c2, tb_b.c3from tb_a, tb_b;-- 结果c1 | c2 | c3... | ... | ... 此时的查询结果仍然相当于一张表查出来的。 内连接的查询条件和外连接通用，不过外连接不使用 where 作为连接条件。 外连接（Outer） 如果负责连接的一个或多个数据不真实存在，比如表 1 外连接表 2 时，当表 1 中的某条记录在表 2 中没有与之匹配的记录时，则称之为外连接。 此时，虽然表 2 没有与之配对的记录，但表 1 中的那条记录是确实是存在的，这时就只能用外连接。 使用格式举例： 12345-- select ... from table1left left outer join table1right on 连接条件-- egselect teachers.name, class.begin, class.daysfrom teachers left outer join class on teachers.id=class.t_id; outer 关键字可以省略，因为内连接没有左右之分。 此外，左右连接本质都是一样的，看站在什么角度去理解。左表、右表之分是与 join 的位置关系有关的，跟 left 、right 无关。 左外连接：left join 在连接时，如果出现左边表数据连接不到右边表的情况，则左边表的数据在最终结果中被保留，右边表内数据用虚拟记录代替（NULL）。 左连接是开发中使用最多的连接方式，因为任何一个数据都不能保证在连接之内都能找到对应的数据配对。 右外连接：right join 在连接时，如果出现右边表数据连接不到左边表的情况，则右边表的数据将被保留。 全外连接：full join，MySQL 暂不支持，实质是左连接结果 union 右连接结果，比如可以模拟实现全连接： 12(select * from a left join b on a.id = b.aid) union(select * from a right join b on a.id = b.aid); 自然连接：Natural 既包含自然内连接又包含自然外连接。通过 MySQL 自己的判断完成连接过程，而无须指定连接条件，MySQL 会自动使用 几张表中相同的字段作为连接条件。使用格式为：select * from a natural right join b。 被自然连接选中的同名字段在输出的结果中靠前，同时，使用什么自然连接（左／右），就先将什么表的字段先显示。 自然连接也分为自然内连接和自然外连接，同时自然外连接又分为自然左外连接和自然右外连接。默认为自然内连接（不需要 inner 修饰）。 自然连接查询和使用 using 条件查询结果一致，即以下一些语句是等价的： 12345678select * from one natural join two;-- 等价于select * from one inner join two using(public_field);select * from one natural left/right join two;-- 等价于select * from one left/right join two using(public_field); 连接条件 on：连接条件。 using：使用同名字段快速连接 where：筛选条件，注意：不能使用没有条件的外连接 内连接和外连接的区别 内连接只保留了连接上了的记录，外连接保存了连接上了的和没有连接上的记录;如果保存的是左表的记录则就是 左外连接，如果保存的是右表的记录就是右外连接。 连接查询的步骤 所有连接的过程都是相同的，也类似与多重循环： 1234567-- 1. 连接左表第 1 条记录和右表的第 1 条记录-- 2. 判断条件(on)，符合则将连接结果保留，否则不保留-- 3. 继续连接，左表第 1 条记录依次和右表第 2, 3, ... 条记录，然后判断-- 4. 当左表第 1 条记录与右表所有记录连接完毕后，开始重新连接左表第 2 条记录与右表第 1, 2, 3, ... 条记录，以此类推 join 和 union 的区别union 是记录之间的组合，join 是字段之间的组合。 将检索结果导出到文件12select * into outfile '/path/to/file'from tb_name select into outfile 不能创建文件夹但能，也只能创建新文件。 此外，如果创建的文件名称和指定路径中的文件夹/文件名称 相同则不会创建成功，这样可以保护现有文件不被重写。 into outfile 适用于 select 所有查询语句。 生成文件格式默认采用行来区分记录，制表符来区分字段。但为了满足某种特殊的需求，会采用不同的分割方式，如 cvs。 MySQL 支持在导出数据时候设置记录与字段的分割符： fields =&gt; 设置字段选项 lines =&gt; 设置行选项 enclosed =&gt; 设置字段分隔符 escaped =&gt; 设置字段包裹符 terminated =&gt; 设置字段终止符，后接 by ‘xx’ 即可 starting =&gt; 设置行开头，后接 by ‘xx’ 即可 12345select * into outfile '/path/to/file'fields terminated by ','lines terminated by '\\n'starting by 'start:'from tb_name where conditions; 导出二进制数据 1select into dumpfile ... 此时将会把数据库内的数据以二进制形式保存到服务器文件。 导出的文件中只有一个文件结束符 EOF 而没有其他的格式，普通文件还是能被解码识别，只是没有格式可读性很不好，本身为二进制文件的 文件就会以”乱码”形式表现出来。 不过，这种情况不常用，因为数据库大都不直接保存二进制文件而是保持二进制文件的保存路径即可。 视图为什么需要视图出于权限安全和隐私的保护需要。有时候保存在某张表内的记录，不希望所有字段都能被所有人查看和操作，这时可以将原表中的一些允许被查看和修改的字段通过 select 选择出来后重新形成一张虚拟表，以替代对原表各种操作从而保护原表中不希望被查看的数据。 此外，视图还可用于替换复杂的 select 语句，如很长的连接查询语句，从而隐藏复杂的业务逻辑，通过视图完成的逻辑通常都是很简单的逻辑。 什么是视图对视图（本身是张虚拟表）主要进行的操作是查询，不主要用于更新和删除，因为对视图的操作最终会影响到原表，而原表那些被隐藏起来的字段通过操作视图是不能够更改的，所以就算是更新和删除了视图，原表中的数据也是不完整的。 视图主要提供给外部人员查看的，而非更改的，相当于提供了一个外部接口。视图本身不保存数据，只是通过 select 语句查询相关数据，视图本质只保存了一条 SQL 语句而已，利用视图对原表进行查询。每对视图进行一次操作 都会执行保存的那句 SQL 语句。 如何使用视图1create view view_name as select statement; 创建视图后就相当于在数据库中形成了一张虚拟表。 如果需要外部接口，一个数据库里面有多个应用，则针对每一个应用采取不同的视图接口。 视图管理12345678-- 删除视图drop view if exists view_name;-- 修改视图alter view view_name as select statement;-- 修改视图结构alter view view_name(new_field_1, new_field_2, ...) as select statement; -- 修改视图内所使用的字段的名称 说明 对视图的修改即是对原表进行修改，即时生效。删除视图时，不会影响原表。 视图的执行过程和执行算法视图的执行算法指一个视图在什么时候执行，依据哪些方式执行。 通常有 3 种执行算法。 undefined当创建视图时， MySQL 默认会使用一种 undefined 的处理算法，即 MySQL 会自动在合并和临时表中进行选择。 merge合并的执行方式，每当执行的时候，先将视图的 SQL 语句与外部查询视图的 SQL 语句混合在一起，最终执行。 temptable临时表模式，每当查询的时候，将视图所使用的 select 语句生成一个结果的临时表（(select … as temp），再在当前的临时表内进行查询。 事务为什么需要事务和什么是事务有时候，业务需要多条 SQL 语句的同时执行成功才能算完成。一组具有相同业务逻辑的 SQL 语句单元，组内所有 SQL 语句完成一个业务。如果整组成功，代表全部 SQL 都实现了，则业务成功；如果其中任何一个 SQL 语句执行失败， 则意味着整个操作都失败，数据库将回到操作之间的状态，则业务失败。 以上特性就是事务。事务没有成功之前，别的用户（进程，会话）是不能看到操作内的数据修改的。 SQL 执行的阶段 1、执行阶段 2、将执行结果提交到数据库 其中事务日志就是用于保存执行阶段的结果。默认的提交方式是自动提交。 MySQL 如何处理事务利用 Innodb 存储引擎的事务日志功能。事务机制只在 innodb 和 bdb 存储引擎下有效。 在一组操作之间设置一个记号（备份点），如果失败至少一个则从备份点处还原，如果都成功则提交。 事务处理的具体操作步骤为： 关闭自动提交功能 通过设置系统变量 autocommit 来配置自动提交选项： 12set autocommit=0;show variables like 'autocommit'; 执行完所有 SQL 语句 如此设置后，如果再次执行更新语句，当前会话的修改会暂时生效，但其他会话查看数据库时还是没有任何改变，因为结果没有被提交。 判断是否都成功 如果成功则将结果提交（commit）。 如果失败，如出现语法错误，逻辑错误，服务器错误等，则回到开始位置（rollback）。 上述操作不是很方便，因为要使用事务逻辑的情况不是最多。所以最常见的事务指令为：start transaction/begin（不推荐使用 begin 因为它在 SQL 语法中有特殊的含义）。 使用该指令，如果事务结束了（无论业务成功与否），会根据处理结果自动提交或者是回到 start 之前的状态。 事务结束之前使用 commit 或 rollback 选择事务的处理结果。 事务的特点原子性／AAtomicity。不可再分，虽然在语法上可以将事务分成多个 SQL 语句，但在功能上不可以分割。 一致性／CConsistency。事务开始之后和结束之前只受一个会话影响，事务操作的数据在事务结束之前会被锁定，其间其他会话不能修改。 隔离性／IIsolation。多个事务之间不会相互影响。隔离级别／严重程度。 持久性／DDurability。事务一旦提交会对数据产生永久影响。 锁的概念对事务进行操作的时候会将整个表都上锁，所以其他会话不能操作处于事务之中的数据。 触发器什么是触发器 ? 类似于 Javascript 中的监听事件（事件驱动编程），在 MySQL 中，可以监听数据进行操作。 在当前表上，设置一个对每行数据的一个监听器，监听相关事件，每当事件发生时，会执行一段 SQL 功能代码。 触发器相当于一个程序。触发，特定时间的发生即触发。 事件有：insert/delete/update。 数据，就是触发该事件的记录。 事件的时机：执行前和执行后。由时机和事件一起形成了 6 种事件： 123456before insertbefore deletebefore updateafter insertafter deleteafter update 监听位置有：for each row。 创建触发器格式为：create trigger 触发器名 事件 执行性代码 事件可以规定为：在哪个表的什么时机上的什么动作。可执行性代码即 SQL 语句。比如： 123create trigger trigger_nameafter updateon tb1 for each row update tb2 set field=value|statement; 管理触发器12345-- 删除触发器drop trigger trigger_name-- 查看触发器show create trigger trigger_name 获得触发器内的数据在MySQL中用 old 和 new表示执行前和执行后的数据。 old： 监听事件所在表上的数据，在事件发生之前的数据，旧的数据。 new： 监听表上，时间发生之后新处理完毕的数据。 注意事项 触发器不能同名。 目前 MySQL 只支持一类事件设置一个触发器。 insert 事件不能使用 old，delete 事件不能使用 new。 如果一个触发程序由多条 SQL 语句组成，应该将多条 SQL 语句用 begin 和 end 包裹起来。 由于触发器中的 SQL 语句也是用分号 ; 作为语句结束符，这和命令行中采取的 ; 作为语句结束符就相矛盾了，就会导致 MySQL 客户端在执行创建触发器的相关 SQL 语句时会以触发器中 SQL 语句的 ; 作为结束符，而不是整个创建触发器的语句结束符。 所以需要使用 delimiter 设置其他符号（通常为 $$ 符号）作为创建触发器时命令行中的语句结束符，创建触发器完成后恢复原来的结束符。举例说明： 1234567891011drop trigger trigger_name;delimiter $$create trigger trigger_nameafter insert on table_namefor each rowbeginupdate tb_1 set field1=value1/expression;update tb_2 set field2=value2/expression;end$$delimiter ; 数据管理备份mysiam 表可以直接将 table_name.frm，table_name.myd，table_name. myi 三个文件拷贝一份出来。 需要的时候，直接移动到相应的数据库目录内即可。注意，此方法如果去处理 innodb 表结构的文件，则只能用 show tables 看到表，但不能使用，因为数据和索引并没有被复制过来而只有数据的结构。 innodb 表 通用备份方案将建表结构与插入数据的 SQL语句生成并保存即可。还原只需重新执行 SQL 语句即可。 使用 MySQL 工具集即 mysqldump，其备份的其实也是 SQL 语句。 它不是 SQL 语法的一部分所以不需要再 MySQL 客户端执行，可以直接单独执行。 配置好环境变量后可以在命令行下直接执行： 12345# 备份整个数据库内的表mysqldump -u root -p db_name &gt; /path/to/save_file# 备份多张表mysqldump -u root -p db_name table1 table2 table3 ... &gt; /path/to/save_file 还原重新执行备份好的 SQL 语句。 可以在 MySQL 客户端直接执行，也可以一次性将一个文件里面的 SQL 语句全部执行，使用命令为：source 备份文件路径。 不过事先要创建一个新数据库作为备份还原的目标，否则会提示 ‘no database selected’。 导出和备份的差别导出的是数据，而备份的不仅是数据还有结构。 误操作恢复 1、数据无价。 2、请使用 where，你要知道你在干嘛。 常见的数据库误操作情况有，没带条件地更新／修改了某张表所有记录的一个字段。比如，批量更新了一张表的所有图片路径；或者，删除了不该删除的记录。 这时候不急是假的，因为用数据是无价的，但是紧急之下，先让自己冷静，参考下面几种 MySQL 提供的可恢复手段。 mysqlbinlog 同大多数关系型数据库一样，日志文件是 MySQL 数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位 mysqld 内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。 MySQL binlog 日志记录了 MySQL 数据库从启用日志以来所有对当前数据库的变更。binlog 日志属于二进制文件，我们可以从 binlog 提取出来生成可阅读的 SQL 语句来重建当前数据库以及根据需要实现时点恢复或不完全恢复。 mysqlbinlog 基本的命令参数包括起止时间，举例如下： 1mysqlbinlog --no-defaults --start-datetime='2016-12-14 09:00:00' --stop-datetime='2016-12-15 17:00:00' ~/mysql-bin.000027 &gt; ~/mysql_restore.sql 然后从生成的 mysql_restore.sql 搜索你刚才误操作的 sql 语句，然后提取出这之前的 sql 中包含你目标表的 sql 操作，删除误操作影响到的错误记录，然后重新执行这些 sql，达到恢复数据的目的 配置与排错查看 mysql 加载配置的文件路径123456789mysql --help | grep my.cnf# eg: order of preferencemy.cnf,$MYSQL_TCP_PORT,/etc/my.cnf/etc/mysql/my.cnf/usr/local/mysql/etc/my.cnf~/.my.cnf MySQL 关键字是否12where &lt;field&gt; is nullwhere &lt;field&gt; is not null PHP 操作 MySQL准备工作要操作 MySQL ，PHP 必须要充当为 MySQL 的客户端(客户端命令行窗口)，因为 MySQL 是 C/S 架构 的。PHP 是MySQL 扩展库函数来操作 MySQL的。在操作之前，有以下几点前提需要注意： MySQL 服务器已经开放接口／API 这是为了允许其他语言操作，在安装 MySQL 时已经设置好了，如果是分步安装的 MySQL，则需要安装服务端、客户端、和开发端（接口）。 在 Windows 上安装 MySQL 时，动态连接文件 libmysql.dll 就是其他程序（非 MySQL 自带客户端）可以操作 MySQL 必先找到的文件 ，如果只有 MySQL 客户端可以操作 MySQL 而其他语言却不能连接，则可以将 libmysql.dll 复制到 c:/windows 文件夹(一个公共位置)。 相应的客户端 客户端利用 MySQL 服务器开放的接口，完成编程，从而操作 MySQL 数据库。 对 PHP 而言，就是增加 一个模拟客户端的功能。 载入相应功能 即载入 PHP 的相关扩展。 通过设置 php.ini 文件，Windows 需取消 ;extention=php_mysqli.dll前的注释。同时还需要设置扩展文件所在的目录：extension_dir = &quot;c:/wamp/php/ext&quot;。 载入成功后使用 phpinfo() 函数可以看见 MySQL 的相关区域。或者测试 MySQL 扩展库中提供的函数是否有效来确认。比 如，var_dump( function_exists( &#39;mysqli_connect&#39; ) );，若返回 ture 则代表载入成功。 PHP 操作 MySQL 的几种方式无论是哪种方式，整个过程都分为 2 步：发出操作命令和接受执行结果。 mysql操作 MySQL 通用性最强的操作手段。不过在较新版本的 PHP 当中已经被弃用。 mysqli：mysql 的升级版本，智能操作 MySQL 数据库。 pdo 数据操作对象，提供了面向对象的操作方法，是数据库抽象层几乎可以操作所有流行的数据库软件 PHP 操作 MySQL 的流程 连接和认证：详见手册 选择数据库，设置编码 此步也可以不进行，因为编码的设置只是为了在客户端显示而不能改变数据保存的格式。单独选择数据库(use database_name)只是一种习惯性操作而不是必须操作。在选择表的同时也可以在其前面指定数据库。 执行 sql：详见手册 处理结果 处理成功的结果会有两种：布尔值和结果集。 布尔值可以直接使用，但是结果集就需要处理，通常都是用 fetch 方法从结果集中逐条提取纪录。最常见的处理方式如下： 12345678# fetch 函数内置结果集的纪录指针 可以在循环中移动while ($row = mysqli_fetch_assoc($res)) &#123; $rows[] = $row;&#125;# fetch_assoc =&gt; 返回值为下标为字段名（字符串）的关联数组# fetch_row =&gt; 返回值为下标为数值索引的的索引数组# fetch_array =&gt; 返回值为混合数组 关闭连接 释放结果集（如果有）：详见手册。 SQL编程SQL 也算是一个编程语言，既然是编程语言就可以用于编程。如 trigger 其实就是 SQL 编程的简单应 用之一。SQL 编程就是将多条 SQL 语句组合到一起完成相应的业务逻辑。 SQL 也有通用编程语言的基本元素。 函数分为内置函数和用户自定义函数。具体查询手册。 数值函数 rand() 123456-- 获得 0～1 之间的随机浮点数select rand();-- 获得 5 ～ 10 之间的随机数select 5+rand()*5;-- ... floor() 1select floor(rand()*5+5); -- 取整 时间和日期函数 now()： 获得当前时间。 unix_timestamp()： 获得时间戳，时间戳本身无意义但是可以将时间戳转换成有意义的时间格式 from_unixtime()： 从格林威治时间开始的秒数。如：select from_unixtime(unix_timestamp()); 会显示当前时间。 字符串函数 concat()： 字符串连接 length()： 统计字符串长度(单位是字节数) char_length()： 统 计字符数(字符数取决于编码方案) substring： 截取字符串。使用格式为：源字符串，开始位置，截取长度(字符数)) ，其中开始位置指的是如果为正数则为从左边数，如果为负数则表示从右边开始数。如：select substring(‘Hello world’, 2, 2); left 和 right： 分别代表从左边截取和从右边截取字符串。 lpad(‘将 被补足的字符串’, 补足后的长度, ‘补的字符串’)： 用字符串补足字符串，如：select lpad( ‘dddd’, 10, ‘**’ ) ; md5(‘要加密的字符串’) ： 对字符串进行 md5 加密。 password(‘要加密的字符串’) ： 加密字符串，相当于两次的 sh1() 加密 sh1(‘要加密的字符串’)： sh1 加密。 变量字段名，系统默认变量，如 variables。 用户自定义变量：set 变量名=变量值。为了区分系统变量 和自定义变量，需要则自定义变量之前加 @ 标志，否则会报错。自定义变量可以通过 select 语句查看：select @variable_name; 或者在表达式中使用。 使用 select into 定义变量：select field_list 表达式 into variable_list;。使用举例：select field_name from table_name where condition into @variable; 注意，select into @variable 要求只返回一行，如果返回多行，则会报语法错误，或者返回的是最后一行。 set 定义变量时可以将表达式赋给一个变量：set @variable = (select count(*) from table_name) ; 变量的作用域和有效期作用域： 用户定义的函数，是全局的（函数内可用），在函数内部定义的变量是局 部的 有效期： 一次会话期间（连接结束之前）都有效。以 @ 命名的变量相当于全局变量，函数内外都能使用。 变量的数据类型即字段的数据类型。 数据类型 =&gt; 表结构；数据 =&gt; 记录。 流程控制 分支 12345678delimiter $$create function fun() returns varchar(20) beginif hour( now() ) &gt;= 18 thenreturn 'Late.'; elsereturn 'Early.'; end if;end$$delimiter ; 循环 12345678910-- 1-10 的和 drop function if exists sum1 ; delimiter $$create function sum1() returns int beginset@i =1;set @sum = 0;while @i&lt;=10 doset @sum = @sum + @i;set @i = @i + 1; end while;return @sum; end$$ delimiter ; 循环的提前终止： SQL 语法中没有 break 但有 leave（跳出当前标签指定的循环）；没有 continue 有 iterate（跳出当前循环的本次循环）。举例说明： 123456789101112drop function if exists sum1 ; delimiter $$create function sum1() returns int beginset@i =0;set @sum = 0; sum:while @i&lt;10 doset @i = @i + 1; if @i = 5 thenleave sum; --iterate sum;end if;set @sum = @sum + @i; end while sum;return @sum;end$$delimiter ; 注意： leave 和 iterate 不像 break 和 continue ，不是根据它们所在的位置来决定终止哪个循环，而是由循环的标签来决定的（类似于 Javascript）。 循环的标签即给循环起的名字，即上面例子中的 sum。 其他流程控制 此外， SQL 语法中也有其他流程控制语法，如 switch，case 等。具体查阅手册。 运算符在 SQL 语法中，= 是关系运算符，即判断左右两端值是否相等而不是赋值运算符，赋值运算符是 := ，如 select ... @user := &#39;姓名&#39;。其他运算符同 PHP 。 注释行注释：# 和 -- 。块注释：/* ... */。 用户自定义函数也称存储函数，即存储在数据库里面的函数。 用户自定义函数是最能体现编程的情况，主要是使用 SQL 语法去定义一个函数的功能。自定义函数也包含：函数／参数列表／函数体／返回值。 1234567891011121314drop function if exists sayHello ;delimiter $$-- 创建函数create function sayHello( username varchar(20) ) returns varchar(20)begin-- 函数体return concat('Hello', username) ;end$$delimiter ;-- 调用自定义函数select sayHello(', caoxl') -- Hello, caoxl 注意： 用户自定义函数和数据库是绑定的，如果在调用自定义函数的时候没有指定具体的数据库，那么会报错找不到函数。 函数也可以用 db_name.func_name 调用。一个函数可以有多个参数，使用逗号分隔。 函数体内的变量名前没有 @ 的话，代表的是局部变量，但是局部变量有专门的声明方式：declare variable;。 比如：declare i int default 0; 练习 判断变量是否为 null 12if var is null then ...if isnull(var) then ... 模拟测试数据 12345678910drop function if exists v_name;delimiter $$create function v_name() returns char(2) begindeclare first_name char(16) default '赵钱孙李周吴郑王冯陈蒋李敏韩沈';declare last_name char(10) default '甲乙丙丁戊己庚辛壬癸';declare full_name char(2);set full_name = concat( substring(first_name, floor(rand()*16+1), 1 ), substring( last_name, floor(rand()*10+1),1 )) ;return full_name; end$$delimiter ; FAQmysql 5.7+ timestamp 零值报错？12345vim /etc/my.cnf # 配置文件路径因环境不同而不同# 找到 `[mysqld]` 一定要在这个字段内配置才能读取到[mysqld]sql_mode=NO_ENGINE_SUBSTITUTIONservice mysqld restart 为什么 MySQL 的字符集设置不能写成 utf-8 ?因为在 MySQL 里面 - 有特殊含义，表示的是字符集下面的校对集。 其他表前缀有时候几个项目需要使用同一个数据库，表前缀用于在同一个数据库中查询逻辑表名相同的表。如 info_student，exam_student。 前缀后缀只是逻辑上的存在，MySQL 统一认为都是标识符。 特殊符号的含义 %：MySQL 通配符，表示任何字符的任意组合 *：表示所有字段 +0 ：表示将检索结果用整数形式输出 123select column_name+0 from tb_name;-- raw `column_name`: 2016-10-07 17:18:00-- res: 20161007171800 \\G ： 当数据量比较多，结构比较混乱的时候，语句末尾用 \\G 代替 ; 可以使输出更易 \\g： 原样输出，同 ; \\c ： 取消操作，避免执行 SQL 时 MySQL 报错 \\q： 退出 MySQL 客户端 表的别名和列的别名有时候表名过长会无谓地增加 SQL 语句的长度。使用别名可以减少 SQL 语句的总长度，这样，无论从功能上还是从代码的 可读性上看上去都更加友好。所以如果表名过长，则需要一个简洁、清晰的别名。 列别名即字段的别名。往往多张实体表中的字段名都相同，如 id，这就有可能会造成理解上的困难 – 到底是谁的 id ?为了 解决这个情况，增强代码的可读性，就需要给列起别名。 表的别名和列的别名起名方式一样的，用 as 关键字就可以了：table_name as t_n，field_name as t_n.f_n。 标志符之间的 .没必要都写上。看字段是否有冲突。如果有冲突的话则用点进一步指明字段的上级表，还冲突的话就继续用点指明上级数 据库名。如果不冲突就只写字段就够了。database.table.field MySQL 函数 sum(field)：求字段内值的和 group by(filed)：按 field 组排序 max(field)：获得 field 字段内最大值 经验 学习程序设计，基本概念／基本思想是重点，语法是次要的。 参考 MyISAM versus InnoDB MySQL 二进制日志(Binary Log)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.caoxl.com/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.caoxl.com/tags/MySQL/"},{"name":"Database","slug":"Database","permalink":"http://blog.caoxl.com/tags/Database/"}]},{"title":"PHP 基础知识","slug":"PHP-Basic-Knowledge","date":"2017-12-31T08:03:55.000Z","updated":"2019-02-21T03:51:39.000Z","comments":true,"path":"2017/12/31/PHP-Basic-Knowledge/","link":"","permalink":"http://blog.caoxl.com/2017/12/31/PHP-Basic-Knowledge/","excerpt":"记录一些PHP基础知识","text":"记录一些PHP基础知识 语法流程控制break后面不跟数字，即默认情况，表示结束「本层」循环，跟数字则表示结束最近几「层」循环。 若其后所跟数字大于当前循环次数时，会出现：fatal error。 除了跳出循环，break 还可以跳出 swtich（条件判断）。 continue后面不跟数字，即默认情况，表示结束「本次」循环，跟数字则表示结束最近几「次」循环。 goto快速跳出多重循环和多重分支。 只能在同一个文件和作用域中跳转，也就是说，goto 无法跳出本函数或者方法，也无法跳入另一个函数。 goto 只能在 php &gt; 5.3 种使用。 变量全局变量在整个作用域（整个 PHP 文件中）都是可见的。 引号中的变量为确保双引号中的变量被正确解析，可以用大括号 {} 包裹起来，比如：”{$v}”。 超全局变量也叫「预定义超全局数组」。 通过预定义超全局数组，我们可以获取程序中需要的各种数据和环境相关的参数值 。 超全局变量除了具有全局变量的特点外，还具有不需要声明和定义（声明也不会报错但无意义），可直接访问的特点。 意味着在一个脚本的全部作用域都可用，本质是 PHP 引擎为了方便、快捷编程，而事先封装好的数据。 PHP 默认有以下 9 种预定义超全局数组： $_GET存储通过 URL 参数传递给当前脚本的数组变量。有 3 种使用方式： 超链接 表单 header() 跳转中带参数提交：header(&#39;Location: query.php?param=val&#39;); 关于 register_globals 引起的 SQL 注入这个特性（缺陷）在 php &gt;= 5.4 后已经被移除了，在低于 5.4 的 php.ini 文件中，确保其值为 off。 其原本带来的隐患是，从 $_GET/$_POST/$_REQUEST 中接收到的参数，到接受的 PHP 脚本后，可以自动通过和参数同名的变量访问，并且能覆盖 PHP 文件中没有声明过的变量。比如 $_GET[&#39;foo&#39;] 可以通过 $foo 来访问其值。 $_POST上传文件必须使用 POST 方式。和 GET 方式相比，优点是更安全和传输的数据大小不受 HTTP 限制（都会受浏览器限制）。 但是，收藏书签时，GET 比 POST 更方便。 $_REQUEST包含了 $_GET/$_POST/$_COOKIE。常用于不清楚提交方式时接受参数。 不过因为包含了三种方式，可能会受到三种方式缺点的攻击，所以并不可信。 判断是 GET 还是 POST，可以通过 $_SERVER[&#39;REQUEST_METHOD&#39;] 来获得。 $_SERVER主要包含客户端发来的 HTTP 请求行和消息头的信息，同时还有服务器自己的信息，比如 Document Root 和 Query String 等。 $_ENV该全局数组可以获取服务器环境变量，在 PHP5.3 中默认禁用，但是可以手动启动： php.ini =&gt; variables_order = &#39;EGPCS&#39; 。 生产环境，最好不要启用。 $GLOBALS注意这个变量名没有下划线 _。 它是一个包含了全部全局变量的全局组合数组，全局变量的名字就是该数组的键。 同时一个自定义的全局变量, 也会自动地被 $GLOBALS 管理。 $_FILE文件上传数组，包含了上传文件的所需数据。 $_COOKIE关于「会话」 打开浏览器访问一个网站的很多页面后，只有当关闭浏览器的时候，和该网站的一次会话才算结束 cookie 属于客户端（浏览器）技术，是服务器／网站保存在浏览器上的信息，供服务器在需要的时候使用。 其特点是：以 ***.txt 保存，不能保存太多的信息（顾名思义：小甜饼）。 cookie 基本使用：1234567891011# 创建/更新 cookiesetcookie($key1, $val1, $expire1); // $expire 是过期的具体时间点对应的时间戳setcookie($key2, $val2, $expire2);// ...# 获得 cookie$cookie = $_COOKIE['key'];# 删除 cookiesetcookie($key, null, time()-1024); // 清除某条 cookie$_COOKIE = []; // 清除所有 cookie 如果不指定失效时间，则 cookie 不会保存到本地客户端，当浏览器的会话结束这个 cookie 就会失效。 一般来说，cookie 不用于保存重要信息。 cookie 保存中文时候，默认会将中文进行 urlencode 编码。 浏览器在访问网站的时候会把 cookie 信息发送给网站的服务器（如果有的话）。 cookie 能保存的只能是字符串，不能是对象。 和 cookie 一样，也是属于会话技术，只是 session 文件（也可以存到缓存或数据库）通常保存在服务器。一般情况，一个 会话就对应一个 session 文件。 服务器在运行时可以为每个用户创建一个 session 文件，当用户再去访问同一台服务器中的其他 web 资源时，可以取出各自的 session 数据为每个用户提供不同的服务。 session 保存格式举例：key | s : size。其中，key 是键值；s 是数据类型，可以为 double ,integer, bool, array, object；size 代表元素的个数或者数据的字节单位大小。 session 在很大程度上弥补了 cookie 的带宽和安全性问题，而两者基本上都是一起配合使用的。 session 基本使用：123456789101112131415161718192021# 初始化 sessionsession_start(); // 只要是需要使用 session 都需要先初始化// 也可以不用每次都初始化 php.ini =&gt; session.auto_start = 1;// 不推荐因为影响效率, 因为不是每个网站都需要 session# 新增 session 纪录$_SESSION[$key] = $val;# 获取 sessionprint_r($_SESSION); // 打印所有 session$val = $_SESSION[$key]; // 获得 session 中 key 为 $key 的值echo $val; // $val 为基本数据类型print_r($val[$index]); // $val 为数组print_r($val-&gt;getName()); // $val 为对象# 更新 session// 思路同 cookie 重置即可# 删除 sessionunset($_SESSION[$key]); // 删除 session 中 key 值为 $key 的纪录session_destroy(); // 删除当前浏览器对应的 session 文件 默认存活时间 24 min，使用了 session 文件则存活时间重新计时 ，可以修改配置：php.ini =&gt; session:gc_maxlifetime = 1440。（也称发呆时间，不同 PHP 版本中这个配置有可能不一样） session 使用有关问题： 服务器是如何实现一个 session 为一次会话服务的？通过客户端传来的 sessid，可以从 cookie 中获得 sessid，也可以从 URL 参数中获得。 用户禁用 cookie 之后, 服务器每次 session_start() 都会创建一个全新的 session 文件，就无法让多个 PHP 去共享一份 session 文件，此时如何使用 session？可以在多个 PHP 文件之间传递 session id，然后通过 session id 来读取共享数据。 123456789101112# 1. 通过超链接／GET 请求if (isset($_GET['PHPSESSID'])) session_id($_GET['PHPSESSID']); // 设置当前的 session idsession_start();// session_id(); // 查看当前的 session id# 使用指定 session id 的 sessionprint_r($_SESSION['key']);# 2. 通过常量 SID// 将 \".SID.\" 插入到超链接中// php.ini =&gt; session.use_trans_sid(透明 SID 支持) 置1, 重启 Apache/FPM 自定义 session 处理器通过 session_set_save_handler 来实现。需要更改配置文件：session.save_handler = files 改为 session.save_handler = user。 session 可以存放的位置文件，数据库，内存，网络文件系统（nfs，也就是另一台服务器）。 关于 session 的垃圾回收机制 1234以下三个文件的配置共同决定了session的垃圾回收机制(gc)session.gc_maxlifetime = 1440 // 发呆时间session.gc_probability = 1 // gc 触发概率分子session.gc_divisor = 1000 // gc 触发概率分母 说明：网站规模越大，session.gc_probability / session.gc_divisor 值应该越小，可以减少服务器压力。 1234session.use_cookie = 1; // 是否启用 cookiesession.cookie_path =/ // cookie 有效的路径session.domain_name = // 根据规范产生域名, 自动生成, 无需设置session.cookie_lifetime = 0 // cookie 保存时间, 默认 0, 表示关闭浏览器就失效 数组数组就是连续存储数据的数据结构。 PHP 有两种数组：索引数组和关联数组，索引和关联两个词都是针对数组的键而言的。 索引数组索引数组是指数组的键是整数的数组，并且键的整数顺序是从0开始，依次类推。 索引数组赋值有三种方式 第一种：用数组变量的名字后面跟一个中括号的方式赋值，当然，索引数组中，中括号内的键一定是整 数。比如，$arr[0]=&#39;苹果&#39;; 第二种：用 array() 创建一个空数组，使用 =&gt; 符号来分隔键和值，左侧表示键，右侧表示值。当然，索引数组中，键一定是整数。比如，array(&#39;0&#39;=&gt;&#39;苹果&#39;); 第三种：用 array() 创建一个空数组，直接在数组里用英文的单引号 ‘ 或者英文的双引号 “ 赋值，数组会默认建立从0开始的整数的键。比如 array(&#39;苹果&#39;); 这个数组相当于 array(&#39;0&#39;=&gt;&#39;苹果&#39;); 访问索引数组内容用数组变量的名字后跟的中括号中的键，来访问数组中的值。例如： 123$fruit = array('苹果','香蕉');$fruit0 = $fruit['0'];print_r($fruit0); // 结果为苹果 关联数组关联数组是指数组的键是字符串的数组。 12345$fruit = array( 'apple' =&gt; \"苹果\", 'banana' =&gt; \"香蕉\", 'pineapple' =&gt; \"菠萝\"); 关联数组赋值关联数组赋值有两种方式: 第一种：用数组变量的名字后面跟一个中括号的方式赋值，当然，关联数组中，中括号内的键一定是字符串。比如，$arr[&#39;apple&#39;]=&#39;苹果&#39;; 第二种：用 array() 创建一个空数组，使用 =&gt; 符号来分隔键和值，左侧表示键，右侧表示值。当然，关联数组中，键一定是字符串。比如，array(&#39;apple&#39;=&gt;&#39;苹果&#39;); 访问关联数组内容用数组变量的名字后跟中 括号+键的 方式来访问数组中的值，键使用单引号或者双引号括起来 1234567$fruit = array( 'apple' =&gt; \"苹果\", 'banana' =&gt; \"香蕉\", 'pineapple' =&gt; \"菠萝\");$fruit0 = $fruit['banana'];print_r($fruit0); 当小数作为数组下标时会怎样？当小数作为下标时，自动截取整数部分作为下标。 数组越界问题当访问到越界元素时，PHP 会提示但不会报错，PHP中的数组可以动态增长的数组 。 语言结构require 和 include require节省资源、避免重复定义的错误 。 includeinclude 需要用到 php 文件时才引入，且出现错误会继续执行， 而 require 遇到错误会终止程序 require_once 和 include_once_once 表示如果被包含文件已经包含进去了则不再包含。 结论项目中最好使用 require_once，但是 php 页面中也不可能只用 require_once，因为有些页面内容确实需要调用多次。 错误和异常手动触发错误1trigger_error('错误提示', E_USER_WARNING); 抛出一个异常从PHP5开始，PHP 支持异常处理，异常处理是面向对象一个重要特性，PHP 代码中的异常通过 throw 抛出，异常抛出之后，后面的代码将不会再被执行。 既然抛出异常会中断程序执行，那么为什么还需要使用异常处理呢？ 异常抛出被用于在遇到未知错误，或者不符合预先设定的条件时，通知客户程序，以便进行其他相关处理，不至于使程序直接报错中断。当代码中使用了 try catch 的时候，抛出的异常会在 catch 中捕获，否则会直接中断。 1234567try&#123; // 可能出现错误或异常的代码&#125; catch (Exception $e) &#123; // 对异常处理 // 1、自己处理 // 2、不处理，将其再次抛出&#125; 使用异常的函数应该位于 try{} 代码块内。如果没有触发异常，则代码将照常继续执行，但是如果异常被触发，会抛出一个异常。 catch {} 代码块会捕获异常，并创建一个包含异常信息的对象。（Exception 是 php 已定义好的异常类） 另外，throw 规定如何触发异常。每一个 throw 必须对应至少一个 catch，当然可以对应多个。 1234567891011121314151617// 检测数字是否大于 1, 如果是, 则抛出一个异常。function checkNum($number)&#123; if ($number &gt; 1) &#123; throw new Exception('数字必须小于等于 1'); &#125; return true;&#125;// 在 try 代码块中触发异常try &#123; checkNum(2); // 如果异常被抛出，那么下面一行代码将不会被输出 echo '如果能看到这个提示，说明你的数字小于等于 1';&#125; catch(Exception $e)&#123; // 捕获异常 echo '捕获异常: ', $e-&gt;getMessage();&#125; 执行上面代码将获得类似这样一个错误: ‘捕获异常: 数字必须小于等于 1’。 其实上面的代码演示的就是如何抛出一个异常，并捕获它的过程： 在 try {} 代码块中调用 checkNum() 函数。执行 checkNum(2) 将触发异常并抛出一个 Exception 异常对象。由于 catch {} 代码块中事先已经准备好接收捕获该异常类对象，因此此时会创建一个包含该异常信息的对象 $e。 通过从这个 Exception 对象调用 $e-&gt;getMessage()，输出来自该异常的错误消息文本。 异常处理类PHP 具有很多异常处理类，其中 Exception 是所有异常处理的基类，具有几个基本属性与方法： message：异常消息内容 code：异常代码 file：抛出异常的文件名 line：抛出异常在该文件的行数 具有的常用方法有： getTrace：获取异常追踪信息 getTraceAsString：获取异常追踪信息的字符串 getMessage：获取出错信息 如果必要的话，可以通过继承 Exception 类来建立自定义的异常处理类。 1234567891011121314151617// 自定义的异常类，继承了 PHP 的异常基类 Exceptionclass MyException extends Exception&#123; public function getInfo() &#123; return '自定义错误信息'; &#125;&#125;try &#123; // 使用异常的函数应该位于 `try` 代码块内 // 如果没有触发异常，则代码将照常继续执行 // 但是如果异常被触发，会抛出一个异常 throw new MyException('error');&#125; catch(Exception $e) &#123; // `catch` 代码块内捕获异常，并创建一个包含异常信息的对象 echo $e-&gt;getInfo(); // 获取自定义的异常信息 echo $e-&gt;getMessage(); // 获取继承自基类的 getMessage 信息&#125; 捕获异常信息在了解了异常处理的基本原理之后，我们可以通过 try...catch... 来捕获异常，我们将执行的代码放在 try 代码块中，一旦其中的代码抛出异常，就能在 catch 中捕获。 这里我们只是通过案例来了解 try catch 的机制以及异常捕获的方法，在实际应用中，不会轻易的抛出异常，只有在极端情况或者非常重要的情况下，才会抛出异常。 抛出异常，可以保障程序的正确性与安全，避免导致不可预知的 bug。 一般的异常处理流程代码为： 1234567try &#123; throw new Exception('wrong');&#125; catch(Exception $e) &#123; echo 'Error:', $e-&gt;getMessage(), PHP_EOL; echo $e-&gt;getTraceAsString(), PHP_EOL;&#125;echo '异常处理后，继续执行其他代码'; 获取错误发生的所在行在异常被捕获之后，我们可以通过异常处理对象获取其中的异常信息，前面我们已经了解捕获方式，以及获取基本的错误信息。 在实际应用中，我们通常会获取足够多的异常信息，然后写入到错误日志中。 通过我们需要将报错的文件名、行号、错误信息、异常追踪信息等记录到日志中，以便调试与修复问题。 字符串字符串定义方式一个字符串通过下面的 3 种方法来定义： 单引号 双引号 heredoc语法结构 单引号和双引号区别PHP 允许我们在双引号串中直接包含字串变量，而单引号串中的内容总被认为是普通字符。 去除字符串首尾的空格PHP 中有 3 个函数可以去掉字符串的空格 trim：去除一个字符串两端空格。 rtrim：去除一个字符串右部空格，其中的 r 是 right 的缩写。 ltrim：去除一个字符串左部空格，其中的 l 是 left 的缩写。 123echo trim(\" 空格 \"), PHP_EOL;echo rtrim(\" 空格 \"), PHP_EOL;echo ltrim(\" 空格 \"), PHP_EOL; 获取字符串的长度strlen 函数对于计算英文字符是非常的擅长，但是如果有中文汉字，要计算长度该怎么办? 可以使用 mb_strlen() 函数获取字符串中中文长度。 12$str = '我爱你';echo mb_strlen($str, 'UTF8'); // 结果为 3 字符串的截取 英文字符串的截取函数 substr() 1234// 函数说明: substr(字符串变量, 开始截取的位置, 截取个数)$str = 'i love you';// 截取 love 这几个字母echo substr($str, 2, 4); 为什么开始位置是 2 呢？因为 substr 函数计算字符串位置是从 0 开始的。 中文字符串的截取函数 mb_substr() 1234// 函数说明: mb_substr(字符串变量, 开始截取的位置, 截取个数, 网页编码)$str='我爱你，中国';// 截取中国两个字echo mb_substr($str, 4, 2, 'utf8'); 查找字符串函数说明：strpos(要处理的字符串, 要定位的字符串, 定位的起始位置[可选]) 123$str = 'I want to study at home';$pos = strpos($str, 'home');echo $pos; // 结果显示19，表示从位置0开始，`home` 在第19个位置开始出现 替换字符串函数说明: str_replace(要查找的字符串, 要替换的字符串, 被搜索的字符串, 替换进行计数[可选]) 123$str = 'I want to learn js';$replace = str_replace('js', 'php', $str);echo $replace; // 结果: I want to learn php 格式化字符串函数说明: sprintf(格式, 要转化的字符串) 123$str = '99.9';$result = sprintf('%01.2f', $str);echo $result; // 结果显示 99.90 解释下，这个例子中的格式： % 是开始的意思，写在最前面表示指定格式开始了。也就是 “起始字符”，直到出现 “转换字符” 为止，就算格式终止。 跟在 % 符号后面的是 0， 是 “填空字元” ，表示如果位置空着就用 0 来填满。 在 0 后面的是 1，这个 1 是规定整个所有的字符串占位要有 1 位以上( 小数点也算一个占位 )。如果把 1 改成 6，则 $result 的值将为 099.90因为，在小数点后面必须是两位，99.90 一共 5 个占位，现在需要 6 个占位，所以用 0 来填满。 在 %01 后面的 .2 就很好理解了，它的意思是，小数点后的数字必须占2位。 如果这时候，$str 的值为 9.234,则 $result 的值将为 9.23.为什么 4 不见了呢? 因为在小数点后面，按照上面的规定，必须且仅能占 2 位。可是 $str 的值 中，小数点后面占了3位，所以，尾数 4 被去掉了，只剩下 23。 最后，以 f “转换字符” 结尾。 字符串的合并与分割 字符串合并：implode()1234// 函数说明: implode(分隔符[可选], 数组)$arr = array('Hello', 'World!');$result = implode(' ', $arr);print_r($result); // 结果显示: Hello World! 字符串分隔：explode()123// 函数说明: explode(分隔符[可选], 字符串)$str = 'apple,banana';$result = explode(',', $str); print_r($result);//结果显示array('apple','banana') 字符串的转义addslashes() 函数用于对特殊字符加上转义字符。12$str = \"what's your name?\";echo addslashes($str); // 输出: what\\'s your name? 函数返回值 使用 return 关键字可以使函数返回值，可以返回包括数组和对象的任意类型。 如果省略了 return，则默认返回值为 NULL。 函数不能返回多个值，但可以通过返回一个数组来得到类似的效果。1234function getNums() &#123; return [1, 2, 3];&#125;list($one, $two, $three) = getNums(); 可变函数所谓可变函数，即通过变量的值来调用函数，因为变量的值是可变的，所以可以通过改变一个变量的值来实现调用不同的函数。 可变函数经常会用在回调函数、函数列表，或者根据动态参数来调用不同的函数。可变函数的调用方法为变量名加括号。 12345function name () &#123; return 'caoxl';&#125;$fun = 'name';$fun(); // 调用可变函数 可变函数也可以用在对象的方法调用上： 12345678910class Book&#123; publich function getName() &#123; return 'Modern PHP'; &#125;&#125;$fun = 'getName';$book = new Book();$booo-&gt;$fun(); 内置函数内置函数指的是 PHP 默认支持的函数，PHP内置了很多标准的常用的处理函数，包括字符串处理、数组函数、文件处理、session 与 cookie 处理等。 我们先拿字符串处理函数来举例，通过内置函数 str_replace可以实现字符串的替换。 下面的例子将 “jobs” 替换成 “steven jobs”：123$str = 'i am jobs.';$str = str_replace('jobs', 'steven jobs', $str);echo $str; 另外，一些函数是通过其他扩展来支持的。比如：操作 mysql 数据库的函数是通过 mysqli 扩展来支持的。 会话控制CookieCookie 是存储在客户端浏览器中的数据，我们通过 Cookie 来跟踪与存储用户数据。一般情况下，Cookie 通过 HTTP headers 从服务端返回到客户端。多数 web 程序都支持 Cookie 的操作，因为 Cookie 是存在于 HTTP 的标头之中，所以必须在其他信息输出以前进行设置，类似于 header 函数的使用限制。 PHP 通过 setcookie() 函数进行 Cookie 的设置，任何从浏览器发回的 Cookie，PHP 都会自动的将他存储在 $_COOKIE 的全局变量之中，因此我们可以通过 $_COOKIE[&#39;key&#39;] 的形式来读取某个 Cookie 值。 PHP 中的 Cookie 具有非常广泛的使用，经常用来存储用户的登录信息， 购物车等，且在使用会话 Session 时通常使用 Cookie 来存储会话 id 来识别用户，Cookie 具备有效期，当有效期结束之后，Cookie 会自动的从 客户端删除。同时为了进行安全控制，Cookie 还可以设置域跟路径。 设置 CookiesetcookiePHP设置 Cookie 最常用的方法就是使用 setcookie 函数。setcookie 具有 7 个可选参数，我们常用到的为前5个： name： Cookie名，可以通过 $_COOKIE[‘name’] 进行访问。 value： Cookie的值。 expire： 过期时间，Unix 时间戳格式，默认为 0，表示浏览器关闭即失效。 path： 有效路径。如果路径设置为 /，则整个网站都有效。 domain： 有效域。默认整个域名都有效，如果设置了 `www.myapp.com’，则只在 www 子域中有效 1234$value = 'test';setcookie(\"TestCookie\", $value);setcookie(\"TestCookie\", $value, time()+3600); // 有效期一小时setcookie(\"TestCookie\", $value, time()+3600, \"/path/\", \"myapp.com\"); // 设置路径与域 setrawcookiePHP 中还有一个设置 Cookie 的函数 setrawcookie。 setrawcookie 跟 setcookie 基本一样，唯一的不同就是 value 值不会自动的进行 urlencode，因此在需要的时候要手动的进行 urlencode。 1setrawcookie('cookie_name', rawurlencode($value), time()+606024*365); 因为 Cookie 是通过 HTTP 标头进行设置的，所以也可以直接使用 header 方法进行设置。 1header('Set-Cookie:key=value'); cookie 的删除与过期时间在 PHP 中删除 cookie 也是采用 setcookie 函数来实现的，只需要设置下失效时间即可： 1setcookie('test', '', time()-1); 可以看到将 cookie 的过期时间设置到当前时间之前，则该 cookie 会自动失效，也就达到了删除 cookie 的目的。 之所以这么设计是因为 cookie 是通过 HTTP 的标头来传递的，客户端根据服务端返回的 Set-Cookie 段来进 行 cookie 的设置，如果删除 cookie 需要使用新的 Del-Cookie 来实现， 则 HTTP 头就会变得复杂，实际上仅通过 Set-Cookie 就可以简单明了的实现 Cookie 的设置、更新与删除。 因此，也可以直接通过 header 函数来删除 cookie。 1234567891011header( 'Set-Cookie: test=1393832059; expires='.gmdate( 'D, d M Y H:i:s \\G\\M\\T', time()-1 ) ); 这里用到了gmdate()，用来生成格林威治标准时间，以便排除时差的影响。 cookie 的有效路径cookie 中的路径用来控制设置的 cookie 在哪个路径下有效，默认为 ’/‘， 在所有路径下都有。 当设定了其他路径之后，则只在设定的路径以及子路径下有效，例如： 1setcookie('test', time(), 0, '/path'); 上面的设置会使 test 在 /path 以及子路径 /path/abc 下都有效，但是在根目录下就读取不到 test 的 cookie 值。 一般情况下，大多是使用所有路径的，只有在极少数有特殊需求的时 候，会设置路径，这种情况下只在指定的路径中才会传递 cookie 值，可以节省数据的传输，增强安全性以及提高性能。 当我们设置了有效路径的时候，不在当前路径的时候则看不到当前cookie。 123setcookie('test', '1',0, '/path');var_dump($_COOKIE['test']); SessionCookie 的局限cookie 将数据存储在客户端，建立起用户与服务器之间的联系，通常可以解决很多问题，但是 cookie 仍然具有一些局限： cookie 相对不是太安全，容易被盗用导致 cookie 欺骗 单个 cookie 的值最大只能存储 4k 每次请求都要进行网络传输，占用带宽 Session 的优点session 是将用户的会话数据存储在服务端，没有大小限制，只通过一个 session id 进行用户识别 Session 和 Cookie 的关系默认情况下 PHP 里的 session id 是通过 cookie 来保存的，因此从某种程度上来说，seesion 依赖于cookie。但这不是绝对的，session id 也可以通过参数来实现，只要能将 session id 传递到服务端进行识别的机制都可以使用 session。 使用 Session在 PHP 中使用 session 非常简单，先执行 session_start() 方法开启 session， 然后通过全局变量$_SESSION 进行 session 的读写。 12345session_start();$_SESSION['test'] = time();print_r($_SESSION); session 会自动的对要设置的值进行 encode 与 decode，因此 session 可以支持任意数据类型，包括数据与对象等。 1234567session_start();$_SESSION['ary'] = array('name' =&gt; 'jobs');$_SESSION['obj'] = new stdClass();print_r($_SESSION); 默认情况下，session 是以文件形式存储在服务器上的，因此当一个页面开启了 session 之后，会独占这个session 文件，这样会导致当前用户的其他并发访问无法执行而等待。 可以采用缓存或者数据库的形式存储来解决这个问题。 删除与销毁 Session删除某个 session 值可以使用 PHP 的 unset 函数，删除后就会从全局变量 $_SESSION 中去除，无法访问。 1234567session_start();$_SESSION['name'] = 'jobs';unset($_SESSION['name']);echo $SESSION['name']; // 提示name不存在 如果要删除所有的 session，可以使用 session_destroy 函数销毁当前 session。session_destroy 会删除所有数据，但是 session_id 仍然存在。123456session_start();$_SESSION['name'] = 'jobs';$_SESSION['time'] = time();session_destroy(); 值得注意的是，session_destroy并不会立即的销毁全局变量 $_SESSION 中的值，只有当下次再访问的时候，$_SESSION 才为空。因此如果需要立即销毁 $_SESSION，可以使用 unset 函数。 123456789session_start();$_SESSION['name'] = 'jobs';$_SESSION['time'] = time();unset($SESSION);session_destroy();var_dump($_SESSION); // 此时已为空 如果需要同时销毁 cookie 中的 session_id，比如在用户退出的时候可能会用到，则还需要显式的调用setcookie 方法删除 session_id 的 cookie 值。 使用 session 来存储登录用户session 可以用来存储多种类型的数据，因此具有很多的用途，常用来存储用户的登录信息，购物车数据，或者一些临时使用的暂存数据等。 用户在登录成功以后，通常可以将用户的信息存储在 session 中，一般的会单独的将一些重要的字段单独存储，然后所有的用户信息独立存储。 12$_SESSION['uid'] = $userinfo['uid'];$_SESSION['userinfo'] = $userinfo; 一般来说，登录信息既可以存储在 sessioin 中，也可以存储在 cookie 中， 他们之间的差别在于 session 可以方便的存取多种数据类型，而 cookie 只支持字符串类型，同时对于一些安全性比较高的数据，cookie 需要进行格式化与加密存储，而 session 存储在服务端则安全性较高。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpsession_start();// 假设用户登录成功获得了以下用户数据$userinfo = array( 'uid' =&gt; 1024, 'name' =&gt; 'cjli', 'email' =&gt; 'cjli@info.com', 'sex' =&gt; 'man', 'age' =&gt; '18');header('Content-Type:text/html; charset=utf-8');// 将用户信息保存到 session 中$_SESSION['uid'] = $userinfo['uid'];$_SESSION['name'] = $userinfo['name'];$_SESSION['userinfo'] = $userinfo;// 将用户数据保存到 cookie 中的一个简单方法$secure_key = 'secure_key'; // 加密密钥$str = serialize($userinfo); // 将用户信息序列化// 用户信息加密前$str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secure_key), $str, MCRYPT_MODE_ECB));// 用户信息加密后// 将加密后的用户数据存储到cookie中setcookie('userinfo', $str);// 当需要使用时进行解密$str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secure_key), base64_decode($str), MCRYPT_MODE_ECB);$uinfo = unserialize($str);echo '解密后的用户信息', PHP_EOL;print_r($uinfo); 日期时间取得当前的 Unix 时间戳UNIX 时间戳( timestamp )是 PHP 中关于时间与日期的一个很重要的概念，它表示从 1970年1月1日 00:00:00 到当前时间的秒数之和。PHP 提供了内置函数 time() 来取得服务器当前时间的时间戳。1echo time(); // 1396193923 这个数字表示从 1970年1月1日 00:00:00 到我输出这个脚本时经历了1396193923 秒。 取得当前的日期php内置了 date() 函数，来取得当前的日期。 1date(时间戳的格式, 规定时间戳[默认是当前的日期和时间，可选]) 返回值：日期和时间。比如： 12345// 第二个参数取默认值的情况echo date(\"Y-m-d\");// 第二个参数有值的情况echo date(\"Y-m-d\",'1396193923'); 将格式化的日期字符串转换为 Unix 时间戳strtotime 函数预期接受一个包含美国英语日期格式的字符串，并尝试将其解析为 Unix 时间戳。 1strtotime(要解析的时间字符串, 计算返回值的时间戳[默认是当前的时间，可选]) 返回值：成功则返回时间戳，否则返回 FALSE。 123456789echo strtotime(\"now\"); // 相当于将英文单词 now 直接等于现在的日期和时间，并把这个日期时间转化为 unix 时间戳; 这个效果跟 `echo time();` 一样echo strtotime(\"+1 seconds\"); // 相当于将现在的日期和时间加上了 1 秒，并把这个日期时间转化为unix 时间戳。这个效果跟 `echo time()+1;` 一样echo strtotime(\"+1 day\"); // 相当于将现在的日期和时间加上了 1 天echo strtotime(\"+1 week\"); // 相当于将现在的日期和时间加上了 1 周echo strtotime(\"+1 week 3 days 7 hours 5 seconds\"); // 相当于将现在的日期和时间加上了 1周3天7小时5秒 格式化格林威治(GMT)标准时间gmdate() 函数能格式化一个 GMT 的日期和时间，返回的是格林威治标准时(GMT)。举个例子，我们现在所在的中国时区是东八区，领先格林威治时间 8 个小时，有时候也叫 GMT+8，那么服务器运行以下脚本返回的时间应该是这样的: 12echo date('Y-m-d H:i:s', time()); // 当前时间假定是 2014-05-01 15:15:22echo gmdate('Y-m-d H:i:s', time()); // 输出 2014-05-01 07:15:22 因为格林威治时间，是现在中国时区的时间减去 8 个小时，所以相对于现在时间要少 8 个小时。 GD库GD 指的是 Graphic Device，PHP 的 GD 库是用来处理图形的扩展库，通过 GD 库提供的一系列 API，可以对图像进行处理或者直接生成新的图片。 PHP 除了能进行文本处理以外，通过 GD 库，可以对 JPG、PNG、GIF、SWF 等图片进行处理。 GD 库常用在图片加水印，验证码生成等方面。PHP 默认已经集成了 GD 库，只需要在安装的时候开启就行。 输出一张图片123456header('Content-Type: image/png');$img = imagecreatetruecolor(100, 100);$red = imagecolorallocate($img, 0xFF, 0x00, 0x00);imagefill($img, 0, 0, $red);imagepng($img);imagedestroy($img); 绘制线条要对图形进行操作，首先要新建一个画布。 通过 imagecreatetruecolor 函数可以创建一个真彩色的空白图片： 1$img = imagecreatetruecolor(100, 100); GD 库中对于画笔所用的颜色，需要通过 imagecolorallocate 函数进行分配，通过参数设定 RGB的颜色值来确定画笔的颜色： 1$red = imagecolorallocate($img, 0xFF, 0x00, 0x00); 然后我们通过调用绘制线段函数 imageline 进行线条的绘制，通过指定起点跟终点来最终得到线条： 1imageline($img, 0, 0, 100, 100, $red); 线条绘制好以后，通过 header 与 imagepng 进行图像的输出。 12header('Content-Type: image/png');imagepng($img); 最后可以调用 imagedestroy 释放该图片占用的内存。 1imagedestroy($img); 通过上面的步骤，可以发现 PHP 绘制图形非常的简单，但很多时候我们不只是需要输出图片，可能我们还需要得到一个图片文件，可以通过 imagepng 函数指定文件名将绘制后的图像保存到文件中： 1imagepng($img, 'img.png'); 在图像中绘制文字GD 库可以进行多种图形的基本操作，常用的有绘制线条，背景填充，画矩形，绘制文字等。 跟绘制线条类似，首先需要新建一个图片与初始化颜色。 123$img = imagecreatetruecolor(100, 100);$red = imagecolorallocate($img, 0xFF, 0x00, 0x00); 然后使用 imagestring 函数来进行文字的绘制，这个函数的参数很多： imagestring(resource $image, int $font, int $x, int $y, string $s, int $col) 可以通过 $font 来设置字体的大小，x, y 设置文字显示的位置，$s 是要绘制的文字，$col 是文字的颜色。 1234imagestring($img, 5, 0, 0, 'Hello world', $red);header('Content-Type: image/png');imagepng($img);imagedestroy($img); 输出图像文件前面我们已经了解到，通过 imagepng 可以直接输出图像到浏览器，但是很多时候，我们希望将处理好的图像保存到文件，以便可以多次使用。 通过指定路径参数将图像保存到文件中。 12$filename = 'img.png';imagepng($img, $filename); 使用不同的函数保存为不同的图片格式： imagepng 可以将图像保存成 png 格式 imagejpeg 将图片保存成 jpeg 格式 imagegif 将图片保存成 gif 格式 需要说明的是，imagejpeg 会对图片进行压缩，因此还可以设置一个质量参数。12$filename = 'img.jpg';imagejpeg($img, $filename, 80); 生成图像验证码简单的验证码其实就是在图片中输出了几个字符，通过 imagestring 函数就能实现。 但是在处理上，为了使验证码更加的安全，防止其他程序自动识别，因此常常需要对验证码进行一些干扰处理，通常会采用绘制一些噪点，干扰线段，对输出的字符进行倾斜、扭曲等操作。 可以使用 imagesetpixel 绘制点来实现噪点干扰，但是只绘制一个点的作用不大，因此这里常常会使用循环进行随机绘制。 1234for($i=0; $i&lt;50; $i++) &#123; imagesetpixel($im, rand(0, 100) , rand(0, 100) , $black); imagesetpixel($im, rand(0, 100) , rand(0, 100) , $green);&#125; 给图片添加水印给图片添加水印的方法一般有两种，一种是在图片上面加上一个字符串，另一种是在图片上加上一个 logo 或者其他的图片。 因为这里处理的是已经存在的图片，所以可以直接从已存在的图片建立画布，通过 imagecreatefromjpeg 可以直接从图片文件创建图像。 1$im = imagecreatefromjpeg($filename); 创建图像对象以后，我们就可以通过前面的 GD 函数，绘制字符串到图像上。 如果要加的水印是一个 logo 图片，那么就需要再建立一个图像对象，然后通过 GD 函数 imagecopy 将 logo 的图像复制到源图像中。 12$logo = imagecreatefrompng($filename);imagecopy($im, $logo, 15, 15, 0, 0, $width, $height); 当将 logo 图片复制到原图片上以后，将加水印后的图片输出保存就完成了加水印处理。 1imagejpeg($im, $filename); 文件上传／下载PHP 简化后的上传原理将客户端的文件上传到服务器端，然后将在服务器端的临时文件移动到指定文目录即可。 $_FILES$_FILES 保存了上传文件的原始信息。 name： 上传文件的名字 type： 上传文件的 MIME 类型 tmp_name： 上传到服务器后的临时文件名 size： 上传文件的大小 error： 上传文件的错误号 浏览器客户端设置 表单的 enctype 必须为：multipart/form-data。 表单 method 必须为 post。 如果 method 和 enctype 写错，则 $_FILES 为空。 php.ini 上传设置File Uploads file_uploads = On： 支持 HTTP 上传。 upload_tmp_dir=： 临时文件保存路径。 upload_max_filesize=2M： 允许上传文件的最大值。 max_file_uploads=20， 允许一次上传的最大文件数。 post_max_size = 8M： POST 提交数据的最大值。 Resource Limits max_execution_time = -1设置脚本被解析器终止之前允许的最大执行时间，单位为秒，防止烂代码写得不好而占用服务器资源。 max_input_time = 60脚本解析输入数据允许的最大时间，单位为秒。 max_input_nesting_level = 64设置输入变量的嵌套深度。 max_input_vars = 1000接受多少输入的变量，本限制将作用于 $_GET/$_POST/$_COOKIE。 该指令可以减轻以哈希碰撞来进行 DDOS 攻击的可能性。如果有超过该指令限制数量的变量，将会导致 E_WARNING 错误，更多的输入变量将会从请求中截断。 memory_limit = 128M最大单线程的独立内存使用量。也就是一个 web 请求，给予线程最大的内存使用量的定义。 错误信息说明 UPLOAD_ERR_OK/0：文件上传成功。 UPLOAD_ERR_INI_SIZE/1：上传文件超过 upload_max_filesize 选项的限制。 UPLOAD_ERR_FORM_SIZE/2：上传文件大小超过了 HTML 表单中 MAX_FILE_SIZE 选项的值。 UPLOAD_ERR_PARTIAL/3：部分文件被上传。 UPLOAD_ERR_NO_FILE/4：没有文件被上传。 UPLOAD_ERR_NO_TMP_DIR/6：找不到临时路径。 UPLOAD_ERR_CANT_WRITE/7：文件写入失败。 UPLOAD_ERR_EXTENSION/8：上传的文件被 PHP 扩展程序中断。 移动上传成功的文件通过 move_uploaded_file() ，该函数对安全模式和 open_basedir 都是敏感的。不过，限制只针对 destination 路径，因为允许移动上传的文件名 filename 可能会与这些限制产生冲 突。 move_uploaded_file() 仅作用于通过 PHP 上传的文件以确保这个操作的安全性。 提醒： 如果目标文件已经存在，将会被覆盖。 上传文件限制客户端限制12345678910111213141516&lt;!-- 通过表单隐藏域限制上传文件的最大值 --&gt;&lt;input type=\"hidden\" name=\"MAX_FILE_SIZE\" vlaue=\"字节数\"&gt;&lt;!-- 通过 accept 表单属性限制上传文件类型 --&gt;&lt;input type=\"file\" name=\"upload_key\" accept=\"文件的 MIME 类型\"&gt;&lt;!-- 通过 multiple 表单属性限制上传文件个数 --&gt;&lt;input type=\"file\" name=\"upload_key\" multiple=\"multiple\"&gt;&lt;!-- 通过 数组形式 表单名限制上传文件个数 --&gt;&lt;input type=\"file\" name=\"upload_keys[]\"&gt;&lt;!-- 通过多个 file 控件限制上传文件个数 --&gt;&lt;!-- 实质也是单文件上传, 此时 $_FILES 是一个二维数组 --&gt;&lt;input type=\"file\" name=\"upload_key1\"&gt;&lt;input type=\"file\" name=\"upload_key2\"&gt; 提醒： 客户端做的限制并不安全，因为可以在客户端任意更改代码。 服务器限制 限制上传文件的大小 限制上传文件的类型 检测是否问需要的文件类型 检测是否为 HTTP POST 方式上传 文件系统读取文件内容PHP 具有丰富的文件操作函数，最简单的读取文件的函数为 file_get_contents，可以将整个文件全部读取到一个字符串中。 1$content = file_get_contents('./test.txt'); file_get_contents 也可以通过参数控制读取内容的开始点以及长度。 1$content = file_get_contents('./test.txt', null, null, 100, 500); PHP 也提供类似于 C 语言操作文件的方法，使用 fopen，fgets，fread等方 法，fgets 可以从文件指针中读取一行，freads 可以读取指定长度的字符串。 1234567891011// 1.fgets$fp = fopen('./text.txt', 'rb');while(!feof($fp)) &#123; echo fgets($fp); // 读取一行&#125;fclose($fp);// 2.fread$fp = fopen('./text.txt', 'rb'); $contents = ''; while(!feof($fp)) &#123;$contents .= fread($fp, 4096); //一次读取4096个字符 &#125;fclose($fp); 使用 fopen 打开的文件，最好使用 fclose 关闭文件指针，以避免文件句柄被占用。 判断文件是否存在一般情况下在对文件进行操作的时候需要先判断文件是否存在，PHP 中常用来判断文件存在的函数有两个 is_file 与 file_exists。 1234$filename = './test.txt';if (file_exists($filename)) &#123; echo file_get_contents($filename);&#125; 如果只是判断文件存在，使用 file_exists 就行，file_exists 不仅可以判断文件是否存在，同时也可以判断目录是否存在。而从函数名可以看出，is_file 是确切的判断给定的路径是否是一个文件。 1234$filename = './test.txt';if (is_file($filename)) &#123; echo file_get_contents($filename);&#125; 更加精确的可以使用 is_readable 与 is_writeable 在文件是否存在的基础上，判断文件是否可读与可写。 1234567$filename = './test.txt';if (is_writeable($filename)) &#123; file_put_contents($filename, 'test');&#125;if (is_readable($filename)) &#123; echo file_get_contents($filename);&#125; 写入内容到文件与读取文件对应，PHP 写文件也具有两种方式，最简单的方式是采用 file_put_contents。 123$filename = './test.txt';$data = 'test';file_put_contents($filename, $data); 上例中，$data 参数可以是一个一维数组，当 $data 是数组的时候，会自动的将数组连接起来，相当于 $data=implode(&#39;&#39;, $data); 同样的，PHP 也支持类似 C 语言风格的操作方式，采用 fwrite 进行文件写入。 1234$fp = fopen('./test.txt', 'w');fwrite($fp, 'hello');fwrite($fp, 'world');fclose($fp); 取得文件的修改时间文件有很多元属性，包括：文件的所有者、创建时间、修改时间、最后的访问时间等。 fileowner： 获得文件的所有者 filectime： 获取文件的创建时间 filemtime： 获取文件的修改时间 fileatime： 获取文件的访问时间 其中最常用的是文件的修改时间，通过文件的修改时间，可以判断文件的时效性，经常用在静态文件或者缓存数据的更新。 12$mtime = filemtime($filename);echo '修改时间:'.date('Y-m-d H:i:s', filemtime($filename)); 取得文件的大小通过 filesize 函数可以取得文件的大小，文件大小是以字节数表示的。 12$filename = '/data/webroot/usercode/code/resource/test.txt';$size = filesize($filename); 如果要转换文件大小的单位，可以自己定义函数来实现。 123456789101112131415function getsize($size, $format = 'kb') &#123; $p = 0;if ($format == 'kb') &#123; $p = 1;&#125; elseif ($format == 'mb') &#123; $p = 2;&#125; elseif ($format == 'gb') &#123; $p = 3;&#125;$size /= pow(1024, $p);return number_format($size, 3);$filename = '/path/to/test.txt';$size = filesize($filename);$size = getsize($size, 'kb'); // 进行单位转换echo $size.'kb'; 值得注意的是，没法通过简单的函数来取得目录的大小，目录的大小是该目录下所有子目录以及文件大小的总和，因此需要通过递归的方法来循环计算目录的大小。 删除文件跟 Unix 系统命令类似，PHP 使用 unlink 函数进行文件删除。 删除文件夹使用 rmdir 函数，文件夹必须为空，如果不为空或者没有权限，则会提示失败。 如果文件夹中存在文件，可以先循环删除目录中的所有文件，然后再删除该目录，循环删除可以使用 glob() 函数遍历所有文件 12345unlink($filename);rmdir($dir);foreach (glob('*') as $filename) &#123; unlink($filename);&#125; 文件流 (IO)从磁盘到内存，是 I；从内存到磁盘，是 O。 OOPwhat ?把生活中问题的解决方案，都封装成对象的方式：属性+行为/方法，进行存储。 为什么软件设计强调高内聚低耦合? 高内聚：该有的都有 低耦合：代码复用性高。 总结：有利于多人开发大型项目。 3 大特性继承继承是面向对象程序设计中常用的一个特性，比如，汽车是一个比较大的类，我们也可以称之为基类，除此之外，汽车还分为卡车、轿车、东风、宝马等，因为这些子类具有很多相同的属性和方法，可以采用继承汽车类来共享这些属性与方法，实现代码的复用。 继承的好处 父类中定义过的类成员不用再子类中重复定义，子类可以直接通过 $this-&gt; 调用父类成员，节省了编程时间。 同一个父类的子类拥有和父类相同的类成员，因此外部代码调用它们的时候可以一视同仁。 子类可以修改和调整父类定义过的成员，即实现重写。最终执行的是子类重写后的成员。PHP 中只能单继承而不能像 C++ / Python 可以多重继承。 封装体现封装性的地方有： 访问控制 public： 可以被类自身、子类、其他类、以及类实例化后的对象访问。 protected： 可以被类自身、子类访问。 private： 只能被父类成员访问。但是可以被可以访问它的类中公共成员函数向外提供一个可以 访问的接口。 接口类是对象的抽象，接口是类的抽象，因此接口其实也是一种抽象类。 接口不能够用于实例化对象。一个类中如过实现了某个接口，那么该类必须实现接口中定义的方法，而接口中不能够具体实现定义的方法。举例说明： 1234interface InterfaceName&#123; public function func($parameter);&#125; 那么如果一个类被告知要实现该接口，就必须实现 func 方法： 1234567class A implements InterfaceName&#123; public function func($parameter) &#123; // do something &#125;&#125; 如何判断某个对象是否实现了某个接口？1var_dump($obj instanceof InterfaceName); 一个接口能继承另一个接口吗？能。但是因此实现该接口的类必须实现子接口和父接口中的所有方法。 抽象类面向对象中的传统抽象类是抽象程度介于接口和类之间的一种表示形态。即抽象类中，部分方法可以实现，部分方法也可以不被实现而让子类去实现。 举例说明： 12345678910111213141516abstract class AbstractClassName&#123; abstract public function func1($parameter); public function func2() &#123; // do something &#125;&#125;class ClassName extends AbstractClassName&#123; // func1 必须被子类实现 func2 不必 public function func1($parameter ) &#123; // do something here &#125;&#125; 抽象类存在的必要性接口中某些方法可能部分对于实现它的类来说都是一样的，而部分又是体 现多态性的，因此对于实现该接口的所有类来说，就算所有类的某个方法本质都是一样的，也 必须实现该方法，因为该方法在接口中定义过了，这样如果实现该接口的类很多，重复的代码 量也就越大。 所以，如果把许多类都具备的方法都实现在接口中，那么将减少很多多余的编码工作，但为了不改变接口出现的概念和意义，因此在面向对象程序设计中，应时出现了抽象类 这一概念，完美地解决了这一问题。 抽象类中，abstract 修饰过的方法就必须被继承该抽象类的子类所实现，而其他方法直接在抽象类中实现。抽象类的定义也需要使用 abstract class 关键字修饰。 多态多态的表现 接口的方法可以被不同的类根据具体需求不同地实现。 父类的方法可以被子类重写以实现不同的功能。 同一个函数名可以根据参数的不同而表现不同的功能。 举例说明：123456789101112131415161718192021222324252627282930interface I&#123; public function foo($v);&#125;class A implements I&#123; public function foo($v) &#123; // do something a &#125;&#125;class B implements I&#123; public function foo($v) &#123; // do something b &#125;&#125;function func($obj)&#123; if( $obj instanceof I ) &#123; $obj -&gt; foo( 'v' ); &#125; else &#123; // do something &#125;&#125;$a = new A();$b = new B();func( $a );func( $b ); 在上面这段代码中，函数 func() 通过传入的参数不同，执行不同的动作，这就体现了多态。 抽象程度根据上面的讨论可得：对象 -&gt; 类 -&gt; 抽象类 -&gt; 接口，抽象程度逐渐上升。 类的属性在类中定义的变量称之为属性，属性声明是由关键字 public，protected 或者 private 开头，后面跟一个普通的变量声明来组成。属性的变量可以设置初始化的默认值，默认值必须是常量。 如何访问成员？成员分为属性和方法。 类属性类型默认都为 public，外部可以访问。一般通过 -&gt; 对象操作符来访问对象的属性或者方法。对于静态属性则使用 :: 双冒号进行访问。当在类成员方法内部调用的时候，可以使用 $this 伪变量调用当前对象的属性。 $this 是 PHP 等语言中的伪变量，表示对象自身。类中可以通过 $this-&gt;member，$this-&gt;fun()来调用类成员。但是 member 和 fun()前面不能有 $。 类方法方法就是在类中的 function，很多时候我们分不清方法与函数有什么差别， 在面向过程的程序设计中function 叫做函数， 在面向对象中 function 则被称之为方法。 同属性一样，类的方法也具有 public，protected 以及 private 的访问控制。使用关键字 static 修饰的，称之为静态方法，静态方法不需要实例化对象，可以通过类名直接调用，操作符为双冒号 ::。 12345678class Car&#123; public static function getName() &#123; return 'Car'; &#125;&#125;echo Car::getName(); 构造函数PHP5 可以在类中使用 __construct() 定义一个构造函数，具有构造函数的类，会在每次对象创 建的时候调用该函数，因此常用来在对象创建的时候进行一些初始化工作。在子类中如果定义了 __construct() 则不会调用父类的 __construct()，如果需要同时调用父类的构造函数，需要使用 parent::__construct() 显式的调用。 12345678910111213141516class Car&#123; public function __construct() &#123; print \"父类构造函数被调用\\n\"; &#125;&#125;class Truck extends Car&#123; publich function __construct() &#123; print \"子类构造函数被调用\\n\"; parent::__construct(); &#125;&#125;$car = new Truck(); 析构函数同样，PHP5 支持析构函数，使用 __destruct() 进行定义，析构函数指的是当某个对象的所有引用被删除，或者对象被显式的销毁时会执行的函数。析构函数的作用：用于释放某些资源。 1234567891011121314class Car&#123; public function __construct() &#123; print \"构造函数被调用 \\n\"; &#125; public function __destruct() &#123; print \"析构函数被调用 \\n\"; &#125;&#125;$car = new Car(); // 实例化时会调用构造函数echo '使用后，准备销毁car对象 \\n';unset($car); // 销毁时会调用析构函数 同构造函数，如果不认为指定，将执行默认的析构函数。如果人为指定了，则覆盖默认方法。 但是析构函数的触发条件有两个： 程序执行结束，系统自动调用析构函数 当对象不再被使用时，比如赋值为 null 时。但更精确的说法是：当对象不再被某个变量所引用时，就会自动调用析构函数。 或者说，对象没有任何变量引用时和程序运行结束时，就会触发析构函数。 当 PHP 代码执行完毕以后，会自动回收与销毁对象，因此一般情况下不需要显式的去销毁对象。 对象引用引用和指针作用很类似。都是指向某个地址，比如指向对象的话，那么就指向堆中的某个地址。 &amp;如果不用引用，那么如果把对象赋值给另一个变量时，对原变量的改变不会影响另一个变量，所以也不会影响到这个对象，即两个变量代表两个不同的地址，即具有拷贝属性。 如果使用对象引用，同样的情况发生时，无论是对哪个变量的改变都是对同一个对象的改变。即两个变量指向的都是同一个对象在内存中的地址。 举例说明： 不使用引用 123$a = new C();$b = $a;$a = null; 此时对象的析构函数不会自动调用，因为还有 $b 指向该对象。 使用引用 123$a = new C();$b = &amp;$a;$a = null; 此时对象的析构函数便会自动调用。 综上，如果 $a = $b，那么从内存上来看，$a 和 $b 是两块不同的内存地址空间，即 $a 和 $b 是不同的两个引用。而如果 $a = &amp;$b，那么 $a 和 &amp;$b 代表的都是同一块内存空间，即 $a 和 $b 是同一个引用。 数据访问修饰符访问控制通过关键字 public，protected 和 private 来实现。 被定义为公有的类成员可以在任何地方被访问。 被定义为受保护的类成员则可以被其自身以及其子类和父类访问。 被定义为私有的 类成员则只能被其定义所在的类访问。 类属性必须定义为公有、受保护、私有之一。为兼容 PHP5 以前的版本，如果采用 var 定义，则被视为公有 类中的方法可以被定义为公有、私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 123456789class Car&#123; $speed = 10; // 错误 属性必须定义访问控制 // 正确（但是不规范） function getSpeed() &#123; return $this-&gt;$speed; &#125;&#125; 如果构造函数定义成了私有方法，则不允许直接实例化对象了，这时候一般通过静态方法进行实例化，在设计模式中会经常使用这样的方法来控制对象的创建，比如单例模式只允许有一个全局唯一的对象。 1234567891011121314151617class Car&#123; private function __construct() &#123; echo 'object create'; &#125; private static $_object = null; public static function getInstance() &#123; if (empty(self::$_object)) &#123; self::$_object = new Car(); // 内部方法可以调用私有方法，因此这里可以创建对象 &#125; return self::$_object; &#125;&#125;// $car = new Car(); // 错误 这里不允许直接实例化对象$car = Car::getInstance(); // 正确 通过静态方法来获得一个实例 如何在子类中访问被子类重写过的方法？如果被 overwrite 的方法名为 func，则可以使用 parent::func(); 的形式来显示地调用被重写的父类方法。 如何在类中访问 const 修饰过的成员？12const CONST_V = 1024;self::CONST_V; 注意： const 修饰的变量名前不需要写 $。 $this 的使用场合$this-&gt; 可用于在类中访问非 static 修饰的类成员。 $this-&gt;member 中的 member 前面不需要 $ 而 self:: 和 static:: 需要 。 static 关键字静态属性与方法可以在不实例化类的情况下调用，直接使用 类名::方法名 的方式进行调用。静态属性不允许对象使用 -&gt; 操作符调用。 static 关键字在 OOP 中有什么用？为了共用类中一些共有的相同成员属性或者方法，同时保存类的共有数据。 如何在类中定义 static 成员？static 放在访问控制符之后，即应该是如下形式：12345private static $member;public static function foo()&#123; // ...&#125; 如何访问类中 static 修饰的成员？类中被 static 修饰的成员不受类实例化的限制，即无论在哪里都可以直接访问。 类中访问自身 static 成员类中访问自身 static 成员属性是用 self::$member 或者 static::$member (注意 $ )。 类中访问自身 static 成员方法是用 self::func() 或者 static::func()。 类外访问 static 成员 静态成员不需要实例化对象就可以访问。 类外访问 static 成员属性是用 ClassName::$member_name (注意 $ )。 类外访问 static 成员方法是用 ClassName::func_name()。 子类中访问父类中的 static 成员 子类中访问父类的 static 成员属性是用 parent::$member_name。(注意 $ ) 子类中访问父类的 static 成员方法是用 parent::func_name() 动态调用静态方法静态方法也可以通过变量来进行动态调用。 123$func = 'getSpeed';$className = 'Car';echo $className::$func(); // 动态调用静态方法 静态方法中可以访问非静态属性吗？不能。静态方法里面只能访问静态属性。 $this 可以访问静态成员吗？不能。静态方法中，$this 伪变量不允许使用。可以使用 self，parent，static在内部调用静态方法与属性。 12345678910111213141516171819class Car&#123; private static $speed = 10; public static function getSpeed() &#123; return self::$speed; &#125; public static function speedUp() &#123; return self::$speed+=10; &#125;&#125;class BigCar extends Car&#123; public static function start() &#123; parent::speedUp(); &#125;&#125; 由于 $this 的使用必须是在对象上下文环境中。所以不能出现这种用法： 1234public static function func()&#123; $this-&gt;member;&#125; final 关键字为什么需要 final 关键字?为了避免子类重写父类方法或者为了避免类被继承。 使用 final 举例： 1234567891011// 类 ClassName 不能被继承final class ClassName&#123; // do something&#125;// 方法 fun 不能被重写final public function fun()&#123; // do something&#125; 魔术方法魔术方法是 PHP 特有的 ( 其他语言也有类似的实现 ) ，在某些情境下会触发而被自动调用的方法。 “魔术” 二字可以大概的有种不可能的事情欺骗了我们的双眼而成为现实的感觉。 总之，魔术方法可以将看似不能完成的事情实现的作用。 construct 和 destruct()对象创建时 和 对象销毁/程序结束时 自动调用。 __toString()当对象被当作 String 使用时自动调用。比如：echo (new A());。 __invoke()当对象被当作方法调用时自动调用。比如：$obj($parameter); call() 和 callStatic()当对象调用类中不存在的方法或静态方法时自动调用。 这两个方法在 PHP 中也被叫做方法的重载 ( overload )。它们的定义类似： 1??? 其中 $name 代表的是被调用的那个不存在的方法名；$argvs 是一个数组，保存了调用该不存在的方法的时候传入的形参列表。 call() 和 callStatic() 有什么用？可以实现已一种 PHP 传统语法无法定义的方式去定义一个具有多态性的方法。 因为同一个函数名的调用却可以因为不同的调用方式完成不同的功能。举例说明： 1234567891011121314class A&#123; public function __call($name, $argvs) &#123; // do something &#125; public static function __callStatic($name, $argvs) &#123; // do something &#125;&#125;$a = new A();$a -&gt; test();$a :: test(); 可以看出，通过 __call() 和 __callStatic()，就像调用了已经存在于类中的方法一样。 同时，又实现了以普通 PHP 语法无法实现的：同时定义一个同名的 static 方法和非 static 方法，完成不同的功能，这也体现了多态。 __get() / __set() / __isset() / __unset()这 4 个方法在 PHP 中被称为属性重载的魔术方法。 __get()： 读取不可访问属性时自动调用。 __set()： 在给不可访问属性赋值时自动调用。 __isset() : 在对不可访问属性调用 isset() 或者 empty() 时自动调用。可以通过自定义 __isset() 方法决定不同的返回值。 __unset() : 在对不可访问属性调用 __unset() 时自动调用。 __get() 和 __set() 有什么用？可以动态地给类中添加/访问原本不存在的属性。 比如可以将该不可访问属性通过一定的方法保存在类中，如预定义的空数组。 以上 4 个方法可以灵活地操作类中原本不存在的数据以实现某些需求。 什么是不可访问属性？属性不存在或者不具备访问权限。 __clone()对象复制时候自动调用。作用是屏蔽不想被复制的属性或者对对象副本进行属性的初始化等操作。 举例说明： 123456789101112131415class A&#123; public $property; public function __clone() &#123; // do something $this-&gt;property = 'temp'; &#125;&#125;$a0 = new A();$a0 -&gt; property = 'value0';$a1 = clone $a0 ;echo\"Beforesetting: $a1-&gt;property= \", $a1-&gt;property;$a1 -&gt; property = 'value1';echo\"Aftersetting: $a1-&gt;property= \", $a1-&gt;property; 说明： clone 的出现是为了解决通过引用或者变量赋值的方式不能真正复制对象的不足。指向对象的引用或 者变量代表的仅仅是对象在内存中的存放位置。 重载PHP 中的重载指的是动态的创建属性与方法，是通过魔术方法来实现的。 属性的重载属性的重载通过 __set()，__get()，__isset()，__unset() 来分别实现对不存在属性的赋值、读取、判断属性是否设置、销毁属性。 1234567891011121314151617181920212223242526class Car&#123; private $ary = array(); public function __set($key, $val) &#123; $this-&gt;ary[$key] = $val; &#125; public function __get($key) &#123; if (isset($this-&gt;ary[$key])) &#123; return $this-&gt;ary[$key]; &#125; return null; &#125; public function __isset($key) &#123; if (isset($this-&gt;ary[$key])) &#123; return true; &#125; return false; &#125; public function __unset($key) &#123; unset($this-&gt;ary[$key]); &#125;&#125;$car = new Car();$car-&gt;name = '汽车'; // name属性动态创建并赋值echo $car-&gt;name; 方法的重载方法的重载通过 __call() 来实现，当调用不存在的方法的时候，将会转为参数调用 __call() 方法，当调用不存在的静态方法时会使用 __callStatic() 重载。 123456789101112class Car &#123; public $speed = 0; public function __call($name, $args) &#123; if ($name == 'speedUp') &#123; $this-&gt;speed += 10; &#125; &#125;&#125;$car = new Car();$car-&gt;speedUp(); // 调用不存在的方法会使用重载echo $car-&gt;speed; 如何理解重载？可以通过“重定向”这一概念来理解。 重定向指的是原本要请求某个 URL 时，由于源资源不存在或者其他原因，服务器返回的却是另一个 URL 的资源。 方法重载指的是原本要访问某个成员方法的时候，由于方法不存在或其他原因，PHP 解析引擎实际调用的却是另一个方法。 属性重载指的是原本要访问的某个成员属性，由于不存在或者其他原因，实际是通过相应的魔术方法完成对类中不存在的成员属性进行的相关操作，就相当于类中有该属性，并相当于在操作类中存在的属性。 对象的高级特性对象比较当同一个类的两个实例的所有属性都相等时，可以使用比较运算符 == 进行判断，当需要判断两个变量是否为同一个对象的引用时，可以使用全等运算符 === 进行判断。 12345class Car &#123;&#125;$a = new Car();$b = new Car();if ($a == $b) echo '=='; // trueif ($a === $b) echo '==='; // false 对象复制在一些特殊情况下，可以通过关键字 clone 来复制一个对象，这时 __clone 方法会被调用，通过这个魔术方法来设置属性的值。 12345678910111213class Car&#123; public $name = 'car'; public function __clone() &#123; $obj = new Car(); $obj-&gt;name = $this-&gt;name; &#125;&#125;$a = new Car();$a-&gt;name = 'new car';$b = clone $a;var_dump($b); 对象序列化可以通过 serialize 方法将对象序列化为字符串，用于存储或者传递数据，然后在需要的时候通过 unserialize 将字符串反序列化成对象进行使用。 123456789class Car&#123; public $name = 'car';&#125;$a = new Car();$str = serialize($a); // 对象序列化成字符串echo $str, PHP_EOL;$b = unserialize($str); // 反序列化为对象print_r($b); 数据库PHP 支持哪些数据库PHP 通过安装相应的扩展来实现数据库操作，现代应用程序的设计离不开数据库的应用，当前主流的数据库 有 MsSQL，MySQL，Sybase，DB2，Oracle，PostgreSQL，Access 等，这些数据库 PHP 都能够安装扩展来支持。 一般情况下常说的 LNMPA 架构指的是：Linux、Nginx、MySQL、PHP、Apache，因此 MySQL 数据库在 PHP 中的应用非常广泛。 数据库扩展PHP 中一个数据库可能有一个或者多个扩展，其中既有官方的，也有第三方提供的。 像 MySQL 常用的扩展有原生的 mysql 库（新版本已弃用），也可以使用增强版 的 mysqli 扩展，还可以使用 PDO 进行连接与操作。不同的扩展提供基本相近的操作方法，不同的是可能具备一些新特性，以及操作性能可能会有所不同。 举例，判断 mysql 数据库扩展是否已经安装： 123if (function_exists('mysql_connect')) &#123; echo 'mysql 扩展已经安装';&#125; PDO PDO （PHP Data Object）是个当前 PHP 操作数据库的主要操作扩展。也建议必须掌握这个的使用。 why ?为了完成相同的功能，PHP 在操作不同的数据库的时候需要使用不同的 API，维护和升级不同数据库的时候变得更繁琐。 what ?PDO 是数据库访问抽象层，统一各种数据库的访问接口。具有如下特性： 编码一致性PDO 提供操作各种数据库的统一接口。 灵活性PDO 在运行时会加载数据库驱动程序，而不需要在每次使用不同的数据库时再去配置和编译 PHP。 高性能PDO 使用 C 语言写的，编译为 PHP。 OOP 特性PDO 是一个抽象接口，利用 PDO 本身并不能实现对数据库的操作。还需要具体的实现方式 PDO 支持的所有数据库见：http://php.net/manual/zh/pdo.drivers.php。 DSNData Source Name：驱动:主机名;数据库。 how ?启用和配置 PDO 扩展123451. 配置 php.ini 开启相应的扩展extension = php_pdo.dll2. 开启相应的数据库扩展，如 MySQLextension = php_pdo_mysql.dll3. 重启 php-fpm(nginx) 或者 apahce 其余操作详见手册：PHP 数据对象。 和 mysqli/mysql 对比PDO 连接 MySQL 的效率和插入数据比 mysql/mysqli 低，但是插入数据的效率没有连接数据库差别那么大。 mysql &amp;&amp; mysqlimysqli 扩展与 mysql 扩展的区别mysql 和 mysqli 都是 PHP 操作 MySQL 数据库的扩展，mysqli 是mysql 的扩展版本，两者 API 命名上的差别基本上只是一个 i，因此，掌握 mysqli 就掌握了 mysql。 对于 4.0.1 版本后的 MySQL，mysql 扩展对其新特性的支持不好，PHP5 之后官方推荐使用 mysqli 和 PDO 方式来操作 MySQL。 mysqli 相对于 mysql 扩展的优点： 支持两种编程风格：面向对象和面对过程 支持预处理语句 支持事务 速度比 MySQL 扩展快 安全性提高 支持 MySQL 的新特性 配置 mysqli 开启 php_mysqli.dll 扩展：php.ini 中取消 php_mysqli.dll 前面的注释。 配置 extension_dir=：指定到 ext 目录的实际路径。 重启服务器后测试 1234phpinfo();var_dump(extension_loaded('mysqli'));var_dump(function_exists('mysqli_connect'));print_r(get_loaded_extensions()); mysqli 基本使用PHP 对扩展的使用基本上都有 2 种方式：面向对象和面向过程，mysqli 也不例外，详见手册。 关于 SQL 操作方法的返回值 select / desc / describe / show / explain 等执行成功返回 mysqli_result 对象，失败返回 false。 其他 SQL 语句执行成功返回 true，执行失败返回 false。 基本步骤连接、选择数据库123456$mysqli = new mysqli( $host, $user, $passwd, $db ) ;// 也可以通过 mysql_select_db 在连接成功手动选择数据库mysqli_select_db('db_name');if( $mysqli-&gt;connect_errno ) &#123; die( $mysqli-&gt;connect_error ) ;&#125; 设置客户端默认字符集／编码方式1$myslqi-&gt;set_charset('utf8'); // not `utf-8` 执行 SQL 语句，根据情况对执行结果进行处理123456789$res = $mysqli-&gt;query( $sql ) ;// 这里的重点还是 SQL 语句和对结果集的处理if( $res &amp;&amp; $res-&gt;num_rows&gt;0 ) &#123; // $res-&gt;fetch_assoc() ; // 默认抓取结果集中的一个由关联数组和索引数组组成的二维数组 // $res-&gt; fetch_all( MYSQL_ASSOC ) ; while( $row = $res-&gt;fetch_assoc() ) &#123; $rows = $row ; &#125;&#125; 默认的，PHP 使用最近的数据库连接执行查询，但如果存在多个连接的情况，则可以通过参数指令从那个连接中进行查询。 1234$link1 = mysql_connect('127.0.0.1', 'code1', '');$link2 = mysql_connect('127.0.0.1', 'code1', '', true); // 开启一个新的连接$res = mysql_query('select * from user limit 1', $link1); // 从第一个连接中查询数据 关闭连接当数据库操作完成以后，可以使用 mysql_close 关闭数据库连接。 默认的，当 PHP 执行完毕以后，会自动的关闭数据库连接，一般情况下已经满足需求，但是在对性能要求比较高的情况下，可以在进行完数据库操作之后尽快关闭数据库连接，以节省资源，提高性能。 1mysqli_close(); 在存在多个数据库连接的情况下，可以设定连接资源参数来关闭指定的数据库连接。 12$link = mysql_connect($host, $user, $pass);mysql_close($link); mysqli 多语句查询插入多条语句需要把需要执行的 SQL 语句用分号分开。 1234$sql = \"select ... ;\" ;$sql .= \"update ...;\" ;$sql .= \"delete from ...\" ;$mysqli -&gt; multi_query( $sql ) ; 第一条 SQL 语句执行的成功与否影响了 mutlti_query() 的返回值，第一条执行成功，后面的不论执行失败与否该方法都返回 true。 每条 SQL 语句如果执行成功都会返回一个结果集。 use_result() / store_result()： 获取第一条查询产生的结果集 more_results()： 检测是否有更多的结果集 next_result()： 将结果集指针移动到下一个结果集。 举例说明： 123456789if ($mysqli-&gt;multi_query($sql)) &#123; do &#123; if ($mysqli_result = $mysqli-&gt;store_result()) &#123; $rows[] = $mysqli_result-&gt;fetch_assoc() ; &#125; &#125; while ($mysqli-&gt;more_results() &amp;&amp; $mysqli-&gt;next_result()) ;&#125; else &#123; $myslqli-&gt;error ;&#125; mysqli 方法／函数1234567$mysqli-&gt;connect_error$mysqli-&gt;connect_errno$mysqli-&gt;client_info$mysqli-&gt;client_version$mysqli-&gt;get_server_info()$mysqli-&gt;insert_id() // 得到上一次操作产生的 AUTO_INCREMENT 的值$mysqli-&gt;affected_rows() // 得到上一次操作产生的受影响的条数 affected_rows() 的返回值说明 -1 代表 SQL 语句有问题、 0 代表没有受影响记录的条数 其余情况下为受影响的记录条数 结果集处理123456789$res-&gt;fetch_all( MYSQLI_NUM/MYSQLI_ASSOC/MYSQLI_BOTH )$res-&gt;fetch_row() // 返回的是索引数组，取得的是结果集中的第一条记录作为索引数组返回$res-&gt;fetch_assoc() // 返回的是关联数组，取得的是结果集中的第一条记录作为关联数组返回，每 fetch/关联 一次，结果集中的指针就下移一位，当指针指向的最后一条后返回 false$res-&gt;fetch_array() // 上面二者都有，也可以和 fetch_all 一样限定返回类型$res-&gt;fetch_object() ; // 返回对象$res-&gt;data_seek( 2 ) ; // 移动结果集内部指针$res-&gt;close() ; // 释放结果集$res-&gt;free();$res-&gt;free_result() ; mysqli 预处理语句mysqli 使用预处理语句需要通过在 SQL 语句借助 占位符? 实现。 举例说明: 12345678910111213141516171819202122$sql = \"insert user( user, passwd, age ) values( ?, ?, ? )\" ;# 准备预处理语句$mysqli_stmt = $mysqli-&gt;prepare( $sql ) ;$user = '' ;$passed = '' ;$age = '' ;# 绑定参数:s 代表字符串;i 代表整型;d 代表浮点数$mysqli_stmt = bind_param( 'ssi', $user, $passed, $age ) ;# 执行预处理语句if( $mysqli_stmt -&gt; execute() ) &#123;echo $mysqli_stmt-&gt;insert_id ;echo '&lt;br&gt;' ;&#125; else &#123; echo $mysqli_stmt -&gt; error ;&#125;# 释放结果集$mysqli_stmt -&gt; free_result() ;# 关闭预处理语句$mysqli_stmt -&gt; close ();# 关闭连接$mysqli -&gt; close() ; 使用预处理语句防止 SQL 注入 不用预处理的 SQL 注入现象 12345678910$user = $_POST[ 'user' ] ;$passwd = md5( $_POST[ 'passwd' ] ) ;$sql = \"select * from user where username='&#123;$user&#125;' andpasswd='&#123;$passwd&#125;'\" ;$res = $mysqli-&gt;query( $sql ) ;if( $res &amp;&amp; $res-&gt;num_rows &gt; 0 ) &#123; echo '登录成功' ;&#125; else &#123; echo '登录失败' ;&#125; 此时如果在页面传递的是 &#39; or 1=1 #那么 SQL 注入是成功的。 使用预处理后防止 SQL 注入成功 12345678910$sql = \"select * from user where username=? and passwd=?\" ;$stmt = $mysqli-&gt;prepare( $sql ) ;if( $stmt-&gt;execute() ) &#123; $stmt -&gt; store_result() ; if( $stmt-&gt;num_rows&gt;0 ) &#123; echo '登录成功' ; &#125; else &#123; echo '登录失败' ; &#125;&#125; 使用预处理语句执行查询操作1234567891011121314151617$sql = \"select id, user, age from user where id&gt;=?\" ;$id = 20 ;$mysql_stmt -&gt; bind_param( 'i', $id ) ;if( $mysqli_stmt -&gt; execute() ) &#123; # 绑定结果集中的值到变量 $mysqli_stmt-&gt;bind_result( $id, $user, $age ) ; while( $mysqli_stmt -&gt; fetch() ) &#123; // do something &#125;&#125;$mysqli_stmt -&gt; free_result() ;$mysqli_stmt -&gt; close() ;$mysqli-&gt;close() ; mysqli 操作事务 数据准备 1234567create table account( id tinyint unsigned auto_increment primary key, username varchar(20) not null unique, money float( 6,2 ));insert account(user, money)values('test', 100), ('tset', 100); PHP 代码 12345678910111213141516171819202122# 关闭自动提交功能$mysqli-&gt;autocommit( FALSE ) ;$sql0 = \"update account set money=money-200 where user='test'\" ;$res0 = $mysqli-&gt;query( $sql0 ) ;$res0affect = $mysqli-&gt;affected_rows ;$sql1 = \"update account set money=money-200 where user='tset'\" ;$res1 = $mysqli-&gt;query( $sql1 ) ;$res1affect = $mysqli-&gt;affected_rows ;if( $res0 &amp;&amp; $res0affect&gt;0 &amp;&amp; res1 &amp;&amp; res1affect&gt;0) &#123; $mysqli-&gt;commit(); echo '转账成功' ; # 恢复自动提交功能 $mysqli-&gt;autocommit( true );&#125; else &#123; $mysqli-&gt;rollback() ; echo '转账失败' ;&#125;$mysqli-&gt;close(); 其他myslqi_select_db() 与 mysqli::select_db()面向对象风格和面向过程风格在对函数的使用方式上是不同的。 如果采用面向对象的使用方式，那么要使用某个对象的方法，如果该方法不是静态方法， 则都需要先实例化一个 mysqli 对象，然后通过该对象调用类中的方法。 所以如果直接使用 mysqli:select_db() 就会出现不存在该静态方法的错误提示。 如果采用面向过程的使用方式，按照手册，则必须要有 2 个参数：第一个参数是 MySQL 链 接的资源描述符。即应该这么使用： 12$link = mysqli( $host, $user, $pwd ) ;mysqli_select_db( $link, $db_name ) ; 基本函数的使用和解释4 大 fetch 函数解释 mysqli_fetch_row() 每执行一次 mysqli_fetch_row() 函数，就从返回的结果集中取出一条( 行 - row )数据，并保存在一个一维索引数组中。 可以使用循环打印出结果集中的查询到的所有数 据: 1234$res = mysqli_query( $link, $sql ) ;while( $row = mysqli_fetch_row( $res ) ) &#123; print_r( $row ) ;&#125; 这里刚开始可能会有点迷惑:为什么没有类似 i++ 的参数控制循环自己却正确地运行呢? 可以理解为 mysqli_fetch_xxx() 函数自带了这种判断，即没执行一次该函数后， 下一次执行该函数时，自动去取下一条数据，就像自增长的指针一样。如果返回值为 空，则说明查询语句的结果数据已经全部取完。 mysqli_fetch_array() mysqli_fetch_array() 与 mysqli_fetch_row() 有相同之处，但是不同之处在于： mysqli_fetch_row() 取一条数据产生的是一个索引数组，保存的是数据库中字段 对应的值。 mysqli_fetch_array() 取一条数据默认返回的结果是一个索引数组和一个关联数组，其中索引数组中保持的也是数据库表中字段对应的值，关联数组中保存的就是数据库中字段的键名。有了关联数组，想要查询结果集中的某个数据，就可以 直接通过 $arr[ ‘key’ ] 的形式来直接获取了。 不难看出，mysqli_fetch_array() 的执行速度比 mysqli_fetch_row() 慢很多，但是可以在执行 mysqli_fetch_array() 时带一些额外的参数让其执行更具体的操作，从而提高效率： 123`MYSQL_ASSOC`：返回关联数组`MYSQL_BOTH`：和默认状态的结果是一样的`MYSQL_NUM`：返回数字数组(索引数组) mysql_fetch_assoc() 从结果集中获得一个关联数组。和 mysqli_fetch_array( $res, MYSQL_ASSOC ) 的执 行结果是完全一样的。 mysql_fetch_object() 从结果集中获得一个对象。因此要按照对象的规矩来取数据。 举例说明： 12345$res = mysqli_fetch_object( $sql ) ;print_r( $res ) ;echo $res -&gt; key; 其他函数 mysqli_num_rows() 返回结果集中的个/行数;可以用于当结果集为空的时候避 免下一步操作造成的资源浪费。 mysqli_result( $res, int $row_no, [int $offset | string $field_name] ) 返 回结果集的值，可以直接 echo。$res 是结果集的地址，$row_no 是行号，第三个参 数要么是偏移量 $offset 要么是字段名$field_name。 Start 和 offset 的下标都从 0 开始。 mysqli_affected_rows( $link ) 返回前一句增删改 SQL 中受到影响的行数。这 里的参数是链接描述符而不是结果集地址。 索引数组和关联数组区别在于对数组内元素的访问方式不一样： 索引数组：$arr[ index ]，其中 index 是整数。 关联数组：$arr[ &quot;key&quot; ]，其中 key 是关联数组中键值对中的键名。 分页查询通过循环可以获取一个查询的所有数据，在实际应用中，我们并不希望一次性获取数据表中的所有数据，那样性能会非常的低，因此会使用翻页功能，比如每页仅显示 10 条或者 20 条数据。 通过 mysql 的 limit 可以很容易的实现分页，limit m,n 表示从 m 行后取 n 行数据，在 PHP 中我们需要构造 m 与 n 来实现获取某一页的所有数据。假定当前页为 $page，每页显示 $n 条数据，那么 m 为当前页前面所有的 数据，即 $m = ($page-1) * $n ，在知道了翻页原理以后，那么我们很容易通过构造 SQL 语句在 PHP 中实现数据翻页。 12345678910$page = 2;$n = 2;$m = ($page - 1) * $n;$sql = \"select * from user limit $m, $n\";$result = mysqli_query($sql);$data = array();// 循环获取当前页的数据while ($row = mysqli_fetch_assoc($result)) &#123; $data[] = $row;&#125; 这里使用了 $m 与 $n 变量来表示偏移量与每页数据条数，但我们推荐使用更有意义的变量名来表示，比如$pagesize, $start, $offset 等，这样更容易理解，有助于团队协作开发。 正则表达式正则表达式是对字符串进行操作的一种逻辑公式，就是用一些特定的字符组合成一个规则字符串，称之为正则匹配模式。 12345$p = '/apple/';$str = \"apple banna\";if (preg_match($p, $str)) &#123; echo 'matched';&#125; 其中，/apple/ 就是一个正则表达式，他用来匹配源字符串是否存在 apple 字符串。 PCREPHP 中使用 PCRE 库函数进行正则匹配，比如上例中的 preg_match 用于 执行一个正则匹配，常用来判断一类字符模式是否存在。 使用正则表达式的目的是为了实现比字符串处理函数更加灵活的处理方式，因此跟字符串处理函数一样，其主要用来判断子字符串是否存在、字符串替换、分割字符串、获取模式子串等。 PHP 使用 PCRE 库函数来进行正则处理，通过设定好模式，然后调用相关 的处理函数来取得匹配结果。preg_match 用来执行一个匹配，可以简单的用来判断模式是否匹配成 功，或者取得一个匹配结果，他的返回值是匹配成功的次数 0 或者 1，在匹配到 1 次以后就会停止搜索。 正则表达式的基本语法PCRE 库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线 (/)、hash符号(#) 以及取反符号(~)，例如: 123/foo bar/#^[^0-9]$#~php~ 如果模式中包含分隔符，则分隔符需要使用反斜杠()进行转义：http:\\/\\/。 如果模式中包含较多的分割字符，建议更换其他的字符作为分隔符，或用 preg_quote 进行转义。 123$p = 'http://';$p = '/'.preg_quote($p, '/').'/';echo $p; 分隔符后面可以使用模式修饰符，模式修饰符包括：i, m, s, x 等，例如使用 i 修饰符可以忽略大小写匹配。 1234$str = 'Http://www.imooc.com/';if (preg_match('/http/i', $str)) &#123; echo '匹配成功';&#125; 元字符与转义正则表达式中具有特殊含义的字符称之为元字符，常用的元字符有： 1234567891011121314\\ 一般用于转义字符^ 断言目标的开始位置(或在多行模式下是行首)$ 断言目标的结束位置(或在多行模式下是行尾). 匹配除换行符外的任何字符(默认)[ 开始字符类定义] 结束字符类定义| 开始一个可选分支( 子组的开始标记) 子组的结束标记? 作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪 特性。 (查阅量词)* 量词，0 次或多次匹配+ 量词，1 次或多次匹配&#123; 自定义量词开始标记&#125; 自定义量词结束标记 下面的 \\s 匹配任意的空白符，包括空格，制表符，换行符。 [^\\s]代表非空白符。[^\\s]+ 表示一次或多次匹配非空白符。 12345$p = '/^我\\s+(苹果|香蕉)$/';$str = '我喜欢吃苹果';if (preg_match($p, $str)) &#123; echo '匹配成功';&#125; 元字符具有两种使用场景，一种是可以在任何地方都能使用，另一种是只能在方括号内使用。 在方括号内使用的有： \\：转义字符 ^：仅在作为第一个字符(方括号内)时，表明字符类取反 -：标记字符范围 其中 ^ 在反括号外面，表示断言目标的开始位置，但在方括号内部则代表字符类取反，方括号内的减号 - 可以标记字符范围，例如 0-9 表示 0 到 9 之 间的所有数字。 1234$p = '/[\\w\\.\\-]+@[a-z0-9\\-]+\\.(com|cn)/';$str = '我的邮箱是 code0809@163.com';preg_match($p, $str, $match);echo $match[0]; 贪婪模式与懒惰模式正则表达式中每个元字符匹配一个字符，当使用 + 之后将会变的贪婪，它将匹配尽可能多的字符，但使用问号 ? 字符时，它将尽可能少的匹配字符，即是懒惰模式。 懒惰模式：在可匹配与可不匹配的时候，优先不匹配。 1234$p = '/\\d?\\-\\d?/';$str = \"我的电话是010-12345678\";preg_match($p, $str, $match);echo $match[0]; //结果为:0-1 贪婪模式：在可匹配与可不匹配的时候，优先匹配。 1234$p = '/\\d+-\\d+/';$str = '我的电话是 010-12345678';preg_match($p, $str, $match);echo $match[0]; // 结果为: 010-12345678 当我们确切的知道所匹配的字符长度的时候，可以使用 {} 指定匹配字符数： 1234$p = '/\\d&#123;3&#125;-\\d&#123;8&#125;/';$str = \"我的电话是010-12345678\";preg_match($p, $str, $match);echo $match[0]; // 结果为: 010-12345678 查找所有匹配结果preg_match 只能匹配一次结果，但很多时候我们需要匹配所有的结果，preg_match_all 可以循环获取一个列表的匹配结果数组。 1234$p = '|&lt;&gt;+&gt;(.*?)&lt;/&gt;+&gt;|i';$str = \"&lt;b&gt;example: &lt;/b&gt;&lt;div align=left&gt;this is a test&lt;/div&gt;\";preg_match_all($p, $str, $matches);print_r($matches); 使用 preg_match_all 匹配一个表格中的数据： 1234$p = '/&lt;tr&gt;&lt;td&gt;(.?)&lt;\\/td&gt;\\s&lt;td&gt;(.?)&lt;\\/td&gt;\\s&lt;\\/tr&gt;/i';$str = '&lt;table&gt; &lt;tr&gt;&lt;td&gt;Eric&lt;/td&gt;&lt;td&gt;25&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;John&lt;/td&gt;&lt;td&gt;26&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;';preg_match_all($p, $str, $matches);print_r($matches); $matches 结果排序为 $matches[0] 保存完整模式的所有匹配，$matches[1] 保存第一个子组的所有匹配，以此类推。 正则表达式的搜索和替换正则表达式的搜索与替换在某些方面具有重要用途，比如调整目标字符串的格式，改变目标字符串中匹配字符串的顺序等。例如我们可以简单的调整字符串的日期格式： 1234$string = 'April 15, 2014';$pattern = '/(\\w+) (\\d+), (\\d+)/i';$replacement = '$3, $&#123;1&#125; $2';echo preg_replace($pattern, $replacement, $string); // 结果为: 2014, April 15 其中 ${1} 与 $1 的写法是等效的，表示第一个匹配的字串，$2 代表第二个 匹配的。 通过复杂的模式，我们可以更加精确的替换目标字符串的内容。 1234$patterns = array ('/(19|20)(\\d&#123;2&#125;)-(\\d&#123;1,2&#125;)-(\\d&#123;1,2&#125;)/', '/^\\s*&#123;(\\w+)&#125;\\s*=/');$replace = array ('\\3/\\4/\\1\\2', '$\\1 ='); // \\3等效于$3,\\4等效于$4，依次类推echo preg_replace($patterns, $replace, '&#123;startDate&#125; = 1999-5-27');// 结果为: $startDate = 5/27/1999 详细解释下结果：(19|20) 表示取 19 或者 20 中任意一个数字，(\\d{2}) 表 示两个数字，(\\d{1,2}) 表示 1 个或 2 个数字，(\\d{1,2}) 表示 1 个或 2 个数 字。 ^\\s*{(\\w+)\\s*=} 表示以任意空格开头的，并且包含在 {} 中的字符， 并且以任意空格结尾的，最后有个 = 号的。 查找并替换举例12345// 将目标字符串 $str 中的文件名替换后增加 em 标签$str = '主要有以下几个文件:index.php, style.css, common.js';$p='/\\w+\\.\\w+/i';$str=preg_replace($p,'&lt;em&gt;$0&lt;/em&gt;',$str);echo $str; 用正则替换来去掉多余的空格与字符123$str = 'one two';$str = preg_replace('/\\s+/', ' ', $str);echo $str; // 结果改变为'one two' 用户信息验证12345678910111213141516171819202122232425262728293031&lt;?php$user = array( 'name' =&gt; 'spark1985', 'email' =&gt; 'spark@imooc.com', 'mobile' =&gt; '13312345678',);// 进行一般性验证if (empty($user)) &#123; die('用户信息不能为空');&#125;if (mb_strlen($user['name']) &lt; 6) &#123; die('用户名长度最少为6位');&#125;// 用户名必须为字母、数字与下划线if (!preg_match('/^\\w+$/i', $user['name'])) &#123; die('用户名不合法');&#125;// 验证邮箱格式是否正确if (!preg_match('/^[\\w\\.]+@\\w+\\.\\w+$/i', $user['email'])) &#123; die('邮箱不合法');&#125;// 手机号必须为 11 位数字 且为 1 开头if (!preg_match('/^1\\d&#123;10&#125;$/i', $user['mobile'])) &#123; die('手机号不合法');&#125;echo '用户信息验证成功'; 然后 PHP 中不要优先使用正则正则的缺点： 逻辑复杂，易出错 效率低 能用 PHP 自身字符串 API 完成的，就不要使用正则。 信息加密技术分类单项散列加密单项散列加密是指通过对不同输入长度的信息进行计算，得到固定长度的输出，输入相同计算结果相同。 但是，这个散列计算过程是单向的，即不能对固定长度的输出进行计算反过来的到原始输入信息。 此类算法的流程只有一步：明文+单向散列算法+salt = 得到密文。（不可逆） 盐（Salt），在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。 对称散列加密对称加密是指加密和解密使用的密钥是同一个，或者可以互相推算。 明文+加密算法+salt = 密文 密文+解密算法+密钥 = 明文 非对称散列加密非对称加密和解密使用的密钥不是同一个，而是由算法生成的一对。 其中一个对外公开，被称作公钥，另一个私钥，只有所有者知道。 明文+加密算法+加密密钥 = 密文 密文+解密算法+密钥 = 明文 数字签名就是一种非对称散列加密技术常见的应用。 PHP 内置的编码/加密/hash APImd5md5 是简单单向加密过程，但是也可以通过字典和彩虹表来查询（猜测）获得( 通过遍历 事先保存过的一些常见的加密后的字符串，按查找的方式破解)。 因此，可以通过多次 md5() 加密来获得不常见的加密字符串在一定程度上提高难度：md5(md5($str, true))。 当第二个参数为 true 时，返回的是 16 字节的原始二进制格式。 cryptstring crypt(string $str, [string $salt]) 返回基于标准 UNIX DES 算法或系统上其它可用的替代算法的散列字符串。 $salt 就是所谓的盐值，也就是干扰串。有效长度只能有 2 个。 sha1和 md5() 使用相似，sha1 也是单项不可逆加密算法。（都可以通过碰撞穷举来获得原始字符串） url 编码 urlencode() 除了 -/_/. 之外的所有非字母和数字都将被替换成百分号 % 后跟两位十六进制数，空格则编码为 +。 可以编码一些特殊字符然后用于传递 很多搜索引擎采用了这种“加密”方式。 rawurlencode() 按照 RFC1738 对 URL 进行编码。和 urlencode() 的唯一区别就是，空格会被编码为 %20。 base64 编码base64 最早用于电子邮件，因为早期的邮件网关只能识别 ASCII 码，其他字符将会被过滤。 把非 ASCII 字符( 中文/图片 )使用 base64 转换成 ASCII 字符传输，接收到后在进行转码即可，base64 适合在在 HTTP/MIME 协议中快速传输数据。 base64 也可以被用于编码/解码二进制数据(图片等)，严格地讲，base64 只是一种编码方式，而不是加密算法。 base64 保存一张图片123456789101112$img = base64_encode(file_get_contents('a.jpg'));// #1header('Content-Type: image/jpeg');echo base64_decode($img);// #2$data = &lt;&lt;&lt; IMG &lt;img src=\"data:;base64, &#123;$img&#125;\"&gt; &lt;img src=\"data:image/jpeg;base64, &#123;$img&#125;\"&gt;IMG;echo $data; 数制补码正数的原码和补码相同。 负数的补码 = 原码的反码+1。 补码给计算机看，原码给人看。 位运算 算术左移低位溢出符号位不变，用符号位补溢出的高位。 算术右移相当于每移一位乘以2 符号位不变，低位补零。 小算法打印金字塔 直角三角形 12345678/* 直角三角形 */# 外层的 for 循环控制层数for ($i=1; $i&lt;=10; ++$i)&#123; # 内层控制每层 * 号的个数 for ($j=1; $j&lt;=$i; ++$j) echo '*'; echo \"\\n\";&#125; 实心金字塔 123456789/* 实心金字塔 */for ($i=1; $i&lt;=5; ++$i) &#123; # 在打印 * 号前先打印空格 for ($k=1; $k&lt;=5-$i; ++$k) echo ' '; for ($j=1; $j&lt;=($i-1)*2+1; ++$j) echo '*'; echo \"\\n\";&#125; 空心金字塔 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 空心金字塔 */# Tips =&gt; 在给每行输出 `*` 号的时候 要判断改输出 `*` 号还是空格$n = 10; // 金字塔层数for ($i=1; $i&lt;=$n; ++$i) &#123; # 在打印 * 号前先打印空格 for ($k=1; $k&lt;=$n-$i; ++$k) echo ' '; # 内层控制每层 * 号的个数 for($j=1; $j&lt;=($i-1)*2+1; ++$j)&#123; # 如果是第一层和最后一层 只输出 * 号 echo ($i==1 || $i==$n) ? '*' : ( ($j==1 || $j==($i-1)*2+1) ? '*' : ' ' ); &#125; echo \"\\n\";&#125;// OR// 打印空心三角形function printOpenTriangle($n = 10) &#123; for ($i=0; $i&lt;$n; ++$i) &#123; // print space - step 1 for ($j=0; $j&lt;$n-$i; ++$j) &#123; echo ' '; &#125; // print asterisk if ($i==0 or $i==$n-1) &#123; for ($k=0; $k&lt;=2*$i; ++$k) &#123; echo '*'; &#125; &#125; else &#123; echo '*'; // print space - step 2 for ($m=0; $m&lt;=2*$i-2; ++$m) &#123; echo ' '; &#125; echo '*'; &#125; // print newline echo PHP_EOL; &#125;&#125; 打印九九乘法表123456/* 99乘法表 */for ($i=1; $i&lt;=9; ++$i) &#123; for ($j=1; $j&lt;=$i; ++$j) echo $i, 'x', $j, '=', $i*$j, ' '; echo \"\\n\";&#125; 编程经验如何看懂一段代码？郝斌 每条语句的功能 程序流程 试数 韩顺平 代码执行顺序图 内存变化图 界面变化图 程序流程图 语句，真假，条件选择等 如何理解递归？从堆栈的角度一个函数执行对应一个独立的栈空间，不管是不是同一个函数。 递归调用时，将一层层开辟堆栈，到底了后再一层层返回值。 从内存的角度变量按地址思考就不会混淆，地址是变量内容的直接索引 。 写代码的步骤？ 明确「需求」 弄懂自己「要做什么」 清晰「流程」 实战经验 死去活来，先写死的测试功能再写活的完善界面和功能。 数据库是项目的核心 写操作的设计的开始 面向接口开发，如果有依赖，则优先制定出依赖间的接口 比如：数据存储格式、JSON API 返回格式 FAQoverride / overwrite / overload 的区别？Overload 重载在 C++ 程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数不同(包括类型、顺序不同)，即函数重载。 相同的范围(在同一个类中) 函数名字相同 参数不同 请注意，重载解析中不考虑返回类型，而且在不同的作用域里声明的函数也不算是重载。 Override 覆盖是指派生类函数覆盖基类函数，特征是： 不同的范围(分别位于派生类与基类) 函数名字相同 参数相同 基类函数必须有virtual 关键字 Overwrite 重写是指派生类的函数屏蔽了与其同名的基类函数，规则如下： 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 virtual 关键字，基类的函数将被隐藏。 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有 virtual 关键字。 此时，基类的函数被隐藏(注意别与覆盖混淆)。 self 和 static两者的差别主要体现在有继承关系的类之间。 简单下个结论： 当在类中使用 self:: 时，无论是否有继承关系，最终引用到的都是这个 self 单词所在的类。 当在类中使用 static:: 时，如果有继承关系，则最终引用到的是子类。 12345678910111213class A &#123; public static function get_A() &#123; // return new self(); return __CLASS__; &#125; public static function get_me() &#123; return new static(); &#125;&#125;class B extends A &#123;&#125;echo get_class(B::get_A()); // Aecho get_class(B::get_me()); // Becho get_class(A::get_me()); // A suggestion：后期静态绑定( PHP 5.3.0+)。 后期静态绑定本想通过引入一个新的关键字表示运行时最初调用的类来绕过限制。简单地说，这个关键字能够让你在上述例子中调用 B::get_me() 时引用的类是 B 而不是 A。最终决定不引入新的关键字，而是使用已经预留的 static 关键字。 static 其实和任何类对象没有必然的联系 STATIC variable are not associated to any particular instance/object of a class. Hence you modify the variable with Parent Class reference or Child Class reference, the same copy gets modified. Hence apart from understanding Public Static as Global, Please understand it as not associated to any particular instance, hence with any class hierarchy reference you update a static variable , same memory location gets updated. 为什么可以使用 :: 调用非静态方法 This is actually an error of some kind if you have strict error reporting on, but not otherwise. 除此之外，PHP 还有其他怪癖行为（比如对象可以使用 -&gt; 调用静态方法），因 PHP 语法松散而保留。但是，请避免使用它们。 参考 PHP 笔记汇总 What is the difference between self::$bar and static::$bar in PHP? [duplicate] php static property Calling non static method with “::” PHP: What if I call a static method in non-static way when using self, parent, static and how?","categories":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.caoxl.com/tags/PHP/"}]},{"title":"Hexo  开发记录","slug":"Hexo-Dev-Notes","date":"2017-12-30T03:42:50.000Z","updated":"2019-02-21T03:45:39.000Z","comments":true,"path":"2017/12/30/Hexo-Dev-Notes/","link":"","permalink":"http://blog.caoxl.com/2017/12/30/Hexo-Dev-Notes/","excerpt":"使用Hexo记录学习与生活中一些事情 一键部署12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 准备工作 开发必备 安装Node.js 安装Git","text":"使用Hexo记录学习与生活中一些事情 一键部署12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 准备工作 开发必备 安装Node.js 安装Git 安装Node.js Linux/Mac cURL: 1curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: 1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1nvm install stable Windows 直接下载 安装Git Windows: 下载并安装 git; Mac: 使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装 Linux (Ubuntu, Debian): sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS): sudo yum install git-core 本地测试12345678910111213141516171819# 下载 Hexonpm install -g hexonpm install -g hexo-cli# 创建 Hexo 博客目录mkdir hexo# 进入 Hexo 博客目录并初始化 Hexo 博客站点cd hexohexo init# 安装依赖npm install# 生成静态博客文件hexo generate# 运行 Hexo 服务hexo server 此时，在浏览器中输入 localhost:4000 就可以看到一个默认的 Hexo 博客了。 如何启动多个博客? 1hexo s -p 8888 // 端口号自己设置 部署到远程服务器1、配置部署参数在 hexo/_config.yml 中找到 Deployment，然后添加如下内容： 123456# Deployment 站点部署到github配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:SoulMate94/SoulMate94.github.io.git branch: master 其中，仓库地址需要灵活修改，仓库分支固定是 gitcafe-pages，可见 GitCafe 和 GitHub 也是一样都提供免费的 Pages 服务。 说明 这里为了防止后面在部署博客的时候重复输入用户名和密码，这里必须填写 SSH 协议而不是 HTTPS 的仓库地址，而且事先必须为部署的 Git 远程仓库服务配置好 SSH 密钥。 2、部署到 Github首先，在 Github 注册账户并创建项目。需要注意的是，项目名和用户名要一致，并且要创建公开项目而不是私有项目。然后运行： 1234567hexo generate# 安装 hexo-deployer-gitnpm install hexo-deployer-git --save# 开始部署到远程服务器hexo deploy 新建、更新、预览、同步你的博客1234hexo n 'name'hexo ghexo shexo d 说明 每次修改本地文件后，都需要运行 hexo generate 才能使最新改动生效，每次执行命令时，都要在站点根目录下，即是站点配置文件 _config.yml 所在的目录 ( 不是主题配置文件 )。 发布文章123456git add -A # 这里可根据自己情况添加文件git commit -m \"adding\" # 这里的注释灵活填写git push alias master # 这里的远程仓库别名和分支根据自己情况填写hexo clean # 为了防止部署上次的博客内容建议先清除再重新生成hexo ghexo d 简单操作: hexo g &amp;&amp; hexo d 配置 主题首先当然也是先下载 Hiker 主题源码到 Hexo 博客的 themes 文件夹下面，即 themes/next/，Hexo 博客的所有主题都放到 themes 文件夹下。 123456789101112131.从GitHub上获取代码 git clone https://github.com/iTimeTraveler/hexo-theme-hiker.git themes/hiker2. 把Hexo主目录下的 _config.yml 文件中的字段 theme 修改为 hiker.# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#theme: landscapetheme: hexo-theme-hiker3. 更新cd themes/Hikergit pull 然后，对 Hexo 的配置主要就是配置根目录下的 _config.yml 文件，称作 站点配置文件 。 而对 Hiker 以及其他 Hexo 主题的配置主要就是配置主题所在文件夹下的 _config.yml 文件，称作 主题配置文件。 网站图标在 themes/next/source 文件夹下放一个你事先准备好的 favicon.ico就行了。 侧边栏头像在 themes/next/source/images 文件夹下放一个你事先准备好的 default_avatar.jpg 就行了。 此外，还可以放置 avatar.jpg，然后通过 /uploads/avatar.jpg 来引用。 或者在 themes/next/source/images 文件夹下新建一个 uploads 目录，里面存放 avatar.jpg，然后通过 /uploads/avatar.jpg 来引用。 编辑站点配置文件，新增字段 avatar，其值设置将成为头像的链接地址。 如果想要头像显示圆角效果，需要找到 layout/_macro/sidebar.swig，然后搜索 site-author-image，在这个 &lt;img&gt; 标签中加上 style=&quot;border-radius:100%;&quot; 即可。 简体中文Hexo 博客搭建好后默认是繁体，可以通过配置站点配置文件中的 language 为 zh-CN 即可。 侧边栏社交链接编辑 站点配置文件，新增字段 social，然后添加社交站点名称与地址即可。例如： 1234# Social linkssocial: GitHub: https://github.com/SoulMate94 Google+: https://plus.google.com/110046839213865610992 摘要只需在 Hiker 主题配置文件中启用摘要和配置摘要的字数： 1234# Automatically Excerptauto_excerpt: enable: true length: 150 此外，除了自动截取指定字数的文字作为文章摘要，还有种方式就是在写文章中使用 标签，代表的意思就是其前面的完整内容将作为摘要。 这样比自动截取摘要有个好处就是不会出现 … 。 注意 如果采用的是自动截取摘要，则尽量不要使用代码段作为文章开头，否则博客首页将比较难看，手机端效果也很差。 扩展 全局搜索 npm install –save hexo-generator-search 1234_config.yml添加search: path: search.xml field: post 如果报错: –save 放置最后 FAQ怎么创建标签云页面 ?1、新建一个页面12# 命名为 tagshexo new page \"tags\" 2、设置页面头信息编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下：1234title: TagClouddate: 2016-01-24 11:44:35type: \"tags\"--- 远程部署不成功 ? Git npm install hexo-deployer-git --save Heroku npm install hexo-deployer-heroku --save Rsync npm install hexo-deployer-rsync --save OpenShift npm install hexo-deployer-openshift --save FTPSync npm install hexo-deployer-ftpsync --save 部署到Github 每次发布都出现404 ?在source文件夹下创建CNAME文件 1存放域名: blog.caoxl.com REDEME.md同上 Hiker 主题下的 文章目录不能滑动 找到 themes/hexo-theme-hiker/source/css/_partial/article.styl 或者 全局搜索.toc-fixed 找到以下代码修改即可: 1234567.toc-fixed position: fixed; top: 30px; margin-top: 0; max-height: 97%; overflow: scroll; z-index: 1; 修改 max-height 和 overflow 即可 附录：Hexo 常用命令1234567hexo chean # 删除 public 目录hexo g &lt;=&gt; hexo generatehexo d &lt;=&gt; hexo deployhexo s &lt;=&gt; hexo serverhexo server -p 4444 # 更改 Hexo 服务器端口hexo server -i 192.168.1.1 # 更改 Hexo 服务器 IPhexo n &lt;=&gt; hexo new 参考 Hexo 文档 Hexo 常见问题 Hexo 常见问题解决方案","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.caoxl.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://blog.caoxl.com/tags/博客/"}]}]}